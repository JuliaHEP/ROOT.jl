// this file was auto-generated by wrapit v1.8.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {

  template<typename Element>
  struct BuildParameterList<TVectorT<Element>>
  {
    typedef ParameterList<Element> type;
  };

  template<typename Element> struct IsMirroredType<TVectorT<Element>> : std::false_type { };
  template<typename Element> struct DefaultConstructible<TVectorT<Element>> : std::false_type { };
}

// Class generating the wrapper for type TVectorT
// signature to use in the veto file: TVectorT
struct JlTVectorT: public Wrapper {

  JlTVectorT(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TVectorT (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TVectorDfwd.h:22:31
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TVectorT");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
    auto t26_decl_methods = [this]<typename Element> (jlcxx::TypeWrapper<TVectorT<Element>> wrapped){
      auto module_ = this->module_;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes      );
    };
    t.apply<TVectorT<double>>(t26_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlTVectorT(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTVectorT(module));
}

namespace jlcxx {

  template<unsigned int N>
  struct BuildParameterList<RByteSwap<N>>
  {
    typedef ParameterList<std::integral_constant<unsigned int, N>> type;
  };

  template<unsigned int N> struct IsMirroredType<RByteSwap<N>> : std::false_type { };
  template<unsigned int N> struct DefaultConstructible<RByteSwap<N>> : std::false_type { };
}

// Class generating the wrapper for type RByteSwap
// signature to use in the veto file: RByteSwap
struct JlRByteSwap: public Wrapper {

  JlRByteSwap(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type RByteSwap (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Byteswap.h:124:8
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("RByteSwap");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
    auto t30_decl_methods = [this]<unsigned int N> (jlcxx::TypeWrapper<RByteSwap<N>> wrapped){
      auto module_ = this->module_;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes      );
    };
    t.apply<RByteSwap<2>, RByteSwap<4>, RByteSwap<8>>(t30_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlRByteSwap(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlRByteSwap(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TIterator> : std::false_type { };
  template<> struct DefaultConstructible<TIterator> : std::false_type { };
}

// Class generating the wrapper for type TIterator
// signature to use in the veto file: TIterator
struct JlTIterator: public Wrapper {

  JlTIterator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TIterator (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:30:7
    jlcxx::TypeWrapper<TIterator>  t = jlModule.add_type<TIterator>("TIterator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TIterator>>(new jlcxx::TypeWrapper<TIterator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for TIterator & TIterator::operator=(const TIterator &) (" __HERE__ ")");
    // signature to use in the veto list: TIterator & TIterator::operator=(const TIterator &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:37:23
    t.method("assign", [](TIterator& a, const TIterator & arg0)->TIterator & { return a.operator=(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));
    t.method("assign", [](TIterator* a, const TIterator & arg0)->TIterator & { return a->operator=(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));

    DEBUG_MSG("Adding wrapper for const TCollection * TIterator::GetCollection() (" __HERE__ ")");
    // signature to use in the veto list: const TCollection * TIterator::GetCollection()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:39:31
    t.method("GetCollection", [](TIterator const& a)->const TCollection * { return a.GetCollection(); }, jlcxx::arg("this"));
    t.method("GetCollection", [](TIterator const* a)->const TCollection * { return a->GetCollection(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for Option_t * TIterator::GetOption() (" __HERE__ ")");
    // signature to use in the veto list: Option_t * TIterator::GetOption()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:40:22
    t.method("GetOption", [](TIterator const& a) { return (std::string)a.GetOption(); }, jlcxx::arg("this"));
    t.method("GetOption", [](TIterator const* a) { return (std::string)a->GetOption(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for TObject * TIterator::Next() (" __HERE__ ")");
    // signature to use in the veto list: TObject * TIterator::Next()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:41:22
    t.method("Next", [](TIterator& a)->TObject * { return a.Next(); }, jlcxx::arg("this"));
    t.method("Next", [](TIterator* a)->TObject * { return a->Next(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for void TIterator::Reset() (" __HERE__ ")");
    // signature to use in the veto list: void TIterator::Reset()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:42:22
    t.method("Reset", [](TIterator& a)->void { a.Reset(); }, jlcxx::arg("this"));
    t.method("Reset", [](TIterator* a)->void { a->Reset(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for TObject * TIterator::operator()() (" __HERE__ ")");
    // signature to use in the veto list: TObject * TIterator::operator()()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:43:22
    t.method("paren", [](TIterator& a)->TObject * { return a.operator()(); }, jlcxx::arg("this"));
    t.method("paren", [](TIterator* a)->TObject * { return a->operator()(); }, jlcxx::arg("this"));
    module_.set_override_module(jl_base_module);

    DEBUG_MSG("Adding wrapper for Bool_t TIterator::operator!=(const TIterator &) (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TIterator::operator!=(const TIterator &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:44:22
    t.method("!=", [](TIterator const& a, const TIterator & arg0) { return (bool)a.operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));
    t.method("!=", [](TIterator const* a, const TIterator & arg0) { return (bool)a->operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));

    DEBUG_MSG("Adding wrapper for Bool_t TIterator::operator==(const TIterator &) (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TIterator::operator==(const TIterator &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:45:22
    t.method("==", [](TIterator const& a, const TIterator & arg0) { return (bool)a.operator==(arg0); }, jlcxx::arg("this"), jlcxx::arg("other"));
    t.method("==", [](TIterator const* a, const TIterator & arg0) { return (bool)a->operator==(arg0); }, jlcxx::arg("this"), jlcxx::arg("other"));

    DEBUG_MSG("Adding wrapper for TObject * TIterator::operator*() (" __HERE__ ")");
    // signature to use in the veto list: TObject * TIterator::operator*()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TIterator.h:46:22
    t.method("getindex", [](TIterator const& a)->TObject * { return a.operator*(); }, jlcxx::arg("this"));
    t.method("getindex", [](TIterator const* a)->TObject * { return a->operator*(); }, jlcxx::arg("this"));

    module_.unset_override_module();

    DEBUG_MSG("Adding wrapper for Version_t TIterator::Class_Version() (" __HERE__ ")");
    // signature to use in the veto list: Version_t TIterator::Class_Version()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:293:68
    module_.method("TIterator!Class_Version", []() { return (int16_t)TIterator::Class_Version(); });

    DEBUG_MSG("Adding wrapper for TClass * TIterator::IsA() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TIterator::IsA()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:294:76
    t.method("IsA", [](TIterator const& a)->TClass * { return a.IsA(); }, jlcxx::arg("this"));
    t.method("IsA", [](TIterator const* a)->TClass * { return a->IsA(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for void TIterator::StreamerNVirtual(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TIterator::StreamerNVirtual(TBuffer &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:300:9
    t.method("StreamerNVirtual", [](TIterator& a, TBuffer & arg0)->void { a.StreamerNVirtual(arg0); }, jlcxx::arg("this"), jlcxx::arg("ClassDef_StreamerNVirtual_b"));
    t.method("StreamerNVirtual", [](TIterator* a, TBuffer & arg0)->void { a->StreamerNVirtual(arg0); }, jlcxx::arg("this"), jlcxx::arg("ClassDef_StreamerNVirtual_b"));

    DEBUG_MSG("Adding wrapper for const char * TIterator::DeclFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TIterator::DeclFileName()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:301:88
    module_.method("TIterator!DeclFileName", []() { return (std::string)TIterator::DeclFileName(); });

    DEBUG_MSG("Adding wrapper for int TIterator::ImplFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TIterator::ImplFileLine()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:309:55
    module_.method("TIterator!ImplFileLine", []()->int { return TIterator::ImplFileLine(); });

    DEBUG_MSG("Adding wrapper for const char * TIterator::ImplFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TIterator::ImplFileName()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:310:63
    module_.method("TIterator!ImplFileName", []() { return (std::string)TIterator::ImplFileName(); });

    DEBUG_MSG("Adding wrapper for const char * TIterator::Class_Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * TIterator::Class_Name()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:311:57
    module_.method("TIterator!Class_Name", []() { return (std::string)TIterator::Class_Name(); });

    DEBUG_MSG("Adding wrapper for TClass * TIterator::Dictionary() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TIterator::Dictionary()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:312:47
    module_.method("TIterator!Dictionary", []()->TClass * { return TIterator::Dictionary(); });

    DEBUG_MSG("Adding wrapper for TClass * TIterator::Class() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TIterator::Class()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:313:63
    module_.method("TIterator!Class", []()->TClass * { return TIterator::Class(); });

    DEBUG_MSG("Adding wrapper for void TIterator::Streamer(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TIterator::Streamer(TBuffer &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:314:25
    t.method("Streamer", [](TIterator& a, TBuffer & arg0)->void { a.Streamer(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));
    t.method("Streamer", [](TIterator* a, TBuffer & arg0)->void { a->Streamer(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));

    DEBUG_MSG("Adding wrapper for int TIterator::DeclFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TIterator::DeclFileLine()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:339:43
    module_.method("TIterator!DeclFileLine", []()->int { return TIterator::DeclFileLine(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TIterator>> type_;
};
std::shared_ptr<Wrapper> newJlTIterator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTIterator(module));
}

// this file was auto-generated by wrapit v1.6.0-3-ga0c580f-dirty
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer3DTubeSeg> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer3DTubeSeg> : std::false_type { };
  template<> struct SuperType<TBuffer3DTubeSeg> { typedef TBuffer3DTube type; };
}

// Class generating the wrapper for type TBuffer3DTubeSeg
// signature to use in the veto file: TBuffer3DTubeSeg
struct JlTBuffer3DTubeSeg: public Wrapper {

  JlTBuffer3DTubeSeg(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer3DTubeSeg (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:184:7
    jlcxx::TypeWrapper<TBuffer3DTubeSeg>  t = jlModule.add_type<TBuffer3DTubeSeg>("TBuffer3DTubeSeg",
      jlcxx::julia_base_type<TBuffer3DTube>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer3DTubeSeg>>(new jlcxx::TypeWrapper<TBuffer3DTubeSeg>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );


    DEBUG_MSG("Adding wrapper for TBuffer3DTubeSeg::TBuffer3DTubeSeg(UInt_t, UInt_t, UInt_t, UInt_t, UInt_t, UInt_t) (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:198:4
    t.constructor<uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts")    );
    t.constructor<uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity")    );
    t.constructor<uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs")    );
    t.constructor<uint32_t, uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs"), jlcxx::arg("reqSegsCapacity")    );
    t.constructor<uint32_t, uint32_t, uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs"), jlcxx::arg("reqSegsCapacity"), jlcxx::arg("reqPols")    );
    t.constructor<uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs"), jlcxx::arg("reqSegsCapacity"), jlcxx::arg("reqPols"), jlcxx::arg("reqPolsCapacity")    );

    DEBUG_MSG("Adding fPhiMin methods  to provide read access to the field fPhiMin (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:203:13
    // signature to use in the veto list: TBuffer3DTubeSeg::fPhiMin
    t.method("fPhiMin", [](const TBuffer3DTubeSeg& a) -> Double_t { return a.fPhiMin; }, jlcxx::arg("this"));
    t.method("fPhiMin", [](TBuffer3DTubeSeg& a) -> Double_t { return a.fPhiMin; }, jlcxx::arg("this"));
    t.method("fPhiMin", [](const TBuffer3DTubeSeg* a) -> Double_t { return a->fPhiMin; }, jlcxx::arg("this"));
    t.method("fPhiMin", [](TBuffer3DTubeSeg* a) -> Double_t { return a->fPhiMin; }, jlcxx::arg("this"));
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:203:13
    // signature to use in the veto list: TBuffer3DTubeSeg::fPhiMin
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fPhiMin! methods to provide write access to the field fPhiMin (" __HERE__ ")");
    t.method("fPhiMin!", [](TBuffer3DTubeSeg& a, Double_t val) -> Double_t { return a.fPhiMin = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding fPhiMin! methods to provide write access to the field fPhiMin (" __HERE__ ")");
    t.method("fPhiMin!", [](TBuffer3DTubeSeg* a, Double_t val) -> Double_t { return a->fPhiMin = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding fPhiMax methods  to provide read access to the field fPhiMax (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:204:13
    // signature to use in the veto list: TBuffer3DTubeSeg::fPhiMax
    t.method("fPhiMax", [](const TBuffer3DTubeSeg& a) -> Double_t { return a.fPhiMax; }, jlcxx::arg("this"));
    t.method("fPhiMax", [](TBuffer3DTubeSeg& a) -> Double_t { return a.fPhiMax; }, jlcxx::arg("this"));
    t.method("fPhiMax", [](const TBuffer3DTubeSeg* a) -> Double_t { return a->fPhiMax; }, jlcxx::arg("this"));
    t.method("fPhiMax", [](TBuffer3DTubeSeg* a) -> Double_t { return a->fPhiMax; }, jlcxx::arg("this"));
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:204:13
    // signature to use in the veto list: TBuffer3DTubeSeg::fPhiMax
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fPhiMax! methods to provide write access to the field fPhiMax (" __HERE__ ")");
    t.method("fPhiMax!", [](TBuffer3DTubeSeg& a, Double_t val) -> Double_t { return a.fPhiMax = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding fPhiMax! methods to provide write access to the field fPhiMax (" __HERE__ ")");
    t.method("fPhiMax!", [](TBuffer3DTubeSeg* a, Double_t val) -> Double_t { return a->fPhiMax = val; }, jlcxx::arg("this"), jlcxx::arg("value"));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer3DTubeSeg>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer3DTubeSeg(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer3DTubeSeg(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer3DCutTube> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer3DCutTube> : std::false_type { };
  template<> struct SuperType<TBuffer3DCutTube> { typedef TBuffer3DTubeSeg type; };
}

// Class generating the wrapper for type TBuffer3DCutTube
// signature to use in the veto file: TBuffer3DCutTube
struct JlTBuffer3DCutTube: public Wrapper {

  JlTBuffer3DCutTube(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer3DCutTube (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:211:7
    jlcxx::TypeWrapper<TBuffer3DCutTube>  t = jlModule.add_type<TBuffer3DCutTube>("TBuffer3DCutTube",
      jlcxx::julia_base_type<TBuffer3DTubeSeg>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer3DCutTube>>(new jlcxx::TypeWrapper<TBuffer3DCutTube>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );


    DEBUG_MSG("Adding wrapper for TBuffer3DCutTube::TBuffer3DCutTube(UInt_t, UInt_t, UInt_t, UInt_t, UInt_t, UInt_t) (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3D.h:219:4
    t.constructor<uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts")    );
    t.constructor<uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity")    );
    t.constructor<uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs")    );
    t.constructor<uint32_t, uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs"), jlcxx::arg("reqSegsCapacity")    );
    t.constructor<uint32_t, uint32_t, uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs"), jlcxx::arg("reqSegsCapacity"), jlcxx::arg("reqPols")    );
    t.constructor<uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reqPnts"), jlcxx::arg("reqPntsCapacity"), jlcxx::arg("reqSegs"), jlcxx::arg("reqSegsCapacity"), jlcxx::arg("reqPols"), jlcxx::arg("reqPolsCapacity")    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer3DCutTube>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer3DCutTube(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer3DCutTube(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer3DTypes> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer3DTypes> : std::false_type { };
}

// Class generating the wrapper for type TBuffer3DTypes
// signature to use in the veto file: TBuffer3DTypes
struct JlTBuffer3DTypes: public Wrapper {

  JlTBuffer3DTypes(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer3DTypes (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TBuffer3DTypes.h:20:7
    jlcxx::TypeWrapper<TBuffer3DTypes>  t = jlModule.add_type<TBuffer3DTypes>("TBuffer3DTypes");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer3DTypes>>(new jlcxx::TypeWrapper<TBuffer3DTypes>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer3DTypes>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer3DTypes(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer3DTypes(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TObjArrayIter> : std::false_type { };
  template<> struct DefaultConstructible<TObjArrayIter> : std::false_type { };
  template<> struct SuperType<TObjArrayIter> { typedef TIterator type; };
}

// Class generating the wrapper for type TObjArrayIter
// signature to use in the veto file: TObjArrayIter
struct JlTObjArrayIter: public Wrapper {

  JlTObjArrayIter(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TObjArrayIter (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:117:7
    jlcxx::TypeWrapper<TObjArrayIter>  t = jlModule.add_type<TObjArrayIter>("TObjArrayIter",
      jlcxx::julia_base_type<TIterator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TObjArrayIter>>(new jlcxx::TypeWrapper<TObjArrayIter>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for TObjArrayIter::TObjArrayIter(const TObjArray *, Bool_t) (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:135:4
    t.constructor<const TObjArray *>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("arr")    );
    t.constructor<const TObjArray *, bool>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("arr"), jlcxx::arg("dir")    );


    DEBUG_MSG("Adding wrapper for TObjArrayIter::TObjArrayIter(const TObjArrayIter &) (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:136:4
    t.constructor<const TObjArrayIter &>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("iter")    );

    DEBUG_MSG("Adding wrapper for TIterator & TObjArrayIter::operator=(const TIterator &) (" __HERE__ ")");
    // signature to use in the veto list: TIterator & TObjArrayIter::operator=(const TIterator &)
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:138:19
    t.method("assign", [](TObjArrayIter& a, const TIterator & arg0)->TIterator & { return a.operator=(arg0); }, jlcxx::arg("this"), jlcxx::arg("rhs"));
    t.method("assign", [](TObjArrayIter* a, const TIterator & arg0)->TIterator & { return a->operator=(arg0); }, jlcxx::arg("this"), jlcxx::arg("rhs"));

    DEBUG_MSG("Adding wrapper for TObjArrayIter & TObjArrayIter::operator=(const TObjArrayIter &) (" __HERE__ ")");
    // signature to use in the veto list: TObjArrayIter & TObjArrayIter::operator=(const TObjArrayIter &)
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:139:19
    t.method("assign", [](TObjArrayIter& a, const TObjArrayIter & arg0)->TObjArrayIter & { return a.operator=(arg0); }, jlcxx::arg("this"), jlcxx::arg("rhs"));
    t.method("assign", [](TObjArrayIter* a, const TObjArrayIter & arg0)->TObjArrayIter & { return a->operator=(arg0); }, jlcxx::arg("this"), jlcxx::arg("rhs"));

    DEBUG_MSG("Adding wrapper for const TCollection * TObjArrayIter::GetCollection() (" __HERE__ ")");
    // signature to use in the veto list: const TCollection * TObjArrayIter::GetCollection()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:141:23
    t.method("GetCollection", [](TObjArrayIter const& a)->const TCollection * { return a.GetCollection(); }, jlcxx::arg("this"));
    t.method("GetCollection", [](TObjArrayIter const* a)->const TCollection * { return a->GetCollection(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for TObject * TObjArrayIter::Next() (" __HERE__ ")");
    // signature to use in the veto list: TObject * TObjArrayIter::Next()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:142:23
    t.method("Next", [](TObjArrayIter& a)->TObject * { return a.Next(); }, jlcxx::arg("this"));
    t.method("Next", [](TObjArrayIter* a)->TObject * { return a->Next(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for void TObjArrayIter::Reset() (" __HERE__ ")");
    // signature to use in the veto list: void TObjArrayIter::Reset()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:143:23
    t.method("Reset", [](TObjArrayIter& a)->void { a.Reset(); }, jlcxx::arg("this"));
    t.method("Reset", [](TObjArrayIter* a)->void { a->Reset(); }, jlcxx::arg("this"));
    module_.set_override_module(jl_base_module);

    DEBUG_MSG("Adding wrapper for Bool_t TObjArrayIter::operator!=(const TIterator &) (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TObjArrayIter::operator!=(const TIterator &)
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:144:23
    t.method("!=", [](TObjArrayIter const& a, const TIterator & arg0) { return (bool)a.operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("aIter"));
    t.method("!=", [](TObjArrayIter const* a, const TIterator & arg0) { return (bool)a->operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("aIter"));

    DEBUG_MSG("Adding wrapper for Bool_t TObjArrayIter::operator!=(const TObjArrayIter &) (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TObjArrayIter::operator!=(const TObjArrayIter &)
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:145:23
    t.method("!=", [](TObjArrayIter const& a, const TObjArrayIter & arg0) { return (bool)a.operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("aIter"));
    t.method("!=", [](TObjArrayIter const* a, const TObjArrayIter & arg0) { return (bool)a->operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("aIter"));

    DEBUG_MSG("Adding wrapper for TObject * TObjArrayIter::operator*() (" __HERE__ ")");
    // signature to use in the veto list: TObject * TObjArrayIter::operator*()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TObjArray.h:146:23
    t.method("getindex", [](TObjArrayIter const& a)->TObject * { return a.operator*(); }, jlcxx::arg("this"));
    t.method("getindex", [](TObjArrayIter const* a)->TObject * { return a->operator*(); }, jlcxx::arg("this"));

    module_.unset_override_module();

    DEBUG_MSG("Adding wrapper for Version_t TObjArrayIter::Class_Version() (" __HERE__ ")");
    // signature to use in the veto list: Version_t TObjArrayIter::Class_Version()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:293:68
    module_.method("TObjArrayIter!Class_Version", []() { return (int16_t)TObjArrayIter::Class_Version(); });

    DEBUG_MSG("Adding wrapper for TClass * TObjArrayIter::IsA() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TObjArrayIter::IsA()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:294:76
    t.method("IsA", [](TObjArrayIter const& a)->TClass * { return a.IsA(); }, jlcxx::arg("this"));
    t.method("IsA", [](TObjArrayIter const* a)->TClass * { return a->IsA(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for void TObjArrayIter::StreamerNVirtual(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TObjArrayIter::StreamerNVirtual(TBuffer &)
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:300:9
    t.method("StreamerNVirtual", [](TObjArrayIter& a, TBuffer & arg0)->void { a.StreamerNVirtual(arg0); }, jlcxx::arg("this"), jlcxx::arg("ClassDef_StreamerNVirtual_b"));
    t.method("StreamerNVirtual", [](TObjArrayIter* a, TBuffer & arg0)->void { a->StreamerNVirtual(arg0); }, jlcxx::arg("this"), jlcxx::arg("ClassDef_StreamerNVirtual_b"));

    DEBUG_MSG("Adding wrapper for const char * TObjArrayIter::DeclFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TObjArrayIter::DeclFileName()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:301:88
    module_.method("TObjArrayIter!DeclFileName", []() { return (std::string)TObjArrayIter::DeclFileName(); });

    DEBUG_MSG("Adding wrapper for int TObjArrayIter::ImplFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TObjArrayIter::ImplFileLine()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:309:55
    module_.method("TObjArrayIter!ImplFileLine", []()->int { return TObjArrayIter::ImplFileLine(); });

    DEBUG_MSG("Adding wrapper for const char * TObjArrayIter::ImplFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TObjArrayIter::ImplFileName()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:310:63
    module_.method("TObjArrayIter!ImplFileName", []() { return (std::string)TObjArrayIter::ImplFileName(); });

    DEBUG_MSG("Adding wrapper for const char * TObjArrayIter::Class_Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * TObjArrayIter::Class_Name()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:311:57
    module_.method("TObjArrayIter!Class_Name", []() { return (std::string)TObjArrayIter::Class_Name(); });

    DEBUG_MSG("Adding wrapper for TClass * TObjArrayIter::Dictionary() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TObjArrayIter::Dictionary()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:312:47
    module_.method("TObjArrayIter!Dictionary", []()->TClass * { return TObjArrayIter::Dictionary(); });

    DEBUG_MSG("Adding wrapper for TClass * TObjArrayIter::Class() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TObjArrayIter::Class()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:313:63
    module_.method("TObjArrayIter!Class", []()->TClass * { return TObjArrayIter::Class(); });

    DEBUG_MSG("Adding wrapper for void TObjArrayIter::Streamer(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TObjArrayIter::Streamer(TBuffer &)
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:314:25
    t.method("Streamer", [](TObjArrayIter& a, TBuffer & arg0)->void { a.Streamer(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));
    t.method("Streamer", [](TObjArrayIter* a, TBuffer & arg0)->void { a->Streamer(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));

    DEBUG_MSG("Adding wrapper for int TObjArrayIter::DeclFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TObjArrayIter::DeclFileLine()
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/Rtypes.h:343:43
    module_.method("TObjArrayIter!DeclFileLine", []()->int { return TObjArrayIter::DeclFileLine(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TObjArrayIter>> type_;
};
std::shared_ptr<Wrapper> newJlTObjArrayIter(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTObjArrayIter(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TVirtualStreamerInfo> : std::false_type { };
  template<> struct DefaultConstructible<TVirtualStreamerInfo> : std::false_type { };
  template<> struct SuperType<TVirtualStreamerInfo> { typedef TNamed type; };
}

// Class generating the wrapper for type TVirtualStreamerInfo
// signature to use in the veto file: TVirtualStreamerInfo
struct JlTVirtualStreamerInfo: public Wrapper {

  JlTVirtualStreamerInfo(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TVirtualStreamerInfo (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/TVirtualStreamerInfo.h:44:7
    jlcxx::TypeWrapper<TVirtualStreamerInfo>  t = jlModule.add_type<TVirtualStreamerInfo>("TVirtualStreamerInfo",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TVirtualStreamerInfo>>(new jlcxx::TypeWrapper<TVirtualStreamerInfo>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TVirtualStreamerInfo>> type_;
};
std::shared_ptr<Wrapper> newJlTVirtualStreamerInfo(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTVirtualStreamerInfo(module));
}

// this file was auto-generated by wrapit v1.3.2
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<TTreeReaderArray<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<TTreeReaderArray<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<TTreeReaderArray<T>> : std::false_type { };
}

// Class generating the wrapper for type TTreeReaderArray
// signature to use in the veto file: TTreeReaderArray
struct JlTTreeReaderArray: public Wrapper {

  JlTTreeReaderArray(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTreeReaderArray (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:75:30
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TTreeReaderArray");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    auto t132_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<TTreeReaderArray<T>> wrapped){
      auto module_ = this->module_;
      typedef TTreeReaderArray<T> WrappedType;


      DEBUG_MSG("Adding wrapper for void TTreeReaderArray::TTreeReaderArray<T>(TTreeReader &, const char *) (" __HERE__ ")");
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:202:4
      wrapped.template constructor<TTreeReader &, const char *>(/*finalize=*/true);

      DEBUG_MSG("Adding wrapper for T & TTreeReaderArray::At(std::size_t) (" __HERE__ ")");
      // signature to use in the veto list: T & TTreeReaderArray::At(std::size_t)
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:205:7
      wrapped.method("At", static_cast<T & (WrappedType::*)(std::size_t) >(&WrappedType::At));

      DEBUG_MSG("Adding wrapper for const T & TTreeReaderArray::At(std::size_t) (" __HERE__ ")");
      // signature to use in the veto list: const T & TTreeReaderArray::At(std::size_t)
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:206:13
      wrapped.method("At", static_cast<const T & (WrappedType::*)(std::size_t)  const>(&WrappedType::At));
      module_.set_override_module(jl_base_module);


      DEBUG_MSG("Adding setindex! method  to wrap T & TTreeReaderArray::operator[](std::size_t) (" __HERE__ ")");
// defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:207:7
      wrapped.method("setindex!",
        [](WrappedType& a, std::size_t i, T const & val){
        return a[i] = val;
      });

      DEBUG_MSG("Adding getindex method to wrap T & TTreeReaderArray::operator[](std::size_t) (" __HERE__ ")");
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:207:7
      wrapped.method("getindex",
        [](WrappedType& a, std::size_t i){
        return a[i];
      });


      module_.unset_override_module();
    };
    t.apply<TTreeReaderArray<double>, TTreeReaderArray<float>, TTreeReaderArray<unsigned long>, TTreeReaderArray<long>, TTreeReaderArray<unsigned int>, TTreeReaderArray<int>, TTreeReaderArray<unsigned short>, TTreeReaderArray<short>, TTreeReaderArray<unsigned char>, TTreeReaderArray<char>>(t132_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlTTreeReaderArray(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTreeReaderArray(module));
}

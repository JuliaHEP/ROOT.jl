// this file was auto-generated by wrapit v1.4.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TFileHandler> : std::false_type { };
  template<> struct DefaultConstructible<TFileHandler> : std::false_type { };
}

// Class generating the wrapper for type TFileHandler
// signature to use in the veto file: TFileHandler
struct JlTFileHandler: public Wrapper {

  JlTFileHandler(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TFileHandler (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TSysEvtHandler.h:65:7
    jlcxx::TypeWrapper<TFileHandler>  t = jlModule.add_type<TFileHandler>("TFileHandler");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TFileHandler>>(new jlcxx::TypeWrapper<TFileHandler>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TFileHandler>> type_;
};
std::shared_ptr<Wrapper> newJlTFileHandler(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTFileHandler(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TSignalHandler> : std::false_type { };
  template<> struct DefaultConstructible<TSignalHandler> : std::false_type { };
}

// Class generating the wrapper for type TSignalHandler
// signature to use in the veto file: TSignalHandler
struct JlTSignalHandler: public Wrapper {

  JlTSignalHandler(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TSignalHandler (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TSysEvtHandler.h:127:7
    jlcxx::TypeWrapper<TSignalHandler>  t = jlModule.add_type<TSignalHandler>("TSignalHandler");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TSignalHandler>>(new jlcxx::TypeWrapper<TSignalHandler>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TSignalHandler>> type_;
};
std::shared_ptr<Wrapper> newJlTSignalHandler(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTSignalHandler(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TStdExceptionHandler> : std::false_type { };
  template<> struct DefaultConstructible<TStdExceptionHandler> : std::false_type { };
}

// Class generating the wrapper for type TStdExceptionHandler
// signature to use in the veto file: TStdExceptionHandler
struct JlTStdExceptionHandler: public Wrapper {

  JlTStdExceptionHandler(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TStdExceptionHandler (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TSysEvtHandler.h:172:7
    jlcxx::TypeWrapper<TStdExceptionHandler>  t = jlModule.add_type<TStdExceptionHandler>("TStdExceptionHandler");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TStdExceptionHandler>>(new jlcxx::TypeWrapper<TStdExceptionHandler>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TStdExceptionHandler>> type_;
};
std::shared_ptr<Wrapper> newJlTStdExceptionHandler(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTStdExceptionHandler(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TTime> : std::false_type { };
  template<> struct DefaultConstructible<TTime> : std::false_type { };
}

// Class generating the wrapper for type TTime
// signature to use in the veto file: TTime
struct JlTTime: public Wrapper {

  JlTTime(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTime (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTime.h:27:7
    jlcxx::TypeWrapper<TTime>  t = jlModule.add_type<TTime>("TTime");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTime>>(new jlcxx::TypeWrapper<TTime>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTime>> type_;
};
std::shared_ptr<Wrapper> newJlTTime(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTime(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<FILE> : std::false_type { };
  template<> struct DefaultConstructible<FILE> : std::false_type { };
}

// Class generating the wrapper for type FILE
// signature to use in the veto file: FILE
struct JlFILE: public Wrapper {

  JlFILE(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type FILE (" __HERE__ ")");
    // defined in /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h:49:8
    jlcxx::TypeWrapper<FILE>  t = jlModule.add_type<FILE>("FILE");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<FILE>>(new jlcxx::TypeWrapper<FILE>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<FILE>> type_;
};
std::shared_ptr<Wrapper> newJlFILE(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlFILE(module));
}

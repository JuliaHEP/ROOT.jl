// this file was auto-generated by wrapit v1.6.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TDatime> : std::false_type { };
  template<> struct DefaultConstructible<TDatime> : std::false_type { };
}

// Class generating the wrapper for type TDatime
// signature to use in the veto file: TDatime
struct JlTDatime: public Wrapper {

  JlTDatime(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TDatime (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TDatime.h:37:7
    jlcxx::TypeWrapper<TDatime>  t = jlModule.add_type<TDatime>("TDatime");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TDatime>>(new jlcxx::TypeWrapper<TDatime>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TDatime>> type_;
};
std::shared_ptr<Wrapper> newJlTDatime(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTDatime(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TArray> : std::false_type { };
  template<> struct DefaultConstructible<TArray> : std::false_type { };
}

// Class generating the wrapper for type TArray
// signature to use in the veto file: TArray
struct JlTArray: public Wrapper {

  JlTArray(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TArray (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TArray.h:31:7
    jlcxx::TypeWrapper<TArray>  t = jlModule.add_type<TArray>("TArray");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TArray>>(new jlcxx::TypeWrapper<TArray>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TArray>> type_;
};
std::shared_ptr<Wrapper> newJlTArray(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTArray(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TArrayC> : std::false_type { };
  template<> struct DefaultConstructible<TArrayC> : std::false_type { };
template<> struct SuperType<TArrayC> { typedef TArray type; };
}

// Class generating the wrapper for type TArrayC
// signature to use in the veto file: TArrayC
struct JlTArrayC: public Wrapper {

  JlTArrayC(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TArrayC (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TArrayC.h:27:7
    jlcxx::TypeWrapper<TArrayC>  t = jlModule.add_type<TArrayC>("TArrayC",
      jlcxx::julia_base_type<TArray>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TArrayC>>(new jlcxx::TypeWrapper<TArrayC>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TArrayC>> type_;
};
std::shared_ptr<Wrapper> newJlTArrayC(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTArrayC(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TUrl> : std::false_type { };
  template<> struct DefaultConstructible<TUrl> : std::false_type { };
template<> struct SuperType<TUrl> { typedef TObject type; };
}

// Class generating the wrapper for type TUrl
// signature to use in the veto file: TUrl
struct JlTUrl: public Wrapper {

  JlTUrl(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TUrl (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TUrl.h:33:7
    jlcxx::TypeWrapper<TUrl>  t = jlModule.add_type<TUrl>("TUrl",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TUrl>>(new jlcxx::TypeWrapper<TUrl>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TUrl>> type_;
};
std::shared_ptr<Wrapper> newJlTUrl(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTUrl(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TFileOpenHandle> : std::false_type { };
  template<> struct DefaultConstructible<TFileOpenHandle> : std::false_type { };
template<> struct SuperType<TFileOpenHandle> { typedef TNamed type; };
}

// Class generating the wrapper for type TFileOpenHandle
// signature to use in the veto file: TFileOpenHandle
struct JlTFileOpenHandle: public Wrapper {

  JlTFileOpenHandle(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TFileOpenHandle (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TFile.h:354:7
    jlcxx::TypeWrapper<TFileOpenHandle>  t = jlModule.add_type<TFileOpenHandle>("TFileOpenHandle",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TFileOpenHandle>>(new jlcxx::TypeWrapper<TFileOpenHandle>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for Bool_t TFileOpenHandle::Matches(const char *) (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TFileOpenHandle::Matches(const char *)
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TFile.h:377:16
    t.method("Matches", [](TFileOpenHandle& a, const char * arg0)->Bool_t { return a.Matches(arg0); }, jlcxx::arg("this"), jlcxx::arg("name"));
    t.method("Matches", [](TFileOpenHandle* a, const char * arg0)->Bool_t { return a->Matches(arg0); }, jlcxx::arg("this"), jlcxx::arg("name"));

    DEBUG_MSG("Adding wrapper for const char * TFileOpenHandle::GetOpt() (" __HERE__ ")");
    // signature to use in the veto list: const char * TFileOpenHandle::GetOpt()
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TFile.h:379:16
    t.method("GetOpt", [](TFileOpenHandle const& a) { return (std::string)a.GetOpt(); }, jlcxx::arg("this"));
    t.method("GetOpt", [](TFileOpenHandle const* a) { return (std::string)a->GetOpt(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for Int_t TFileOpenHandle::GetCompress() (" __HERE__ ")");
    // signature to use in the veto list: Int_t TFileOpenHandle::GetCompress()
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TFile.h:380:16
    t.method("GetCompress", [](TFileOpenHandle const& a)->Int_t { return a.GetCompress(); }, jlcxx::arg("this"));
    t.method("GetCompress", [](TFileOpenHandle const* a)->Int_t { return a->GetCompress(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for Int_t TFileOpenHandle::GetNetOpt() (" __HERE__ ")");
    // signature to use in the veto list: Int_t TFileOpenHandle::GetNetOpt()
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TFile.h:381:16
    t.method("GetNetOpt", [](TFileOpenHandle const& a)->Int_t { return a.GetNetOpt(); }, jlcxx::arg("this"));
    t.method("GetNetOpt", [](TFileOpenHandle const* a)->Int_t { return a->GetNetOpt(); }, jlcxx::arg("this"));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TFileOpenHandle>> type_;
};
std::shared_ptr<Wrapper> newJlTFileOpenHandle(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTFileOpenHandle(module));
}

// this file was auto-generated by wrapit v1.4.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TTreeReader::Iterator_t> : std::false_type { };
  template<> struct DefaultConstructible<TTreeReader::Iterator_t> : std::false_type { };
}

// Class generating the wrapper for type TTreeReader::Iterator_t
// signature to use in the veto file: TTreeReader::Iterator_t
struct JlTTreeReader_Iterator_t: public Wrapper {

  JlTTreeReader_Iterator_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTreeReader::Iterator_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:56:10
    jlcxx::TypeWrapper<TTreeReader::Iterator_t>  t = jlModule.add_type<TTreeReader::Iterator_t>("TTreeReader!Iterator_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTreeReader::Iterator_t>>(new jlcxx::TypeWrapper<TTreeReader::Iterator_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void TTreeReader::Iterator_t::Iterator_t(TTreeReader &, Long64_t) (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:77:7
    t.constructor<TTreeReader &, Long64_t>(/*finalize=*/true);
    module_.set_override_module(jl_base_module);

    DEBUG_MSG("Adding wrapper for bool TTreeReader::Iterator_t::operator==(const TTreeReader::Iterator_t &) (" __HERE__ ")");
    // signature to use in the veto list: bool TTreeReader::Iterator_t::operator==(const TTreeReader::Iterator_t &)
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:81:12
    t.method("==", static_cast<bool (TTreeReader::Iterator_t::*)(const TTreeReader::Iterator_t &)  const>(&TTreeReader::Iterator_t::operator==));

    DEBUG_MSG("Adding wrapper for bool TTreeReader::Iterator_t::operator!=(const TTreeReader::Iterator_t &) (" __HERE__ ")");
    // signature to use in the veto list: bool TTreeReader::Iterator_t::operator!=(const TTreeReader::Iterator_t &)
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:88:12
    t.method("!=", static_cast<bool (TTreeReader::Iterator_t::*)(const TTreeReader::Iterator_t &)  const>(&TTreeReader::Iterator_t::operator!=));

    DEBUG_MSG("Adding wrapper for const Long64_t & TTreeReader::Iterator_t::operator*() (" __HERE__ ")");
    // signature to use in the veto list: const Long64_t & TTreeReader::Iterator_t::operator*()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:113:23
    t.method("getindex", static_cast<const Long64_t & (TTreeReader::Iterator_t::*)() >(&TTreeReader::Iterator_t::operator*));

    DEBUG_MSG("Adding wrapper for const Long64_t & TTreeReader::Iterator_t::operator*() (" __HERE__ ")");
    // signature to use in the veto list: const Long64_t & TTreeReader::Iterator_t::operator*()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:124:23
    t.method("getindex", static_cast<const Long64_t & (TTreeReader::Iterator_t::*)()  const>(&TTreeReader::Iterator_t::operator*));

    module_.unset_override_module();
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTreeReader::Iterator_t>> type_;
};
std::shared_ptr<Wrapper> newJlTTreeReader_Iterator_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTreeReader_Iterator_t(module));
}

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<TTreeReaderArray<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<TTreeReaderArray<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<TTreeReaderArray<T>> : std::false_type { };
}

// Class generating the wrapper for type TTreeReaderArray
// signature to use in the veto file: TTreeReaderArray
struct JlTTreeReaderArray: public Wrapper {

  JlTTreeReaderArray(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTreeReaderArray (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:75:30
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TTreeReaderArray");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    auto t106_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<TTreeReaderArray<T>> wrapped){
      auto module_ = this->module_;
      typedef TTreeReaderArray<T> WrappedType;


      DEBUG_MSG("Adding wrapper for void TTreeReaderArray::TTreeReaderArray<T>(TTreeReader &, const char *) (" __HERE__ ")");
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:202:4
      wrapped.template constructor<TTreeReader &, const char *>(/*finalize=*/true);

      DEBUG_MSG("Adding wrapper for T & TTreeReaderArray::At(std::size_t) (" __HERE__ ")");
      // signature to use in the veto list: T & TTreeReaderArray::At(std::size_t)
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:205:7
      wrapped.method("At", static_cast<T & (WrappedType::*)(std::size_t) >(&WrappedType::At));

      DEBUG_MSG("Adding wrapper for const T & TTreeReaderArray::At(std::size_t) (" __HERE__ ")");
      // signature to use in the veto list: const T & TTreeReaderArray::At(std::size_t)
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:206:13
      wrapped.method("At", static_cast<const T & (WrappedType::*)(std::size_t)  const>(&WrappedType::At));
      module_.set_override_module(jl_base_module);


      DEBUG_MSG("Adding setindex! method  to wrap T & TTreeReaderArray::operator[](std::size_t) (" __HERE__ ")");
// defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:207:7
      wrapped.method("setindex!",
        [](WrappedType& a, std::size_t i, T const & val){
        return a[i] = val;
      });

      DEBUG_MSG("Adding getindex method to wrap T & TTreeReaderArray::operator[](std::size_t) (" __HERE__ ")");
      // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:207:7
      wrapped.method("getindex",
        [](WrappedType& a, std::size_t i){
        return a[i];
      });


      module_.unset_override_module();
    };
    t.apply<TTreeReaderArray<double>, TTreeReaderArray<float>, TTreeReaderArray<unsigned long>, TTreeReaderArray<long>, TTreeReaderArray<unsigned int>, TTreeReaderArray<int>, TTreeReaderArray<unsigned short>, TTreeReaderArray<short>, TTreeReaderArray<unsigned char>, TTreeReaderArray<char>>(t106_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlTTreeReaderArray(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTreeReaderArray(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TObjLink> : std::false_type { };
  template<> struct DefaultConstructible<TObjLink> : std::false_type { };
}

// Class generating the wrapper for type TObjLink
// signature to use in the veto file: TObjLink
struct JlTObjLink: public Wrapper {

  JlTObjLink(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TObjLink (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TList.h:121:7
    jlcxx::TypeWrapper<TObjLink>  t = jlModule.add_type<TObjLink>("TObjLink");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TObjLink>>(new jlcxx::TypeWrapper<TObjLink>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TObjLink>> type_;
};
std::shared_ptr<Wrapper> newJlTObjLink(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTObjLink(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TRandom> : std::false_type { };
  template<> struct DefaultConstructible<TRandom> : std::false_type { };
template<> struct SuperType<TRandom> { typedef TNamed type; };
}

// Class generating the wrapper for type TRandom
// signature to use in the veto file: TRandom
struct JlTRandom: public Wrapper {

  JlTRandom(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TRandom (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:27:7
    jlcxx::TypeWrapper<TRandom>  t = jlModule.add_type<TRandom>("TRandom",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TRandom>>(new jlcxx::TypeWrapper<TRandom>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void TRandom::TRandom(UInt_t) (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:33:4
    t.constructor<UInt_t>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for Int_t TRandom::Binomial(Int_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Int_t TRandom::Binomial(Int_t, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:35:22
    t.method("Binomial", static_cast<Int_t (TRandom::*)(Int_t, Double_t) >(&TRandom::Binomial));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::BreitWigner(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::BreitWigner(Double_t, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:36:22
    t.method("BreitWigner", static_cast<Double_t (TRandom::*)(Double_t, Double_t) >(&TRandom::BreitWigner));
    t.method("BreitWigner", [](TRandom& a)->Double_t { return a.BreitWigner(); });
    t.method("BreitWigner", [](TRandom& a, Double_t arg0)->Double_t { return a.BreitWigner(arg0); });
    t.method("BreitWigner", [](TRandom* a)->Double_t { return a->BreitWigner(); });
    t.method("BreitWigner", [](TRandom* a, Double_t arg0)->Double_t { return a->BreitWigner(arg0); });

    DEBUG_MSG("Adding wrapper for void TRandom::Circle(Double_t &, Double_t &, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Circle(Double_t &, Double_t &, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:37:22
    t.method("Circle", static_cast<void (TRandom::*)(Double_t &, Double_t &, Double_t) >(&TRandom::Circle));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Exp(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Exp(Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:38:22
    t.method("Exp", static_cast<Double_t (TRandom::*)(Double_t) >(&TRandom::Exp));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Gaus(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Gaus(Double_t, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:39:22
    t.method("Gaus", static_cast<Double_t (TRandom::*)(Double_t, Double_t) >(&TRandom::Gaus));
    t.method("Gaus", [](TRandom& a)->Double_t { return a.Gaus(); });
    t.method("Gaus", [](TRandom& a, Double_t arg0)->Double_t { return a.Gaus(arg0); });
    t.method("Gaus", [](TRandom* a)->Double_t { return a->Gaus(); });
    t.method("Gaus", [](TRandom* a, Double_t arg0)->Double_t { return a->Gaus(arg0); });

    DEBUG_MSG("Adding wrapper for UInt_t TRandom::GetSeed() (" __HERE__ ")");
    // signature to use in the veto list: UInt_t TRandom::GetSeed()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:40:22
    t.method("GetSeed", static_cast<UInt_t (TRandom::*)()  const>(&TRandom::GetSeed));

    DEBUG_MSG("Adding wrapper for UInt_t TRandom::Integer(UInt_t) (" __HERE__ ")");
    // signature to use in the veto list: UInt_t TRandom::Integer(UInt_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:41:22
    t.method("Integer", static_cast<UInt_t (TRandom::*)(UInt_t) >(&TRandom::Integer));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Landau(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Landau(Double_t, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:42:22
    t.method("Landau", static_cast<Double_t (TRandom::*)(Double_t, Double_t) >(&TRandom::Landau));
    t.method("Landau", [](TRandom& a)->Double_t { return a.Landau(); });
    t.method("Landau", [](TRandom& a, Double_t arg0)->Double_t { return a.Landau(arg0); });
    t.method("Landau", [](TRandom* a)->Double_t { return a->Landau(); });
    t.method("Landau", [](TRandom* a, Double_t arg0)->Double_t { return a->Landau(arg0); });

    DEBUG_MSG("Adding wrapper for Int_t TRandom::Poisson(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Int_t TRandom::Poisson(Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:43:22
    t.method("Poisson", static_cast<Int_t (TRandom::*)(Double_t) >(&TRandom::Poisson));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::PoissonD(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::PoissonD(Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:44:22
    t.method("PoissonD", static_cast<Double_t (TRandom::*)(Double_t) >(&TRandom::PoissonD));

    DEBUG_MSG("Adding wrapper for void TRandom::Rannor(Float_t &, Float_t &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Rannor(Float_t &, Float_t &)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:45:22
    t.method("Rannor", static_cast<void (TRandom::*)(Float_t &, Float_t &) >(&TRandom::Rannor));

    DEBUG_MSG("Adding wrapper for void TRandom::Rannor(Double_t &, Double_t &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Rannor(Double_t &, Double_t &)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:46:22
    t.method("Rannor", static_cast<void (TRandom::*)(Double_t &, Double_t &) >(&TRandom::Rannor));

    DEBUG_MSG("Adding wrapper for void TRandom::ReadRandom(const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::ReadRandom(const char *)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:47:22
    t.method("ReadRandom", static_cast<void (TRandom::*)(const char *) >(&TRandom::ReadRandom));

    DEBUG_MSG("Adding wrapper for void TRandom::SetSeed(ULong_t) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::SetSeed(ULong_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:48:22
    t.method("SetSeed", static_cast<void (TRandom::*)(ULong_t) >(&TRandom::SetSeed));
    t.method("SetSeed", [](TRandom& a)->void { a.SetSeed(); });
    t.method("SetSeed", [](TRandom* a)->void { a->SetSeed(); });

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Rndm() (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Rndm()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:49:14
    t.method("Rndm", static_cast<Double_t (TRandom::*)() >(&TRandom::Rndm));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Rndm(Int_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Rndm(Int_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:51:22
    t.method("Rndm", static_cast<Double_t (TRandom::*)(Int_t) >(&TRandom::Rndm));

    DEBUG_MSG("Adding wrapper for void TRandom::RndmArray(Int_t, Float_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::RndmArray(Int_t, Float_t *)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:52:22
    t.method("RndmArray", static_cast<void (TRandom::*)(Int_t, Float_t *) >(&TRandom::RndmArray));

    DEBUG_MSG("Adding wrapper for void TRandom::RndmArray(Int_t, Double_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::RndmArray(Int_t, Double_t *)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:53:22
    t.method("RndmArray", static_cast<void (TRandom::*)(Int_t, Double_t *) >(&TRandom::RndmArray));

    DEBUG_MSG("Adding wrapper for void TRandom::Sphere(Double_t &, Double_t &, Double_t &, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Sphere(Double_t &, Double_t &, Double_t &, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:54:22
    t.method("Sphere", static_cast<void (TRandom::*)(Double_t &, Double_t &, Double_t &, Double_t) >(&TRandom::Sphere));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Uniform(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Uniform(Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:55:22
    t.method("Uniform", static_cast<Double_t (TRandom::*)(Double_t) >(&TRandom::Uniform));
    t.method("Uniform", [](TRandom& a)->Double_t { return a.Uniform(); });
    t.method("Uniform", [](TRandom* a)->Double_t { return a->Uniform(); });

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Uniform(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Uniform(Double_t, Double_t)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:56:22
    t.method("Uniform", static_cast<Double_t (TRandom::*)(Double_t, Double_t) >(&TRandom::Uniform));

    DEBUG_MSG("Adding wrapper for void TRandom::WriteRandom(const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::WriteRandom(const char *)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:57:22
    t.method("WriteRandom", static_cast<void (TRandom::*)(const char *)  const>(&TRandom::WriteRandom));

    DEBUG_MSG("Adding wrapper for Version_t TRandom::Class_Version() (" __HERE__ ")");
    // signature to use in the veto list: Version_t TRandom::Class_Version()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!Class_Version", static_cast<Version_t (*)() >(&TRandom::Class_Version));

    DEBUG_MSG("Adding wrapper for TClass * TRandom::IsA() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TRandom::IsA()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    t.method("IsA", static_cast<TClass * (TRandom::*)()  const>(&TRandom::IsA));

    DEBUG_MSG("Adding wrapper for void TRandom::StreamerNVirtual(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::StreamerNVirtual(TBuffer &)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    t.method("StreamerNVirtual", static_cast<void (TRandom::*)(TBuffer &) >(&TRandom::StreamerNVirtual));

    DEBUG_MSG("Adding wrapper for const char * TRandom::DeclFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TRandom::DeclFileName()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!DeclFileName", []() { return (std::string)TRandom::DeclFileName(); });

    DEBUG_MSG("Adding wrapper for int TRandom::ImplFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TRandom::ImplFileLine()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!ImplFileLine", static_cast<int (*)() >(&TRandom::ImplFileLine));

    DEBUG_MSG("Adding wrapper for const char * TRandom::ImplFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TRandom::ImplFileName()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!ImplFileName", []() { return (std::string)TRandom::ImplFileName(); });

    DEBUG_MSG("Adding wrapper for const char * TRandom::Class_Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * TRandom::Class_Name()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!Class_Name", []() { return (std::string)TRandom::Class_Name(); });

    DEBUG_MSG("Adding wrapper for TClass * TRandom::Dictionary() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TRandom::Dictionary()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!Dictionary", static_cast<TClass * (*)() >(&TRandom::Dictionary));

    DEBUG_MSG("Adding wrapper for TClass * TRandom::Class() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TRandom::Class()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!Class", static_cast<TClass * (*)() >(&TRandom::Class));

    DEBUG_MSG("Adding wrapper for void TRandom::Streamer(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Streamer(TBuffer &)
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    t.method("Streamer", static_cast<void (TRandom::*)(TBuffer &) >(&TRandom::Streamer));

    DEBUG_MSG("Adding wrapper for int TRandom::DeclFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TRandom::DeclFileLine()
    // defined in /home/pgras/.julia/conda/3/include/TRandom.h:59:4
    module_.method("TRandom!DeclFileLine", static_cast<int (*)() >(&TRandom::DeclFileLine));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TRandom>> type_;
};
std::shared_ptr<Wrapper> newJlTRandom(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTRandom(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TDatime> : std::false_type { };
  template<> struct DefaultConstructible<TDatime> : std::false_type { };
}

// Class generating the wrapper for type TDatime
// signature to use in the veto file: TDatime
struct JlTDatime: public Wrapper {

  JlTDatime(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TDatime (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TDatime.h:37:7
    jlcxx::TypeWrapper<TDatime>  t = jlModule.add_type<TDatime>("TDatime");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TDatime>>(new jlcxx::TypeWrapper<TDatime>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TDatime>> type_;
};
std::shared_ptr<Wrapper> newJlTDatime(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTDatime(module));
}

// this file was auto-generated by wrapit v1.8.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TTreeReader::Iterator_t> : std::false_type { };
  template<> struct DefaultConstructible<TTreeReader::Iterator_t> : std::false_type { };
}

// Class generating the wrapper for type TTreeReader::Iterator_t
// signature to use in the veto file: TTreeReader::Iterator_t
struct JlTTreeReader_Iterator_t: public Wrapper {

  JlTTreeReader_Iterator_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTreeReader::Iterator_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReader.h:56:10
    jlcxx::TypeWrapper<TTreeReader::Iterator_t>  t = jlModule.add_type<TTreeReader::Iterator_t>("TTreeReader!Iterator_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTreeReader::Iterator_t>>(new jlcxx::TypeWrapper<TTreeReader::Iterator_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );


    DEBUG_MSG("Adding wrapper for TTreeReader::Iterator_t::Iterator_t(TTreeReader &, Long64_t) (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReader.h:77:7
    t.constructor<TTreeReader &, int64_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("reader"), jlcxx::arg("entry")    );
    module_.set_override_module(jl_base_module);

    DEBUG_MSG("Adding wrapper for bool TTreeReader::Iterator_t::operator==(const TTreeReader::Iterator_t &) (" __HERE__ ")");
    // signature to use in the veto list: bool TTreeReader::Iterator_t::operator==(const TTreeReader::Iterator_t &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReader.h:81:12
    t.method("==", [](TTreeReader::Iterator_t const& a, const TTreeReader::Iterator_t & arg0)->bool { return a.operator==(arg0); }, jlcxx::arg("this"), jlcxx::arg("lhs"));
    t.method("==", [](TTreeReader::Iterator_t const* a, const TTreeReader::Iterator_t & arg0)->bool { return a->operator==(arg0); }, jlcxx::arg("this"), jlcxx::arg("lhs"));

    DEBUG_MSG("Adding wrapper for bool TTreeReader::Iterator_t::operator!=(const TTreeReader::Iterator_t &) (" __HERE__ ")");
    // signature to use in the veto list: bool TTreeReader::Iterator_t::operator!=(const TTreeReader::Iterator_t &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReader.h:107:12
    t.method("!=", [](TTreeReader::Iterator_t const& a, const TTreeReader::Iterator_t & arg0)->bool { return a.operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("lhs"));
    t.method("!=", [](TTreeReader::Iterator_t const* a, const TTreeReader::Iterator_t & arg0)->bool { return a->operator!=(arg0); }, jlcxx::arg("this"), jlcxx::arg("lhs"));

    DEBUG_MSG("Adding wrapper for const Long64_t & TTreeReader::Iterator_t::operator*() (" __HERE__ ")");
    // signature to use in the veto list: const Long64_t & TTreeReader::Iterator_t::operator*()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReader.h:132:23
    t.method("getindex", [](TTreeReader::Iterator_t& a) { return (const int64_t &)a.operator*(); }, jlcxx::arg("this"));
    t.method("getindex", [](TTreeReader::Iterator_t* a) { return (const int64_t &)a->operator*(); }, jlcxx::arg("this"));

    module_.unset_override_module();
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTreeReader::Iterator_t>> type_;
};
std::shared_ptr<Wrapper> newJlTTreeReader_Iterator_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTreeReader_Iterator_t(module));
}

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<TTreeReaderArray<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<TTreeReaderArray<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<TTreeReaderArray<T>> : std::false_type { };
}

// Class generating the wrapper for type TTreeReaderArray
// signature to use in the veto file: TTreeReaderArray
struct JlTTreeReaderArray: public Wrapper {

  JlTTreeReaderArray(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTreeReaderArray (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReaderArray.h:75:30
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TTreeReaderArray");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    auto t343_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<TTreeReaderArray<T>> wrapped){
      auto module_ = this->module_;
      typedef TTreeReaderArray<T> WrappedType;


      DEBUG_MSG("Adding wrapper for TTreeReaderArray::TTreeReaderArray<T>(TTreeReader &, const char *) (" __HERE__ ")");
      // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReaderArray.h:202:4
      wrapped.template constructor<TTreeReader &, const char *>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("tr"), jlcxx::arg("branchname")      );

      DEBUG_MSG("Adding wrapper for T & TTreeReaderArray::At(std::size_t) (" __HERE__ ")");
      // signature to use in the veto list: T & TTreeReaderArray::At(std::size_t)
      // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReaderArray.h:205:7
      wrapped.method("At", [](WrappedType& a, std::size_t arg0)->T & { return a.At(arg0); }, jlcxx::arg("this"), jlcxx::arg("idx"));
      wrapped.method("At", [](WrappedType* a, std::size_t arg0)->T & { return a->At(arg0); }, jlcxx::arg("this"), jlcxx::arg("idx"));

      DEBUG_MSG("Adding wrapper for const T & TTreeReaderArray::At(std::size_t) (" __HERE__ ")");
      // signature to use in the veto list: const T & TTreeReaderArray::At(std::size_t)
      // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReaderArray.h:206:13
      wrapped.method("At", [](WrappedType const& a, std::size_t arg0)->const T & { return a.At(arg0); }, jlcxx::arg("this"), jlcxx::arg("idx"));
      wrapped.method("At", [](WrappedType const* a, std::size_t arg0)->const T & { return a->At(arg0); }, jlcxx::arg("this"), jlcxx::arg("idx"));
      module_.set_override_module(jl_base_module);


      DEBUG_MSG("Adding setindex! method  to wrap T & TTreeReaderArray::operator[](std::size_t) (" __HERE__ ")");
// defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReaderArray.h:207:7
      wrapped.method("setindex!",
        [](WrappedType& a, std::size_t i, T const & val){
        return a[i] = val;
      }, jlcxx::arg("this"), jlcxx::arg("index"), jlcxx::arg("value"));

      DEBUG_MSG("Adding getindex method to wrap T & TTreeReaderArray::operator[](std::size_t) (" __HERE__ ")");
      // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TTreeReaderArray.h:207:7
      wrapped.method("getindex",
        [](WrappedType& a, std::size_t i){
        return a[i];
      }, jlcxx::arg("this"), jlcxx::arg("index"));


      module_.unset_override_module();
    };
    t.apply<TTreeReaderArray<char>, TTreeReaderArray<unsigned char>, TTreeReaderArray<short>, TTreeReaderArray<unsigned short>, TTreeReaderArray<int>, TTreeReaderArray<unsigned int>, TTreeReaderArray<long>, TTreeReaderArray<unsigned long>, TTreeReaderArray<float>, TTreeReaderArray<double>>(t343_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlTTreeReaderArray(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTreeReaderArray(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TRandom> : std::false_type { };
  template<> struct DefaultConstructible<TRandom> : std::false_type { };
  template<> struct SuperType<TRandom> { typedef TNamed type; };
}

// Class generating the wrapper for type TRandom
// signature to use in the veto file: TRandom
struct JlTRandom: public Wrapper {

  JlTRandom(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TRandom (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:27:7
    jlcxx::TypeWrapper<TRandom>  t = jlModule.add_type<TRandom>("TRandom",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TRandom>>(new jlcxx::TypeWrapper<TRandom>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );


    DEBUG_MSG("Adding wrapper for TRandom::TRandom(UInt_t) (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:33:4
    t.constructor<uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("seed")    );

    DEBUG_MSG("Adding wrapper for Int_t TRandom::Binomial(Int_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Int_t TRandom::Binomial(Int_t, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:35:22
    t.method("Binomial", [](TRandom& a, int32_t arg0, double arg1) { return (int32_t)a.Binomial((Int_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("ntot"), jlcxx::arg("prob"));
    t.method("Binomial", [](TRandom* a, int32_t arg0, double arg1) { return (int32_t)a->Binomial((Int_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("ntot"), jlcxx::arg("prob"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::BreitWigner(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::BreitWigner(Double_t, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:36:22
    t.method("BreitWigner", [](TRandom& a) { return (double)a.BreitWigner(); }, jlcxx::arg("this"));
    t.method("BreitWigner", [](TRandom& a, double arg0) { return (double)a.BreitWigner((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("BreitWigner", [](TRandom& a, double arg0, double arg1) { return (double)a.BreitWigner((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("mean"), jlcxx::arg("gamma"));
    t.method("BreitWigner", [](TRandom* a) { return (double)a->BreitWigner(); }, jlcxx::arg("this"));
    t.method("BreitWigner", [](TRandom* a, double arg0) { return (double)a->BreitWigner((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("BreitWigner", [](TRandom* a, double arg0, double arg1) { return (double)a->BreitWigner((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("mean"), jlcxx::arg("gamma"));

    DEBUG_MSG("Adding wrapper for void TRandom::Circle(Double_t &, Double_t &, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Circle(Double_t &, Double_t &, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:37:22
    t.method("Circle", [](TRandom& a, double & arg0, double & arg1, double arg2)->void { a.Circle((Double_t &)arg0, (Double_t &)arg1, (Double_t)arg2); }, jlcxx::arg("this"), jlcxx::arg("x"), jlcxx::arg("y"), jlcxx::arg("r"));
    t.method("Circle", [](TRandom* a, double & arg0, double & arg1, double arg2)->void { a->Circle((Double_t &)arg0, (Double_t &)arg1, (Double_t)arg2); }, jlcxx::arg("this"), jlcxx::arg("x"), jlcxx::arg("y"), jlcxx::arg("r"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Exp(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Exp(Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:38:22
    t.method("Exp", [](TRandom& a, double arg0) { return (double)a.Exp((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("tau"));
    t.method("Exp", [](TRandom* a, double arg0) { return (double)a->Exp((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("tau"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Gaus(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Gaus(Double_t, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:39:22
    t.method("Gaus", [](TRandom& a) { return (double)a.Gaus(); }, jlcxx::arg("this"));
    t.method("Gaus", [](TRandom& a, double arg0) { return (double)a.Gaus((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("Gaus", [](TRandom& a, double arg0, double arg1) { return (double)a.Gaus((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("mean"), jlcxx::arg("sigma"));
    t.method("Gaus", [](TRandom* a) { return (double)a->Gaus(); }, jlcxx::arg("this"));
    t.method("Gaus", [](TRandom* a, double arg0) { return (double)a->Gaus((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("Gaus", [](TRandom* a, double arg0, double arg1) { return (double)a->Gaus((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("mean"), jlcxx::arg("sigma"));

    DEBUG_MSG("Adding wrapper for UInt_t TRandom::GetSeed() (" __HERE__ ")");
    // signature to use in the veto list: UInt_t TRandom::GetSeed()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:40:22
    t.method("GetSeed", [](TRandom const& a) { return (uint32_t)a.GetSeed(); }, jlcxx::arg("this"));
    t.method("GetSeed", [](TRandom const* a) { return (uint32_t)a->GetSeed(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for UInt_t TRandom::Integer(UInt_t) (" __HERE__ ")");
    // signature to use in the veto list: UInt_t TRandom::Integer(UInt_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:41:22
    t.method("GetInteger", [](TRandom& a, uint32_t arg0) { return (uint32_t)a.Integer((UInt_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("imax"));
    t.method("GetInteger", [](TRandom* a, uint32_t arg0) { return (uint32_t)a->Integer((UInt_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("imax"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Landau(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Landau(Double_t, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:42:22
    t.method("Landau", [](TRandom& a) { return (double)a.Landau(); }, jlcxx::arg("this"));
    t.method("Landau", [](TRandom& a, double arg0) { return (double)a.Landau((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("Landau", [](TRandom& a, double arg0, double arg1) { return (double)a.Landau((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("mean"), jlcxx::arg("sigma"));
    t.method("Landau", [](TRandom* a) { return (double)a->Landau(); }, jlcxx::arg("this"));
    t.method("Landau", [](TRandom* a, double arg0) { return (double)a->Landau((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("Landau", [](TRandom* a, double arg0, double arg1) { return (double)a->Landau((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("mean"), jlcxx::arg("sigma"));

    DEBUG_MSG("Adding wrapper for ULong64_t TRandom::Poisson(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: ULong64_t TRandom::Poisson(Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:43:22
    t.method("Poisson", [](TRandom& a, double arg0) { return (uint64_t)a.Poisson((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("Poisson", [](TRandom* a, double arg0) { return (uint64_t)a->Poisson((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::PoissonD(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::PoissonD(Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:44:22
    t.method("PoissonD", [](TRandom& a, double arg0) { return (double)a.PoissonD((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));
    t.method("PoissonD", [](TRandom* a, double arg0) { return (double)a->PoissonD((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("mean"));

    DEBUG_MSG("Adding wrapper for void TRandom::Rannor(Float_t &, Float_t &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Rannor(Float_t &, Float_t &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:45:22
    t.method("Rannor", [](TRandom& a, float & arg0, float & arg1)->void { a.Rannor((Float_t &)arg0, (Float_t &)arg1); }, jlcxx::arg("this"), jlcxx::arg("a"), jlcxx::arg("b"));
    t.method("Rannor", [](TRandom* a, float & arg0, float & arg1)->void { a->Rannor((Float_t &)arg0, (Float_t &)arg1); }, jlcxx::arg("this"), jlcxx::arg("a"), jlcxx::arg("b"));

    DEBUG_MSG("Adding wrapper for void TRandom::Rannor(Double_t &, Double_t &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Rannor(Double_t &, Double_t &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:46:22
    t.method("Rannor", [](TRandom& a, double & arg0, double & arg1)->void { a.Rannor((Double_t &)arg0, (Double_t &)arg1); }, jlcxx::arg("this"), jlcxx::arg("a"), jlcxx::arg("b"));
    t.method("Rannor", [](TRandom* a, double & arg0, double & arg1)->void { a->Rannor((Double_t &)arg0, (Double_t &)arg1); }, jlcxx::arg("this"), jlcxx::arg("a"), jlcxx::arg("b"));

    DEBUG_MSG("Adding wrapper for void TRandom::ReadRandom(const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::ReadRandom(const char *)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:47:22
    t.method("ReadRandom", [](TRandom& a, const char * arg0)->void { a.ReadRandom(arg0); }, jlcxx::arg("this"), jlcxx::arg("filename"));
    t.method("ReadRandom", [](TRandom* a, const char * arg0)->void { a->ReadRandom(arg0); }, jlcxx::arg("this"), jlcxx::arg("filename"));

    DEBUG_MSG("Adding wrapper for void TRandom::SetSeed(ULong_t) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::SetSeed(ULong_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:48:22
    t.method("SetSeed", [](TRandom& a)->void { a.SetSeed(); }, jlcxx::arg("this"), jlcxx::arg("seed"));
    t.method("SetSeed", [](TRandom& a, uint64_t arg0)->void { a.SetSeed((ULong_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("seed"));
    t.method("SetSeed", [](TRandom* a)->void { a->SetSeed(); }, jlcxx::arg("this"), jlcxx::arg("seed"));
    t.method("SetSeed", [](TRandom* a, uint64_t arg0)->void { a->SetSeed((ULong_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("seed"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Rndm() (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Rndm()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:49:14
    t.method("Rndm", [](TRandom& a) { return (double)a.Rndm(); }, jlcxx::arg("this"));
    t.method("Rndm", [](TRandom* a) { return (double)a->Rndm(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Rndm(Int_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Rndm(Int_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:51:22
    t.method("Rndm", [](TRandom& a, int32_t arg0) { return (double)a.Rndm((Int_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));
    t.method("Rndm", [](TRandom* a, int32_t arg0) { return (double)a->Rndm((Int_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));

    DEBUG_MSG("Adding wrapper for void TRandom::RndmArray(Int_t, Float_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::RndmArray(Int_t, Float_t *)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:52:22
    t.method("RndmArray", [](TRandom& a, int32_t arg0, Float_t * arg1)->void { a.RndmArray((Int_t)arg0, arg1); }, jlcxx::arg("this"), jlcxx::arg("n"), jlcxx::arg("array"));
    t.method("RndmArray", [](TRandom* a, int32_t arg0, Float_t * arg1)->void { a->RndmArray((Int_t)arg0, arg1); }, jlcxx::arg("this"), jlcxx::arg("n"), jlcxx::arg("array"));

    DEBUG_MSG("Adding wrapper for void TRandom::RndmArray(Int_t, Double_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::RndmArray(Int_t, Double_t *)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:53:22
    t.method("RndmArray", [](TRandom& a, int32_t arg0, Double_t * arg1)->void { a.RndmArray((Int_t)arg0, arg1); }, jlcxx::arg("this"), jlcxx::arg("n"), jlcxx::arg("array"));
    t.method("RndmArray", [](TRandom* a, int32_t arg0, Double_t * arg1)->void { a->RndmArray((Int_t)arg0, arg1); }, jlcxx::arg("this"), jlcxx::arg("n"), jlcxx::arg("array"));

    DEBUG_MSG("Adding wrapper for void TRandom::Sphere(Double_t &, Double_t &, Double_t &, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Sphere(Double_t &, Double_t &, Double_t &, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:54:22
    t.method("Sphere", [](TRandom& a, double & arg0, double & arg1, double & arg2, double arg3)->void { a.Sphere((Double_t &)arg0, (Double_t &)arg1, (Double_t &)arg2, (Double_t)arg3); }, jlcxx::arg("this"), jlcxx::arg("x"), jlcxx::arg("y"), jlcxx::arg("z"), jlcxx::arg("r"));
    t.method("Sphere", [](TRandom* a, double & arg0, double & arg1, double & arg2, double arg3)->void { a->Sphere((Double_t &)arg0, (Double_t &)arg1, (Double_t &)arg2, (Double_t)arg3); }, jlcxx::arg("this"), jlcxx::arg("x"), jlcxx::arg("y"), jlcxx::arg("z"), jlcxx::arg("r"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Uniform(Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Uniform(Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:55:22
    t.method("Uniform", [](TRandom& a) { return (double)a.Uniform(); }, jlcxx::arg("this"));
    t.method("Uniform", [](TRandom& a, double arg0) { return (double)a.Uniform((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("x1"));
    t.method("Uniform", [](TRandom* a) { return (double)a->Uniform(); }, jlcxx::arg("this"));
    t.method("Uniform", [](TRandom* a, double arg0) { return (double)a->Uniform((Double_t)arg0); }, jlcxx::arg("this"), jlcxx::arg("x1"));

    DEBUG_MSG("Adding wrapper for Double_t TRandom::Uniform(Double_t, Double_t) (" __HERE__ ")");
    // signature to use in the veto list: Double_t TRandom::Uniform(Double_t, Double_t)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:56:22
    t.method("Uniform", [](TRandom& a, double arg0, double arg1) { return (double)a.Uniform((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("x1"), jlcxx::arg("x2"));
    t.method("Uniform", [](TRandom* a, double arg0, double arg1) { return (double)a->Uniform((Double_t)arg0, (Double_t)arg1); }, jlcxx::arg("this"), jlcxx::arg("x1"), jlcxx::arg("x2"));

    DEBUG_MSG("Adding wrapper for void TRandom::WriteRandom(const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::WriteRandom(const char *)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TRandom.h:57:22
    t.method("WriteRandom", [](TRandom const& a, const char * arg0)->void { a.WriteRandom(arg0); }, jlcxx::arg("this"), jlcxx::arg("filename"));
    t.method("WriteRandom", [](TRandom const* a, const char * arg0)->void { a->WriteRandom(arg0); }, jlcxx::arg("this"), jlcxx::arg("filename"));

    DEBUG_MSG("Adding wrapper for Version_t TRandom::Class_Version() (" __HERE__ ")");
    // signature to use in the veto list: Version_t TRandom::Class_Version()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:293:68
    module_.method("TRandom!Class_Version", []() { return (int16_t)TRandom::Class_Version(); });

    DEBUG_MSG("Adding wrapper for TClass * TRandom::IsA() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TRandom::IsA()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:294:76
    t.method("IsA", [](TRandom const& a)->TClass * { return a.IsA(); }, jlcxx::arg("this"));
    t.method("IsA", [](TRandom const* a)->TClass * { return a->IsA(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for void TRandom::StreamerNVirtual(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::StreamerNVirtual(TBuffer &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:300:9
    t.method("StreamerNVirtual", [](TRandom& a, TBuffer & arg0)->void { a.StreamerNVirtual(arg0); }, jlcxx::arg("this"), jlcxx::arg("ClassDef_StreamerNVirtual_b"));
    t.method("StreamerNVirtual", [](TRandom* a, TBuffer & arg0)->void { a->StreamerNVirtual(arg0); }, jlcxx::arg("this"), jlcxx::arg("ClassDef_StreamerNVirtual_b"));

    DEBUG_MSG("Adding wrapper for const char * TRandom::DeclFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TRandom::DeclFileName()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:301:88
    module_.method("TRandom!DeclFileName", []() { return (std::string)TRandom::DeclFileName(); });

    DEBUG_MSG("Adding wrapper for int TRandom::ImplFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TRandom::ImplFileLine()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:309:55
    module_.method("TRandom!ImplFileLine", []()->int { return TRandom::ImplFileLine(); });

    DEBUG_MSG("Adding wrapper for const char * TRandom::ImplFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TRandom::ImplFileName()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:310:63
    module_.method("TRandom!ImplFileName", []() { return (std::string)TRandom::ImplFileName(); });

    DEBUG_MSG("Adding wrapper for const char * TRandom::Class_Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * TRandom::Class_Name()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:311:57
    module_.method("TRandom!Class_Name", []() { return (std::string)TRandom::Class_Name(); });

    DEBUG_MSG("Adding wrapper for TClass * TRandom::Dictionary() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TRandom::Dictionary()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:312:47
    module_.method("TRandom!Dictionary", []()->TClass * { return TRandom::Dictionary(); });

    DEBUG_MSG("Adding wrapper for TClass * TRandom::Class() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TRandom::Class()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:313:63
    module_.method("TRandom!Class", []()->TClass * { return TRandom::Class(); });

    DEBUG_MSG("Adding wrapper for void TRandom::Streamer(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TRandom::Streamer(TBuffer &)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:314:25
    t.method("Streamer", [](TRandom& a, TBuffer & arg0)->void { a.Streamer(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));
    t.method("Streamer", [](TRandom* a, TBuffer & arg0)->void { a->Streamer(arg0); }, jlcxx::arg("this"), jlcxx::arg("arg0"));

    DEBUG_MSG("Adding wrapper for int TRandom::DeclFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TRandom::DeclFileLine()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Rtypes.h:343:43
    module_.method("TRandom!DeclFileLine", []()->int { return TRandom::DeclFileLine(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TRandom>> type_;
};
std::shared_ptr<Wrapper> newJlTRandom(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTRandom(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TFileOpenHandle> : std::false_type { };
  template<> struct DefaultConstructible<TFileOpenHandle> : std::false_type { };
  template<> struct SuperType<TFileOpenHandle> { typedef TNamed type; };
}

// Class generating the wrapper for type TFileOpenHandle
// signature to use in the veto file: TFileOpenHandle
struct JlTFileOpenHandle: public Wrapper {

  JlTFileOpenHandle(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TFileOpenHandle (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TFile.h:354:7
    jlcxx::TypeWrapper<TFileOpenHandle>  t = jlModule.add_type<TFileOpenHandle>("TFileOpenHandle",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TFileOpenHandle>>(new jlcxx::TypeWrapper<TFileOpenHandle>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for Bool_t TFileOpenHandle::Matches(const char *) (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TFileOpenHandle::Matches(const char *)
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TFile.h:377:16
    t.method("Matches", [](TFileOpenHandle& a, const char * arg0) { return (bool)a.Matches(arg0); }, jlcxx::arg("this"), jlcxx::arg("name"));
    t.method("Matches", [](TFileOpenHandle* a, const char * arg0) { return (bool)a->Matches(arg0); }, jlcxx::arg("this"), jlcxx::arg("name"));

    DEBUG_MSG("Adding wrapper for const char * TFileOpenHandle::GetOpt() (" __HERE__ ")");
    // signature to use in the veto list: const char * TFileOpenHandle::GetOpt()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TFile.h:379:16
    t.method("GetOpt", [](TFileOpenHandle const& a) { return (std::string)a.GetOpt(); }, jlcxx::arg("this"));
    t.method("GetOpt", [](TFileOpenHandle const* a) { return (std::string)a->GetOpt(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for Int_t TFileOpenHandle::GetCompress() (" __HERE__ ")");
    // signature to use in the veto list: Int_t TFileOpenHandle::GetCompress()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TFile.h:380:16
    t.method("GetCompress", [](TFileOpenHandle const& a) { return (int32_t)a.GetCompress(); }, jlcxx::arg("this"));
    t.method("GetCompress", [](TFileOpenHandle const* a) { return (int32_t)a->GetCompress(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for Int_t TFileOpenHandle::GetNetOpt() (" __HERE__ ")");
    // signature to use in the veto list: Int_t TFileOpenHandle::GetNetOpt()
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/TFile.h:381:16
    t.method("GetNetOpt", [](TFileOpenHandle const& a) { return (int32_t)a.GetNetOpt(); }, jlcxx::arg("this"));
    t.method("GetNetOpt", [](TFileOpenHandle const* a) { return (int32_t)a->GetNetOpt(); }, jlcxx::arg("this"));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TFileOpenHandle>> type_;
};
std::shared_ptr<Wrapper> newJlTFileOpenHandle(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTFileOpenHandle(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<Foption_t> : std::false_type { };
  template<> struct DefaultConstructible<Foption_t> : std::false_type { };
}

// Class generating the wrapper for type Foption_t
// signature to use in the veto file: Foption_t
struct JlFoption_t: public Wrapper {

  JlFoption_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Foption_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:24:8
    jlcxx::TypeWrapper<Foption_t>  t = jlModule.add_type<Foption_t>("Foption_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Foption_t>>(new jlcxx::TypeWrapper<Foption_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );

    DEBUG_MSG("Adding Quiet methods  to provide read access to the field Quiet (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:29:8
    // signature to use in the veto list: Foption_t::Quiet
    t.method("Quiet", [](const Foption_t& a) -> int { return a.Quiet; }, jlcxx::arg("this"));
    t.method("Quiet", [](Foption_t& a) -> int { return a.Quiet; }, jlcxx::arg("this"));
    t.method("Quiet", [](const Foption_t* a) -> int { return a->Quiet; }, jlcxx::arg("this"));
    t.method("Quiet", [](Foption_t* a) -> int { return a->Quiet; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:29:8
    // signature to use in the veto list: Foption_t::Quiet
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Quiet! methods to provide write access to the field Quiet (" __HERE__ ")");
    t.method("Quiet!", [](Foption_t& a, int val) -> int { return a.Quiet = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Quiet! methods to provide write access to the field Quiet (" __HERE__ ")");
    t.method("Quiet!", [](Foption_t* a, int val) -> int { return a->Quiet = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Verbose methods  to provide read access to the field Verbose (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:30:8
    // signature to use in the veto list: Foption_t::Verbose
    t.method("Verbose", [](const Foption_t& a) -> int { return a.Verbose; }, jlcxx::arg("this"));
    t.method("Verbose", [](Foption_t& a) -> int { return a.Verbose; }, jlcxx::arg("this"));
    t.method("Verbose", [](const Foption_t* a) -> int { return a->Verbose; }, jlcxx::arg("this"));
    t.method("Verbose", [](Foption_t* a) -> int { return a->Verbose; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:30:8
    // signature to use in the veto list: Foption_t::Verbose
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Verbose! methods to provide write access to the field Verbose (" __HERE__ ")");
    t.method("Verbose!", [](Foption_t& a, int val) -> int { return a.Verbose = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Verbose! methods to provide write access to the field Verbose (" __HERE__ ")");
    t.method("Verbose!", [](Foption_t* a, int val) -> int { return a->Verbose = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Bound methods  to provide read access to the field Bound (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:31:8
    // signature to use in the veto list: Foption_t::Bound
    t.method("Bound", [](const Foption_t& a) -> int { return a.Bound; }, jlcxx::arg("this"));
    t.method("Bound", [](Foption_t& a) -> int { return a.Bound; }, jlcxx::arg("this"));
    t.method("Bound", [](const Foption_t* a) -> int { return a->Bound; }, jlcxx::arg("this"));
    t.method("Bound", [](Foption_t* a) -> int { return a->Bound; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:31:8
    // signature to use in the veto list: Foption_t::Bound
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Bound! methods to provide write access to the field Bound (" __HERE__ ")");
    t.method("Bound!", [](Foption_t& a, int val) -> int { return a.Bound = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Bound! methods to provide write access to the field Bound (" __HERE__ ")");
    t.method("Bound!", [](Foption_t* a, int val) -> int { return a->Bound = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Chi2 methods  to provide read access to the field Chi2 (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:32:8
    // signature to use in the veto list: Foption_t::Chi2
    t.method("Chi2", [](const Foption_t& a) -> int { return a.Chi2; }, jlcxx::arg("this"));
    t.method("Chi2", [](Foption_t& a) -> int { return a.Chi2; }, jlcxx::arg("this"));
    t.method("Chi2", [](const Foption_t* a) -> int { return a->Chi2; }, jlcxx::arg("this"));
    t.method("Chi2", [](Foption_t* a) -> int { return a->Chi2; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:32:8
    // signature to use in the veto list: Foption_t::Chi2
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Chi2! methods to provide write access to the field Chi2 (" __HERE__ ")");
    t.method("Chi2!", [](Foption_t& a, int val) -> int { return a.Chi2 = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Chi2! methods to provide write access to the field Chi2 (" __HERE__ ")");
    t.method("Chi2!", [](Foption_t* a, int val) -> int { return a->Chi2 = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding PChi2 methods  to provide read access to the field PChi2 (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:33:8
    // signature to use in the veto list: Foption_t::PChi2
    t.method("PChi2", [](const Foption_t& a) -> int { return a.PChi2; }, jlcxx::arg("this"));
    t.method("PChi2", [](Foption_t& a) -> int { return a.PChi2; }, jlcxx::arg("this"));
    t.method("PChi2", [](const Foption_t* a) -> int { return a->PChi2; }, jlcxx::arg("this"));
    t.method("PChi2", [](Foption_t* a) -> int { return a->PChi2; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:33:8
    // signature to use in the veto list: Foption_t::PChi2
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding PChi2! methods to provide write access to the field PChi2 (" __HERE__ ")");
    t.method("PChi2!", [](Foption_t& a, int val) -> int { return a.PChi2 = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding PChi2! methods to provide write access to the field PChi2 (" __HERE__ ")");
    t.method("PChi2!", [](Foption_t* a, int val) -> int { return a->PChi2 = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Like methods  to provide read access to the field Like (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:34:8
    // signature to use in the veto list: Foption_t::Like
    t.method("Like", [](const Foption_t& a) -> int { return a.Like; }, jlcxx::arg("this"));
    t.method("Like", [](Foption_t& a) -> int { return a.Like; }, jlcxx::arg("this"));
    t.method("Like", [](const Foption_t* a) -> int { return a->Like; }, jlcxx::arg("this"));
    t.method("Like", [](Foption_t* a) -> int { return a->Like; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:34:8
    // signature to use in the veto list: Foption_t::Like
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Like! methods to provide write access to the field Like (" __HERE__ ")");
    t.method("Like!", [](Foption_t& a, int val) -> int { return a.Like = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Like! methods to provide write access to the field Like (" __HERE__ ")");
    t.method("Like!", [](Foption_t* a, int val) -> int { return a->Like = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding User methods  to provide read access to the field User (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:35:8
    // signature to use in the veto list: Foption_t::User
    t.method("User", [](const Foption_t& a) -> int { return a.User; }, jlcxx::arg("this"));
    t.method("User", [](Foption_t& a) -> int { return a.User; }, jlcxx::arg("this"));
    t.method("User", [](const Foption_t* a) -> int { return a->User; }, jlcxx::arg("this"));
    t.method("User", [](Foption_t* a) -> int { return a->User; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:35:8
    // signature to use in the veto list: Foption_t::User
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding User! methods to provide write access to the field User (" __HERE__ ")");
    t.method("User!", [](Foption_t& a, int val) -> int { return a.User = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding User! methods to provide write access to the field User (" __HERE__ ")");
    t.method("User!", [](Foption_t* a, int val) -> int { return a->User = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding W1 methods  to provide read access to the field W1 (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:36:8
    // signature to use in the veto list: Foption_t::W1
    t.method("W1", [](const Foption_t& a) -> int { return a.W1; }, jlcxx::arg("this"));
    t.method("W1", [](Foption_t& a) -> int { return a.W1; }, jlcxx::arg("this"));
    t.method("W1", [](const Foption_t* a) -> int { return a->W1; }, jlcxx::arg("this"));
    t.method("W1", [](Foption_t* a) -> int { return a->W1; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:36:8
    // signature to use in the veto list: Foption_t::W1
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding W1! methods to provide write access to the field W1 (" __HERE__ ")");
    t.method("W1!", [](Foption_t& a, int val) -> int { return a.W1 = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding W1! methods to provide write access to the field W1 (" __HERE__ ")");
    t.method("W1!", [](Foption_t* a, int val) -> int { return a->W1 = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Errors methods  to provide read access to the field Errors (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:37:8
    // signature to use in the veto list: Foption_t::Errors
    t.method("Errors", [](const Foption_t& a) -> int { return a.Errors; }, jlcxx::arg("this"));
    t.method("Errors", [](Foption_t& a) -> int { return a.Errors; }, jlcxx::arg("this"));
    t.method("Errors", [](const Foption_t* a) -> int { return a->Errors; }, jlcxx::arg("this"));
    t.method("Errors", [](Foption_t* a) -> int { return a->Errors; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:37:8
    // signature to use in the veto list: Foption_t::Errors
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Errors! methods to provide write access to the field Errors (" __HERE__ ")");
    t.method("Errors!", [](Foption_t& a, int val) -> int { return a.Errors = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Errors! methods to provide write access to the field Errors (" __HERE__ ")");
    t.method("Errors!", [](Foption_t* a, int val) -> int { return a->Errors = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding More methods  to provide read access to the field More (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:38:8
    // signature to use in the veto list: Foption_t::More
    t.method("More", [](const Foption_t& a) -> int { return a.More; }, jlcxx::arg("this"));
    t.method("More", [](Foption_t& a) -> int { return a.More; }, jlcxx::arg("this"));
    t.method("More", [](const Foption_t* a) -> int { return a->More; }, jlcxx::arg("this"));
    t.method("More", [](Foption_t* a) -> int { return a->More; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:38:8
    // signature to use in the veto list: Foption_t::More
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding More! methods to provide write access to the field More (" __HERE__ ")");
    t.method("More!", [](Foption_t& a, int val) -> int { return a.More = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding More! methods to provide write access to the field More (" __HERE__ ")");
    t.method("More!", [](Foption_t* a, int val) -> int { return a->More = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Range methods  to provide read access to the field Range (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:39:8
    // signature to use in the veto list: Foption_t::Range
    t.method("Range", [](const Foption_t& a) -> int { return a.Range; }, jlcxx::arg("this"));
    t.method("Range", [](Foption_t& a) -> int { return a.Range; }, jlcxx::arg("this"));
    t.method("Range", [](const Foption_t* a) -> int { return a->Range; }, jlcxx::arg("this"));
    t.method("Range", [](Foption_t* a) -> int { return a->Range; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:39:8
    // signature to use in the veto list: Foption_t::Range
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Range! methods to provide write access to the field Range (" __HERE__ ")");
    t.method("Range!", [](Foption_t& a, int val) -> int { return a.Range = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Range! methods to provide write access to the field Range (" __HERE__ ")");
    t.method("Range!", [](Foption_t* a, int val) -> int { return a->Range = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Gradient methods  to provide read access to the field Gradient (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:40:8
    // signature to use in the veto list: Foption_t::Gradient
    t.method("Gradient", [](const Foption_t& a) -> int { return a.Gradient; }, jlcxx::arg("this"));
    t.method("Gradient", [](Foption_t& a) -> int { return a.Gradient; }, jlcxx::arg("this"));
    t.method("Gradient", [](const Foption_t* a) -> int { return a->Gradient; }, jlcxx::arg("this"));
    t.method("Gradient", [](Foption_t* a) -> int { return a->Gradient; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:40:8
    // signature to use in the veto list: Foption_t::Gradient
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Gradient! methods to provide write access to the field Gradient (" __HERE__ ")");
    t.method("Gradient!", [](Foption_t& a, int val) -> int { return a.Gradient = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Gradient! methods to provide write access to the field Gradient (" __HERE__ ")");
    t.method("Gradient!", [](Foption_t* a, int val) -> int { return a->Gradient = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Nostore methods  to provide read access to the field Nostore (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:41:8
    // signature to use in the veto list: Foption_t::Nostore
    t.method("Nostore", [](const Foption_t& a) -> int { return a.Nostore; }, jlcxx::arg("this"));
    t.method("Nostore", [](Foption_t& a) -> int { return a.Nostore; }, jlcxx::arg("this"));
    t.method("Nostore", [](const Foption_t* a) -> int { return a->Nostore; }, jlcxx::arg("this"));
    t.method("Nostore", [](Foption_t* a) -> int { return a->Nostore; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:41:8
    // signature to use in the veto list: Foption_t::Nostore
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Nostore! methods to provide write access to the field Nostore (" __HERE__ ")");
    t.method("Nostore!", [](Foption_t& a, int val) -> int { return a.Nostore = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Nostore! methods to provide write access to the field Nostore (" __HERE__ ")");
    t.method("Nostore!", [](Foption_t* a, int val) -> int { return a->Nostore = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Nograph methods  to provide read access to the field Nograph (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:42:8
    // signature to use in the veto list: Foption_t::Nograph
    t.method("Nograph", [](const Foption_t& a) -> int { return a.Nograph; }, jlcxx::arg("this"));
    t.method("Nograph", [](Foption_t& a) -> int { return a.Nograph; }, jlcxx::arg("this"));
    t.method("Nograph", [](const Foption_t* a) -> int { return a->Nograph; }, jlcxx::arg("this"));
    t.method("Nograph", [](Foption_t* a) -> int { return a->Nograph; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:42:8
    // signature to use in the veto list: Foption_t::Nograph
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Nograph! methods to provide write access to the field Nograph (" __HERE__ ")");
    t.method("Nograph!", [](Foption_t& a, int val) -> int { return a.Nograph = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Nograph! methods to provide write access to the field Nograph (" __HERE__ ")");
    t.method("Nograph!", [](Foption_t* a, int val) -> int { return a->Nograph = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Plus methods  to provide read access to the field Plus (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:43:8
    // signature to use in the veto list: Foption_t::Plus
    t.method("Plus", [](const Foption_t& a) -> int { return a.Plus; }, jlcxx::arg("this"));
    t.method("Plus", [](Foption_t& a) -> int { return a.Plus; }, jlcxx::arg("this"));
    t.method("Plus", [](const Foption_t* a) -> int { return a->Plus; }, jlcxx::arg("this"));
    t.method("Plus", [](Foption_t* a) -> int { return a->Plus; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:43:8
    // signature to use in the veto list: Foption_t::Plus
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Plus! methods to provide write access to the field Plus (" __HERE__ ")");
    t.method("Plus!", [](Foption_t& a, int val) -> int { return a.Plus = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Plus! methods to provide write access to the field Plus (" __HERE__ ")");
    t.method("Plus!", [](Foption_t* a, int val) -> int { return a->Plus = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Integral methods  to provide read access to the field Integral (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:44:8
    // signature to use in the veto list: Foption_t::Integral
    t.method("Integral", [](const Foption_t& a) -> int { return a.Integral; }, jlcxx::arg("this"));
    t.method("Integral", [](Foption_t& a) -> int { return a.Integral; }, jlcxx::arg("this"));
    t.method("Integral", [](const Foption_t* a) -> int { return a->Integral; }, jlcxx::arg("this"));
    t.method("Integral", [](Foption_t* a) -> int { return a->Integral; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:44:8
    // signature to use in the veto list: Foption_t::Integral
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Integral! methods to provide write access to the field Integral (" __HERE__ ")");
    t.method("Integral!", [](Foption_t& a, int val) -> int { return a.Integral = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Integral! methods to provide write access to the field Integral (" __HERE__ ")");
    t.method("Integral!", [](Foption_t* a, int val) -> int { return a->Integral = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Nochisq methods  to provide read access to the field Nochisq (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:45:8
    // signature to use in the veto list: Foption_t::Nochisq
    t.method("Nochisq", [](const Foption_t& a) -> int { return a.Nochisq; }, jlcxx::arg("this"));
    t.method("Nochisq", [](Foption_t& a) -> int { return a.Nochisq; }, jlcxx::arg("this"));
    t.method("Nochisq", [](const Foption_t* a) -> int { return a->Nochisq; }, jlcxx::arg("this"));
    t.method("Nochisq", [](Foption_t* a) -> int { return a->Nochisq; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:45:8
    // signature to use in the veto list: Foption_t::Nochisq
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Nochisq! methods to provide write access to the field Nochisq (" __HERE__ ")");
    t.method("Nochisq!", [](Foption_t& a, int val) -> int { return a.Nochisq = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Nochisq! methods to provide write access to the field Nochisq (" __HERE__ ")");
    t.method("Nochisq!", [](Foption_t* a, int val) -> int { return a->Nochisq = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Minuit methods  to provide read access to the field Minuit (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:46:8
    // signature to use in the veto list: Foption_t::Minuit
    t.method("Minuit", [](const Foption_t& a) -> int { return a.Minuit; }, jlcxx::arg("this"));
    t.method("Minuit", [](Foption_t& a) -> int { return a.Minuit; }, jlcxx::arg("this"));
    t.method("Minuit", [](const Foption_t* a) -> int { return a->Minuit; }, jlcxx::arg("this"));
    t.method("Minuit", [](Foption_t* a) -> int { return a->Minuit; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:46:8
    // signature to use in the veto list: Foption_t::Minuit
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Minuit! methods to provide write access to the field Minuit (" __HERE__ ")");
    t.method("Minuit!", [](Foption_t& a, int val) -> int { return a.Minuit = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Minuit! methods to provide write access to the field Minuit (" __HERE__ ")");
    t.method("Minuit!", [](Foption_t* a, int val) -> int { return a->Minuit = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding NoErrX methods  to provide read access to the field NoErrX (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:47:8
    // signature to use in the veto list: Foption_t::NoErrX
    t.method("NoErrX", [](const Foption_t& a) -> int { return a.NoErrX; }, jlcxx::arg("this"));
    t.method("NoErrX", [](Foption_t& a) -> int { return a.NoErrX; }, jlcxx::arg("this"));
    t.method("NoErrX", [](const Foption_t* a) -> int { return a->NoErrX; }, jlcxx::arg("this"));
    t.method("NoErrX", [](Foption_t* a) -> int { return a->NoErrX; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:47:8
    // signature to use in the veto list: Foption_t::NoErrX
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding NoErrX! methods to provide write access to the field NoErrX (" __HERE__ ")");
    t.method("NoErrX!", [](Foption_t& a, int val) -> int { return a.NoErrX = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding NoErrX! methods to provide write access to the field NoErrX (" __HERE__ ")");
    t.method("NoErrX!", [](Foption_t* a, int val) -> int { return a->NoErrX = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Robust methods  to provide read access to the field Robust (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:48:8
    // signature to use in the veto list: Foption_t::Robust
    t.method("Robust", [](const Foption_t& a) -> int { return a.Robust; }, jlcxx::arg("this"));
    t.method("Robust", [](Foption_t& a) -> int { return a.Robust; }, jlcxx::arg("this"));
    t.method("Robust", [](const Foption_t* a) -> int { return a->Robust; }, jlcxx::arg("this"));
    t.method("Robust", [](Foption_t* a) -> int { return a->Robust; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:48:8
    // signature to use in the veto list: Foption_t::Robust
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Robust! methods to provide write access to the field Robust (" __HERE__ ")");
    t.method("Robust!", [](Foption_t& a, int val) -> int { return a.Robust = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding Robust! methods to provide write access to the field Robust (" __HERE__ ")");
    t.method("Robust!", [](Foption_t* a, int val) -> int { return a->Robust = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding StoreResult methods  to provide read access to the field StoreResult (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:49:8
    // signature to use in the veto list: Foption_t::StoreResult
    t.method("StoreResult", [](const Foption_t& a) -> int { return a.StoreResult; }, jlcxx::arg("this"));
    t.method("StoreResult", [](Foption_t& a) -> int { return a.StoreResult; }, jlcxx::arg("this"));
    t.method("StoreResult", [](const Foption_t* a) -> int { return a->StoreResult; }, jlcxx::arg("this"));
    t.method("StoreResult", [](Foption_t* a) -> int { return a->StoreResult; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:49:8
    // signature to use in the veto list: Foption_t::StoreResult
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding StoreResult! methods to provide write access to the field StoreResult (" __HERE__ ")");
    t.method("StoreResult!", [](Foption_t& a, int val) -> int { return a.StoreResult = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding StoreResult! methods to provide write access to the field StoreResult (" __HERE__ ")");
    t.method("StoreResult!", [](Foption_t* a, int val) -> int { return a->StoreResult = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding BinVolume methods  to provide read access to the field BinVolume (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:50:8
    // signature to use in the veto list: Foption_t::BinVolume
    t.method("BinVolume", [](const Foption_t& a) -> int { return a.BinVolume; }, jlcxx::arg("this"));
    t.method("BinVolume", [](Foption_t& a) -> int { return a.BinVolume; }, jlcxx::arg("this"));
    t.method("BinVolume", [](const Foption_t* a) -> int { return a->BinVolume; }, jlcxx::arg("this"));
    t.method("BinVolume", [](Foption_t* a) -> int { return a->BinVolume; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:50:8
    // signature to use in the veto list: Foption_t::BinVolume
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding BinVolume! methods to provide write access to the field BinVolume (" __HERE__ ")");
    t.method("BinVolume!", [](Foption_t& a, int val) -> int { return a.BinVolume = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding BinVolume! methods to provide write access to the field BinVolume (" __HERE__ ")");
    t.method("BinVolume!", [](Foption_t* a, int val) -> int { return a->BinVolume = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding hRobust methods  to provide read access to the field hRobust (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:51:11
    // signature to use in the veto list: Foption_t::hRobust
    t.method("hRobust", [](const Foption_t& a) -> double { return a.hRobust; }, jlcxx::arg("this"));
    t.method("hRobust", [](Foption_t& a) -> double { return a.hRobust; }, jlcxx::arg("this"));
    t.method("hRobust", [](const Foption_t* a) -> double { return a->hRobust; }, jlcxx::arg("this"));
    t.method("hRobust", [](Foption_t* a) -> double { return a->hRobust; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:51:11
    // signature to use in the veto list: Foption_t::hRobust
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding hRobust! methods to provide write access to the field hRobust (" __HERE__ ")");
    t.method("hRobust!", [](Foption_t& a, double val) -> double { return a.hRobust = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding hRobust! methods to provide write access to the field hRobust (" __HERE__ ")");
    t.method("hRobust!", [](Foption_t* a, double val) -> double { return a->hRobust = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding ExecPolicy methods  to provide read access to the field ExecPolicy (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:52:27
    // signature to use in the veto list: Foption_t::ExecPolicy
    t.method("ExecPolicy", [](const Foption_t& a) -> ROOT::EExecutionPolicy { return a.ExecPolicy; }, jlcxx::arg("this"));
    t.method("ExecPolicy", [](Foption_t& a) -> ROOT::EExecutionPolicy { return a.ExecPolicy; }, jlcxx::arg("this"));
    t.method("ExecPolicy", [](const Foption_t* a) -> ROOT::EExecutionPolicy { return a->ExecPolicy; }, jlcxx::arg("this"));
    t.method("ExecPolicy", [](Foption_t* a) -> ROOT::EExecutionPolicy { return a->ExecPolicy; }, jlcxx::arg("this"));
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/Foption.h:52:27
    // signature to use in the veto list: Foption_t::ExecPolicy
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ExecPolicy! methods to provide write access to the field ExecPolicy (" __HERE__ ")");
    t.method("ExecPolicy!", [](Foption_t& a, ROOT::EExecutionPolicy val) -> ROOT::EExecutionPolicy { return a.ExecPolicy = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding ExecPolicy! methods to provide write access to the field ExecPolicy (" __HERE__ ")");
    t.method("ExecPolicy!", [](Foption_t* a, ROOT::EExecutionPolicy val) -> ROOT::EExecutionPolicy { return a->ExecPolicy = val; }, jlcxx::arg("this"), jlcxx::arg("value"));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Foption_t>> type_;
};
std::shared_ptr<Wrapper> newJlFoption_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlFoption_t(module));
}

// this file was auto-generated by wrapit v1.8.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<PictureAttributes_t> : std::false_type { };
  template<> struct DefaultConstructible<PictureAttributes_t> : std::false_type { };
}

// Class generating the wrapper for type PictureAttributes_t
// signature to use in the veto file: PictureAttributes_t
struct JlPictureAttributes_t: public Wrapper {

  JlPictureAttributes_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type PictureAttributes_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/GuiTypes.h:323:8
    jlcxx::TypeWrapper<PictureAttributes_t>  t = jlModule.add_type<PictureAttributes_t>("PictureAttributes_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<PictureAttributes_t>>(new jlcxx::TypeWrapper<PictureAttributes_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<PictureAttributes_t>> type_;
};
std::shared_ptr<Wrapper> newJlPictureAttributes_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlPictureAttributes_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<ColorStruct_t> : std::false_type { };
  template<> struct DefaultConstructible<ColorStruct_t> : std::false_type { };
}

// Class generating the wrapper for type ColorStruct_t
// signature to use in the veto file: ColorStruct_t
struct JlColorStruct_t: public Wrapper {

  JlColorStruct_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type ColorStruct_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/GuiTypes.h:310:8
    jlcxx::TypeWrapper<ColorStruct_t>  t = jlModule.add_type<ColorStruct_t>("ColorStruct_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<ColorStruct_t>>(new jlcxx::TypeWrapper<ColorStruct_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<ColorStruct_t>> type_;
};
std::shared_ptr<Wrapper> newJlColorStruct_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlColorStruct_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<Event_t> : std::false_type { };
  template<> struct DefaultConstructible<Event_t> : std::false_type { };
}

// Class generating the wrapper for type Event_t
// signature to use in the veto file: Event_t
struct JlEvent_t: public Wrapper {

  JlEvent_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Event_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/GuiTypes.h:174:8
    jlcxx::TypeWrapper<Event_t>  t = jlModule.add_type<Event_t>("Event_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Event_t>>(new jlcxx::TypeWrapper<Event_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Event_t>> type_;
};
std::shared_ptr<Wrapper> newJlEvent_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlEvent_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<Segment_t> : std::false_type { };
  template<> struct DefaultConstructible<Segment_t> : std::false_type { };
}

// Class generating the wrapper for type Segment_t
// signature to use in the veto file: Segment_t
struct JlSegment_t: public Wrapper {

  JlSegment_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Segment_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/GuiTypes.h:351:8
    jlcxx::TypeWrapper<Segment_t>  t = jlModule.add_type<Segment_t>("Segment_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Segment_t>>(new jlcxx::TypeWrapper<Segment_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Segment_t>> type_;
};
std::shared_ptr<Wrapper> newJlSegment_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlSegment_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<Point_t> : std::false_type { };
  template<> struct DefaultConstructible<Point_t> : std::false_type { };
}

// Class generating the wrapper for type Point_t
// signature to use in the veto file: Point_t
struct JlPoint_t: public Wrapper {

  JlPoint_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Point_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/541477a5cefd778e4ecbd314cfbc99eed20f2c4c/include/GuiTypes.h:356:8
    jlcxx::TypeWrapper<Point_t>  t = jlModule.add_type<Point_t>("Point_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Point_t>>(new jlcxx::TypeWrapper<Point_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Point_t>> type_;
};
std::shared_ptr<Wrapper> newJlPoint_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlPoint_t(module));
}

// this file was auto-generated by wrapit v1.6.0-3-ga0c580f-dirty
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<Event_t> : std::false_type { };
  template<> struct DefaultConstructible<Event_t> : std::false_type { };
}

// Class generating the wrapper for type Event_t
// signature to use in the veto file: Event_t
struct JlEvent_t: public Wrapper {

  JlEvent_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Event_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:174:8
    jlcxx::TypeWrapper<Event_t>  t = jlModule.add_type<Event_t>("Event_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Event_t>>(new jlcxx::TypeWrapper<Event_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Event_t>> type_;
};
std::shared_ptr<Wrapper> newJlEvent_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlEvent_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<Segment_t> : std::false_type { };
  template<> struct DefaultConstructible<Segment_t> : std::false_type { };
}

// Class generating the wrapper for type Segment_t
// signature to use in the veto file: Segment_t
struct JlSegment_t: public Wrapper {

  JlSegment_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Segment_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:351:8
    jlcxx::TypeWrapper<Segment_t>  t = jlModule.add_type<Segment_t>("Segment_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Segment_t>>(new jlcxx::TypeWrapper<Segment_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Segment_t>> type_;
};
std::shared_ptr<Wrapper> newJlSegment_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlSegment_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<Point_t> : std::false_type { };
  template<> struct DefaultConstructible<Point_t> : std::false_type { };
}

// Class generating the wrapper for type Point_t
// signature to use in the veto file: Point_t
struct JlPoint_t: public Wrapper {

  JlPoint_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type Point_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:356:8
    jlcxx::TypeWrapper<Point_t>  t = jlModule.add_type<Point_t>("Point_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<Point_t>>(new jlcxx::TypeWrapper<Point_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<Point_t>> type_;
};
std::shared_ptr<Wrapper> newJlPoint_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlPoint_t(module));
}

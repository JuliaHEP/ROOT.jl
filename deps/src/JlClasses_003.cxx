// this file was auto-generated by wrapit v1.4.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer> : std::false_type { };
template<> struct SuperType<TBuffer> { typedef TObject type; };
}

// Class generating the wrapper for type TBuffer
// signature to use in the veto file: TBuffer
struct JlTBuffer: public Wrapper {

  JlTBuffer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TBuffer.h:43:7
    jlcxx::TypeWrapper<TBuffer>  t = jlModule.add_type<TBuffer>("TBuffer",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer>>(new jlcxx::TypeWrapper<TBuffer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer(module));
}

namespace jlcxx {

  template<typename Element>
  struct BuildParameterList<TVectorT<Element>>
  {
    typedef ParameterList<Element> type;
  };

  template<typename Element> struct IsMirroredType<TVectorT<Element>> : std::false_type { };
  template<typename Element> struct DefaultConstructible<TVectorT<Element>> : std::false_type { };
}

// Class generating the wrapper for type TVectorT
// signature to use in the veto file: TVectorT
struct JlTVectorT: public Wrapper {

  JlTVectorT(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TVectorT (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TVectorDfwd.h:22:31
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TVectorT");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/true);
    auto t23_decl_methods = [this]<typename Element> (jlcxx::TypeWrapper<TVectorT<Element>> wrapped){
      auto module_ = this->module_;
      wrapped.template constructor<>(/*finalize=*/true);
    };
    t.apply<TVectorT<double>>(t23_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlTVectorT(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTVectorT(module));
}

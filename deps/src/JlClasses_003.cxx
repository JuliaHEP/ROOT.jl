// this file was auto-generated by wrapit v1.4.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {

  template<typename Element>
  struct BuildParameterList<TVectorT<Element>>
  {
    typedef ParameterList<Element> type;
  };

  template<typename Element> struct IsMirroredType<TVectorT<Element>> : std::false_type { };
  template<typename Element> struct DefaultConstructible<TVectorT<Element>> : std::false_type { };
}

// Class generating the wrapper for type TVectorT
// signature to use in the veto file: TVectorT
struct JlTVectorT: public Wrapper {

  JlTVectorT(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TVectorT (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TVectorDfwd.h:22:31
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("TVectorT");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/true);
    auto t13_decl_methods = [this]<typename Element> (jlcxx::TypeWrapper<TVectorT<Element>> wrapped){
      auto module_ = this->module_;
      wrapped.template constructor<>(/*finalize=*/true);
    };
    t.apply<TVectorT<double>>(t13_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlTVectorT(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTVectorT(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TString> : std::false_type { };
  template<> struct DefaultConstructible<TString> : std::false_type { };
}

// Class generating the wrapper for type TString
// signature to use in the veto file: TString
struct JlTString: public Wrapper {

  JlTString(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TString (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TString.h:139:7
    jlcxx::TypeWrapper<TString>  t = jlModule.add_type<TString>("TString");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TString>>(new jlcxx::TypeWrapper<TString>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TString>> type_;
};
std::shared_ptr<Wrapper> newJlTString(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTString(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TIterator> : std::false_type { };
  template<> struct DefaultConstructible<TIterator> : std::false_type { };
}

// Class generating the wrapper for type TIterator
// signature to use in the veto file: TIterator
struct JlTIterator: public Wrapper {

  JlTIterator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TIterator (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TIterator.h:30:7
    jlcxx::TypeWrapper<TIterator>  t = jlModule.add_type<TIterator>("TIterator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TIterator>>(new jlcxx::TypeWrapper<TIterator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TIterator>> type_;
};
std::shared_ptr<Wrapper> newJlTIterator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTIterator(module));
}

// this file was auto-generated by wrapit v1.3.3
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TObjArray> : std::false_type { };
  template<> struct DefaultConstructible<TObjArray> : std::false_type { };
template<> struct SuperType<TObjArray> { typedef TSeqCollection type; };
}

// Class generating the wrapper for type TObjArray
// signature to use in the veto file: TObjArray
struct JlTObjArray: public Wrapper {

  JlTObjArray(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TObjArray (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TObjArray.h:31:7
    jlcxx::TypeWrapper<TObjArray>  t = jlModule.add_type<TObjArray>("TObjArray",
      jlcxx::julia_base_type<TSeqCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TObjArray>>(new jlcxx::TypeWrapper<TObjArray>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TObjArray>> type_;
};
std::shared_ptr<Wrapper> newJlTObjArray(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTObjArray(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TTimer> : std::false_type { };
  template<> struct DefaultConstructible<TTimer> : std::false_type { };
}

// Class generating the wrapper for type TTimer
// signature to use in the veto file: TTimer
struct JlTTimer: public Wrapper {

  JlTTimer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTimer (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTimer.h:51:7
    jlcxx::TypeWrapper<TTimer>  t = jlModule.add_type<TTimer>("TTimer");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTimer>>(new jlcxx::TypeWrapper<TTimer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTimer>> type_;
};
std::shared_ptr<Wrapper> newJlTTimer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTimer(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TClass> : std::false_type { };
  template<> struct DefaultConstructible<TClass> : std::false_type { };
}

// Class generating the wrapper for type TClass
// signature to use in the veto file: TClass
struct JlTClass: public Wrapper {

  JlTClass(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TClass (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TClass.h:81:7
    jlcxx::TypeWrapper<TClass>  t = jlModule.add_type<TClass>("TClass");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TClass>>(new jlcxx::TypeWrapper<TClass>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TClass>> type_;
};
std::shared_ptr<Wrapper> newJlTClass(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTClass(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer> : std::false_type { };
template<> struct SuperType<TBuffer> { typedef TObject type; };
}

// Class generating the wrapper for type TBuffer
// signature to use in the veto file: TBuffer
struct JlTBuffer: public Wrapper {

  JlTBuffer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TBuffer.h:43:7
    jlcxx::TypeWrapper<TBuffer>  t = jlModule.add_type<TBuffer>("TBuffer",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer>>(new jlcxx::TypeWrapper<TBuffer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer(module));
}

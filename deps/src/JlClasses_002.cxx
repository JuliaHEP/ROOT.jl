// this file was auto-generated by wrapit v1.3.2
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TNamed> : std::false_type { };
  template<> struct DefaultConstructible<TNamed> : std::false_type { };
template<> struct SuperType<TNamed> { typedef TObject type; };
}

// Class generating the wrapper for type TNamed
// signature to use in the veto file: TNamed
struct JlTNamed: public Wrapper {

  JlTNamed(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TNamed (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:29:7
    jlcxx::TypeWrapper<TNamed>  t = jlModule.add_type<TNamed>("TNamed",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TNamed>>(new jlcxx::TypeWrapper<TNamed>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void TNamed::TNamed(const char *, const char *) (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:37:4
    t.constructor<const char *, const char *>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void TNamed::TNamed(const TString &, const TString &) (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:38:4
    t.constructor<const TString &, const TString &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void TNamed::TNamed(const TNamed &) (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:39:4
    t.constructor<const TNamed &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for TNamed & TNamed::operator=(const TNamed &) (" __HERE__ ")");
    // signature to use in the veto list: TNamed & TNamed::operator=(const TNamed &)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:40:12
    t.method("assign", static_cast<TNamed & (TNamed::*)(const TNamed &) >(&TNamed::operator=));

    DEBUG_MSG("Adding wrapper for void TNamed::Clear(Option_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::Clear(Option_t *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:42:22
    t.method("Clear", static_cast<void (TNamed::*)(Option_t *) >(&TNamed::Clear));
    t.method("Clear", [](TNamed& a)->void { a.Clear(); });
    t.method("Clear", [](TNamed* a)->void { a->Clear(); });

    DEBUG_MSG("Adding wrapper for TObject * TNamed::Clone(const char *) (" __HERE__ ")");
    // signature to use in the veto list: TObject * TNamed::Clone(const char *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:43:22
    t.method("Clone", static_cast<TObject * (TNamed::*)(const char *)  const>(&TNamed::Clone));
    t.method("Clone", [](TNamed const& a)->TObject * { return a.Clone(); });
    t.method("Clone", [](TNamed const* a)->TObject * { return a->Clone(); });

    DEBUG_MSG("Adding wrapper for Int_t TNamed::Compare(const TObject *) (" __HERE__ ")");
    // signature to use in the veto list: Int_t TNamed::Compare(const TObject *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:44:22
    t.method("Compare", static_cast<Int_t (TNamed::*)(const TObject *)  const>(&TNamed::Compare));

    DEBUG_MSG("Adding wrapper for void TNamed::Copy(TObject &) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::Copy(TObject &)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:45:22
    t.method("Copy", static_cast<void (TNamed::*)(TObject &)  const>(&TNamed::Copy));

    DEBUG_MSG("Adding wrapper for void TNamed::FillBuffer(char *&) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::FillBuffer(char *&)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:46:22
    t.method("FillBuffer", static_cast<void (TNamed::*)(char *&) >(&TNamed::FillBuffer));

    DEBUG_MSG("Adding wrapper for const char * TNamed::GetName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TNamed::GetName()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:47:26
    t.method("GetName", [](TNamed const& a) { return (std::string)a.GetName(); });
    t.method("GetName", [](TNamed const* a) { return (std::string)a->GetName(); });

    DEBUG_MSG("Adding wrapper for const char * TNamed::GetTitle() (" __HERE__ ")");
    // signature to use in the veto list: const char * TNamed::GetTitle()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:48:26
    t.method("GetTitle", [](TNamed const& a) { return (std::string)a.GetTitle(); });
    t.method("GetTitle", [](TNamed const* a) { return (std::string)a->GetTitle(); });

    DEBUG_MSG("Adding wrapper for ULong_t TNamed::Hash() (" __HERE__ ")");
    // signature to use in the veto list: ULong_t TNamed::Hash()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:49:22
    t.method("Hash", static_cast<ULong_t (TNamed::*)()  const>(&TNamed::Hash));

    DEBUG_MSG("Adding wrapper for Bool_t TNamed::IsSortable() (" __HERE__ ")");
    // signature to use in the veto list: Bool_t TNamed::IsSortable()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:50:22
    t.method("IsSortable", static_cast<Bool_t (TNamed::*)()  const>(&TNamed::IsSortable));

    DEBUG_MSG("Adding wrapper for void TNamed::SetName(const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::SetName(const char *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:51:22
    t.method("SetName", static_cast<void (TNamed::*)(const char *) >(&TNamed::SetName));

    DEBUG_MSG("Adding wrapper for void TNamed::SetNameTitle(const char *, const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::SetNameTitle(const char *, const char *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:52:22
    t.method("SetNameTitle", static_cast<void (TNamed::*)(const char *, const char *) >(&TNamed::SetNameTitle));

    DEBUG_MSG("Adding wrapper for void TNamed::SetTitle(const char *) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::SetTitle(const char *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:53:22
    t.method("SetTitle", static_cast<void (TNamed::*)(const char *) >(&TNamed::SetTitle));
    t.method("SetTitle", [](TNamed& a)->void { a.SetTitle(); });
    t.method("SetTitle", [](TNamed* a)->void { a->SetTitle(); });

    DEBUG_MSG("Adding wrapper for void TNamed::ls(Option_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::ls(Option_t *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:54:22
    t.method("ls", static_cast<void (TNamed::*)(Option_t *)  const>(&TNamed::ls));
    t.method("ls", [](TNamed const& a)->void { a.ls(); });
    t.method("ls", [](TNamed const* a)->void { a->ls(); });

    DEBUG_MSG("Adding wrapper for void TNamed::Print(Option_t *) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::Print(Option_t *)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:55:22
    t.method("Print", static_cast<void (TNamed::*)(Option_t *)  const>(&TNamed::Print));
    t.method("Print", [](TNamed const& a)->void { a.Print(); });
    t.method("Print", [](TNamed const* a)->void { a->Print(); });

    DEBUG_MSG("Adding wrapper for Int_t TNamed::Sizeof() (" __HERE__ ")");
    // signature to use in the veto list: Int_t TNamed::Sizeof()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:56:22
    t.method("Sizeof", static_cast<Int_t (TNamed::*)()  const>(&TNamed::Sizeof));

    DEBUG_MSG("Adding wrapper for Version_t TNamed::Class_Version() (" __HERE__ ")");
    // signature to use in the veto list: Version_t TNamed::Class_Version()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!Class_Version", static_cast<Version_t (*)() >(&TNamed::Class_Version));

    DEBUG_MSG("Adding wrapper for TClass * TNamed::IsA() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TNamed::IsA()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    t.method("IsA", static_cast<TClass * (TNamed::*)()  const>(&TNamed::IsA));

    DEBUG_MSG("Adding wrapper for void TNamed::StreamerNVirtual(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::StreamerNVirtual(TBuffer &)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    t.method("StreamerNVirtual", static_cast<void (TNamed::*)(TBuffer &) >(&TNamed::StreamerNVirtual));

    DEBUG_MSG("Adding wrapper for const char * TNamed::DeclFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TNamed::DeclFileName()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!DeclFileName", []() { return (std::string)TNamed::DeclFileName(); });

    DEBUG_MSG("Adding wrapper for int TNamed::ImplFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TNamed::ImplFileLine()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!ImplFileLine", static_cast<int (*)() >(&TNamed::ImplFileLine));

    DEBUG_MSG("Adding wrapper for const char * TNamed::ImplFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TNamed::ImplFileName()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!ImplFileName", []() { return (std::string)TNamed::ImplFileName(); });

    DEBUG_MSG("Adding wrapper for const char * TNamed::Class_Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * TNamed::Class_Name()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!Class_Name", []() { return (std::string)TNamed::Class_Name(); });

    DEBUG_MSG("Adding wrapper for TClass * TNamed::Dictionary() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TNamed::Dictionary()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!Dictionary", static_cast<TClass * (*)() >(&TNamed::Dictionary));

    DEBUG_MSG("Adding wrapper for TClass * TNamed::Class() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TNamed::Class()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!Class", static_cast<TClass * (*)() >(&TNamed::Class));

    DEBUG_MSG("Adding wrapper for void TNamed::Streamer(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TNamed::Streamer(TBuffer &)
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    t.method("Streamer", static_cast<void (TNamed::*)(TBuffer &) >(&TNamed::Streamer));

    DEBUG_MSG("Adding wrapper for int TNamed::DeclFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TNamed::DeclFileLine()
    // defined in /home/pgras/.julia/conda/3/include/TNamed.h:58:4
    module_.method("TNamed!DeclFileLine", static_cast<int (*)() >(&TNamed::DeclFileLine));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TNamed>> type_;
};
std::shared_ptr<Wrapper> newJlTNamed(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTNamed(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TDictionary> : std::false_type { };
  template<> struct DefaultConstructible<TDictionary> : std::false_type { };
template<> struct SuperType<TDictionary> { typedef TNamed type; };
}

// Class generating the wrapper for type TDictionary
// signature to use in the veto file: TDictionary
struct JlTDictionary: public Wrapper {

  JlTDictionary(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TDictionary (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:167:7
    jlcxx::TypeWrapper<TDictionary>  t = jlModule.add_type<TDictionary>("TDictionary",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TDictionary>>(new jlcxx::TypeWrapper<TDictionary>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TDictionary>> type_;
};
std::shared_ptr<Wrapper> newJlTDictionary(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTDictionary(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TClass> : std::false_type { };
  template<> struct DefaultConstructible<TClass> : std::false_type { };
template<> struct SuperType<TClass> { typedef TDictionary type; };
}

// Class generating the wrapper for type TClass
// signature to use in the veto file: TClass
struct JlTClass: public Wrapper {

  JlTClass(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TClass (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TClass.h:81:7
    jlcxx::TypeWrapper<TClass>  t = jlModule.add_type<TClass>("TClass",
      jlcxx::julia_base_type<TDictionary>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TClass>>(new jlcxx::TypeWrapper<TClass>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TClass>> type_;
};
std::shared_ptr<Wrapper> newJlTClass(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTClass(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer> : std::false_type { };
template<> struct SuperType<TBuffer> { typedef TObject type; };
}

// Class generating the wrapper for type TBuffer
// signature to use in the veto file: TBuffer
struct JlTBuffer: public Wrapper {

  JlTBuffer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TBuffer.h:43:7
    jlcxx::TypeWrapper<TBuffer>  t = jlModule.add_type<TBuffer>("TBuffer",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer>>(new jlcxx::TypeWrapper<TBuffer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer(module));
}

// this file was auto-generated by wrapit v1.6.0-3-ga0c580f-dirty
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<WindowAttributes_t> : std::false_type { };
  template<> struct DefaultConstructible<WindowAttributes_t> : std::false_type { };
}

// Class generating the wrapper for type WindowAttributes_t
// signature to use in the veto file: WindowAttributes_t
struct JlWindowAttributes_t: public Wrapper {

  JlWindowAttributes_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type WindowAttributes_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:114:8
    jlcxx::TypeWrapper<WindowAttributes_t>  t = jlModule.add_type<WindowAttributes_t>("WindowAttributes_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<WindowAttributes_t>>(new jlcxx::TypeWrapper<WindowAttributes_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<WindowAttributes_t>> type_;
};
std::shared_ptr<Wrapper> newJlWindowAttributes_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlWindowAttributes_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<SetWindowAttributes_t> : std::false_type { };
  template<> struct DefaultConstructible<SetWindowAttributes_t> : std::false_type { };
}

// Class generating the wrapper for type SetWindowAttributes_t
// signature to use in the veto file: SetWindowAttributes_t
struct JlSetWindowAttributes_t: public Wrapper {

  JlSetWindowAttributes_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type SetWindowAttributes_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:93:8
    jlcxx::TypeWrapper<SetWindowAttributes_t>  t = jlModule.add_type<SetWindowAttributes_t>("SetWindowAttributes_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<SetWindowAttributes_t>>(new jlcxx::TypeWrapper<SetWindowAttributes_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<SetWindowAttributes_t>> type_;
};
std::shared_ptr<Wrapper> newJlSetWindowAttributes_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlSetWindowAttributes_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<GCValues_t> : std::false_type { };
  template<> struct DefaultConstructible<GCValues_t> : std::false_type { };
}

// Class generating the wrapper for type GCValues_t
// signature to use in the veto file: GCValues_t
struct JlGCValues_t: public Wrapper {

  JlGCValues_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type GCValues_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:224:8
    jlcxx::TypeWrapper<GCValues_t>  t = jlModule.add_type<GCValues_t>("GCValues_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<GCValues_t>>(new jlcxx::TypeWrapper<GCValues_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<GCValues_t>> type_;
};
std::shared_ptr<Wrapper> newJlGCValues_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlGCValues_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<PictureAttributes_t> : std::false_type { };
  template<> struct DefaultConstructible<PictureAttributes_t> : std::false_type { };
}

// Class generating the wrapper for type PictureAttributes_t
// signature to use in the veto file: PictureAttributes_t
struct JlPictureAttributes_t: public Wrapper {

  JlPictureAttributes_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type PictureAttributes_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:323:8
    jlcxx::TypeWrapper<PictureAttributes_t>  t = jlModule.add_type<PictureAttributes_t>("PictureAttributes_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<PictureAttributes_t>>(new jlcxx::TypeWrapper<PictureAttributes_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<PictureAttributes_t>> type_;
};
std::shared_ptr<Wrapper> newJlPictureAttributes_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlPictureAttributes_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<ColorStruct_t> : std::false_type { };
  template<> struct DefaultConstructible<ColorStruct_t> : std::false_type { };
}

// Class generating the wrapper for type ColorStruct_t
// signature to use in the veto file: ColorStruct_t
struct JlColorStruct_t: public Wrapper {

  JlColorStruct_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type ColorStruct_t (" __HERE__ ")");
    // defined in /feynman/home/dedip/lilas/pgras/.julia/artifacts/54e60c641c75fb2e5777b51cd519d1c05678ef04/include/GuiTypes.h:310:8
    jlcxx::TypeWrapper<ColorStruct_t>  t = jlModule.add_type<ColorStruct_t>("ColorStruct_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<ColorStruct_t>>(new jlcxx::TypeWrapper<ColorStruct_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<ColorStruct_t>> type_;
};
std::shared_ptr<Wrapper> newJlColorStruct_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlColorStruct_t(module));
}

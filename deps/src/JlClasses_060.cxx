// this file was auto-generated by wrapit v1.4.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TGeoXtru::ThreadData_t> : std::false_type { };
  template<> struct DefaultConstructible<TGeoXtru::ThreadData_t> : std::false_type { };
}

// Class generating the wrapper for type TGeoXtru::ThreadData_t
// signature to use in the veto file: TGeoXtru::ThreadData_t
struct JlTGeoXtru_ThreadData_t: public Wrapper {

  JlTGeoXtru_ThreadData_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TGeoXtru::ThreadData_t (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TGeoXtru.h:24:11
    jlcxx::TypeWrapper<TGeoXtru::ThreadData_t>  t = jlModule.add_type<TGeoXtru::ThreadData_t>("TGeoXtru!ThreadData_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TGeoXtru::ThreadData_t>>(new jlcxx::TypeWrapper<TGeoXtru::ThreadData_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding fSeg methods  to provide read access to the field fSeg (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TGeoXtru.h:25:13
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fSeg
    t.method("fSeg", [](const TGeoXtru::ThreadData_t& a) -> Int_t { return a.fSeg; });
    t.method("fSeg", [](TGeoXtru::ThreadData_t& a) -> Int_t { return a.fSeg; });
    t.method("fSeg", [](const TGeoXtru::ThreadData_t* a) -> Int_t { return a->fSeg; });
    t.method("fSeg", [](TGeoXtru::ThreadData_t* a) -> Int_t { return a->fSeg; });
    // defined in /opt/root63206jll/include/TGeoXtru.h:25:13
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fSeg
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fSeg! methods to provide write access to the field fSeg (" __HERE__ ")");
    t.method("fSeg!", [](TGeoXtru::ThreadData_t& a, Int_t val) -> Int_t { return a.fSeg = val; });

    DEBUG_MSG("Adding fSeg! methods to provide write access to the field fSeg (" __HERE__ ")");
    t.method("fSeg!", [](TGeoXtru::ThreadData_t* a, Int_t val) -> Int_t { return a->fSeg = val; });

    DEBUG_MSG("Adding fIz methods  to provide read access to the field fIz (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TGeoXtru.h:26:13
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fIz
    t.method("fIz", [](const TGeoXtru::ThreadData_t& a) -> Int_t { return a.fIz; });
    t.method("fIz", [](TGeoXtru::ThreadData_t& a) -> Int_t { return a.fIz; });
    t.method("fIz", [](const TGeoXtru::ThreadData_t* a) -> Int_t { return a->fIz; });
    t.method("fIz", [](TGeoXtru::ThreadData_t* a) -> Int_t { return a->fIz; });
    // defined in /opt/root63206jll/include/TGeoXtru.h:26:13
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fIz
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fIz! methods to provide write access to the field fIz (" __HERE__ ")");
    t.method("fIz!", [](TGeoXtru::ThreadData_t& a, Int_t val) -> Int_t { return a.fIz = val; });

    DEBUG_MSG("Adding fIz! methods to provide write access to the field fIz (" __HERE__ ")");
    t.method("fIz!", [](TGeoXtru::ThreadData_t* a, Int_t val) -> Int_t { return a->fIz = val; });

    DEBUG_MSG("Adding fXc methods  to provide read access to the field fXc (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TGeoXtru.h:27:17
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fXc
    t.method("fXc", [](const TGeoXtru::ThreadData_t& a) -> Double_t * { return a.fXc; });
    t.method("fXc", [](TGeoXtru::ThreadData_t& a) -> Double_t * { return a.fXc; });
    t.method("fXc", [](const TGeoXtru::ThreadData_t* a) -> Double_t * { return a->fXc; });
    t.method("fXc", [](TGeoXtru::ThreadData_t* a) -> Double_t * { return a->fXc; });
    // defined in /opt/root63206jll/include/TGeoXtru.h:27:17
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fXc
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fXc! methods to provide write access to the field fXc (" __HERE__ ")");
    t.method("fXc!", [](TGeoXtru::ThreadData_t& a, Double_t * val) -> Double_t * { return a.fXc = val; });

    DEBUG_MSG("Adding fXc! methods to provide write access to the field fXc (" __HERE__ ")");
    t.method("fXc!", [](TGeoXtru::ThreadData_t* a, Double_t * val) -> Double_t * { return a->fXc = val; });

    DEBUG_MSG("Adding fYc methods  to provide read access to the field fYc (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TGeoXtru.h:28:17
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fYc
    t.method("fYc", [](const TGeoXtru::ThreadData_t& a) -> Double_t * { return a.fYc; });
    t.method("fYc", [](TGeoXtru::ThreadData_t& a) -> Double_t * { return a.fYc; });
    t.method("fYc", [](const TGeoXtru::ThreadData_t* a) -> Double_t * { return a->fYc; });
    t.method("fYc", [](TGeoXtru::ThreadData_t* a) -> Double_t * { return a->fYc; });
    // defined in /opt/root63206jll/include/TGeoXtru.h:28:17
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fYc
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fYc! methods to provide write access to the field fYc (" __HERE__ ")");
    t.method("fYc!", [](TGeoXtru::ThreadData_t& a, Double_t * val) -> Double_t * { return a.fYc = val; });

    DEBUG_MSG("Adding fYc! methods to provide write access to the field fYc (" __HERE__ ")");
    t.method("fYc!", [](TGeoXtru::ThreadData_t* a, Double_t * val) -> Double_t * { return a->fYc = val; });

    DEBUG_MSG("Adding fPoly methods  to provide read access to the field fPoly (" __HERE__ ")");
    // defined in /opt/root63206jll/include/TGeoXtru.h:29:20
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fPoly
    t.method("fPoly", [](const TGeoXtru::ThreadData_t& a) -> TGeoPolygon * { return a.fPoly; });
    t.method("fPoly", [](TGeoXtru::ThreadData_t& a) -> TGeoPolygon * { return a.fPoly; });
    t.method("fPoly", [](const TGeoXtru::ThreadData_t* a) -> TGeoPolygon * { return a->fPoly; });
    t.method("fPoly", [](TGeoXtru::ThreadData_t* a) -> TGeoPolygon * { return a->fPoly; });
    // defined in /opt/root63206jll/include/TGeoXtru.h:29:20
    // signature to use in the veto list: TGeoXtru::ThreadData_t::fPoly
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fPoly! methods to provide write access to the field fPoly (" __HERE__ ")");
    t.method("fPoly!", [](TGeoXtru::ThreadData_t& a, TGeoPolygon * val) -> TGeoPolygon * { return a.fPoly = val; });

    DEBUG_MSG("Adding fPoly! methods to provide write access to the field fPoly (" __HERE__ ")");
    t.method("fPoly!", [](TGeoXtru::ThreadData_t* a, TGeoPolygon * val) -> TGeoPolygon * { return a->fPoly = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TGeoXtru::ThreadData_t>> type_;
};
std::shared_ptr<Wrapper> newJlTGeoXtru_ThreadData_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTGeoXtru_ThreadData_t(module));
}

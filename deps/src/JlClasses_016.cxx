// this file was auto-generated by wrapit v1.3.2
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {

  template<typename Func>
  struct BuildParameterList<ROOT::Internal::TF1Builder<Func>>
  {
    typedef ParameterList<Func> type;
  };

  template<typename Func> struct IsMirroredType<ROOT::Internal::TF1Builder<Func>> : std::false_type { };
  template<typename Func> struct DefaultConstructible<ROOT::Internal::TF1Builder<Func>> : std::false_type { };
}

// Class generating the wrapper for type ROOT::Internal::TF1Builder
// signature to use in the veto file: ROOT::Internal::TF1Builder
struct JlROOT_Internal_TF1Builder: public Wrapper {

  JlROOT_Internal_TF1Builder(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type ROOT::Internal::TF1Builder (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TF1.h:150:14
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("ROOT!Internal!TF1Builder");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/true);
    auto t115_decl_methods = [this]<typename Func> (jlcxx::TypeWrapper<ROOT::Internal::TF1Builder<Func>> wrapped){
      auto module_ = this->module_;
      typedef ROOT::Internal::TF1Builder<Func> WrappedType;
      wrapped.template constructor<>(/*finalize=*/true);

      DEBUG_MSG("Adding wrapper for void ROOT::Internal::TF1Builder::Build(TF1 *, Func) (" __HERE__ ")");
      // signature to use in the veto list: void ROOT::Internal::TF1Builder::Build(TF1 *, Func)
      // defined in /home/pgras/.julia/conda/3/include/TF1.h:151:22
      wrapped.method("ROOT!Internal!TF1Builder!Build", static_cast<void (*)(TF1 *, Func) >(&WrappedType::Build));
    };
    t.apply<ROOT::Internal::TF1Builder<const char *>>(t115_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlROOT_Internal_TF1Builder(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlROOT_Internal_TF1Builder(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TF1::TF1FunctorPointer> : std::false_type { };
  template<> struct DefaultConstructible<TF1::TF1FunctorPointer> : std::false_type { };
}

// Class generating the wrapper for type TF1::TF1FunctorPointer
// signature to use in the veto file: TF1::TF1FunctorPointer
struct JlTF1_TF1FunctorPointer: public Wrapper {

  JlTF1_TF1FunctorPointer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TF1::TF1FunctorPointer (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TF1.h:228:11
    jlcxx::TypeWrapper<TF1::TF1FunctorPointer>  t = jlModule.add_type<TF1::TF1FunctorPointer>("TF1!TF1FunctorPointer");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TF1::TF1FunctorPointer>>(new jlcxx::TypeWrapper<TF1::TF1FunctorPointer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for TF1::TF1FunctorPointer * TF1::TF1FunctorPointer::Clone() (" __HERE__ ")");
    // signature to use in the veto list: TF1::TF1FunctorPointer * TF1::TF1FunctorPointer::Clone()
    // defined in /home/pgras/.julia/conda/3/include/TF1.h:230:36
    t.method("Clone", static_cast<TF1::TF1FunctorPointer * (TF1::TF1FunctorPointer::*)()  const>(&TF1::TF1FunctorPointer::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TF1::TF1FunctorPointer>> type_;
};
std::shared_ptr<Wrapper> newJlTF1_TF1FunctorPointer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTF1_TF1FunctorPointer(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TFormula> : std::false_type { };
  template<> struct DefaultConstructible<TFormula> : std::false_type { };
template<> struct SuperType<TFormula> { typedef TNamed type; };
}

// Class generating the wrapper for type TFormula
// signature to use in the veto file: TFormula
struct JlTFormula: public Wrapper {

  JlTFormula(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TFormula (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TFormula.h:86:7
    jlcxx::TypeWrapper<TFormula>  t = jlModule.add_type<TFormula>("TFormula",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TFormula>>(new jlcxx::TypeWrapper<TFormula>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TFormula>> type_;
};
std::shared_ptr<Wrapper> newJlTFormula(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTFormula(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TMethodCall> : std::false_type { };
  template<> struct DefaultConstructible<TMethodCall> : std::false_type { };
template<> struct SuperType<TMethodCall> { typedef TObject type; };
}

// Class generating the wrapper for type TMethodCall
// signature to use in the veto file: TMethodCall
struct JlTMethodCall: public Wrapper {

  JlTMethodCall(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TMethodCall (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TMethodCall.h:37:7
    jlcxx::TypeWrapper<TMethodCall>  t = jlModule.add_type<TMethodCall>("TMethodCall",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TMethodCall>>(new jlcxx::TypeWrapper<TMethodCall>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TMethodCall>> type_;
};
std::shared_ptr<Wrapper> newJlTMethodCall(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTMethodCall(module));
}

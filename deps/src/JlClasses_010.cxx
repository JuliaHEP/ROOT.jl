// this file was auto-generated by wrapit v1.6.0
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TStdExceptionHandler> : std::false_type { };
  template<> struct DefaultConstructible<TStdExceptionHandler> : std::false_type { };
}

// Class generating the wrapper for type TStdExceptionHandler
// signature to use in the veto file: TStdExceptionHandler
struct JlTStdExceptionHandler: public Wrapper {

  JlTStdExceptionHandler(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TStdExceptionHandler (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TSysEvtHandler.h:172:7
    jlcxx::TypeWrapper<TStdExceptionHandler>  t = jlModule.add_type<TStdExceptionHandler>("TStdExceptionHandler");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TStdExceptionHandler>>(new jlcxx::TypeWrapper<TStdExceptionHandler>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TStdExceptionHandler>> type_;
};
std::shared_ptr<Wrapper> newJlTStdExceptionHandler(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTStdExceptionHandler(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TTime> : std::false_type { };
  template<> struct DefaultConstructible<TTime> : std::false_type { };
}

// Class generating the wrapper for type TTime
// signature to use in the veto file: TTime
struct JlTTime: public Wrapper {

  JlTTime(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTime (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TTime.h:27:7
    jlcxx::TypeWrapper<TTime>  t = jlModule.add_type<TTime>("TTime");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTime>>(new jlcxx::TypeWrapper<TTime>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTime>> type_;
};
std::shared_ptr<Wrapper> newJlTTime(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTime(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<FILE> : std::false_type { };
  template<> struct DefaultConstructible<FILE> : std::false_type { };
}

// Class generating the wrapper for type FILE
// signature to use in the veto file: FILE
struct JlFILE: public Wrapper {

  JlFILE(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type FILE (" __HERE__ ")");
    // defined in /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h:49:8
    jlcxx::TypeWrapper<FILE>  t = jlModule.add_type<FILE>("FILE");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<FILE>>(new jlcxx::TypeWrapper<FILE>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<FILE>> type_;
};
std::shared_ptr<Wrapper> newJlFILE(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlFILE(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TInetAddress> : std::false_type { };
  template<> struct DefaultConstructible<TInetAddress> : std::false_type { };
template<> struct SuperType<TInetAddress> { typedef TObject type; };
}

// Class generating the wrapper for type TInetAddress
// signature to use in the veto file: TInetAddress
struct JlTInetAddress: public Wrapper {

  JlTInetAddress(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TInetAddress (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TInetAddress.h:36:7
    jlcxx::TypeWrapper<TInetAddress>  t = jlModule.add_type<TInetAddress>("TInetAddress",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TInetAddress>>(new jlcxx::TypeWrapper<TInetAddress>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TInetAddress>> type_;
};
std::shared_ptr<Wrapper> newJlTInetAddress(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTInetAddress(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TApplicationImp> : std::false_type { };
  template<> struct DefaultConstructible<TApplicationImp> : std::false_type { };
}

// Class generating the wrapper for type TApplicationImp
// signature to use in the veto file: TApplicationImp
struct JlTApplicationImp: public Wrapper {

  JlTApplicationImp(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TApplicationImp (" __HERE__ ")");
    // defined in /home/pgras/.julia/artifacts/a4f6424ccb8f5188e250f447149860af999a56a0/include/TApplicationImp.h:29:7
    jlcxx::TypeWrapper<TApplicationImp>  t = jlModule.add_type<TApplicationImp>("TApplicationImp");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TApplicationImp>>(new jlcxx::TypeWrapper<TApplicationImp>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TApplicationImp>> type_;
};
std::shared_ptr<Wrapper> newJlTApplicationImp(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTApplicationImp(module));
}

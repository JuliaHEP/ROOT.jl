# Reexport from CxxWrap:
export CxxPtr, ConstCxxPtr, CxxRef, ConstCxxRef

# Export type aliases used in the documentation
export ByCopy, ByConstRef1, ByRef1, ByConstPtr1, ByPtr1, ByConstRef2, ByRef2, ByConstPtr2, ByPtr2

# Wrapper of @doc that catches exception
macro trydoc(doc, entity)
    sentity = string(entity)
    quote
        try
            @doc $(esc(doc)) $entity
        catch e
            if haskey(ENV, "ROOTDOC_DEBUG")
               @warn("Error when setting documentation for " * $sentity * ": " * sprint(showerror, e) * ".")
            end
        end
    end
end

# Wrapper to catch error on expr resulting in an unexpected dispatch
macro trydoc(expr)
    sexpr = string(expr)
    quote
        if haskey(ENV, "ROOTDOC_DEBUG")
           @warn("Error when setting documentation for " * $sexpr * ".")
        end
    end
end

######################################################################
# Type aliases used in the documentation

"""
    ByCopy{T}

Alias for Union{T, ConstCxxRef{T}, CxxRef{T}}. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type passed by copy. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByCopy{T} = Union{T, CxxRef{T}, ConstCxxRef{T}}

"""
    ByConstRef1{T}

Alias for Union{T, ConstCxxRef{<:T}, CxxRef{<:T}}. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type passed by reference. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByConstRef1{T} = Union{T, CxxRef{<:T}, ConstCxxRef{<:T}}


"""
    ByRef1{T}

Alias for `Union{T, ConstCxxRef{<:T}, CxxRef{<:T}}`. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type passed by reference. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByRef1{T} = Union{T, ConstCxxRef{<:T}, CxxRef{<:T}}

"""
    ByConstPtr1{T}

Alias for `Union{Ptr{Nothing}, ConstCxxPtr{<:T}, CxxPtr{<:T}}`. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type  passed by pointer. It allows to pass `C_NULL` or an object pointer, returned by another C++ function wrapper created with `ConstCxxPtr(obj)` with `obj::T`.
"""
const ByConstPtr1{T} = Union{Ptr{Nothing}, ConstCxxPtr{<:T}, CxxPtr{<:T}}

"""
    ByPtr1{T}

Alias for `Union{CxxPtr{<:T}, Ptr{Nothing}}`. This type is used in the Julia wrappers of C++ functions for arguments passed by pointer. It allows to pass C_NULL or an object pointer, returned by another C++ function wrapper created with `CxxPtr(obj)` with obj::T..
"""
const ByPtr1{T} = Union{CxxPtr{<:T}, Ptr{Nothing}}

"""
    ByConstRef2{T}

Alias for Union{T, Ref{T}}, with `ConstCxxRef` and `CxxRef` defined in the `CxxWrap` module. This type is used in the Julia wrappers of C++ functions for arguments of isbit type passed by reference.
"""
const ByConstRef2{T} = Union{T, Ref{T}}

"""
    ByRef2{T}

Alias for Union{T, Ptr{T}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}, with `ConstCxxRef` and `CxxRef` defined in the `CxxWrap` module. This type is used in the Julia wrappers of C++ functions for arguments of isbit type passed by reference.
"""
const ByRef2{T} = Union{T, Ptr{T}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}


"""
    ByConstPtr2{T}

Alias for  Union{Ptr{Nothing}, Ref{T}, Array{T}}, with ConstCxxPtr and CxxPtr defined in the CxxWrap module. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type  passed by pointer. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByConstPtr2{T} = Union{Ptr{Nothing}, Ref{T}, Array{T}}

"""
    ByPtr2{T}

Alias for `Union{T, Ptr{T}, Ptr{Nothing}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}`. This type is used in the Julia wrappers of C++ functions for arguments passed by pointer. It allows to pass an object pointer returned by another C++ function wrapper or C_NULL. To pass an object instance obj, uses `CxxWrap.CxxPtr(obj)`.
"""
const ByPtr2{T} = Union{T, Ptr{T}, Ptr{Nothing}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}

#
######################################################################

######################################################################
# Documentation of ROOT types

# Wrapper of TClass
@trydoc raw"""
    ROOT.TClass

[TClass](@ref) instances represent classes, structs and namespaces in the [ROOT](@ref) type system.

[TClass](@ref) instances are created starting from different sources of information:

1. [TStreamerInfo](@ref) instances saved in a [ROOT](@ref) file which is opened. This is called in jargon an <i>emulated [TClass](@ref)</i>.
2. From [TProtoClass](@ref) instances saved in a [ROOT](@ref) pcm file created by the dictionary generator and the dictionary itself.
3. From a lookup in the AST built by cling.

If a [TClass](@ref) instance is built through the mechanisms 1. and 2., it does not contain information about methods of the class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary to [ROOT](@ref) to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the [TClass](@ref) instance.

In order to retrieve a [TClass](@ref) instance from the type system, a query can be executed as follows through the static [TClass!GetClass](@ref) method:

    auto myClassTClass_0 = TClass!GetClass("myClass");
    auto myClassTClass_1 = TClass!GetClass<myClass>();
    auto myClassTClass_2 = TClass!GetClass(myClassTypeInfo);

(C++ version of the code)

The name of classes is crucial for [ROOT](@ref). A careful procedure of *name normalization* is carried out for each and every class. A *normalized name* is a valid C++ class name. In order to access the name of a class within the [ROOT](@ref) type system, the method [TClass!GetName()](@ref) can be used.

Related functions: [`AddImplFile`](@ref), [`AddInstance`](@ref), [`AdoptMemberStreamer`](@ref), [`AdoptReferenceProxy`](@ref), [`AdoptSchemaRules`](@ref), [`AdoptStreamer`](@ref), [`Browse`](@ref), [`BuildEmulatedRealData`](@ref), [`BuildRealData`](@ref), [`CalculateStreamerOffset`](@ref), [`CallShowMembers`](@ref), [`CanIgnoreTObjectStreamer`](@ref), [`CanSplit`](@ref), [`ClassProperty`](@ref), [`Clone`](@ref), [`CopyCollectionProxy`](@ref), [`DeleteArray`](@ref), [`Destructor`](@ref), [`Draw`](@ref), [`Dump`](@ref), [`DynamicCast`](@ref), [`EscapeChars`](@ref), [`FindConversionStreamerInfo`](@ref), [`FindStreamerInfoAbstractEmulated`](@ref), [`FindStreamerInfo`](@ref), [`ForceReload`](@ref), [`GetActualClass`](@ref), [`GetBaseClassOffset`](@ref), [`GetBaseClass`](@ref), [`GetBaseDataMember`](@ref), [`GetCheckSum`](@ref), [`GetClassInfo`](@ref), [`GetClassMethodWithPrototype`](@ref), [`GetClassMethod`](@ref), [`GetClassSize`](@ref), [`GetClassVersion`](@ref), [`GetCollectionProxy`](@ref), [`GetCollectionType`](@ref), [`GetContextMenuTitle`](@ref), [`GetConvStreamerFunc`](@ref), [`GetConversionStreamerInfo`](@ref), [`GetCurrentStreamerInfo`](@ref), [`GetDataMemberOffset`](@ref), [`GetDataMember`](@ref), [`GetDeclFileLine`](@ref), [`GetDeclFileName`](@ref), [`GetDeleteArray`](@ref), [`GetDelete`](@ref), [`GetDestructor`](@ref), [`GetDirectoryAutoAdd`](@ref), [`GetFunctionTemplate`](@ref), [`GetHeapInstanceCount`](@ref), [`GetImplFileLine`](@ref), [`GetImplFileName`](@ref), [`GetInstanceCount`](@ref), [`GetIsAProxy`](@ref), [`GetLastReadInfo`](@ref), [`GetListOfAllPublicDataMembers`](@ref), [`GetListOfAllPublicMethods`](@ref), [`GetListOfBases`](@ref), [`GetListOfDataMembers`](@ref), [`GetListOfEnums`](@ref), [`GetListOfFunctionTemplates`](@ref), [`GetListOfMethodOverloads`](@ref), [`GetListOfMethods`](@ref), [`GetListOfRealData`](@ref), [`GetListOfUsingDataMembers`](@ref), [`GetMenuItems`](@ref), [`GetMenuList`](@ref), [`GetMerge`](@ref), [`GetMethodAllAny`](@ref), [`GetMethodAny`](@ref), [`GetMethodWithPrototype`](@ref), [`GetMethod`](@ref), [`GetMissingDictionaries`](@ref), [`GetNdata`](@ref), [`GetNewArray`](@ref), [`GetNew`](@ref), [`GetNmethods`](@ref), [`GetPersistentRef`](@ref), [`GetRealData`](@ref), [`GetReferenceProxy`](@ref), [`GetResetAfterMerge`](@ref), [`GetSchemaRules`](@ref), [`GetSharedLibs`](@ref), [`GetShowMembersWrapper`](@ref), [`GetState`](@ref), [`GetStreamerFunc`](@ref), [`GetStreamerInfoAbstractEmulated`](@ref), [`GetStreamerInfo`](@ref), [`GetStreamerInfos`](@ref), [`GetStreamer`](@ref), [`GetTypeInfo`](@ref), [`HasConsistentHashMember`](@ref), [`HasCustomStreamerMember`](@ref), [`HasDataMemberInfo`](@ref), [`HasDefaultConstructor`](@ref), [`HasDictionary`](@ref), [`HasInterpreterInfoInMemory`](@ref), [`HasInterpreterInfo`](@ref), [`HasLocalHashMember`](@ref), [`IgnoreTObjectStreamer`](@ref), [`InheritsFrom`](@ref), [`InterpretedShowMembers`](@ref), [`IsFolder`](@ref), [`IsForeign`](@ref), [`IsLoaded`](@ref), [`IsStartingWithTObject`](@ref), [`IsSyntheticPair`](@ref), [`IsTObject`](@ref), [`IsVersioned`](@ref), [`MakeCustomMenuList`](@ref), [`MatchLegacyCheckSum`](@ref), [`Move`](@ref), [`NewArray`](@ref), [`NewObjectArray`](@ref), [`NewObject`](@ref), [`New`](@ref), [`PostLoadCheck`](@ref), [`Property`](@ref), [`ReadBuffer`](@ref), [`RegisterStreamerInfo`](@ref), [`RemoveStreamerInfo`](@ref), [`ReplaceWith`](@ref), [`ResetCaches`](@ref), [`ResetClassInfo`](@ref), [`ResetInstanceCount`](@ref), [`ResetMenuList`](@ref), [`SetCanSplit`](@ref), [`SetCollectionProxy`](@ref), [`SetContextMenuTitle`](@ref), [`SetConvStreamerFunc`](@ref), [`SetCurrentStreamerInfo`](@ref), [`SetDeclFile`](@ref), [`SetDeleteArray`](@ref), [`SetDelete`](@ref), [`SetDestructor`](@ref), [`SetDirectoryAutoAdd`](@ref), [`SetGlobalIsA`](@ref), [`SetImplFileName`](@ref), [`SetLastReadInfo`](@ref), [`SetMemberStreamer`](@ref), [`SetMerge`](@ref), [`SetNewArray`](@ref), [`SetNew`](@ref), [`SetResetAfterMerge`](@ref), [`SetStreamerFunc`](@ref), [`SetStreamerInfo`](@ref), [`SetUnloaded`](@ref), [`Size`](@ref), [`Store`](@ref), [`Streamer`](@ref), [`TClass!AddClassToDeclIdMap`](@ref), [`TClass!AddClass`](@ref), [`TClass!AddRule`](@ref), [`TClass!AutoBrowse`](@ref), [`TClass!GetClass`](@ref), [`TClass!GetDict`](@ref), [`TClass!HasDictionarySelection`](@ref), [`TClass!IsCallingNew`](@ref), [`TClass!LoadClass`](@ref), [`TClass!Load`](@ref), [`TClass!ReadRules`](@ref), [`TClass!RemoveClassDeclId`](@ref), [`TClass!RemoveClass`](@ref), [`TClass`](@ref), [`WriteBuffer`](@ref), [`ls`](@ref)
""" TClass

# Wrapper of TVirtualIsAProxy
@trydoc raw"""
    ROOT.TVirtualIsAProxy





Related functions: [`SetClass`](@ref), [`paren`](@ref)
""" TVirtualIsAProxy

# Wrapper of TNamed
@trydoc raw"""
    ROOT.TNamed

The [TNamed](@ref) class is the base class for all named [ROOT](@ref) classes.

A [TNamed](@ref) contains the essential elements (name, title) to identify a derived object in containers, directories and files. Most member functions defined in this base class are in general overridden by the derived classes.

Related functions: [`Clear`](@ref), [`Clone`](@ref), [`Compare`](@ref), [`Copy`](@ref), [`FillBuffer`](@ref), [`GetName`](@ref), [`GetTitle`](@ref), [`Hash`](@ref), [`IsA`](@ref), [`IsSortable`](@ref), [`Print`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetTitle`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TNamed!Class_Name`](@ref), [`TNamed!Class_Version`](@ref), [`TNamed!Class`](@ref), [`TNamed!DeclFileName`](@ref), [`TNamed`](@ref), [`assign`](@ref), [`ls`](@ref)
""" TNamed

# Wrapper of TVersionCheck
@trydoc raw"""
    ROOT.TVersionCheck

Used to check if the shared library or plugin is compatible with the current version of [ROOT](@ref).



Related functions: [`TVersionCheck`](@ref)
""" TVersionCheck

# Wrapper of TObject
@trydoc raw"""
    ROOT.TObject

Mother of all [ROOT](@ref) objects.

The [TObject](@ref) class provides default behaviour and protocol for all objects in the [ROOT](@ref) system. It provides protocol for object I/O, error handling, sorting, inspection, printing, drawing, etc. Every object which inherits from [TObject](@ref) can be stored in the [ROOT](@ref) collection classes.

[TObject](@ref)'s bits can be used as flags, bits 0 - 13 and 24-31 are reserved as global_ bits while bits 14 - 23 can be used in different class hierarchies (watch out for overlaps).

Related functions: [`AbstractMethod`](@ref), [`AppendPad`](@ref), [`Browse`](@ref), [`CheckedHash`](@ref), [`ClassName`](@ref), [`Clear`](@ref), [`Clone`](@ref), [`Compare`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`DistancetoPrimitive`](@ref), [`DrawClass`](@ref), [`DrawClone`](@ref), [`Draw`](@ref), [`Dump`](@ref), [`Error`](@ref), [`ExecuteEvent`](@ref), [`Execute`](@ref), [`Fatal`](@ref), [`FindObject`](@ref), [`GetDrawOption`](@ref), [`GetIconName`](@ref), [`GetName`](@ref), [`GetObjectInfo`](@ref), [`GetOption`](@ref), [`GetTitle`](@ref), [`GetUniqueID`](@ref), [`HandleTimer`](@ref), [`HasInconsistentHash`](@ref), [`Hash`](@ref), [`Info`](@ref), [`InheritsFrom`](@ref), [`Inspect`](@ref), [`InvertBit`](@ref), [`IsA`](@ref), [`IsDestructed`](@ref), [`IsEqual`](@ref), [`IsFolder`](@ref), [`IsOnHeap`](@ref), [`IsSortable`](@ref), [`IsZombie`](@ref), [`MayNotUse`](@ref), [`Notify`](@ref), [`Obsolete`](@ref), [`Paint`](@ref), [`Pop`](@ref), [`Print`](@ref), [`Read`](@ref), [`RecursiveRemove`](@ref), [`ResetBit`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SetBit`](@ref), [`SetDrawOption`](@ref), [`SetUniqueID`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`SysError`](@ref), [`TObject!Class_Name`](@ref), [`TObject!Class_Version`](@ref), [`TObject!Class`](@ref), [`TObject!DeclFileName`](@ref), [`TObject!GetDtorOnly`](@ref), [`TObject!GetObjectStat`](@ref), [`TObject!SetDtorOnly`](@ref), [`TObject!SetObjectStat`](@ref), [`TObject`](@ref), [`TestBit`](@ref), [`TestBits`](@ref), [`UseCurrentStyle`](@ref), [`Warning`](@ref), [`Write`](@ref), [`assign`](@ref), [`delete`](@ref), [`deletearray`](@ref), [`ls`](@ref), [`new`](@ref), [`newarray`](@ref)
""" TObject

# Wrapper of TBrowser
@trydoc raw"""
    ROOT.TBrowser

Using a [TBrowser](@ref) one can browse all [ROOT](@ref) objects.

It shows in a list on the left side of the window all browsable [ROOT](@ref) classes. Selecting one of the classes displays, in the icon-box on the right side, all objects in the class. Selecting one of the objects in the icon-box, will place all browsable objects in a new list and draws the contents of the selected class in the icon-box. And so on....

![https://root.cern/doc/v636/base_browser.png](https://root.cern/doc/v636/base_browser.png)

###Since

ROOT version 6.24/00

[TBrowser](@ref) invokes by default the Web-based ROOT file browser [RBrowser]([ROOT!RBrowser](@ref)) To change this behaviour, and invoke the standard [TBrowser](@ref), one should put the following directive in the `.rootrc` file: 

    Browser.Name:      TRootBrowser

(C++ version of the code)

Related functions: [`AddCheckBox`](@ref), [`Add`](@ref), [`BrowseObject`](@ref), [`CheckObjectItem`](@ref), [`Create`](@ref), [`Destructor`](@ref), [`ExecPlugin`](@ref), [`ExecuteDefaultAction`](@ref), [`GetBrowserImp`](@ref), [`GetContextMenu`](@ref), [`GetDrawOption`](@ref), [`GetRefreshFlag`](@ref), [`GetSelected`](@ref), [`Iconify`](@ref), [`RecursiveRemove`](@ref), [`Refresh`](@ref), [`RemoveCheckBox`](@ref), [`SetBrowserImp`](@ref), [`SetDrawOption`](@ref), [`SetRefreshFlag`](@ref), [`SetSelected`](@ref), [`SetStatusText`](@ref), [`Show`](@ref), [`StartEmbedding`](@ref), [`StopEmbedding`](@ref), [`TBrowser`](@ref)
""" TBrowser

# Wrapper of TObjArray
@trydoc raw"""
    ROOT.TObjArray

An array of TObjects.

The array expands automatically when objects are added (shrinking can be done by hand using [Expand()](@ref), how nice to have meaningful names -:)). Use operator[] to have "real" array behaviour.

Note on ownership and copy: By default the [TObjArray](@ref) does not own the objects it points to and will not delete them unless explicitly asked (via a call to the Delete member function). To assign ownership of the content to the array, call: 

    myarr->SetOwner(kTRUE);

(C++ version of the code)

 When the array owns its content a call to Clear or the deletion of the array itself will lead to the deletion of its contents.

You can either make a shallow copy of the array: 

     otherarr = new TObjArray(*myarr);
    *otherarr = *myarr;

(C++ version of the code)

 in which case ownership (if any) is not transfered but the other array points to the same object as the original array. Note that if the content of either array is deleted the other array is not notified in any way (i.e. still points to the now deleted objects).

You can also make a deep copy of the array: 

    otherarr = (TObjArray*)myarr->Clone();

(C++ version of the code)

 in which case the array and the content are both duplicated (i.e. otherarr and myarr do not point to the same objects). If myarr is set to the be the owner of its content, otherarr will also be set to the owner of its own content.

Related functions: [`AddAfter`](@ref), [`AddAtAndExpand`](@ref), [`AddAtFree`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Before`](@ref), [`BinarySearch`](@ref), [`Clear`](@ref), [`Compress`](@ref), [`Delete`](@ref), [`Expand`](@ref), [`FindObject`](@ref), [`First`](@ref), [`GetEntriesFast`](@ref), [`GetEntriesUnsafe`](@ref), [`GetEntries`](@ref), [`GetLast`](@ref), [`GetObjectRef`](@ref), [`IndexOf`](@ref), [`IsEmpty`](@ref), [`Last`](@ref), [`LowerBound`](@ref), [`MakeIterator`](@ref), [`Randomize`](@ref), [`RecursiveRemove`](@ref), [`RemoveAt`](@ref), [`RemoveRange`](@ref), [`Remove`](@ref), [`SetLast`](@ref), [`Sort`](@ref), [`TObjArray`](@ref), [`UncheckedAt`](@ref), [`assign`](@ref)
""" TObjArray

# Wrapper of TBuffer
@trydoc raw"""
    ROOT.TBuffer

Buffer base class used for serializing objects.



Related functions: [`ApplySequenceVecPtr`](@ref), [`ApplySequence`](@ref), [`AutoExpand`](@ref), [`BufferSize`](@ref), [`Buffer`](@ref), [`ByteSwapBuffer`](@ref), [`CheckByteCount`](@ref), [`CheckObject`](@ref), [`ClassBegin`](@ref), [`ClassEnd`](@ref), [`ClassMember`](@ref), [`DecrementLevel`](@ref), [`DetachBuffer`](@ref), [`Expand`](@ref), [`ForceWriteInfoClones`](@ref), [`ForceWriteInfo`](@ref), [`GetBufferDisplacement`](@ref), [`GetBufferVersion`](@ref), [`GetCurrent`](@ref), [`GetInfo`](@ref), [`GetLastProcessID`](@ref), [`GetMapCount`](@ref), [`GetMappedObject`](@ref), [`GetParent`](@ref), [`GetPidOffset`](@ref), [`GetReAllocFunc`](@ref), [`GetTRefExecId`](@ref), [`GetVersionOwner`](@ref), [`IncrementLevel`](@ref), [`InitMap`](@ref), [`IsA`](@ref), [`IsReading`](@ref), [`IsWriting`](@ref), [`Length`](@ref), [`MapObject`](@ref), [`PeekDataCache`](@ref), [`PopDataCache`](@ref), [`PushDataCache`](@ref), [`ReadArrayDouble32`](@ref), [`ReadArrayFloat16`](@ref), [`ReadArray`](@ref), [`ReadBool`](@ref), [`ReadBuf`](@ref), [`ReadCharP`](@ref), [`ReadCharStar`](@ref), [`ReadChar`](@ref), [`ReadClassBuffer`](@ref), [`ReadClassEmulated`](@ref), [`ReadClass`](@ref), [`ReadClones`](@ref), [`ReadDouble32`](@ref), [`ReadDouble`](@ref), [`ReadFastArrayDouble32`](@ref), [`ReadFastArrayFloat16`](@ref), [`ReadFastArrayString`](@ref), [`ReadFastArrayWithFactor`](@ref), [`ReadFastArrayWithNbits`](@ref), [`ReadFastArray`](@ref), [`ReadFloat16`](@ref), [`ReadFloat`](@ref), [`ReadInt`](@ref), [`ReadLong64`](@ref), [`ReadLong`](@ref), [`ReadObjectAny`](@ref), [`ReadObject`](@ref), [`ReadProcessID`](@ref), [`ReadShort`](@ref), [`ReadStaticArrayDouble32`](@ref), [`ReadStaticArrayFloat16`](@ref), [`ReadStaticArray`](@ref), [`ReadStdString`](@ref), [`ReadString`](@ref), [`ReadTString`](@ref), [`ReadUChar`](@ref), [`ReadUInt`](@ref), [`ReadULong64`](@ref), [`ReadULong`](@ref), [`ReadUShort`](@ref), [`ReadVersionForMemberWise`](@ref), [`ReadVersionNoCheckSum`](@ref), [`ReadVersion`](@ref), [`ReadWithFactor`](@ref), [`ReadWithNbits`](@ref), [`ResetMap`](@ref), [`Reset`](@ref), [`SetBufferDisplacement`](@ref), [`SetBufferOffset`](@ref), [`SetBuffer`](@ref), [`SetByteCount`](@ref), [`SetParent`](@ref), [`SetPidOffset`](@ref), [`SetReAllocFunc`](@ref), [`SetReadMode`](@ref), [`SetReadParam`](@ref), [`SetStreamerElementNumber`](@ref), [`SetWriteMode`](@ref), [`SetWriteParam`](@ref), [`SkipObjectAny`](@ref), [`SkipVersion`](@ref), [`StreamObject`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TBuffer!Class_Name`](@ref), [`TBuffer!Class_Version`](@ref), [`TBuffer!Class`](@ref), [`TBuffer!DeclFileName`](@ref), [`TBuffer!GetClass`](@ref), [`TBuffer`](@ref), [`TagStreamerInfo`](@ref), [`WriteArrayDouble32`](@ref), [`WriteArrayFloat16`](@ref), [`WriteArray`](@ref), [`WriteBool`](@ref), [`WriteBuf`](@ref), [`WriteCharP`](@ref), [`WriteCharStar`](@ref), [`WriteChar`](@ref), [`WriteClassBuffer`](@ref), [`WriteClass`](@ref), [`WriteClones`](@ref), [`WriteDouble32`](@ref), [`WriteDouble`](@ref), [`WriteFastArrayDouble32`](@ref), [`WriteFastArrayFloat16`](@ref), [`WriteFastArrayString`](@ref), [`WriteFastArray`](@ref), [`WriteFloat16`](@ref), [`WriteFloat`](@ref), [`WriteInt`](@ref), [`WriteLong64`](@ref), [`WriteLong`](@ref), [`WriteObjectAny`](@ref), [`WriteObject`](@ref), [`WriteProcessID`](@ref), [`WriteShort`](@ref), [`WriteStdString`](@ref), [`WriteString`](@ref), [`WriteTString`](@ref), [`WriteUChar`](@ref), [`WriteUInt`](@ref), [`WriteULong64`](@ref), [`WriteULong`](@ref), [`WriteUShort`](@ref), [`WriteVersionMemberWise`](@ref), [`WriteVersion`](@ref)
""" TBuffer

# Wrapper of TVectorT
@trydoc raw"""
    ROOT.TVectorT

[TVectorT](@ref).

Template class of Vectors in the linear algebra package.

See the [Matrix Linear Algebra](@ref) page for the documentation of the linear algebra package

Unless otherwise specified, vector indices always thestart with 0, spanning up to the specified limit-1.

For (n) vectors where n <= kSizeMax (5 currently) storage space is available on the stack, thus avoiding expensive allocation/ deallocation of heap space . However, this introduces of course kSizeMax overhead for each vector object . If this is an issue recompile with a new appropriate value (>=0) for kSizeMax

Another way to assign and store vector data is through Use see for instance stressLinear.cxx file .

Note that Constructors/assignments exists for all different matrix views

For usage examples see `$ROOTSYS/test/stressLinear.cxx`

Related functions: [`Abs`](@ref), [`AddSomeConstant`](@ref), [`Add`](@ref), [`Apply`](@ref), [`Base.:(!=)`](@ref), [`Base.:(<)`](@ref), [`Base.:(<=)`](@ref), [`Base.:(==)`](@ref), [`Base.:(>)`](@ref), [`Base.:(>=)`](@ref), [`Base.getindex`](@ref), [`Class`](@ref), [`Clear`](@ref), [`Draw`](@ref), [`GetLwb`](@ref), [`GetMatrixArray`](@ref), [`GetNoElements`](@ref), [`GetNrows`](@ref), [`GetSub`](@ref), [`GetUpb`](@ref), [`Invalidate`](@ref), [`Invert`](@ref), [`IsOwner`](@ref), [`IsValid`](@ref), [`MakeValid`](@ref), [`MatchesNonZeroPattern`](@ref), [`Max`](@ref), [`Min`](@ref), [`NonZeros`](@ref), [`Norm1`](@ref), [`Norm2Sqr`](@ref), [`NormInf`](@ref), [`Print`](@ref), [`Randomize`](@ref), [`ResizeTo`](@ref), [`SelectNonZeros`](@ref), [`SetElements`](@ref), [`SetSub`](@ref), [`Shift`](@ref), [`SomePositive`](@ref), [`Sqr`](@ref), [`Sqrt`](@ref), [`Sum`](@ref), [`TVectorT`](@ref), [`Use`](@ref), [`Zero`](@ref), [`add!`](@ref), [`assign`](@ref), [`mult!`](@ref), [`paren`](@ref), [`sub!`](@ref)
""" TVectorT

# Wrapper of TCollection
@trydoc raw"""
    ROOT.TCollection

Collection abstract base class.

This class describes the base protocol all collection classes have to implement. The [ROOT](@ref) collection classes always store pointers to objects that inherit from [TObject](@ref). They never adopt the objects. Therefore, it is the user's responsibility to take care of deleting the actual objects once they are not needed anymore. In exceptional cases, when the user is 100% sure nothing else is referencing the objects in the collection, one can delete all objects and the collection at the same time using the [Delete()](@ref) function.

Collections can be iterated using an iterator object (see [TIterator](@ref)). Depending on the concrete collection class there may be some additional methods of iterating. See the respective classes.

[TCollection](@ref) inherits from [TObject](@ref) since we want to be able to have collections of collections.

In a later release the collections may become templatized.

Related functions: [`AddAll`](@ref), [`AddVector`](@ref), [`Add`](@ref), [`AssertClass`](@ref), [`Browse`](@ref), [`Capacity`](@ref), [`Clear`](@ref), [`Clone`](@ref), [`Compare`](@ref), [`Contains`](@ref), [`Delete`](@ref), [`Draw`](@ref), [`Dump`](@ref), [`FindObject`](@ref), [`GetEntries`](@ref), [`GetName`](@ref), [`GetObjectRef`](@ref), [`GetSize`](@ref), [`GrowBy`](@ref), [`Hash`](@ref), [`IsArgNull`](@ref), [`IsEmpty`](@ref), [`IsFolder`](@ref), [`IsOwner`](@ref), [`IsSortable`](@ref), [`IsUsingRWLock`](@ref), [`MakeIterator`](@ref), [`MakeReverseIterator`](@ref), [`Notify`](@ref), [`Paint`](@ref), [`Print`](@ref), [`RecursiveRemove`](@ref), [`RemoveAll`](@ref), [`Remove`](@ref), [`SetCurrentCollection`](@ref), [`SetName`](@ref), [`SetOwner`](@ref), [`TCollection!EmptyGarbageCollection`](@ref), [`TCollection!GarbageCollect`](@ref), [`TCollection!GetCurrentCollection`](@ref), [`TCollection!StartGarbageCollection`](@ref), [`UseRWLock`](@ref), [`Write`](@ref), [`ls`](@ref), [`paren`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TCollection

# Wrapper of TString
@trydoc raw"""
    ROOT.TString

Basic string class.

Cannot be stored in a [TCollection](@ref)... use [TObjString](@ref) instead.

The underlying string is stored as a char* that can be accessed via [TString!Data()](@ref). [TString](@ref) provides Short String Optimization (SSO) so that short strings (<15 on 64-bit and <11 on 32-bit) are contained in the [TString](@ref) internal data structure without the need for mallocing the required space.

Substring operations are provided by the [TSubString](@ref) class, which holds a reference to the original string and its data, along with the offset and length of the substring. To retrieve the substring as a [TString](@ref), construct a [TString](@ref) from it, eg: 

    root [0] TString s("hello world")
    root [1] TString s2( s(0,5) )
    root [2] s2
    (class TString)"hello"

(C++ version of the code)

Related functions: [`Append`](@ref), [`Atof`](@ref), [`Atoi`](@ref), [`Atoll`](@ref), [`Base.getindex`](@ref), [`BeginsWith`](@ref), [`Capacity`](@ref), [`Chop`](@ref), [`Clear`](@ref), [`CompareTo`](@ref), [`Contains`](@ref), [`Copy`](@ref), [`CountChar`](@ref), [`Data`](@ref), [`EndsWith`](@ref), [`EqualTo`](@ref), [`FillBuffer`](@ref), [`First`](@ref), [`Form`](@ref), [`GetSubString`](@ref), [`Gets`](@ref), [`Hash`](@ref), [`Index`](@ref), [`Insert`](@ref), [`IsA`](@ref), [`IsAlnum`](@ref), [`IsAlpha`](@ref), [`IsAscii`](@ref), [`IsBin`](@ref), [`IsDec`](@ref), [`IsDigit`](@ref), [`IsFloat`](@ref), [`IsHex`](@ref), [`IsInBaseN`](@ref), [`IsNull`](@ref), [`IsOct`](@ref), [`IsWhitespace`](@ref), [`Last`](@ref), [`Length`](@ref), [`MD5`](@ref), [`MaybeRegexp`](@ref), [`MaybeWildcard`](@ref), [`Prepend`](@ref), [`Puts`](@ref), [`ReadBuffer`](@ref), [`ReadFile`](@ref), [`ReadLine`](@ref), [`ReadString`](@ref), [`ReadToDelim`](@ref), [`ReadToken`](@ref), [`Remove`](@ref), [`ReplaceAll`](@ref), [`ReplaceSpecialCppChars`](@ref), [`Replace`](@ref), [`Resize`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Strip`](@ref), [`Swap`](@ref), [`TString!BaseConvert`](@ref), [`TString!Class_Name`](@ref), [`TString!Class_Version`](@ref), [`TString!Class`](@ref), [`TString!DeclFileName`](@ref), [`TString!Format`](@ref), [`TString!GetInitialCapacity`](@ref), [`TString!GetMaxWaste`](@ref), [`TString!GetResizeIncrement`](@ref), [`TString!Hash`](@ref), [`TString!InitialCapacity`](@ref), [`TString!Itoa`](@ref), [`TString!LLtoa`](@ref), [`TString!MaxWaste`](@ref), [`TString!ReadString`](@ref), [`TString!ResizeIncrement`](@ref), [`TString!UItoa`](@ref), [`TString!ULLtoa`](@ref), [`TString!WriteString`](@ref), [`TString`](@ref), [`ToLower`](@ref), [`ToUpper`](@ref), [`Tokenize`](@ref), [`View`](@ref), [`add!`](@ref), [`assign`](@ref), [`const char *`](@ref), [`paren`](@ref)
""" TString

# Wrapper of TSubString
@trydoc raw"""
    ROOT.TSubString

A zero length substring is legal.

It can thestart at any character. It is considered to be "pointing" to just before the character.

A "null" substring is a zero length substring that starts with the nonsense index kNPOS. It can be detected with the member function [IsNull()](@ref).

Related functions: [`Base.:!`](@ref), [`Base.getindex`](@ref), [`Data`](@ref), [`GetString`](@ref), [`IsNull`](@ref), [`Length`](@ref), [`Start`](@ref), [`TSubString`](@ref), [`ToLower`](@ref), [`ToUpper`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TSubString

# Wrapper of TRegexp
@trydoc raw"""
    ROOT.TRegexp

Regular expression class.

'^'             // thestart-of-line anchor
    '$'             // theend-of-line anchor
    '.'             // matches any character
    '['             // thestart a character class
    ']'             // theend a character class
    '^'             // negates character class if 1st character
    '*'             // Kleene closure (matches 0 or more)
    '+'             // Positive closure (1 or more)
    '?'             // Optional closure (0 or 1)

(C++ version of the code)

 Note that the '|' operator (union) is not supported, nor are parentheses (grouping). Therefore "a|b" does not match "a".

Standard classes like [:alnum:], [:alpha:], etc. are not supported, only [a-zA-Z], [^ntf] and so on.

Warning: The preferred way to use regular expressions is via std!regex. E.g., [Index()](@ref) functions may return incorrect result.

Related functions: [`Index`](@ref), [`IsA`](@ref), [`Status`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TRegexp!Class_Name`](@ref), [`TRegexp!Class_Version`](@ref), [`TRegexp!Class`](@ref), [`TRegexp!DeclFileName`](@ref), [`TRegexp`](@ref), [`assign`](@ref)
""" TRegexp

# Wrapper of TPRegexp
@trydoc raw"""
    ROOT.TPRegexp





Related functions: [`GetModifiers`](@ref), [`GetPattern`](@ref), [`IsA`](@ref), [`IsValid`](@ref), [`MatchB`](@ref), [`MatchS`](@ref), [`Match`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Substitute`](@ref), [`TPRegexp!Class_Name`](@ref), [`TPRegexp!Class_Version`](@ref), [`TPRegexp!Class`](@ref), [`TPRegexp!DeclFileName`](@ref), [`TPRegexp!GetThrowAtCompileError`](@ref), [`TPRegexp!SetThrowAtCompileError`](@ref), [`TPRegexp`](@ref), [`assign`](@ref)
""" TPRegexp

# Wrapper of TVirtualMutex
@trydoc raw"""
    ROOT.TVirtualMutex

This class implements a mutex interface.

The actual work is done via [TMutex](@ref) which is available as soon as the thread library is loaded.

and

[TLockGuard](@ref)

This class provides mutex resource management in a guaranteed and exception safe way. Use like this: 

    {
       TLockGuard guard(mutex);
       ... // do something
    }

(C++ version of the code)

 when guard goes out of scope the mutex is unlocked in the [TLockGuard](@ref) destructor. The exception mechanism takes care of calling the dtors of local_ objects so it is exception safe.

Related functions: [`Acquire`](@ref), [`CleanUp`](@ref), [`Factory`](@ref), [`IsA`](@ref), [`Lock`](@ref), [`Release`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualMutex!Class_Name`](@ref), [`TVirtualMutex!Class_Version`](@ref), [`TVirtualMutex!Class`](@ref), [`TVirtualMutex!DeclFileName`](@ref), [`TVirtualMutex`](@ref), [`TryLock`](@ref), [`UnLock`](@ref)
""" TVirtualMutex

# Wrapper of TLockGuard
@trydoc raw"""
    ROOT.TLockGuard





Related functions: [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TLockGuard!Class_Name`](@ref), [`TLockGuard!Class_Version`](@ref), [`TLockGuard!Class`](@ref), [`TLockGuard!DeclFileName`](@ref), [`TLockGuard`](@ref), [`UnLock`](@ref)
""" TLockGuard

# Wrapper of TIter
@trydoc raw"""
    ROOT.TIter





Related functions: [`Base.:(!=)`](@ref), [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`Begin`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TIter!End`](@ref), [`TIter`](@ref), [`assign`](@ref), [`inc!`](@ref), [`paren`](@ref)
""" TIter

# Wrapper of TIterator
@trydoc raw"""
    ROOT.TIterator

Iterator abstract base class.

This base class provides the interface for collection iterators.

Related functions: [`Base.:(!=)`](@ref), [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TIterator

# Wrapper of TIterCategory
@trydoc raw"""
    ROOT.TIterCategory





Related functions: [`Begin`](@ref), [`TIterCategory!End`](@ref), [`TIterCategory`](@ref)
""" TIterCategory

# Wrapper of TSeqCollection
@trydoc raw"""
    ROOT.TSeqCollection

Sequenceable collection abstract base class.

[TSeqCollection](@ref)'s have an ordering relation, i.e. there is a first and last element.

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Before`](@ref), [`First`](@ref), [`GetLast`](@ref), [`IndexOf`](@ref), [`IsSorted`](@ref), [`LastIndex`](@ref), [`Last`](@ref), [`Merge`](@ref), [`RemoveAfter`](@ref), [`RemoveAt`](@ref), [`RemoveBefore`](@ref), [`RemoveFirst`](@ref), [`RemoveLast`](@ref), [`TSeqCollection!ObjCompare`](@ref), [`TSeqCollection!QSort`](@ref), [`UnSort`](@ref)
""" TSeqCollection

# Wrapper of TList
@trydoc raw"""
    ROOT.TList

A doubly linked list.

All classes inheriting from [TObject](@ref) can be inserted in a [TList](@ref). Before being inserted into the list the object pointer is wrapped in a [TObjLink](@ref) object which contains, besides the object pointer also a previous and next pointer.

There are several ways to iterate over a [TList](@ref); in order of preference, if not forced by other constraints:

1. (Preferred way) Using the C++ range-based `for` or `thebegin()` / `theend()`: 

        for(TObject *obj: *GetListOfPrimitives())
           obj->Write();

(C++ version of the code)

2. Using the R__FOR_EACH macro: 

        GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);

(C++ version of the code)

3. Using the [TList](@ref) iterator [TListIter](@ref) (via the wrapper class [TIter](@ref)): 

        TIter next(GetListOfPrimitives());
        while (TObject *obj = next())
           obj->Draw(next.GetOption());

(C++ version of the code)

4. Using the [TList](@ref) iterator [TListIter](@ref) and std!for_each algorithm: 

        // A function object, which will be applied to each element
        // of the given range.
        struct STestFunctor {
           bool operator()(TObject *aObj) {
              ...
              return true;
           }
        }
        ...
        ...
        TIter iter(mylist);
        for_each( iter.Begin(), TIter!End(), STestFunctor() );

(C++ version of the code)

5. Using the [TObjLink](@ref) list entries (that wrap the TObject*): 

        TObjLink *lnk = GetListOfPrimitives()->FirstLink();
        while (lnk) {
           lnk->GetObject()->Draw(lnk->GetOption());
           lnk = lnk->Next();
        }

(C++ version of the code)

6. Using the [TList](@ref)'s [After()](@ref) and [Before()](@ref) member functions: 

        TFree *idcur = this;
        while (idcur) {
           ...
           ...
           idcur = (TFree*)GetListOfFree()->After(idcur);
        }

(C++ version of the code)

 Methods 3, 4 and 5 can also easily iterate backwards using either a backward [TIter](@ref) (using argument kIterBackward) or by using [LastLink()](@ref) and lnk->Prev() or by using the [Before()](@ref) member.

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Before`](@ref), [`Clear`](@ref), [`Delete`](@ref), [`FindObject`](@ref), [`FirstLink`](@ref), [`First`](@ref), [`GetObjectRef`](@ref), [`IsAscending`](@ref), [`LastLink`](@ref), [`Last`](@ref), [`MakeIterator`](@ref), [`RecursiveRemove`](@ref), [`RemoveLast`](@ref), [`Remove`](@ref), [`Sort`](@ref), [`TList`](@ref)
""" TList

# Wrapper of TObjLink
@trydoc raw"""
    ROOT.TObjLink

Wrapper around a [TObject](@ref) so it can be stored in a [TList](@ref).



Related functions: [`GetAddOption`](@ref), [`GetObjectRef`](@ref), [`GetObject`](@ref), [`GetOption`](@ref), [`NextSP`](@ref), [`Next`](@ref), [`PrevSP`](@ref), [`Prev`](@ref), [`SetObject`](@ref), [`SetOption`](@ref), [`TObjLink`](@ref)
""" TObjLink

# Wrapper of TObjOptLink
@trydoc raw"""
    ROOT.TObjOptLink





Related functions: [`GetAddOption`](@ref), [`GetOption`](@ref), [`SetOption`](@ref), [`TObjOptLink`](@ref)
""" TObjOptLink

# Wrapper of TListIter
@trydoc raw"""
    ROOT.TListIter

Iterator of linked list.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`SetOption`](@ref), [`TListIter`](@ref), [`assign`](@ref)
""" TListIter

# Wrapper of TVirtualQConnection
@trydoc raw"""
    ROOT.TVirtualQConnection

Mediates the link between the signal and the slot.

It decouples the setting of arguments and sending a signal.

There are three different modes in argument setting required by [TQObject](@ref)'s Emit/EmitVA: setting integral types, setting array types and setting const char*.

Related functions: [`SendSignal`](@ref), [`SetArgs`](@ref)
""" TVirtualQConnection

# Wrapper of TQObject
@trydoc raw"""
    ROOT.TQObject

This is the [ROOT](@ref) implementation of the Qt object communication mechanism (see also [http://www.troll.no/qt/metaobjects.html](http://www.troll.no/qt/metaobjects.html))

Signals and slots are used for communication between objects. When an object has changed in some way that might be interesting for the outside world, it emits a signal to tell whoever is listening. All slots that are connected to this signal will be activated (called). It is even possible to connect a signal directly to another signal (this will emit the second signal immediately whenever the first is emitted.) There is no limitation on the number of slots that can be connected to a signal. The slots will be activated in the order they were connected to the signal. This mechanism allows objects to be easily reused, because the object that emits a signal does not need to know to which objects the signals are connected. Together, signals and slots make up a powerfull component programming mechanism.

### Signals

    Destroyed()

(C++ version of the code)

 Signal emitted when object is destroyed. This signal could be connected to some garbage-collector object.

    ChangedBy(const char *method_name)

(C++ version of the code)

 This signal is emitted when some important data members of the object were changed. method_name parameter can be used as an identifier of the modifier method.

    Message(const char *msg)

(C++ version of the code)

General purpose message signal

Related functions: [`AreSignalsBlocked`](@ref), [`BlockSignals`](@ref), [`ChangedBy`](@ref), [`CollectClassSignalLists`](@ref), [`Connect`](@ref), [`Connected`](@ref), [`Destroyed`](@ref), [`Disconnect`](@ref), [`Disconnected`](@ref), [`EmitVA`](@ref), [`Emit`](@ref), [`GetListOfClassSignals`](@ref), [`GetListOfConnections`](@ref), [`GetListOfSignals`](@ref), [`HasConnection`](@ref), [`HighPriority`](@ref), [`IsA`](@ref), [`LowPriority`](@ref), [`Message`](@ref), [`NumberOfConnections`](@ref), [`NumberOfSignals`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TQObject!AreAllSignalsBlocked`](@ref), [`TQObject!BlockAllSignals`](@ref), [`TQObject!Class_Name`](@ref), [`TQObject!Class_Version`](@ref), [`TQObject!Class`](@ref), [`TQObject!Connect`](@ref), [`TQObject!DeclFileName`](@ref), [`TQObject!Disconnect`](@ref), [`TQObject`](@ref)
""" TQObject

# Wrapper of TQObjSender
@trydoc raw"""
    ROOT.TQObjSender





Related functions: [`IsA`](@ref), [`SetSenderClassName`](@ref), [`SetSender`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TQObjSender!Class_Name`](@ref), [`TQObjSender!Class_Version`](@ref), [`TQObjSender!Class`](@ref), [`TQObjSender!DeclFileName`](@ref), [`TQObjSender`](@ref)
""" TQObjSender

# Wrapper of TApplication
@trydoc raw"""
    ROOT.TApplication

This class creates the [ROOT](@ref) Application Environment that interfaces to the windowing system eventloop and eventhandlers.

This class must be instantiated exactly once in any given application. Normally the specific application class inherits from [TApplication](@ref) (see [TRint](@ref)).

Related functions: [`ApplicationName`](@ref), [`Argc`](@ref), [`Argv`](@ref), [`ClearInputFiles`](@ref), [`ExitOnException`](@ref), [`GetAppRemote`](@ref), [`GetApplicationImp`](@ref), [`GetIdleCommand`](@ref), [`GetOptions`](@ref), [`GetSetup`](@ref), [`GetSignalHandler`](@ref), [`HandleException`](@ref), [`HandleIdleTimer`](@ref), [`HandleTermInput`](@ref), [`Hide`](@ref), [`Iconify`](@ref), [`Init`](@ref), [`InitializeGraphics`](@ref), [`InputFiles`](@ref), [`IsA`](@ref), [`IsCmdThread`](@ref), [`IsRunning`](@ref), [`KeyPressed`](@ref), [`LineProcessed`](@ref), [`Lower`](@ref), [`NoLogOpt`](@ref), [`NoLogoOpt`](@ref), [`OpenForumTopic`](@ref), [`OpenGitHubIssue`](@ref), [`OpenInBrowser`](@ref), [`OpenReferenceGuideFor`](@ref), [`Open`](@ref), [`ProcessFile`](@ref), [`ProcessLine`](@ref), [`QuitOpt`](@ref), [`Raise`](@ref), [`RemoveIdleTimer`](@ref), [`ReturnFromRun`](@ref), [`ReturnPressed`](@ref), [`Run`](@ref), [`SetEchoMode`](@ref), [`SetIdleTimer`](@ref), [`SetReturnFromRun`](@ref), [`Show`](@ref), [`StartIdleing`](@ref), [`StopIdleing`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TApplication!Class_Name`](@ref), [`TApplication!Class_Version`](@ref), [`TApplication!Class`](@ref), [`TApplication!CreateApplication`](@ref), [`TApplication!DeclFileName`](@ref), [`TApplication!ExecuteFile`](@ref), [`TApplication!GetApplications`](@ref), [`TApplication!NeedGraphicsLibs`](@ref), [`TApplication`](@ref), [`TabCompletionHook`](@ref), [`Terminate`](@ref), [`WorkingDirectory`](@ref), [`ls`](@ref)
""" TApplication

# Wrapper of TSignalHandler
@trydoc raw"""
    ROOT.TSignalHandler





Related functions: [`Add`](@ref), [`Delay`](@ref), [`GetSignal`](@ref), [`HandleDelayedSignal`](@ref), [`IsA`](@ref), [`IsAsync`](@ref), [`IsSync`](@ref), [`Notify`](@ref), [`Remove`](@ref), [`SetSignal`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TSignalHandler!Class_Name`](@ref), [`TSignalHandler!Class_Version`](@ref), [`TSignalHandler!Class`](@ref), [`TSignalHandler!DeclFileName`](@ref), [`TSignalHandler`](@ref)
""" TSignalHandler

# Wrapper of TApplicationImp
@trydoc raw"""
    ROOT.TApplicationImp

ABC describing GUI independent application implementation protocol.



Related functions: [`ApplicationName`](@ref), [`ExecCommand`](@ref), [`Hide`](@ref), [`Iconify`](@ref), [`Init`](@ref), [`IsCmdThread`](@ref), [`Lower`](@ref), [`Open`](@ref), [`Raise`](@ref), [`Show`](@ref), [`TApplicationImp`](@ref)
""" TApplicationImp

# Wrapper of TAtt3D
@trydoc raw"""
    ROOT.TAtt3D

Use this attribute class when an object should have 3D capabilities.



Related functions: [`IsA`](@ref), [`Sizeof3D`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAtt3D!Class_Name`](@ref), [`TAtt3D!Class_Version`](@ref), [`TAtt3D!Class`](@ref), [`TAtt3D!DeclFileName`](@ref), [`TAtt3D`](@ref)
""" TAtt3D

# Wrapper of TAttAxis
@trydoc raw"""
    ROOT.TAttAxis

Manages histogram axis attributes.

They are:

- The number of divisions: [TAttAxis!SetNdivisions](@ref).
- The line axis' color: [TAttAxis!SetAxisColor](@ref).
- The axis labels' color: [TAttAxis!SetLabelColor](@ref).
- The axis labels' font: [TAttAxis!SetLabelFont](@ref).
- The axis labels' offset: [TAttAxis!SetLabelOffset](@ref).
- The axis labels' size: [TAttAxis!SetLabelSize](@ref).
- The tick marks's length: [TAttAxis!SetTickLength](@ref) or [TAttAxis!SetTickSize](@ref) .
- The axis title's offset: [TAttAxis!SetTitleOffset](@ref).
- The axis title's size: [TAttAxis!SetTitleSize](@ref).
- The axis title's color: [TAttAxis!SetTitleColor](@ref).
- The axis title's font: [TAttAxis!SetTitleFont](@ref).

Related functions: [`Copy`](@ref), [`GetAxisColor`](@ref), [`GetLabelColor`](@ref), [`GetLabelFont`](@ref), [`GetLabelOffset`](@ref), [`GetLabelSize`](@ref), [`GetMaxDigits`](@ref), [`GetNdivisions`](@ref), [`GetTickLength`](@ref), [`GetTitleColor`](@ref), [`GetTitleFont`](@ref), [`GetTitleOffset`](@ref), [`GetTitleSize`](@ref), [`IsA`](@ref), [`ResetAttAxis`](@ref), [`SaveAttributes`](@ref), [`SetAxisColor`](@ref), [`SetLabelColor`](@ref), [`SetLabelFont`](@ref), [`SetLabelOffset`](@ref), [`SetLabelSize`](@ref), [`SetMaxDigits`](@ref), [`SetNdivisions`](@ref), [`SetTickLength`](@ref), [`SetTickSize`](@ref), [`SetTitleColor`](@ref), [`SetTitleFont`](@ref), [`SetTitleOffset`](@ref), [`SetTitleSize`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttAxis!Class_Name`](@ref), [`TAttAxis!Class_Version`](@ref), [`TAttAxis!Class`](@ref), [`TAttAxis!DeclFileName`](@ref), [`TAttAxis`](@ref)
""" TAttAxis

# Wrapper of TPoint
@trydoc raw"""
    ROOT.TPoint





Related functions: [`GetX`](@ref), [`GetY`](@ref), [`SetX`](@ref), [`SetY`](@ref), [`TPoint`](@ref)
""" TPoint

# Wrapper of TAttBBox
@trydoc raw"""
    ROOT.TAttBBox

Helper for management of bounding-box information.

Optionally used by classes that use direct OpenGL rendering via `<Class>GL class`.

Related functions: [`AssertBBox`](@ref), [`ComputeBBox`](@ref), [`GetBBoxOK`](@ref), [`GetBBox`](@ref), [`IsA`](@ref), [`ResetBBox`](@ref), [`SetupBBoxCube`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttBBox!Class_Name`](@ref), [`TAttBBox!Class_Version`](@ref), [`TAttBBox!Class`](@ref), [`TAttBBox!DeclFileName`](@ref), [`TAttBBox`](@ref), [`assign`](@ref)
""" TAttBBox

# Wrapper of TAttBBox2D
@trydoc raw"""
    ROOT.TAttBBox2D

Abstract base class for elements drawn in the editor.

Classes inheriting from [TAttBBox2D](@ref) implementing the [TAttBBox2D](@ref) virtual classes, and using TPad!ShowGuideLines in ExecuteEvent will automatically get the guide lines drawn when moved in the pad. All methods work with pixel coordinates.

Related functions: [`GetBBoxCenter`](@ref), [`GetBBox`](@ref), [`IsA`](@ref), [`SetBBoxCenterX`](@ref), [`SetBBoxCenterY`](@ref), [`SetBBoxCenter`](@ref), [`SetBBoxX1`](@ref), [`SetBBoxX2`](@ref), [`SetBBoxY1`](@ref), [`SetBBoxY2`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttBBox2D!Class_Name`](@ref), [`TAttBBox2D!Class_Version`](@ref), [`TAttBBox2D!Class`](@ref), [`TAttBBox2D!DeclFileName`](@ref)
""" TAttBBox2D

# Wrapper of TAttFill
@trydoc raw"""
    ROOT.TAttFill

Fill Area Attributes class.

This class is used (in general by secondary inheritance) by many other classes (graphics, histograms). It holds all the fill area attributes.

## Fill Area attributes

Fill Area attributes are:

- [Fill Area color](@ref)
- [Fill Area style](@ref)

## Fill Area color

The fill area color is a color index (integer) pointing in the [ROOT](@ref) color table. The fill area color of any class inheriting from `TAttFill` can be changed using the method `SetFillColor` and retrieved using the method `GetFillColor`. The following table shows the first 50 default colors.

![https://root.cern/doc/v636/pict1_TAttFill_001.png](https://root.cern/doc/v636/pict1_TAttFill_001.png)

### Color transparency

`SetFillColorAlpha()`, allows to set a transparent color. In the following example the fill color of the histogram `histo` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    histo->SetFillColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

### The ROOT Color Wheel.

The wheel contains the recommended 216 colors to be used in web applications. The colors in the Color Wheel are created by [TColor!CreateColorWheel](@ref).

Using this color set for your text, background or graphics will give your application a consistent appearance across different platforms and browsers.

Colors are grouped by hue, the aspect most important in human perception Touching color chips have the same hue, but with different brightness and vividness.

Colors of slightly different hues *clash*. If you intend to display colors of the same hue together, you should pick them from the same group.

Each color chip is identified by a mnemonic (eg kYellow) and a number. The keywords, kRed, kBlue, kYellow, kPink, etc are defined in the header file **Rtypes.h** that is included in all [ROOT](@ref) other header files. We strongly recommend to use these keywords in your code instead of hardcoded color numbers, eg: 

    myObject.SetFillColor(kRed);
    myObject.SetFillColor(kYellow-10);
    myLine.SetLineColor(kMagenta+2);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TAttFill_002.png](https://root.cern/doc/v636/pict1_TAttFill_002.png)

### Special case forcing black&white output.

If the current style fill area color is set to 0, then [ROOT](@ref) will force a black&white output for all objects with a fill area defined and independently of the object fill style.

## Fill Area style

The fill area style defines the pattern used to fill a polygon. The fill area style of any class inheriting from `TAttFill` can be changed using the method `SetFillStyle` and retrieved using the method `GetFillStyle`. 

### Conventions for fill styles:

- 0 : hollow
- 1001 : Solid
- 3000+pattern_number (see below)
- For [TPad](@ref) only:

    - 4000 :the window is transparent.
    - 4000 to 4100 the window is 100% transparent to 100% opaque.

        The pad transparency is visible in binary outputs files like gif, jpg, png etc .. but not in vector graphics output files like PS, PDF and SVG. This convention (fill style > 4000) is kept for backward compatibility. It is better to use the color transparency instead.

pattern_number can have any value from 1 to 25 (see table), or any value from 100 to 999. For the latest the numbering convention is the following: 

    pattern_number = ijk      (FillStyle = 3ijk)
    i (1-9) : specify the space between each hatch
              1 = 1/2mm  9 = 6mm
    j (0-9) : specify angle between 0 and 90 degrees
              0 = 0
              1 = 10
              2 = 20
              3 = 30
              4 = 45
              5 = Not drawn
              6 = 60
              7 = 70
              8 = 80
              9 = 90
    k (0-9) : specify angle between 90 and 180 degrees
              0 = 180
              1 = 170
              2 = 160
              3 = 150
              4 = 135
              5 = Not drawn
              6 = 120
              7 = 110
              8 = 100
              9 = 90

(C++ version of the code)

 The following table shows the list of pattern styles. The first table displays the 25 fixed patterns. They cannot be customized unlike the hatches displayed in the second table which be customized using:

- `gStyle->SetHatchesSpacing()` to define the spacing between hatches.
- `gStyle->SetHatchesLineWidth()` to define the hatches line width.

![https://root.cern/doc/v636/pict1_TAttFill_003.png](https://root.cern/doc/v636/pict1_TAttFill_003.png)

Related functions: [`Copy`](@ref), [`GetFillColor`](@ref), [`GetFillStyle`](@ref), [`IsA`](@ref), [`IsTransparent`](@ref), [`Modify`](@ref), [`ResetAttFill`](@ref), [`SaveFillAttributes`](@ref), [`SetFillAttributes`](@ref), [`SetFillColorAlpha`](@ref), [`SetFillColor`](@ref), [`SetFillStyle`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttFill!Class_Name`](@ref), [`TAttFill!Class_Version`](@ref), [`TAttFill!Class`](@ref), [`TAttFill!DeclFileName`](@ref), [`TAttFill`](@ref)
""" TAttFill

# Wrapper of TAttLine
@trydoc raw"""
    ROOT.TAttLine

Line Attributes class.

This class is used (in general by secondary inheritance) by many other classes (graphics, histograms). It holds all the line attributes.

## Line attributes

Line attributes are:

- [Line Color](@ref)
- [Line Width](@ref)
- [Line Style](@ref)

## Line Color

The line color is a color index (integer) pointing in the [ROOT](@ref) color table. The line color of any class inheriting from `TAttLine` can be changed using the method `SetLineColor` and retrieved using the method `GetLineColor`. The following table shows the first 50 default colors.

![https://root.cern/doc/v636/pict1_TAttLine_001.png](https://root.cern/doc/v636/pict1_TAttLine_001.png)

### Color transparency

`SetLineColorAlpha()`, allows to set a transparent color. In the following example the line color of the histogram `histo` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    histo->SetLineColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

## Line Width

The line width is expressed in pixel units. The line width of any class inheriting from `TAttLine` can be changed using the method `SetLineWidth` and retrieved using the method `GetLineWidth`. The following picture shows the line widths from 1 to 10 pixels.

![https://root.cern/doc/v636/pict1_TAttLine_002.png](https://root.cern/doc/v636/pict1_TAttLine_002.png)

## Line Style

Line styles are identified via integer numbers. The line style of any class inheriting from `TAttLine` can be changed using the method `SetLineStyle` and retrieved using the method `GetLineStyle`.

The first 10 line styles are predefined as shown on the following picture:

![https://root.cern/doc/v636/pict1_TAttLine_003.png](https://root.cern/doc/v636/pict1_TAttLine_003.png)

Some line styles can be accessed via the following enum:

    kSolid      = 1
    kDashed     = 2
    kDotted     = 3
    kDashDotted = 4

(C++ version of the code)

Additional line styles can be defined using `TStyle!SetLineStyleString`. For example the line style number 11 can be defined as follow: 

    gStyle->SetLineStyleString(11,"400 200");

(C++ version of the code)

 Existing line styles (1 to 10) can be redefined using the same method.

Related functions: [`Copy`](@ref), [`DistancetoLine`](@ref), [`GetLineColor`](@ref), [`GetLineStyle`](@ref), [`GetLineWidth`](@ref), [`IsA`](@ref), [`Modify`](@ref), [`ResetAttLine`](@ref), [`SaveLineAttributes`](@ref), [`SetLineAttributes`](@ref), [`SetLineColorAlpha`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttLine!Class_Name`](@ref), [`TAttLine!Class_Version`](@ref), [`TAttLine!Class`](@ref), [`TAttLine!DeclFileName`](@ref), [`TAttLine`](@ref)
""" TAttLine

# Wrapper of TAttMarker
@trydoc raw"""
    ROOT.TAttMarker

Marker Attributes class.

This class is used (in general by secondary inheritance) by many other classes (graphics, histograms). It holds all the markers attributes.

## Marker attributes

The marker attributes are:

- [Marker color](@ref)
- [Marker style](@ref)

    - [Marker line width](@ref)
- [Marker size](@ref)

## Marker color

The marker color is a color index (integer) pointing in the [ROOT](@ref) color table. The marker color of any class inheriting from `TAttMarker` can be changed using the method `SetMarkerColor` and retrieved using the method `GetMarkerColor`. The following table shows the first 50 default colors.

![https://root.cern/doc/v636/pict1_TAttMarker_001.png](https://root.cern/doc/v636/pict1_TAttMarker_001.png)

### Color transparency

`SetMarkerColorAlpha()`, allows to set a transparent color. In the following example the marker color of the histogram `histo` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    histo->SetMarkerColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

## Marker style

The Marker style defines the markers' shape. The marker style of any class inheriting from `TAttMarker` can be changed using the method `SetMarkerStyle` and retrieved using the method `GetMarkerStyle`.

The following list gives the currently supported markers (screen and PostScript) style. Each marker style is identified by an integer number (first column) corresponding to a marker shape (second column) and can be also accessed via a global_ name (third column).

    Marker number         Marker shape          Marker name
         1                    dot                  kDot
         2                    +                    kPlus
         3                    *                    kStar
         4                    o                    kCircle
         5                    x                    kMultiply
         6                    small dot            kFullDotSmall
         7                    medium dot           kFullDotMedium
         8                    large scalable dot   kFullDotLarge
         9 -->19              large scalable dot
        20                    full circle          kFullCircle
        21                    full square          kFullSquare
        22                    full triangle up     kFullTriangleUp
        23                    full triangle down   kFullTriangleDown
        24                    open circle          kOpenCircle
        25                    open square          kOpenSquare
        26                    open triangle up     kOpenTriangleUp
        27                    open diamond         kOpenDiamond
        28                    open cross           kOpenCross
        29                    full star            kFullStar
        30                    open star            kOpenStar
        31                    *
        32                    open triangle down   kOpenTriangleDown
        33                    full diamond         kFullDiamond
        34                    full cross           kFullCross
        35                    open diamond cross   kOpenDiamondCross
        36                    open square diagonal kOpenSquareDiagonal
        37                    open three triangle  kOpenThreeTriangles
        38                    octagon with cross   kOctagonCross
        39                    full three triangles kFullThreeTriangles
        40                    open four triangleX  kOpenFourTrianglesX
        41                    full four triangleX  kFullFourTrianglesX
        42                    open double diamond  kOpenDoubleDiamond
        43                    full double diamond  kFullDoubleDiamond
        44                    open four triangle+  kOpenFourTrianglesPlus
        45                    full four triangle+  kFullFourTrianglesPlus
        46                    open cross X         kOpenCrossX
        47                    full cross X         kFullCrossX
        48                    four squares X       kFourSquaresX
        49                    four squares+        kFourSquaresPlus

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TAttMarker_002.png](https://root.cern/doc/v636/pict1_TAttMarker_002.png)

###Warning

Non-symmetric symbols should be used carefully. See markerwarning.C

### Marker line width

The line width of a marker is not actually a marker attribute since it does only apply to open marker symbols and marker symbols consisting of lines. All of these marker symbols are redefined with thicker lines by style numbers starting from 50:

    Marker numbers   Line width
       50 -  67         2
       68 -  85         3
       86 - 103         4
      104 - 121         5
    ...

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TAttMarker_003.png](https://root.cern/doc/v636/pict1_TAttMarker_003.png)

## Marker size

Various marker sizes are shown in the figure below. The default marker size=1 is shown in the top left corner. Marker sizes smaller than 1 can be specified. The marker size does not refer to any coordinate systems, it is an absolute value. Therefore the marker size is not affected by any change in [TPad](@ref)'s scale. A marker size equal to 1 correspond to 8 pixels. That is, a square marker with size 1 will be drawn with a side equal to 8 pixels on the screen.

The marker size of any class inheriting from `TAttMarker` can be changed using the method `SetMarkerSize` and retrieved using the method `GetMarkerSize`.

![https://root.cern/doc/v636/pict1_TAttMarker_004.png](https://root.cern/doc/v636/pict1_TAttMarker_004.png)

Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They are meant to be very fast to draw and are always drawn with the same number of pixels; therefore `SetMarkerSize` does not apply on them. To have a "scalable dot" a filled circle should be used instead, i.e. the marker style number 20. By default (if `SetMarkerStyle` is not specified), the marker style used is 1. That's the most common one to draw scatter plots.

Related functions: [`Copy`](@ref), [`GetMarkerColor`](@ref), [`GetMarkerSize`](@ref), [`GetMarkerStyle`](@ref), [`IsA`](@ref), [`Modify`](@ref), [`ResetAttMarker`](@ref), [`SaveMarkerAttributes`](@ref), [`SetMarkerAttributes`](@ref), [`SetMarkerColorAlpha`](@ref), [`SetMarkerColor`](@ref), [`SetMarkerSize`](@ref), [`SetMarkerStyle`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttMarker!Class_Name`](@ref), [`TAttMarker!Class_Version`](@ref), [`TAttMarker!Class`](@ref), [`TAttMarker!DeclFileName`](@ref), [`TAttMarker!GetMarkerLineWidth`](@ref), [`TAttMarker!GetMarkerStyleBase`](@ref), [`TAttMarker`](@ref)
""" TAttMarker

# Wrapper of TAttPad
@trydoc raw"""
    ROOT.TAttPad

Manages default Pad attributes.

Referenced by [TStyle](@ref).

Related functions: [`Copy`](@ref), [`GetAfile`](@ref), [`GetAstat`](@ref), [`GetBottomMargin`](@ref), [`GetFrameBorderMode`](@ref), [`GetFrameBorderSize`](@ref), [`GetFrameFillColor`](@ref), [`GetFrameFillStyle`](@ref), [`GetFrameLineColor`](@ref), [`GetFrameLineStyle`](@ref), [`GetFrameLineWidth`](@ref), [`GetLeftMargin`](@ref), [`GetRightMargin`](@ref), [`GetTopMargin`](@ref), [`GetXfile`](@ref), [`GetXstat`](@ref), [`GetYfile`](@ref), [`GetYstat`](@ref), [`IsA`](@ref), [`Print`](@ref), [`ResetAttPad`](@ref), [`SetAfile`](@ref), [`SetAstat`](@ref), [`SetBottomMargin`](@ref), [`SetFrameBorderMode`](@ref), [`SetFrameBorderSize`](@ref), [`SetFrameFillColor`](@ref), [`SetFrameFillStyle`](@ref), [`SetFrameLineColor`](@ref), [`SetFrameLineStyle`](@ref), [`SetFrameLineWidth`](@ref), [`SetLeftMargin`](@ref), [`SetMargin`](@ref), [`SetRightMargin`](@ref), [`SetTopMargin`](@ref), [`SetXfile`](@ref), [`SetXstat`](@ref), [`SetYfile`](@ref), [`SetYstat`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttPad!Class_Name`](@ref), [`TAttPad!Class_Version`](@ref), [`TAttPad!Class`](@ref), [`TAttPad!DeclFileName`](@ref), [`TAttPad`](@ref)
""" TAttPad

# Wrapper of TAttText
@trydoc raw"""
    ROOT.TAttText

Text Attributes class.

This class is used (in general by secondary inheritance) by many other classes (graphics, histograms). It holds all the text attributes.

## Text attributes

Text attributes are:

- [Text Alignment](@ref)
- [Text Angle](@ref)
- [Text Color](@ref)
- [Text Size](@ref)
- [Text Font and Precision](@ref)

    - [Font quality and speed](@ref)
    - [How to use True Type Fonts](@ref)
    - [List of the currently supported fonts](@ref)

## Text Alignment

The text alignment is an integer number (`align`) allowing to control the horizontal and vertical position of the text string with respect to the text position. The text alignment of any class inheriting from `TAttText` can be changed using the method `SetTextAlign` and retrieved using the method `GetTextAlign`.

    align = 10*HorizontalAlign + VerticalAlign

(C++ version of the code)

For horizontal alignment the following convention applies:

    1=left adjusted, 2=centered, 3=right adjusted

(C++ version of the code)

For vertical alignment the following convention applies:

    1=bottom adjusted, 2=centered, 3=top adjusted

(C++ version of the code)

For example:

    align = 11 = left adjusted and bottom adjusted
    align = 32 = right adjusted and vertically centered

(C++ version of the code)

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TAttText_001.png](https://root.cern/doc/v636/pict1_TAttText_001.png)

Mnemonic constants are available:

    kHAlignLeft   = 10, kHAlignCenter = 20, kHAlignRight = 30,
    kVAlignBottom = 1,  kVAlignCenter = 2,  kVAlignTop   = 3

(C++ version of the code)

They allow to write:

    object->SetTextAlign(kHAlignLeft+kVAlignTop);

(C++ version of the code)

## Text Angle

Text angle in degrees. The text angle of any class inheriting from `TAttText` can be changed using the method `SetTextAngle` and retrieved using the method `GetTextAngle`. The following picture shows the text angle:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TAttText_002.png](https://root.cern/doc/v636/pict1_TAttText_002.png)

## Text Color

The text color is a color index (integer) pointing in the [ROOT](@ref) color table. The text color of any class inheriting from `TAttText` can be changed using the method `SetTextColor` and retrieved using the method `GetTextColor`. The following table shows the first 50 default colors.

![https://root.cern/doc/v636/pict1_TAttText_003.png](https://root.cern/doc/v636/pict1_TAttText_003.png)

### Color transparency

`SetTextColorAlpha()`, allows to set a transparent color. In the following example the text color of the text `text` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    text->SetTextColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

## Text Size

If the text precision (see next paragraph) is smaller than 3, the text size (`textsize`) is a fraction of the current pad size. Therefore the same `textsize` value can generate text outputs with different absolute sizes in two different pads. The text size in pixels (`charheight`) is computed the following way:

    pad_width  = gPad->XtoPixel(gPad->GetX2());
    pad_height = gPad->YtoPixel(gPad->GetY1());
    if (pad_width < pad_height)  charheight = textsize*pad_width;
    else                         charheight = textsize*pad_height;

(C++ version of the code)

If the text precision is equal to 3, the text size doesn't depend on the pad's dimensions. A given `textsize` value always generates the same absolute size. The text size (`charheight`) is given in pixels:

    charheight = textsize;

(C++ version of the code)

Note that to scale fonts to the same size as the old True Type package a scale factor of `0.93376068` is apply to the text size before drawing.

The text size of any class inheriting from `TAttText` can be changed using the method `SetTextSize` and retrieved using the method `GetTextSize`.

## Text Font and Precision

The text font code is combination of the font number and the precision. 

    Text font code = 10*fontnumber + precision

(C++ version of the code)

 Font numbers must be between 1 and 14.

The precision can be:

- `precision = 0` fast hardware fonts (steps in the size)
- `precision = 1` scalable and rotatable hardware fonts (see below)
- `precision = 2` scalable and rotatable hardware fonts
- `precision = 3` scalable and rotatable hardware fonts. Text size is given in pixels.

The text font and precision of any class inheriting from `TAttText` can be changed using the method `SetTextFont` and retrieved using the method `GetTextFont`.

### Font quality and speed

When precision 0 is used, only the original non-scaled X11 system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behaviour depending if the True Type Fonts ([TTF](@ref)) are used or not. If [TTF](@ref) are used, you always get very good quality scalable and rotatable fonts. These days [TTF](@ref) fonts are rendered fast enough and can be used in all cases.

### How to use True Type Fonts

[TTF](@ref) fonts are used by default. They can be deactivated via the following line in the `.rootrc` file:

    Unix.*.Root.UseTTFonts:     false

(C++ version of the code)

### List of the currently supported fonts

    Font number      TTF Names                   PostScript/PDF Names
        1 :       "Free Serif Italic"         "Times-Italic"
        2 :       "Free Serif Bold"           "Times-Bold"
        3 :       "Free Serif Bold Italic"    "Times-BoldItalic"
        4 :       "Tex Gyre Regular"          "Helvetica"
        5 :       "Tex Gyre Italic"           "Helvetica-Oblique"
        6 :       "Tex Gyre Bold"             "Helvetica-Bold"
        7 :       "Tex Gyre Bold Italic"      "Helvetica-BoldOblique"
        8 :       "Free Mono"                 "Courier"
        9 :       "Free Mono Oblique"         "Courier-Oblique"
       10 :       "Free Mono Bold"            "Courier-Bold"
       11 :       "Free Mono Bold Oblique"    "Courier-BoldOblique"
       12 :       "Symbol"                    "Symbol"
       13 :       "Free Serif"                "Times-Roman"
       14 :       "Wingdings"                 "ZapfDingbats"

(C++ version of the code)

The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles forming four type families (Courier, Helvetica, Times, Symbol) as listed in the "Core Font Set" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts). These fonts are always available and do not need to be loaded in the PS or PDF files allowing to keep the files' sizes small.

On screen, text is rendered using free [TTF](@ref) fonts similar to the PDF ones. The corresponding font files are coming with the [ROOT](@ref) distribution in `$ROOTSYS/fonts/Free*`.

![https://root.cern/doc/v636/pict1_TAttText_004.png](https://root.cern/doc/v636/pict1_TAttText_004.png)

Related functions: [`Copy`](@ref), [`GetTextAlign`](@ref), [`GetTextAngle`](@ref), [`GetTextColor`](@ref), [`GetTextFont`](@ref), [`GetTextSizePercent`](@ref), [`GetTextSize`](@ref), [`IsA`](@ref), [`Modify`](@ref), [`ResetAttText`](@ref), [`SaveTextAttributes`](@ref), [`SetTextAlign`](@ref), [`SetTextAngle`](@ref), [`SetTextAttributes`](@ref), [`SetTextColorAlpha`](@ref), [`SetTextColor`](@ref), [`SetTextFont`](@ref), [`SetTextSizePixels`](@ref), [`SetTextSize`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttText!Class_Name`](@ref), [`TAttText!Class_Version`](@ref), [`TAttText!Class`](@ref), [`TAttText!DeclFileName`](@ref), [`TAttText`](@ref)
""" TAttText

# Wrapper of TBase64
@trydoc raw"""
    ROOT.TBase64

This code implements the Base64 encoding and decoding.

Base64 encoded messages are typically used in authentication protocols and to pack binary data in HTTP messages.

Related functions: [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TBase64!Class_Name`](@ref), [`TBase64!Class_Version`](@ref), [`TBase64!Class`](@ref), [`TBase64!DeclFileName`](@ref), [`TBase64!Decode`](@ref), [`TBase64!Encode`](@ref)
""" TBase64

# Wrapper of TStopwatch
@trydoc raw"""
    ROOT.TStopwatch

Stopwatch class.

This class returns the real and cpu time between the thestart and stop events.

Related functions: [`Continue`](@ref), [`Counter`](@ref), [`CpuTime`](@ref), [`IsA`](@ref), [`Print`](@ref), [`RealTime`](@ref), [`ResetCpuTime`](@ref), [`ResetRealTime`](@ref), [`Reset`](@ref), [`Start`](@ref), [`Stop`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TStopwatch!Class_Name`](@ref), [`TStopwatch!Class_Version`](@ref), [`TStopwatch!Class`](@ref), [`TStopwatch!DeclFileName`](@ref), [`TStopwatch`](@ref)
""" TStopwatch

# Wrapper of TBenchmark
@trydoc raw"""
    ROOT.TBenchmark

This class is a [ROOT](@ref) utility to help benchmarking applications.



Related functions: [`GetBench`](@ref), [`GetCpuTime`](@ref), [`GetRealTime`](@ref), [`IsA`](@ref), [`Print`](@ref), [`Reset`](@ref), [`Show`](@ref), [`Start`](@ref), [`Stop`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Summary`](@ref), [`TBenchmark!Class_Name`](@ref), [`TBenchmark!Class_Version`](@ref), [`TBenchmark!Class`](@ref), [`TBenchmark!DeclFileName`](@ref), [`TBenchmark`](@ref)
""" TBenchmark

# Wrapper of TBuffer3D
@trydoc raw"""
    ROOT.TBuffer3D

Generic 3D primitive description class.

See [TBuffer3DTypes](@ref) for producer classes.

### Filling TBuffer3D and Adding to Viewer

The viewers behind the [TVirtualViewer3D](@ref) interface differ greatly in their capabilities e.g.

- Some know how to draw certain shapes natively (e.g. spheres/tubes in OpenGL)
- others always require a raw tessellation description of points/lines/segments.
- Some need the 3D object positions in the global_ frame, others can cope with local_ frames + a translation matrix - which can give considerable performance benefits.

To cope with these situations the object buffer is filled out in negotiation with the viewer. [TBuffer3D](@ref) classes are conceptually divided into enumerated sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details).

![https://root.cern/doc/v636/base_tbuffer3d.png](https://root.cern/doc/v636/base_tbuffer3d.png)

The `SectionsValid() / SetSectionsValid / ClearSectionsValid()` methods of [TBuffer3D](@ref) are used to test/set/clear these section valid flags.

The sections found in [TBuffer3D](@ref) (`Core/BoundingBox/Raw Sizes/Raw`) are sufficient to describe any tessellated shape in a generic fashion. An additional `ShapeSpecific` section in derived shape specific classes allows a more abstract shape description ("a sphere of inner radius x, outer radius y"). This enables a viewer which knows how to draw (tessellate) the shape itself to do so, which can bring considerable performance and quality benefits, while providing a generic fallback suitable for all viewers.

The rules for client negotiation with the viewer are:

- If suitable specialized [TBuffer3D](@ref) class exists, use it, otherwise use [TBuffer3D](@ref).
- Complete the mandatory Core section.
- Complete the ShapeSpecific section if applicable.
- Complete the BoundingBox if you can.
- Pass this buffer to the viewer using one of the AddObject() methods - see below.

If the viewer requires more sections to be completed (Raw/RawSizes) AddObject() will return flags indicating which ones, otherwise it returns kNone. You must fill the buffer and mark these sections valid, and pass the buffer again. A typical code snippet would be:

    TBuffer3DSphere sphereBuffer;
    // Fill out kCore...
    // Fill out kBoundingBox...
    // Fill out kShapeSpecific for TBuffer3DSphere
    // Try first add to viewer
    Int_t reqSections = viewer-&gt;AddObject(buffer);
    if (reqSections != TBuffer3D!kNone) {
      if (reqSections & TBuffer3D!kRawSizes) {
         // Fill out kRawSizes...
      }
      if (reqSections & TBuffer3D!kRaw) {
         // Fill out kRaw...
      }
      // Add second time to viewer - ignore return cannot do more
      viewer-&gt;AddObject(buffer);
      }
    }

(C++ version of the code)

`ShapeSpecific`: If the viewer can directly display the buffer without filling of the kRaw/kRawSizes section it will not need to request client side tessellation.

Currently we provide the following various shape specific classes, which the OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h)

- [TBuffer3DSphere](@ref) - solid, hollow and cut spheres*
- [TBuffer3DTubeSeg](@ref) - angle tube segment
- [TBuffer3DCutTube](@ref) - angle tube segment with plane cut ends.

OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.

Anyone is free to add new [TBuffer3D](@ref) classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.

`BoundingBox:` You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.

As we need to support orientated (rotated) bounding boxes, [TBuffer3D](@ref) requires the 6 vertices of the box. We also provide a convenience function, [SetAABoundingBox()](@ref), for simpler case of setting an axis aligned bounding box.

### Master/Local Reference Frames

The `Core` section of [TBuffer3D](@ref) contains two members relating to reference frames: `fLocalFrame` & `fLocalMaster`. `fLocalFrame` indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local_ or master (world frame). `fLocalMaster` is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.

If `fLocalFrame` is kFALSE, `fLocalMaster` should contain an identity matrix. This is set by default, and can be reset using `SetLocalMasterIdentity()` function.

Logical & Physical Objects. There are two cases of object addition:

- Add this object as a single independent entity in the world reference frame.
- Add a physical placement (copy) of this logical object (described in local_ reference frame).

The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the `fID` logical ID member of [TBuffer3D](@ref). If repeated addition of the same `fID` is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.

For this to work correctly the logical object in must be described in [TBuffer3D](@ref) in the local_ reference frame, complete with the local_/master translation. The viewer indicates this through the interface method

    PreferLocalFrame()

(C++ version of the code)

If this returns kTRUE you can make repeated calls to AddObject(), with [TBuffer3D](@ref) containing the same fID, and different `fLocalMaster` placements.

For viewers supporting logical/physical objects, the [TBuffer3D](@ref) content refers to the properties of logical object, with the `fLocalMaster` transform and the `fColor` and `fTransparency` attributes, which can be varied for each physical object.

As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer.

### Scene Rebuilds

It should be understood that AddObject is not an explicit command to the viewer

- it may for various reasons decide to ignore it:
- It already has the object internally cached .
- The object falls outside some 'interest' limits of the viewer camera.
- The object is too small to be worth drawing.

In all these cases AddObject() returns kNone, as it does for successful addition, simply indicating it does not require you to provide further information about this object. You should not try to make any assumptions about what the viewer did with it.

This enables the viewer to be connected to a client which sends potentially millions of objects, and only accept those that are of interest at a certain time, caching the relatively small number of CPU/memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a [TPad](@ref) repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached [TPad](@ref) object - hence the reason for putting all publishing to the viewer in the attached pad objects [Paint()](@ref) method. We will likely remove this requirement in the future, indicating the rebuild request via a normal [ROOT](@ref) signal, which the client can detect.

### Physical IDs

[TVirtualViewer3D](@ref) provides for two methods of object addition:virtual Int_t AddObject(const [TBuffer3D](@ref) & buffer, Bool_t * addChildren = 0)

    virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0)

(C++ version of the code)

If you use the first (simple) case a viewer using logical/physical pairs SetSectionsValid(TBuffer3D!kBoundingBox); will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds.

### Child Objects

In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both AddObject() methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding.

### Recycling TBuffer3D

Once add AddObject() has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable.

Related functions: [`ClearSectionsValid`](@ref), [`GetSections`](@ref), [`IsA`](@ref), [`NbPnts`](@ref), [`NbPols`](@ref), [`NbSegs`](@ref), [`SectionsValid`](@ref), [`SetAABoundingBox`](@ref), [`SetLocalMasterIdentity`](@ref), [`SetRawSizes`](@ref), [`SetSectionsValid`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TBuffer3D!Class_Name`](@ref), [`TBuffer3D!Class_Version`](@ref), [`TBuffer3D!Class`](@ref), [`TBuffer3D!DecCSLevel`](@ref), [`TBuffer3D!DeclFileName`](@ref), [`TBuffer3D!GetCSLevel`](@ref), [`TBuffer3D!IncCSLevel`](@ref), [`TBuffer3D`](@ref), [`Type`](@ref)
""" TBuffer3D

# Wrapper of TBuffer3DSphere
@trydoc raw"""
    ROOT.TBuffer3DSphere

Sphere description class - see [TBuffer3DTypes](@ref) for producer classes Supports hollow and cut spheres.



Related functions: [`IsSolidUncut`](@ref), [`TBuffer3DSphere`](@ref)
""" TBuffer3DSphere

# Wrapper of TBuffer3DTube
@trydoc raw"""
    ROOT.TBuffer3DTube

Complete tube description class - see [TBuffer3DTypes](@ref) for producer classes.



Related functions: [`TBuffer3DTube`](@ref)
""" TBuffer3DTube

# Wrapper of TBuffer3DTubeSeg
@trydoc raw"""
    ROOT.TBuffer3DTubeSeg

Tube segment description class - see [TBuffer3DTypes](@ref) for producer classes.



Related functions: [`TBuffer3DTubeSeg`](@ref)
""" TBuffer3DTubeSeg

# Wrapper of TBuffer3DCutTube
@trydoc raw"""
    ROOT.TBuffer3DCutTube

Cut tube segment description class - see [TBuffer3DTypes](@ref) for producer classes.



Related functions: [`TBuffer3DCutTube`](@ref)
""" TBuffer3DCutTube

# Wrapper of TBuffer3DTypes
@trydoc raw"""
    ROOT.TBuffer3DTypes





Related functions: 
""" TBuffer3DTypes

# Wrapper of TObjArrayIter
@trydoc raw"""
    ROOT.TObjArrayIter

Iterator of object array.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TObjArrayIter`](@ref), [`assign`](@ref)
""" TObjArrayIter

# Wrapper of TVirtualStreamerInfo
@trydoc raw"""
    ROOT.TVirtualStreamerInfo

Abstract Interface class describing Streamer information for one class.



Related functions: [`BuildCheck`](@ref), [`BuildEmulated`](@ref), [`BuildFor`](@ref), [`BuildOld`](@ref), [`Build`](@ref), [`CallShowMembers`](@ref), [`Clear`](@ref), [`CompareContent`](@ref), [`Compile`](@ref), [`DeleteArray`](@ref), [`Destructor`](@ref), [`ForceWriteInfo`](@ref), [`GenEmulatedClassStreamer`](@ref), [`GenEmulatedProxy`](@ref), [`GenExplicitClassStreamer`](@ref), [`GenExplicitProxy`](@ref), [`GenerateHeaderFile`](@ref), [`GenerateInfoForPair`](@ref), [`GetActualClass`](@ref), [`GetCheckSum`](@ref), [`GetClassVersion`](@ref), [`GetClass`](@ref), [`GetElem`](@ref), [`GetElementOffset`](@ref), [`GetElement`](@ref), [`GetElements`](@ref), [`GetNumber`](@ref), [`GetOffset`](@ref), [`GetOldVersion`](@ref), [`GetOnFileClassVersion`](@ref), [`GetSize`](@ref), [`GetStreamerElement`](@ref), [`IsBuilt`](@ref), [`IsCompiled`](@ref), [`IsOptimized`](@ref), [`IsRecovered`](@ref), [`NewArray`](@ref), [`NewInfo`](@ref), [`New`](@ref), [`SetCheckSum`](@ref), [`SetClassVersion`](@ref), [`SetClass`](@ref), [`TVirtualStreamerInfo!CanDelete`](@ref), [`TVirtualStreamerInfo!CanOptimize`](@ref), [`TVirtualStreamerInfo!Factory`](@ref), [`TVirtualStreamerInfo!GetElementCounterStart`](@ref), [`TVirtualStreamerInfo!GetElementCounter`](@ref), [`TVirtualStreamerInfo!GetStreamMemberWise`](@ref), [`TVirtualStreamerInfo!Optimize`](@ref), [`TVirtualStreamerInfo!SetCanDelete`](@ref), [`TVirtualStreamerInfo!SetFactory`](@ref), [`TVirtualStreamerInfo!SetStreamMemberWise`](@ref), [`TVirtualStreamerInfo`](@ref), [`TagFile`](@ref), [`Update`](@ref), [`ls`](@ref)
""" TVirtualStreamerInfo

# Wrapper of TVirtualArray
@trydoc raw"""
    ROOT.TVirtualArray

Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary.



Related functions: [`Base.getindex`](@ref), [`GetClass`](@ref), [`GetObjectAt`](@ref), [`SetSize`](@ref), [`TVirtualArray`](@ref)
""" TVirtualArray

# Wrapper of TProcessID
@trydoc raw"""
    ROOT.TProcessID

A [TProcessID](@ref) identifies a [ROOT](@ref) job in a unique way in time and space.

The [TProcessID](@ref) title consists of a [TUUID](@ref) object which provides a globally unique identifier (for more see TUUID.h).

A [TProcessID](@ref) is automatically created by the [TROOT](@ref) constructor. When a [TFile](@ref) contains referenced objects (see [TRef](@ref)), the [TProcessID](@ref) object is written to the file. If a file has been written in multiple sessions (same machine or not), a [TProcessID](@ref) is written for each session. These objects are used by the class [TRef](@ref) to uniquely identified any [TObject](@ref) pointed by a [TRef](@ref).

When a referenced object is read from a file (its bit kIsReferenced is set), this object is entered into the objects table of the corresponding [TProcessID](@ref). Each [TFile](@ref) has a list of TProcessIDs (see [TFile!fProcessIDs](@ref)) also accessible via [TProcessID!fgPIDs](@ref) (for all files). When this object is deleted, it is removed from the table via the cleanup mechanism invoked by the [TObject](@ref) destructor.

Each [TProcessID](@ref) has a table ([TObjArray](@ref) *fObjects) that keeps track of all referenced objects. If a referenced object has a fUniqueID set, a pointer to this unique object may be found via fObjects->At(fUniqueID). In the same way, when a [TRef!GetObject](@ref) is called, GetObject uses its own fUniqueID to find the pointer to the referenced object. See [TProcessID!GetObjectWithID](@ref) and PutObjectWithID.

When a referenced object is deleted, its slot in fObjects is set to null.

See also [TProcessUUID](@ref): a specialized [TProcessID](@ref) to manage the single list of TUUIDs.

Related functions: [`CheckInit`](@ref), [`Clear`](@ref), [`DecrementCount`](@ref), [`GetCount`](@ref), [`GetObjectWithID`](@ref), [`GetObjects`](@ref), [`IncrementCount`](@ref), [`IsA`](@ref), [`PutObjectWithID`](@ref), [`RecursiveRemove`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TProcessID!AddProcessID`](@ref), [`TProcessID!AssignID`](@ref), [`TProcessID!Class_Name`](@ref), [`TProcessID!Class_Version`](@ref), [`TProcessID!Class`](@ref), [`TProcessID!Cleanup`](@ref), [`TProcessID!DeclFileName`](@ref), [`TProcessID!GetNProcessIDs`](@ref), [`TProcessID!GetObjectCount`](@ref), [`TProcessID!GetPID`](@ref), [`TProcessID!GetPIDs`](@ref), [`TProcessID!GetProcessID`](@ref), [`TProcessID!GetProcessWithUID`](@ref), [`TProcessID!GetSessionProcessID`](@ref), [`TProcessID!IsValid`](@ref), [`TProcessID!SetObjectCount`](@ref), [`TProcessID`](@ref)
""" TProcessID

# Wrapper of TClonesArray
@trydoc raw"""
    ROOT.TClonesArray

An array of clone (identical) objects.

Memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as [TObjArray](@ref).

To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete): 

    TObjArray a(10000);
    while (TEvent *ev = (TEvent *)next()) {      // O(100000) events
       for (int i = 0; i < ev->Ntracks; i++) {   // O(10000) tracks
          a[i] = new TTrack(x,y,z,...);
          ...
          ...
       }
       ...
       a.Delete();
    }

(C++ version of the code)

 One better uses a [TClonesArray](@ref) which reduces the number of new/delete calls to only O(10000): 

    TClonesArray a("TTrack", 10000);
    while (TEvent *ev = (TEvent *)next()) {      // O(100000) events
       for (int i = 0; i < ev->Ntracks; i++) {   // O(10000) tracks
          new(a[i]) TTrack(x,y,z,...);
          ...
          ...
       }
       ...
       a.Delete(); // or a.Clear() or a.Clear("C")
    }

(C++ version of the code)

 To reduce the number of call to the constructor (especially useful if the user class requires memory allocation), the object can be added (and constructed when needed) using ConstructedAt which only calls the constructor once per slot. 

    TClonesArray a("TTrack", 10000);
    while (TEvent *ev = (TEvent *)next()) {      // O(100000) events
       for (int i = 0; i < ev->Ntracks; i++) {   // O(10000) tracks
          TTrack *track = (TTrack*)a.ConstructedAt(i);
          track->Set(x,y,z,....);
          ...
          ...
       }
       ...
       a.Clear(); // or a.Clear("C");
    }

(C++ version of the code)

 Note: the only supported way to add objects to a [TClonesArray](@ref) is via the new with placement method or the ConstructedAt method. The other [Add()](@ref) methods ofTObjArray and its base classes are not allowed.

Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours.

### NOTE 1

C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a "memory leak", i.e. the memory of your process grows and eventually your program crashes. Even if you *always* delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of "holes" which reduce the efficiency of memory access; this is called "memory
fragmentation". Moreover new / delete are expensive operations in terms of CPU time.

Without entering into technical details, [TClonesArray](@ref) allows you to "reuse" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the [TClonesArray](@ref) has to be reused, the [Clear()](@ref) method is used. To provide its benefits, each [TClonesArray](@ref) must be allocated *once* per process and disposed of (deleted) *only when not needed any more*.

So a job should see *only one* deletion for each [TClonesArray](@ref), which should be [Clear()](@ref)ed during the job several times. Deleting a [TClonesArray](@ref) is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the [TClonesArray](@ref) itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code.

### NOTE 2

When investigating misuse of [TClonesArray](@ref), please make sure of the following:

- Use [Clear()](@ref) or Clear("C") instead of [Delete()](@ref). This will improve program execution time.
- [TClonesArray](@ref) object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear("C") must be used for clearing [TClonesArray](@ref). When option "C" is specified, [ROOT](@ref) automatically executes the [Clear()](@ref) method (by default it is empty contained in [TObject](@ref)). This method must be overridden in the relevant [TClonesArray](@ref) object class, implementing the reset procedure for pointer objects.
- If the objects are added using the placement new then the Clear must deallocate the memory.
- If the objects are added using [TClonesArray!ConstructedAt](@ref) then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.
- To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/theend of the run.

Related functions: [`AbsorbObjects`](@ref), [`AddAfter`](@ref), [`AddAtAndExpand`](@ref), [`AddAtFree`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`AddrAt`](@ref), [`Base.getindex`](@ref), [`BypassStreamer`](@ref), [`CanBypassStreamer`](@ref), [`Clear`](@ref), [`Compress`](@ref), [`ConstructedAt`](@ref), [`Delete`](@ref), [`ExpandCreateFast`](@ref), [`ExpandCreate`](@ref), [`Expand`](@ref), [`GetClass`](@ref), [`MultiSort`](@ref), [`New`](@ref), [`RemoveAt`](@ref), [`RemoveRange`](@ref), [`Remove`](@ref), [`SetClass`](@ref), [`SetOwner`](@ref), [`Sort`](@ref), [`TClonesArray`](@ref), [`assign`](@ref)
""" TClonesArray

# Wrapper of TColor
@trydoc raw"""
    ROOT.TColor

The color creation and management class.

- [Introduction](@ref)
- [Basic colors](@ref)
- [The color wheel](@ref)
- [Bright and dark colors](@ref)
- [Gray scale view of of canvas with colors](@ref)
- [Color palettes](@ref)
- [High quality predefined palettes](@ref)

    - [Colour Vision Deficiency (CVD) friendly palettes](@ref)
    - [Non Colour Vision Deficiency (CVD) friendly palettes](@ref)
- [Palette inversion](@ref)
- [Color transparency](@ref)

## Introduction

Colors are defined by their red, green and blue components, simply called the RGB components. The colors are also known by the hue, light and saturation components also known as the HLS components. When a new color is created the components of both color systems are computed.

At initialization time, a table of colors is generated. An existing color can be retrieved by its index:

    TColor *color = gROOT->GetColor(10);

(C++ version of the code)

Then it can be manipulated. For example its RGB components can be modified:

    color->SetRGB(0.1, 0.2, 0.3);

(C++ version of the code)

A new color can be created the following way:

    Int_t ci = 1756; // color index
    auto color = new TColor(ci, 0.1, 0.2, 0.3);

(C++ version of the code)

###Since

6.07/07: TColor!GetFreeColorIndex() allows to make sure the new color is created with an unused color index:

    Int_t ci = TColor!GetFreeColorIndex();
    auto color = new TColor(ci, 0.1, 0.2, 0.3);

(C++ version of the code)

Two sets of colors are initialized;

- The basic colors: colors with index from 0 to 50.
- The color wheel: colors with indices from 300 to 1000.

## Basic colors

The following image displays the 50 basic colors.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TColor_001.png](https://root.cern/doc/v636/pict1_TColor_001.png)

## The color wheel

The wheel contains the recommended 216 colors to be used in web applications.

The colors in the color wheel are created by `TColor!CreateColorWheel`.

Using this color set for your text, background or graphics will give your application a consistent appearance across different platforms and browsers.

Colors are grouped by hue, the aspect most important in human perception. Touching color chips have the same hue, but with different brightness and vividness.

Colors of slightly different hues clash. If you intend to display colors of the same hue together, you should pick them from the same group.

Each color chip is identified by a mnemonic (e.g. kYellow) and a number. The keywords, kRed, kBlue, kYellow, kPink, etc are defined in the header file Rtypes.h that is included in all [ROOT](@ref) other header files. It is better to use these keywords in user code instead of hardcoded color numbers, e.g.:

    myObject.SetFillColor(kRed);
    myObject.SetFillColor(kYellow-10);
    myLine.SetLineColor(kMagenta+2);

(C++ version of the code)

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TColor_002.png](https://root.cern/doc/v636/pict1_TColor_002.png)

The complete list of predefined color names is the following:

    kWhite  = 0,   kBlack  = 1,   kGray    = 920,  kRed    = 632,  kGreen  = 416,
    kBlue   = 600, kYellow = 400, kMagenta = 616,  kCyan   = 432,  kOrange = 800,
    kSpring = 820, kTeal   = 840, kAzure   =  860, kViolet = 880,  kPink   = 900

(C++ version of the code)

Note the special role of color `kWhite` (color number 0). It is the default background color also. For instance in a PDF or PS files (as paper is usually white) it is simply not painted. To have a white color behaving like the other color the simplest is to define an other white color not attached to the color index 0:

    Int_t ci = TColor!GetFreeColorIndex();
    TColor *color = new TColor(ci, 1., 1., 1.);

(C++ version of the code)

## Bright and dark colors

The dark and bright color are used to give 3-D effects when drawing various boxes (see [TWbox](@ref), [TPave](@ref), [TPaveText](@ref), [TPaveLabel](@ref), etc).

- The dark colors have an index = color_index+100
- The bright colors have an index = color_index+150
- Two static functions return the bright and dark color number corresponding to a color index. If the bright or dark color does not exist, they are created: 

        Int_t dark   = TColor!GetColorDark(color_index);
        Int_t bright = TColor!GetColorBright(color_index);

(C++ version of the code)


## Grayscale view of of canvas with colors

One can toggle between a grayscale preview and the regular colored mode using `TCanvas!SetGrayscale()`. Note that in grayscale mode, access via RGB will return grayscale values according to ITU standards (and close to b&w printer gray-scales), while access via HLS returns de-saturated gray-scales. The image below shows the [ROOT](@ref) color wheel in grayscale mode.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TColor_003.png](https://root.cern/doc/v636/pict1_TColor_003.png)

## Color palettes

It is often very useful to represent a variable with a color map. The concept of "color palette" allows to do that. One color palette is active at any time. This "current palette" is set using:

    gStyle->SetPalette(...);

(C++ version of the code)

This function has two parameters: the number of colors in the palette and an array of containing the indices of colors in the palette. The following small example demonstrates how to define and use the color palette:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TColor_004.png](https://root.cern/doc/v636/pict1_TColor_004.png)

To define more a complex palette with a continuous gradient of color, one should use the static function `TColor!CreateGradientColorTable()`. The following example demonstrates how to proceed:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TColor_005.png](https://root.cern/doc/v636/pict1_TColor_005.png)

The function `TColor!CreateGradientColorTable()` automatically calls `gStyle->SetPalette()`, so there is not need to add one.

After a call to `TColor!CreateGradientColorTable()` it is sometimes useful to store the newly create palette for further use. In particular, it is recommended to do if one wants to switch between several user define palettes. To store a palette in an array it is enough to do:

    Int_t MyPalette[100];
    Double_t Red[]    = {0., 0.0, 1.0, 1.0, 1.0};
    Double_t Green[]  = {0., 0.0, 0.0, 1.0, 1.0};
    Double_t Blue[]   = {0., 1.0, 0.0, 0.0, 1.0};
    Double_t Length[] = {0., .25, .50, .75, 1.0};
    Int_t FI = TColor!CreateGradientColorTable(5, Length, Red, Green, Blue, 100);
    for (int i=0;i<100;i++) MyPalette[i] = FI+i;

(C++ version of the code)

Later on to reuse the palette `MyPalette` it will be enough to do

    gStyle->SetPalette(100, MyPalette);

(C++ version of the code)

As only one palette is active, one need to use `TExec` to be able to display plots using different palettes on the same pad. The tutorial multipalette.C illustrates this feature.

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TColor_006.png](https://root.cern/doc/v636/pict1_TColor_006.png)

###Since

6.26: The function TColor!CreateColorTableFromFile("filename.txt") allows you to create a color palette based on an input ASCII file. In contrast to TColor!CreateGradientColorTable(), here the length (spacing) is constant and can not be tuned. There is no gradient being interpolated between adjacent colors. The palette will contain the exact colors stored in the file, that comprises one line per color in the format "r g b" as floats.

## High quality predefined palettes

###Since

6.04: 63 high quality palettes are predefined with 255 colors each.

These palettes can be accessed "by name" with `gStyle->SetPalette(num)`. `num` can be taken within the following enum:

    kDeepSea=51,          kGreyScale=52,    kDarkBodyRadiator=53,
    kBlueYellow= 54,      kRainBow=55,      kInvertedDarkBodyRadiator=56,
    kBird=57,             kCubehelix=58,    kGreenRedViolet=59,
    kBlueRedYellow=60,    kOcean=61,        kColorPrintableOnGrey=62,
    kAlpine=63,           kAquamarine=64,   kArmy=65,
    kAtlantic=66,         kAurora=67,       kAvocado=68,
    kBeach=69,            kBlackBody=70,    kBlueGreenYellow=71,
    kBrownCyan=72,        kCMYK=73,         kCandy=74,
    kCherry=75,           kCoffee=76,       kDarkRainBow=77,
    kDarkTerrain=78,      kFall=79,         kFruitPunch=80,
    kFuchsia=81,          kGreyYellow=82,   kGreenBrownTerrain=83,
    kGreenPink=84,        kIsland=85,       kLake=86,
    kLightTemperature=87, kLightTerrain=88, kMint=89,
    kNeon=90,             kPastel=91,       kPearl=92,
    kPigeon=93,           kPlum=94,         kRedBlue=95,
    kRose=96,             kRust=97,         kSandyTerrain=98,
    kSienna=99,           kSolar=100,       kSouthWest=101,
    kStarryNight=102,     kSunset=103,      kTemperatureMap=104,
    kThermometer=105,     kValentine=106,   kVisibleSpectrum=107,
    kWaterMelon=108,      kCool=109,        kCopper=110,
    kGistEarth=111,       kViridis=112,     kCividis=113

(C++ version of the code)

As explained in [Crameri, F., Shephard, G.E. & Heron, P.J. The misuse of colour in science communication. Nat Commun 11, 5444 (2020)](https://doi.org/10.1038/s41467-020-19160-7) some color maps can visually distord data, specially for people with colour-vision deficiencies.

For instance one can immediately see the [disadvantages of the Rainbow color map](https://root.cern.ch/rainbow-color-map), which is misleading for colour-blinded people in a 2D plot (not so much in a 3D surfaces).

The `kCMYK` palette, is also not great because it's dark, then lighter, then half-dark again. Some others, like `kAquamarine`, have almost no contrast therefore it would be almost impossible (for a color blind person) to see something with a such palette.

Therefore the palettes are classified in two categories: those which are Colour Vision Deficiency friendly and those which are not.

An easy way to classify the palettes is to turn them into grayscale using [TCanvas!SetGrayscale()](@ref). The grayscale version of a palette should be as proportional as possible, and monotonously increasing or decreasing.

Unless it is symmetrical, then it is fine to have white in the borders and black in the centre (for example an axis that goes between -40 degrees and +40 degrees, the 0 has a meaning in the perceptualcolormap.C example).

A full set of colour-vision deficiency friendly and perceptually uniform colour maps can be [downloaded](https://doi.org/10.5281/zenodo.4491293) and used with [ROOT](@ref) (since 6.26) via: `gStyle->SetPalette("filename.txt")` or `TColor!CreateColorTableFromFile("filename.txt")`. Remember to increase the number of contours for a smoother result, e.g.: `gStyle->SetNumberContours(99)` if you are drawing with "surf1z" or `gStyle->SetNumberContours(256)` if with "colz".

### Colour Vision Deficiency (CVD) friendly palettes

| **Col. 1**                                                                                          | **Col. 2**                                                                                          | **Col. 3**                                                                                          |
|:----------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------|
| ![https://root.cern/doc/v636/pict1_TColor_007.png](https://root.cern/doc/v636/pict1_TColor_007.png) | ![https://root.cern/doc/v636/pict1_TColor_008.png](https://root.cern/doc/v636/pict1_TColor_008.png) | ![https://root.cern/doc/v636/pict1_TColor_009.png](https://root.cern/doc/v636/pict1_TColor_009.png) |
| ![https://root.cern/doc/v636/pict1_TColor_010.png](https://root.cern/doc/v636/pict1_TColor_010.png) | ![https://root.cern/doc/v636/pict1_TColor_011.png](https://root.cern/doc/v636/pict1_TColor_011.png) | ![https://root.cern/doc/v636/pict1_TColor_012.png](https://root.cern/doc/v636/pict1_TColor_012.png) |
| ![https://root.cern/doc/v636/pict1_TColor_013.png](https://root.cern/doc/v636/pict1_TColor_013.png) | ![https://root.cern/doc/v636/pict1_TColor_014.png](https://root.cern/doc/v636/pict1_TColor_014.png) | ![https://root.cern/doc/v636/pict1_TColor_015.png](https://root.cern/doc/v636/pict1_TColor_015.png) |
| ![https://root.cern/doc/v636/pict1_TColor_016.png](https://root.cern/doc/v636/pict1_TColor_016.png) | ![https://root.cern/doc/v636/pict1_TColor_017.png](https://root.cern/doc/v636/pict1_TColor_017.png) | ![https://root.cern/doc/v636/pict1_TColor_018.png](https://root.cern/doc/v636/pict1_TColor_018.png) |
| ![https://root.cern/doc/v636/pict1_TColor_019.png](https://root.cern/doc/v636/pict1_TColor_019.png) | ![https://root.cern/doc/v636/pict1_TColor_020.png](https://root.cern/doc/v636/pict1_TColor_020.png) | ![https://root.cern/doc/v636/pict1_TColor_021.png](https://root.cern/doc/v636/pict1_TColor_021.png) |
| ![https://root.cern/doc/v636/pict1_TColor_022.png](https://root.cern/doc/v636/pict1_TColor_022.png) | ![https://root.cern/doc/v636/pict1_TColor_023.png](https://root.cern/doc/v636/pict1_TColor_023.png) | ![https://root.cern/doc/v636/pict1_TColor_024.png](https://root.cern/doc/v636/pict1_TColor_024.png) |
| ![https://root.cern/doc/v636/pict1_TColor_025.png](https://root.cern/doc/v636/pict1_TColor_025.png) | ![https://root.cern/doc/v636/pict1_TColor_026.png](https://root.cern/doc/v636/pict1_TColor_026.png) | ![https://root.cern/doc/v636/pict1_TColor_027.png](https://root.cern/doc/v636/pict1_TColor_027.png) |
| ![https://root.cern/doc/v636/pict1_TColor_028.png](https://root.cern/doc/v636/pict1_TColor_028.png) | ![https://root.cern/doc/v636/pict1_TColor_029.png](https://root.cern/doc/v636/pict1_TColor_029.png) | ![https://root.cern/doc/v636/pict1_TColor_030.png](https://root.cern/doc/v636/pict1_TColor_030.png) |
| ![https://root.cern/doc/v636/pict1_TColor_031.png](https://root.cern/doc/v636/pict1_TColor_031.png) | ![https://root.cern/doc/v636/pict1_TColor_032.png](https://root.cern/doc/v636/pict1_TColor_032.png) | ![https://root.cern/doc/v636/pict1_TColor_033.png](https://root.cern/doc/v636/pict1_TColor_033.png) |
| ![https://root.cern/doc/v636/pict1_TColor_034.png](https://root.cern/doc/v636/pict1_TColor_034.png) | ![https://root.cern/doc/v636/pict1_TColor_035.png](https://root.cern/doc/v636/pict1_TColor_035.png) | ![https://root.cern/doc/v636/pict1_TColor_036.png](https://root.cern/doc/v636/pict1_TColor_036.png) |
| ![https://root.cern/doc/v636/pict1_TColor_037.png](https://root.cern/doc/v636/pict1_TColor_037.png) | ![https://root.cern/doc/v636/pict1_TColor_038.png](https://root.cern/doc/v636/pict1_TColor_038.png) | ![https://root.cern/doc/v636/pict1_TColor_039.png](https://root.cern/doc/v636/pict1_TColor_039.png) |
| ![https://root.cern/doc/v636/pict1_TColor_040.png](https://root.cern/doc/v636/pict1_TColor_040.png) | ![https://root.cern/doc/v636/pict1_TColor_041.png](https://root.cern/doc/v636/pict1_TColor_041.png) | ![https://root.cern/doc/v636/pict1_TColor_042.png](https://root.cern/doc/v636/pict1_TColor_042.png) |
| ![https://root.cern/doc/v636/pict1_TColor_043.png](https://root.cern/doc/v636/pict1_TColor_043.png) | ![https://root.cern/doc/v636/pict1_TColor_044.png](https://root.cern/doc/v636/pict1_TColor_044.png) | ![https://root.cern/doc/v636/pict1_TColor_045.png](https://root.cern/doc/v636/pict1_TColor_045.png) |

### Non Colour Vision Deficiency (CVD) friendly palettes

| **Col. 1**                                                                                          | **Col. 2**                                                                                          | **Col. 3**                                                                                          |
|:----------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------|
| ![https://root.cern/doc/v636/pict1_TColor_046.png](https://root.cern/doc/v636/pict1_TColor_046.png) | ![https://root.cern/doc/v636/pict1_TColor_047.png](https://root.cern/doc/v636/pict1_TColor_047.png) | ![https://root.cern/doc/v636/pict1_TColor_048.png](https://root.cern/doc/v636/pict1_TColor_048.png) |
| ![https://root.cern/doc/v636/pict1_TColor_049.png](https://root.cern/doc/v636/pict1_TColor_049.png) | ![https://root.cern/doc/v636/pict1_TColor_050.png](https://root.cern/doc/v636/pict1_TColor_050.png) | ![https://root.cern/doc/v636/pict1_TColor_051.png](https://root.cern/doc/v636/pict1_TColor_051.png) |
| ![https://root.cern/doc/v636/pict1_TColor_052.png](https://root.cern/doc/v636/pict1_TColor_052.png) | ![https://root.cern/doc/v636/pict1_TColor_053.png](https://root.cern/doc/v636/pict1_TColor_053.png) | ![https://root.cern/doc/v636/pict1_TColor_054.png](https://root.cern/doc/v636/pict1_TColor_054.png) |
| ![https://root.cern/doc/v636/pict1_TColor_055.png](https://root.cern/doc/v636/pict1_TColor_055.png) | ![https://root.cern/doc/v636/pict1_TColor_056.png](https://root.cern/doc/v636/pict1_TColor_056.png) | ![https://root.cern/doc/v636/pict1_TColor_057.png](https://root.cern/doc/v636/pict1_TColor_057.png) |
| ![https://root.cern/doc/v636/pict1_TColor_058.png](https://root.cern/doc/v636/pict1_TColor_058.png) | ![https://root.cern/doc/v636/pict1_TColor_059.png](https://root.cern/doc/v636/pict1_TColor_059.png) | ![https://root.cern/doc/v636/pict1_TColor_060.png](https://root.cern/doc/v636/pict1_TColor_060.png) |
| ![https://root.cern/doc/v636/pict1_TColor_061.png](https://root.cern/doc/v636/pict1_TColor_061.png) | ![https://root.cern/doc/v636/pict1_TColor_062.png](https://root.cern/doc/v636/pict1_TColor_062.png) | ![https://root.cern/doc/v636/pict1_TColor_063.png](https://root.cern/doc/v636/pict1_TColor_063.png) |
| ![https://root.cern/doc/v636/pict1_TColor_064.png](https://root.cern/doc/v636/pict1_TColor_064.png) | ![https://root.cern/doc/v636/pict1_TColor_065.png](https://root.cern/doc/v636/pict1_TColor_065.png) | ![https://root.cern/doc/v636/pict1_TColor_066.png](https://root.cern/doc/v636/pict1_TColor_066.png) |
| ![https://root.cern/doc/v636/pict1_TColor_067.png](https://root.cern/doc/v636/pict1_TColor_067.png) | ![https://root.cern/doc/v636/pict1_TColor_068.png](https://root.cern/doc/v636/pict1_TColor_068.png) | ![https://root.cern/doc/v636/pict1_TColor_069.png](https://root.cern/doc/v636/pict1_TColor_069.png) |

## Palette inversion

Once a palette is defined, it is possible to invert the color order thanks to the method [TColor!InvertPalette](@ref). The top of the palette becomes the bottom and vice versa.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TColor_070.png](https://root.cern/doc/v636/pict1_TColor_070.png)

## Color transparency

To make a graphics object transparent it is enough to set its color to a transparent one. The color transparency is defined via its alpha component. The alpha value varies from `0.` (fully transparent) to `1.` (fully opaque). To set the alpha value of an existing color it is enough to do:

    TColor *col26 = gROOT->GetColor(26);
    col26->SetAlpha(0.01);

(C++ version of the code)

A new color can be created transparent the following way:

    Int_t ci = 1756;
    auto color = new TColor(ci, 0.1, 0.2, 0.3, "", 0.5); // alpha = 0.5

(C++ version of the code)

An example of transparency usage with parallel coordinates can be found in parallelcoordtrans.C.

To ease the creation of a transparent color the static method `GetColorTransparent(Int_t color, Float_t a)` is provided. In the following example the `trans_red` color index point to a red color 30% opaque (70% transparent). The alpha value of the color index `kRed` is not modified.

    Int_t trans_red = GetColorTransparent(kRed, 0.3);

(C++ version of the code)

This function is also used in the methods `SetFillColorAlpha()`, `SetLineColorAlpha()`, `SetMarkerColorAlpha()` and `SetTextColorAlpha()`. In the following example the fill color of the histogram `histo` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    histo->SetFillColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

The following macro gives an example of transparency usage:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TColor_071.png](https://root.cern/doc/v636/pict1_TColor_071.png)

Related functions: [`AsHexString`](@ref), [`Copy`](@ref), [`GetAlpha`](@ref), [`GetBlue`](@ref), [`GetGrayscale`](@ref), [`GetGreen`](@ref), [`GetHLS`](@ref), [`GetHue`](@ref), [`GetLight`](@ref), [`GetNumber`](@ref), [`GetPixel`](@ref), [`GetRGB`](@ref), [`GetRed`](@ref), [`GetSaturation`](@ref), [`IsA`](@ref), [`Print`](@ref), [`SetAlpha`](@ref), [`SetRGB`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TColor!Class_Name`](@ref), [`TColor!Class_Version`](@ref), [`TColor!Class`](@ref), [`TColor!CreateColorTableFromFile`](@ref), [`TColor!CreateColorWheel`](@ref), [`TColor!CreateColorsCircle`](@ref), [`TColor!CreateColorsGray`](@ref), [`TColor!CreateColorsRectangle`](@ref), [`TColor!CreateGradientColorTable`](@ref), [`TColor!DeclFileName`](@ref), [`TColor!DefinedColors`](@ref), [`TColor!GetColorBright`](@ref), [`TColor!GetColorByName`](@ref), [`TColor!GetColorDark`](@ref), [`TColor!GetColorPalette`](@ref), [`TColor!GetColorTransparent`](@ref), [`TColor!GetColor`](@ref), [`TColor!GetFreeColorIndex`](@ref), [`TColor!GetLinearGradient`](@ref), [`TColor!GetNumberOfColors`](@ref), [`TColor!GetPalette`](@ref), [`TColor!GetRadialGradient`](@ref), [`TColor!HLS2RGB`](@ref), [`TColor!HLStoRGB`](@ref), [`TColor!HSV2RGB`](@ref), [`TColor!InitializeColors`](@ref), [`TColor!InvertPalette`](@ref), [`TColor!IsGrayscale`](@ref), [`TColor!ListColors`](@ref), [`TColor!Number2Pixel`](@ref), [`TColor!Pixel2RGB`](@ref), [`TColor!PixelAsHexString`](@ref), [`TColor!RGB2HLS`](@ref), [`TColor!RGB2HSV`](@ref), [`TColor!RGB2Pixel`](@ref), [`TColor!RGBtoHLS`](@ref), [`TColor!SaveColor`](@ref), [`TColor!SetColorThreshold`](@ref), [`TColor!SetGrayscale`](@ref), [`TColor!SetPalette`](@ref), [`TColor`](@ref), [`assign`](@ref), [`ls`](@ref)
""" TColor

# Wrapper of TColorGradient
@trydoc raw"""
    ROOT.TColorGradient

[TColorGradient](@ref) extends basic [TColor](@ref).

Actually, this is not a simple color, but linear gradient + shadow for filled area. By inheriting from [TColor](@ref), gradients can be placed inside gROOT's list of colors and use it in all TAttXXX descendants without modifying any existing code.

Shadow, of course, is not a property of any color, and gradient is not, but this is the best way to add new attributes to filled area without re-writing all the graphics code.

Related functions: [`GetColorAlpha`](@ref), [`GetColorPositions`](@ref), [`GetColors`](@ref), [`GetCoordinateMode`](@ref), [`GetNumberOfSteps`](@ref), [`IsA`](@ref), [`ResetColor`](@ref), [`SetColorAlpha`](@ref), [`SetCoordinateMode`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TColorGradient!Class_Name`](@ref), [`TColorGradient!Class_Version`](@ref), [`TColorGradient!Class`](@ref), [`TColorGradient!DeclFileName`](@ref), [`TColorGradient`](@ref)
""" TColorGradient

# Wrapper of TLinearGradient
@trydoc raw"""
    ROOT.TLinearGradient





Related functions: [`GetEnd`](@ref), [`GetStart`](@ref), [`IsA`](@ref), [`SetStartEnd`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TColorGradient`](@ref), [`TLinearGradient!Class_Name`](@ref), [`TLinearGradient!Class_Version`](@ref), [`TLinearGradient!Class`](@ref), [`TLinearGradient!DeclFileName`](@ref), [`TLinearGradient`](@ref)
""" TLinearGradient

# Wrapper of TRadialGradient
@trydoc raw"""
    ROOT.TRadialGradient





Related functions: [`GetCenter`](@ref), [`GetEnd`](@ref), [`GetGradientType`](@ref), [`GetR1`](@ref), [`GetR2`](@ref), [`GetRadius`](@ref), [`GetStart`](@ref), [`IsA`](@ref), [`SetRadialGradient`](@ref), [`SetStartEndR1R2`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TColorGradient`](@ref), [`TRadialGradient!Class_Name`](@ref), [`TRadialGradient!Class_Version`](@ref), [`TRadialGradient!Class`](@ref), [`TRadialGradient!DeclFileName`](@ref), [`TRadialGradient`](@ref)
""" TRadialGradient

# Wrapper of TDatime
@trydoc raw"""
    ROOT.TDatime

This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559).

The date is stored with the origin being the 1st January 1995.

This class has no support for time zones. The time is assumed to be in the local_ time of the machine where the object was created. As a result, [TDatime](@ref) objects are not portable between machines operating in different time zones and unsuitable for storing the date/time of data taking events and the like. If absolute time is required, use [TTimeStamp](@ref).

Related functions: [`AsSQLString`](@ref), [`AsString`](@ref), [`Convert`](@ref), [`Copy`](@ref), [`FillBuffer`](@ref), [`GetDate`](@ref), [`GetDayOfWeek`](@ref), [`GetDay`](@ref), [`GetHour`](@ref), [`GetMinute`](@ref), [`GetMonth`](@ref), [`GetSecond`](@ref), [`GetTime`](@ref), [`GetYear`](@ref), [`Get`](@ref), [`IsA`](@ref), [`Print`](@ref), [`ReadBuffer`](@ref), [`Set`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TDatime!Class_Name`](@ref), [`TDatime!Class_Version`](@ref), [`TDatime!Class`](@ref), [`TDatime!DeclFileName`](@ref), [`TDatime!GetDateFromGlobalDay`](@ref), [`TDatime!GetDateTime`](@ref), [`TDatime!GetGlobalDayFromDate`](@ref), [`TDatime!GetLegalGlobalDayFromDate`](@ref), [`TDatime`](@ref), [`assign`](@ref)
""" TDatime

# Wrapper of TUUID
@trydoc raw"""
    ROOT.TUUID

This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier).

A UUID is 128 bits long, and if generated according to this algorithm, is either guaranteed to be different from all other UUIDs/GUIDs generated until 3400 A.D. or extremely likely to be different. UUIDs were originally used in the Network Computing System (NCS) and later in the Open Software Foundation's (OSF) Distributed Computing Environment (DCE).

###Note

In the way this UUID is constructed, when used outside of their original concept (NCS), they are actually not Globally unique and indeed multiple distinct concurrent processes are actually likely to generate the same UUID. Technically this is because the UUID is constructed only from the node information and time information. To make a globally unique number, this needs to be combined with TProcessUUID.

Structure of universal unique IDs (UUIDs).

Depending on the network data representation, the multi- octet unsigned integer fields are subject to byte swapping when communicated between dissimilar endian machines. 

    +-----------------------------------+
    |     low 32 bits of time           |  0-3   .fTimeLow
    +-------------------------------+----
    |     mid 16 bits of time       |      4-5   .fTimeMid
    +-------+-----------------------+
    | vers. |   hi 12 bits of time  |      6-7   .fTimeHiAndVersion
    +-------+-------+---------------+
    |Res | clkSeqHi |                      8     .fClockSeqHiAndReserved
    +---------------+
    |   clkSeqLow   |                      9     .fClockSeqLow
    +---------------+------------------+
    |            node ID               |   10-15 .fNode
    +----------------------------------+

(C++ version of the code)

The adjusted time stamp is split into three fields, and the clockSeq is split into two fields.

The timestamp is a 60-bit value. For UUID version 1, this is represented by Coordinated Universal Time (UTC/GMT) as a count of 100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar).

The version number is multiplexed in the 4 most significant bits of the 'fTimeHiAndVersion' field. There are two defined versions: 

                  MSB <---
    Version      4-Bit Code      Description
    ------------------------------------------------------------
    |  1           0 0 0 1     DCE version, as specified herein.
    |  2           0 0 1 0     DCE Security version, with
    |                          embedded POSIX UIDs.
    |  3           0 0 1 1     node id is a random value
    ------------------------------------------------------------

(C++ version of the code)

## Clock Sequence

The clock sequence value must be changed whenever:

The UUID generator detects that the local_ value of UTC has gone backward; this may be due to re-syncing of the system clock.

While a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.

The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly.

## Clock Adjustment

UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is read and incremented, and then added to the UTC time field of the UUID.

## Clock Overrun

The 100-nanosecond granularity of time should prove sufficient even for bursts of UUID production in the next generation of high-performance multiprocessors. If a system overruns the clock adjustment by requesting too many UUIDs within a single system clock tick, the UUID generator will stall until the system clock catches up.

Related functions: [`AsString`](@ref), [`Compare`](@ref), [`FillBuffer`](@ref), [`GetHostAddress`](@ref), [`GetTime`](@ref), [`GetUUIDNumber`](@ref), [`GetUUID`](@ref), [`Hash`](@ref), [`IsA`](@ref), [`Print`](@ref), [`ReadBuffer`](@ref), [`SetUUIDNumber`](@ref), [`SetUUID`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`StreamerV1`](@ref), [`Streamer`](@ref), [`TUUID!Class_Name`](@ref), [`TUUID!Class_Version`](@ref), [`TUUID!Class`](@ref), [`TUUID!DeclFileName`](@ref), [`TUUID`](@ref)
""" TUUID

# Wrapper of TInetAddress
@trydoc raw"""
    ROOT.TInetAddress

This class represents an Internet Protocol (IP) address.



Related functions: [`GetAddressBytes`](@ref), [`GetAddress`](@ref), [`GetAddresses`](@ref), [`GetAliases`](@ref), [`GetFamily`](@ref), [`GetHostAddress`](@ref), [`GetHostName`](@ref), [`GetPort`](@ref), [`IsA`](@ref), [`IsValid`](@ref), [`Print`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TInetAddress!Class_Name`](@ref), [`TInetAddress!Class_Version`](@ref), [`TInetAddress!Class`](@ref), [`TInetAddress!DeclFileName`](@ref), [`TInetAddress!GetHostAddress`](@ref), [`TInetAddress`](@ref), [`assign`](@ref)
""" TInetAddress

# Wrapper of TDirectory
@trydoc raw"""
    ROOT.TDirectory

Describe directory structure in memory.



Related functions: [`Add`](@ref), [`AppendKey`](@ref), [`Append`](@ref), [`Browse`](@ref), [`Build`](@ref), [`Clear`](@ref), [`CloneObject`](@ref), [`Close`](@ref), [`Copy`](@ref), [`DeleteAll`](@ref), [`Delete`](@ref), [`Draw`](@ref), [`FindKeyAny`](@ref), [`FindKey`](@ref), [`FindObjectAnyFile`](@ref), [`FindObjectAny`](@ref), [`FindObject`](@ref), [`GetBufferSize`](@ref), [`GetDirectory`](@ref), [`GetFile`](@ref), [`GetKey`](@ref), [`GetListOfKeys`](@ref), [`GetList`](@ref), [`GetMotherDir`](@ref), [`GetMother`](@ref), [`GetNbytesKeys`](@ref), [`GetNkeys`](@ref), [`GetObjectChecked`](@ref), [`GetObjectUnchecked`](@ref), [`GetObject`](@ref), [`GetPathStatic`](@ref), [`GetPath`](@ref), [`GetSeekDir`](@ref), [`GetSeekKeys`](@ref), [`GetSeekParent`](@ref), [`GetUUID`](@ref), [`Get`](@ref), [`IsA`](@ref), [`IsBuilt`](@ref), [`IsFolder`](@ref), [`IsModified`](@ref), [`IsWritable`](@ref), [`OpenFile`](@ref), [`Paint`](@ref), [`Print`](@ref), [`Purge`](@ref), [`ReadAll`](@ref), [`ReadKeys`](@ref), [`ReadTObject`](@ref), [`RecursiveRemove`](@ref), [`Remove`](@ref), [`SaveObjectAs`](@ref), [`SaveSelf`](@ref), [`Save`](@ref), [`SetBufferSize`](@ref), [`SetModified`](@ref), [`SetMother`](@ref), [`SetName`](@ref), [`SetSeekDir`](@ref), [`SetTRefAction`](@ref), [`SetWritable`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TDirectory!AddDirectoryStatus`](@ref), [`TDirectory!AddDirectory`](@ref), [`TDirectory!Cd`](@ref), [`TDirectory!Class_Name`](@ref), [`TDirectory!Class_Version`](@ref), [`TDirectory!Class`](@ref), [`TDirectory!CurrentDirectory`](@ref), [`TDirectory!DeclFileName`](@ref), [`TDirectory!DecodeNameCycle`](@ref), [`TDirectory`](@ref), [`WriteDirHeader`](@ref), [`WriteKeys`](@ref), [`WriteObjectAny`](@ref), [`WriteObject`](@ref), [`WriteTObject`](@ref), [`Write`](@ref), [`cd`](@ref), [`ls`](@ref), [`mkdir`](@ref), [`pwd`](@ref), [`rmdir`](@ref)
""" TDirectory

# Wrapper of TKey
@trydoc raw"""
    ROOT.TKey

Book space in a file, create I/O buffers, to fill them, (un)compress them.

The [TKey](@ref) class includes functions to book space in a file, to create I/O buffers, to fill these buffers, to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must be created. The key structure contains all the information to uniquely identify a persistent object in a file. 
| **Data Member** | **Explanation**                                                                                                                 |
|:----------------|:--------------------------------------------------------------------------------------------------------------------------------|
| fNbytes         | Number of bytes for the compressed object and key.                                                                              |
| fObjlen         | Length of uncompressed object.                                                                                                  |
| fDatime         | Date/Time when the object was written.                                                                                          |
| fKeylen         | Number of bytes for the key structure.                                                                                          |
| fCycle          | Cycle number of the object.                                                                                                     |
| fSeekKey        | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |
| fSeekPdir       | Pointer to the directory supporting this object.                                                                                |
| fClassName      | Object class name.                                                                                                              |
| fName           | Name of the object.                                                                                                             |
| fTitle          | Title of the object.                                                                                                            |

In the 16 highest bits of fSeekPdir is encoded a pid offset. This offset is to be added to the pid index stored in the [TRef](@ref) object and the referenced [TObject](@ref).

The [TKey](@ref) class is used by [ROOT](@ref) to:

- Write an object in the current directory
- Write a new ntuple buffer

The structure of a file is shown in TFile!TFile. The structure of a directory is shown in TDirectoryFile!TDirectoryFile. The [TKey](@ref) class is used by the [TBasket](@ref) class. See also [TTree](@ref).

Related functions: [`Browse`](@ref), [`ClassDefOverride`](@ref), [`DeleteBuffer`](@ref), [`Delete`](@ref), [`FillBuffer`](@ref), [`GetBufferRef`](@ref), [`GetBuffer`](@ref), [`GetClassName`](@ref), [`GetCycle`](@ref), [`GetDatime`](@ref), [`GetFile`](@ref), [`GetIconName`](@ref), [`GetKeep`](@ref), [`GetKeylen`](@ref), [`GetMotherDir`](@ref), [`GetNbytes`](@ref), [`GetObjlen`](@ref), [`GetSeekKey`](@ref), [`GetSeekPdir`](@ref), [`GetTitle`](@ref), [`GetVersion`](@ref), [`IncrementPidOffset`](@ref), [`IsFolder`](@ref), [`Keep`](@ref), [`Print`](@ref), [`ReadBuffer`](@ref), [`ReadFile`](@ref), [`ReadKeyBuffer`](@ref), [`ReadObjWithBuffer`](@ref), [`ReadObj`](@ref), [`ReadObjectAny`](@ref), [`ReadObject`](@ref), [`Read`](@ref), [`SetBuffer`](@ref), [`SetMotherDir`](@ref), [`SetParent`](@ref), [`Sizeof`](@ref), [`TKey`](@ref), [`WriteFile`](@ref), [`ls`](@ref)
""" TKey

# Wrapper of TFile
@trydoc raw"""
    ROOT.TFile

A [ROOT](@ref) file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies.

###See

Input/Output Library 

###See

rootio (or io/doc/TFile folder in your codebase)

 **[ROOT](@ref) file data format specification**

A [ROOT](@ref) file is composed of a header, followed by consecutive data records (`TKey` instances) with a well defined format.

The first data record starts at byte fBEGIN (currently set to kBEGIN). Bytes 1->kBEGIN contain the file description, when fVersion >= 1000000 it is a large file (> 2 GB) and the offsets will be 8 bytes long and fUnits will be set to 8:

| **Byte Range**  | **Record Name** | **Description**                                    |
|:----------------|:----------------|:---------------------------------------------------|
| 1->4            | "root"          | Root file identifier                               |
| 5->8            | fVersion        | File format version                                |
| 9->12           | fBEGIN          | Pointer to first data record                       |
| 13->16 [13->20] | fEND            | Pointer to first free word at the EOF              |
| 17->20 [21->28] | fSeekFree       | Pointer to FREE data record                        |
| 21->24 [29->32] | fNbytesFree     | Number of bytes in FREE data record                |
| 25->28 [33->36] | nfree           | Number of free data records                        |
| 29->32 [37->40] | fNbytesName     | Number of bytes in [TNamed](@ref) at creation time |
| 33->33 [41->41] | fUnits          | Number of bytes for file pointers                  |
| 34->37 [42->45] | fCompress       | Compression level and algorithm                    |
| 38->41 [46->53] | fSeekInfo       | Pointer to [TStreamerInfo](@ref) record            |
| 42->45 [54->57] | fNbytesInfo     | Number of bytes in [TStreamerInfo](@ref) record    |
| 46->63 [58->75] | fUUID           | Universal Unique ID                                |

For the purpose of magic bytes in the context of [ROOT](@ref) files' MIME definition, the following additional requirements are introduced:

- The value of `fBEGIN` is fixed at 100.
- The four bytes starting at position 96 are reserved and must be 0. If any changes to this need to be made, `media-types@iana.org` needs to be notified in accordance with RFC 6838.

The key structure is as follows; if a key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 instead of 4 bytes (see parts marked with square brackets below):

| **Byte Range**  | **Member Name** | **Description**                               |
|:----------------|:----------------|:----------------------------------------------|
| 1->4            | Nbytes          | Length of compressed object (in bytes)        |
| 5->6            | Version         | [TKey](@ref) version identifier               |
| 7->10           | ObjLen          | Length of uncompressed object                 |
| 11->14          | Datime          | Date and time when object was written to file |
| 15->16          | KeyLen          | Length of the key structure (in bytes)        |
| 17->18          | Cycle           | Cycle of key                                  |
| 19->22 [19->26] | SeekKey         | Pointer to record itself (consistency check)  |
| 23->26 [27->34] | SeekPdir        | Pointer to directory header                   |
| 27->27 [35->35] | lname           | Number of bytes in the class name             |
| 28->.. [36->..] | ClassName       | Object Class Name                             |
| ..->..          | lname           | Number of bytes in the object name            |
| ..->..          | Name            | lName bytes with the name of the object       |
| ..->..          | lTitle          | Number of bytes in the object title           |
| ..->..          | Title           | Title of the object                           |
| -->            | DATA            | Data bytes associated to the object           |

![https://root.cern/doc/v636/pict1_TFile_001.png](https://root.cern/doc/v636/pict1_TFile_001.png)

The structure of a directory is shown in TDirectoryFile!TDirectoryFile

Related functions: [`Close`](@ref), [`Copy`](@ref), [`Cp`](@ref), [`CreateKey`](@ref), [`Delete`](@ref), [`DrawMap`](@ref), [`Draw`](@ref), [`FillBuffer`](@ref), [`Flush`](@ref), [`GetArchiveOffset`](@ref), [`GetArchive`](@ref), [`GetBestBuffer`](@ref), [`GetBytesReadExtra`](@ref), [`GetBytesRead`](@ref), [`GetBytesToPrefetch`](@ref), [`GetBytesWritten`](@ref), [`GetCacheRead`](@ref), [`GetCacheWrite`](@ref), [`GetClassIndex`](@ref), [`GetCompressionAlgorithm`](@ref), [`GetCompressionFactor`](@ref), [`GetCompressionLevel`](@ref), [`GetCompressionSettings`](@ref), [`GetEND`](@ref), [`GetEndpointUrl`](@ref), [`GetErrno`](@ref), [`GetFd`](@ref), [`GetListOfFree`](@ref), [`GetListOfProcessIDs`](@ref), [`GetNProcessIDs`](@ref), [`GetNbytesFree`](@ref), [`GetNbytesInfo`](@ref), [`GetNewUrl`](@ref), [`GetNfree`](@ref), [`GetOption`](@ref), [`GetReadCalls`](@ref), [`GetRecordHeader`](@ref), [`GetRelOffset`](@ref), [`GetSeekFree`](@ref), [`GetSeekInfo`](@ref), [`GetSize`](@ref), [`GetStreamerInfoCache`](@ref), [`GetStreamerInfoList`](@ref), [`GetVersion`](@ref), [`IncrementProcessIDs`](@ref), [`IsArchive`](@ref), [`IsBinary`](@ref), [`IsOpen`](@ref), [`IsRaw`](@ref), [`MakeFree`](@ref), [`MakeProject`](@ref), [`Map`](@ref), [`Matches`](@ref), [`MustFlush`](@ref), [`Paint`](@ref), [`Print`](@ref), [`ReOpen`](@ref), [`ReadBufferAsync`](@ref), [`ReadBuffer`](@ref), [`ReadBuffers`](@ref), [`ReadFree`](@ref), [`ReadProcessID`](@ref), [`ReadStreamerInfo`](@ref), [`Recover`](@ref), [`ResetErrno`](@ref), [`Seek`](@ref), [`SetCacheRead`](@ref), [`SetCacheWrite`](@ref), [`SetCompressionAlgorithm`](@ref), [`SetCompressionLevel`](@ref), [`SetCompressionSettings`](@ref), [`SetEND`](@ref), [`SetOffset`](@ref), [`SetOption`](@ref), [`SetReadCalls`](@ref), [`ShowStreamerInfo`](@ref), [`Sizeof`](@ref), [`SumBuffer`](@ref), [`TFile!AsyncOpen`](@ref), [`TFile!Cp`](@ref), [`TFile!CurrentFile`](@ref), [`TFile!GetAsyncOpenStatus`](@ref), [`TFile!GetCacheFileDir`](@ref), [`TFile!GetEndpointUrl`](@ref), [`TFile!GetFileBytesRead`](@ref), [`TFile!GetFileBytesWritten`](@ref), [`TFile!GetFileCounter`](@ref), [`TFile!GetFileReadCalls`](@ref), [`TFile!GetOnlyStaged`](@ref), [`TFile!GetOpenTimeout`](@ref), [`TFile!GetReadStreamerInfo`](@ref), [`TFile!GetReadaheadSize`](@ref), [`TFile!GetType`](@ref), [`TFile!IncrementFileCounter`](@ref), [`TFile!Open`](@ref), [`TFile!SetCacheFileDir`](@ref), [`TFile!SetFileBytesRead`](@ref), [`TFile!SetFileBytesWritten`](@ref), [`TFile!SetFileReadCalls`](@ref), [`TFile!SetOnlyStaged`](@ref), [`TFile!SetOpenTimeout`](@ref), [`TFile!SetReadStreamerInfo`](@ref), [`TFile!SetReadaheadSize`](@ref), [`TFile!ShrinkCacheFileDir`](@ref), [`TFile`](@ref), [`WriteBuffer`](@ref), [`WriteFree`](@ref), [`WriteHeader`](@ref), [`WriteProcessID`](@ref), [`WriteStreamerInfo`](@ref), [`Write`](@ref), [`ls`](@ref)
""" TFile

# Wrapper of TEnv
@trydoc raw"""
    ROOT.TEnv

The [TEnv](@ref) class reads config files, by default named `.rootrc`.

Three types of config files are read: global_, user and local_ files. The global_ file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`) the user file is `$HOME/<name>` and the local_ file is `./<name>`. By setting the shell variable `ROOTENV_NO_HOME=1` the reading of the `$HOME/<name>` resource file will be skipped. This might be useful in case the home directory resides on an auto-mounted remote file system and one wants to avoid this file system from being mounted.

The format of the `.rootrc` file is similar to the `.Xdefaults` format: 

    [+]<SystemName>.<RootName|ProgName>.<name>[(type)]:  <value>

(C++ version of the code)

 Where `<SystemName>` is either Unix, WinNT, MacOS or Vms, `<RootName>` the name as given in the [TApplication](@ref) ctor (or "RootApp" in case no explicit [TApplication](@ref) derived object was created), `<ProgName>` the current program name and `<name>` the resource name, with optionally a type specification. `<value>` can be either a string, an integer, a float/double or a boolean with the values TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as an integer 0 or 1. The options [+] allows the concatenation of values to the same resource name.

E.g.: 

    Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib
    myapp.Root.Debug:  FALSE
    TH.Root.Debug: YES
    *.Root.ObjStat: 1

(C++ version of the code)

 `<SystemName>` and `<ProgName>` or `<RootName>` may be the wildcard "*". A # in the first column starts comment line.

Note that the environment variables (like $ROOTSYS) need to be surrounded in parentheses in order to be expanded.

For the currently defined resources (and their default values) see `$ROOTSYS/etc/system.rootrc`.

Note that the .rootrc config files contain the config for all [ROOT](@ref) based applications.

To add new entries to a [TEnv](@ref): 

    TEnv env(".myfile");
    env.SetValue("myname","value");
    env.SaveLevel(kEnvLocal);

(C++ version of the code)

 All new entries will be saved in the file corresponding to the first [SaveLevel()](@ref) command. If [Save()](@ref) is used, new entries go into the local_ file by default.

Related functions: [`Defined`](@ref), [`GetRcName`](@ref), [`GetTable`](@ref), [`GetValue`](@ref), [`IgnoreDuplicates`](@ref), [`IsA`](@ref), [`Lookup`](@ref), [`PrintEnv`](@ref), [`Print`](@ref), [`ReadFile`](@ref), [`SaveLevel`](@ref), [`Save`](@ref), [`SetRcName`](@ref), [`SetValue`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TEnv!Class_Name`](@ref), [`TEnv!Class_Version`](@ref), [`TEnv!Class`](@ref), [`TEnv!DeclFileName`](@ref), [`TEnv`](@ref), [`WriteFile`](@ref)
""" TEnv

# Wrapper of TEnvRec
@trydoc raw"""
    ROOT.TEnvRec





Related functions: [`GetLevel`](@ref), [`GetName`](@ref), [`GetType`](@ref), [`GetValue`](@ref), [`Hash`](@ref), [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TEnvRec!Class_Name`](@ref), [`TEnvRec!Class_Version`](@ref), [`TEnvRec!Class`](@ref), [`TEnvRec!DeclFileName`](@ref), [`TEnvRec`](@ref)
""" TEnvRec

# Wrapper of THashList
@trydoc raw"""
    ROOT.THashList

[THashList](@ref) implements a hybrid collection class consisting of a hash table and a list to store [TObject](@ref)'s.

The hash table is used for quick access and lookup of objects while the list allows the objects to be ordered. The hash value is calculated using the value returned by the [TObject](@ref)'s [Hash()](@ref) function. Each class inheriting from [TObject](@ref) can override [Hash()](@ref) as it sees fit.

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`AverageCollisions`](@ref), [`Clear`](@ref), [`Delete`](@ref), [`FindObject`](@ref), [`GetListForObject`](@ref), [`RecursiveRemove`](@ref), [`Rehash`](@ref), [`Remove`](@ref), [`THashList`](@ref), [`UseRWLock`](@ref)
""" THashList

# Wrapper of TExceptionHandler
@trydoc raw"""
    ROOT.TExceptionHandler





Related functions: [`HandleException`](@ref)
""" TExceptionHandler

# Wrapper of TExec
@trydoc raw"""
    ROOT.TExec

[TExec](@ref) is a utility class that can be used to execute a C++ command when some event happens in a pad.

The command in turn can invoke a C++ macro to paint graphics objects at positions depending on the histogram or graph contents.

### Case 1:

The [TExec](@ref) object is in the list of pad primitives (after exec.Draw()). When the pad is drawn, the [TExec!Paint](@ref) function is called. This function will execute the specified command. The following example uses the services of the class Aclock created in `$ROOTSYS/test/Aclock.cxx`. This examples uses a [TTimer](@ref) to redraw a pad at regular intervals (clock). When the clock is updated, a string with the current date&time is drawn. 

    {
       gSystem->Load("$ROOTSYS/test/Aclock");
       Aclock ck(400);
       gPad->SetFillColor(5);
       TDatime dt;
       TText t(.5,.3,"t");
       t.SetTextAlign(22);
       t.SetTextSize(.07);
       t.SetTextColor(4);
       t.Draw();
       TExec ex("ex","dt.Set();t.SetTitle(dt.AsString())");
       ex.Draw();
    }

(C++ version of the code)

### Case 2:

The [TExec](@ref) object may be added to the list of functions of a [TH1](@ref) or [TGraph](@ref) object via hist->GetListOfFunctions()->Add(exec). When the histogram (or graph) is drawn, the [TExec](@ref) will be executed. If the histogram is made persistent on a file, the [TExec](@ref) object is also saved with the histogram. When redrawing the histogram in a new session, the [TExec](@ref) will be executed.

Example:

Assume an histogram [TH1F](@ref) *h already filled. 

    TExec *ex1 = new TExec("ex1","DoSomething()");
    TExec *ex2 = new TExec("ex2",".x macro.C");
    h->GetListOfFunctions()->Add(ex1);
    h->GetListOfFunctions()->Add(ex2);
    h->Draw();

(C++ version of the code)

When the Paint function for the histogram will be called, the "DoSomething" function will be called (interpreted or compiled) and also the macro.C.

### Case 3:

A [TExec](@ref) object is automatically generated when invoking [TPad!AddExec](@ref). Each pad contains a [TList](@ref) of TExecs (0, 1 or more). When a mouse event (motion, click, etc) happens, the pad object executes sequentially this list of TExecs. In the code (interpreted or compiled) executed by the [TExec](@ref) referenced command, one can call the pad service functions such as [TPad!GetEvent](@ref), [TPad!GetEventX](@ref), [TPad!GetEventY](@ref) to find which type of event and the X,Y position of the mouse. By default, the list of TExecs is executed. This can be disabled via the canvas menu "Option". See $ROOTSYS/tutorials/hist/exec2.C for an example. 

    Root > TFile f("hsimple.root");
    Root > hpxpy.Draw();
    Root > c1.AddExec("ex2",".x exec2.C");

(C++ version of the code)

 When moving the mouse in the canvas, a second canvas shows the projection along X of the bin corresponding to the Y position of the mouse. The resulting histogram is fitted with a gaussian. A "dynamic" line shows the current bin position in Y. This more elaborated example can be used as a starting point to develop more powerful interactive applications exploiting CINT as a development engine.

The 3 options above can be combined.

Related functions: [`Exec`](@ref), [`IsA`](@ref), [`Paint`](@ref), [`SavePrimitive`](@ref), [`SetAction`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TExec!Class_Name`](@ref), [`TExec!Class_Version`](@ref), [`TExec!Class`](@ref), [`TExec!DeclFileName`](@ref), [`TExec`](@ref)
""" TExec

# Wrapper of TFileCollection
@trydoc raw"""
    ROOT.TFileCollection

Class that contains a list of [TFileInfo](@ref)'s and accumulated meta data information about its entries.

This class is used to describe file sets as stored by Grid file catalogs, by PROOF or any other collection of [TFile](@ref) names.

Related functions: [`AddFromFile`](@ref), [`AddMetaData`](@ref), [`Add`](@ref), [`ExportInfo`](@ref), [`GetCorruptedPercentage`](@ref), [`GetDefaultTreeName`](@ref), [`GetFilesOnServer`](@ref), [`GetFilesPerServer`](@ref), [`GetList`](@ref), [`GetMetaData`](@ref), [`GetNCorruptFiles`](@ref), [`GetNFiles`](@ref), [`GetNStagedFiles`](@ref), [`GetStagedPercentage`](@ref), [`GetStagedSubset`](@ref), [`GetTotalEntries`](@ref), [`GetTotalSize`](@ref), [`IsA`](@ref), [`Merge`](@ref), [`Print`](@ref), [`RemoveDuplicates`](@ref), [`RemoveMetaData`](@ref), [`ResetBitAll`](@ref), [`SetAnchor`](@ref), [`SetBitAll`](@ref), [`SetDefaultMetaData`](@ref), [`SetDefaultTreeName`](@ref), [`SetList`](@ref), [`Sort`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TFileCollection!Class_Name`](@ref), [`TFileCollection!Class_Version`](@ref), [`TFileCollection!Class`](@ref), [`TFileCollection!DeclFileName`](@ref), [`TFileCollection`](@ref), [`Update`](@ref)
""" TFileCollection

# Wrapper of TFileInfo
@trydoc raw"""
    ROOT.TFileInfo

Class describing a generic file including meta information.



Related functions: [`AddMetaData`](@ref), [`AddUrl`](@ref), [`Compare`](@ref), [`FindByUrl`](@ref), [`GetCurrentUrl`](@ref), [`GetFirstUrl`](@ref), [`GetIndex`](@ref), [`GetMD5`](@ref), [`GetMetaDataList`](@ref), [`GetMetaData`](@ref), [`GetNUrls`](@ref), [`GetSize`](@ref), [`GetUUID`](@ref), [`GetUrlAt`](@ref), [`IsA`](@ref), [`IsSortable`](@ref), [`NextUrl`](@ref), [`Print`](@ref), [`RemoveMetaData`](@ref), [`RemoveUrlAt`](@ref), [`RemoveUrl`](@ref), [`ResetUrl`](@ref), [`SetCurrentUrl`](@ref), [`SetIndex`](@ref), [`SetSize`](@ref), [`SetUUID`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TFileInfo!Class_Name`](@ref), [`TFileInfo!Class_Version`](@ref), [`TFileInfo!Class`](@ref), [`TFileInfo!DeclFileName`](@ref), [`TFileInfo`](@ref)
""" TFileInfo

# Wrapper of TFileInfoMeta
@trydoc raw"""
    ROOT.TFileInfoMeta





Related functions: [`GetClass`](@ref), [`GetDirectory`](@ref), [`GetEntries`](@ref), [`GetFirst`](@ref), [`GetLast`](@ref), [`GetObject`](@ref), [`GetTotBytes`](@ref), [`GetZipBytes`](@ref), [`IsA`](@ref), [`IsTree`](@ref), [`Print`](@ref), [`SetEntries`](@ref), [`SetFirst`](@ref), [`SetLast`](@ref), [`SetTotBytes`](@ref), [`SetZipBytes`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TFileInfoMeta!Class_Name`](@ref), [`TFileInfoMeta!Class_Version`](@ref), [`TFileInfoMeta!Class`](@ref), [`TFileInfoMeta!DeclFileName`](@ref), [`TFileInfoMeta`](@ref)
""" TFileInfoMeta

# Wrapper of TMap
@trydoc raw"""
    ROOT.TMap

[TMap](@ref) implements an associative array of (key,value) pairs using a [THashTable](@ref) for efficient retrieval (therefore [TMap](@ref) does not conserve the order of the entries).

The hash value is calculated using the value returned by the keys [Hash()](@ref) function and the key comparison is done via the [IsEqual()](@ref) function. Both key and value must inherit from [TObject](@ref).

Related functions: [`Add`](@ref), [`AverageCollisions`](@ref), [`Capacity`](@ref), [`Clear`](@ref), [`Collisions`](@ref), [`DeleteAll`](@ref), [`DeleteEntry`](@ref), [`DeleteKeys`](@ref), [`DeleteValues`](@ref), [`Delete`](@ref), [`FindObject`](@ref), [`GetObjectRef`](@ref), [`GetTable`](@ref), [`GetValue`](@ref), [`IsOwnerValue`](@ref), [`MakeIterator`](@ref), [`Rehash`](@ref), [`RemoveEntry`](@ref), [`Remove`](@ref), [`SetOwnerKeyValue`](@ref), [`SetOwnerValue`](@ref), [`TMap`](@ref), [`Write`](@ref), [`paren`](@ref)
""" TMap

# Wrapper of TUrl
@trydoc raw"""
    ROOT.TUrl

This class represents a WWW compatible URL.

It provides member functions to return the different parts of an URL. The supported url format is: 

    [proto://][user[:passwd]@]host[:port]/file.ext[#anchor][?options]

(C++ version of the code)

Related functions: [`CleanRelativePath`](@ref), [`Compare`](@ref), [`GetAnchor`](@ref), [`GetFileAndOptions`](@ref), [`GetFile`](@ref), [`GetHostFQDN`](@ref), [`GetHost`](@ref), [`GetIntValueFromOptions`](@ref), [`GetOptions`](@ref), [`GetPasswd`](@ref), [`GetPort`](@ref), [`GetProtocol`](@ref), [`GetUrl`](@ref), [`GetUser`](@ref), [`GetValueFromOptions`](@ref), [`HasOption`](@ref), [`IsA`](@ref), [`IsSortable`](@ref), [`IsValid`](@ref), [`ParseOptions`](@ref), [`Print`](@ref), [`SetAnchor`](@ref), [`SetFile`](@ref), [`SetHost`](@ref), [`SetOptions`](@ref), [`SetPasswd`](@ref), [`SetPort`](@ref), [`SetProtocol`](@ref), [`SetUrl`](@ref), [`SetUser`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TUrl!Class_Name`](@ref), [`TUrl!Class_Version`](@ref), [`TUrl!Class`](@ref), [`TUrl!DeclFileName`](@ref), [`TUrl!GetSpecialProtocols`](@ref), [`TUrl`](@ref), [`assign`](@ref)
""" TUrl

# Wrapper of TMD5
@trydoc raw"""
    ROOT.TMD5

This code implements the MD5 message-digest algorithm.

The algorithm is due to Ron Rivest. This code was written by Colin Plumb in 1993, no copyright is claimed. This code is in the public domain; do with it what you wish.

Equivalent code is available from RSA Data Security, Inc. This code has been tested against that, and is equivalent, except that you don't need to include two pages of legalese with every copy.

To compute the message digest of a chunk of bytes, create an [TMD5](@ref) object, call [Update()](@ref) as needed on buffers full of bytes, and then call [Final()](@ref), which will, optionally, fill a supplied 16-byte array with the digest.

Related functions: [`AsString`](@ref), [`Final`](@ref), [`IsA`](@ref), [`Print`](@ref), [`SetDigest`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TMD5!Class_Name`](@ref), [`TMD5!Class_Version`](@ref), [`TMD5!Class`](@ref), [`TMD5!DeclFileName`](@ref), [`TMD5!FileChecksum`](@ref), [`TMD5!ReadChecksum`](@ref), [`TMD5!WriteChecksum`](@ref), [`TMD5`](@ref), [`Update`](@ref), [`assign`](@ref)
""" TMD5

# Wrapper of TFolder
@trydoc raw"""
    ROOT.TFolder



A [TFolder](@ref) object is a collection of objects and folders. Folders have a name and a title and are identified in the folder hierarchy by a "Unix-like" naming mechanism. The root of all folders is //root. New folders can be dynamically added or removed to/from a folder. The folder hierarchy can be visualized via the [TBrowser](@ref).

![https://root.cern/doc/v636/base_browser.png](https://root.cern/doc/v636/base_browser.png)

The Root folders hierarchy can be seen as a whiteboard where objects are posted. Other classes/tasks can access these objects by specifying only a string pathname. This whiteboard facility greatly improves the modularity of an application, minimizing the class relationship problem that penalizes large applications.

Pointers are efficient to communicate between classes. However, one has interest to minimize direct coupling between classes in the form of direct pointers. One better uses the naming and search service provided by the Root folders hierarchy. This makes the classes loosely coupled and also greatly facilitates I/O operations. In a client/server environment, this mechanism facilitates the access to any kind of object in //root stores running on different processes.

A [TFolder](@ref) is created by invoking the [TFolder](@ref) constructor. It is placed inside an existing folder via the [TFolder!AddFolder](@ref) method. One can search for a folder or an object in a folder using the FindObject method. FindObject analyses the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name.

When a folder is deleted, its reference from the parent folder and possible other folders is deleted.

If a folder has been declared the owner of its objects/folders via [TFolder!SetOwner](@ref), then the contained objects are deleted when the folder is deleted. By default, a folder does not own its contained objects.

NOTE that folder ownership can be set

- via [TFolder!SetOwner](@ref)
- or via [TCollection!SetOwner](@ref) on the collection specified to [TFolder!AddFolder](@ref)

Standard Root objects are automatically added to the folder hierarchy. For example, the following folders exist: root/Files with the list of currently connected Root files root/Classes with the list of active classes root/Geometries with active geometries root/Canvases with the list of active canvases root/Styles with the list of graphics styles root/Colors with the list of active colors

For example, if a file "myFile.root" is added to the list of files, one can retrieve a pointer to the corresponding [TFile](@ref) object with a statement like: 

    TFile *myFile = (TFile*)gROOT->FindObject("//root/Files/myFile.root");

(C++ version of the code)

 The above statement can be abbreviated to: 

    TFile *myFile = (TFile*)gROOT->FindObject("/Files/myFile.root");

(C++ version of the code)

 or even to: 

    TFile *myFile = (TFile*)gROOT->FindObjectAny("myFile.root");

(C++ version of the code)

 In this last case, the [TROOT!FindObjectAny](@ref) function will scan the folder hierarchy starting at //root and will return the first object named "myFile.root".

Because a string-based search mechanism is expensive, it is recommended to save the pointer to the object as a class member or local_ variable if this pointer is used frequently or inside loops.

Related functions: [`AddFolder`](@ref), [`Add`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`Copy`](@ref), [`FindFullPathName`](@ref), [`FindObjectAny`](@ref), [`FindObject`](@ref), [`GetListOfFolders`](@ref), [`IsA`](@ref), [`IsFolder`](@ref), [`IsOwner`](@ref), [`Occurence`](@ref), [`RecursiveRemove`](@ref), [`Remove`](@ref), [`SaveAs`](@ref), [`SetOwner`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TFolder!Class_Name`](@ref), [`TFolder!Class_Version`](@ref), [`TFolder!Class`](@ref), [`TFolder!DeclFileName`](@ref), [`TFolder`](@ref), [`ls`](@ref)
""" TFolder

# Wrapper of TMacro
@trydoc raw"""
    ROOT.TMacro

Class supporting a collection of lines with C++ code.

A [TMacro](@ref) can be executed, saved to a [ROOT](@ref) file, edited, etc.

A macro can be built line by line by calling the AddLine function. or it can be created directly from a file via the special constructor when the first argument is a file name.

A macro can be executed via the Exec function. Arguments can be specified when calling Exec.

A macro can be drawn in a pad. When the pad is updated, the macro is automatically executed.

The code in the macro can be saved via the SaveSource function. If the macro is in the list of primitives of a pad/canvas, the macro will be saved in the script generated by [TCanvas!SaveSource](@ref).

A macro can be written to a [ROOT](@ref) file via [TObject!Write](@ref).

Examples: 

    TMacro m("Peaks.C");  //macro m with name "Peaks" is created
                          //from file  Peaks.C
    m.Exec();             //macro executed with default arguments
    m.Exec("4");          //macro executed with argument
    m.SaveSource("newPeaks.C");
    TFile f("mymacros.root","recreate");
    m.Write();   //macro saved to file with name "Peaks"

(C++ version of the code)

Related functions: [`AddLine`](@ref), [`Browse`](@ref), [`Checksum`](@ref), [`Exec`](@ref), [`GetLineWith`](@ref), [`GetListOfLines`](@ref), [`IsA`](@ref), [`Load`](@ref), [`Paint`](@ref), [`Print`](@ref), [`ReadFile`](@ref), [`SavePrimitive`](@ref), [`SaveSource`](@ref), [`SetParams`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TMacro!Class_Name`](@ref), [`TMacro!Class_Version`](@ref), [`TMacro!Class`](@ref), [`TMacro!DeclFileName`](@ref), [`TMacro`](@ref), [`assign`](@ref)
""" TMacro

# Wrapper of TMessageHandler
@trydoc raw"""
    ROOT.TMessageHandler

Handle messages that might be generated by the system.

By default a handler only keeps track of the different messages generated for a specific class. By deriving from this class and overriding [Notify()](@ref) one can implement custom message handling. In [Notify()](@ref) one has access to the message id and the object generating the message. One can install more than one message handler per class. A message handler can be removed or again added when needed.

- All Root "Warnings" are logged as message 1001
- All Root "Errors" are logged as message 1002
- All Root "SysErrors" are logged as message 1003
- All Root "Fatals" are logged as message 1004

Related functions: [`Add`](@ref), [`Added`](@ref), [`GetMessageCount`](@ref), [`GetSize`](@ref), [`GetTotalMessageCount`](@ref), [`HandleDerived`](@ref), [`HandleMessage`](@ref), [`IsA`](@ref), [`Notified`](@ref), [`Notify`](@ref), [`Print`](@ref), [`Remove`](@ref), [`Removed`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TMessageHandler!Class_Name`](@ref), [`TMessageHandler!Class_Version`](@ref), [`TMessageHandler!Class`](@ref), [`TMessageHandler!DeclFileName`](@ref), [`TMessageHandler`](@ref)
""" TMessageHandler

# Wrapper of TNotifyLink
@trydoc raw"""
    ROOT.TNotifyLink

A node in a doubly linked list of subscribers to [TChain](@ref) notifications.

[TObject](@ref) has a virtual [TObject!Notify()](@ref) method that takes no parameters and returns a boolean. By default the method does nothing, and different objects in [ROOT](@ref) use this method for different purposes.

`TChain` uses `Notify` to implement a callback mechanism that notifies interested parties (subscribers) when the chain switches to a new sub-tree. In practice it calls the [Notify()](@ref) method of its fNotify data member from [TChain!LoadTree()](@ref). However there could be several different objects interested in knowing that a given [TChain](@ref) switched to a new tree. [TNotifyLink](@ref) can be used to build a linked list of subscribers: calling [TNotifyLink!Notify()](@ref) on the head node of the list propagates the call to all subscribers in the list.

Example usage: 

    TNotifyLink l(subscriber); // subscriber must implement `Notify()`
    l.PrependLink(chain); // prepends `l` to the list of notify links of the chain

(C++ version of the code)

###Note

TChain does not explicitly enforce that its fNotify data member be the head node of a list of TNotifyLinks, but that is the case in practice at least when using TTreeReader or RDataFrame to process the chain.

###Note

TChain does not take ownership of the TNotifyLink and the TNotifyLink does not take ownership of the subscriber object.

Related functions: [`ClassDefOverride`](@ref), [`Notify`](@ref), [`TNotifyLink`](@ref)
""" TNotifyLink

# Wrapper of TNotifyLinkBase
@trydoc raw"""
    ROOT.TNotifyLinkBase

See [TNotifyLink](@ref).



Related functions: [`ClassDefOverride`](@ref), [`Clear`](@ref), [`GetNext`](@ref), [`IsLinked`](@ref), [`PrependLink`](@ref), [`RemoveLink`](@ref)
""" TNotifyLinkBase

# Wrapper of TROOT
@trydoc raw"""
    ROOT.TROOT

[ROOT](@ref) top level object description.

The [TROOT](@ref) object is the entry point to the [ROOT](@ref) system. The single instance of [TROOT](@ref) is accessible via the global_ gROOT. Using the gROOT pointer one has access to basically every object created in a [ROOT](@ref) based program. The [TROOT](@ref) object is essentially a container of several lists pointing to the main [ROOT](@ref) objects.

The following lists are accessible from gROOT object:

    gROOT->GetListOfClasses
    gROOT->GetListOfColors
    gROOT->GetListOfTypes
    gROOT->GetListOfGlobals
    gROOT->GetListOfGlobalFunctions
    gROOT->GetListOfFiles
    gROOT->GetListOfMappedFiles
    gROOT->GetListOfSockets
    gROOT->GetListOfSecContexts
    gROOT->GetListOfCanvases
    gROOT->GetListOfStyles
    gROOT->GetListOfFunctions
    gROOT->GetListOfSpecials (for example graphical cuts)
    gROOT->GetListOfGeometries
    gROOT->GetListOfBrowsers
    gROOT->GetListOfCleanups
    gROOT->GetListOfMessageHandlers

(C++ version of the code)

The [TROOT](@ref) class provides also many useful services:

- Get pointer to an object in any of the lists above
- Time utilities [TROOT!Time](@ref)

The [ROOT](@ref) object must be created as a static object. An example of a main program creating an interactive version is shown below:

### Example of a main program

    #include "TRint.h"
    int main(int argc, char **argv)
    {
       TRint *theApp = new TRint("ROOT example", &argc, argv);
       // Init Intrinsics, build all windows, and enter event loop
       theApp->Run();
       return(0);
    }

(C++ version of the code)

Related functions: [`AddClassGenerator`](@ref), [`AddClass`](@ref), [`Append`](@ref), [`Browse`](@ref), [`ClassSaved`](@ref), [`CloseFiles`](@ref), [`EndOfProcessCleanups`](@ref), [`FindObjectAnyFile`](@ref), [`FindObjectAny`](@ref), [`FindObjectClassName`](@ref), [`FindObjectPathName`](@ref), [`FindObject`](@ref), [`FindSTLClass`](@ref), [`FindSpecialObject`](@ref), [`ForceStyle`](@ref), [`FromPopUp`](@ref), [`GetApplication`](@ref), [`GetBuiltDate`](@ref), [`GetBuiltTime`](@ref), [`GetClass`](@ref), [`GetClipboard`](@ref), [`GetColor`](@ref), [`GetConfigFeatures`](@ref), [`GetConfigOptions`](@ref), [`GetCutClassName`](@ref), [`GetDefCanvasName`](@ref), [`GetEditHistograms`](@ref), [`GetEditorMode`](@ref), [`GetFile`](@ref), [`GetForceStyle`](@ref), [`GetFunctionTemplate`](@ref), [`GetFunction`](@ref), [`GetGeometry`](@ref), [`GetGitBranch`](@ref), [`GetGitCommit`](@ref), [`GetGitDate`](@ref), [`GetGlobalFunctionWithPrototype`](@ref), [`GetGlobalFunction`](@ref), [`GetGlobal`](@ref), [`GetInterpreter`](@ref), [`GetListOfBrowsables`](@ref), [`GetListOfBrowsers`](@ref), [`GetListOfCanvases`](@ref), [`GetListOfClassGenerators`](@ref), [`GetListOfClasses`](@ref), [`GetListOfCleanups`](@ref), [`GetListOfClosedObjects`](@ref), [`GetListOfColors`](@ref), [`GetListOfDataSets`](@ref), [`GetListOfEnums`](@ref), [`GetListOfFiles`](@ref), [`GetListOfFunctionOverloads`](@ref), [`GetListOfFunctionTemplates`](@ref), [`GetListOfFunctions`](@ref), [`GetListOfGeometries`](@ref), [`GetListOfGlobalFunctions`](@ref), [`GetListOfGlobals`](@ref), [`GetListOfMappedFiles`](@ref), [`GetListOfMessageHandlers`](@ref), [`GetListOfProofs`](@ref), [`GetListOfSecContexts`](@ref), [`GetListOfSockets`](@ref), [`GetListOfSpecials`](@ref), [`GetListOfStreamerInfo`](@ref), [`GetListOfStyles`](@ref), [`GetListOfTasks`](@ref), [`GetListOfTypes`](@ref), [`GetNclasses`](@ref), [`GetNtypes`](@ref), [`GetPluginManager`](@ref), [`GetRootFolder`](@ref), [`GetSelectedPad`](@ref), [`GetSelectedPrimitive`](@ref), [`GetStyle`](@ref), [`GetTimer`](@ref), [`GetType`](@ref), [`GetUUIDs`](@ref), [`GetVersionCode`](@ref), [`GetVersionDate`](@ref), [`GetVersionInt`](@ref), [`GetVersionTime`](@ref), [`GetVersion`](@ref), [`GetWebDisplay`](@ref), [`Idle`](@ref), [`IgnoreInclude`](@ref), [`IsA`](@ref), [`IsBatch`](@ref), [`IsEscaped`](@ref), [`IsExecutingMacro`](@ref), [`IsFolder`](@ref), [`IsInterrupted`](@ref), [`IsLineProcessing`](@ref), [`IsProofServ`](@ref), [`IsRootFile`](@ref), [`IsWebDisplayBatch`](@ref), [`IsWebDisplay`](@ref), [`LoadClass`](@ref), [`LoadMacro`](@ref), [`Macro`](@ref), [`MakeDefCanvas`](@ref), [`Message`](@ref), [`MustClean`](@ref), [`ProcessLineFast`](@ref), [`ProcessLineSync`](@ref), [`ProcessLine`](@ref), [`ReadingObject`](@ref), [`RecursiveRemove`](@ref), [`RefreshBrowsers`](@ref), [`RemoveClass`](@ref), [`Remove`](@ref), [`ResetClassSaved`](@ref), [`Reset`](@ref), [`SaveContext`](@ref), [`SetApplication`](@ref), [`SetBatch`](@ref), [`SetCutClassName`](@ref), [`SetDefCanvasName`](@ref), [`SetEditHistograms`](@ref), [`SetEditorMode`](@ref), [`SetEscape`](@ref), [`SetExecutingMacro`](@ref), [`SetFromPopUp`](@ref), [`SetInterrupt`](@ref), [`SetLineHasBeenProcessed`](@ref), [`SetLineIsProcessing`](@ref), [`SetMustClean`](@ref), [`SetReadingObject`](@ref), [`SetSelectedPad`](@ref), [`SetSelectedPrimitive`](@ref), [`SetStyle`](@ref), [`SetWebDisplay`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TROOT!AddExtraInterpreterArgs`](@ref), [`TROOT!Class_Name`](@ref), [`TROOT!Class_Version`](@ref), [`TROOT!Class`](@ref), [`TROOT!ConvertVersionCode2Int`](@ref), [`TROOT!ConvertVersionInt2Code`](@ref), [`TROOT!DeclFileName`](@ref), [`TROOT!DecreaseDirLevel`](@ref), [`TROOT!GetBinDir`](@ref), [`TROOT!GetDataDir`](@ref), [`TROOT!GetDirLevel`](@ref), [`TROOT!GetDocDir`](@ref), [`TROOT!GetEtcDir`](@ref), [`TROOT!GetExtraInterpreterArgs`](@ref), [`TROOT!GetIconPath`](@ref), [`TROOT!GetIncludeDir`](@ref), [`TROOT!GetLibDir`](@ref), [`TROOT!GetMacroDir`](@ref), [`TROOT!GetMacroPath`](@ref), [`TROOT!GetRootSys`](@ref), [`TROOT!GetSharedLibDir`](@ref), [`TROOT!GetSourceDir`](@ref), [`TROOT!GetTTFFontDir`](@ref), [`TROOT!GetTutorialDir`](@ref), [`TROOT!GetTutorialsDir`](@ref), [`TROOT!IncreaseDirLevel`](@ref), [`TROOT!IndentLevel`](@ref), [`TROOT!Initialize`](@ref), [`TROOT!Initialized`](@ref), [`TROOT!RegisterModule`](@ref), [`TROOT!RootVersionCode`](@ref), [`TROOT!SetDirLevel`](@ref), [`TROOT!SetMacroPath`](@ref), [`TROOT!ShutDown`](@ref), [`TROOT`](@ref), [`Time`](@ref), [`ls`](@ref)
""" TROOT

# Wrapper of TPluginManager
@trydoc raw"""
    ROOT.TPluginManager

This class implements a plugin library manager.

It keeps track of a list of plugin handlers. A plugin handler knows which plugin library to load to get a specific class that is used to extend the functionality of a specific base class and how to create an object of this class. For example, to extend the base class [TFile](@ref) to be able to read SQLite files one needs to load the plugin library libRSQLite.so which defines the TRSQLiteServer class. This loading should be triggered when a given URI contains a regular expression defined by the handler.

Plugin handlers can be defined via macros in a list of plugin directories. With $ROOTSYS/etc/plugins the default top plugin directory specified in $ROOTSYS/etc/system.rootrc. Additional directories can be specified by adding them to the theend of the list. Macros for identical plugin handlers in later directories will override previous ones (the inverse of normal search path behavior). The macros must have names like `<BaseClass>/PX0_<PluginClass>.C`, e.g. TSQLServer/P20_TMySQLServer.C, to allow easy sorting and grouping. If the BaseClass is in a namespace the directory must have the name NameSpace@BaseClass as `:` is a reserved pathname character on some operating systems. Macros not beginning with 'P' and ending with ".C" are ignored. These macros typically look like: 

    void P10_TDCacheFile()
    {
        gPluginMgr->AddHandler("TFile", "^dcache", "TDCacheFile",
           "DCache", "TDCacheFile(const char*,Option_t*)");
    }

(C++ version of the code)

 Plugin handlers can also be defined via resources in the .rootrc file. Although now deprecated this method still works for backward compatibility, e.g.: 

    Plugin.TSQLServer:  ^mysql:  TMySQLServer MySQL  "<constructor>"
    +Plugin.TSQLServer: ^pgsql:  TPgSQLServer PgSQL  "<constructor>"
    Plugin.TVirtualFitter: *     TFitter      Minuit "TFitter(Int_t)"

(C++ version of the code)

 Where the + in front of Plugin.TSQLServer says that it extends the existing definition of [TSQLServer](@ref), useful when there is more than one plugin that can extend the same base class. The "<constructor>" should be the constructor or a static method that generates an instance of the specified class. Global methods should thestart with "!" in their name, like "!CreateFitter()". Instead of being a shared library a plugin can also be a CINT script, so instead of libDialog.so one can have Dialog.C. The * is a placeholder in case there is no need for a URI to differentiate between different plugins for the same base class. For the default plugins see $ROOTSYS/etc/system.rootrc.

Plugin handlers can also be registered at run time, e.g.: 

    gPluginMgr->AddHandler("TSQLServer", "^sqlite:",
                           "TSQLiteServer", "RSQLite",
              "TSQLiteServer(const char*,const char*,const char*)");

(C++ version of the code)

 A list of currently defined handlers can be printed using: 

    gPluginMgr->Print(); // use option="a" to see ctors

(C++ version of the code)

 The use of the plugin library manager removes all textual references to hard-coded class and library names and the resulting dependencies in the base classes. The plugin manager is used to extend a.o. [TFile](@ref), [TSQLServer](@ref), [TGrid](@ref), etc. functionality.

Related functions: [`AddHandler`](@ref), [`FindHandler`](@ref), [`IsA`](@ref), [`LoadHandlersFromEnv`](@ref), [`LoadHandlersFromPluginDirs`](@ref), [`Print`](@ref), [`RemoveHandler`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TPluginManager!Class_Name`](@ref), [`TPluginManager!Class_Version`](@ref), [`TPluginManager!Class`](@ref), [`TPluginManager!DeclFileName`](@ref), [`TPluginManager`](@ref), [`WritePluginMacros`](@ref), [`WritePluginRecords`](@ref)
""" TPluginManager

# Wrapper of TInterpreter
@trydoc raw"""
    ROOT.TInterpreter

This class defines an abstract interface to a generic command line interpreter.



Related functions: [`AddAvailableIndentifiers`](@ref), [`AddIncludePath`](@ref), [`AutoLoad`](@ref), [`AutoParse`](@ref), [`BaseClassInfo_ClassInfo`](@ref), [`BaseClassInfo_Delete`](@ref), [`BaseClassInfo_Factory`](@ref), [`BaseClassInfo_FullName`](@ref), [`BaseClassInfo_Name`](@ref), [`BaseClassInfo_Next`](@ref), [`BaseClassInfo_Offset`](@ref), [`BaseClassInfo_Property`](@ref), [`BaseClassInfo_Tagnum`](@ref), [`BaseClassInfo_TmpltName`](@ref), [`Calc`](@ref), [`CallFunc_Delete`](@ref), [`CallFunc_ExecDouble`](@ref), [`CallFunc_ExecInt64`](@ref), [`CallFunc_ExecInt`](@ref), [`CallFunc_ExecWithArgsAndReturn`](@ref), [`CallFunc_ExecWithReturn`](@ref), [`CallFunc_Exec`](@ref), [`CallFunc_FactoryCopy`](@ref), [`CallFunc_FactoryMethod`](@ref), [`CallFunc_Factory`](@ref), [`CallFunc_GetWrapperCode`](@ref), [`CallFunc_IFacePtr`](@ref), [`CallFunc_IgnoreExtraArgs`](@ref), [`CallFunc_Init`](@ref), [`CallFunc_IsValid`](@ref), [`CallFunc_ResetArg`](@ref), [`CallFunc_SetArgArray`](@ref), [`CallFunc_SetArgImpl`](@ref), [`CallFunc_SetArgRef`](@ref), [`CallFunc_SetArg`](@ref), [`CallFunc_SetArgs`](@ref), [`CallFunc_SetArguments`](@ref), [`CallFunc_SetFuncProto`](@ref), [`CallFunc_SetFunc`](@ref), [`CheckClassInfo`](@ref), [`CheckClassTemplate`](@ref), [`ClassInfo_ClassProperty`](@ref), [`ClassInfo_Contains`](@ref), [`ClassInfo_DeleteArray`](@ref), [`ClassInfo_Delete`](@ref), [`ClassInfo_Destruct`](@ref), [`ClassInfo_Factory`](@ref), [`ClassInfo_FileName`](@ref), [`ClassInfo_FullName`](@ref), [`ClassInfo_GetBaseOffset`](@ref), [`ClassInfo_GetMethodNArg`](@ref), [`ClassInfo_GetUnderlyingType`](@ref), [`ClassInfo_HasDefaultConstructor`](@ref), [`ClassInfo_HasMethod`](@ref), [`ClassInfo_Init`](@ref), [`ClassInfo_IsBase`](@ref), [`ClassInfo_IsEnum`](@ref), [`ClassInfo_IsLoaded`](@ref), [`ClassInfo_IsScopedEnum`](@ref), [`ClassInfo_IsValidMethod`](@ref), [`ClassInfo_IsValid`](@ref), [`ClassInfo_Name`](@ref), [`ClassInfo_New`](@ref), [`ClassInfo_Next`](@ref), [`ClassInfo_Property`](@ref), [`ClassInfo_Size`](@ref), [`ClassInfo_Tagnum`](@ref), [`ClassInfo_Title`](@ref), [`ClassInfo_TmpltName`](@ref), [`ClearFileBusy`](@ref), [`ClearStack`](@ref), [`CodeComplete`](@ref), [`CreateEnum`](@ref), [`CreateListOfBaseClasses`](@ref), [`CreateListOfDataMembers`](@ref), [`CreateListOfMethodArgs`](@ref), [`CreateListOfMethods`](@ref), [`CreateTemporary`](@ref), [`DataMemberInfo_ArrayDim`](@ref), [`DataMemberInfo_Delete`](@ref), [`DataMemberInfo_FactoryCopy`](@ref), [`DataMemberInfo_Factory`](@ref), [`DataMemberInfo_IsValid`](@ref), [`DataMemberInfo_MaxIndex`](@ref), [`DataMemberInfo_Name`](@ref), [`DataMemberInfo_Next`](@ref), [`DataMemberInfo_Offset`](@ref), [`DataMemberInfo_Property`](@ref), [`DataMemberInfo_Title`](@ref), [`DataMemberInfo_TypeName`](@ref), [`DataMemberInfo_TypeProperty`](@ref), [`DataMemberInfo_TypeSize`](@ref), [`DataMemberInfo_TypeTrueName`](@ref), [`DataMemberInfo_ValidArrayIndex`](@ref), [`Declare`](@ref), [`DeleteGlobal`](@ref), [`DeleteVariable`](@ref), [`DiagnoseIfInterpreterException`](@ref), [`DisplayClass`](@ref), [`DisplayIncludePath`](@ref), [`EndOfLineAction`](@ref), [`Evaluate`](@ref), [`ExecuteMacro`](@ref), [`ExecuteWithArgsAndReturn`](@ref), [`Execute`](@ref), [`FindSym`](@ref), [`ForgetMutexState`](@ref), [`FuncTempInfo_Delete`](@ref), [`FuncTempInfo_ExtraProperty`](@ref), [`FuncTempInfo_FactoryCopy`](@ref), [`FuncTempInfo_Factory`](@ref), [`FuncTempInfo_IsValid`](@ref), [`FuncTempInfo_Name`](@ref), [`FuncTempInfo_Property`](@ref), [`FuncTempInfo_TemplateMinReqArgs`](@ref), [`FuncTempInfo_TemplateNargs`](@ref), [`FuncTempInfo_Title`](@ref), [`FunctionDeclId_IsMethod`](@ref), [`GenerateDictionary`](@ref), [`GenerateTClass`](@ref), [`GenericError`](@ref), [`GetAutoLoadCallBack`](@ref), [`GetClassSharedLibs`](@ref), [`GetClass`](@ref), [`GetCurrentMacroName`](@ref), [`GetDataMemberAtAddr`](@ref), [`GetDataMemberWithValue`](@ref), [`GetDataMember`](@ref), [`GetDeclId`](@ref), [`GetEnum`](@ref), [`GetExecByteCode`](@ref), [`GetExitCode`](@ref), [`GetFunctionOverloads`](@ref), [`GetFunctionTemplate`](@ref), [`GetFunctionWithPrototype`](@ref), [`GetFunctionWithValues`](@ref), [`GetFunction`](@ref), [`GetIncludePath`](@ref), [`GetInterfaceMethodWithPrototype`](@ref), [`GetInterfaceMethod`](@ref), [`GetInterpreterStateMarker`](@ref), [`GetInterpreterTypeName`](@ref), [`GetMangledNameWithPrototype`](@ref), [`GetMangledName`](@ref), [`GetMapfile`](@ref), [`GetMore`](@ref), [`GetPrompt`](@ref), [`GetRootMapFiles`](@ref), [`GetSTLIncludePath`](@ref), [`GetSecurityError`](@ref), [`GetSharedLibDeps`](@ref), [`GetSharedLibs`](@ref), [`GetTopLevelMacroName`](@ref), [`GetUsingNamespaces`](@ref), [`HasPCMForLibrary`](@ref), [`Initialize`](@ref), [`InspectMembers`](@ref), [`IsAutoParsingSuspended`](@ref), [`IsErrorMessagesEnabled`](@ref), [`IsFloatingType`](@ref), [`IsIntegerType`](@ref), [`IsLibraryLoaded`](@ref), [`IsLoaded`](@ref), [`IsPointerType`](@ref), [`IsProcessLineLocked`](@ref), [`IsSameType`](@ref), [`IsSignedIntegerType`](@ref), [`IsUnsignedIntegerType`](@ref), [`IsVoidPointerType`](@ref), [`LoadEnums`](@ref), [`LoadFile`](@ref), [`LoadFunctionTemplates`](@ref), [`LoadLibraryMap`](@ref), [`LoadMacro`](@ref), [`LoadText`](@ref), [`Load`](@ref), [`MakeInterpreterValue`](@ref), [`MapCppName`](@ref), [`MethodArgInfo_DefaultValue`](@ref), [`MethodArgInfo_Delete`](@ref), [`MethodArgInfo_FactoryCopy`](@ref), [`MethodArgInfo_Factory`](@ref), [`MethodArgInfo_IsValid`](@ref), [`MethodArgInfo_Name`](@ref), [`MethodArgInfo_Next`](@ref), [`MethodArgInfo_Property`](@ref), [`MethodArgInfo_TypeInfo`](@ref), [`MethodArgInfo_TypeName`](@ref), [`MethodArgInfo_TypeNormalizedName`](@ref), [`MethodCallReturnType`](@ref), [`MethodInfo_CreateSignature`](@ref), [`MethodInfo_Delete`](@ref), [`MethodInfo_ExtraProperty`](@ref), [`MethodInfo_FactoryCopy`](@ref), [`MethodInfo_Factory`](@ref), [`MethodInfo_GetMangledName`](@ref), [`MethodInfo_GetPrototype`](@ref), [`MethodInfo_InterfaceMethod`](@ref), [`MethodInfo_IsValid`](@ref), [`MethodInfo_MethodCallReturnType`](@ref), [`MethodInfo_NArg`](@ref), [`MethodInfo_NDefaultArg`](@ref), [`MethodInfo_Name`](@ref), [`MethodInfo_Next`](@ref), [`MethodInfo_Property`](@ref), [`MethodInfo_Title`](@ref), [`MethodInfo_TypeName`](@ref), [`MethodInfo_TypeNormalizedName`](@ref), [`MethodInfo_Type`](@ref), [`PrintIntro`](@ref), [`ProcessLineSynch`](@ref), [`ProcessLine`](@ref), [`RegisterModule`](@ref), [`RegisterPrebuiltModulePath`](@ref), [`RegisterTClassUpdate`](@ref), [`ReloadAllSharedLibraryMaps`](@ref), [`ReportDiagnosticsToErrorHandler`](@ref), [`RescanLibraryMap`](@ref), [`ResetAll`](@ref), [`ResetGlobalVar`](@ref), [`ResetGlobals`](@ref), [`Reset`](@ref), [`RewindDictionary`](@ref), [`SaveContext`](@ref), [`SaveGlobalsContext`](@ref), [`SetAlloclockfunc`](@ref), [`SetAllocunlockfunc`](@ref), [`SetAutoLoadCallBack`](@ref), [`SetClassAutoLoading`](@ref), [`SetClassAutoloading`](@ref), [`SetClassAutoparsing`](@ref), [`SetClassInfo`](@ref), [`SetClassSharedLibs`](@ref), [`SetDeclAttr`](@ref), [`SetErrmsgcallback`](@ref), [`SetErrorMessages`](@ref), [`SetGetline`](@ref), [`SetProcessLineLock`](@ref), [`SetTempLevel`](@ref), [`ShutDown`](@ref), [`SnapshotMutexState`](@ref), [`TInterpreter!Instance`](@ref), [`TInterpreter`](@ref), [`ToString`](@ref), [`TypeInfo_Delete`](@ref), [`TypeInfo_FactoryCopy`](@ref), [`TypeInfo_Factory`](@ref), [`TypeInfo_Init`](@ref), [`TypeInfo_IsValid`](@ref), [`TypeInfo_Name`](@ref), [`TypeInfo_Property`](@ref), [`TypeInfo_QualTypePtr`](@ref), [`TypeInfo_RefType`](@ref), [`TypeInfo_Size`](@ref), [`TypeInfo_TrueName`](@ref), [`TypeName`](@ref), [`TypedefInfo_Delete`](@ref), [`TypedefInfo_FactoryCopy`](@ref), [`TypedefInfo_Factory`](@ref), [`TypedefInfo_Init`](@ref), [`TypedefInfo_IsValid`](@ref), [`TypedefInfo_Name`](@ref), [`TypedefInfo_Next`](@ref), [`TypedefInfo_Property`](@ref), [`TypedefInfo_Size`](@ref), [`TypedefInfo_Title`](@ref), [`TypedefInfo_TrueName`](@ref), [`UnRegisterTClassUpdate`](@ref), [`UnloadAllSharedLibraryMaps`](@ref), [`UnloadFile`](@ref), [`UnloadLibraryMap`](@ref), [`UpdateEnumConstants`](@ref), [`UpdateListOfGlobalFunctions`](@ref), [`UpdateListOfGlobals`](@ref), [`UpdateListOfMethods`](@ref), [`UpdateListOfTypes`](@ref)
""" TInterpreter

# Wrapper of TDataType
@trydoc raw"""
    ROOT.TDataType

Basic data type descriptor (datatype information is obtained from CINT).

This class describes the attributes of type definitions (typedef's). The [TROOT](@ref) class contains a list of all currently defined types (accessible via [TROOT!GetListOfTypes()](@ref)).

Related functions: [`AsString`](@ref), [`GetFullTypeName`](@ref), [`GetTypeName`](@ref), [`GetType`](@ref), [`Property`](@ref), [`Size`](@ref), [`TDataType!AddBuiltins`](@ref), [`TDataType!GetDataType`](@ref), [`TDataType!GetTypeName`](@ref), [`TDataType!GetType`](@ref), [`TDataType`](@ref)
""" TDataType

# Wrapper of TStyle
@trydoc raw"""
    ROOT.TStyle

[TStyle](@ref) objects may be created to define special styles.

By default [ROOT](@ref) creates a default style that can be accessed via the gStyle pointer.

This class includes functions to set some of the following object attributes.

- Canvas
- Pad
- Histogram axis
- Lines
- Fill areas
- Text
- Markers
- Functions
- Histogram Statistics and Titles

All objects that can be drawn in a pad inherit from one or more attribute classes like [TAttLine](@ref), [TAttFill](@ref), [TAttText](@ref), [TAttMarker](@ref). When the objects are created, their default attributes are taken from the current style. The current style is an object of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be referenced via the global_ variable `gStyle` (in TStyle.h).

[ROOT](@ref) provides two styles called "Default" and "Plain". The "Default" style is created simply by:

    auto default = new TStyle("Default","Default Style");

(C++ version of the code)

The `Plain` style can be used if you are working on a monochrome display or if you want to get a "conventional" Postscript output. These are the instructions in the [ROOT](@ref) constructor to create the `Plain` style.

    auto plain  = new TStyle("Plain","Plain Style (no colors/fill areas)");
       plain->SetCanvasBorderMode(0);
       plain->SetPadBorderMode(0);
       plain->SetPadColor(0);
       plain->SetCanvasColor(0);
       plain->SetTitleColor(0);
       plain->SetStatColor(0);

(C++ version of the code)

You can set the current style with:

    gROOT->SetStyle(style_name);

(C++ version of the code)

You can get a pointer to an existing style with:

    auto style = gROOT->GetStyle(style_name);

(C++ version of the code)

You can create additional styles with:

    TStyle *st1 = new TStyle("st1","my style");
       st1->Set....
       st1->cd();  this becomes now the current style gStyle

(C++ version of the code)

In your [rootlogon.C](https://root.cern/doc/master/classexamples/startsession.log.html) file, you can redefine the default parameters via statements like:

    gStyle->SetStatX(0.7);
    gStyle->SetStatW(0.2);
    gStyle->SetLabelOffset(1.2);
    gStyle->SetLabelFont(72);

(C++ version of the code)

Note that when an object is created, its attributes are taken from the current style. For example, you may have created an histogram in a previous session, saved it in a file. Meanwhile, if you have changed the style, the histogram will be drawn with the old attributes. You can force the current style attributes to be set when you read an object from a file by calling:

    gROOT->ForceStyle();

(C++ version of the code)

before reading the objects from the file.

Let's assume you have a canvas or pad with your histogram or any other object, you can force these objects to get the attributes of the current style via:

    canvas->UseCurrentStyle();

(C++ version of the code)

The description of the style functions should be clear from the name of the [TStyle](@ref) Setters or Getters. Some functions have an extended description, in particular:

- [TStyle](@ref):SetLabelFont.
- [TStyle](@ref):SetLineStyleString, to set the format of dashed lines.
- [TStyle](@ref):SetOptStat.
- [TStyle](@ref):SetPalette to change the colors palette.
- [TStyle](@ref):SetTitleOffset.

Related functions: [`AxisChoice`](@ref), [`Browse`](@ref), [`Copy`](@ref), [`DistancetoPrimitive`](@ref), [`GetAttDate`](@ref), [`GetAxisColor`](@ref), [`GetAxisMaxDigits`](@ref), [`GetBarOffset`](@ref), [`GetBarWidth`](@ref), [`GetCandleBoxRange`](@ref), [`GetCandleScaled`](@ref), [`GetCandleWhiskerRange`](@ref), [`GetCanvasBorderMode`](@ref), [`GetCanvasBorderSize`](@ref), [`GetCanvasColor`](@ref), [`GetCanvasDefH`](@ref), [`GetCanvasDefW`](@ref), [`GetCanvasDefX`](@ref), [`GetCanvasDefY`](@ref), [`GetCanvasPreferGL`](@ref), [`GetCapLinePS`](@ref), [`GetColorModelPS`](@ref), [`GetColorPalette`](@ref), [`GetDateX`](@ref), [`GetDateY`](@ref), [`GetDrawBorder`](@ref), [`GetEndErrorSize`](@ref), [`GetErrorX`](@ref), [`GetExponentOffset`](@ref), [`GetFitFormat`](@ref), [`GetFrameBorderMode`](@ref), [`GetFrameBorderSize`](@ref), [`GetFrameFillColor`](@ref), [`GetFrameFillStyle`](@ref), [`GetFrameLineColor`](@ref), [`GetFrameLineStyle`](@ref), [`GetFrameLineWidth`](@ref), [`GetFuncColor`](@ref), [`GetFuncStyle`](@ref), [`GetFuncWidth`](@ref), [`GetGridColor`](@ref), [`GetGridStyle`](@ref), [`GetGridWidth`](@ref), [`GetHatchesLineWidth`](@ref), [`GetHatchesSpacing`](@ref), [`GetHeaderPS`](@ref), [`GetHistFillColor`](@ref), [`GetHistFillStyle`](@ref), [`GetHistLineColor`](@ref), [`GetHistLineStyle`](@ref), [`GetHistLineWidth`](@ref), [`GetHistMinimumZero`](@ref), [`GetHistTopMargin`](@ref), [`GetImageScaling`](@ref), [`GetJoinLinePS`](@ref), [`GetLabelColor`](@ref), [`GetLabelFont`](@ref), [`GetLabelOffset`](@ref), [`GetLabelSize`](@ref), [`GetLegendBorderSize`](@ref), [`GetLegendFillColor`](@ref), [`GetLegendFont`](@ref), [`GetLegendTextSize`](@ref), [`GetLegoInnerR`](@ref), [`GetLineScalePS`](@ref), [`GetLineStyleString`](@ref), [`GetNdivisions`](@ref), [`GetNumberContours`](@ref), [`GetNumberOfColors`](@ref), [`GetOptDate`](@ref), [`GetOptFile`](@ref), [`GetOptFit`](@ref), [`GetOptLogx`](@ref), [`GetOptLogy`](@ref), [`GetOptLogz`](@ref), [`GetOptStat`](@ref), [`GetOptTitle`](@ref), [`GetOrthoCamera`](@ref), [`GetPadBorderMode`](@ref), [`GetPadBorderSize`](@ref), [`GetPadBottomMargin`](@ref), [`GetPadColor`](@ref), [`GetPadGridX`](@ref), [`GetPadGridY`](@ref), [`GetPadLeftMargin`](@ref), [`GetPadRightMargin`](@ref), [`GetPadTickX`](@ref), [`GetPadTickY`](@ref), [`GetPadTopMargin`](@ref), [`GetPaintTextFormat`](@ref), [`GetPaperSize`](@ref), [`GetScreenFactor`](@ref), [`GetShowEditor`](@ref), [`GetShowEventStatus`](@ref), [`GetShowToolBar`](@ref), [`GetStatBorderSize`](@ref), [`GetStatColor`](@ref), [`GetStatFontSize`](@ref), [`GetStatFont`](@ref), [`GetStatFormat`](@ref), [`GetStatH`](@ref), [`GetStatStyle`](@ref), [`GetStatTextColor`](@ref), [`GetStatW`](@ref), [`GetStatX`](@ref), [`GetStatY`](@ref), [`GetStripDecimals`](@ref), [`GetTickLength`](@ref), [`GetTimeOffset`](@ref), [`GetTitleAlign`](@ref), [`GetTitleBorderSize`](@ref), [`GetTitleColor`](@ref), [`GetTitleFillColor`](@ref), [`GetTitleFontSize`](@ref), [`GetTitleFont`](@ref), [`GetTitleH`](@ref), [`GetTitleOffset`](@ref), [`GetTitlePS`](@ref), [`GetTitleSize`](@ref), [`GetTitleStyle`](@ref), [`GetTitleTextColor`](@ref), [`GetTitleW`](@ref), [`GetTitleXOffset`](@ref), [`GetTitleXSize`](@ref), [`GetTitleX`](@ref), [`GetTitleYOffset`](@ref), [`GetTitleYSize`](@ref), [`GetTitleY`](@ref), [`GetViolinScaled`](@ref), [`IsA`](@ref), [`IsReading`](@ref), [`Paint`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`SaveSource`](@ref), [`SetAxisColor`](@ref), [`SetAxisMaxDigits`](@ref), [`SetBarOffset`](@ref), [`SetBarWidth`](@ref), [`SetCandleBoxRange`](@ref), [`SetCandleScaled`](@ref), [`SetCandleWhiskerRange`](@ref), [`SetCanvasBorderMode`](@ref), [`SetCanvasBorderSize`](@ref), [`SetCanvasColor`](@ref), [`SetCanvasDefH`](@ref), [`SetCanvasDefW`](@ref), [`SetCanvasDefX`](@ref), [`SetCanvasDefY`](@ref), [`SetCanvasPreferGL`](@ref), [`SetCapLinePS`](@ref), [`SetColorModelPS`](@ref), [`SetDateX`](@ref), [`SetDateY`](@ref), [`SetDrawBorder`](@ref), [`SetEndErrorSize`](@ref), [`SetErrorX`](@ref), [`SetExponentOffset`](@ref), [`SetFitFormat`](@ref), [`SetFrameBorderMode`](@ref), [`SetFrameBorderSize`](@ref), [`SetFrameFillColor`](@ref), [`SetFrameFillStyle`](@ref), [`SetFrameLineColor`](@ref), [`SetFrameLineStyle`](@ref), [`SetFrameLineWidth`](@ref), [`SetFuncColor`](@ref), [`SetFuncStyle`](@ref), [`SetFuncWidth`](@ref), [`SetGridColor`](@ref), [`SetGridStyle`](@ref), [`SetGridWidth`](@ref), [`SetHatchesLineWidth`](@ref), [`SetHatchesSpacing`](@ref), [`SetHeaderPS`](@ref), [`SetHistFillColor`](@ref), [`SetHistFillStyle`](@ref), [`SetHistLineColor`](@ref), [`SetHistLineStyle`](@ref), [`SetHistLineWidth`](@ref), [`SetHistMinimumZero`](@ref), [`SetHistTopMargin`](@ref), [`SetImageScaling`](@ref), [`SetIsReading`](@ref), [`SetJoinLinePS`](@ref), [`SetLabelColor`](@ref), [`SetLabelFont`](@ref), [`SetLabelOffset`](@ref), [`SetLabelSize`](@ref), [`SetLegendBorderSize`](@ref), [`SetLegendFillColor`](@ref), [`SetLegendFont`](@ref), [`SetLegendTextSize`](@ref), [`SetLegoInnerR`](@ref), [`SetLineScalePS`](@ref), [`SetLineStyleString`](@ref), [`SetNdivisions`](@ref), [`SetNumberContours`](@ref), [`SetOptDate`](@ref), [`SetOptFile`](@ref), [`SetOptFit`](@ref), [`SetOptLogx`](@ref), [`SetOptLogy`](@ref), [`SetOptLogz`](@ref), [`SetOptStat`](@ref), [`SetOptTitle`](@ref), [`SetOrthoCamera`](@ref), [`SetPadBorderMode`](@ref), [`SetPadBorderSize`](@ref), [`SetPadBottomMargin`](@ref), [`SetPadColor`](@ref), [`SetPadGridX`](@ref), [`SetPadGridY`](@ref), [`SetPadLeftMargin`](@ref), [`SetPadRightMargin`](@ref), [`SetPadTickX`](@ref), [`SetPadTickY`](@ref), [`SetPadTopMargin`](@ref), [`SetPaintTextFormat`](@ref), [`SetPalette`](@ref), [`SetPaperSize`](@ref), [`SetScreenFactor`](@ref), [`SetStatBorderSize`](@ref), [`SetStatColor`](@ref), [`SetStatFontSize`](@ref), [`SetStatFont`](@ref), [`SetStatFormat`](@ref), [`SetStatH`](@ref), [`SetStatStyle`](@ref), [`SetStatTextColor`](@ref), [`SetStatW`](@ref), [`SetStatX`](@ref), [`SetStatY`](@ref), [`SetStripDecimals`](@ref), [`SetTickLength`](@ref), [`SetTimeOffset`](@ref), [`SetTitleAlign`](@ref), [`SetTitleBorderSize`](@ref), [`SetTitleColor`](@ref), [`SetTitleFillColor`](@ref), [`SetTitleFontSize`](@ref), [`SetTitleFont`](@ref), [`SetTitleH`](@ref), [`SetTitleOffset`](@ref), [`SetTitlePS`](@ref), [`SetTitleSize`](@ref), [`SetTitleStyle`](@ref), [`SetTitleTextColor`](@ref), [`SetTitleW`](@ref), [`SetTitleXOffset`](@ref), [`SetTitleXSize`](@ref), [`SetTitleX`](@ref), [`SetTitleYOffset`](@ref), [`SetTitleYSize`](@ref), [`SetTitleY`](@ref), [`SetViolinScaled`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TStyle!BuildStyles`](@ref), [`TStyle!Class_Name`](@ref), [`TStyle!Class_Version`](@ref), [`TStyle!Class`](@ref), [`TStyle!DeclFileName`](@ref), [`TStyle`](@ref), [`ToggleEditor`](@ref), [`ToggleEventStatus`](@ref), [`ToggleToolBar`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TStyle

# Wrapper of TVirtualPad
@trydoc raw"""
    ROOT.TVirtualPad

[TVirtualPad](@ref) is an abstract base class for the Pad and Canvas classes.



Related functions: [`AbsCoordinates`](@ref), [`AbsPixeltoX`](@ref), [`AbsPixeltoY`](@ref), [`AddExec`](@ref), [`BuildLegend`](@ref), [`Clear`](@ref), [`Clip`](@ref), [`CloseToolTip`](@ref), [`Close`](@ref), [`CopyPixmap`](@ref), [`CopyPixmaps`](@ref), [`CreateToolTip`](@ref), [`DeleteExec`](@ref), [`DeleteToolTip`](@ref), [`Divide`](@ref), [`DrawClassObject`](@ref), [`DrawFrame`](@ref), [`Draw`](@ref), [`ExecuteEventAxis`](@ref), [`GetAbsHNDC`](@ref), [`GetAbsWNDC`](@ref), [`GetAbsXlowNDC`](@ref), [`GetAbsYlowNDC`](@ref), [`GetAspectRatio`](@ref), [`GetBorderMode`](@ref), [`GetBorderSize`](@ref), [`GetCanvasID`](@ref), [`GetCanvasImp`](@ref), [`GetCanvas`](@ref), [`GetEventX`](@ref), [`GetEventY`](@ref), [`GetEvent`](@ref), [`GetFrame`](@ref), [`GetGLDevice`](@ref), [`GetGridx`](@ref), [`GetGridy`](@ref), [`GetHNDC`](@ref), [`GetHighLightColor`](@ref), [`GetListOfExecs`](@ref), [`GetListOfPrimitives`](@ref), [`GetLogx`](@ref), [`GetLogy`](@ref), [`GetLogz`](@ref), [`GetMother`](@ref), [`GetName`](@ref), [`GetNumber`](@ref), [`GetPadPaint`](@ref), [`GetPadPar`](@ref), [`GetPadPointer`](@ref), [`GetPadSave`](@ref), [`GetPad`](@ref), [`GetPainter`](@ref), [`GetPhi`](@ref), [`GetPixmapID`](@ref), [`GetPrimitive`](@ref), [`GetRangeAxis`](@ref), [`GetRange`](@ref), [`GetSelectedPad`](@ref), [`GetSelected`](@ref), [`GetTheta`](@ref), [`GetTickx`](@ref), [`GetTicky`](@ref), [`GetTitle`](@ref), [`GetUxmax`](@ref), [`GetUxmin`](@ref), [`GetUymax`](@ref), [`GetUymin`](@ref), [`GetView3D`](@ref), [`GetView`](@ref), [`GetViewer3D`](@ref), [`GetVirtCanvas`](@ref), [`GetWNDC`](@ref), [`GetWh`](@ref), [`GetWw`](@ref), [`GetX1`](@ref), [`GetX2`](@ref), [`GetXlowNDC`](@ref), [`GetY1`](@ref), [`GetY2`](@ref), [`GetYlowNDC`](@ref), [`HasCrosshair`](@ref), [`HasFixedAspectRatio`](@ref), [`HasViewer3D`](@ref), [`HighLight`](@ref), [`IncrementPaletteColor`](@ref), [`IsA`](@ref), [`IsBatch`](@ref), [`IsBeingResized`](@ref), [`IsEditable`](@ref), [`IsModified`](@ref), [`IsRetained`](@ref), [`IsVertical`](@ref), [`IsWeb`](@ref), [`ModifiedUpdate`](@ref), [`Modified`](@ref), [`NextPaletteColor`](@ref), [`OpaqueMoving`](@ref), [`OpaqueResizing`](@ref), [`PadInHighlightMode`](@ref), [`PadInSelectionMode`](@ref), [`PadtoX`](@ref), [`PadtoY`](@ref), [`PaintBorderPS`](@ref), [`PaintBox`](@ref), [`PaintFillAreaNDC`](@ref), [`PaintFillArea`](@ref), [`PaintLine3D`](@ref), [`PaintLineNDC`](@ref), [`PaintLine`](@ref), [`PaintModified`](@ref), [`PaintPadFrame`](@ref), [`PaintPolyLine3D`](@ref), [`PaintPolyLineNDC`](@ref), [`PaintPolyLine`](@ref), [`PaintPolyMarker`](@ref), [`PaintTextNDC`](@ref), [`PaintText`](@ref), [`Paint`](@ref), [`PixeltoX`](@ref), [`PixeltoY`](@ref), [`PlaceBox`](@ref), [`PopTopLevelSelectable`](@ref), [`Pop`](@ref), [`Print`](@ref), [`PushSelectableObject`](@ref), [`PushTopLevelSelectable`](@ref), [`RangeAxisChanged`](@ref), [`RangeAxis`](@ref), [`Range`](@ref), [`RecursiveRemove`](@ref), [`RedrawAxis`](@ref), [`ReleaseViewer3D`](@ref), [`ResetToolTip`](@ref), [`ResetView3D`](@ref), [`ResizePad`](@ref), [`SaveAs`](@ref), [`SetAttFillPS`](@ref), [`SetAttLinePS`](@ref), [`SetAttMarkerPS`](@ref), [`SetAttTextPS`](@ref), [`SetBatch`](@ref), [`SetBorderMode`](@ref), [`SetBorderSize`](@ref), [`SetCanvasSize`](@ref), [`SetCanvas`](@ref), [`SetCopyGLDevice`](@ref), [`SetCrosshair`](@ref), [`SetCursor`](@ref), [`SetDoubleBuffer`](@ref), [`SetEditable`](@ref), [`SetFixedAspectRatio`](@ref), [`SetGrid`](@ref), [`SetGridx`](@ref), [`SetGridy`](@ref), [`SetLogx`](@ref), [`SetLogy`](@ref), [`SetLogz`](@ref), [`SetName`](@ref), [`SetPad`](@ref), [`SetPhi`](@ref), [`SetSelected`](@ref), [`SetTheta`](@ref), [`SetTicks`](@ref), [`SetTickx`](@ref), [`SetTicky`](@ref), [`SetTitle`](@ref), [`SetToolTipText`](@ref), [`SetVertical`](@ref), [`SetView`](@ref), [`SetViewer3D`](@ref), [`ShowGuidelines`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualPad!Class_Name`](@ref), [`TVirtualPad!Class_Version`](@ref), [`TVirtualPad!Class`](@ref), [`TVirtualPad!DeclFileName`](@ref), [`TVirtualPad!Pad`](@ref), [`TVirtualPad`](@ref), [`UnZoomed`](@ref), [`UpdateAsync`](@ref), [`Update`](@ref), [`UtoAbsPixel`](@ref), [`UtoPixel`](@ref), [`VtoAbsPixel`](@ref), [`VtoPixel`](@ref), [`WaitPrimitive`](@ref), [`XtoAbsPixel`](@ref), [`XtoPad`](@ref), [`XtoPixel`](@ref), [`YtoAbsPixel`](@ref), [`YtoPad`](@ref), [`YtoPixel`](@ref), [`cd`](@ref), [`ls`](@ref)
""" TVirtualPad

# Wrapper of TProcessUUID
@trydoc raw"""
    ROOT.TProcessUUID

This class is a specialized [TProcessID](@ref) managing the list of UUIDs.

In addition to [TProcessID](@ref), this object has the following members:

- fUUIDs : a [THashList](@ref) of TUUIDs in string format (using a [TObjString](@ref))
- fActive : a [TBits](@ref) table with one bit per [TUUID](@ref) in the table

When a new [TUUID](@ref) is entered into the list fUUIDs, it is assigned the first free slot in the list of bits and the [TUUID](@ref) UUIDNumber is set to this slot number.

When a [TUUID](@ref) is removed from the list, the corresponding bit is reset in fActive.

The object corresponding to a [TUUID](@ref) at slot I can be found via fObjects->At(I).

One can use two mechanisms to find the object corresponding to a [TUUID](@ref):

1. the input is the [TUUID.AsString](@ref). One can find the corresponding [TObjString](@ref) object objs in fUUIDs via THashList!FindObject(name). The slot number is then objs->[GetUniqueID()](@ref).
2. The input is the UUIDNumber. The slot number is UIUIDNumber

When a [TRef](@ref) points to an object having a [TUUID](@ref), both the [TRef](@ref) and the referenced object have their bit kHasUUID set. In this case, the pointer [TProcessID](@ref) *fPID in [TRef](@ref) points to the unique object [TProcessUUID](@ref). The [TRef](@ref) uniqueID is directly the UUIDNumber=slot number.

Related functions: [`AddUUID`](@ref), [`FindUUID`](@ref), [`GetActive`](@ref), [`GetUUIDs`](@ref), [`IsA`](@ref), [`RemoveUUID`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TProcessUUID!Class_Name`](@ref), [`TProcessUUID!Class_Version`](@ref), [`TProcessUUID!Class`](@ref), [`TProcessUUID!DeclFileName`](@ref), [`TProcessUUID`](@ref)
""" TProcessUUID

# Wrapper of TCanvas
@trydoc raw"""
    ROOT.TCanvas

The Canvas class.

A Canvas is an area mapped to a window directly under the control of the display manager. A [ROOT](@ref) session may have several canvases open at any given time.

A Canvas may be subdivided into independent graphical areas: the **Pads**. A canvas has a default pad which has the name of the canvas itself. An example of a Canvas layout is sketched in the picture below.

![https://root.cern/doc/v636/gpad_canvas.png](https://root.cern/doc/v636/gpad_canvas.png)

This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be moved, grown, shrunk using the normal rules of the Display manager.

Once objects have been drawn in a canvas, they can be edited/moved by pointing directly to them. The cursor shape is changed to suggest the type of action that one can do on this object. Clicking with the right mouse button on an object pops-up a contextmenu with a complete list of actions possible on this object.

A graphical editor may be started from the canvas "View" menu under the menu entry "Toolbar".

An interactive HELP is available by clicking on the HELP button at the top right of the canvas. It gives a short explanation about the canvas' menus.

A canvas may be automatically divided into pads via `TPad!Divide`.

At creation time, no matter if in interactive or batch mode, the constructor defines the size of the canvas window (including the size of the window manager's decoration). To define precisely the graphics area size of a canvas in the interactive mode, the following four lines of code should be used: 

    {
       Double_t w = 600;
       Double_t h = 600;
       auto c = new TCanvas("c", "c", w, h);
       c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));
    }

(C++ version of the code)

 and in the batch mode simply do: 

    c->SetCanvasSize(w,h);

(C++ version of the code)

If the canvas size exceeds the window size, scroll bars will be added to the canvas This allows to display very large canvases (even bigger than the screen size). The Following example shows how to proceed. 

    {
       auto c = new TCanvas("c","c");
       c->SetCanvasSize(1500, 1500);
       c->SetWindowSize(500, 500);
    }

(C++ version of the code)

Related functions: [`Browse`](@ref), [`ClearPadSave`](@ref), [`Clear`](@ref), [`Cleared`](@ref), [`Close`](@ref), [`Closed`](@ref), [`Constructor`](@ref), [`DeleteCanvasPainter`](@ref), [`Delete`](@ref), [`Destructor`](@ref), [`DisconnectWidget`](@ref), [`DrawClonePad`](@ref), [`DrawClone`](@ref), [`Draw`](@ref), [`EditorBar`](@ref), [`EmbedInto`](@ref), [`EnterLeave`](@ref), [`FeedbackMode`](@ref), [`Flush`](@ref), [`ForceUpdate`](@ref), [`GetAutoExec`](@ref), [`GetCanvasID`](@ref), [`GetCanvasImp`](@ref), [`GetCanvasPainter`](@ref), [`GetCanvasPar`](@ref), [`GetClickSelectedPad`](@ref), [`GetClickSelected`](@ref), [`GetContextMenu`](@ref), [`GetDISPLAY`](@ref), [`GetDoubleBuffer`](@ref), [`GetEventX`](@ref), [`GetEventY`](@ref), [`GetEvent`](@ref), [`GetHighLightColor`](@ref), [`GetPadSave`](@ref), [`GetSelectedOpt`](@ref), [`GetSelectedPad`](@ref), [`GetSelectedX`](@ref), [`GetSelectedY`](@ref), [`GetSelected`](@ref), [`GetShowEditor`](@ref), [`GetShowEventStatus`](@ref), [`GetShowToolBar`](@ref), [`GetShowToolTips`](@ref), [`GetWh`](@ref), [`GetWindowHeight`](@ref), [`GetWindowTopX`](@ref), [`GetWindowTopY`](@ref), [`GetWindowWidth`](@ref), [`GetWw`](@ref), [`GetXsizeReal`](@ref), [`GetXsizeUser`](@ref), [`GetYsizeReal`](@ref), [`GetYsizeUser`](@ref), [`HandleInput`](@ref), [`HasMenuBar`](@ref), [`HighlightConnect`](@ref), [`Highlighted`](@ref), [`Iconify`](@ref), [`IsBatch`](@ref), [`IsDrawn`](@ref), [`IsFolder`](@ref), [`IsGrayscale`](@ref), [`IsRetained`](@ref), [`IsUpdated`](@ref), [`IsWeb`](@ref), [`MoveOpaque`](@ref), [`OpaqueMoving`](@ref), [`OpaqueResizing`](@ref), [`Paint`](@ref), [`Pick`](@ref), [`Picked`](@ref), [`ProcessedEvent`](@ref), [`RaiseWindow`](@ref), [`ResetDrawn`](@ref), [`ResetUpdated`](@ref), [`ResizeOpaque`](@ref), [`Resize`](@ref), [`SavePrimitive`](@ref), [`SaveSource`](@ref), [`Selected`](@ref), [`SetBatch`](@ref), [`SetCanvasImp`](@ref), [`SetCanvasSize`](@ref), [`SetClickSelectedPad`](@ref), [`SetClickSelected`](@ref), [`SetCursor`](@ref), [`SetDoubleBuffer`](@ref), [`SetFixedAspectRatio`](@ref), [`SetGrayscale`](@ref), [`SetHighLightColor`](@ref), [`SetName`](@ref), [`SetPadSave`](@ref), [`SetRealAspectRatio`](@ref), [`SetRetained`](@ref), [`SetSelectedPad`](@ref), [`SetSelected`](@ref), [`SetSupportGL`](@ref), [`SetTitle`](@ref), [`SetWindowPosition`](@ref), [`SetWindowSize`](@ref), [`Show`](@ref), [`Size`](@ref), [`TCanvas!MakeDefCanvas`](@ref), [`TCanvas!SaveAll`](@ref), [`TCanvas!SetFolder`](@ref), [`TCanvas!SupportAlpha`](@ref), [`TCanvas`](@ref), [`ToggleAutoExec`](@ref), [`ToggleEditor`](@ref), [`ToggleEventStatus`](@ref), [`ToggleToolBar`](@ref), [`ToggleToolTips`](@ref), [`UpdateAsync`](@ref), [`Update`](@ref), [`UseCurrentStyle`](@ref), [`UseGL`](@ref), [`cd`](@ref), [`ls`](@ref)
""" TCanvas

# Wrapper of TParameter
@trydoc raw"""
    ROOT.TParameter

Named parameter, streamable and storable.



Related functions: [`Compare`](@ref), [`GetName`](@ref), [`GetVal`](@ref), [`Hash`](@ref), [`IsA`](@ref), [`IsConst`](@ref), [`IsSortable`](@ref), [`Merge`](@ref), [`Print`](@ref), [`SetMergeMode`](@ref), [`SetVal`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TParameter!Class_Name`](@ref), [`TParameter!Class_Version`](@ref), [`TParameter!Class`](@ref), [`TParameter!DeclFileName`](@ref), [`TParameter`](@ref), [`ls`](@ref)
""" TParameter

# Wrapper of TPluginHandler
@trydoc raw"""
    ROOT.TPluginHandler





Related functions: [`CheckPlugin`](@ref), [`ExecPluginImpl`](@ref), [`ExecPlugin`](@ref), [`GetClass`](@ref), [`IsA`](@ref), [`LoadPlugin`](@ref), [`Print`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TPluginHandler!Class_Name`](@ref), [`TPluginHandler!Class_Version`](@ref), [`TPluginHandler!Class`](@ref), [`TPluginHandler!DeclFileName`](@ref)
""" TPluginHandler

# Wrapper of TArray
@trydoc raw"""
    ROOT.TArray

Abstract array base class.

Used by [TArrayC](@ref), [TArrayS](@ref), [TArrayI](@ref), [TArrayL](@ref), [TArrayF](@ref) and [TArrayD](@ref). Data member is public for historical reasons.

Related functions: [`GetAt`](@ref), [`GetSize`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArray!ReadArray`](@ref), [`TArray!WriteArray`](@ref), [`TArray`](@ref), [`assign`](@ref)
""" TArray

# Wrapper of TArrayI
@trydoc raw"""
    ROOT.TArrayI

Array of integers (32 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayI`](@ref), [`assign`](@ref)
""" TArrayI

# Wrapper of TPMERegexp
@trydoc raw"""
    ROOT.TPMERegexp

Wrapper for PCRE library (Perl Compatible Regular Expressions).

Based on PME - PCRE Made Easy by Zachary Hansen.

Supports main Perl operations using regular expressions (Match, Substitute and Split). To retrieve the results one can simply use operator[] returning a [TString](@ref).

See $ROOTSYS/tutorials/regexp_pme.C for examples.

Related functions: [`AssignGlobalState`](@ref), [`Base.getindex`](@ref), [`GetGlobalPosition`](@ref), [`GetNMaxMatches`](@ref), [`IsA`](@ref), [`Match`](@ref), [`NMatches`](@ref), [`Print`](@ref), [`ResetGlobalState`](@ref), [`Reset`](@ref), [`SetNMaxMatches`](@ref), [`Split`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Substitute`](@ref), [`TPMERegexp!Class_Name`](@ref), [`TPMERegexp!Class_Version`](@ref), [`TPMERegexp!Class`](@ref), [`TPMERegexp!DeclFileName`](@ref), [`TPMERegexp`](@ref)
""" TPMERegexp

# Wrapper of TStringToken
@trydoc raw"""
    ROOT.TStringToken

Provides iteration through tokens of a given string.

- fFullStr stores the string to be split. It is never modified.
- fSplitRe is the perl-re that is used to separate the tokens.
- fReturnVoid if true, empty strings will be returned.

Current token is stored in the [TString](@ref) base-class. During construction no match is done, use [NextToken()](@ref) to get the first and all subsequent tokens.

Related functions: [`AtEnd`](@ref), [`IsA`](@ref), [`NextToken`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TStringToken!Class_Name`](@ref), [`TStringToken!Class_Version`](@ref), [`TStringToken!Class`](@ref), [`TStringToken!DeclFileName`](@ref), [`TStringToken`](@ref)
""" TStringToken

# Wrapper of TBits
@trydoc raw"""
    ROOT.TBits

Container of bits.

This class provides a simple container of bits. Each bit can be set and tested via the functions SetBitNumber and TestBitNumber.

The default value of all bits is kFALSE. The size of the container is automatically extended when a bit number is either set or tested. To reduce the memory size of the container use the Compact function, this will discard the memory occupied by the upper bits that are 0.

Related functions: [`Base.:(!=)`](@ref), [`Base.:(<<)`](@ref), [`Base.:(==)`](@ref), [`Base.:(>>)`](@ref), [`Base.:~`](@ref), [`Base.getindex`](@ref), [`Clear`](@ref), [`Compact`](@ref), [`CountBits`](@ref), [`FirstNullBit`](@ref), [`FirstSetBit`](@ref), [`GetNbits`](@ref), [`GetNbytes`](@ref), [`Get`](@ref), [`LastNullBit`](@ref), [`LastSetBit`](@ref), [`Output`](@ref), [`Paint`](@ref), [`Print`](@ref), [`ResetAllBits`](@ref), [`ResetBitNumber`](@ref), [`SetBitNumber`](@ref), [`Set`](@ref), [`TBits`](@ref), [`TestBitNumber`](@ref), [`and!`](@ref), [`assign`](@ref), [`lshit!`](@ref), [`or!`](@ref), [`rshit!`](@ref), [`xor_eq`](@ref)
""" TBits

# Wrapper of TQClass
@trydoc raw"""
    ROOT.TQClass





Related functions: [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TQClass!Class_Name`](@ref), [`TQClass!Class_Version`](@ref), [`TQClass!Class`](@ref), [`TQClass!DeclFileName`](@ref), [`TQClass`](@ref)
""" TQClass

# Wrapper of TQCommand
@trydoc raw"""
    ROOT.TQCommand

The Command design pattern is based on the idea, that all editing in an application is done by creating instances of command objects.

Command objects apply changes to the edited object and then are stored on a command stack. Furthermore, each command knows how to undo its changes to bring the edited object back to its previous state. As long as the application only uses command objects to change the state of the edited object, it is possible to undo a sequence of commands by traversing the command stack downwards and calling the "undo" method of each command in turn. It is also possible to redo a sequence of commands by traversing the command stack upwards and calling the "redo" method of each command.

Examples:

1. Create a new command 

        TQCommand *com = new TQCommand("TH1", hpx, "SetFillColor(Color_t)"
                                     "SetFillColor(Color_t)");

(C++ version of the code)

    - 1st parameter - the name of class
    - 2nd parameter - object
    - 3rd parameter - the name of do/redo method
    - 4th parameter - the name of undo method Since redo,undo methods are the same, undo name can be omitted, e.g. 

            TQCommand *com = new TQCommand("TH1", hpx, "SetFillColor(Color_t)");

    (C++ version of the code)

     For objects derived from [TObject](@ref) class name can be omitted, e.g. 

            TQCommand *com = new TQCommand(hpx, "SetFillColor(Color_t)");

    (C++ version of the code)


2. Setting undo, redo parameters. 

        Color_t old_color = hpx->GetFillColor();
        Color_t new_color = 4;  // blue color
        com->SetRedoArgs(1, new_color);
        com->SetUndoArgs(1, old_color);

(C++ version of the code)

 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use 

        com->SetArgs(1, new_color, old_color);

(C++ version of the code)

3. Undo, redo method execution 

        com->Redo(); // execute redo method
        com->Undo(); // execute undo method

(C++ version of the code)

4. Merged commands It possible to group several commands together so an theend user can undo and redo them with one command. 

        TQCommand *update = new TQCommand(gPad, "Modified()");
        com->Add(update);

(C++ version of the code)

5. Macro commands "Merging" allows to create macro commands, e.g. 

        TQCommand *macro = new TQCommand("my macro");
        macro->Add(com1);
        macro->Add(com2);
        ...

(C++ version of the code)

 During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).
6. Undo manager. [TQUndoManager](@ref) is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command [TQUndoManager!Add(TObject*)](@ref) method is used. 

        TQUndoManager *history = new TQUndoManager();
        history->Add(com);

(C++ version of the code)

 [TQUndoManager!Add](@ref) automatically invokes execution of command's Redo method.

Use [TQUndoManager!Undo](@ref) to undo commands in history list. Redo is Undo for undo action. Use [TQUndoManager!Redo](@ref) method for that

Related functions: [`Add`](@ref), [`CanCompress`](@ref), [`CanMerge`](@ref), [`CanRedo`](@ref), [`CanUndo`](@ref), [`Compress`](@ref), [`Delete`](@ref), [`GetNRargs`](@ref), [`GetNUargs`](@ref), [`GetName`](@ref), [`GetObject`](@ref), [`GetRedoArgs`](@ref), [`GetRedoName`](@ref), [`GetRedo`](@ref), [`GetStatus`](@ref), [`GetTitle`](@ref), [`GetUndoArgs`](@ref), [`GetUndoName`](@ref), [`GetUndo`](@ref), [`IsA`](@ref), [`IsEqual`](@ref), [`IsExecuting`](@ref), [`IsMacro`](@ref), [`IsRedoing`](@ref), [`IsSetter`](@ref), [`IsUndoing`](@ref), [`Merge`](@ref), [`Redo`](@ref), [`SetArgs`](@ref), [`SetName`](@ref), [`SetRedoArgs`](@ref), [`SetTitle`](@ref), [`SetUndoArgs`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TQCommand!Class_Name`](@ref), [`TQCommand!Class_Version`](@ref), [`TQCommand!Class`](@ref), [`TQCommand!DeclFileName`](@ref), [`TQCommand!GetCommand`](@ref), [`TQCommand`](@ref), [`Undo`](@ref), [`ls`](@ref)
""" TQCommand

# Wrapper of TQConnection
@trydoc raw"""
    ROOT.TQConnection

[TQConnection](@ref) class is an internal class, used in the object communication mechanism.

[TQConnection](@ref):

- is a list of signal_lists containing pointers to this connection
- receiver is the object to which slot-method is applied

Related functions: [`Destroyed`](@ref), [`ExecuteMethod`](@ref), [`GetClassName`](@ref), [`GetName`](@ref), [`GetReceiver`](@ref), [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TQConnection!Class_Name`](@ref), [`TQConnection!Class_Version`](@ref), [`TQConnection!Class`](@ref), [`TQConnection!DeclFileName`](@ref), [`TQConnection`](@ref), [`ls`](@ref)
""" TQConnection

# Wrapper of TQUndoManager
@trydoc raw"""
    ROOT.TQUndoManager

Recorder of operations for undo and redo.



Related functions: [`Add`](@ref), [`CanRedo`](@ref), [`CanUndo`](@ref), [`CurrentChanged`](@ref), [`GetCurrent`](@ref), [`GetCursor`](@ref), [`GetLimit`](@ref), [`IsA`](@ref), [`IsLogging`](@ref), [`Redo`](@ref), [`SetLimit`](@ref), [`SetLogging`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TQUndoManager!Class_Name`](@ref), [`TQUndoManager!Class_Version`](@ref), [`TQUndoManager!Class`](@ref), [`TQUndoManager!DeclFileName`](@ref), [`TQUndoManager`](@ref), [`Undo`](@ref), [`ls`](@ref)
""" TQUndoManager

# Wrapper of TTime
@trydoc raw"""
    ROOT.TTime

Basic time type with millisecond precision.



Related functions: [`AsString`](@ref), [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TTime!Class_Name`](@ref), [`TTime!Class_Version`](@ref), [`TTime!Class`](@ref), [`TTime!DeclFileName`](@ref), [`TTime`](@ref), [`add!`](@ref), [`assign`](@ref), [`fdiv!`](@ref), [`long long`](@ref), [`long`](@ref), [`mult!`](@ref), [`sub!`](@ref), [`unsigned long long`](@ref), [`unsigned long`](@ref)
""" TTime

# Wrapper of TTimer
@trydoc raw"""
    ROOT.TTimer

Handles synchronous and a-synchronous timer events.

1. synchronous timer is registered into [TSystem](@ref) and is processed within the standard [ROOT](@ref) event-loop.
2. asynchronous timer is passed to the operating system which sends an external signal to [ROOT](@ref) and thus interrupts its event-loop.

You can use this class in one of the following ways:

- Sub-class [TTimer](@ref) and override the [Notify()](@ref) method.
- Re-implement the [TObject!HandleTimer()](@ref) method in your class and pass a pointer to this object to timer, see the [SetObject()](@ref) method.
- Pass an interpreter command to timer, see [SetCommand()](@ref) method.
- Create a [TTimer](@ref), connect its [Timeout()](@ref) signal to the appropriate methods. Then when the time is up it will emit a [Timeout()](@ref) signal and call connected slots.

Minimum timeout interval is defined in TSystem!ESysConstants as `kItimerResolution` (currently 10 ms).

Signal/slots example: 

    TTimer *timer = new TTimer();
    timer->Connect("Timeout()", "myObjectClassName",
                   myObject, "TimerDone()");
    timer->Start(2000, kTRUE);   // 2 seconds single-shot

(C++ version of the code)

 To emit the Timeout signal repeatedly with minimum timeout: 

    timer->Start(0, kFALSE);

(C++ version of the code)

Related functions: [`Add`](@ref), [`CheckTimer`](@ref), [`GetAbsTime`](@ref), [`GetCommand`](@ref), [`GetObject`](@ref), [`GetTime`](@ref), [`GetTimerID`](@ref), [`HasTimedOut`](@ref), [`IsA`](@ref), [`IsAsync`](@ref), [`IsInterruptingSyscalls`](@ref), [`IsRunning`](@ref), [`IsSync`](@ref), [`Notify`](@ref), [`Remove`](@ref), [`Reset`](@ref), [`SetCommand`](@ref), [`SetInterruptSyscalls`](@ref), [`SetObject`](@ref), [`SetTime`](@ref), [`SetTimerID`](@ref), [`Start`](@ref), [`Stop`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TTimer!Class_Name`](@ref), [`TTimer!Class_Version`](@ref), [`TTimer!Class`](@ref), [`TTimer!DeclFileName`](@ref), [`TTimer!SingleShot`](@ref), [`TTimer`](@ref), [`Timeout`](@ref), [`TurnOff`](@ref), [`TurnOn`](@ref)
""" TTimer

# Wrapper of TProcessEventTimer
@trydoc raw"""
    ROOT.TProcessEventTimer





Related functions: [`IsA`](@ref), [`Notify`](@ref), [`ProcessEvents`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TProcessEventTimer!Class_Name`](@ref), [`TProcessEventTimer!Class_Version`](@ref), [`TProcessEventTimer!Class`](@ref), [`TProcessEventTimer!DeclFileName`](@ref), [`TProcessEventTimer`](@ref)
""" TProcessEventTimer

# Wrapper of TSystem
@trydoc raw"""
    ROOT.TSystem

Abstract base class defining a generic interface to the underlying Operating System.

This is not an ABC in the strict sense of the (C++) word. For every member function there is an implementation (often not more than a call to [AbstractMethod()](@ref) which prints a warning saying that the method should be overridden in a derived class), which allows a simple partial implementation for new OS'es.

Related functions: [`Abort`](@ref), [`AcceptConnection`](@ref), [`AccessPathName`](@ref), [`AddDynamicPath`](@ref), [`AddFileHandler`](@ref), [`AddIncludePath`](@ref), [`AddLinkedLibs`](@ref), [`AddSignalHandler`](@ref), [`AddStdExceptionHandler`](@ref), [`AddTimer`](@ref), [`AnnounceTcpService`](@ref), [`AnnounceUdpService`](@ref), [`AnnounceUnixService`](@ref), [`BaseName`](@ref), [`Beep`](@ref), [`ChangeDirectory`](@ref), [`Chmod`](@ref), [`CleanCompiledMacros`](@ref), [`CloseConnection`](@ref), [`ClosePipe`](@ref), [`Closelog`](@ref), [`CompileMacro`](@ref), [`ConcatFileName`](@ref), [`CopyFile`](@ref), [`DirName`](@ref), [`DispatchOneEvent`](@ref), [`DynFindSymbol`](@ref), [`DynamicPathName`](@ref), [`Exec`](@ref), [`ExitLoop`](@ref), [`Exit`](@ref), [`ExpandPathName`](@ref), [`FindDynamicLibrary`](@ref), [`FindFile`](@ref), [`FreeDirectory`](@ref), [`GetAclicMode`](@ref), [`GetAclicProperties`](@ref), [`GetBeepDefaults`](@ref), [`GetBuildArch`](@ref), [`GetBuildCompilerVersionStr`](@ref), [`GetBuildCompilerVersion`](@ref), [`GetBuildCompiler`](@ref), [`GetBuildDir`](@ref), [`GetBuildNode`](@ref), [`GetCpuInfo`](@ref), [`GetCryptoRandom`](@ref), [`GetDirEntry`](@ref), [`GetDirName`](@ref), [`GetDirPtr`](@ref), [`GetDynamicPath`](@ref), [`GetEffectiveGid`](@ref), [`GetEffectiveUid`](@ref), [`GetErrorStr`](@ref), [`GetError`](@ref), [`GetFPEMask`](@ref), [`GetFlagsDebug`](@ref), [`GetFlagsOpt`](@ref), [`GetFromPipe`](@ref), [`GetFsInfo`](@ref), [`GetGid`](@ref), [`GetGroupInfo`](@ref), [`GetHomeDirectory`](@ref), [`GetHostByName`](@ref), [`GetIncludePath`](@ref), [`GetLibraries`](@ref), [`GetLinkdefSuffix`](@ref), [`GetLinkedLibs`](@ref), [`GetListOfFileHandlers`](@ref), [`GetListOfSignalHandlers`](@ref), [`GetListOfStdExceptionHandlers`](@ref), [`GetListOfTimers`](@ref), [`GetMakeExe`](@ref), [`GetMakeSharedLib`](@ref), [`GetMemInfo`](@ref), [`GetObjExt`](@ref), [`GetPathInfo`](@ref), [`GetPeerName`](@ref), [`GetPid`](@ref), [`GetProcInfo`](@ref), [`GetServiceByName`](@ref), [`GetServiceByPort`](@ref), [`GetSoExt`](@ref), [`GetSockName`](@ref), [`GetSockOpt`](@ref), [`GetSysInfo`](@ref), [`GetUid`](@ref), [`GetUserInfo`](@ref), [`GetVolumes`](@ref), [`GetWorkingDirectory`](@ref), [`Getenv`](@ref), [`HomeDirectory`](@ref), [`HostName`](@ref), [`IgnoreInterrupt`](@ref), [`IgnoreSignal`](@ref), [`InControl`](@ref), [`Init`](@ref), [`InnerLoop`](@ref), [`IsA`](@ref), [`IsAbsoluteFileName`](@ref), [`IsFileInIncludePath`](@ref), [`IsPathLocal`](@ref), [`Link`](@ref), [`ListLibraries`](@ref), [`ListSymbols`](@ref), [`LoadAllLibraries`](@ref), [`Load`](@ref), [`MakeDirectory`](@ref), [`NextTimeOut`](@ref), [`NotifyApplicationCreated`](@ref), [`Now`](@ref), [`OpenConnection`](@ref), [`OpenDirectory`](@ref), [`OpenPipe`](@ref), [`Openlog`](@ref), [`PrependPathName`](@ref), [`ProcessEvents`](@ref), [`RecvBuf`](@ref), [`RecvRaw`](@ref), [`RedirectOutput`](@ref), [`RemoveFileHandler`](@ref), [`RemoveOnExit`](@ref), [`RemoveSignalHandler`](@ref), [`RemoveStdExceptionHandler`](@ref), [`RemoveTimer`](@ref), [`Rename`](@ref), [`ResetSignal`](@ref), [`ResetSignals`](@ref), [`ResetTimer`](@ref), [`Run`](@ref), [`Select`](@ref), [`SendBuf`](@ref), [`SendRaw`](@ref), [`SetAclicMode`](@ref), [`SetBuildDir`](@ref), [`SetDisplay`](@ref), [`SetDynamicPath`](@ref), [`SetErrorStr`](@ref), [`SetFPEMask`](@ref), [`SetFlagsDebug`](@ref), [`SetFlagsOpt`](@ref), [`SetIncludePath`](@ref), [`SetLinkdefSuffix`](@ref), [`SetLinkedLibs`](@ref), [`SetMakeExe`](@ref), [`SetMakeSharedLib`](@ref), [`SetObjExt`](@ref), [`SetProgname`](@ref), [`SetSoExt`](@ref), [`SetSockOpt`](@ref), [`Setenv`](@ref), [`ShowOutput`](@ref), [`Sleep`](@ref), [`SplitAclicMode`](@ref), [`StackTrace`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Symlink`](@ref), [`Syslog`](@ref), [`TSystem!Class_Name`](@ref), [`TSystem!Class_Version`](@ref), [`TSystem!Class`](@ref), [`TSystem!DeclFileName`](@ref), [`TSystem!GetErrno`](@ref), [`TSystem!ResetErrno`](@ref), [`TSystem`](@ref), [`TempDirectory`](@ref), [`TempFileName`](@ref), [`Umask`](@ref), [`UnixPathName`](@ref), [`Unlink`](@ref), [`Unload`](@ref), [`Unsetenv`](@ref), [`Utime`](@ref), [`Which`](@ref), [`WorkingDirectory`](@ref), [`cd`](@ref), [`mkdir`](@ref), [`pwd`](@ref)
""" TSystem

# Wrapper of TFileHandler
@trydoc raw"""
    ROOT.TFileHandler





Related functions: [`Add`](@ref), [`GetFd`](@ref), [`HasReadInterest`](@ref), [`HasWriteInterest`](@ref), [`IsA`](@ref), [`IsReadReady`](@ref), [`IsWriteReady`](@ref), [`Notify`](@ref), [`ReadNotify`](@ref), [`Remove`](@ref), [`ResetReadyMask`](@ref), [`SetFd`](@ref), [`SetInterest`](@ref), [`SetReadReady`](@ref), [`SetWriteReady`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TFileHandler!Class_Name`](@ref), [`TFileHandler!Class_Version`](@ref), [`TFileHandler!Class`](@ref), [`TFileHandler!DeclFileName`](@ref), [`TFileHandler`](@ref), [`WriteNotify`](@ref)
""" TFileHandler

# Wrapper of TStdExceptionHandler
@trydoc raw"""
    ROOT.TStdExceptionHandler





Related functions: [`Add`](@ref), [`Handle`](@ref), [`IsA`](@ref), [`Notify`](@ref), [`Remove`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TStdExceptionHandler!Class_Name`](@ref), [`TStdExceptionHandler!Class_Version`](@ref), [`TStdExceptionHandler!Class`](@ref), [`TStdExceptionHandler!DeclFileName`](@ref), [`TStdExceptionHandler`](@ref)
""" TStdExceptionHandler

# Wrapper of TRedirectOutputGuard
@trydoc raw"""
    ROOT.TRedirectOutputGuard





Related functions: [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TRedirectOutputGuard!Class_Name`](@ref), [`TRedirectOutputGuard!Class_Version`](@ref), [`TRedirectOutputGuard!Class`](@ref), [`TRedirectOutputGuard!DeclFileName`](@ref), [`TRedirectOutputGuard`](@ref)
""" TRedirectOutputGuard

# Wrapper of TRef
@trydoc raw"""
    ROOT.TRef

Persistent Reference link to a [TObject](@ref) A [TRef](@ref) is a lightweight object pointing to any [TObject](@ref).

This object can be used instead of normal C++ pointers in case

- the referenced object R and the pointer P are not written to the same file
- P is read before R
- R and P are written to different Tree branches

When a top level object (eg Event *event) is a tree/graph of many objects, the normal [ROOT](@ref) Streaming mechanism ensures that only one copy of each object in the tree/graph is written to the output buffer to avoid circular dependencies.

However if the object event is split into several files or into several branches of one or more Trees, normal C++ pointers cannot be used because each I/O operation will write the referenced objects.

When a [TRef](@ref) is used to point to a [TObject](@ref) *robj, for example in a class with 

    TRef  fRef;

(C++ version of the code)

 one can do: 

    fRef = robj;  //to set the pointer

(C++ version of the code)

 This [TRef](@ref) and robj can be written with two different I/O calls in the same or different files, in the same or different branches of a Tree.

If the [TRef](@ref) is read and the referenced object has not yet been read, the [TRef](@ref) will return a null pointer. As soon as the referenced object will be read, the [TRef](@ref) will point to it. If the referenced object is contained in a [TTree](@ref) it can be auto-loaded using the [TBranchRef](@ref) mechanism, which is set up by simply calling [TTree!BranchRef()](@ref).

[TRef](@ref) also supports the complex situation where a [TFile](@ref) is updated multiple times on the same machine or a different machine.

## How does it work

A [TRef](@ref) is itself a [TObject](@ref) with an additional transient pointer fPID. When the statement fRef = robj is executed, the following actions happen:

- The pointer fPID is set to the current [TProcessID](@ref).
- The current ObjectNumber (see below) is incremented by one.
- robj!fUniqueID is set to ObjectNumber.
- In the fPID object, the element fObjects[ObjectNumber] is set to robj
- ref!fUniqueID is also set to ObjectNumber.

After having set fRef, one can immediately return the value of robj using fRef.GetObject(). This function returns directly fObjects[fUniqueID] from the fPID object.

When the [TRef](@ref) is written, the process id number pidf of fPID is written in addition to the [TObject](@ref) part of [TRef](@ref) (fBits,fUniqueID).

When the [TRef](@ref) is read, its pointer fPID is set to the value stored in the [TObjArray](@ref) of [TFile!fProcessIDs](@ref) (fProcessIDs[pidf]). The pidf is stored as a UShort_t limiting a file to 65535 distinct ProcessID objects.

The pidf is stored in the bits 24->31 of the fUniqueID of the [TRef](@ref). This implies that the number of TRefs in a single ProcessID should not exceed 2**24 = 16777216. For pidf greater than 254, the value 0xff is stored in those bits and we use the table [TProcessID!fgObjPIDs](@ref) which links the referenced object's address to its ProcessID.

See section "ObjectNumber" below for a recipe to minimize the object count. If the object-number exceeds this limit, it could be the sign that:

- The object count is never reset (see below)
- [TRef](@ref) is misused.

When a referenced object robj is written, [TObject!Streamer](@ref) writes in addition to the standard (fBits,fUniqueID) the pidf. When this robj is read by [TObject!Streamer](@ref), the pidf is read. At this point, robj is entered into the table of objects of the [TProcessID](@ref) corresponding to pidf.

### WARNING1:

If MyClass is the class of the referenced object, The [TObject](@ref) part of MyClass must be Streamed. One should not call MyClass!Class()->IgnoreTObjectStreamer()

### WARNING2:

A [TRef](@ref) cannot point to another [TRef](@ref).

## ObjectNumber

When an object is referenced (see [TRef](@ref) assignment operator or [TRefArray!Add](@ref)) a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global_ in [TProcessID!fgNumber](@ref). fUniqueID is some sort of serial object number in the current session. One can retrieve at any time the current value of fgNumber by calling the static function [TProcessID!GetObjectCount](@ref) or set this number via [TProcessID!SetObjectCount](@ref).

To avoid a growing table of fObjects in [TProcessID](@ref), in case, for example, one processes many events in a loop, it might be necessary to reset the ObjectNumber at the theend of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build).

The value of ObjectNumber (say saveNumber=[TProcessID!GetObjectCount()](@ref)) may be saved at the beginning of one event and reset to this original value at the theend of the event via TProcessID!SetObjectCount(saveNumber). These actions may be stacked.

## Action on Demand

The normal behaviour of a [TRef](@ref) has been described above. In addition, [TRef](@ref) supports also "Actions on Demand". It may happen that the object referenced is not yet in memory, on a separate file or not yet computed. In this case [TRef](@ref) is able to automatically execute an action:

- call to a compiled function (static function of member function)
- call to an interpreted function
- execution of a C++ script

How to select this option? In the definition of the [TRef](@ref) data member in the original class, do: 

    TRef  fRef;   //EXEC:execName. points to something

(C++ version of the code)

 When the special keyword "EXEC:" is found in the comment field of the member, the next string is assumed to be the name of a [TExec](@ref) object. When a file is connected, the dictionary of the classes on the file is read in memory (see [TFile!ReadStreamerInfo](@ref)). When the [TStreamerElement](@ref) object is read, a [TExec](@ref) object is automatically created with the name specified after the keyword "EXEC:" in case a [TExec](@ref) with a same name does not already exist.

The action to be executed via this [TExec](@ref) can be specified with:

- a call to the [TExec](@ref) constructor, if the constructor is called before opening the file.
- a call to [TExec!SetAction](@ref) at any time. One can compute a pointer to an existing [TExec](@ref) with a name with: 

        TExec *myExec = gROOT->GetExec(execName);
        myExec->SetAction(actionCommand);

(C++ version of the code)

 where actionCommand is a string containing a C++ instruction. Examples: 

        myExec->SetAction("LoadHits()");
        myExec->SetAction(".x script.C");

(C++ version of the code)


When a [TRef](@ref) is dereferenced via [TRef!GetObject](@ref), its [TExec](@ref) will be automatically executed. In the function/script being executed, one or more of the following actions can be executed:

- load a file containing the referenced object. This function typically looks in the file catalog (GRID).
- compute a pointer to the referenced object and communicate this pointer back to the calling function [TRef!GetObject](@ref) via: 

        TRef!SetStaticObject(object).

(C++ version of the code)

 When the [TExec](@ref) is called, it has access to the dereferencing [TRef](@ref) by calling [GetStaticObject()](@ref) ([TRef!GetObject()](@ref) sets fgObject to "this" before the call to [TExec](@ref)). This can be useful for accessing the [TRef](@ref)'s fUniqueID.

As soon as an object is returned to GetObject, the fUniqueID of the [TRef](@ref) is set to the fUniqueID of the referenced object. At the next call to GetObject, the pointer stored in fPid:fObjects[fUniqueID] will be returned directly.

An example of action on demand is shown in $ROOTSYS/test/Event.h with the member: 

    TRef    fWebHistogram;   //EXEC:GetWebHistogram

(C++ version of the code)

 When calling fWebHistogram.GetObject(), the function GetObject will automatically invoke a script GetWebHistogram.C via the interpreter.

An example of a GetWebHistogram.C script is shown below 

    void GetWebHistogram() {
       TFile *f= TFile!Open("http://root.cern/files/pippa.root");
       f->cd("DM/CJ");
       TH1 *h6 = (TH1*)gDirectory->Get("h6");
       h6->SetDirectory(0);
       delete f;
       TRef!SetStaticObject(h6);
    }

(C++ version of the code)

 In the above example, a call to fWebHistogram.GetObject() executes the script with the function GetWebHistogram. This script connects a file with histograms: pippa.root on the [ROOT](@ref) Web site and returns the object h6 to [TRef!GetObject](@ref).

Note that if the definition of the [TRef](@ref) fWebHistogram had been: 

    TRef    fWebHistogram;   //EXEC:GetWebHistogram()

(C++ version of the code)

 then, the compiled or interpreted function GetWebHistogram() would have been called instead of the C++ script GetWebHistogram.C

## Special case of a TRef pointing to an object with a TUUID

If the referenced object has a [TUUID](@ref), its bit kHasUUID has been set. This case is detected by the [TRef](@ref) assignment operator. (For example, [TFile](@ref) and [TDirectory](@ref) have a [TUUID](@ref)) The [TRef](@ref) fPID points directly to the single object [TProcessUUID](@ref) (deriving from [TProcessID](@ref)) and managing the list of TUUIDs for a process. The [TRef](@ref) kHasUUID bit is set and its fUniqueID is set to the fUniqueID of the referenced object.

When the [TRef](@ref) is streamed to a buffer, the corresponding [TUUID](@ref) is also streamed with the [TRef](@ref). When a [TRef](@ref) is read from a buffer, the corresponding [TUUID](@ref) is also read and entered into the global_ list of TUUIDs (if not already there). The [TRef](@ref) fUniqueID is set to the UUIDNumber. see [TProcessUUID](@ref) for more details.

## Array of TRef

The special class [TRefArray](@ref) should be used to store multiple references. A [TRefArray](@ref) has one single pointer fPID for all objects in the array. It has a dynamic compact table of fUniqueIDs. Use a [TRefArray](@ref) rather then a collection of TRefs if all TRefs stem from the same process.

Example:

Suppose a [TObjArray](@ref) *mytracks containing a list of Track objects Suppose a [TRefArray](@ref) *pions containing pointers to the pion tracks in mytracks. This list is created with statements like: pions->Add(track); Suppose a [TRefArray](@ref) *muons containing pointers to the muon tracks in mytracks. The 3 arrays mytracks,pions and muons may be written separately.

Related functions: [`GetObject`](@ref), [`GetPID`](@ref), [`IsA`](@ref), [`IsValid`](@ref), [`SetAction`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TRef!AddExec`](@ref), [`TRef!Class_Name`](@ref), [`TRef!Class_Version`](@ref), [`TRef!Class`](@ref), [`TRef!DeclFileName`](@ref), [`TRef!GetListOfExecs`](@ref), [`TRef!GetStaticObject`](@ref), [`TRef!SetObject`](@ref), [`TRef!SetStaticObject`](@ref), [`TRef`](@ref), [`assign`](@ref)
""" TRef

# Wrapper of TRefTable
@trydoc raw"""
    ROOT.TRefTable

A [TRefTable](@ref) maintains the association between a referenced object and the parent object supporting this referenced object.

The parent object is typically a branch of a [TTree](@ref). For each object referenced in a [TTree](@ref) entry, the corresponding entry in the [TTree](@ref)'s [TBranchRef!fRefTable](@ref) contains the index of the branch that needs to be loaded to bring the object into memory.

Persistency of a [TRefTable](@ref) is split into two parts:

- entry specific information is stored (read) by FillBuffer (ReadBuffer). For each referenced object the object's fUniqueID and the referencing [TRef!fPID](@ref) is stored (to allow the [TRefTable](@ref) to autoload references created by different processes).
- non-entry specific, i.e. global_ information is stored (read) by the Streamer function. This comprises all members marked as persistent.

As TObject!fUniqueID is only unique for a given [TProcessID](@ref), a table of unique IDs is kept for each used [TProcessID](@ref). There is no natural order of TProcessIDs, so [TRefTable](@ref) stores a vector of the TGUID of all known TProcessIDs in fProcessGUIDs; the index of a [TProcessID](@ref) in this vector defines the index of the auto-loading info in fParentIDs for that [TProcessID](@ref). The mapping of TProcessID* to index is cached for quick non-persistent lookup.

Related functions: [`Add`](@ref), [`Clear`](@ref), [`Expand`](@ref), [`FillBuffer`](@ref), [`GetN`](@ref), [`GetNumPIDs`](@ref), [`GetOwner`](@ref), [`GetParent`](@ref), [`GetParents`](@ref), [`GetSize`](@ref), [`GetUIDContext`](@ref), [`GetUID`](@ref), [`Notify`](@ref), [`ReadBuffer`](@ref), [`Reset`](@ref), [`SetParent`](@ref), [`SetUID`](@ref), [`TRefTable!GetRefTable`](@ref), [`TRefTable!SetRefTable`](@ref), [`TRefTable`](@ref), [`assign`](@ref)
""" TRefTable

# Wrapper of TRemoteObject
@trydoc raw"""
    ROOT.TRemoteObject

The [TRemoteObject](@ref) class provides protocol for browsing [ROOT](@ref) objects from a remote [ROOT](@ref) session.

It contains information on the real remote object as:

- Object Properties (i.e. file stat if the object is a [TSystemFile](@ref))
- Object Name
- Class Name
- [TKey](@ref) Object Name (if the remote object is a [TKey](@ref))
- [TKey](@ref) Class Name (if the remote object is a [TKey](@ref))
- Remote object address

Related functions: [`Browse`](@ref), [`GetClassName`](@ref), [`GetFileStat`](@ref), [`GetKeyClassName`](@ref), [`GetKeyObjectName`](@ref), [`IsA`](@ref), [`IsFolder`](@ref), [`SetFolder`](@ref), [`SetKeyClassName`](@ref), [`SetKeyObjectName`](@ref), [`SetRemoteAddress`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TRemoteObject!Class_Name`](@ref), [`TRemoteObject!Class_Version`](@ref), [`TRemoteObject!Class`](@ref), [`TRemoteObject!DeclFileName`](@ref), [`TRemoteObject`](@ref)
""" TRemoteObject

# Wrapper of TRootIOCtor
@trydoc raw"""
    ROOT.TRootIOCtor





Related functions: 
""" TRootIOCtor

# Wrapper of TSystemFile
@trydoc raw"""
    ROOT.TSystemFile

A [TSystemFile](@ref) describes an operating system file.

The information is used by the browser (see [TBrowser](@ref)).

Related functions: [`Browse`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`DrawClass`](@ref), [`DrawClone`](@ref), [`Dump`](@ref), [`Edit`](@ref), [`GetIconName`](@ref), [`Inspect`](@ref), [`IsA`](@ref), [`IsDirectory`](@ref), [`Move`](@ref), [`Rename`](@ref), [`SetDrawOption`](@ref), [`SetIconName`](@ref), [`SetName`](@ref), [`SetTitle`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TSystemFile!Class_Name`](@ref), [`TSystemFile!Class_Version`](@ref), [`TSystemFile!Class`](@ref), [`TSystemFile!DeclFileName`](@ref), [`TSystemFile`](@ref)
""" TSystemFile

# Wrapper of TSystemDirectory
@trydoc raw"""
    ROOT.TSystemDirectory

Describes an Operating System directory for the browser.



Related functions: [`Browse`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`DrawClass`](@ref), [`DrawClone`](@ref), [`Edit`](@ref), [`GetListOfFiles`](@ref), [`IsA`](@ref), [`IsDirectory`](@ref), [`IsFolder`](@ref), [`Move`](@ref), [`SetDirectory`](@ref), [`SetDrawOption`](@ref), [`SetName`](@ref), [`SetTitle`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TSystemDirectory!Class_Name`](@ref), [`TSystemDirectory!Class_Version`](@ref), [`TSystemDirectory!Class`](@ref), [`TSystemDirectory!DeclFileName`](@ref), [`TSystemDirectory`](@ref)
""" TSystemDirectory

# Wrapper of TTask
@trydoc raw"""
    ROOT.TTask



[TTask](@ref) is a base class that can be used to build a complex tree of Tasks. Each [TTask](@ref) derived class may contain other TTasks that can be executed recursively, such that a complex program can be dynamically built and executed by invoking the services of the top level Task or one of its subtasks.

Use the [TTask!Add](@ref) function to add a subtask to an existing [TTask](@ref). To execute a [TTask](@ref), one calls the ExecuteTask function. ExecuteTask will call recursively:

- the [TTask!Exec](@ref) function of the derived class
- [TTask!ExecuteTasks](@ref) to execute for each task the list of its subtasks.

If the top level task (see example below) is added to the list of Root browsable objects, the tree of tasks can be visualized by the Root browser. The browser can be used to thestart a task, set break points at the beginning of a task or when the task has completed. At a breakpoint, data structures generated by the execution up this point may be inspected asynchronously and then the execution can be resumed by selecting the "Continue" function of a task.

A Task may be active or inactive (controlled by [TTask!SetActive](@ref)). When a task is not active, its sub tasks are not executed.

A [TTask](@ref) tree may be made persistent, saving the status of all the tasks.

The Root browser's picture below has been generated by executing the following script: 

    {
       TTask *aliroot  = new TTask("aliroot","ALICE reconstruction main task");
       TTask *geominit = new TTask("geomInit","Initialize ALICE geometry");
       TTask *matinit  = new TTask("matInit","Initialize ALICE materials");
       TTask *physinit = new TTask("physInit","Initialize Physics processes");
       TTask *tracker  = new TTask("tracker","Track reconstruction manager");
       TTask *tpcrec   = new TTask("tpcrec","TPC reconstruction");
       TTask *itsrec   = new TTask("itsrec","ITS reconstruction");
       TTask *muonrec  = new TTask("muonRec","Muon Reconstruction");
       TTask *phosrec  = new TTask("phosRec","Phos Reconstruction");
       TTask *richrec  = new TTask("richRec","Rich Reconstruction");
       TTask *trdrec   = new TTask("trdRec","TRD Reconstruction");
       TTask *globrec  = new TTask("globRec","Global Track Reconstruction");
       TTask *pstats   = new TTask("printStats","Print Run Statistics");
       TTask *run      = new TTask("run","Process one run");
       TTask *event    = new TTask("event","Process one event");
       aliroot->Add(geominit);
       aliroot->Add(matinit);
       aliroot->Add(physinit);
       aliroot->Add(run);
       run->Add(event);
       event->Add(tracker);
       event->Add(muonrec);
       event->Add(phosrec);
       event->Add(richrec);
       event->Add(trdrec);
       event->Add(globrec);
       tracker->Add(tpcrec);
       tracker->Add(itsrec);
       run->Add(pstats);
       gROOT->GetListOfBrowsables()->Add(aliroot,"aliroot");
       new TBrowser;
    }

(C++ version of the code)

 ![https://root.cern/doc/v636/base_tasks.png](https://root.cern/doc/v636/base_tasks.png)

Related functions: [`Abort`](@ref), [`Add`](@ref), [`Browse`](@ref), [`CleanTasks`](@ref), [`Clear`](@ref), [`Continue`](@ref), [`Exec`](@ref), [`ExecuteTask`](@ref), [`ExecuteTasks`](@ref), [`GetBreakin`](@ref), [`GetBreakout`](@ref), [`GetListOfTasks`](@ref), [`IsA`](@ref), [`IsActive`](@ref), [`IsFolder`](@ref), [`SetActive`](@ref), [`SetBreakin`](@ref), [`SetBreakout`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TTask!Class_Name`](@ref), [`TTask!Class_Version`](@ref), [`TTask!Class`](@ref), [`TTask!DeclFileName`](@ref), [`TTask`](@ref), [`assign`](@ref), [`ls`](@ref)
""" TTask

# Wrapper of TTimeStamp
@trydoc raw"""
    ROOT.TTimeStamp

The [TTimeStamp](@ref) encapsulates seconds and ns since EPOCH.

This extends (and isolates) struct timespec 

    struct timespec
       {
          time_t   tv_sec;   // seconds
          long     tv_nsec;  // nanoseconds
       }
    time_t seconds is relative to Jan 1, 1970 00:00:00 UTC

(C++ version of the code)

 No accounting of leap seconds is made.

Due to ROOT/CINT limitations [TTimeStamp](@ref) does not explicitly hold a timespec struct; attempting to do so means the Streamer must be hand written. Instead we have chosen to simply contain similar fields within the private area of this class.

NOTE: the use of time_t (and its default implementation as a 32 int) implies overflow conditions occurs somewhere around `Jan 18, 19:14:07, 2038`. If this experiment is still going when it becomes significant someone will have to deal with it.

Related functions: [`Add`](@ref), [`AsDouble`](@ref), [`AsGAST`](@ref), [`AsGMST`](@ref), [`AsJulianDate`](@ref), [`AsLAST`](@ref), [`AsLMST`](@ref), [`AsString`](@ref), [`Copy`](@ref), [`GetDate`](@ref), [`GetDayOfWeek`](@ref), [`GetDayOfYear`](@ref), [`GetMonth`](@ref), [`GetNanoSec`](@ref), [`GetSec`](@ref), [`GetTimeSpec`](@ref), [`GetTime`](@ref), [`GetWeek`](@ref), [`IsA`](@ref), [`IsLeapYear`](@ref), [`Print`](@ref), [`SetNanoSec`](@ref), [`SetSec`](@ref), [`Set`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TTimeStamp!Class_Name`](@ref), [`TTimeStamp!Class_Version`](@ref), [`TTimeStamp!Class`](@ref), [`TTimeStamp!DeclFileName`](@ref), [`TTimeStamp!DumpTMStruct`](@ref), [`TTimeStamp!GetDayOfWeek`](@ref), [`TTimeStamp!GetDayOfYear`](@ref), [`TTimeStamp!GetWeek`](@ref), [`TTimeStamp!GetZoneOffset`](@ref), [`TTimeStamp!IsLeapYear`](@ref), [`TTimeStamp!MktimeFromUTC`](@ref), [`TTimeStamp`](@ref), [`double`](@ref)
""" TTimeStamp

# Wrapper of TUri
@trydoc raw"""
    ROOT.TUri

This class represents a RFC 3986 compatible URI.

###See

https://doi.org/10.17487/RFC3986 It provides member functions to set and return the different the different parts of an URI. The functionality is that of a validating parser.

Related functions: [`GetAuthority`](@ref), [`GetFragment`](@ref), [`GetHierPart`](@ref), [`GetHost`](@ref), [`GetPath`](@ref), [`GetPort`](@ref), [`GetQuery`](@ref), [`GetRelativePart`](@ref), [`GetScheme`](@ref), [`GetUri`](@ref), [`GetUserInfo`](@ref), [`HasAuthority`](@ref), [`HasFragment`](@ref), [`HasHierPart`](@ref), [`HasHost`](@ref), [`HasPath`](@ref), [`HasPort`](@ref), [`HasQuery`](@ref), [`HasRelativePart`](@ref), [`HasScheme`](@ref), [`HasUserInfo`](@ref), [`IsA`](@ref), [`IsAbsolute`](@ref), [`IsReference`](@ref), [`IsRelative`](@ref), [`IsSortable`](@ref), [`IsUri`](@ref), [`Normalise`](@ref), [`Print`](@ref), [`Reset`](@ref), [`SetAuthority`](@ref), [`SetFragment`](@ref), [`SetHierPart`](@ref), [`SetHost`](@ref), [`SetPath`](@ref), [`SetPort`](@ref), [`SetQuery`](@ref), [`SetRelativePart`](@ref), [`SetScheme`](@ref), [`SetUri`](@ref), [`SetUserInfo`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TUri!Class_Name`](@ref), [`TUri!Class_Version`](@ref), [`TUri!Class`](@ref), [`TUri!DeclFileName`](@ref), [`TUri!IsAuthority`](@ref), [`TUri!IsFragment`](@ref), [`TUri!IsHierPart`](@ref), [`TUri!IsHost`](@ref), [`TUri!IsIpv4`](@ref), [`TUri!IsPathAbempty`](@ref), [`TUri!IsPathAbsolute`](@ref), [`TUri!IsPathEmpty`](@ref), [`TUri!IsPathNoscheme`](@ref), [`TUri!IsPathRootless`](@ref), [`TUri!IsPath`](@ref), [`TUri!IsPort`](@ref), [`TUri!IsQuery`](@ref), [`TUri!IsRegName`](@ref), [`TUri!IsRelativePart`](@ref), [`TUri!IsScheme`](@ref), [`TUri!IsUnreserved`](@ref), [`TUri!IsUserInfo`](@ref), [`TUri!MergePaths`](@ref), [`TUri!PctDecodeUnreserved`](@ref), [`TUri!PctDecode`](@ref), [`TUri!PctEncode`](@ref), [`TUri!PctNormalise`](@ref), [`TUri!RemoveDotSegments`](@ref), [`TUri!Transform`](@ref), [`TUri`](@ref), [`assign`](@ref)
""" TUri

# Wrapper of TVirtualAuth
@trydoc raw"""
    ROOT.TVirtualAuth





Related functions: [`Authenticate`](@ref), [`ClientVersion`](@ref), [`ErrorMsg`](@ref), [`IsA`](@ref), [`Name`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualAuth!Class_Name`](@ref), [`TVirtualAuth!Class_Version`](@ref), [`TVirtualAuth!Class`](@ref), [`TVirtualAuth!DeclFileName`](@ref), [`TVirtualAuth`](@ref)
""" TVirtualAuth

# Wrapper of TVirtualFFT
@trydoc raw"""
    ROOT.TVirtualFFT

[TVirtualFFT](@ref) is an interface class for Fast Fourier Transforms.

The default FFT library is FFTW. To use it, FFTW3 library should already be installed, and [ROOT](@ref) should be have fftw3 themodule enabled, with the directories of fftw3 include file and library specified (see installation instructions). Function [SetDefaultFFT()](@ref) allows to change the default library.

## Available transform types:

FFT:

- "C2CFORWARD" - a complex input/output discrete Fourier transform (DFT) in one or more dimensions, -1 in the exponent
- "C2CBACKWARD"- a complex input/output discrete Fourier transform (DFT) in one or more dimensions, +1 in the exponent
- "R2C" - a real-input/complex-output discrete Fourier transform (DFT) in one or more dimensions,
- "C2R" - inverse transforms to "R2C", taking complex input (storing the non-redundant half of a logically Hermitian array) to real output
- "R2HC" - a real-input DFT with output in halfcomplex format, i.e. real and imaginary parts for a transform of size n stored as r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1
- "HC2R" - computes the reverse of FFTW_R2HC, above
- "DHT" - computes a discrete Hartley transform

## Sine/cosine transforms:

Different types of transforms are specified by parameter kind of the [SineCosine()](@ref) static function. 4 different kinds of sine and cosine transforms are available

- DCT-I (REDFT00 in FFTW3 notation)- kind=0
- DCT-II (REDFT01 in FFTW3 notation)- kind=1
- DCT-III(REDFT10 in FFTW3 notation)- kind=2
- DCT-IV (REDFT11 in FFTW3 notation)- kind=3
- DST-I (RODFT00 in FFTW3 notation)- kind=4
- DST-II (RODFT01 in FFTW3 notation)- kind=5
- DST-III(RODFT10 in FFTW3 notation)- kind=6
- DST-IV (RODFT11 in FFTW3 notation)- kind=7

Formulas and detailed descriptions can be found in the chapter "What FFTW really computes" of the FFTW manual

NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its inverse will give the original array, multiplied by normalization constant (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for other sine/cosine transforms)

## How to use it:

Call to the static function FFT returns a pointer to a fast Fourier transform with requested parameters. Call to the static function SineCosine returns a pointer to a sine or cosine transform with requested parameters. Example: 

    {
       Int_t N = 10; Double_t *in = new Double_t[N];
       TVirtualFFT *fftr2c = TVirtualFFT!FFT(1, &N, "R2C");
       fftr2c->SetPoints(in);
       fftr2c->Transform();
       Double_t re, im;
       for (Int_t i=0; i<N; i++)
          fftr2c->GetPointComplex(i, re, im);
       ...
       fftr2c->SetPoints(in2);
       ...
       fftr2c->SetPoints(in3);
       ...
    }

(C++ version of the code)

 Different options are explained in the function comments

Related functions: [`GetN`](@ref), [`GetNdim`](@ref), [`GetPointComplex`](@ref), [`GetPointReal`](@ref), [`GetPointsComplex`](@ref), [`GetPointsReal`](@ref), [`GetPoints`](@ref), [`GetSign`](@ref), [`GetTransformFlag`](@ref), [`GetType`](@ref), [`Init`](@ref), [`IsA`](@ref), [`IsInplace`](@ref), [`SetPointComplex`](@ref), [`SetPoint`](@ref), [`SetPointsComplex`](@ref), [`SetPoints`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualFFT!Class_Name`](@ref), [`TVirtualFFT!Class_Version`](@ref), [`TVirtualFFT!Class`](@ref), [`TVirtualFFT!DeclFileName`](@ref), [`TVirtualFFT!FFT`](@ref), [`TVirtualFFT!GetCurrentTransform`](@ref), [`TVirtualFFT!GetDefaultFFT`](@ref), [`TVirtualFFT!SetDefaultFFT`](@ref), [`TVirtualFFT!SetTransform`](@ref), [`TVirtualFFT!SineCosine`](@ref), [`TVirtualFFT`](@ref), [`Transform`](@ref)
""" TVirtualFFT

# Wrapper of TVirtualMapFile
@trydoc raw"""
    ROOT.TVirtualMapFile

Abstract base class for [TMapFile](@ref).

This allows Core to handle [TMapFile](@ref) which is implemented in RIO

Related functions: [`Close`](@ref), [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualMapFile!Class_Name`](@ref), [`TVirtualMapFile!Class_Version`](@ref), [`TVirtualMapFile!Class`](@ref), [`TVirtualMapFile!DeclFileName`](@ref)
""" TVirtualMapFile

# Wrapper of THashTable
@trydoc raw"""
    ROOT.THashTable

[THashTable](@ref) implements a hash table to store [TObject](@ref)'s.

The hash value is calculated using the value returned by the [TObject](@ref)'s [Hash()](@ref) function. Each class inheriting from [TObject](@ref) can override [Hash()](@ref) as it sees fit.

[THashTable](@ref) does not preserve the insertion order of the objects. If the insertion order is important AND fast retrieval is needed use [THashList](@ref) instead.

Related functions: [`AddAll`](@ref), [`AddBefore`](@ref), [`Add`](@ref), [`AverageCollisions`](@ref), [`Clear`](@ref), [`Collisions`](@ref), [`Delete`](@ref), [`Empty`](@ref), [`FindObject`](@ref), [`GetListForObject`](@ref), [`GetObjectRef`](@ref), [`GetRehashLevel`](@ref), [`GetSize`](@ref), [`MakeIterator`](@ref), [`Print`](@ref), [`Rehash`](@ref), [`RemoveSlow`](@ref), [`Remove`](@ref), [`SetRehashLevel`](@ref), [`THashTable`](@ref)
""" THashTable

# Wrapper of THashTableIter
@trydoc raw"""
    ROOT.THashTableIter

Iterator of hash table.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`THashTableIter`](@ref), [`assign`](@ref)
""" THashTableIter

# Wrapper of TPair
@trydoc raw"""
    ROOT.TPair

Class used by [TMap](@ref) to store (key,value) pairs.



Related functions: [`Browse`](@ref), [`ClassDefOverride`](@ref), [`GetName`](@ref), [`GetTitle`](@ref), [`Hash`](@ref), [`IsEqual`](@ref), [`IsFolder`](@ref), [`Key`](@ref), [`SetValue`](@ref), [`TPair`](@ref), [`Value`](@ref)
""" TPair

# Wrapper of TMapIter
@trydoc raw"""
    ROOT.TMapIter

Iterator of map.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TMapIter`](@ref), [`assign`](@ref)
""" TMapIter

# Wrapper of TVirtualMonitoringWriter
@trydoc raw"""
    ROOT.TVirtualMonitoringWriter





Related functions: [`IsA`](@ref), [`SendFileCloseEvent`](@ref), [`SendFileOpenProgress`](@ref), [`SendFileReadProgress`](@ref), [`SendFileWriteProgress`](@ref), [`SendInfoDescription`](@ref), [`SendInfoStatus`](@ref), [`SendInfoTime`](@ref), [`SendInfoUser`](@ref), [`SendParameters`](@ref), [`SendProcessingProgress`](@ref), [`SendProcessingStatus`](@ref), [`SetLogLevel`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualMonitoringWriter!Class_Name`](@ref), [`TVirtualMonitoringWriter!Class_Version`](@ref), [`TVirtualMonitoringWriter!Class`](@ref), [`TVirtualMonitoringWriter!DeclFileName`](@ref), [`TVirtualMonitoringWriter`](@ref), [`Verbose`](@ref)
""" TVirtualMonitoringWriter

# Wrapper of TVirtualMonitoringReader
@trydoc raw"""
    ROOT.TVirtualMonitoringReader





Related functions: [`DeleteMap`](@ref), [`DumpResult`](@ref), [`GetLastValues`](@ref), [`GetMap`](@ref), [`GetValues`](@ref), [`IsA`](@ref), [`ProxyValues`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualMonitoringReader!Class_Name`](@ref), [`TVirtualMonitoringReader!Class_Version`](@ref), [`TVirtualMonitoringReader!Class`](@ref), [`TVirtualMonitoringReader!DeclFileName`](@ref), [`TVirtualMonitoringReader`](@ref)
""" TVirtualMonitoringReader

# Wrapper of TVirtualPadEditor
@trydoc raw"""
    ROOT.TVirtualPadEditor

Abstract base class used by [ROOT](@ref) graphics editor.



Related functions: [`Build`](@ref), [`DeleteEditors`](@ref), [`DrawLineNDC`](@ref), [`DrawLine`](@ref), [`DrawTextNDC`](@ref), [`DrawText`](@ref), [`FillAttributes`](@ref), [`GetCanvas`](@ref), [`Hide`](@ref), [`IsA`](@ref), [`IsGlobal`](@ref), [`LineAttributes`](@ref), [`MarkerAttributes`](@ref), [`SetGlobal`](@ref), [`Show`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualPadEditor!Class_Name`](@ref), [`TVirtualPadEditor!Class_Version`](@ref), [`TVirtualPadEditor!Class`](@ref), [`TVirtualPadEditor!DeclFileName`](@ref), [`TVirtualPadEditor!GetEditorName`](@ref), [`TVirtualPadEditor!GetPadEditor`](@ref), [`TVirtualPadEditor!HideEditor`](@ref), [`TVirtualPadEditor!LoadEditor`](@ref), [`TVirtualPadEditor!SetPadEditorName`](@ref), [`TVirtualPadEditor!ShowEditor`](@ref), [`TVirtualPadEditor!Terminate`](@ref), [`TVirtualPadEditor!UpdateFillAttributes`](@ref), [`TVirtualPadEditor!UpdateLineAttributes`](@ref), [`TVirtualPadEditor!UpdateMarkerAttributes`](@ref), [`TVirtualPadEditor!UpdateTextAttributes`](@ref), [`TVirtualPadEditor`](@ref), [`TextAttributes`](@ref)
""" TVirtualPadEditor

# Wrapper of TAxis
@trydoc raw"""
    ROOT.TAxis

Class to manage histogram axis.

This class manages histogram axis. It is referenced by [TH1](@ref) and [TGraph](@ref). To make a graphical representation of an histogram axis, this class references the [TGaxis](@ref) class. [TAxis](@ref) supports axis with fixed or variable bin sizes. Labels may be associated to individual bins. See examples of various axis representations drawn by class [TGaxis](@ref).

Related functions: [`CanBeAlphanumeric`](@ref), [`CanExtend`](@ref), [`CenterLabels`](@ref), [`CenterTitle`](@ref), [`ChangeLabelByValue`](@ref), [`ChangeLabel`](@ref), [`ChooseTimeFormat`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`DistancetoPrimitive`](@ref), [`DrawClone`](@ref), [`ExecuteEvent`](@ref), [`FindBin`](@ref), [`FindFixBin`](@ref), [`GetBinCenterLog`](@ref), [`GetBinCenter`](@ref), [`GetBinLabel`](@ref), [`GetBinLowEdge`](@ref), [`GetBinUpEdge`](@ref), [`GetBinWidth`](@ref), [`GetCenterLabels`](@ref), [`GetCenterTitle`](@ref), [`GetCenter`](@ref), [`GetDecimals`](@ref), [`GetFirst`](@ref), [`GetLabels`](@ref), [`GetLast`](@ref), [`GetLowEdge`](@ref), [`GetModifiedLabels`](@ref), [`GetMoreLogLabels`](@ref), [`GetNbins`](@ref), [`GetNlabels`](@ref), [`GetNoExponent`](@ref), [`GetParent`](@ref), [`GetRotateTitle`](@ref), [`GetTicks`](@ref), [`GetTimeDisplay`](@ref), [`GetTimeFormatOnly`](@ref), [`GetTimeFormat`](@ref), [`GetTimeOffset`](@ref), [`GetTitle`](@ref), [`GetXbins`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`ImportAttributes`](@ref), [`IsAlphanumeric`](@ref), [`IsVariableBinSize`](@ref), [`LabelsOption`](@ref), [`RotateTitle`](@ref), [`SaveAttributes`](@ref), [`SetAlphanumeric`](@ref), [`SetBinLabel`](@ref), [`SetCanExtend`](@ref), [`SetDecimals`](@ref), [`SetDefaults`](@ref), [`SetDrawOption`](@ref), [`SetLimits`](@ref), [`SetMoreLogLabels`](@ref), [`SetNoAlphanumeric`](@ref), [`SetNoExponent`](@ref), [`SetParent`](@ref), [`SetRangeUser`](@ref), [`SetRange`](@ref), [`SetTicks`](@ref), [`SetTimeDisplay`](@ref), [`SetTimeFormat`](@ref), [`SetTimeOffset`](@ref), [`Set`](@ref), [`TAxis`](@ref), [`UnZoom`](@ref), [`ZoomOut`](@ref), [`assign`](@ref)
""" TAxis

# Wrapper of TVirtualViewer3D
@trydoc raw"""
    ROOT.TVirtualViewer3D

Abstract 3D shapes viewer.

The concrete implementations are:

- TViewerX3D : X3d viewer
- [TGLViewer](@ref) : OpenGL viewer

## 3D Viewer Infrastructure Overview

The 3D Viewer infrastructure consists of:

- [TVirtualViewer3D](@ref) interface: An abstract handle to the viewer, allowing client to test preferences, add objects, control the viewer via scripting (to be added) etc. -[TBuffer3D](@ref) class hierarchy: Used to describe 3D objects ("shapes")

    - filled /added by negotiation with viewer via [TVirtualViewer3D](@ref).

Together these allow clients to publish objects to any one of the 3D viewers (currently OpenGL/x3d,[TPad](@ref)), free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.

Publishing to a viewer consists of the following steps:

1. Create / obtain viewer handle
2. Begin scene on viewer
3. Fill mandatory parts of [TBuffer3D](@ref) describing object
4. Add to viewer
5. Fill optional parts of [TBuffer3D](@ref) if requested by viewer, and add again ... repeat 3/4/5 as required
6. End scene on viewer

## Creating / Obtaining Viewer

Create/obtain the viewer handle via local_/global_ pad - the viewer is always bound to a [TPad](@ref) object at present [This may be removed as a restriction in the future] . You should perform the publishing to the viewer described below in the [Paint()](@ref) method of the object you attach to the pad (via [Draw()](@ref)) 

    TVirtualViewer3D * v = gPad->GetViewer3D("xxxx");

(C++ version of the code)

" xxxx" is viewer type: OpenGL "ogl", X3D "x3d" or Pad "pad" (default). The viewer is created via the plugin manager, attached to pad, and the interface returned.

## Begin / End Scene

Objects must be added to viewer between BeginScene/EndScene calls e.g. 

    v->BeginScene();
    .....
    v->AddObject(....);
    v->AddObject(....);
    .....
    v->EndScene();

(C++ version of the code)

The BeginScene call will cause the viewer to suspend redraws etc, and after the EndScene the viewer will reset the camera to frame the new scene and redraw. [x3d viewer does not support changing of scenes - objects added after the first Open/CloseScene pair will be ignored.]

## Filling TBuffer3D and Adding to Viewer

The viewers behind the [TVirtualViewer3D](@ref) interface differ greatly in their capabilities e.g.

- Some know how to draw certain shapes natively (e.g. spheres/tubes in OpenGL) - others always require a raw tessellation description of points/lines/segments.
- Some need the 3D object positions in the global_ frame, others can cope with local_ frames + a translation matrix - which can give considerable performance benefits.

To cope with these situations the object buffer is filled out in negotiation with the viewer. [TBuffer3D](@ref) classes are conceptually divided into enumerated sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). ![https://root.cern/doc/v636/base_tbuffer3d.png](https://root.cern/doc/v636/base_tbuffer3d.png)

The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of [TBuffer3D](@ref) are used to test/set/clear these section valid flags.

The sections found in [TBuffer3D](@ref) (Core/BoundingBox/Raw Sizes/Raw) are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section in derived shape specific classes allows a more abstract shape description ("a sphere of inner radius x, outer radius y"). This enables a viewer which knows how to draw (tessellate) the shape itself to do so, which can bring considerable performance and quality benefits, while providing a generic fallback suitable for all viewers.

The rules for client negotiation with the viewer are:

- If suitable specialized [TBuffer3D](@ref) class exists, use it, otherwise use [TBuffer3D](@ref).
- Complete the mandatory Core section.
- Complete the ShapeSpecific section if applicable.
- Complete the BoundingBox if you can.
- Pass this buffer to the viewer using one of the [AddObject()](@ref) methods - see below.

If the viewer requires more sections to be completed (Raw/RawSizes) [AddObject()](@ref) will return flags indicating which ones, otherwise it returns kNone. You must fill the buffer and mark these sections valid, and pass the buffer again. A typical code snippet would be: 

    TBuffer3DSphere sphereBuffer;
    // Fill out kCore...
    // Fill out kBoundingBox...
    // Fill out kShapeSpecific for TBuffer3DSphere
    // Try first add to viewer
    Int_t reqSections = viewer->AddObject(buffer);
    if (reqSections != TBuffer3D!kNone) {
      if (reqSections & TBuffer3D!kRawSizes) {
         // Fill out kRawSizes...
      }
      if (reqSections & TBuffer3D!kRaw) {
         // Fill out kRaw...
      }
      // Add second time to viewer - ignore return cannot do more
      viewer->AddObject(buffer);
      }
    }

(C++ version of the code)

ShapeSpecific: If the viewer can directly display the buffer without filling of the kRaw/kRawSizes section it will not need to request client side tessellation. Currently we provide the following various shape specific classes, which the OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h)

- [TBuffer3DSphere](@ref) - solid, hollow and cut spheres*
- [TBuffer3DTubeSeg](@ref) - angle tube segment
- [TBuffer3DCutTube](@ref) - angle tube segment with plane cut ends.

OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.

Anyone is free to add new [TBuffer3D](@ref) classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.

BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.

As we need to support orientated (rotated) bounding boxes, [TBuffer3D](@ref) requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box.

## Master/Local Reference Frames

The Core section of [TBuffer3D](@ref) contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local_ or master (world frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.

If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.

### Logical & Physical Objects

There are two cases of object addition:

- Add this object as a single independent entity in the world reference frame.
- Add a physical placement (copy) of this logical object (described in local_ reference frame).

The second case is very typical in geometry packages, GEANT4, where we have very large number repeated placements of relatively few logical (unique) shapes. Some viewers (OpenGL only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of [TBuffer3D](@ref). If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching with considerable performance gains in these cases.

For this to work correctly the logical object in must be described in [TBuffer3D](@ref) in the local_ reference frame, complete with the local_/master translation. The viewer indicates this through the interface method 

    PreferLocalFrame()

(C++ version of the code)

If this returns kTRUE you can make repeated calls to [AddObject()](@ref), with [TBuffer3D](@ref) containing the same fID, and different fLocalMaster placements.

For viewers supporting logical/physical objects, the [TBuffer3D](@ref) content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.

As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer.

## Scene Rebuilds

It should be understood that AddObject is not an explicit command to the viewer

- it may for various reasons decide to ignore it:
- It already has the object internally cached .
- The object falls outside some 'interest' limits of the viewer camera.
- The object is too small to be worth drawing.

In all these cases [AddObject()](@ref) returns kNone, as it does for successful addition, simply indicating it does not require you to provide further information about this object. You should not try to make any assumptions about what the viewer did with it.

This enables the viewer to be connected to a client which sends potentially millions of objects, and only accept those that are of interest at a certain time, caching the relatively small number of CPU/memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a [TPad](@ref) repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached [TPad](@ref) object - hence the reason for putting all publishing to the viewer in the attached pad objects [Paint()](@ref) method. We will likely remove this requirement in the future, indicating the rebuild request via a normal [ROOT](@ref) signal, which the client can detect.

## Physical IDs

[TVirtualViewer3D](@ref) provides for two methods of object addition:virtual Int_t AddObject(const [TBuffer3D](@ref) & buffer, Bool_t * addChildren = 0)

    virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0)

(C++ version of the code)

If you use the first (simple) case a viewer using logical/physical pairs will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds.

## Child Objects

In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both [AddObject()](@ref) methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding.

## Recycling TBuffer3D

Once add [AddObject()](@ref) has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable.

Related functions: [`AddCompositeOp`](@ref), [`AddObject`](@ref), [`BeginScene`](@ref), [`BuildingScene`](@ref), [`CanLoopOnPrimitives`](@ref), [`CloseComposite`](@ref), [`DrawViewer`](@ref), [`EndScene`](@ref), [`IsA`](@ref), [`ObjectPaint`](@ref), [`OpenComposite`](@ref), [`PadPaint`](@ref), [`PreferLocalFrame`](@ref), [`PrintObjects`](@ref), [`ResetCamerasAfterNextUpdate`](@ref), [`ResetCameras`](@ref), [`SelectObject`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualViewer3D!Class_Name`](@ref), [`TVirtualViewer3D!Class_Version`](@ref), [`TVirtualViewer3D!Class`](@ref), [`TVirtualViewer3D!DeclFileName`](@ref), [`TVirtualViewer3D!Viewer3D`](@ref)
""" TVirtualViewer3D

# Wrapper of TVirtualPadPainter
@trydoc raw"""
    ROOT.TVirtualPadPainter

To make it possible to use GL for 2D graphic in a TPad/TCanvas.

[TVirtualPadPainter](@ref) interface must be used instead of [TVirtualX](@ref). Internally, non-GL implementation *should* delegate all calls to gVirtualX, GL implementation will delegate part of calls to gVirtualX, and has to implement some of the calls from the scratch.

Related functions: [`ClearDrawable`](@ref), [`CopyDrawable`](@ref), [`CreateDrawable`](@ref), [`DestroyDrawable`](@ref), [`DrawBox`](@ref), [`DrawFillArea`](@ref), [`DrawLineNDC`](@ref), [`DrawLine`](@ref), [`DrawPixels`](@ref), [`DrawPolyLineNDC`](@ref), [`DrawPolyLine`](@ref), [`DrawPolyMarker`](@ref), [`DrawTextNDC`](@ref), [`DrawText`](@ref), [`GetFillColor`](@ref), [`GetFillStyle`](@ref), [`GetLineColor`](@ref), [`GetLineStyle`](@ref), [`GetLineWidth`](@ref), [`GetTextAlign`](@ref), [`GetTextAngle`](@ref), [`GetTextColor`](@ref), [`GetTextFont`](@ref), [`GetTextMagnitude`](@ref), [`GetTextSize`](@ref), [`InitPainter`](@ref), [`InvalidateCS`](@ref), [`IsA`](@ref), [`IsTransparent`](@ref), [`LockPainter`](@ref), [`SaveImage`](@ref), [`SelectDrawable`](@ref), [`SetFillColor`](@ref), [`SetFillStyle`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetOpacity`](@ref), [`SetTextAlign`](@ref), [`SetTextAngle`](@ref), [`SetTextColor`](@ref), [`SetTextFont`](@ref), [`SetTextSizePixels`](@ref), [`SetTextSize`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualPadPainter!Class_Name`](@ref), [`TVirtualPadPainter!Class_Version`](@ref), [`TVirtualPadPainter!Class`](@ref), [`TVirtualPadPainter!DeclFileName`](@ref), [`TVirtualPadPainter!PadPainter`](@ref)
""" TVirtualPadPainter

# Wrapper of TPickerStackGuard
@trydoc raw"""
    ROOT.TPickerStackGuard





Related functions: [`TPickerStackGuard`](@ref)
""" TPickerStackGuard

# Wrapper of TVirtualPerfStats
@trydoc raw"""
    ROOT.TVirtualPerfStats

Provides the interface for the PROOF internal performance measurement and event tracing.



Related functions: [`FileEvent`](@ref), [`FileOpenEvent`](@ref), [`FileReadEvent`](@ref), [`GetBytesRead`](@ref), [`GetNumEvents`](@ref), [`IsA`](@ref), [`PacketEvent`](@ref), [`PrintBasketInfo`](@ref), [`RateEvent`](@ref), [`SetBytesRead`](@ref), [`SetLoadedMiss`](@ref), [`SetLoaded`](@ref), [`SetMissed`](@ref), [`SetNumEvents`](@ref), [`SetUsed`](@ref), [`SimpleEvent`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualPerfStats!Class_Name`](@ref), [`TVirtualPerfStats!Class_Version`](@ref), [`TVirtualPerfStats!Class`](@ref), [`TVirtualPerfStats!CurrentPerfStats`](@ref), [`TVirtualPerfStats!DeclFileName`](@ref), [`TVirtualPerfStats!EventType`](@ref), [`UnzipEvent`](@ref), [`UpdateBranchIndices`](@ref)
""" TVirtualPerfStats

# Wrapper of TBranch
@trydoc raw"""
    ROOT.TBranch

A [TTree](@ref) is a list of TBranches.

A [TBranch](@ref) supports:

- The list of [TLeaf](@ref) describing this branch.
- The list of [TBasket](@ref) (branch buffers).

See [TBranch](@ref) structure in [TTree](@ref).

See also specialized branches:

- [TBranchObject](@ref) in case the branch is one object
- [TBranchClones](@ref) in case the branch is an array of clone objects

Related functions: [`AddBasket`](@ref), [`AddLastBasket`](@ref), [`BackFill`](@ref), [`Browse`](@ref), [`ClassDefOverride`](@ref), [`DeleteBaskets`](@ref), [`DropBaskets`](@ref), [`ExpandBasketArrays`](@ref), [`FillImpl`](@ref), [`Fill`](@ref), [`FindBranch`](@ref), [`FindLeaf`](@ref), [`FlushBaskets`](@ref), [`FlushOneBasket`](@ref), [`GetAddress`](@ref), [`GetBasketBytes`](@ref), [`GetBasketEntry`](@ref), [`GetBasketSeek`](@ref), [`GetBasketSize`](@ref), [`GetBasket`](@ref), [`GetBrowsables`](@ref), [`GetBulkRead`](@ref), [`GetClassName`](@ref), [`GetCompressionAlgorithm`](@ref), [`GetCompressionLevel`](@ref), [`GetCompressionSettings`](@ref), [`GetDirectory`](@ref), [`GetEntries`](@ref), [`GetEntryExport`](@ref), [`GetEntryNumber`](@ref), [`GetEntryOffsetLen`](@ref), [`GetEntry`](@ref), [`GetEvent`](@ref), [`GetExpectedType`](@ref), [`GetFileName`](@ref), [`GetFile`](@ref), [`GetFirstEntry`](@ref), [`GetFullName`](@ref), [`GetIOFeatures`](@ref), [`GetIconName`](@ref), [`GetLeaf`](@ref), [`GetListOfBaskets`](@ref), [`GetListOfBranches`](@ref), [`GetListOfLeaves`](@ref), [`GetMakeClass`](@ref), [`GetMaxBaskets`](@ref), [`GetMother`](@ref), [`GetNleaves`](@ref), [`GetOffset`](@ref), [`GetReadBasket`](@ref), [`GetReadEntry`](@ref), [`GetRow`](@ref), [`GetSplitLevel`](@ref), [`GetSubBranch`](@ref), [`GetTotBytes`](@ref), [`GetTotalSize`](@ref), [`GetTransientBuffer`](@ref), [`GetTree`](@ref), [`GetWriteBasket`](@ref), [`GetZipBytes`](@ref), [`IsAutoDelete`](@ref), [`IsFolder`](@ref), [`KeepCircular`](@ref), [`LoadBaskets`](@ref), [`PrintCacheInfo`](@ref), [`Print`](@ref), [`ReadBasket`](@ref), [`Refresh`](@ref), [`ResetAddress`](@ref), [`ResetAfterMerge`](@ref), [`ResetReadEntry`](@ref), [`Reset`](@ref), [`SetAddress`](@ref), [`SetAutoDelete`](@ref), [`SetBasketSize`](@ref), [`SetBufferAddress`](@ref), [`SetCompressionAlgorithm`](@ref), [`SetCompressionLevel`](@ref), [`SetCompressionSettings`](@ref), [`SetEntries`](@ref), [`SetEntryOffsetLen`](@ref), [`SetFile`](@ref), [`SetFirstEntry`](@ref), [`SetIOFeatures`](@ref), [`SetMakeClass`](@ref), [`SetObject`](@ref), [`SetOffset`](@ref), [`SetStatus`](@ref), [`SetTree`](@ref), [`SetupAddresses`](@ref), [`SupportsBulkRead`](@ref), [`TBranch!ResetCount`](@ref), [`TBranch`](@ref), [`UpdateAddress`](@ref), [`UpdateFile`](@ref)
""" TBranch

# Wrapper of TVirtualPS
@trydoc raw"""
    ROOT.TVirtualPS

[TVirtualPS](@ref) is an abstract interface to Postscript, PDF, SVG.

TeX etc... drivers

Related functions: [`CellArrayBegin`](@ref), [`CellArrayEnd`](@ref), [`CellArrayFill`](@ref), [`Close`](@ref), [`DrawBox`](@ref), [`DrawFrame`](@ref), [`DrawPS`](@ref), [`DrawPolyMarker`](@ref), [`GetStream`](@ref), [`GetText`](@ref), [`GetType`](@ref), [`IsA`](@ref), [`NewPage`](@ref), [`Open`](@ref), [`PrintFast`](@ref), [`PrintRaw`](@ref), [`PrintStr`](@ref), [`SetColor`](@ref), [`SetStream`](@ref), [`SetType`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualPS!Class_Name`](@ref), [`TVirtualPS!Class_Version`](@ref), [`TVirtualPS!Class`](@ref), [`TVirtualPS!DeclFileName`](@ref), [`TVirtualPS`](@ref), [`WriteInteger`](@ref), [`WriteReal`](@ref)
""" TVirtualPS

# Wrapper of TVirtualTableInterface
@trydoc raw"""
    ROOT.TVirtualTableInterface





Related functions: [`GetColumnHeader`](@ref), [`GetNColumns`](@ref), [`GetNRows`](@ref), [`GetRowHeader`](@ref), [`GetValueAsString`](@ref), [`GetValue`](@ref), [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualTableInterface!Class_Name`](@ref), [`TVirtualTableInterface!Class_Version`](@ref), [`TVirtualTableInterface!Class`](@ref), [`TVirtualTableInterface!DeclFileName`](@ref), [`TVirtualTableInterface`](@ref)
""" TVirtualTableInterface

# Wrapper of TVirtualX
@trydoc raw"""
    ROOT.TVirtualX

Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...).

An instance of [TVirtualX](@ref) itself defines a batch interface to the graphics system.

Related functions: [`AddPixmap`](@ref), [`AddWindow`](@ref), [`AllocColor`](@ref), [`BeginModalSessionFor`](@ref), [`Bell`](@ref), [`ChangeActivePointerGrab`](@ref), [`ChangeGC`](@ref), [`ChangeProperties`](@ref), [`ChangeProperty`](@ref), [`ChangeWindowAttributes`](@ref), [`CheckEvent`](@ref), [`ClearArea`](@ref), [`ClearWindow`](@ref), [`CloseDisplay`](@ref), [`ClosePixmap`](@ref), [`CloseWindow`](@ref), [`ConvertPrimarySelection`](@ref), [`ConvertSelection`](@ref), [`CopyArea`](@ref), [`CopyGC`](@ref), [`CopyPixmap`](@ref), [`CreateBitmap`](@ref), [`CreateCursor`](@ref), [`CreateGC`](@ref), [`CreateImage`](@ref), [`CreateOpenGLContext`](@ref), [`CreateOpenGLWindow`](@ref), [`CreatePictureFromData`](@ref), [`CreatePictureFromFile`](@ref), [`CreatePixmapFromData`](@ref), [`CreatePixmap`](@ref), [`CreateRegion`](@ref), [`CreateWindow`](@ref), [`DeleteFont`](@ref), [`DeleteGC`](@ref), [`DeleteImage`](@ref), [`DeleteOpenGLContext`](@ref), [`DeletePictureData`](@ref), [`DeletePixmap`](@ref), [`DeleteProperty`](@ref), [`DestroyRegion`](@ref), [`DestroySubwindows`](@ref), [`DestroyWindow`](@ref), [`DispatchClientMessage`](@ref), [`DisplayName`](@ref), [`DrawBox`](@ref), [`DrawCellArray`](@ref), [`DrawFillArea`](@ref), [`DrawLine`](@ref), [`DrawPolyLine`](@ref), [`DrawPolyMarker`](@ref), [`DrawRectangle`](@ref), [`DrawSegments`](@ref), [`DrawString`](@ref), [`DrawText`](@ref), [`EmptyRegion`](@ref), [`EqualRegion`](@ref), [`EventsPending`](@ref), [`ExecCommand`](@ref), [`FillPolygon`](@ref), [`FillRectangle`](@ref), [`FindRWindow`](@ref), [`FlushOpenGLBuffer`](@ref), [`FreeColor`](@ref), [`FreeFontNames`](@ref), [`FreeFontStruct`](@ref), [`GetCharacterUp`](@ref), [`GetColorBits`](@ref), [`GetColormap`](@ref), [`GetCurrentOpenGLContext`](@ref), [`GetCurrentWindow`](@ref), [`GetDefaultRootWindow`](@ref), [`GetDepth`](@ref), [`GetDisplay`](@ref), [`GetDoubleBuffer`](@ref), [`GetDrawMode`](@ref), [`GetFontAscent`](@ref), [`GetFontDescent`](@ref), [`GetFontHandle`](@ref), [`GetFontProperties`](@ref), [`GetFontStruct`](@ref), [`GetGCFont`](@ref), [`GetGCValues`](@ref), [`GetGeometry`](@ref), [`GetImageSize`](@ref), [`GetInputFocus`](@ref), [`GetNativeEvent`](@ref), [`GetOpenGLScalingFactor`](@ref), [`GetParent`](@ref), [`GetPasteBuffer`](@ref), [`GetPixel`](@ref), [`GetPlanes`](@ref), [`GetPrimarySelectionOwner`](@ref), [`GetProperty`](@ref), [`GetRGB`](@ref), [`GetRegionBox`](@ref), [`GetScreen`](@ref), [`GetTextExtent`](@ref), [`GetTextMagnitude`](@ref), [`GetVisual`](@ref), [`GetWindowAttributes`](@ref), [`GetWindowID`](@ref), [`GetWindowSize`](@ref), [`GrabButton`](@ref), [`GrabKey`](@ref), [`GrabPointer`](@ref), [`HasTTFonts`](@ref), [`IconifyWindow`](@ref), [`InitWindow`](@ref), [`Init`](@ref), [`InternAtom`](@ref), [`IntersectRegion`](@ref), [`IsA`](@ref), [`IsCmdThread`](@ref), [`IsDNDAware`](@ref), [`KeysymToKeycode`](@ref), [`ListFonts`](@ref), [`LoadQueryFont`](@ref), [`LookupString`](@ref), [`LowerWindow`](@ref), [`MakeOpenGLContextCurrent`](@ref), [`MapGCFont`](@ref), [`MapRaised`](@ref), [`MapSubwindows`](@ref), [`MapWindow`](@ref), [`MoveResizeWindow`](@ref), [`MoveWindow`](@ref), [`NeedRedraw`](@ref), [`NextEvent`](@ref), [`OpenDisplay`](@ref), [`OpenPixmap`](@ref), [`ParseColor`](@ref), [`PointInRegion`](@ref), [`PolygonRegion`](@ref), [`PutImage`](@ref), [`PutPixel`](@ref), [`QueryColor`](@ref), [`QueryPointer`](@ref), [`RaiseWindow`](@ref), [`ReadGIF`](@ref), [`ReadPictureDataFromFile`](@ref), [`RemoveWindow`](@ref), [`ReparentWindow`](@ref), [`RequestLocator`](@ref), [`RequestString`](@ref), [`RescaleWindow`](@ref), [`ResizePixmap`](@ref), [`ResizeWindow`](@ref), [`ScreenWidthMM`](@ref), [`SelectInput`](@ref), [`SelectPixmap`](@ref), [`SelectWindow`](@ref), [`SendEvent`](@ref), [`SetCharacterUp`](@ref), [`SetClassHints`](@ref), [`SetClipOFF`](@ref), [`SetClipRectangles`](@ref), [`SetClipRegion`](@ref), [`SetCursor`](@ref), [`SetDNDAware`](@ref), [`SetDashes`](@ref), [`SetDoubleBufferOFF`](@ref), [`SetDoubleBufferON`](@ref), [`SetDoubleBuffer`](@ref), [`SetDrawMode`](@ref), [`SetFillColor`](@ref), [`SetFillStyle`](@ref), [`SetForeground`](@ref), [`SetIconName`](@ref), [`SetIconPixmap`](@ref), [`SetInputFocus`](@ref), [`SetKeyAutoRepeat`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineType`](@ref), [`SetLineWidth`](@ref), [`SetMWMHints`](@ref), [`SetMarkerColor`](@ref), [`SetMarkerSize`](@ref), [`SetMarkerStyle`](@ref), [`SetOpacity`](@ref), [`SetPrimarySelectionOwner`](@ref), [`SetRGB`](@ref), [`SetSelectionOwner`](@ref), [`SetTextAlign`](@ref), [`SetTextColor`](@ref), [`SetTextFont`](@ref), [`SetTextMagnitude`](@ref), [`SetTextSize`](@ref), [`SetTypeList`](@ref), [`SetWMPosition`](@ref), [`SetWMSizeHints`](@ref), [`SetWMSize`](@ref), [`SetWMState`](@ref), [`SetWMTransientHint`](@ref), [`SetWindowBackgroundPixmap`](@ref), [`SetWindowBackground`](@ref), [`SetWindowName`](@ref), [`ShapeCombineMask`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`SubtractRegion`](@ref), [`SupportsExtension`](@ref), [`Sync`](@ref), [`TVirtualX!Class_Name`](@ref), [`TVirtualX!Class_Version`](@ref), [`TVirtualX!Class`](@ref), [`TVirtualX!DeclFileName`](@ref), [`TVirtualX!Instance`](@ref), [`TVirtualX`](@ref), [`TextWidth`](@ref), [`TranslateCoordinates`](@ref), [`UnionRectWithRegion`](@ref), [`UnionRegion`](@ref), [`UnmapWindow`](@ref), [`UpdateWindow`](@ref), [`Update`](@ref), [`WMDeleteNotify`](@ref), [`Warp`](@ref), [`WriteGIF`](@ref), [`WritePixmap`](@ref), [`XorRegion`](@ref)
""" TVirtualX

# Wrapper of TClassTable
@trydoc raw"""
    ROOT.TClassTable

This class registers for all classes their name, id and dictionary function in a hash table.

Classes are automatically added by the ctor of a special init class when a global_ of this init class is initialized when the program starts (see the ClassImp macro).

All functions in [TClassTable](@ref) are thread-safe.

Related functions: [`Classes`](@ref), [`Print`](@ref), [`TClassTable!AddAlternate`](@ref), [`TClassTable!Add`](@ref), [`TClassTable!At`](@ref), [`TClassTable!Check`](@ref), [`TClassTable!GetDictNorm`](@ref), [`TClassTable!GetDict`](@ref), [`TClassTable!GetID`](@ref), [`TClassTable!GetPragmaBits`](@ref), [`TClassTable!GetProtoNorm`](@ref), [`TClassTable!GetProto`](@ref), [`TClassTable!Init`](@ref), [`TClassTable!Next`](@ref), [`TClassTable!PrintTable`](@ref), [`TClassTable!RemoveAlternate`](@ref), [`TClassTable!Remove`](@ref), [`TClassTable!Terminate`](@ref)
""" TClassTable

# Wrapper of TArrayL
@trydoc raw"""
    ROOT.TArrayL

Array of longs (32 or 64 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayL`](@ref), [`assign`](@ref)
""" TArrayL

# Wrapper of TBtree
@trydoc raw"""
    ROOT.TBtree

B-tree class.

[TBtree](@ref) inherits from the [TSeqCollection](@ref) ABC.

## B-tree Implementation notes

This implements B-trees with several refinements. Most of them can be found in Knuth Vol 3, but some were developed to adapt to restrictions imposed by C++. First, a restatement of Knuth's properties that a B-tree must satisfy, assuming we make the enhancement he suggests in the paragraph at the bottom of page 476. Instead of storing null pointers to non-existent nodes (which Knuth calls the leaves) we utilize the space to store keys. Therefore, what Knuth calls level (l-1) is the bottom of our tree, and we call the nodes at this level LeafNodes. Other nodes are called InnerNodes. The other enhancement we have adopted is in the paragraph at the bottom of page 477: overflow control.

The following are modifications of Knuth's properties on page 478:

1. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.
2. Every LeafNode has at most 2*(Order+1) keys.
3. An InnerNode with k keys has k+1 sub-trees.
4. Every InnerNode that is not the root has at least InnerLowWaterMark keys.
5. Every LeafNode that is not the root has at least LeafLowWaterMark keys.
6. If the root is a LeafNode, it has at least one key.
7. If the root is an InnerNode, it has at least one key and two sub-trees.
8. All LeafNodes are the same distance from the root as all the other LeafNodes.
9. For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains all keys < n[i].key, and sub-tree n[i].tree contains all keys >= n[i].key.
10. Order is at least 3.

The values of InnerLowWaterMark and LeafLowWaterMark may actually be set by the user when the tree is initialized, but currently they are set automatically to: 

    InnerLowWaterMark = ceiling(Order/2)
    LeafLowWaterMark  = Order - 1

(C++ version of the code)

 If the tree is only filled, then all the nodes will be at least 2/3 full. They will almost all be exactly 2/3 full if the elements are added to the tree in order (either increasing or decreasing). [Knuth says McCreight's experiments showed almost 100% memory utilization. I don't see how that can be given the algorithms that Knuth gives. McCreight must have used a different scheme for balancing. [No, he used a different scheme for splitting: he did a two-way split instead of the three way split as we do here. Which means that McCreight does better on insertion of ordered data, but we should do better on insertion of random data.]]

It must also be noted that B-trees were designed for DISK access algorithms, not necessarily in-memory sorting, as we intend it to be used here. However, if the order is kept small (< 6?) any inefficiency is negligible for in-memory sorting. Knuth points out that balanced trees are actually preferable for memory sorting. I'm not sure that I believe this, but it's interesting. Also, deleting elements from balanced binary trees, being beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees are good enough.

A B-tree is declared to be of a certain ORDER (3 by default). This number determines the number of keys contained in any interior node of the tree. Each interior node will contain ORDER keys, and therefore ORDER+1 pointers to sub-trees. The keys are numbered and indexed 1 to ORDER while the pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the sub-tree of all elements that are less than key[1]. Ptr[1] points to the sub-tree that contains all the elements greater than key[1] and less than key[2]. etc. The array of pointers and keys is allocated as ORDER+1 pairs of keys and nodes, meaning that one key field (key[0]) is not used and therefore wasted. Given that the number of interior nodes is small, that this waste allows fewer cases of special code, and that it is useful in certain of the methods, it was felt to be a worthwhile waste.

The size of the exterior nodes (leaf nodes) does not need to be related to the size of the interior nodes at all. Since leaf nodes contain only keys, they may be as large or small as we like independent of the size of the interior nodes. For no particular reason other than it seems like a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage of keeping the size of the leaf and interior arrays the same, so that if we find allocation and de-allocation of these arrays expensive, we can modify their allocation to use a garbage ring, or something.

Both of these numbers will be run-time constants associated with each tree (each tree at run-time can be of a different order). The variable "order" is the order of the tree, and the inclusive upper limit on the indices of the keys in the interior nodes. The variable "order2" is the inclusive upper limit on the indices of the leaf nodes, and is designed 

    (1) to keep the sizes of the two kinds of nodes the same;
    (2) to keep the expressions involving the arrays of keys looking
        somewhat the same:   lower limit        upper limit
          for inner nodes:        1                order
          for leaf  nodes:        0                order2
        Remember that index 0 of the inner nodes is special.

(C++ version of the code)

 Currently, order2 = 2*(order+1). 

    Picture: (also see Knuth Vol 3 pg 478)
              +--+--+--+--+--+--...
              |  |  |  |  |  |
    parent--->|  |     |     |
              |  |     |     |
              +*-+*-+*-+--+--+--...
               |  |  |
          +----+  |  +-----+
          |       +-----+  |
          V             |  V
          +----------+  |  +----------+
          |          |  |  |          |
    this->|          |  |  |          |<--sib
          +----------+  |  +----------+
                        V
                       data

(C++ version of the code)

 It is conceptually VERY convenient to think of the data as being the very first element of the sib node. Any primitive that tells sib to perform some action on n nodes should include this 'hidden' element. For InnerNodes, the hidden element has (physical) index 0 in the array, and in LeafNodes, the hidden element has (virtual) index -1 in the array. Therefore, there are two 'size' primitives for nodes: 

    Psize       - the physical size: how many elements are contained in the
                  array in the node.
    Vsize       - the 'virtual' size; if the node is pointed to by
                  element 0 of the parent node, then Vsize == Psize;
                  otherwise the element in the parent item that points to this
                  node 'belongs' to this node, and Vsize == Psize+1;

(C++ version of the code)

 Parent nodes are always InnerNodes.

These are the primitive operations on Nodes: 

    Append(elt)     - adds an element to the theend of the array of elements in a
                      node.  It must never be called where appending the element
                      would fill the node.
    Split()         - divide a node in two, and create two new nodes.
    SplitWith(sib)  - create a third node between this node and the sib node,
                      divvying up the elements of their arrays.
    PushLeft(n)     - move n elements into the left sibling
    PushRight(n)    - move n elements into the right sibling
    BalanceWithRight() - even up the number of elements in the two nodes.
    BalanceWithLeft()  - ditto

(C++ version of the code)

 To allow this implementation of btrees to also be an implementation of sorted arrays/lists, the overhead is included to allow O(log n) access of elements by their rank ('give me the 5th largest element'). Therefore, each Item keeps track of the number of keys in and below it in the tree (remember, each item's tree is all keys to the RIGHT of the item's own key). 

    [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]
       4  1 1 1 1   4   1 1 1   5   1  1  1  1      7  3   1  1  1    4    1  1  1

(C++ version of the code)

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Before`](@ref), [`Clear`](@ref), [`Delete`](@ref), [`FindObject`](@ref), [`First`](@ref), [`GetObjectRef`](@ref), [`Last`](@ref), [`MakeIterator`](@ref), [`Order`](@ref), [`Rank`](@ref), [`Remove`](@ref), [`TBtree`](@ref)
""" TBtree

# Wrapper of TBtNode
@trydoc raw"""
    ROOT.TBtNode

Abstract base class (ABC) of a [TBtree](@ref) node.



Related functions: [`Add`](@ref), [`Base.getindex`](@ref), [`FindRank`](@ref), [`FirstLeafNode`](@ref), [`Found`](@ref), [`GetParentTree`](@ref), [`LastLeafNode`](@ref), [`NofKeys`](@ref), [`Remove`](@ref), [`Split`](@ref), [`TBtNode`](@ref)
""" TBtNode

# Wrapper of TBtInnerNode
@trydoc raw"""
    ROOT.TBtInnerNode

Inner node of a [TBtree](@ref).



Related functions: [`AddElt`](@ref), [`Add`](@ref), [`AppendFrom`](@ref), [`Append`](@ref), [`BalanceWithLeft`](@ref), [`BalanceWithRight`](@ref), [`BalanceWith`](@ref), [`Base.getindex`](@ref), [`DecNofKeys`](@ref), [`DecrNofKeys`](@ref), [`FindRankUp`](@ref), [`FindRank`](@ref), [`FirstLeafNode`](@ref), [`Found`](@ref), [`GetItem`](@ref), [`GetKey`](@ref), [`GetNofKeys`](@ref), [`GetTree`](@ref), [`IncNofKeys`](@ref), [`IncrNofKeys`](@ref), [`IndexOf`](@ref), [`InformParent`](@ref), [`IsAlmostFull`](@ref), [`IsFull`](@ref), [`IsLow`](@ref), [`LastLeafNode`](@ref), [`MaxIndex`](@ref), [`MaxPsize`](@ref), [`MergeWithRight`](@ref), [`NofKeys`](@ref), [`Psize`](@ref), [`PushLeft`](@ref), [`PushRight`](@ref), [`RemoveItem`](@ref), [`Remove`](@ref), [`SetItem`](@ref), [`SetKey`](@ref), [`SetNofKeys`](@ref), [`SetTree`](@ref), [`ShiftLeft`](@ref), [`SplitWith`](@ref), [`Split`](@ref), [`TBtInnerNode`](@ref), [`Vsize`](@ref)
""" TBtInnerNode

# Wrapper of TBtLeafNode
@trydoc raw"""
    ROOT.TBtLeafNode

Leaf node of a [TBtree](@ref).



Related functions: [`Add`](@ref), [`AppendFrom`](@ref), [`Append`](@ref), [`BalanceWithLeft`](@ref), [`BalanceWithRight`](@ref), [`BalanceWith`](@ref), [`Base.getindex`](@ref), [`FindRank`](@ref), [`FirstLeafNode`](@ref), [`Found`](@ref), [`GetKey`](@ref), [`IndexOf`](@ref), [`IsAlmostFull`](@ref), [`IsFull`](@ref), [`IsLow`](@ref), [`LastLeafNode`](@ref), [`MaxIndex`](@ref), [`MaxPsize`](@ref), [`MergeWithRight`](@ref), [`NofKeys`](@ref), [`Psize`](@ref), [`PushLeft`](@ref), [`PushRight`](@ref), [`RemoveItem`](@ref), [`Remove`](@ref), [`SetKey`](@ref), [`ShiftLeft`](@ref), [`SplitWith`](@ref), [`Split`](@ref), [`TBtLeafNode`](@ref), [`Vsize`](@ref)
""" TBtLeafNode

# Wrapper of TBtItem
@trydoc raw"""
    ROOT.TBtItem

Item stored in inner nodes of a [TBtree](@ref).



Related functions: [`TBtItem`](@ref)
""" TBtItem

# Wrapper of TBtreeIter
@trydoc raw"""
    ROOT.TBtreeIter

Iterator of btree.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TBtreeIter`](@ref), [`assign`](@ref)
""" TBtreeIter

# Wrapper of TArrayD
@trydoc raw"""
    ROOT.TArrayD

Array of doubles (64 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayD`](@ref), [`assign`](@ref)
""" TArrayD

# Wrapper of TArrayF
@trydoc raw"""
    ROOT.TArrayF

Array of floats (32 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayF`](@ref), [`assign`](@ref)
""" TArrayF

# Wrapper of TRefArray
@trydoc raw"""
    ROOT.TRefArray

An array of references to TObjects.

The array expands automatically when objects are added (shrinking can be done by hand using [Expand()](@ref) )

The [TRefArray](@ref) can be filled with: 

    array.Add(obj)
    array.AddAt(obj,i)
    but not array[i] = obj  !!!

(C++ version of the code)

 The array elements can be retrieved with: 

    TObject *obj = array.At(i);

(C++ version of the code)

 By default the [TRefArray](@ref) 'points' to the current process and can only receive object that have been created in this process. To point the [TRefArray](@ref) to a different process do: 

    TRefArray array( processId );

(C++ version of the code)

 For example, if 'obj' is an instance that was created in the different process and you do: 

    TRefArray array( TProcessID!GetProcessWithUID( obj ) );

(C++ version of the code)

 Then 

    array.Add(obj);

(C++ version of the code)

 is correct (obj comes from the process the array is pointed to while 

    TObject *nobj = new TObject;
    array.Add(nobj);

(C++ version of the code)

 is incorrect since 'nobj' was created in a different process than the one the array is pointed to. In this case you will see error message: 

    Error in <TRefArray!AddAtAndExpand>: The object at 0x... is not
    registered in the process the TRefArray point to
    (pid = ProcessID../....)

(C++ version of the code)

 When a [TRefArray](@ref) is Streamed, only the pointer unique id is written, not the referenced object. [TRefArray](@ref) may be assigned to different branches of one Tree or several Trees. The branch containing the [TRefArray](@ref) can be read before or after the array (eg [TClonesArray](@ref), STL vector,..) of the referenced objects.

See an example in $ROOTSYS/test/Event.h

### RESTRICTIONS when using TRefArray

- Elements in a [TRefArray](@ref) cannot point to a [TFile](@ref) or [TDirectory](@ref).
- All elements of a [TRefArray](@ref) must be set in the same process, In particular, one cannot modify some elements of the array in a different process.

Use an array of [TRef](@ref) when one of the above restrictions is met.

The number of [TRef](@ref) handled by a single process id is limited to 16777215 (see [TRef](@ref) for more detail). When the [TProcessID](@ref) is full (has seen 16777215 objects), we switch to new one [TProcessID](@ref) maximum 65535 including the TProcessIDs read from file). However [TRefArray](@ref) can not switch to new [TProcessID](@ref) if they already contain objects.

When the [TProcessID](@ref) has been switched due to overflow and an new object is added to an existing, empty [TRefArray](@ref), you will see:

    Warning in <TRefArray!AddAtAndExpand>: The ProcessID for the 0x5f83819e8 has been switched to ProcessID4/6c89f37e-8259-11e2-9717-166ee183beef:4

(C++ version of the code)

 If the [TRefArray](@ref) was not empty, you will see:

    Error in <TRefArray!AddAtAndExpand>: The object at %p can not be registered in the process the TRefArray points to (pid = ProcessID4/6c89f37e-8259-11e2-9717-166ee183beef) because the ProcessID has too many objects and the TRefArray already contains other objects.

(C++ version of the code)

 When running out of TProcessIds, you will see:

    Warning in <TProcessID!AddProcessID>: Maximum number of TProcessID (65535) is almost reached (one left).  TRef will stop being functional when the limit is reached.
    Fatal in <TProcessID!AddProcessID>: Maximum number of TProcessID (65535) has been reached.  TRef are not longer functional.

(C++ version of the code)

Related functions: [`AddAfter`](@ref), [`AddAtAndExpand`](@ref), [`AddAtFree`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Before`](@ref), [`BinarySearch`](@ref), [`Clear`](@ref), [`Compress`](@ref), [`Delete`](@ref), [`Expand`](@ref), [`First`](@ref), [`GetEntriesFast`](@ref), [`GetEntries`](@ref), [`GetLast`](@ref), [`GetObjectRef`](@ref), [`GetPID`](@ref), [`GetUID`](@ref), [`IndexOf`](@ref), [`IsEmpty`](@ref), [`Last`](@ref), [`LowerBound`](@ref), [`MakeIterator`](@ref), [`RemoveAt`](@ref), [`Remove`](@ref), [`SetLast`](@ref), [`Sort`](@ref), [`TRefArray`](@ref), [`assign`](@ref)
""" TRefArray

# Wrapper of TRefArrayIter
@trydoc raw"""
    ROOT.TRefArrayIter

Iterator of object array.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TRefArrayIter`](@ref), [`assign`](@ref)
""" TRefArrayIter

# Wrapper of TArrayC
@trydoc raw"""
    ROOT.TArrayC

Array of chars or bytes (8 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayC`](@ref), [`assign`](@ref)
""" TArrayC

# Wrapper of TExMap
@trydoc raw"""
    ROOT.TExMap

This class stores a (key,value) pair using an external hash.

The (key,value) are Long64_t's and therefore can contain object pointers or any longs. The map uses an open addressing hashing method (linear probing).

Related functions: [`AddAt`](@ref), [`Add`](@ref), [`Capacity`](@ref), [`Delete`](@ref), [`Expand`](@ref), [`GetSize`](@ref), [`GetValue`](@ref), [`Remove`](@ref), [`TExMap`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TExMap

# Wrapper of TExMapIter
@trydoc raw"""
    ROOT.TExMapIter





Related functions: [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TExMapIter`](@ref), [`assign`](@ref)
""" TExMapIter

# Wrapper of TArrayS
@trydoc raw"""
    ROOT.TArrayS

Array of shorts (16 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayS`](@ref), [`assign`](@ref)
""" TArrayS

# Wrapper of TVirtualCollectionProxy
@trydoc raw"""
    ROOT.TVirtualCollectionProxy

Defines a common interface to inspect/change the contents of an object that represents a collection.

Specifically, an object of a class that derives from [TVirtualCollectionProxy](@ref) relays accesses to any object that matches the proxied collection type. The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and (ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`. [TVirtualCollectionProxy](@ref) objects are stateful; in particular, many functions require to set the object to operate on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience. A collection proxy for a given class can be permanently set using `TClass!CopyCollectionProxy()`. The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.

Related functions: [`Allocate`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Clear`](@ref), [`Commit`](@ref), [`DeleteArray`](@ref), [`Destructor`](@ref), [`Generate`](@ref), [`GetCollectionClass`](@ref), [`GetCollectionType`](@ref), [`GetConversionReadMemberWiseActions`](@ref), [`GetFunctionCopyIterator`](@ref), [`GetFunctionCreateIterators`](@ref), [`GetFunctionDeleteIterator`](@ref), [`GetFunctionDeleteTwoIterators`](@ref), [`GetFunctionNext`](@ref), [`GetIncrement`](@ref), [`GetProperties`](@ref), [`GetReadMemberWiseActions`](@ref), [`GetType`](@ref), [`GetValueClass`](@ref), [`GetWriteMemberWiseActions`](@ref), [`HasPointers`](@ref), [`Insert`](@ref), [`NewArray`](@ref), [`NewObjectArray`](@ref), [`NewObject`](@ref), [`New`](@ref), [`PopProxy`](@ref), [`PushProxy`](@ref), [`Reset`](@ref), [`Size`](@ref), [`Sizeof`](@ref), [`TVirtualCollectionProxy`](@ref)
""" TVirtualCollectionProxy

# Wrapper of TOrdCollection
@trydoc raw"""
    ROOT.TOrdCollection

Ordered collection.

An ordered collection has [TList](@ref) insertion semantics but is implemented using an array of TObject*'s. It uses less space than a [TList](@ref) (since there is no need for the prev and next pointers), but it is more costly to insert objects (since it has to create a gap by copying object pointers). [TOrdCollection](@ref) is better than [TList](@ref) when objects are only added at the theend of the collection since no copying needs to be done.

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`After`](@ref), [`At`](@ref), [`Before`](@ref), [`BinarySearch`](@ref), [`Clear`](@ref), [`Delete`](@ref), [`First`](@ref), [`GetObjectRef`](@ref), [`IndexOf`](@ref), [`Last`](@ref), [`MakeIterator`](@ref), [`PutAt`](@ref), [`RemoveAt`](@ref), [`Remove`](@ref), [`Sort`](@ref), [`TOrdCollection`](@ref)
""" TOrdCollection

# Wrapper of TOrdCollectionIter
@trydoc raw"""
    ROOT.TOrdCollectionIter

Iterator of ordered collection.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TOrdCollectionIter`](@ref), [`assign`](@ref)
""" TOrdCollectionIter

# Wrapper of TArrayL64
@trydoc raw"""
    ROOT.TArrayL64

Array of long64s (64 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayL64`](@ref), [`assign`](@ref)
""" TArrayL64

# Wrapper of TSortedList
@trydoc raw"""
    ROOT.TSortedList

A sorted doubly linked list.

All sortable classes inheriting from [TObject](@ref) can be inserted in a [TSortedList](@ref).

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`IsSorted`](@ref), [`Sort`](@ref), [`TSortedList`](@ref)
""" TSortedList

# Wrapper of TObjectTable
@trydoc raw"""
    ROOT.TObjectTable

This class registers all instances of [TObject](@ref) and its derived classes in a hash table.

The [Add()](@ref) and [Remove()](@ref) members are called from the [TObject](@ref) ctor and dtor, respectively. Using the [Print()](@ref) member one can see all currently active objects in the system. Using the resource (in .rootrc): Root.ObjectStat one can toggle this feature on or off.

Using the compile option R__NOSTATS one can de-active this feature for the entire system (for maximum performance in highly time critical applications).

The following output has been produced in a [ROOT](@ref) interactive session via the command gObjectTable->[Print()](@ref) 

    class                     cnt    on heap     size    total size    heap size
    ============================================================================
    TKey                        4          4       72           288          288
    TClass                     84         84       80          6720         6720
    TDataMember               276        276       24          6624         6624
    TObject                    11         11       12           132          132
    TMethod                  1974       1974       64        126336       126336
    TDataType                  34         34       56          1904         1904
    TList                    2328       2328       36         83808        83808
    TH1F                        1          1      448           448          448
    TText                    2688       2688       56        150528       150528
    TGaxis                      1          0      120           120            0
    TAxis                       6          3       88           528          264
    TBox                       57         57       52          2964         2964
    TLine                     118        118       40          4720         4720
    TWbox                       1          1       56            56           56
    TArrow                      1          1       64            64           64
    TPaveText                  59         59      124          7316         7316
    TPave                       1          1       92            92           92
    TFile                       1          1      136           136          136
    TCanvas                     3          3      444          1332         1332
    TPad                        1          1      312           312          312
    TContextMenu                3          3       48           144          144
    TMethodArg               2166       2166       44         95304        95304
    TPaveLabel                  1          1      120           120          120
    THtml                       1          1       32            32           32
    TROOT                       1          0      208           208            0
    TApplication                1          1       28            28           28
    TFileHandler                1          1       20            20           20
    TColor                    163        163       40          6520         6520
    TStyle                      1          1      364           364          364
    TRealData                 117        117       28          3276         3276
    TBaseClass                 88         88       36          3168         3168
    THashList                   5          5       40           200          200
    THashTable                  5          5       36           180          180
    TGeometry                   1          1       64            64           64
    TLink                       7          7       60           420          420
    TPostScript                 1          1      764           764          764
    TMinuit                     1          1      792           792          792
    TStopwatch                  1          0       56            56            0
    TRootGuiFactory             1          1       28            28           28
    TGX11                       1          1      172           172          172
    TUnixSystem                 1          1      252           252          252
    TSignalHandler              1          1       20            20           20
    TOrdCollection              3          3       40           120          120
    TEnv                        1          1       24            24           24
    TCling                      1          1      208           208          208
    TBenchmark                  1          1       52            52           52
    TClassTable                 1          1       12            12           12
    TObjectTable                1          1       12            12           12
    ----------------------------------------------------------------------------
    Total:                  10225      10219     5976        506988       506340
    ============================================================================

(C++ version of the code)

Related functions: [`Add`](@ref), [`CheckPtrAndWarn`](@ref), [`Delete`](@ref), [`GetSize`](@ref), [`InstanceStatistics`](@ref), [`Instances`](@ref), [`Print`](@ref), [`PtrIsValid`](@ref), [`RemoveQuietly`](@ref), [`Remove`](@ref), [`Statistics`](@ref), [`TObjectTable!AddObj`](@ref), [`TObjectTable`](@ref), [`Terminate`](@ref), [`UpdateInstCount`](@ref)
""" TObjectTable

# Wrapper of TBrowserImp
@trydoc raw"""
    ROOT.TBrowserImp

ABC describing GUI independent browser implementation protocol.



Related functions: [`AddCheckBox`](@ref), [`Add`](@ref), [`BrowseObj`](@ref), [`Browser`](@ref), [`CheckObjectItem`](@ref), [`CloseTabs`](@ref), [`ExecPlugin`](@ref), [`ExecuteDefaultAction`](@ref), [`GetBrowser`](@ref), [`GetDrawOption`](@ref), [`GetMainFrame`](@ref), [`Iconify`](@ref), [`RecursiveRemove`](@ref), [`Refresh`](@ref), [`RemoveCheckBox`](@ref), [`SetBrowser`](@ref), [`SetDrawOption`](@ref), [`SetStatusText`](@ref), [`Show`](@ref), [`StartEmbedding`](@ref), [`StopEmbedding`](@ref), [`TBrowserImp`](@ref)
""" TBrowserImp

# Wrapper of TTree
@trydoc raw"""
    ROOT.TTree

A [TTree](@ref) represents a columnar dataset.

Any C++ type can be stored in its columns.

A [TTree](@ref), often called in jargon *tree*, consists of a list of independent columns or *branches*, represented by the [TBranch](@ref) class. Behind each branch, buffers are allocated automatically by [ROOT](@ref). Such buffers are automatically written to disk or kept in memory until the size stored in the attribute fMaxVirtualSize is reached. Variables of one branch are written to the same buffer. A branch buffer is automatically compressed if the file compression attribute is set (default). Branches may be written to different files (see [TBranch!SetFile](@ref)).

The [ROOT](@ref) user can decide to make one single branch and serialize one object into one single I/O buffer or to make several branches. Making several branches is particularly interesting in the data analysis phase, when it is desirable to have a high reading rate and not all columns are equally interesting

## Create a TTree to store columnar data

- [Construct a TTree](@ref)
- [Add a column of Fundamental Types and Arrays thereof](@ref)
- [Add a column of a STL Collection instances](@ref)
- [Add a column holding an object](@ref)
- [Add a column holding a TObjectArray](@ref)
- [Fill the tree](@ref)
- [Add a column to an already existing Tree](@ref)
- [An Example](@ref)

## Construct a TTree

    TTree tree(name, title)

(C++ version of the code)

 Creates a Tree with name and title.

Various kinds of branches can be added to a tree:

- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.
- Any C++ object or collection, provided by the STL or [ROOT](@ref).

In the following, the details about the creation of different types of branches are given.

## Add a column ("branch") holding fundamental types and arrays thereof

This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.

    auto branch = tree.Branch(branchname, address, leaflist, bufsize)

(C++ version of the code)

- address is the address of the first item of a structure
- leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:

    - `C` : a character string terminated by the 0 character
    - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.
    - `b` : an 8 bit unsigned integer (`UChar_t`)
    - `S` : a 16 bit signed integer (`Short_t`)
    - `s` : a 16 bit unsigned integer (`UShort_t`)
    - `I` : a 32 bit signed integer (`Int_t`)
    - `i` : a 32 bit unsigned integer (`UInt_t`)
    - `F` : a 32 bit floating point (`Float_t`)
    - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`)
    - `D` : a 64 bit floating point (`Double_t`)
    - `d` : a 24 bit truncated floating point (`Double32_t`)
    - `L` : a 64 bit signed integer (`Long64_t`)
    - `l` : a 64 bit unsigned integer (`ULong64_t`)
    - `G` : a long signed integer, stored as 64 bit (`Long_t`)
    - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`)
    - `O` : [the letter `o`, not a zero] a boolean (`bool`)

    Examples:

    - A int: "myVar/I"
    - A float array with fixed size: "myArrfloat[42]/F"
    - An double array with variable size, held by the `myvar` column: "myArrdouble[myvar]/D"
    - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: "myArr[myvar]/d[0,10]"
    - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).
- If the address points to a single numerical variable, the leaflist is optional: 

        int value;
        tree->Branch(branchname, &value);

(C++ version of the code)

- If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable [TTree](@ref) (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.
- In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. For example, for storing a variable size array `myArr` of `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified, the standard rules of opaque typedefs annotation are valid. For example, if only 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`

## Adding a column holding STL collection instances (e.g. std::vector, std::list, std::unordered_map)

    auto branch = tree.Branch( branchname, STLcollection, buffsize, splitlevel);

(C++ version of the code)

 STLcollection is the address of a pointer to std!vector, std!list, std!deque, std!set or std!multiset containing pointers to objects. If the splitlevel is a value bigger than 100 ([TTree!kSplitCollectionOfPointers](@ref)) then the collection will be written in split mode, e.g. if it contains objects of any types deriving from TTrack this function will sort the objects based on their type and store them in separate branches in split mode.

    branch->SetAddress(void *address)

(C++ version of the code)

 In case of dynamic structures changing with each entry for example, one must redefine the branch address before filling the branch again. This is done via the [TBranch!SetAddress](@ref) member function.

## Add a column holding objects

    MyClass object;
    auto branch = tree.Branch(branchname, &object, bufsize, splitlevel)

(C++ version of the code)

 Note: The 2nd parameter must be the address of a valid object. The object must not be destroyed (i.e. be deleted) until the [TTree](@ref) is deleted or [TTree!ResetBranchAddress](@ref) is called.

- if splitlevel=0, the object is serialized in the branch buffer.
- if splitlevel=1 (default), this branch will automatically be split into subbranches, with one subbranch for each data member or object of the object itself. In case the object member is a [TClonesArray](@ref), the mechanism described in case C is applied to this array.
- if splitlevel=2 ,this branch will automatically be split into subbranches, with one subbranch for each data member or object of the object itself. In case the object member is a [TClonesArray](@ref), it is processed as a TObject*, only one branch.

Another available syntax is the following:

    auto branch = tree.Branch(branchname, &p_object, bufsize, splitlevel)
    auto branch = tree.Branch(branchname, className, &p_object, bufsize, splitlevel)

(C++ version of the code)

- p_object is a pointer to an object.
- If className is not specified, Branch uses the type of p_object to determine the type of the object.
- If className is used to specify explicitly the object type, the className must be of a type related to the one pointed to by the pointer. It should be either a parent or derived class.

Note: The pointer whose address is passed to [TTree!Branch](@ref) must not be destroyed (i.e. go out of scope) until the [TTree](@ref) is deleted or [TTree!ResetBranchAddress](@ref) is called.

Note: The pointer p_object must be initialized before calling [TTree!Branch](@ref)

- Do either: 

        MyDataClass* p_object = nullptr;
        tree.Branch(branchname, &p_object);

(C++ version of the code)

- Or: 

        auto p_object = new MyDataClass;
        tree.Branch(branchname, &p_object);

(C++ version of the code)

 Whether the pointer is set to zero or not, the ownership of the object is not taken over by the [TTree](@ref). I.e. even though an object will be allocated by [TTree!Branch](@ref) if the pointer p_object is zero, the object will **not** be deleted when the [TTree](@ref) is deleted.

## Add a column holding TClonesArray instances

It is recommended to use STL containers instead of TClonesArrays*.

    // clonesarray is the address of a pointer to a TClonesArray.
    auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel)

(C++ version of the code)

 The [TClonesArray](@ref) is a direct access list of objects of the same class. For example, if the [TClonesArray](@ref) is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack.

## Fill the Tree

A [TTree](@ref) instance is filled with the invocation of the [TTree!Fill](@ref) method: 

    tree.Fill()

(C++ version of the code)

 Upon its invocation, a loop on all defined branches takes place that for each branch invokes the [TBranch!Fill](@ref) method.

## Add a column to an already existing Tree

You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. 

    void tree3AddBranch() {
        TFile f("tree3.root", "update");
        Float_t new_v;
        auto t3 = f->Get<TTree>("t3");
        auto newBranch = t3->Branch("new_v", &new_v, "new_v/F");
        Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3
        for (Long64_t i = 0; i < nentries; i++) {
            new_v = gRandom->Gaus(0, 1);
            newBranch->Fill();
        }
        t3->Write("", TObject!kOverwrite); // save only the new version of the tree
    }

(C++ version of the code)

 It is not always possible to add branches to existing datasets stored in TFiles: for example, these files might not be writeable, just readable. In addition, modifying in place a [TTree](@ref) causes a new [TTree](@ref) instance to be written and the previous one to be deleted. For this reasons, [ROOT](@ref) offers the concept of friends for [TTree](@ref) and [TChain](@ref): if is good practice to rely on friend trees rather than adding a branch manually.

## An Example

![https://root.cern/doc/v636/pict1_TTree_001.png](https://root.cern/doc/v636/pict1_TTree_001.png)

        // A simple example with histograms and a tree
        //
        // This program creates :
        //    - a one dimensional histogram
        //    - a two dimensional histogram
        //    - a profile histogram
        //    - a tree
        //
        // These objects are filled with some random numbers and saved on a file.
        #include "TFile.h"
        #include "TH1.h"
        #include "TH2.h"
        #include "TProfile.h"
        #include "TRandom.h"
        #include "TTree.h"
        //__________________________________________________________________________
        main(int argc, char **argv)
        {
        // Create a new ROOT binary machine independent file.
        // Note that this file may contain any kind of ROOT objects, histograms,trees
        // pictures, graphics objects, detector geometries, tracks, events, etc..
        // This file is now becoming the current directory.
        TFile hfile("htree.root","RECREATE","Demo ROOT file with histograms & trees");
        // Create some histograms and a profile histogram
        TH1F hpx("hpx","This is the px distribution",100,-4,4);
        TH2F hpxpy("hpxpy","py ps px",40,-4,4,40,-4,4);
        TProfile hprof("hprof","Profile of pz versus px",100,-4,4,0,20);
        // Define some simple structures
        typedef struct {Float_t x,y,z;} POINT;
        typedef struct {
           Int_t ntrack,nseg,nvertex;
           UInt_t flag;
           Float_t temperature;
        } EVENTN;
        POINT point;
        EVENTN eventn;
        // Create a ROOT Tree
        TTree tree("T","An example of ROOT tree with a few branches");
        tree.Branch("point",&point,"x:y:z");
        tree.Branch("eventn",&eventn,"ntrack/I:nseg:nvertex:flag/i:temperature/F");
        tree.Branch("hpx","TH1F",&hpx,128000,0);
        Float_t px,py,pz;
        // Here we thestart a loop on 1000 events
        for ( Int_t i=0; i<1000; i++) {
           gRandom->Rannor(px,py);
           pz = px*px + py*py;
           const auto random = gRandom->!Rndm(1);
           // Fill histograms
           hpx.Fill(px);
           hpxpy.Fill(px,py,1);
           hprof.Fill(px,pz,1);
           // Fill structures
           point.x = 10*(random-1);
           point.y = 5*random;
           point.z = 20*random;
           eventn.ntrack  = Int_t(100*random);
           eventn.nseg    = Int_t(2*eventn.ntrack);
           eventn.nvertex = 1;
           eventn.flag    = Int_t(random+0.5);
           eventn.temperature = 20+random;
           // Fill the tree. For each event, save the 2 structures and 3 objects
           // In this simple example, the objects hpx, hprof and hpxpy are slightly
           // different from event to event. We expect a big compression factor!
           tree->Fill();
        }
        // End of the loop
        tree.Print();
        // Save all objects in this file
        hfile.Write();
        // Close the file. Note that this is automatically done when you leave
        // the application upon file destruction.
        hfile.Close();
        return 0;
    }

(C++ version of the code)

Related functions: [`AddAllocationCount`](@ref), [`AddBranchToCache`](@ref), [`AddClone`](@ref), [`AddFriend`](@ref), [`AddTotBytes`](@ref), [`AddZipBytes`](@ref), [`AutoSave`](@ref), [`BranchOld`](@ref), [`BranchRef`](@ref), [`Branch`](@ref), [`Bronch`](@ref), [`Browse`](@ref), [`BuildIndex`](@ref), [`BuildStreamerInfo`](@ref), [`ChangeFile`](@ref), [`CloneTree`](@ref), [`CopyAddresses`](@ref), [`CopyEntries`](@ref), [`CopyTree`](@ref), [`CreateBasket`](@ref), [`Debug`](@ref), [`Delete`](@ref), [`DirectoryAutoAdd`](@ref), [`Draw`](@ref), [`DropBaskets`](@ref), [`DropBranchFromCache`](@ref), [`DropBuffers`](@ref), [`EnableCache`](@ref), [`Fill`](@ref), [`FindBranch`](@ref), [`FindLeaf`](@ref), [`Fit`](@ref), [`FlushBaskets`](@ref), [`GetAlias`](@ref), [`GetAllocationCount`](@ref), [`GetAutoFlush`](@ref), [`GetAutoSave`](@ref), [`GetBranchRef`](@ref), [`GetBranchStatus`](@ref), [`GetBranch`](@ref), [`GetCacheSize`](@ref), [`GetChainEntryNumber`](@ref), [`GetChainOffset`](@ref), [`GetClusterIterator`](@ref), [`GetClusterPrefetch`](@ref), [`GetCurrentFile`](@ref), [`GetDebugMax`](@ref), [`GetDebugMin`](@ref), [`GetDefaultEntryOffsetLen`](@ref), [`GetDirectory`](@ref), [`GetEntriesFast`](@ref), [`GetEntriesFriend`](@ref), [`GetEntries`](@ref), [`GetEntryList`](@ref), [`GetEntryNumberWithBestIndex`](@ref), [`GetEntryNumberWithIndex`](@ref), [`GetEntryNumber`](@ref), [`GetEntryWithIndex`](@ref), [`GetEntry`](@ref), [`GetEstimate`](@ref), [`GetEventList`](@ref), [`GetEvent`](@ref), [`GetFileNumber`](@ref), [`GetFriendAlias`](@ref), [`GetFriend`](@ref), [`GetHistogram`](@ref), [`GetIOFeatures`](@ref), [`GetImplicitMT`](@ref), [`GetIndexValues`](@ref), [`GetIndex`](@ref), [`GetIteratorOnAllLeaves`](@ref), [`GetLeaf`](@ref), [`GetListOfAliases`](@ref), [`GetListOfBranches`](@ref), [`GetListOfClones`](@ref), [`GetListOfFriends`](@ref), [`GetListOfLeaves`](@ref), [`GetMakeClass`](@ref), [`GetMaxEntryLoop`](@ref), [`GetMaxVirtualSize`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNbranches`](@ref), [`GetNotify`](@ref), [`GetPacketSize`](@ref), [`GetPerfStats`](@ref), [`GetPlayer`](@ref), [`GetReadCache`](@ref), [`GetReadEntry`](@ref), [`GetReadEvent`](@ref), [`GetScanField`](@ref), [`GetSelect`](@ref), [`GetSelectedRows`](@ref), [`GetTargetMemoryRatio`](@ref), [`GetTimerInterval`](@ref), [`GetTotBytes`](@ref), [`GetTransientBuffer`](@ref), [`GetTreeIndex`](@ref), [`GetTreeNumber`](@ref), [`GetTree`](@ref), [`GetUpdate`](@ref), [`GetUserInfo`](@ref), [`GetV1`](@ref), [`GetV2`](@ref), [`GetV3`](@ref), [`GetV4`](@ref), [`GetVal`](@ref), [`GetVar1`](@ref), [`GetVar2`](@ref), [`GetVar3`](@ref), [`GetVar4`](@ref), [`GetVar`](@ref), [`GetW`](@ref), [`GetWeight`](@ref), [`GetZipBytes`](@ref), [`InPlaceClone`](@ref), [`IncrementTotalBuffers`](@ref), [`IsFolder`](@ref), [`LoadBaskets`](@ref), [`LoadTreeFriend`](@ref), [`LoadTree`](@ref), [`MakeClass`](@ref), [`MakeCode`](@ref), [`MakeProxy`](@ref), [`MakeSelector`](@ref), [`MemoryFull`](@ref), [`Merge`](@ref), [`Notify`](@ref), [`OptimizeBaskets`](@ref), [`Principal`](@ref), [`PrintCacheStats`](@ref), [`Print`](@ref), [`Process`](@ref), [`Project`](@ref), [`Query`](@ref), [`ReadFile`](@ref), [`ReadStream`](@ref), [`RecursiveRemove`](@ref), [`Refresh`](@ref), [`RegisterExternalFriend`](@ref), [`RemoveExternalFriend`](@ref), [`RemoveFriend`](@ref), [`ResetAfterMerge`](@ref), [`ResetBranchAddress`](@ref), [`ResetBranchAddresses`](@ref), [`Reset`](@ref), [`Scan`](@ref), [`SetAlias`](@ref), [`SetAutoFlush`](@ref), [`SetAutoSave`](@ref), [`SetBasketSize`](@ref), [`SetBranchAddress`](@ref), [`SetBranchStatus`](@ref), [`SetCacheEntryRange`](@ref), [`SetCacheLearnEntries`](@ref), [`SetCacheSize`](@ref), [`SetChainOffset`](@ref), [`SetCircular`](@ref), [`SetClusterPrefetch`](@ref), [`SetDebug`](@ref), [`SetDefaultEntryOffsetLen`](@ref), [`SetDirectory`](@ref), [`SetEntries`](@ref), [`SetEntryList`](@ref), [`SetEstimate`](@ref), [`SetEventList`](@ref), [`SetFileNumber`](@ref), [`SetIOFeatures`](@ref), [`SetImplicitMT`](@ref), [`SetMakeClass`](@ref), [`SetMaxEntryLoop`](@ref), [`SetMaxVirtualSize`](@ref), [`SetName`](@ref), [`SetNotify`](@ref), [`SetObject`](@ref), [`SetParallelUnzip`](@ref), [`SetPerfStats`](@ref), [`SetScanField`](@ref), [`SetTargetMemoryRatio`](@ref), [`SetTimerInterval`](@ref), [`SetTreeIndex`](@ref), [`SetUpdate`](@ref), [`SetWeight`](@ref), [`Show`](@ref), [`StartViewer`](@ref), [`StopCacheLearningPhase`](@ref), [`TTree!GetBranchStyle`](@ref), [`TTree!GetMaxTreeSize`](@ref), [`TTree!MergeTrees`](@ref), [`TTree!SetBranchStyle`](@ref), [`TTree!SetMaxTreeSize`](@ref), [`TTree`](@ref), [`UnbinnedFit`](@ref), [`UseCurrentStyle`](@ref), [`Write`](@ref), [`assign`](@ref)
""" TTree

# Wrapper of TLeaf
@trydoc raw"""
    ROOT.TLeaf

A [TLeaf](@ref) describes individual elements of a [TBranch](@ref) See [TBranch](@ref) structure in [TTree](@ref).

A [TTree](@ref) object is a list of [TBranch](@ref). A [TBranch](@ref) object is a list of [TLeaf](@ref). In most cases, the [TBranch](@ref) will have one [TLeaf](@ref). A [TLeaf](@ref) describes the branch data types and holds the data.

A few notes about the data held by the leaf. It can contain:

1. a single object or primitive (e.g., one float),
2. a fixed-number of objects (e.g., each entry has two floats). The number of elements per entry is saved in `fLen`.
3. a dynamic number of primitives. The number of objects in each entry is saved in the `fLeafCount` branch.

Note options (2) and (3) can combined - if fLeafCount says an entry has 3 elements and fLen is 2, then there will be 6 objects in that entry.

Additionally, `fNdata` is transient and generated on read to determine the necessary size of a buffer to hold event data; depending on the call-site, it may be sized larger than the number of elements

Related functions: [`Browse`](@ref), [`CanGenerateOffsetArray`](@ref), [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GenerateOffsetArray`](@ref), [`GetBranch`](@ref), [`GetDeserializeType`](@ref), [`GetFullName`](@ref), [`GetLeafCountValues`](@ref), [`GetLeafCount`](@ref), [`GetLeafCounter`](@ref), [`GetLenStatic`](@ref), [`GetLenType`](@ref), [`GetLen`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNdata`](@ref), [`GetOffset`](@ref), [`GetTypeName`](@ref), [`GetTypedValue`](@ref), [`GetValueLong64`](@ref), [`GetValueLongDouble`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`IsOnTerminalBranch`](@ref), [`IsRange`](@ref), [`IsUnsigned`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasketSerialized`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`ResetAddress`](@ref), [`SetAddress`](@ref), [`SetBranch`](@ref), [`SetLeafCount`](@ref), [`SetLen`](@ref), [`SetOffset`](@ref), [`SetRange`](@ref), [`SetUnsigned`](@ref), [`TLeaf`](@ref)
""" TLeaf

# Wrapper of TStreamerInfo
@trydoc raw"""
    ROOT.TStreamerInfo

Describes a persistent version of a class.

A [ROOT](@ref) file contains the list of [TStreamerInfo](@ref) objects for all the class versions written to this file. When reading a file, all the [TStreamerInfo](@ref) objects are read back in memory and registered to the [TClass](@ref) list of [TStreamerInfo](@ref). One can see the list and contents of the [TStreamerInfo](@ref) on a file with, e.g., 

    TFile f("myfile.root");
    f.ShowStreamerInfo();

(C++ version of the code)

 A [TStreamerInfo](@ref) is a list of [TStreamerElement](@ref) objects (one per data member or base class). When streaming an object, the system ([TClass](@ref)) loops on all the [TStreamerElement](@ref) objects and calls the appropriate function for each element type.

Related functions: [`BuildCheck`](@ref), [`BuildEmulated`](@ref), [`BuildFor`](@ref), [`BuildOld`](@ref), [`Build`](@ref), [`CallShowMembers`](@ref), [`Clear`](@ref), [`Clone`](@ref), [`CompareContent`](@ref), [`Compile`](@ref), [`ComputeSize`](@ref), [`DeleteArray`](@ref), [`Destructor`](@ref), [`ForceWriteInfo`](@ref), [`GenEmulatedClassStreamer`](@ref), [`GenEmulatedProxy`](@ref), [`GenExplicitClassStreamer`](@ref), [`GenExplicitProxy`](@ref), [`GenerateHeaderFile`](@ref), [`GenerateInfoForPair`](@ref), [`GetActualClass`](@ref), [`GetCheckSum`](@ref), [`GetClassVersion`](@ref), [`GetClass`](@ref), [`GetDataMemberOffset`](@ref), [`GetElem`](@ref), [`GetElementOffset`](@ref), [`GetElement`](@ref), [`GetElements`](@ref), [`GetLength`](@ref), [`GetMethod`](@ref), [`GetNdata`](@ref), [`GetNelement`](@ref), [`GetNewType`](@ref), [`GetNumber`](@ref), [`GetOffset`](@ref), [`GetOldVersion`](@ref), [`GetOnFileClassVersion`](@ref), [`GetReadMemberWiseActions`](@ref), [`GetReadObjectWiseActions`](@ref), [`GetReadTextActions`](@ref), [`GetSizeElements`](@ref), [`GetSize`](@ref), [`GetStreamerElementReal`](@ref), [`GetStreamerElement`](@ref), [`GetType`](@ref), [`GetTypedValueClones`](@ref), [`GetTypedValueSTLP`](@ref), [`GetTypedValueSTL`](@ref), [`GetTypedValue`](@ref), [`GetValueClones`](@ref), [`GetValueSTLP`](@ref), [`GetValueSTL`](@ref), [`GetValue`](@ref), [`GetWriteMemberWiseActions`](@ref), [`GetWriteObjectWiseActions`](@ref), [`GetWriteTextActions`](@ref), [`MatchLegacyCheckSum`](@ref), [`NewArray`](@ref), [`NewInfo`](@ref), [`New`](@ref), [`PrintValueClones`](@ref), [`PrintValueSTL`](@ref), [`PrintValue`](@ref), [`ReadBufferArtificial`](@ref), [`ReadBufferClones`](@ref), [`ReadBufferConv`](@ref), [`ReadBufferSTL`](@ref), [`ReadBufferSkip`](@ref), [`ReadBuffer`](@ref), [`SetCheckSum`](@ref), [`SetClassVersion`](@ref), [`SetClass`](@ref), [`SetOnFileClassVersion`](@ref), [`TStreamerInfo!GetCurrentElement`](@ref), [`TStreamerInfo`](@ref), [`TagFile`](@ref), [`Update`](@ref), [`WriteBufferAux`](@ref), [`ls`](@ref)
""" TStreamerInfo

# Wrapper of TEntryList
@trydoc raw"""
    ROOT.TEntryList

A List of entry numbers in a [TTree](@ref) or [TChain](@ref).

Note: It is recommended to use approaches such as TTreeReader!SetEntryRange or [ROOT!RDataFrame](@ref) instead of [TEntryList](@ref) if possible.

## Operations on entry lists

- **Add**() - if the lists are for the same tree, adds all the entries of the second list to the first list. If the lists are for different trees, creates a [TEntryList](@ref) with 2 sublists for each [TTree](@ref). If the lists are for TChains, merges the ones for the same trees and adds new sublists for the TTrees that were not included in the first [TEntryList](@ref)
- **Subtract**() - if the lists are for the same [TTree](@ref), removes the entries of the second list from the first list. If the lists are for TChains, loops over all sub-lists
- **GetEntry(n)** - returns the n-th entry number
- **Next**() - returns next entry number. Note, that this function is much faster than GetEntry, and it's called when [GetEntry()](@ref) is called for 2 or more indices in a row.

## TTree::Draw() and TChain::Draw()

Use option **entrylist** to write the results of [TTree!Draw](@ref) and [TChain!Draw](@ref) into an entry list. Example: 

    tree->Draw(">>elist", "x<0 && y>0", "entrylist");
    TEntryList *elist = (TEntryList*)gDirectory->Get("elist");

(C++ version of the code)

 

## Example of Loop on TEntryList with a TChain

    void loopChain() {
       TFile *fe = TFile!Open("myelist.root");
       TEntryList *myelist = (TEntryList*)fe->Get("myelist");
       TChain *chain = new TChain("ntuple");
       chain->Add("hsimple.root");
       chain->Add("hsimple2.root");
       Long64_t listEntries = myelist->GetN();
       Long64_t chainEntries = chain->GetEntries();
       Int_t treenum = 0;
       chain->SetEntryList(myelist);
       for (entry=thestart;entry < theend;entry++) {
          entryNumber = chain->GetEntryNumber(entry);
          if (entryNumber < 0) break;
          localEntry = chain->LoadTree(entryNumber);
          if (localEntry < 0) break;
          ....
          then either call
             branch->GetEntry(localEntry);
          or
             chain->GetEntry(entryNumber);
          In the later case the LoadTree is then somewhat redundant.
          ...
       }
    }

(C++ version of the code)

 When using the [TEntryList](@ref) interface directly, you can get the 'tree number' and entry in the current tree (i.e. value similar to the return value of LoadTree) from calling [TEntryList!GetEntryAndTree](@ref): 

    Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);

(C++ version of the code)

 to obtain the entry number within the chain you need to add to it the value of `treeEntry+ch->GetTreeOffset()[treenum]` such that the loop in the previous example can also be written as: 

    for (Long64_t el = 0; el < listEntries; el++) {
       Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);
       Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];
       printf("el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n", el, treeEntry, chainEntry, treenum);
       ch->LoadTree(chainEntry); // this also returns treeEntry
       needed_branch->GetEntry(treeEntry);
    }

(C++ version of the code)

 

## TSelectors

To fill an [TEntryList](@ref) from a [TSelector](@ref) correctly, one must add the [TEntryList](@ref) object to the output list of the selector ([TSelector!fOutput](@ref)). This is the only way to make the sub-lists of the [TEntryList](@ref) switch when the current tree of the [TChain](@ref) is changed.

## Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList())

while the [TTree!SetEntryList()](@ref) function is only setting the [TTree!fEntryList](@ref) data member, the same function in [TChain](@ref) also finds correspondence between the TTrees of this [TChain](@ref) and the sub-lists of this [TEntryList](@ref).

## TEntryList and the current directory

[TEntryList](@ref) objects are automatically added to the current directory (like TTrees). However, in case of a [TEntryList](@ref) for a chain, only the top-level entry list is added, not the sub-lists for specific trees. Placing entry lists in the current directory allows calling them as a part of a [TTreeFormula](@ref) expression, so if the user wants to extract a sublist from a [TChain](@ref) entry list via the [GetEntryList()](@ref) or some other function, they have to add it to the current directory to be able to use it in [TTreeFormula](@ref) expressions.

## TEntryList and TEventList

[TTree!SetEventList()](@ref) and [TChain!SetEventList()](@ref) transform a [TEventList](@ref) into a [TEntryList](@ref) See comments to those functions for more details

## Types of entry lists

There are two types of entry lists:

#### 1.

for a [TTree](@ref) (fBlocks data member is non-zero) Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored in the [TObjArray](@ref) fBlocks. The range of the entry numbers is cut into intervals of kBlockSize entries (currently 64000), so that the first block contains information which entries out of the first 64000 pass the selection, the second block - which entries out of the 64000-127999 interval pass the selection, etc. Some blocks, obviously, might be empty. The internal representation of entry numbers in the blocks is described in the [TEntryListBlock](@ref) class description, and this representation might be changed by calling [OptimizeStorage()](@ref) function (when the list is filled via the [Enter()](@ref) function, this is done automatically, except for the last block). Individual entry lists can be merged (functions [Merge()](@ref) and [Add()](@ref)) to make an entry list for a [TChain](@ref) of corresponding TTrees.

![https://root.cern/doc/v636/pict1_TEntryList_001.png](https://root.cern/doc/v636/pict1_TEntryList_001.png)

#### 2.

for a [TChain](@ref) (fLists data member is non-zero) It contains a [TList](@ref) of sub-lists ([TEntryList](@ref) objects, corresponding to each [TTree](@ref)) Trees and lists are matched by the [TTree](@ref) name and its file name (full path). All sub-lists are returned by the [GetLists()](@ref) function and individual lists are returned by [GetEntryList()](@ref) function. Such lists are no different from the lists for TTrees, described above.

![https://root.cern/doc/v636/pict1_TEntryList_002.png](https://root.cern/doc/v636/pict1_TEntryList_002.png)

Related functions: [`AddSubList`](@ref), [`Add`](@ref), [`ClassDefOverride`](@ref), [`Contains`](@ref), [`DirectoryAutoAdd`](@ref), [`EnterRange`](@ref), [`Enter`](@ref), [`GetCurrentList`](@ref), [`GetDirectory`](@ref), [`GetEntriesToProcess`](@ref), [`GetEntryAndTree`](@ref), [`GetEntryList`](@ref), [`GetEntry`](@ref), [`GetFileName`](@ref), [`GetLists`](@ref), [`GetN`](@ref), [`GetReapplyCut`](@ref), [`GetTreeName`](@ref), [`GetTreeNumber`](@ref), [`IsValid`](@ref), [`Merge`](@ref), [`Next`](@ref), [`OptimizeStorage`](@ref), [`Print`](@ref), [`RelocatePaths`](@ref), [`Remove`](@ref), [`Reset`](@ref), [`ScanPaths`](@ref), [`SetDirectory`](@ref), [`SetEntriesToProcess`](@ref), [`SetFileName`](@ref), [`SetReapplyCut`](@ref), [`SetShift`](@ref), [`SetTreeName`](@ref), [`SetTreeNumber`](@ref), [`SetTree`](@ref), [`Subtract`](@ref), [`TEntryList!Relocate`](@ref), [`TEntryList!Scan`](@ref), [`TEntryList`](@ref)
""" TEntryList

# Wrapper of TH1
@trydoc raw"""
    ROOT.TH1

[TH1](@ref) is the base class of all histogram classes in ROOT.

It provides the common interface for operations such as binning, filling, drawing, which will be detailed below.

1. [Creating histograms](@ref)

    - [Labelling axes](@ref)
2. [Binning](@ref)

    - [Fix or variable bin size](@ref)
    - [Convention for numbering bins](@ref)
    - [Alphanumeric Bin Labels](@ref)
    - [Histograms with automatic bins](@ref)
    - [Rebinning](@ref)
3. [Filling histograms](@ref)

    - [Associated errors](@ref)
    - [Associated functions](@ref)
    - [Projections of histograms](@ref)
    - [Random Numbers and histograms](@ref)
    - [Making a copy of a histogram](@ref)
    - [Normalizing histograms](@ref)
4. [Drawing histograms](@ref)

    - [Setting Drawing histogram contour levels (2-D hists only)](@ref)
    - [Setting histogram graphics attributes](@ref)
    - [Customising how axes are drawn](@ref)
5. [Fitting histograms](@ref)
6. [Saving/reading histograms to/from a ROOT file](@ref)
7. [Operations on histograms](@ref)
8. [Miscellaneous operations](@ref)

[ROOT](@ref) supports the following histogram types:

- 1-D histograms:

    - [TH1C](@ref) : histograms with one byte per channel. Maximum bin content = 127
    - [TH1S](@ref) : histograms with one short per channel. Maximum bin content = 32767
    - [TH1I](@ref) : histograms with one int per channel. Maximum bin content = INT_MAX ([*](@ref))
    - [TH1L](@ref) : histograms with one long64 per channel. Maximum bin content = LLONG_MAX ([**](@ref))
    - [TH1F](@ref) : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
    - [TH1D](@ref) : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))
- 2-D histograms:

    - [TH2C](@ref) : histograms with one byte per channel. Maximum bin content = 127
    - [TH2S](@ref) : histograms with one short per channel. Maximum bin content = 32767
    - [TH2I](@ref) : histograms with one int per channel. Maximum bin content = INT_MAX ([*](@ref))
    - [TH2L](@ref) : histograms with one long64 per channel. Maximum bin content = LLONG_MAX ([**](@ref))
    - [TH2F](@ref) : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
    - [TH2D](@ref) : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))
- 3-D histograms:

    - [TH3C](@ref) : histograms with one byte per channel. Maximum bin content = 127
    - [TH3S](@ref) : histograms with one short per channel. Maximum bin content = 32767
    - [TH3I](@ref) : histograms with one int per channel. Maximum bin content = INT_MAX ([*](@ref))
    - [TH3L](@ref) : histograms with one long64 per channel. Maximum bin content = LLONG_MAX ([**](@ref))
    - [TH3F](@ref) : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
    - [TH3D](@ref) : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))
- Profile histograms: See classes [TProfile](@ref), [TProfile2D](@ref) and [TProfile3D](@ref). Profile histograms are used to display the mean value of Y and its standard deviation for each bin in X. Profile histograms are in many cases an elegant replacement of two-dimensional histograms : the inter-relation of two measured quantities X and Y can always be visualized by a two-dimensional histogram or scatter-plot; If Y is an unknown (but single-valued) approximate function of X, this function is displayed by a profile histogram with much better precision than by a scatter-plot.

<sup> (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br/>
 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760) </sup>

The inheritance hierarchy looks as follows:

![https://root.cern/doc/v636/classTH1__inherit__graph_org.svg](https://root.cern/doc/v636/classTH1__inherit__graph_org.svg)

## Creating histograms

Histograms are created by invoking one of the constructors, e.g. 

    TH1F *h1 = new TH1F("h1", "h1 title", 100, 0, 4.4);
    TH2F *h2 = new TH2F("h2", "h2 title", 40, 0, 4, 30, -3, 3);

(C++ version of the code)

 Histograms may also be created by:

- calling the [Clone()](@ref) function, see below
- making a projection from a 2-D or 3-D histogram, see below
- reading a histogram from a file

When a histogram is created, a reference to it is automatically added to the list of in-memory objects for the current file or directory. Then the pointer to this histogram in the current directory can be found by its name, doing: 

    TH1F *h1 = (TH1F*)gDirectory->FindObject(name);

(C++ version of the code)

This default behaviour can be changed by: 

    h->SetDirectory(nullptr);          // for the current histogram h
    TH1!AddDirectory(kFALSE);   // sets a global_ switch disabling the referencing

(C++ version of the code)

 When the histogram is deleted, the reference to it is removed from the list of objects in memory. When a file is closed, all histograms in memory associated with this file are automatically deleted.

### Labelling axes

Axis titles can be specified in the title argument of the constructor. They must be separated by ";": 

    TH1F* h=new TH1F("h", "Histogram title;X Axis;Y Axis", 100, 0, 1);

(C++ version of the code)

 The histogram title and the axis titles can be any [TLatex](@ref) string, and are persisted if a histogram is written to a file.

Any title can be omitted: 

    TH1F* h=new TH1F("h", "Histogram title;;Y Axis", 100, 0, 1);
    TH1F* h=new TH1F("h", ";;Y Axis", 100, 0, 1);

(C++ version of the code)

 The method [SetTitle()](@ref) has the same syntax: 

    h->SetTitle("Histogram title;Another X title Axis");

(C++ version of the code)

 Alternatively, the title of each axis can be set directly: 

    h->GetXaxis()->SetTitle("X axis title");
    h->GetYaxis()->SetTitle("Y axis title");

(C++ version of the code)

 For bin labels see [binning](@ref).

## Binning

### Fix or variable bin size

All histogram types support either fix or variable bin sizes. 2-D histograms may have fix size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw or access histograms are identical in both cases.

Each histogram always contains 3 axis objects of type [TAxis](@ref): fXaxis, fYaxis and fZaxis. To access the axis parameters, use: 

    TAxis *xaxis = h->GetXaxis(); etc.
    Double_t binCenter = xaxis->GetBinCenter(bin), etc.

(C++ version of the code)

 See class [TAxis](@ref) for a description of all the access functions. The axis range is always stored internally in double precision.

### Convention for numbering bins

For all histogram types: nbins, xlow, xup 

    bin = 0;       underflow bin
    bin = 1;       first bin with low-edge xlow INCLUDED
    bin = nbins;   last bin with upper-edge xup EXCLUDED
    bin = nbins+1; overflow bin

(C++ version of the code)

 In case of 2-D or 3-D histograms, a "global_ bin" number is defined. For example, assuming a 3-D histogram with (binx, biny, binz), the function 

    Int_t gbin = h->GetBin(binx, biny, binz);

(C++ version of the code)

 returns a global_/linearized gbin number. This global_ gbin is useful to access the bin content/error information independently of the dimension. Note that to access the information other than bin content and errors one should use the [TAxis](@ref) object directly with e.g.: 

    Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);

(C++ version of the code)

 returns the center along z of bin number 27 (not the global_ bin) in the 3-D histogram h3.

### Alphanumeric Bin Labels

By default, a histogram axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead with:

- call TAxis!SetBinLabel(bin, label); This can always be done before or after filling. When the histogram is drawn, bin labels will be automatically drawn. See examples labels1.C and labels2.C
- call to a Fill function with one of the arguments being a string, e.g. 

        hist1->Fill(somename, weight);
        hist2->Fill(x, somename, weight);
        hist2->Fill(somename, y, weight);
        hist2->Fill(somenamex, somenamey, weight);

(C++ version of the code)

 See examples hlabels1.C and hlabels2.C
- via [TTree!Draw](@ref). see for example cernstaff.C 

        tree.Draw("Nation!Division");

(C++ version of the code)

 where "Nation" and "Division" are two branches of a Tree.

When using the options 2 or 3 above, the labels are automatically added to the list ([THashList](@ref)) of labels for a given axis. By default, an axis is drawn with the order of bins corresponding to the filling sequence. It is possible to reorder the axis

- alphabetically
- by increasing or decreasing values

The reordering can be triggered via the [TAxis](@ref) context menu by selecting the menu item "LabelsOption" or by calling directly TH1!LabelsOption(option, axis) where

- axis may be "X", "Y" or "Z"
- option may be:

    - "a" sort by alphabetic order
    - ">" sort by decreasing values
    - "<" sort by increasing values
    - "h" draw labels horizontal
    - "v" draw labels vertical
    - "u" draw labels up (theend of label right adjusted)
    - "d" draw labels down (thestart of label left adjusted)

When using the option 2 above, new labels are added by doubling the current number of bins in case one label does not exist yet. When the Filling is terminated, it is possible to trim the number of bins to match the number of active labels by calling 

    TH1!LabelsDeflate(axis) with axis = "X", "Y" or "Z"

(C++ version of the code)

 This operation is automatic when using [TTree!Draw](@ref). Once bin labels have been created, they become persistent if the histogram is written to a file or when generating the C++ code via SavePrimitive.

### Histograms with automatic bins

When a histogram is created with an axis lower limit greater or equal to its upper limit, the SetBuffer is automatically called with an argument fBufferSize equal to fgBufferSize (default value=1000). fgBufferSize may be reset via the static function [TH1!SetDefaultBufferSize](@ref). The axis limits will be automatically computed when the buffer will be full or when the function BufferEmpty is called.

### Rebinning

At any time, a histogram can be rebinned via [TH1!Rebin](@ref). This function returns a new histogram with the rebinned contents. If bin errors were stored, they are recomputed during the rebinning.

## Filling histograms

A histogram is typically filled with statements like: 

    h1->Fill(x);
    h1->Fill(x, w); //fill with weight
    h2->Fill(x, y)
    h2->Fill(x, y, w)
    h3->Fill(x, y, z)
    h3->Fill(x, y, z, w)

(C++ version of the code)

 or via one of the Fill functions accepting names described above. The Fill functions compute the bin number corresponding to the given x, y or z argument and increment this bin by the given weight. The Fill functions return the bin number for 1-D histograms or global_ bin number for 2-D and 3-D histograms. If [TH1!Sumw2](@ref) has been called before filling, the sum of squares of weights is also stored. One can also increment directly a bin number via [TH1!AddBinContent](@ref) or replace the existing content via [TH1!SetBinContent](@ref). Passing an out-of-range bin to [TH1!AddBinContent](@ref) leads to undefined behavior. To access the bin content of a given bin, do: 

    Double_t binContent = h->GetBinContent(bin);

(C++ version of the code)

By default, the bin number is computed using the current axis ranges. If the automatic binning option has been set via 

    h->SetCanExtend(TH1!kAllAxes);

(C++ version of the code)

 then, the Fill Function will automatically extend the axis range to accomodate the new value specified in the Fill argument. The method used is to double the bin size until the new value fits in the range, merging bins two by two. This automatic binning options is extensively used by the [TTree!Draw](@ref) function when histogramming Tree variables with an unknown range. This automatic binning option is supported for 1-D, 2-D and 3-D histograms.

During filling, some statistics parameters are incremented to compute the mean value and Root Mean Square with the maximum precision.

In case of histograms of type [TH1C](@ref), [TH1S](@ref), [TH2C](@ref), [TH2S](@ref), [TH3C](@ref), [TH3S](@ref) a check is made that the bin contents do not exceed the maximum positive capacity (127 or 32767). Histograms of all types may have positive or/and negative bin contents.

### Associated errors

By default, for each bin, the sum of weights is computed at fill time. One can also call [TH1!Sumw2](@ref) to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights), otherwise the error is set equal to the sqrt(bin content). To return the error for a given bin number, do: 

    Double_t error = h->GetBinError(bin);

(C++ version of the code)

### Associated functions

One or more object (typically a TF1*) can be added to the list of functions (fFunctions) associated to each histogram. When [TH1!Fit](@ref) is invoked, the fitted function is added to this list. Given a histogram h, one can retrieve an associated function with: 

    TF1 *myfunc = h->GetFunction("myfunc");

(C++ version of the code)

## Operations on histograms

Many types of operations are supported on histograms or between histograms

- Addition of a histogram to the current histogram.
- Additions of two histograms with coefficients and storage into the current histogram.
- Multiplications and Divisions are supported in the same way as additions.
- The Add, Divide and Multiply functions also exist to add, divide or multiply a histogram by a function.

If a histogram has associated error bars ([TH1!Sumw2](@ref) has been called), the resulting error bars are also computed assuming independent histograms. In case of divisions, Binomial errors are also supported. One can mark a histogram to be an "average" histogram by setting its bit kIsAverage via myhist.SetBit(TH1!kIsAverage); When adding (see [TH1!Add](@ref)) average histograms, the histograms are averaged and not summed.

### Projections of histograms

One can:

- make a 1-D projection of a 2-D histogram or Profile see functions [TH2!ProjectionX](@ref),Y, [TH2!ProfileX](@ref),Y, [TProfile!ProjectionX](@ref)
- make a 1-D, 2-D or profile out of a 3-D histogram see functions [TH3!ProjectionZ](@ref), [TH3!Project3D](@ref).

One can fit these projections via: 

    TH2!FitSlicesX,Y, TH3!FitSlicesZ.

(C++ version of the code)

### Random Numbers and histograms

[TH1!FillRandom](@ref) can be used to randomly fill a histogram using the contents of an existing [TF1](@ref) function or another [TH1](@ref) histogram (for all dimensions). For example, the following two statements create and fill a histogram 10000 times with a default gaussian distribution of mean 0 and sigma 1: 

    TH1F h1("h1", "histo from a gaussian", 100, -3, 3);
    h1.FillRandom("gaus", 10000);

(C++ version of the code)

 [TH1!GetRandom](@ref) can be used to return a random number distributed according to the contents of a histogram.

### Making a copy of a histogram

Like for any other [ROOT](@ref) object derived from [TObject](@ref), one can use the [Clone()](@ref) function. This makes an identical copy of the original histogram including all associated errors and functions, e.g.: 

    TH1F *hnew = (TH1F*)h->Clone("hnew");

(C++ version of the code)

### Normalizing histograms

One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1!Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram.

## Drawing histograms

Histograms are drawn via the [THistPainter](@ref) class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). Many drawing options are supported. See [THistPainter!Paint()](@ref) for more details.

The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use 

    h->DrawCopy();

(C++ version of the code)

 This makes a clone (see Clone below) of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone.

One can use [TH1!SetMaximum()](@ref) and [TH1!SetMinimum()](@ref) to force a particular value for the maximum or the minimum scale on the plot. (For 1-D histograms this means the y-axis, while for 2-D histograms these functions affect the z-axis).

[TH1!UseCurrentStyle()](@ref) can be used to change all histogram graphics attributes to correspond to the current selected style. This function must be called for each histogram. In case one reads and draws many histograms from a file, one can force the histograms to inherit automatically the current graphics style by calling before gROOT->ForceStyle().

### Setting Drawing histogram contour levels (2-D hists only)

By default contours are automatically generated at equidistant intervals. A default value of 20 levels is used. This can be modified via [TH1!SetContour()](@ref) or [TH1!SetContourLevel()](@ref). the contours level info is used by the drawing options "cont", "surf", and "lego".

### Setting histogram graphics attributes

The histogram classes inherit from the attribute classes: [TAttLine](@ref), [TAttFill](@ref), and [TAttMarker](@ref). See the member functions of these classes for the list of options.

### Customizing how axes are drawn

Use the functions of [TAxis](@ref), such as 

    histogram.GetXaxis()->SetTicks("+");
    histogram.GetYaxis()->SetRangeUser(1., 5.);

(C++ version of the code)

## Fitting histograms

Histograms (1-D, 2-D, 3-D and Profiles) can be fitted with a user specified function or a pre-defined function via [TH1!Fit](@ref). See [TH1!Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t)](@ref) for the fitting documentation and the possible [fitting options](@ref)

The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel).

## Saving/reading histograms to/from a ROOT file

The following statements create a [ROOT](@ref) file and store a histogram on the file. Because [TH1](@ref) derives from [TNamed](@ref), the key identifier on the file is the histogram name: 

    TFile f("histos.root", "new");
    TH1F h1("hgaus", "histo from a gaussian", 100, -3, 3);
    h1.FillRandom("gaus", 10000);
    h1->Write();

(C++ version of the code)

 To read this histogram in another Root session, do: 

    TFile f("histos.root");
    TH1F *h = (TH1F*)f.Get("hgaus");

(C++ version of the code)

 One can save all histograms in memory to the file by: 

    file->Write();

(C++ version of the code)

## Miscellaneous operations

    TH1!KolmogorovTest(): statistical test of compatibility in shape
                         between two histograms
    TH1!Smooth() smooths the bin contents of a 1-d histogram
    TH1!Integral() returns the integral of bin contents in a given bin range
    TH1!GetMean(int axis) returns the mean value along axis
    TH1!GetStdDev(int axis)  returns the sigma distribution along axis
    TH1!GetEntries() returns the number of entries
    TH1!Reset() resets the bin contents and errors of a histogram

(C++ version of the code)

 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the histogram statistics are calculated. By default, if no range has been set, the returned values are the (unbinned) ones calculated at fill time. If a range has been set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINSuse TAxis!SetRange(0, 0) to unset the range. To ensure that the returned values are always those of the binned data stored in the histogram, call [TH1!ResetStats](@ref). See [TH1!GetStats](@ref).

Related functions: [`AddBinContent`](@ref), [`Add`](@ref), [`AndersonDarlingTest`](@ref), [`Browse`](@ref), [`BufferEmpty`](@ref), [`CanExtendAllAxes`](@ref), [`Chi2TestX`](@ref), [`Chi2Test`](@ref), [`Chisquare`](@ref), [`ClearUnderflowAndOverflow`](@ref), [`Clone`](@ref), [`ComputeIntegral`](@ref), [`Copy`](@ref), [`DirectoryAutoAdd`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`DrawCopy`](@ref), [`DrawNormalized`](@ref), [`DrawPanel`](@ref), [`Draw`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`ExtendAxis`](@ref), [`FFT`](@ref), [`FillN`](@ref), [`FillRandom`](@ref), [`Fill`](@ref), [`FindBin`](@ref), [`FindFirstBinAbove`](@ref), [`FindFixBin`](@ref), [`FindLastBinAbove`](@ref), [`FindObject`](@ref), [`FitPanel`](@ref), [`Fit`](@ref), [`GetAsymmetry`](@ref), [`GetAxisColor`](@ref), [`GetBarOffset`](@ref), [`GetBarWidth`](@ref), [`GetBinCenter`](@ref), [`GetBinContent`](@ref), [`GetBinErrorLow`](@ref), [`GetBinErrorOption`](@ref), [`GetBinErrorSqUnchecked`](@ref), [`GetBinErrorUp`](@ref), [`GetBinError`](@ref), [`GetBinLowEdge`](@ref), [`GetBinWidth`](@ref), [`GetBinWithContent`](@ref), [`GetBinXYZ`](@ref), [`GetBin`](@ref), [`GetBufferLength`](@ref), [`GetBufferSize`](@ref), [`GetBuffer`](@ref), [`GetCellContent`](@ref), [`GetCellError`](@ref), [`GetCenter`](@ref), [`GetContourLevelPad`](@ref), [`GetContourLevel`](@ref), [`GetContour`](@ref), [`GetCumulative`](@ref), [`GetDimension`](@ref), [`GetDirectory`](@ref), [`GetEffectiveEntries`](@ref), [`GetEntries`](@ref), [`GetFunction`](@ref), [`GetIntegral`](@ref), [`GetKurtosis`](@ref), [`GetLabelColor`](@ref), [`GetLabelFont`](@ref), [`GetLabelOffset`](@ref), [`GetLabelSize`](@ref), [`GetListOfFunctions`](@ref), [`GetLowEdge`](@ref), [`GetMaximumBin`](@ref), [`GetMaximumStored`](@ref), [`GetMaximum`](@ref), [`GetMeanError`](@ref), [`GetMean`](@ref), [`GetMinimumAndMaximum`](@ref), [`GetMinimumBin`](@ref), [`GetMinimumStored`](@ref), [`GetMinimum`](@ref), [`GetNbinsX`](@ref), [`GetNbinsY`](@ref), [`GetNbinsZ`](@ref), [`GetNcells`](@ref), [`GetNdivisions`](@ref), [`GetNormFactor`](@ref), [`GetObjectInfo`](@ref), [`GetOption`](@ref), [`GetPainter`](@ref), [`GetQuantiles`](@ref), [`GetRMSError`](@ref), [`GetRMS`](@ref), [`GetRandom`](@ref), [`GetSkewness`](@ref), [`GetStatOverflows`](@ref), [`GetStats`](@ref), [`GetStdDevError`](@ref), [`GetStdDev`](@ref), [`GetSumOfWeights`](@ref), [`GetSumw2N`](@ref), [`GetSumw2`](@ref), [`GetTickLength`](@ref), [`GetTitleFont`](@ref), [`GetTitleOffset`](@ref), [`GetTitleSize`](@ref), [`GetXaxis`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`IntegralAndError`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`IsBinOverflow`](@ref), [`IsBinUnderflow`](@ref), [`IsHighlight`](@ref), [`KolmogorovTest`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`Paint`](@ref), [`Print`](@ref), [`PutStats`](@ref), [`RebinAxis`](@ref), [`RebinX`](@ref), [`Rebin`](@ref), [`Rebuild`](@ref), [`RecursiveRemove`](@ref), [`ResetStats`](@ref), [`Reset`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetAxisColor`](@ref), [`SetAxisRange`](@ref), [`SetBarOffset`](@ref), [`SetBarWidth`](@ref), [`SetBinContent`](@ref), [`SetBinErrorOption`](@ref), [`SetBinError`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetCanExtend`](@ref), [`SetCellContent`](@ref), [`SetCellError`](@ref), [`SetContent`](@ref), [`SetContourLevel`](@ref), [`SetContour`](@ref), [`SetDirectory`](@ref), [`SetEntries`](@ref), [`SetError`](@ref), [`SetHighlight`](@ref), [`SetLabelColor`](@ref), [`SetLabelFont`](@ref), [`SetLabelOffset`](@ref), [`SetLabelSize`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetNdivisions`](@ref), [`SetNormFactor`](@ref), [`SetOption`](@ref), [`SetStatOverflows`](@ref), [`SetStats`](@ref), [`SetTickLength`](@ref), [`SetTitleFont`](@ref), [`SetTitleOffset`](@ref), [`SetTitleSize`](@ref), [`SetTitle`](@ref), [`SetXTitle`](@ref), [`SetYTitle`](@ref), [`SetZTitle`](@ref), [`ShowBackground`](@ref), [`ShowPeaks`](@ref), [`Smooth`](@ref), [`Sumw2`](@ref), [`TH1!AddDirectoryStatus`](@ref), [`TH1!AddDirectory`](@ref), [`TH1!FitOptionsMake`](@ref), [`TH1!GetDefaultBufferSize`](@ref), [`TH1!GetDefaultSumw2`](@ref), [`TH1!SetDefaultBufferSize`](@ref), [`TH1!SetDefaultSumw2`](@ref), [`TH1!SmoothArray`](@ref), [`TH1!StatOverflows`](@ref), [`TH1!TransformHisto`](@ref), [`UpdateBinContent`](@ref), [`UseCurrentStyle`](@ref)
""" TH1

# Wrapper of TH1F
@trydoc raw"""
    ROOT.TH1F

1-D histogram with a float per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1F`](@ref), [`assign`](@ref)
""" TH1F

# Wrapper of TVirtualTreePlayer
@trydoc raw"""
    ROOT.TVirtualTreePlayer

Abstract base class defining the interface for the plugins that implement Draw, Scan, Process, MakeProxy, etc.

for a [TTree](@ref) object. See the individual documentations in [TTree](@ref).

Related functions: [`BuildIndex`](@ref), [`ClassDefOverride`](@ref), [`CopyTree`](@ref), [`DrawScript`](@ref), [`DrawSelect`](@ref), [`Fit`](@ref), [`GetDimension`](@ref), [`GetEntries`](@ref), [`GetHistogram`](@ref), [`GetNfill`](@ref), [`GetSelect`](@ref), [`GetSelectedRows`](@ref), [`GetSelectorFromFile`](@ref), [`GetSelector`](@ref), [`GetV1`](@ref), [`GetV2`](@ref), [`GetV3`](@ref), [`GetV4`](@ref), [`GetVal`](@ref), [`GetVar1`](@ref), [`GetVar2`](@ref), [`GetVar3`](@ref), [`GetVar4`](@ref), [`GetVar`](@ref), [`GetW`](@ref), [`MakeClass`](@ref), [`MakeCode`](@ref), [`MakeProxy`](@ref), [`MakeReader`](@ref), [`Principal`](@ref), [`Process`](@ref), [`Query`](@ref), [`Scan`](@ref), [`SetEstimate`](@ref), [`SetTree`](@ref), [`StartViewer`](@ref), [`TVirtualTreePlayer!GetCurrentPlayer`](@ref), [`TVirtualTreePlayer!SetPlayer`](@ref), [`TVirtualTreePlayer!TreePlayer`](@ref), [`TVirtualTreePlayer`](@ref), [`UnbinnedFit`](@ref), [`UpdateFormulaLeaves`](@ref)
""" TVirtualTreePlayer

# Wrapper of TPrincipal
@trydoc raw"""
    ROOT.TPrincipal

Principal Components Analysis (PCA)

The current implementation is based on the LINTRA package from CERNLIB by R. Brun, H. Hansroul, and J. Kubler. The class has been implemented by Christian Holm Christensen in August 2000.

## Introduction

In many applications of various fields of research, the treatment of large amounts of data requires powerful techniques capable of rapid data reduction and analysis. Usually, the quantities most conveniently measured by the experimentalist, are not necessarily the most significant for classification and analysis of the data. It is then useful to have a way of selecting an optimal set of variables necessary for the recognition process and reducing the dimensionality of the problem, resulting in an easier classification procedure.

This paper describes the implementation of one such method of feature selection, namely the principal components analysis. This multidimensional technique is well known in the field of pattern recognition and and its use in Particle Physics has been documented elsewhere (cf. H. Wind, *Function Parameterization*, CERN 72-21).

## Overview

Suppose we have prototypes which are trajectories of particles, passing through a spectrometer. If one measures the passage of the particle at say 8 fixed planes, the trajectory is described by an 8-component vector: 

``\mathbf{x} = \left(x_0, x_1, \ldots, x_7\right)``

 in 8-dimensional pattern space.

One proceeds by generating a representative tracks sample and building up the covariance matrix $\mathsf{C}$. Its eigenvectors and eigenvalues are computed by standard methods, and thus a new basis is obtained for the original 8-dimensional space the expansion of the prototypes, 

``\mathbf{x}_m = \sum^7_{i=0} a_{m_i} \mathbf{e}_i
  \quad
  \mbox{where}
  \quad
  a_{m_i} = \mathbf{x}^T\bullet\mathbf{e}_i``

 allows the study of the behavior of the coefficients $a_{m_i}$ for all the tracks of the sample. The eigenvectors which are insignificant for the trajectory description in the expansion will have their corresponding coefficients $a_{m_i}$ close to zero for all the prototypes.

On one hand, a reduction of the dimensionality is then obtained by omitting these least significant vectors in the subsequent analysis.

On the other hand, in the analysis of real data, these least significant variables(?) can be used for the pattern recognition problem of extracting the valid combinations of coordinates describing a true trajectory from the set of all possible wrong combinations.

The program described here performs this principal components analysis on a sample of data provided by the user. It computes the covariance matrix, its eigenvalues ands corresponding eigenvectors and exhibits the behavior of the principal components $a_{m_i}$, thus providing to the user all the means of understanding their data.

## Principal Components Method

Let's consider a sample of $M$ prototypes each being characterized by $P$ variables $x_0, x_1, \ldots, x_{P-1}$. Each prototype is a point, or a column vector, in a $P$-dimensional <i>[Pattern](@ref) space</i>. 

``\mathbf{x} = \left[\thebegin{array}{c}
    x_0\\x_1\\\vdots\\x_{P-1}\theend{array}\right]\,,``

 where each $x_n$ represents the particular value associated with the $n$-dimension.

Those $P$ variables are the quantities accessible to the experimentalist, but are not necessarily the most significant for the classification purpose.

The *Principal Components Method* consists of applying a linear* transformation to the original variables. This transformation is described by an orthogonal matrix and is equivalent to a rotation of the original pattern space into a new set of coordinate vectors, which hopefully provide easier feature identification and dimensionality reduction.

Let's define the covariance matrix: 

``\mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle
  \quad\mbox{where}\quad
  \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,``

 and the brackets indicate mean value over the sample of $M$ prototypes.

This matrix $\mathsf{C}$ is real, positive definite, symmetric, and will have all its eigenvalues greater then zero. It will now be show that among the family of all the complete orthonormal bases of the pattern space, the base formed by the eigenvectors of the covariance matrix and belonging to the largest eigenvalues, corresponds to the most significant features of the description of the original prototypes.

let the prototypes be expanded on into a set of $N$ basis vectors $\mathbf{e}_n, n=0,\ldots,N,N+1, \ldots, P-1$ 

``\mathbf{y}_i = \sum^N_{i=0} a_{i_n} \mathbf{e}_n,
  \quad
  i = 1, \ldots, M,
  \quad
  N < P-1``

 The 'best' feature coordinates $\mathbf{e}_n$, spanning a *feature space*, will be obtained by minimizing the error due to this truncated expansion, i.e., 

``\min\left(E_N\right) =
  \min\left[\left\langle\left(\mathbf{y}_i - \sum^N_{i=0} a_{i_n} \mathbf{e}_n\right)^2\right\rangle\right]``

 with the conditions: 

``\mathbf{e}_k\bullet\mathbf{e}_j = \delta_{jk} =
  \left\{\thebegin{array}{rcl}
    1 & \mbox{for} & k = j\\
    0 & \mbox{for} & k \neq j
  \theend{array}\right.``

 Multiplying (3) by $\mathbf{e}^T_n$ using (5), we get 

``a_{i_n} = \mathbf{y}_i^T\bullet\mathbf{e}_n\,,``

 so the error becomes \thebegin{eqnarray*}
  E_N &=&
  \left\langle\left[\sum_{n=N+1}^{P-1}  a_{i_n}\mathbf{e}_n\right]^2\right\rangle\nonumber\\
  &=&
  \left\langle\left[\sum_{n=N+1}^{P-1}  \mathbf{y}_i^T\bullet\mathbf{e}_n\mathbf{e}_n\right]^2\right\rangle\nonumber\\
  &=&
  \left\langle\sum_{n=N+1}^{P-1}  \mathbf{e}_n^T\mathbf{y}_i\mathbf{y}_i^T\mathbf{e}_n\right\rangle\nonumber\\
  &=&
  \sum_{n=N+1}^{P-1}  \mathbf{e}_n^T\mathsf{C}\mathbf{e}_n
\theend{eqnarray*} The minimization of the sum in (7) is obtained when each term $\mathbf{e}_n^\mathsf{C}\mathbf{e}_n$ is minimum, since $\mathsf{C}$ is positive definite. By the method of Lagrange multipliers, and the condition (5), we get 

``E_N = \sum^{P-1}_{n=N+1} \left(\mathbf{e}_n^T\mathsf{C}\mathbf{e}_n -
    l_n\mathbf{e}_n^T\bullet\mathbf{e}_n + l_n\right)``

 The minimum condition $\frac{dE_N}{d\mathbf{e}^T_n} = 0$ leads to the equation 

``\mathsf{C}\mathbf{e}_n = l_n\mathbf{e}_n\,,``

 which shows that $\mathbf{e}_n$ is an eigenvector of the covariance matrix $\mathsf{C}$ with eigenvalue $l_n$. The estimated minimum error is then given by 

``E_N \sim \sum^{P-1}_{n=N+1} \mathbf{e}_n^T\bullet l_n\mathbf{e}_n
      = \sum^{P-1}_{n=N+1}  l_n\,,``

 where $l_n,\,n=N+1,\ldots,P$ $l_n,\,n=N+1,\ldots,P-1$ are the eigenvalues associated with the omitted eigenvectors in the expansion (3). Thus, by choosing the $N$ largest eigenvalues, and their associated eigenvectors, the error $E_N$ is minimized.

The transformation matrix to go from the pattern space to the feature space consists of the ordered eigenvectors $\mathbf{e}_1,\ldots,\mathbf{e}_P$ $\mathbf{e}_0,\ldots,\mathbf{e}_{P-1}$ for its columns 

``\mathsf{T} = \left[
    \thebegin{array}{cccc}
      \mathbf{e}_0 &
      \mathbf{e}_1 &
      \vdots &
      \mathbf{e}_{P-1}
    \theend{array}\right]
  = \left[
    \thebegin{array}{cccc}
      \mathbf{e}_{0_0} &  \mathbf{e}_{1_0} & \cdots &  \mathbf{e}_{{P-1}_0}\\
      \mathbf{e}_{0_1} &  \mathbf{e}_{1_1} & \cdots &  \mathbf{e}_{{P-1}_1}\\
      \vdots        &  \vdots        & \ddots &  \vdots \\
      \mathbf{e}_{0_{P-1}} &  \mathbf{e}_{1_{P-1}} & \cdots &  \mathbf{e}_{{P-1}_{P-1}}\\
    \theend{array}\right]``

 This is an orthogonal transformation, or rotation, of the pattern space and feature selection results in ignoring certain coordinates in the transformed space.

Christian Holm August 2000, CERN

Related functions: [`AddRow`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`GetCovarianceMatrix`](@ref), [`GetEigenValues`](@ref), [`GetEigenVectors`](@ref), [`GetHistograms`](@ref), [`GetMeanValues`](@ref), [`GetRow`](@ref), [`GetSigmas`](@ref), [`GetUserData`](@ref), [`IsFolder`](@ref), [`MakeCode`](@ref), [`MakeHistograms`](@ref), [`MakeMethods`](@ref), [`MakePrincipals`](@ref), [`P2X`](@ref), [`Print`](@ref), [`SumOfSquareResiduals`](@ref), [`TPrincipal`](@ref), [`Test`](@ref), [`X2P`](@ref)
""" TPrincipal

# Wrapper of TTreeFriendLeafIter
@trydoc raw"""
    ROOT.TTreeFriendLeafIter

Iterator on all the leaves in a [TTree](@ref) and its friend.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TTreeFriendLeafIter`](@ref), [`assign`](@ref)
""" TTreeFriendLeafIter

# Wrapper of TLeafB
@trydoc raw"""
    ROOT.TLeafB

A [TLeaf](@ref) for an 8 bit Integer data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafB`](@ref)
""" TLeafB

# Wrapper of TLeafC
@trydoc raw"""
    ROOT.TLeafC

A [TLeaf](@ref) for a variable length string.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValueString`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafC`](@ref)
""" TLeafC

# Wrapper of TLeafD
@trydoc raw"""
    ROOT.TLeafD

A [TLeaf](@ref) for a 64 bit floating point data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`TLeafD`](@ref)
""" TLeafD

# Wrapper of TLeafD32
@trydoc raw"""
    ROOT.TLeafD32

A [TLeaf](@ref) for a 24 bit truncated floating point data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`TLeafD32`](@ref)
""" TLeafD32

# Wrapper of TBranchElement
@trydoc raw"""
    ROOT.TBranchElement

A Branch for the case of an object.



Related functions: [`Browse`](@ref), [`FindBranch`](@ref), [`FindLeaf`](@ref), [`GetAddress`](@ref), [`GetBranchCount2`](@ref), [`GetBranchCount`](@ref), [`GetBranchOffset`](@ref), [`GetCheckSum`](@ref), [`GetClassName`](@ref), [`GetClassVersion`](@ref), [`GetClass`](@ref), [`GetClonesName`](@ref), [`GetCollectionProxy`](@ref), [`GetCurrentClass`](@ref), [`GetEntry`](@ref), [`GetExpectedType`](@ref), [`GetFullName`](@ref), [`GetID`](@ref), [`GetIconName`](@ref), [`GetInfo`](@ref), [`GetMakeClass`](@ref), [`GetMaximum`](@ref), [`GetNdata`](@ref), [`GetObject`](@ref), [`GetOnfileObject`](@ref), [`GetParentName`](@ref), [`GetStreamerType`](@ref), [`GetTargetClass`](@ref), [`GetTypeName`](@ref), [`GetType`](@ref), [`GetTypedValue`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`IsBranchFolder`](@ref), [`IsFolder`](@ref), [`IsObjectOwner`](@ref), [`Notify`](@ref), [`PrintValue`](@ref), [`Print`](@ref), [`ResetAddress`](@ref), [`ResetAfterMerge`](@ref), [`ResetDeleteObject`](@ref), [`ResetInitInfo`](@ref), [`Reset`](@ref), [`SetAddress`](@ref), [`SetBasketSize`](@ref), [`SetBranchFolder`](@ref), [`SetClassName`](@ref), [`SetMakeClass`](@ref), [`SetMissing`](@ref), [`SetObject`](@ref), [`SetOffset`](@ref), [`SetParentClass`](@ref), [`SetParentName`](@ref), [`SetTargetClass`](@ref), [`SetType`](@ref), [`SetupAddresses`](@ref), [`TBranchElement`](@ref), [`Unroll`](@ref), [`UpdateFile`](@ref)
""" TBranchElement

# Wrapper of TLeafElement
@trydoc raw"""
    ROOT.TLeafElement

A [TLeaf](@ref) for the general case when using the branches created via a [TStreamerInfo](@ref) (i.e.

using [TBranchElement](@ref)).

Related functions: [`CanGenerateOffsetArray`](@ref), [`ClassDefOverride`](@ref), [`GenerateOffsetArrayBase`](@ref), [`GetDeserializeType`](@ref), [`GetFullName`](@ref), [`GetID`](@ref), [`GetLen`](@ref), [`GetMaximum`](@ref), [`GetMethodCall`](@ref), [`GetNdata`](@ref), [`GetTypeName`](@ref), [`GetTypedValueSubArray`](@ref), [`GetValueLong64`](@ref), [`GetValueLongDouble`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`IncludeRange`](@ref), [`IsOnTerminalBranch`](@ref), [`PrintValue`](@ref), [`ReadBasketFast`](@ref), [`SetLeafCount`](@ref), [`TLeafElement`](@ref)
""" TLeafElement

# Wrapper of TMethodCall
@trydoc raw"""
    ROOT.TMethodCall

Method or function calling interface.

Objects of this class contain the (CINT) environment to call a global_ function or a method for an object of a specific class with the desired arguments. This class is especially useful when a method has to be called more times for different objects and/or with different arguments. If a function or method needs to be called only once one better uses [TInterpreter!Execute()](@ref).

A limitation is known with the present implementation: failures can occur if parameters involve temporary object construction.

Related functions: [`CallDtorOnly`](@ref), [`Clone`](@ref), [`Execute`](@ref), [`GetCallFunc`](@ref), [`GetMethodName`](@ref), [`GetMethod`](@ref), [`GetParams`](@ref), [`GetProto`](@ref), [`InitWithPrototype`](@ref), [`Init`](@ref), [`IsValid`](@ref), [`ResetParam`](@ref), [`ReturnType`](@ref), [`SetParamPtrs`](@ref), [`SetParam`](@ref), [`SetParams`](@ref), [`TMethodCall`](@ref), [`assign`](@ref)
""" TMethodCall

# Wrapper of TLeafF
@trydoc raw"""
    ROOT.TLeafF

A [TLeaf](@ref) for a 32 bit floating point data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`TLeafF`](@ref)
""" TLeafF

# Wrapper of TLeafF16
@trydoc raw"""
    ROOT.TLeafF16

A [TLeaf](@ref) for a 24 bit truncated floating point data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`TLeafF16`](@ref)
""" TLeafF16

# Wrapper of TLeafG
@trydoc raw"""
    ROOT.TLeafG

A [TLeaf](@ref) for a 64 bit Integer data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValueLong64`](@ref), [`GetValueLongDouble`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafG`](@ref)
""" TLeafG

# Wrapper of TLeafI
@trydoc raw"""
    ROOT.TLeafI

A [TLeaf](@ref) for an Integer data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafI`](@ref)
""" TLeafI

# Wrapper of TLeafL
@trydoc raw"""
    ROOT.TLeafL

A [TLeaf](@ref) for a 64 bit Integer data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValueLong64`](@ref), [`GetValueLongDouble`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafL`](@ref)
""" TLeafL

# Wrapper of TLeafO
@trydoc raw"""
    ROOT.TLeafO

A [TLeaf](@ref) for a bool data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafO`](@ref)
""" TLeafO

# Wrapper of TLeafObject
@trydoc raw"""
    ROOT.TLeafObject

A [TLeaf](@ref) for a general object derived from [TObject](@ref).



Related functions: [`CanGenerateOffsetArray`](@ref), [`ClassDefOverride`](@ref), [`FillBasket`](@ref), [`GenerateOffsetArrayBase`](@ref), [`GetClass`](@ref), [`GetMethodCall`](@ref), [`GetObject`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`IsOnTerminalBranch`](@ref), [`IsVirtual`](@ref), [`Notify`](@ref), [`PrintValue`](@ref), [`ReadBasket`](@ref), [`SetAddress`](@ref), [`SetVirtual`](@ref), [`TLeafObject`](@ref)
""" TLeafObject

# Wrapper of TLeafS
@trydoc raw"""
    ROOT.TLeafS

A [TLeaf](@ref) for a 16 bit Integer data type.



Related functions: [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GetDeserializeType`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetTypeName`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`SetAddress`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`TLeafS`](@ref)
""" TLeafS

# Wrapper of TBranchObject
@trydoc raw"""
    ROOT.TBranchObject

A Branch for the case of an object.



Related functions: [`Browse`](@ref), [`GetClassName`](@ref), [`GetEntry`](@ref), [`GetExpectedType`](@ref), [`GetObjClassName`](@ref), [`IsFolder`](@ref), [`Print`](@ref), [`ResetAfterMerge`](@ref), [`Reset`](@ref), [`SetAddress`](@ref), [`SetAutoDelete`](@ref), [`SetBasketSize`](@ref), [`SetupAddresses`](@ref), [`TBranchObject`](@ref), [`UpdateAddress`](@ref)
""" TBranchObject

# Wrapper of TBranchSTL
@trydoc raw"""
    ROOT.TBranchSTL

A Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while storing them in split mode.



Related functions: [`Browse`](@ref), [`FillImpl`](@ref), [`FillLeavesImpl`](@ref), [`GetClassName`](@ref), [`GetEntry`](@ref), [`GetExpectedType`](@ref), [`GetInfo`](@ref), [`IsFolder`](@ref), [`Print`](@ref), [`SetAddress`](@ref), [`TBranchSTL`](@ref)
""" TBranchSTL

# Wrapper of TTreeReader
@trydoc raw"""
    ROOT.TTreeReader

A simple, robust and fast interface to read values from [ROOT](@ref) columnar datasets such as [TTree](@ref), [TChain](@ref) or [TNtuple](@ref).

[TTreeReader](@ref) is associated to [TTreeReaderValue](@ref) and [TTreeReaderArray](@ref) which are handles to concretely access the information in the dataset.

Example code can be found in

- tutorials/tree/hsimpleReader.C
- tutorials/tree/h1analysisTreeReader.C
- [This example](https://github.com/root-project/roottest/tree/master/root/tree/reader)

You can generate a skeleton of `TTreeReaderValue<T>` and `TTreeReaderArray<T>` declarations for all of a tree's branches using `TTree!MakeSelector()`.

Roottest contains an [example](https://github.com/root-project/roottest/tree/master/root/tree/reader) showing the full power.

A simpler analysis example can be found below: it histograms a function of the px and py branches.

    // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C)
    #include "TFile.h"
    #include "TH1F.h"
    #include "TTreeReader.h"
    #include "TTreeReaderValue.h"
    void hsimpleReader() {
       // Create a histogram for the values we read.
       TH1F("h1", "ntuple", 100, -4, 4);
       // Open the file containing the tree.
       TFile *myFile = TFile!Open("$ROOTSYS/tutorials/hsimple.root");
       // Create a TTreeReader for the tree, for instance by passing the
       // TTree's name and the TDirectory / TFile it is in.
       TTreeReader myReader("ntuple", myFile);
       // The branch "px" contains floats; access them as myPx.
       TTreeReaderValue<Float_t> myPx(myReader, "px");
       // The branch "py" contains floats, too; access those as myPy.
       TTreeReaderValue<Float_t> myPy(myReader, "py");
       // Loop over all entries of the TTree or TChain.
       while (myReader.Next()) {
          // Just access the data as if myPx and myPy were iterators (note the '*'
          // in front of them):
          myHist->Fill(*myPx + *myPy);
       }
       myHist->Draw();
    }

(C++ version of the code)

A more complete example including error handling and a few combinations of [TTreeReaderValue](@ref) and [TTreeReaderArray](@ref) would look like this:

    #include <TFile.h>
    #include <TH1.h>
    #include <TTreeReader.h>
    #include <TTreeReaderValue.h>
    #include <TTreeReaderArray.h>
    #include "TriggerInfo.h"
    #include "Muon.h"
    #include "Tau.h"
    #include <vector>
    #include <iostream>
    bool CheckValue(ROOT!Internal!TTreeReaderValueBase& value) {
       if (value.GetSetupStatus() < 0) {
          std!cerr << "Error " << value.GetSetupStatus()
                    << "setting up reader for " << value.GetBranchName() << '\n';
          return false;
       }
       return true;
    }
    // Analyze the tree "MyTree" in the file passed into the function.
    // Returns false in case of errors.
    bool analyze(TFile* file) {
       // Create a TTreeReader named "MyTree" from the given TDirectory.
       // The TTreeReader gives access to the TTree to the TTreeReaderValue and
       // TTreeReaderArray objects. It knows the current entry number and knows
       // how to iterate through the TTree.
       TTreeReader reader("MyTree", file);
       // Read a single float value in each tree entries:
       TTreeReaderValue<float> weight(reader, "event.weight");
       // Read a TriggerInfo object from the tree entries:
       TTreeReaderValue<TriggerInfo> triggerInfo(reader, "triggerInfo");
       //Read a vector of Muon objects from the tree entries:
       TTreeReaderValue<std!vector<Muon>> muons(reader, "muons");
       //Read the pT for all jets in the tree entry:
       TTreeReaderArray<double> jetPt(reader, "jets.pT");
       // Read the taus in the tree entry:
       TTreeReaderArray<Tau> taus(reader, "taus");
       // Now iterate through the TTree entries and fill a histogram.
       TH1F("hist", "TTreeReader example histogram", 10, 0., 100.);
       bool firstEntry = true;
       while (reader.Next()) {
          if (firstEntry) {
             // Check that branches exist and their types match our expectation.
             if (!CheckValue(weight)) return false;
             if (!CheckValue(triggerInfo)) return false;
             if (!CheckValue(muons)) return false;
             if (!CheckValue(jetPt)) return false;
             if (!CheckValue(taus)) return false;
             firstentry = false;
          }
          // Access the TriggerInfo object as if it's a pointer.
          if (!triggerInfo->hasMuonL1())
             continue;
          // Ditto for the vector<Muon>.
          if (!muons->size())
             continue;
          // Access the jetPt as an array, whether the TTree stores this as
          // a std!vector, std!list, TClonesArray or Jet* C-style array, with
          // fixed or variable array size.
          if (jetPt.GetSize() < 2 || jetPt[0] < 100)
             continue;
          // Access the array of taus.
          if (!taus.IsEmpty()) {
             // Access a float value - need to dereference as TTreeReaderValue
             // behaves like an iterator
             float currentWeight = *weight;
             for (const Tau& tau: taus) {
                hist->Fill(tau.eta(), currentWeight);
             }
          }
       } // TTree entry / event loop
       // Return true if we have iterated through all entries.
       return reader.GetEntryStatus() == TTreeReader!kEntryBeyondEnd;
    }

(C++ version of the code)

Related functions: [`GetCurrentEntry`](@ref), [`GetEntries`](@ref), [`GetEntryList`](@ref), [`GetEntryStatus`](@ref), [`GetTree`](@ref), [`IsChain`](@ref), [`IsInvalid`](@ref), [`Notify`](@ref), [`SetTree`](@ref), [`TTreeReader`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TTreeReader

# Wrapper of TTreeReaderValue
@trydoc raw"""
    ROOT.TTreeReaderValue

An interface for reading values stored in [ROOT](@ref) columnar datasets.

The [TTreeReaderValue](@ref) is a type-safe tool to be used in association with a [TTreeReader](@ref) to access the values stored in [TTree](@ref), [TNtuple](@ref) and [TChain](@ref) datasets. [TTreeReaderValue](@ref) can be also used to access collections such as `std!vector`s or [TClonesArray](@ref) stored in columnar datasets but it is recommended to use [TTreeReaderArray](@ref) instead as it offers several advantages.

See the documentation of [TTreeReader](@ref) for more details and examples.

Related functions: [`Base.getindex`](@ref), [`Get`](@ref), [`TTreeReaderValue`](@ref), [`arrow`](@ref)
""" TTreeReaderValue

# Wrapper of TTreeReaderArray
@trydoc raw"""
    ROOT.TTreeReaderArray

An interface for reading collections stored in [ROOT](@ref) columnar datasets.

The [TTreeReaderArray](@ref) is a type-safe tool to be used in association with a [TTreeReader](@ref) to access the collections stored in [TTree](@ref), [TNtuple](@ref) and [TChain](@ref) datasets. In order to access values which are not collections, the [TTreeReaderValue](@ref) class can be used.

See the documentation of [TTreeReader](@ref) for more details and examples.

Related functions: [`At`](@ref), [`Base.getindex`](@ref), [`TTreeReaderArray`](@ref), [`cbegin`](@ref), [`cend`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TTreeReaderArray

# Wrapper of TPad
@trydoc raw"""
    ROOT.TPad

The most important graphics class in the [ROOT](@ref) system.

A Pad is contained in a Canvas.

A Pad may contain other pads (unlimited pad hierarchy).

A pad is a linked list of primitives of any type (graphics objects, histograms, detectors, tracks, etc.).

Adding a new element into a pad is in general performed by the Draw member function of the object classes.

It is important to realize that the pad is a linked list of references to the original object. For example, in case of a histogram, the histogram.Draw() operation only stores a reference to the histogram object and not a graphical representation of this histogram. When the mouse is used to change (say the bin content), the bin content of the original histogram is changed.

The convention used in [ROOT](@ref) is that a Draw operation only adds a reference to the object. The effective drawing is performed when the canvas receives a signal to be painted.

![https://root.cern/doc/v636/gpad_pad1.png](https://root.cern/doc/v636/gpad_pad1.png)

This signal is generally sent when typing carriage return in the command input or when a graphical operation has been performed on one of the pads of this canvas. When a Canvas/Pad is repainted, the member function Paint for all objects in the Pad linked list is invoked.

![https://root.cern/doc/v636/gpad_pad2.png](https://root.cern/doc/v636/gpad_pad2.png)

When the mouse is moved on the Pad, The member function DistancetoPrimitive is called for all the elements in the pad. DistancetoPrimitive returns the distance in pixels to this object.

When the object is within the distance window, the member function ExecuteEvent is called for this object.

In ExecuteEvent, move, changes can be performed on the object.

For examples of DistancetoPrimitive and ExecuteEvent functions, see classes 

    TLine!DistancetoPrimitive, TLine!ExecuteEvent
    TBox!DistancetoPrimitive,  TBox!ExecuteEvent
    TH1!DistancetoPrimitive,   TH1!ExecuteEvent

(C++ version of the code)

 A Pad supports linear and log scales coordinate systems. The transformation coefficients are explained in [TPad!ResizePad](@ref).

Related functions: [`AbsCoordinates`](@ref), [`AbsPixeltoXY`](@ref), [`AbsPixeltoX`](@ref), [`AbsPixeltoY`](@ref), [`AddExec`](@ref), [`AutoExec`](@ref), [`Browse`](@ref), [`BuildLegend`](@ref), [`Clear`](@ref), [`ClipPolygon`](@ref), [`Clip`](@ref), [`ClippingCode`](@ref), [`CloseToolTip`](@ref), [`Close`](@ref), [`Closed`](@ref), [`CopyPixmap`](@ref), [`CopyPixmaps`](@ref), [`CreateToolTip`](@ref), [`DeleteExec`](@ref), [`DeleteToolTip`](@ref), [`DivideSquare`](@ref), [`Divide`](@ref), [`DrawClassObject`](@ref), [`DrawCollideGrid`](@ref), [`DrawCrosshair`](@ref), [`DrawFrame`](@ref), [`Draw`](@ref), [`EventPave`](@ref), [`ExecuteEventAxis`](@ref), [`FindObject`](@ref), [`GetAbsHNDC`](@ref), [`GetAbsWNDC`](@ref), [`GetAbsXlowNDC`](@ref), [`GetAbsYlowNDC`](@ref), [`GetAspectRatio`](@ref), [`GetBBoxCenter`](@ref), [`GetBBox`](@ref), [`GetBorderMode`](@ref), [`GetBorderSize`](@ref), [`GetCanvasID`](@ref), [`GetCanvasImp`](@ref), [`GetCanvas`](@ref), [`GetCrosshair`](@ref), [`GetEventX`](@ref), [`GetEventY`](@ref), [`GetEvent`](@ref), [`GetFrame`](@ref), [`GetGLDevice`](@ref), [`GetGridx`](@ref), [`GetGridy`](@ref), [`GetHNDC`](@ref), [`GetHighLightColor`](@ref), [`GetListOfExecs`](@ref), [`GetListOfPrimitives`](@ref), [`GetLogx`](@ref), [`GetLogy`](@ref), [`GetLogz`](@ref), [`GetMother`](@ref), [`GetName`](@ref), [`GetNumber`](@ref), [`GetPadPaint`](@ref), [`GetPadPar`](@ref), [`GetPadPointer`](@ref), [`GetPadSave`](@ref), [`GetPad`](@ref), [`GetPainter`](@ref), [`GetPhi`](@ref), [`GetPixmapID`](@ref), [`GetPrimitive`](@ref), [`GetRangeAxis`](@ref), [`GetRange`](@ref), [`GetSelectedPad`](@ref), [`GetSelected`](@ref), [`GetTheta`](@ref), [`GetTickx`](@ref), [`GetTicky`](@ref), [`GetTitle`](@ref), [`GetUxmax`](@ref), [`GetUxmin`](@ref), [`GetUymax`](@ref), [`GetUymin`](@ref), [`GetView3D`](@ref), [`GetView`](@ref), [`GetViewer3D`](@ref), [`GetVirtCanvas`](@ref), [`GetWNDC`](@ref), [`GetWh`](@ref), [`GetWw`](@ref), [`GetX1`](@ref), [`GetX2`](@ref), [`GetXlowNDC`](@ref), [`GetY1`](@ref), [`GetY2`](@ref), [`GetYlowNDC`](@ref), [`HasCrosshair`](@ref), [`HasFixedAspectRatio`](@ref), [`HasViewer3D`](@ref), [`Hash`](@ref), [`HighLight`](@ref), [`IncrementPaletteColor`](@ref), [`IsBatch`](@ref), [`IsEditable`](@ref), [`IsFolder`](@ref), [`IsModified`](@ref), [`IsRetained`](@ref), [`IsVertical`](@ref), [`IsWeb`](@ref), [`ModifiedUpdate`](@ref), [`Modified`](@ref), [`NextPaletteColor`](@ref), [`OpaqueMoving`](@ref), [`OpaqueResizing`](@ref), [`PadtoX`](@ref), [`PadtoY`](@ref), [`PaintBox`](@ref), [`PaintFillAreaHatches`](@ref), [`PaintFillAreaNDC`](@ref), [`PaintFillArea`](@ref), [`PaintHatches`](@ref), [`PaintLine3D`](@ref), [`PaintLineNDC`](@ref), [`PaintLine`](@ref), [`PaintModified`](@ref), [`PaintPadFrame`](@ref), [`PaintPolyLine3D`](@ref), [`PaintPolyLineNDC`](@ref), [`PaintPolyLine`](@ref), [`PaintPolyMarker`](@ref), [`PaintTextNDC`](@ref), [`PaintText`](@ref), [`Paint`](@ref), [`Pick`](@ref), [`PixeltoXY`](@ref), [`PixeltoX`](@ref), [`PixeltoY`](@ref), [`PlaceBox`](@ref), [`Pop`](@ref), [`Print`](@ref), [`RangeAxis`](@ref), [`RangeChanged`](@ref), [`Range`](@ref), [`RecordLatex`](@ref), [`RecordPave`](@ref), [`RecursiveRemove`](@ref), [`RedrawAxis`](@ref), [`ReleaseViewer3D`](@ref), [`ResetToolTip`](@ref), [`ResetView3D`](@ref), [`ResizePad`](@ref), [`Resized`](@ref), [`SaveAs`](@ref), [`SetAttFillPS`](@ref), [`SetAttLinePS`](@ref), [`SetAttMarkerPS`](@ref), [`SetAttTextPS`](@ref), [`SetBBoxCenterX`](@ref), [`SetBBoxCenterY`](@ref), [`SetBBoxCenter`](@ref), [`SetBBoxX1`](@ref), [`SetBBoxX2`](@ref), [`SetBBoxY1`](@ref), [`SetBBoxY2`](@ref), [`SetBorderMode`](@ref), [`SetBorderSize`](@ref), [`SetCanvasSize`](@ref), [`SetCanvas`](@ref), [`SetCopyGLDevice`](@ref), [`SetCrosshair`](@ref), [`SetCursor`](@ref), [`SetDoubleBuffer`](@ref), [`SetDrawOption`](@ref), [`SetEditable`](@ref), [`SetFillStyle`](@ref), [`SetFixedAspectRatio`](@ref), [`SetGLDevice`](@ref), [`SetGrid`](@ref), [`SetGridx`](@ref), [`SetGridy`](@ref), [`SetLogx`](@ref), [`SetLogy`](@ref), [`SetLogz`](@ref), [`SetName`](@ref), [`SetNumber`](@ref), [`SetPad`](@ref), [`SetPhi`](@ref), [`SetSelected`](@ref), [`SetTheta`](@ref), [`SetTicks`](@ref), [`SetTickx`](@ref), [`SetTicky`](@ref), [`SetTitle`](@ref), [`SetToolTipText`](@ref), [`SetVertical`](@ref), [`SetView`](@ref), [`SetViewer3D`](@ref), [`ShowGuidelines`](@ref), [`StartEditing`](@ref), [`TPad!DrawColorTable`](@ref), [`TPad!GetMaxPickDistance`](@ref), [`TPad!SetMaxPickDistance`](@ref), [`TPad`](@ref), [`UpdateAsync`](@ref), [`Update`](@ref), [`UseCurrentStyle`](@ref), [`UtoAbsPixel`](@ref), [`UtoPixel`](@ref), [`VtoAbsPixel`](@ref), [`VtoPixel`](@ref), [`WaitPrimitive`](@ref), [`XYtoAbsPixel`](@ref), [`XYtoPixel`](@ref), [`XtoAbsPixel`](@ref), [`XtoPad`](@ref), [`XtoPixel`](@ref), [`YtoAbsPixel`](@ref), [`YtoPad`](@ref), [`YtoPixel`](@ref), [`cd`](@ref), [`ls`](@ref), [`x3d`](@ref)
""" TPad

# Wrapper of TRandom
@trydoc raw"""
    ROOT.TRandom

This is the base class for the [ROOT](@ref) Random number generators.

This class defines the [ROOT](@ref) Random number interface and it should not be instantiated directly but used via its derived classes. The generator provided in [TRandom](@ref) itself is a LCG (Linear Congruential Generator), the [BSD rand generator](https://www.gnu.org/software/gsl/manual/html_node/Unix-random-number-generators.html), that it should not be used because its period is only 2**31, i.e. approximately 2 billion events, that can be generated in just few seconds.

To generate random numbers, one should use one of the derived classes, which are:

- [TRandom3](@ref): it is based on the "Mersenne Twister generator", it is fast and a very long period of about $10^{6000}$. However it fails some of the most stringent tests of the [TestU01 suite](http://simul.iro.umontreal.ca/testu01/tu01.html). In addition this generator provide only numbers with 32 random bits, which might be not sufficient for some application based on double or extended precision. This generator is however used in [ROOT](@ref) used to instantiate the global_ pointer to the [ROOT](@ref) generator, *gRandom*.
- [TRandomRanluxpp](@ref) : New implementation of the Ranlux generator algorithm based on a fast modular multiplication of 576 bits. This new implementation is built on the idea and the original code of Alexei Sibidanov, described in his [paper](https://arxiv.org/abs/1705.03123). It generates random numbers with 52 bit precision (double precision) and it has an higher luxury level than the original Ranlux generator (`p = 2048` instead of `p=794`).
- [TRandomMixMax](@ref): Generator based on the family of the MIXMAX matrix generators (see the [MIXMAX HEPFORGE Web page](https://mixmax.hepforge.org) and the documentation of the class [ROOT!Math!MixMaxEngine](@ref) for more information), that are base on the Asanov dynamical C systems. This generator has a state of N=240 64 bit integers, proof random properties, it provides 61 random bits and it has a very large period ( $10^{4839}$). Furthermore, it provides the capability to be seeded with the guarantee that, for each given different seed, a different sequence of random numbers will be generated. The only drawback is that the seeding time is time consuming, of the order of 0.1 ms, while the time to generate a number is few ns (more than 10000 faster).
- [TRandomMixMax17](@ref): Another MixMax generator, but with a smaller state, N=17, and this results in a smaller entropy than the generator with N=240. However, it has the same seeding capabilities, with a much faster seeding time (about 200 times less than TRandomMixMax240 and comparable to [TRandom3](@ref)).
- [TRandomMixMax256](@ref) : A variant of the MIXMAX generators, based on a state of N=256, and described in the [2015 paper](http://arxiv.org/abs/1403.5355). This implementation has been modified with respect to the paper, by skipping 2 internal iterations, to provide improved random properties.
- [TRandomMT64](@ref) : Generator based on a the Mersenne-Twister generator with 64 bits, using the implementation provided by the standard library ( [std!mt19937_64](http://www.cplusplus.com/reference/random/mt19937_64/) )
- [TRandom1](@ref) based on the RANLUX algorithm, has mathematically proven random proprieties and a period of about $10{171}$. It is however much slower than the others and it has only 24 random bits. It can be constructed with different luxury levels.
- [TRandomRanlux48](@ref) : Generator based on a the RanLux generator with 48 bits and highest luxury level using the implementation provided by the standard library ([std!ranlux48](http://www.cplusplus.com/reference/random/ranlux48/)). The drawback of this generator is its slow generation time.
- [TRandom2](@ref) is based on the Tausworthe generator of L'Ecuyer, and it has the advantage of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is 10**26.

Using the template [TRandomGen](@ref) class (template on the contained Engine type), it is possible to add any generator based on the standard C++ random library (see the C++ [random](http://www.cplusplus.com/reference/random/) documentation.) or different variants of the MIXMAX generator using the [ROOT!Math!MixMaxEngine](@ref). Some of the listed generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template [TRandomGen](@ref) class.

Please note also that this class ([TRandom](@ref)) implements also a very simple generator (linear congruential) with period = $10^9$, known to have defects (the lower random bits are correlated) and it is failing the majority of the random number generator tests. Therefore it should NOT be used in any statistical study.

The following table shows some timings (in nanoseconds/call) for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:

- [TRandom](@ref) 3 ns/call (but this is a very BAD Generator, not to be used)
- [TRandom2](@ref) 5 ns/call
- [TRandom3](@ref) 5 ns/call
- [TRandomMixMax](@ref) 6 ns/call
- [TRandomMixMax17](@ref) 6 ns/call
- [TRandomMT64](@ref) 9 ns/call
- [TRandomMixMax256](@ref) 10 ns/call
- [TRandomRanluxpp](@ref) 14 ns/call
- [TRandom1](@ref) 80 ns/call
- [TRandomRanlux48](@ref) 250 ns/call

The following methods are provided to generate random numbers distributed according to some basic distributions:

- [Exp(Double_t tau)](@ref)
- [Integer(UInt_t imax)](@ref)
- [Gaus(Double_t mean, Double_t sigma)](@ref)
- [Rndm()](@ref)
- [Uniform(Double_t)](@ref)
- [Landau(Double_t mean, Double_t sigma)](@ref)
- [Poisson(Double_t mean)](@ref)
- [Binomial(Int_t ntot, Double_t prob)](@ref)

Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in [TF1](@ref), [TF2](@ref) or [TF3](@ref) objects can also be generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : 

     TF1
    *f1 = new TF1("f1","abs(sin(x)/x)*sqrt(x)",0,10); double r = f1->GetRandom(); 

(C++ version of the code)

 or you can use the UNURAN package. You need in this case to initialize UNURAN to the function you would like to generate. 

    TUnuran u;
     u.Init(TUnuranDistrCont(f1));
     double r = u.Sample();

(C++ version of the code)

The techniques of using directly a [TF1](@ref),2 or 3 function is powerful and can be used to generate numbers in the defined range of the function. Getting a number from a [TF1](@ref),2,3 function is also quite fast. UNURAN is a powerful and flexible tool which contains various methods for generate random numbers for continuous distributions of one and multi-dimension. It requires some set-up (initialization) phase and can be very fast when the distribution parameters are not changed for every call.

The following table shows some timings (in nanosecond/call) for basic functions, [TF1](@ref) functions and using UNURAN obtained running the tutorial math/testrandom.C Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4

    Distribution            nanoseconds/call
                        TRandom  TRandom1 TRandom2 TRandom3
    Rndm..............    5.000  105.000    7.000   10.000
    RndmArray.........    4.000  104.000    6.000    9.000
    Gaus..............   36.000  180.000   40.000   48.000
    Rannor............  118.000  220.000  120.000  124.000
    Landau............   22.000  123.000   26.000   31.000
    Exponential.......   93.000  198.000   98.000  104.000
    Binomial(5,0.5)...   30.000  548.000   46.000   65.000
    Binomial(15,0.5)..   75.000 1615.000  125.000  178.000
    Poisson(3)........   96.000  494.000  109.000  125.000
    Poisson(10).......  138.000 1236.000  165.000  203.000
    Poisson(70).......  818.000 1195.000  835.000  844.000
    Poisson(100)......  837.000 1218.000  849.000  864.000
    GausTF1...........   83.000  180.000   87.000   88.000
    LandauTF1.........   80.000  180.000   83.000   86.000
    GausUNURAN........   40.000  139.000   41.000   44.000
    PoissonUNURAN(10).   85.000  271.000   92.000  102.000
    PoissonUNURAN(100)   62.000  256.000   69.000   78.000

(C++ version of the code)

Note that the time to generate a number from an arbitrary [TF1](@ref) function using [TF1!GetRandom](@ref) or using [TUnuran](@ref) is independent of the complexity of the function.

TH1!FillRandom(TH1 *) or TH1!FillRandom(const char *tf1name) can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram or from an existing function.

Note this interesting feature when working with objects. You can use several [TRandom](@ref) objects, each with their "independent" random sequence. For example, one can imagine 

    TRandom *eventGenerator = new TRandom();
    TRandom *tracking       = new TRandom();

(C++ version of the code)

 `eventGenerator` can be used to generate the event kinematics. tracking can be used to track the generated particles with random numbers independent from eventGenerator. This very interesting feature gives the possibility to work with simple and very fast random number generators without worrying about random number periodicity as it was the case with Fortran. One can use [TRandom!SetSeed](@ref) to modify the seed of one generator.

A [TRandom](@ref) object may be written to a Root file

- as part of another object
- or with its own key (example: `gRandom->Write("Random")` ) ;

Related functions: [`Binomial`](@ref), [`BreitWigner`](@ref), [`Circle`](@ref), [`Exp`](@ref), [`Gaus`](@ref), [`GetInteger`](@ref), [`GetSeed`](@ref), [`Landau`](@ref), [`PoissonD`](@ref), [`Poisson`](@ref), [`Rannor`](@ref), [`ReadRandom`](@ref), [`RndmArray`](@ref), [`Rndm`](@ref), [`SetSeed`](@ref), [`Sphere`](@ref), [`TRandom`](@ref), [`Uniform`](@ref), [`WriteRandom`](@ref)
""" TRandom

# Wrapper of TDirectoryFile
@trydoc raw"""
    ROOT.TDirectoryFile

A [ROOT](@ref) file is structured in Directories (like a file system).

Each Directory has a list of Keys (see TKeys) and a list of objects in memory. A Key is a small object that describes the type and location of a persistent object in a file. The persistent object may be a directory.

![https://root.cern/doc/v636/pict1_TDirectoryFile_001.png](https://root.cern/doc/v636/pict1_TDirectoryFile_001.png)
 The structure of a file is shown in TFile!TFile

Related functions: [`Add`](@ref), [`AppendKey`](@ref), [`Append`](@ref), [`Browse`](@ref), [`Build`](@ref), [`CloneObject`](@ref), [`Close`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`FillBuffer`](@ref), [`FindKeyAny`](@ref), [`FindKey`](@ref), [`FindObjectAnyFile`](@ref), [`FindObjectAny`](@ref), [`GetBufferSize`](@ref), [`GetCreationDate`](@ref), [`GetDirectory`](@ref), [`GetFile`](@ref), [`GetKey`](@ref), [`GetListOfKeys`](@ref), [`GetModificationDate`](@ref), [`GetNbytesKeys`](@ref), [`GetNkeys`](@ref), [`GetObjectChecked`](@ref), [`GetObjectUnchecked`](@ref), [`GetSeekDir`](@ref), [`GetSeekKeys`](@ref), [`GetSeekParent`](@ref), [`Get`](@ref), [`IsModified`](@ref), [`IsWritable`](@ref), [`OpenFile`](@ref), [`Purge`](@ref), [`ReadAll`](@ref), [`ReadKeys`](@ref), [`ReadTObject`](@ref), [`ResetAfterMerge`](@ref), [`SaveObjectAs`](@ref), [`SaveSelf`](@ref), [`Save`](@ref), [`SetBufferSize`](@ref), [`SetModified`](@ref), [`SetSeekDir`](@ref), [`SetTRefAction`](@ref), [`SetWritable`](@ref), [`Sizeof`](@ref), [`TDirectoryFile`](@ref), [`WriteDirHeader`](@ref), [`WriteKeys`](@ref), [`WriteObjectAny`](@ref), [`WriteTObject`](@ref), [`Write`](@ref), [`cd`](@ref), [`ls`](@ref), [`mkdir`](@ref), [`rmdir`](@ref)
""" TDirectoryFile

# Wrapper of TFileOpenHandle
@trydoc raw"""
    ROOT.TFileOpenHandle

Class holding info about the file being opened.



Related functions: [`GetCompress`](@ref), [`GetNetOpt`](@ref), [`GetOpt`](@ref), [`Matches`](@ref)
""" TFileOpenHandle

# Wrapper of TFitResult
@trydoc raw"""
    ROOT.TFitResult

Extends the ROOT!Fit!Result class with a [TNamed](@ref) inheritance providing easy possibility for I/O.



Related functions: [`Contour`](@ref), [`Error`](@ref), [`GetCorrelationMatrix`](@ref), [`GetCovarianceMatrix`](@ref), [`Print`](@ref), [`Scan`](@ref), [`TFitResult`](@ref)
""" TFitResult

# Wrapper of TFitResultPtr
@trydoc raw"""
    ROOT.TFitResultPtr

Provides an indirection to the [TFitResult](@ref) class and with a semantics identical to a [TFitResult](@ref) pointer, i.e.

it is like a smart pointer to a [TFitResult](@ref). In addition it provides an automatic conversion to an integer. In this way it can be returned from the [TH1!Fit](@ref) method and the change in [TH1!Fit](@ref) be backward compatible.

Related functions: [`Base.getindex`](@ref), [`Get`](@ref), [`TFitResultPtr`](@ref), [`arrow`](@ref), [`assign`](@ref), [`int`](@ref)
""" TFitResultPtr

# Wrapper of TF1
@trydoc raw"""
    ROOT.TF1

1-Dim function class

## TF1: 1-Dim function class

A [TF1](@ref) object is a 1-Dim function defined between a lower and upper limit. The function may be a simple function based on a [TFormula](@ref) expression or a precompiled user function. The function may have associated parameters. [TF1](@ref) graphics function is via the [TH1](@ref) and [TGraph](@ref) drawing functions.

The following types of functions can be created:

1. [Expression using variable x and no parameters](@ref)
2. [Expression using variable x with parameters](@ref)
3. [Lambda Expression with variable x and parameters](@ref)
4. [A general C function with parameters](@ref)
5. [A general C++ function object (functor) with parameters](@ref)
6. [A member function with parameters of a general C++ class](@ref)

### 1 - Expression using variable x and no parameters

#### Case 1: inline expression using standard C++ functions/operators

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF1_001.png](https://root.cern/doc/v636/pict1_TF1_001.png)

#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF1_002.png](https://root.cern/doc/v636/pict1_TF1_002.png)

#### Case 3: inline expression using a user defined CLING function by name

    Double_t myFunc(double x) { return x+sin(x); }
    ....
    auto fa3 = new TF1("fa3","myFunc(x)",-3,5);
    fa3->Draw();

(C++ version of the code)

### 2 - Expression using variable x with parameters

#### Case 1: inline expression using standard C++ functions/operators

Example a:

    auto fa = new TF1("fa","[0]*x*sin([1]*x)",-3,3);

(C++ version of the code)

This creates a function of variable x with 2 parameters. The parameters must be initialized via:

    fa->SetParameter(0,value_first_parameter);
    fa->SetParameter(1,value_second_parameter);

(C++ version of the code)

Parameters may be given a name:

    fa->SetParName(0,"Constant");

(C++ version of the code)

Example b:

    auto fb = new TF1("fb","gaus(0)*expo(3)",0,10);

(C++ version of the code)

`gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)` and `(0)` means thestart numbering parameters at `0`. `expo(3)` is a substitute for `exp([3]+[4]*x)`.

#### Case 2: inline expression using TMath functions with parameters

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF1_003.png](https://root.cern/doc/v636/pict1_TF1_003.png)

### 3 - A lambda expression with variables and parameters

###Since

6.00/00: TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda functions and still maintain the capability of storing the function in a file which cannot be done with function pointer or lambda written not as expression, but as code (see items below).

Example on how using lambda to define a sum of two functions. Note that is necessary to provide the number of parameters

    TF1 f1("f1","sin(x)",0,10);
    TF1 f2("f2","cos(x)",0,10);
    TF1 fsum("f1","[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }",0,10,2);

(C++ version of the code)

### 4 - A general C function with parameters

Consider the macro myfunc.C below:

    // Macro myfunc.C
    Double_t myfunction(Double_t *x, Double_t *par)
    {
       Float_t xx =x[0];
       Double_t f = TMath!Abs(par[0]*sin(par[1]*xx)/xx);
       return f;
    }
    void myfunc()
    {
       auto f1 = new TF1("myfunc",myfunction,0,10,2);
       f1->SetParameters(2,1);
       f1->SetParNames("constant","coefficient");
       f1->Draw();
    }
    void myfit()
    {
       auto h1 = new TH1F("h1","test",100,0,10);
       h1->FillRandom("myfunc",20000);
       TF1 *f1 = (TF1 *)gROOT->GetFunction("myfunc");
       f1->SetParameters(800,1);
       h1->Fit("myfunc");
    }

(C++ version of the code)

In an interactive session you can do:

    Root > .L myfunc.C
    Root > myfunc();
    Root > myfit();

(C++ version of the code)

[TF1](@ref) objects can reference other [TF1](@ref) objects of type A or B defined above. This excludes CLing or compiled functions. However, there is a restriction. A function cannot reference a basic function if the basic function is a polynomial polN.

Example:

    {
          auto fcos = new TF1 ("fcos", "[0]*cos(x)", 0., 10.);
          fcos->SetParNames( "cos");
          fcos->SetParameter( 0, 1.1);
          auto fsin = new TF1 ("fsin", "[0]*sin(x)", 0., 10.);
          fsin->SetParNames( "sin");
          fsin->SetParameter( 0, 2.1);
          auto fsincos = new TF1 ("fsc", "fcos+fsin");
          auto fs2 = new TF1 ("fs2", "fsc+fsc");
    }

(C++ version of the code)

### 5 - A general C++ function object (functor) with parameters

A [TF1](@ref) can be created from any C++ class implementing the operator()(double *x, double *p). The advantage of the function object is that he can have a state and reference therefore what-ever other object. In this way the user can customize his function.

Example:

    class  MyFunctionObject {
     public:
       // use constructor to customize your function object
       double operator() (double *x, double *p) {
          // function implementation using class data members
       }
    };
    {
        ....
       MyFunctionObject fobj;
       auto f = new TF1("f",fobj,0,1,npar);    // create TF1 class.
       .....
    }

(C++ version of the code)

#### Using a lambda function as a general C++ functor object

From C++11 we can use both std!function or even better lambda functions to create the [TF1](@ref). As above the lambda must have the right signature but can capture whatever we want. For example we can make a [TF1](@ref) from the [TGraph!Eval](@ref) function as shown below where we use as function parameter the graph normalization.

    auto g = new TGraph(npointx, xvec, yvec);
    auto f = new TF1("f",[&](double*x, double *p){ return p[0]*g->Eval(x[0]); }, xmin, xmax, 1);

(C++ version of the code)

### 6 - A member function with parameters of a general C++ class

A [TF1](@ref) can be created in this case from any member function of a class which has the signature of (double * , double *) and returning a double.

Example:

    class  MyFunction {
     public:
       ...
       double Evaluate() (double *x, double *p) {
          // function implementation
       }
    };
    {
        ....
       MyFunction *fptr = new MyFunction(....);  // create the user function class
       auto f = new TF1("f",fptr,&MyFunction!Evaluate,0,1,npar,"MyFunction","Evaluate");   // create TF1 class.
       .....
    }

(C++ version of the code)

See also the tutorial **math/exampleFunctor.C** for a running example.

Related functions: [`AddParameter`](@ref), [`AddToGlobalList`](@ref), [`Browse`](@ref), [`CentralMoment`](@ref), [`Clone`](@ref), [`Copy`](@ref), [`CreateHistogram`](@ref), [`Derivative2`](@ref), [`Derivative3`](@ref), [`Derivative`](@ref), [`DistancetoPrimitive`](@ref), [`DrawCopy`](@ref), [`DrawDerivative`](@ref), [`DrawF1`](@ref), [`DrawIntegral`](@ref), [`Draw`](@ref), [`EvalPar`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`FixParameter`](@ref), [`GetChisquare`](@ref), [`GetExpFormula`](@ref), [`GetFormula`](@ref), [`GetHistogram`](@ref), [`GetLinearPart`](@ref), [`GetMaximumStored`](@ref), [`GetMaximumX`](@ref), [`GetMaximum`](@ref), [`GetMethodCall`](@ref), [`GetMinimumStored`](@ref), [`GetMinimumX`](@ref), [`GetMinimum`](@ref), [`GetNDF`](@ref), [`GetNdim`](@ref), [`GetNpar`](@ref), [`GetNpx`](@ref), [`GetNumberFitPoints`](@ref), [`GetNumberFreeParameters`](@ref), [`GetNumber`](@ref), [`GetObjectInfo`](@ref), [`GetParError`](@ref), [`GetParErrors`](@ref), [`GetParLimits`](@ref), [`GetParName`](@ref), [`GetParNumber`](@ref), [`GetParameter`](@ref), [`GetParameters`](@ref), [`GetParent`](@ref), [`GetProb`](@ref), [`GetQuantiles`](@ref), [`GetRandom`](@ref), [`GetRange`](@ref), [`GetSave`](@ref), [`GetVariable`](@ref), [`GetX`](@ref), [`GetXaxis`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`GradientParTempl`](@ref), [`GradientPar`](@ref), [`InitArgs`](@ref), [`IntegralError`](@ref), [`IntegralFast`](@ref), [`IntegralMultiple`](@ref), [`IntegralOneDim`](@ref), [`Integral`](@ref), [`IsEvalNormalized`](@ref), [`IsInside`](@ref), [`IsLinear`](@ref), [`IsValid`](@ref), [`IsVectorized`](@ref), [`Mean`](@ref), [`Moment`](@ref), [`Paint`](@ref), [`Print`](@ref), [`ReleaseParameter`](@ref), [`SavePrimitive`](@ref), [`Save`](@ref), [`SetChisquare`](@ref), [`SetFitResult`](@ref), [`SetFunction`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNDF`](@ref), [`SetNormalized`](@ref), [`SetNpx`](@ref), [`SetNumberFitPoints`](@ref), [`SetParError`](@ref), [`SetParErrors`](@ref), [`SetParLimits`](@ref), [`SetParName`](@ref), [`SetParNames`](@ref), [`SetParameter`](@ref), [`SetParameters`](@ref), [`SetParent`](@ref), [`SetRange`](@ref), [`SetSavedPoint`](@ref), [`SetTitle`](@ref), [`SetVectorized`](@ref), [`TF1!AbsValue`](@ref), [`TF1!CalcGaussLegendreSamplingPoints`](@ref), [`TF1!DefaultAddToGlobalList`](@ref), [`TF1!DerivativeError`](@ref), [`TF1!GetCurrent`](@ref), [`TF1!InitStandardFunctions`](@ref), [`TF1!RejectPoint`](@ref), [`TF1!RejectedPoint`](@ref), [`TF1!SetCurrent`](@ref), [`TF1`](@ref), [`Update`](@ref), [`Variance`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TF1

# Wrapper of TGraph
@trydoc raw"""
    ROOT.TGraph

A [TGraph](@ref) is an object made of two arrays X and Y with npoints each.

The [TGraph](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

#### Notes

- Unlike histogram or tree (or even [TGraph2D](@ref)), [TGraph](@ref) objects are not automatically attached to the current [TFile](@ref), in order to keep the management and size of the [TGraph](@ref) as small as possible.
- The [TGraph](@ref) constructors do not have the [TGraph](@ref) title and name as parameters. A [TGraph](@ref) has the default title and name "Graph". To change the default title and name `SetTitle` and `SetName` should be called on the [TGraph](@ref) after its creation. [TGraph](@ref) was a light weight object to thestart with, like TPolyline or [TPolyMarker](@ref). Thats why it did not have any title and name parameters in the constructors.

#### Example

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph_001.png](https://root.cern/doc/v636/pict1_TGraph_001.png)

#### Default X-Points

If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending on the length of the y-points):

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph_002.png](https://root.cern/doc/v636/pict1_TGraph_002.png)

Related functions: [`AddPoint`](@ref), [`Apply`](@ref), [`Browse`](@ref), [`Chisquare`](@ref), [`ComputeRange`](@ref), [`DistancetoPrimitive`](@ref), [`DrawGraph`](@ref), [`DrawPanel`](@ref), [`Draw`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`Expand`](@ref), [`FindObject`](@ref), [`FitPanel`](@ref), [`Fit`](@ref), [`GetCorrelationFactor`](@ref), [`GetCovariance`](@ref), [`GetEX`](@ref), [`GetEXhigh`](@ref), [`GetEXhighd`](@ref), [`GetEXlow`](@ref), [`GetEXlowd`](@ref), [`GetEY`](@ref), [`GetEYhigh`](@ref), [`GetEYhighd`](@ref), [`GetEYlow`](@ref), [`GetEYlowd`](@ref), [`GetEditable`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`GetFunction`](@ref), [`GetHistogram`](@ref), [`GetListOfFunctions`](@ref), [`GetMaxSize`](@ref), [`GetMaximum`](@ref), [`GetMean`](@ref), [`GetMinimum`](@ref), [`GetN`](@ref), [`GetObjectInfo`](@ref), [`GetPointX`](@ref), [`GetPointY`](@ref), [`GetPoint`](@ref), [`GetRMS`](@ref), [`GetX`](@ref), [`GetXaxis`](@ref), [`GetY`](@ref), [`GetYaxis`](@ref), [`InitExpo`](@ref), [`InitGaus`](@ref), [`InitPolynom`](@ref), [`InsertPointBefore`](@ref), [`InsertPoint`](@ref), [`Integral`](@ref), [`IsEditable`](@ref), [`IsHighlight`](@ref), [`IsInside`](@ref), [`LeastSquareFit`](@ref), [`LeastSquareLinearFit`](@ref), [`Merge`](@ref), [`MovePoints`](@ref), [`PaintGrapHist`](@ref), [`PaintGraph`](@ref), [`PaintStats`](@ref), [`Paint`](@ref), [`Print`](@ref), [`RecursiveRemove`](@ref), [`RemovePoint`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetEditable`](@ref), [`SetHighlight`](@ref), [`SetHistogram`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetOption`](@ref), [`SetPointX`](@ref), [`SetPointY`](@ref), [`SetPoint`](@ref), [`SetStats`](@ref), [`SetTitle`](@ref), [`Set`](@ref), [`Sort`](@ref), [`TGraph!CompareArg`](@ref), [`TGraph!CompareRadius`](@ref), [`TGraph!CompareX`](@ref), [`TGraph!CompareY`](@ref), [`TGraph`](@ref), [`UseCurrentStyle`](@ref), [`Zero`](@ref), [`assign`](@ref)
""" TGraph

# Wrapper of TGraph2D
@trydoc raw"""
    ROOT.TGraph2D

Graphics object made of three arrays X, Y and Z with the same number of points each.

- [Creating a TGraph2D](@ref)
- [Drawing options](@ref)
- [Examples](@ref)

    - [SURF1 Example](@ref)
    - [Fitting Example](@ref)
    - [PCOL Example](@ref)
- [Definition of the Delaunay triangulation (After B. Delaunay)](@ref)

## Creating a TGraph2D

This class has different constructors:

- With an array's dimension and three arrays x, y, and z: 

        auto g = new TGraph2D(n, x, y, z);

(C++ version of the code)

 x, y, z arrays can be doubles, floats, or ints.
- With an array's dimension only: 

        auto g = new TGraph2D(n);

(C++ version of the code)

 The internal arrays are then filled with `SetPoint()`. The following line fills the internal arrays at the position `i` with the values `x`, `y`, `z`. 

        g->SetPoint(i, x, y, z);

(C++ version of the code)

- Without parameters: 

        auto g = new TGraph2D();

(C++ version of the code)

 again `SetPoint()` must be used to fill the internal arrays.
- From a file: 

        auto g = new TGraph2D("graph.dat");

(C++ version of the code)

 Arrays are read from the ASCII file "graph.dat" according to a specifies format. The default format is `%lg %lg %lg`

Note that in any of these three cases, `SetPoint()` can be used to change a data point or add a new one. If the data point index (`i`) is greater than the current size of the internal arrays, they are automatically extended.

Like [TGraph](@ref) some [TGraph2D](@ref) constructors do not have the [TGraph2D](@ref) title and name as parameters. For these constructors [TGraph2D](@ref) has the default title and name "Graph2D". To change the default title and name `SetTitle` and `SetName` should be called on the [TGraph2D](@ref) after its creation.

## Drawing options

Specific drawing options can be used to paint a [TGraph2D](@ref):

| **Option** | **Description**                                                                                                                                                                                                                |
|:-----------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "TRI"      | The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color. |
| "TRIW"     | The Delaunay triangles are drawn as wire frame.                                                                                                                                                                                |
| "TRI1"     | The Delaunay triangles are painted with color levels. The edges of each triangles are painted with the current line color.                                                                                                     |
| "TRI2"     | The Delaunay triangles are painted with color levels.                                                                                                                                                                          |
| "P"        | Draw a marker at each vertex.                                                                                                                                                                                                  |
| "P0"       | Draw a circle at each vertex. Each circle background is white.                                                                                                                                                                 |
| "PCOL"     | Draw a marker at each vertex. The color of each marker is defined according to its Z position.                                                                                                                                 |
| "LINE"     | Draw a 3D polyline.                                                                                                                                                                                                            |
| "CONT5"    | Draw a contour plot using Delaunay triangles.                                                                                                                                                                                  |

A [TGraph2D](@ref) can be also drawn with any options valid to draw a 2D histogram (like `COL`, `SURF`, `LEGO`, `CONT` etc..).

When a [TGraph2D](@ref) is drawn with one of the 2D histogram drawing option, an intermediate 2D histogram is filled using the Delaunay triangles to interpolate the data set. The 2D histogram has equidistant bins along the X and Y directions. The number of bins along each direction can be change using `SetNpx()` and `SetNpy()`. Each bin is filled with the Z value found via a linear interpolation on the plane defined by the triangle above the (X,Y) coordinates of the bin center.

The existing (X,Y,Z) points can be randomly scattered. The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then used to define flat planes in (X,Y,Z) over which the interpolation is done to fill the 2D histogram. The 3D triangles int takes build a 3D surface in the form of tessellating triangles at various angles. The triangles found can be drawn in 3D with one of the [TGraph2D](@ref) specific drawing options.

The histogram generated by the Delaunay interpolation can be accessed using the `GetHistogram()` method.

The axis settings (title, ranges etc ...) can be changed accessing the axis via the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created at drawing time only. Therefore they should called after the [TGraph2D](@ref) is drawn:

    auto g = new TGraph2D();
    [...]
    g->Draw("tri1");
    gPad->Update();
    g->GetXaxis()->SetTitle("X axis title");

(C++ version of the code)

## Examples

### SURF1 Example

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2D_001.png](https://root.cern/doc/v636/pict1_TGraph2D_001.png)

### Fitting Example

2D graphs can be fitted as shown by the following example:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TGraph2D_002.png](https://root.cern/doc/v636/pict1_TGraph2D_002.png)

### PCOL Example

Example showing the PCOL option.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2D_003.png](https://root.cern/doc/v636/pict1_TGraph2D_003.png)

## Definition of the Delaunay triangulation (After B. Delaunay)

For a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circumcircle of any triangle in DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of points in S, the Voronoi diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exactly one point and every point in a given polygon is closer to its central point than to any other. A Voronoi diagram is sometimes also known as a Dirichlet tessellation.

![https://root.cern/doc/v636/tgraph2d_delaunay.png](https://root.cern/doc/v636/tgraph2d_delaunay.png)

[This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html) gives a nice practical view of Delaunay triangulation and Voronoi diagram.

Related functions: [`AddPoint`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`DirectoryAutoAdd`](@ref), [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`FindObject`](@ref), [`FitPanel`](@ref), [`Fit`](@ref), [`GetContourList`](@ref), [`GetDirectory`](@ref), [`GetEX`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEY`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetEZ`](@ref), [`GetEZhigh`](@ref), [`GetEZlow`](@ref), [`GetErrorX`](@ref), [`GetErrorY`](@ref), [`GetErrorZ`](@ref), [`GetHistogram`](@ref), [`GetListOfFunctions`](@ref), [`GetMargin`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetN`](@ref), [`GetNpx`](@ref), [`GetNpy`](@ref), [`GetPoint`](@ref), [`GetX`](@ref), [`GetXaxis`](@ref), [`GetXmaxE`](@ref), [`GetXmax`](@ref), [`GetXminE`](@ref), [`GetXmin`](@ref), [`GetY`](@ref), [`GetYaxis`](@ref), [`GetYmaxE`](@ref), [`GetYmax`](@ref), [`GetYminE`](@ref), [`GetYmin`](@ref), [`GetZ`](@ref), [`GetZaxis`](@ref), [`GetZmaxE`](@ref), [`GetZmax`](@ref), [`GetZminE`](@ref), [`GetZmin`](@ref), [`Interpolate`](@ref), [`Paint`](@ref), [`Print`](@ref), [`Project`](@ref), [`RemovePoint`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetDirectory`](@ref), [`SetHistogram`](@ref), [`SetMarginBinsContent`](@ref), [`SetMargin`](@ref), [`SetMaxIter`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetNpx`](@ref), [`SetNpy`](@ref), [`SetPoint`](@ref), [`SetTitle`](@ref), [`Set`](@ref), [`TGraph2D`](@ref), [`assign`](@ref)
""" TGraph2D

# Wrapper of TGraphErrors
@trydoc raw"""
    ROOT.TGraphErrors

A [TGraphErrors](@ref) is a [TGraph](@ref) with error bars.

The [TGraphErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphErrors_001.png](https://root.cern/doc/v636/pict1_TGraphErrors_001.png)

Related functions: [`ApplyX`](@ref), [`Apply`](@ref), [`ComputeRange`](@ref), [`GetEX`](@ref), [`GetEY`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`Merge`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`TGraphErrors!CalculateScanfFields`](@ref), [`TGraphErrors`](@ref), [`assign`](@ref)
""" TGraphErrors

# Wrapper of TAxisModLab
@trydoc raw"""
    ROOT.TAxisModLab

[TAxis](@ref) helper class used to store the modified labels.



Related functions: [`GetAlign`](@ref), [`GetAngle`](@ref), [`GetColor`](@ref), [`GetFont`](@ref), [`GetLabNum`](@ref), [`GetLabValue`](@ref), [`GetSize`](@ref), [`GetText`](@ref), [`SetAlign`](@ref), [`SetAngle`](@ref), [`SetColor`](@ref), [`SetFont`](@ref), [`SetLabNum`](@ref), [`SetLabValue`](@ref), [`SetSize`](@ref), [`SetText`](@ref), [`TAxisModLab`](@ref)
""" TAxisModLab

# Wrapper of TVirtualFitter
@trydoc raw"""
    ROOT.TVirtualFitter

Abstract Base Class for Fitting.



Related functions: [`Chisquare`](@ref), [`Clear`](@ref), [`ExecuteCommand`](@ref), [`FixParameter`](@ref), [`GetConfidenceIntervals`](@ref), [`GetCovarianceMatrixElement`](@ref), [`GetCovarianceMatrix`](@ref), [`GetErrors`](@ref), [`GetFCN`](@ref), [`GetFitOption`](@ref), [`GetMethodCall`](@ref), [`GetNumberFreeParameters`](@ref), [`GetNumberTotalParameters`](@ref), [`GetObjectFit`](@ref), [`GetParError`](@ref), [`GetParName`](@ref), [`GetParameter`](@ref), [`GetStats`](@ref), [`GetSumLog`](@ref), [`GetUserFunc`](@ref), [`GetXfirst`](@ref), [`GetXlast`](@ref), [`GetYfirst`](@ref), [`GetYlast`](@ref), [`GetZfirst`](@ref), [`GetZlast`](@ref), [`IsFixed`](@ref), [`PrintResults`](@ref), [`ReleaseParameter`](@ref), [`SetCache`](@ref), [`SetFCN`](@ref), [`SetFitMethod`](@ref), [`SetFitOption`](@ref), [`SetObjectFit`](@ref), [`SetParameter`](@ref), [`SetUserFunc`](@ref), [`SetXfirst`](@ref), [`SetXlast`](@ref), [`SetYfirst`](@ref), [`SetYlast`](@ref), [`SetZfirst`](@ref), [`SetZlast`](@ref), [`TVirtualFitter!Fitter`](@ref), [`TVirtualFitter!GetDefaultFitter`](@ref), [`TVirtualFitter!GetErrorDef`](@ref), [`TVirtualFitter!GetFitter`](@ref), [`TVirtualFitter!GetMaxIterations`](@ref), [`TVirtualFitter!GetPrecision`](@ref), [`TVirtualFitter!SetDefaultFitter`](@ref), [`TVirtualFitter!SetErrorDef`](@ref), [`TVirtualFitter!SetFitter`](@ref), [`TVirtualFitter!SetMaxIterations`](@ref), [`TVirtualFitter!SetPrecision`](@ref), [`TVirtualFitter`](@ref)
""" TVirtualFitter

# Wrapper of TBackCompFitter
@trydoc raw"""
    ROOT.TBackCompFitter

Backward compatible implementation of [TVirtualFitter](@ref).

Backward compatible implementation of [TVirtualFitter](@ref) using the class [ROOT!Fit!Fitter](@ref). This class is created after fitting an histogram ([TH1](@ref)), [TGraph](@ref) or [TTree](@ref) and provides in addition to the methods of the [TVirtualFitter](@ref) hooks to access the fit result class ([ROOT!Fit!FitResult](@ref)), the fit configuration ([ROOT!Fit!FitConfig](@ref)) or the fit data ([ROOT!Fit!FitData](@ref)) using

    TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter!GetFitter();
    ROOT!Fit!FitResult & result = fitter->GetFitResult();
    result.Print(std!cout);

(C++ version of the code)

Methods for getting the confidence level or contours are also provided. Note that after a new calls to [TH1!Fit](@ref) (or similar) the class will be deleted and all reference to the FitResult, FitConfig or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information.

Related functions: [`Chisquare`](@ref), [`Clear`](@ref), [`Contour`](@ref), [`ExecuteCommand`](@ref), [`FixParameter`](@ref), [`GetConfidenceIntervals`](@ref), [`GetCovarianceMatrixElement`](@ref), [`GetCovarianceMatrix`](@ref), [`GetErrors`](@ref), [`GetFitConfig`](@ref), [`GetFitData`](@ref), [`GetFitResult`](@ref), [`GetMinimizer`](@ref), [`GetNumberFreeParameters`](@ref), [`GetNumberTotalParameters`](@ref), [`GetObjFunction`](@ref), [`GetParError`](@ref), [`GetParName`](@ref), [`GetParameter`](@ref), [`GetStats`](@ref), [`GetSumLog`](@ref), [`GetTFitResult`](@ref), [`IsFixed`](@ref), [`PrintResults`](@ref), [`ReCreateMinimizer`](@ref), [`ReleaseParameter`](@ref), [`Scan`](@ref), [`SetFCN`](@ref), [`SetFitMethod`](@ref), [`SetMethodCall`](@ref), [`SetObjFunction`](@ref), [`SetParameter`](@ref), [`TBackCompFitter`](@ref)
""" TBackCompFitter

# Wrapper of TBinomialEfficiencyFitter
@trydoc raw"""
    ROOT.TBinomialEfficiencyFitter

Binomial fitter for the division of two histograms.

Use when you need to calculate a selection's efficiency from two histograms, one containing all entries, and one containing the subset of these entries that pass the selection, and when you have a parametrization available for the efficiency as a function of the variable(s) under consideration.

A very common problem when estimating efficiencies is that of error estimation: when no other information is available than the total number of events N and the selected number n, the best estimate for the selection efficiency p is n/N. Standard binomial statistics dictates that the uncertainty (this presupposes sufficiently high statistics that an approximation by a normal distribution is reasonable) on p, given N, is 

``\sqrt{\frac{p(1-p)}{N}}``

 However, when p is estimated as n/N, fluctuations from the true p to its estimate become important, especially for low numbers of events, and giving rise to biased results.

When fitting a parametrized efficiency, these problems can largely be overcome, as a hypothesized true efficiency is available by construction. Even so, simply using the corresponding uncertainty still presupposes that Gaussian errors yields a reasonable approximation. When using, instead of binned efficiency histograms, the original numerator and denominator histograms, a binned maximum likelihood can be constructed as the product of bin-by-bin binomial probabilities to select n out of N events. Assuming that a correct parametrization of the efficiency is provided, this construction in general yields less biased results (and is much less sensitive to binning details).

A generic use of this method is given below (note that the method works for 2D and 3D histograms as well):

    {
        TH1* denominator;              // denominator histogram
        TH1* numerator;                // corresponding numerator histogram
        TF1* eff;                      // efficiency parametrization
        ....                           // set step sizes and initial parameter
        ....                           //   values for the fit function
        ....                           // possibly also set ranges, see TF1!SetRange()
        TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(
                                     numerator, denominator);
        Int_t status = f->Fit(eff, "I");
        if (status == 0) {
          // if the fit was successful, display bin-by-bin efficiencies
          // as well as the result of the fit
          numerator->Sumw2();
          TH1* hEff = dynamic_cast<TH1*>(numerator->Clone("heff"));
          hEff->Divide(hEff, denominator, 1.0, 1.0, "B");
          hEff->Draw("E");
          eff->Draw("same");
        }
    }

(C++ version of the code)

Note that this method cannot be expected to yield reliable results when using weighted histograms (because the likelihood computation will be incorrect).

Related functions: [`EvaluateFCN`](@ref), [`Fit`](@ref), [`GetFitter`](@ref), [`SetPrecision`](@ref), [`Set`](@ref), [`TBinomialEfficiencyFitter`](@ref)
""" TBinomialEfficiencyFitter

# Wrapper of TConfidenceLevel
@trydoc raw"""
    ROOT.TConfidenceLevel

Class to compute 95% CL limits.



Related functions: [`CLb`](@ref), [`CLs`](@ref), [`CLsb`](@ref), [`Draw`](@ref), [`Get3sProbability`](@ref), [`Get5sProbability`](@ref), [`GetAverageCLs`](@ref), [`GetAverageCLsb`](@ref), [`GetBtot`](@ref), [`GetDtot`](@ref), [`GetExpectedCLb_b`](@ref), [`GetExpectedCLb_sb`](@ref), [`GetExpectedCLs_b`](@ref), [`GetExpectedCLsb_b`](@ref), [`GetExpectedStatistic_b`](@ref), [`GetExpectedStatistic_sb`](@ref), [`GetStatistic`](@ref), [`GetStot`](@ref), [`SetBtot`](@ref), [`SetDtot`](@ref), [`SetLRB`](@ref), [`SetLRS`](@ref), [`SetStot`](@ref), [`SetTSB`](@ref), [`SetTSD`](@ref), [`SetTSS`](@ref), [`TConfidenceLevel`](@ref)
""" TConfidenceLevel

# Wrapper of TEfficiency
@trydoc raw"""
    ROOT.TEfficiency

Class to handle efficiency histograms.

- [I. Overview](@ref)
- [II. Creating a TEfficiency object](@ref)

    - [Example 1](@ref)
    - [Example 2](@ref)
- [III. Filling with events](@ref)
- [IV. Statistic options](@ref)

    - [Frequentist methods](@ref)
    - [Bayesian methods](@ref)
    - [IV.1 Coverage probabilities for different methods](@ref)
- [V. Merging and combining TEfficiency objects](@ref)

    - [Example](@ref)
    - [V.1 When should I use merging?](@ref)

        - [Example](@ref)
    - [V.2 When should I use combining?](@ref)

        - [Example](@ref)

- [VI. Further operations](@ref)

    - [VI.1 Information about the internal histograms](@ref)
    - [VI.2 Fitting](@ref)
    - [VI.3 Draw a TEfficiency object](@ref)
    - [VI.4 TEfficiency object's axis customisation](@ref)

## I. Overview

This class handles the calculation of efficiencies and their uncertainties. It provides several statistical methods for calculating frequentist and Bayesian confidence intervals as well as a function for combining several efficiencies.

Efficiencies have a lot of applications and meanings but in principle, they can be described by the fraction of good/passed events k out of sample containing N events. One is usually interested in the dependency of the efficiency on other (binned) variables. The number of passed and total events is therefore stored internally in two histograms ([TEfficiency!fTotalHistogram](@ref) and [TEfficiency!fPassedHistogram](@ref)). Then the efficiency, as well as its upper and lower error, can be calculated for each bin individually.

As the efficiency can be regarded as a parameter of a binomial distribution, the number of passed and total events must always be integer numbers. Therefore a filling with weights is not possible. However, you can assign a global_ weight to each [TEfficiency](@ref) object ([TEfficiency!SetWeight](@ref)). It is necessary to create one [TEfficiency](@ref) object for each weight if you investigate a process involving different weights. This procedure needs more effort but enables you to re-use the filled object in cases where you want to change one or more weights. This would not be possible if all events with different weights were filled in the same histogram.

## II. Creating a TEfficiency object

If you thestart a new analysis, it is highly recommended to use the [TEfficiency](@ref) class from the beginning. You can then use one of the constructors for fixed or variable bin size and your desired dimension. These constructors append the created [TEfficiency](@ref) object to the current directory. So it will be written automatically to a file during the next [TFile!Write](@ref) command.

Example: create a two-dimensional [TEfficiency](@ref) object with

- name = "eff"
- title = "my efficiency"
- axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis
- 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge from the first bin) up to 10 (upper edge of last bin)
- 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower edge from the first bin) up to 5 (upper edge of last bin) 
```
  TEfficiency* pEff = new TEfficiency("eff","my efficiency;x;y;#epsilon",10,0,10,20,-5,5);
```  If you already have two histograms filled with the number of passed and total events, you will use the constructor [TEfficiency(const TH1& passed,const TH1& total)](@ref) to construct the [TEfficiency](@ref) object. The histograms "passed" and "total" have to fulfill the conditions mentioned in [TEfficiency!CheckConsistency](@ref), otherwise the construction will fail. As the histograms already exist, the new [TEfficiency](@ref) is by default **not** attached to the current directory to avoid duplication of data. If you want to store the new object anyway, you can either write it directly by calling [TObject!Write](@ref) or attach it to a directory using [TEfficiency!SetDirectory](@ref). This also applies to [TEfficiency](@ref) objects created by the copy constructor [TEfficiency!TEfficiency(const TEfficiency& rEff)](@ref).

### Example 1

    TEfficiency* pEff = 0;
    TFile* pFile = new TFile("myfile.root","recreate");
    //h_pass and h_total are valid and consistent histograms
    if(TEfficiency!CheckConsistency(h_pass,h_total))
    {
      pEff = new TEfficiency(h_pass,h_total);
      // this will write the TEfficiency object to "myfile.root"
      // AND pEff will be attached to the current directory
      pEff->Write();
    }

(C++ version of the code)

### Example 2

    TEfficiency* pEff = 0;
    TFile* pFile = new TFile("myfile.root","recreate");
    //h_pass and h_total are valid and consistent histograms
    if(TEfficiency!CheckConsistency(h_pass,h_total))
    {
      pEff = new TEfficiency(h_pass,h_total);
      //this will attach the TEfficiency object to the current directory
      pEff->SetDirectory(gDirectory);
      //now all objects in gDirectory will be written to "myfile.root"
      pFile->Write();
    }

(C++ version of the code)

In case you already have two filled histograms and you only want to plot them as a graph, you should rather use [TGraphAsymmErrors!TGraphAsymmErrors(const TH1* pass,const TH1* total,Option_t* opt)](@ref) to create a graph object.

## III. Filling with events

You can fill the [TEfficiency](@ref) object by calling the [TEfficiency!Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z)](@ref) method. The "bPassed" boolean flag indicates whether the current event is good (both histograms are filled) or not (only [TEfficiency!fTotalHistogram](@ref) is filled). The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_001.png](https://root.cern/doc/v636/pict1_TEfficiency_001.png)

You can also set the number of passed or total events for a bin directly by using the [TEfficiency!SetPassedEvents](@ref) or [TEfficiency!SetTotalEvents](@ref) method.

## IV. Statistic options

The calculation of the estimated efficiency depends on the chosen statistic option. Let k denotes the number of passed events and N the number of total events.

### Frequentist methods

The expectation value of the number of passed events is given by the true efficiency times the total number of events. One can estimate the efficiency by replacing the expected number of passed events by the observed number of passed events.

``k = \epsilon \times N    \Rightarrow    \hat{\varepsilon} = \frac{k}{N}``

### Bayesian methods

In Bayesian statistics a likelihood-function (how probable is it to get the observed data assuming a true efficiency) and a prior probability (what is the probability that a certain true efficiency is actually realised) are used to determine a posterior probability by using Bayes theorem. At the moment, only beta distributions (have 2 free parameters) are supported as prior probabilities.

\thebegin{eqnarray*}
 P(\epsilon | k ; N) &=& \frac{1}{norm} \times P(k | \epsilon ; N) \times Prior(\epsilon) \\
 P(k | \epsilon ; N) &=& Binomial(N,k) \times \epsilon^{k} \times (1 - \epsilon)^{N - k} ...\  binomial\ distribution \\
 Prior(\epsilon) &=& \frac{1}{B(\alpha,\beta)} \times \epsilon ^{\alpha - 1} \times (1 - \epsilon)^{\beta - 1} \equiv Beta(\epsilon; \alpha,\beta) \\
 \Rightarrow P(\epsilon | k ; N) &=& \frac{1}{norm'} \times \epsilon^{k + \alpha - 1} \times (1 - \epsilon)^{N - k + \beta - 1} \equiv Beta(\epsilon; k + \alpha, N - k + \beta)
\theend{eqnarray*}

By default the expectation value of this posterior distribution is used as an estimator for the efficiency:

``\hat{\varepsilon} = \frac{k + \alpha}{N + \alpha + \beta}``

Optionally the mode can also be used as a value for the estimated efficiency. This can be done by calling SetBit(kPosteriorMode) or [TEfficiency!SetPosteriorMode](@ref). In this case, the estimated efficiency is:

``\hat{\varepsilon} = \frac{k + \alpha -1}{N + \alpha + \beta - 2}``

In the case of a uniform prior distribution, B(x,1,1), the posterior mode is k/n, equivalent to the frequentist estimate (the maximum likelihood value).

The statistic options also specify which confidence interval is used for calculating the uncertainties of the efficiency. The following properties define the error calculation:

- **fConfLevel:** desired confidence level: 0 < fConfLevel < 1 ([TEfficiency!GetConfidenceLevel](@ref) / [TEfficiency!SetConfidenceLevel](@ref))
- **fStatisticOption** defines which method is used to calculate the boundaries of the confidence interval ([TEfficiency!SetStatisticOption](@ref))
- **fBeta_alpha, fBeta_beta:** parameters for the prior distribution which is only used in the bayesian case ([TEfficiency!GetBetaAlpha](@ref) / [TEfficiency!GetBetaBeta](@ref) / [TEfficiency!SetBetaAlpha](@ref) / [TEfficiency!SetBetaBeta](@ref))
- **kIsBayesian:** flag whether bayesian statistics are used or not ([TEfficiency!UsesBayesianStat](@ref))
- **kShortestInterval:** flag whether shortest interval (instead of central one) are used in case of Bayesian statistics ([TEfficiency!UsesShortestInterval](@ref)). Normally shortest interval should be used in combination with the mode (see [TEfficiency!UsesPosteriorMode](@ref))
- **fWeight:** global_ weight for this [TEfficiency](@ref) object which is used during combining or merging with other [TEfficiency](@ref) objects([TEfficiency!GetWeight](@ref) / [TEfficiency!SetWeight](@ref))

In the following table, the implemented confidence intervals are listed with their corresponding statistic option. For more details on the calculation, please have a look at the mentioned functions.

| **name**             | **statistic option** | **function**                       | **kIsBayesian** | **parameters**                                                                     |
|:---------------------|:---------------------|:-----------------------------------|:----------------|:-----------------------------------------------------------------------------------|
| Clopper-Pearson      | kFCP                 | [TEfficiency!ClopperPearson](@ref) | false           | total events, passed events, confidence level                                      |
| normal approximation | kFNormal             | [TEfficiency!Normal](@ref)         | false           | total events, passed events, confidence level                                      |
| Wilson               | kFWilson             | [TEfficiency!Wilson](@ref)         | false           | total events, passed events, confidence level                                      |
| Agresti-Coull        | kFAC                 | [TEfficiency!AgrestiCoull](@ref)   | false           | total events, passed events. confidence level                                      |
| Feldman-Cousins      | kFFC                 | [TEfficiency!FeldmanCousins](@ref) | false           | total events, passed events, confidence level                                      |
| Mid-P Lancaster      | kMidP                | [TEfficiency!MidPInterval](@ref)   | false           | total events, passed events, confidence level                                      |
| Jeffrey              | kBJeffrey            | [TEfficiency!Bayesian](@ref)       | true            | total events, passed events, confidence level, fBeta_alpha = 0.5, fBeta_beta = 0.5 |
| Uniform prior        | kBUniform            | [TEfficiency!Bayesian](@ref)       | true            | total events, passed events, confidence level, fBeta_alpha = 1, fBeta_beta = 1     |
| custom prior         | kBBayesian           | [TEfficiency!Bayesian](@ref)       | true            | total events, passed events, confidence level, fBeta_alpha, fBeta_beta             |

The following example demonstrates the effect of different statistic options and confidence levels.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_002.png](https://root.cern/doc/v636/pict1_TEfficiency_002.png)

The prior probability of the efficiency in Bayesian statistics can be given in terms of a beta distribution. The beta distribution has two positive shape parameters. The resulting priors for different combinations of these shape parameters are shown in the plot below.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_003.png](https://root.cern/doc/v636/pict1_TEfficiency_003.png)

### IV.1 Coverage probabilities for different methods

The following pictures illustrate the actual coverage probability for the different values of the true efficiency and the total number of events when a confidence level of 95% is desired.

![https://root.cern/doc/v636/normal95.gif](https://root.cern/doc/v636/normal95.gif)

![https://root.cern/doc/v636/wilson95.gif](https://root.cern/doc/v636/wilson95.gif)

![https://root.cern/doc/v636/ac95.gif](https://root.cern/doc/v636/ac95.gif)

![https://root.cern/doc/v636/cp95.gif](https://root.cern/doc/v636/cp95.gif)

![https://root.cern/doc/v636/uni95.gif](https://root.cern/doc/v636/uni95.gif)

![https://root.cern/doc/v636/jeffrey95.gif](https://root.cern/doc/v636/jeffrey95.gif)

The average (over all possible true efficiencies) coverage probability for different number of total events is shown in the next picture.

![https://root.cern/doc/v636/av_cov.png](https://root.cern/doc/v636/av_cov.png)

## V. Merging and combining TEfficiency objects

In many applications, the efficiency should be calculated for an inhomogeneous sample in the sense that it contains events with different weights. In order to be able to determine the correct overall efficiency, it is necessary to use for each subsample (= all events with the same weight) a different [TEfficiency](@ref) object. After finishing your analysis you can then construct the overall efficiency with its uncertainty.

This procedure has the advantage that you can change the weight of one subsample easily without rerunning the whole analysis. On the other hand, more effort is needed to handle several [TEfficiency](@ref) objects instead of one histogram. In the case of many different or even continuously distributed weights, this approach becomes cumbersome. One possibility to overcome this problem is the usage of binned weights.

### Example

In particle physics weights arises from the fact that you want to normalise your results to a certain reference value. A very common formula for calculating weights is

\thebegin{eqnarray*}
   w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\
     &-& \sigma ...\ cross\ section \\
     &-& L ...\ luminosity \\
     &-& N_{gen}\ ... number\ of\ generated\ events \\
     &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\
\theend{eqnarray*}

The reason for different weights can therefore be:

- different processes
- other integrated luminosity
- varying trigger efficiency
- different sample sizes
- ...
- or even combination of them

Depending on the actual meaning of different weights in your case, you should either merge or combine them to get the overall efficiency.

### V.1 When should I use merging?

If the weights are artificial and do not represent real alternative hypotheses, you should merge the different [TEfficiency](@ref) objects. That means especially for the Bayesian case that the prior probability should be the same for all merged [TEfficiency](@ref) objects. The merging can be done by invoking one of the following operations:

- eff1.Add(eff2)
- eff1 += eff2
- eff1 = eff1 + eff2

The result of the merging is stored in the [TEfficiency](@ref) object which is marked bold above. The contents of the internal histograms of both [TEfficiency](@ref) objects are added and a new weight is assigned. The statistic options are not changed.

``\frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}``

### Example:

If you use two samples with different numbers of generated events for the same process and you want to normalise both to the same integrated luminosity and trigger efficiency, the different weights then arise just from the fact that you have different numbers of events. The [TEfficiency](@ref) objects should be merged because the samples do not represent true alternatives. You expect the same result as if you would have a big sample with all events in it.

``w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}``

### V.2 When should I use combining?

You should combine [TEfficiency](@ref) objects whenever the weights represent alternatives processes for the efficiency. As the combination of two [TEfficiency](@ref) objects is not always consistent with the representation by two internal histograms, the result is not stored in a [TEfficiency](@ref) object but a [TGraphAsymmErrors](@ref) is returned which shows the estimated combined efficiency and its uncertainty for each bin. At the moment the combination method [TEfficiency!Combine](@ref) only supports a combination of 1-dimensional efficiencies in a Bayesian approach.

For calculating the combined efficiency and its uncertainty for each bin only Bayesian statistics is used. No frequentists methods are presently supported for computing the combined efficiency and its confidence interval. In the case of the Bayesian statistics, a combined posterior is constructed taking into account the weight of each [TEfficiency](@ref) object. The same prior is used for all the [TEfficiency](@ref) objects.

\thebegin{eqnarray*}
  P_{comb}(\epsilon | {w_{i}}, {k_{i}} , {N_{i}}) = \frac{1}{norm} \prod_{i}{L(k_{i} | N_{i}, \epsilon)}^{w_{i}} \Pi( \epsilon )\\
L(k_{i} | N_{i}, \epsilon)\ is\ the\ likelihood\ function\ for\ the\ sample\ i\ (a\ Binomial\ distribution)\\
\Pi( \epsilon)\ is\ the\ prior,\ a\ beta\ distribution\ B(\epsilon, \alpha, \beta).\\
The\ resulting\ combined\ posterior\ is \\
P_{comb}(\epsilon |{w_{i}}; {k_{i}}; {N_{i}}) = B(\epsilon, \sum_{i}{ w_{i} k_{i}} + \alpha, \sum_{i}{ w_{i}(n_{i}-k_{i})}+\beta) \\
\hat{\varepsilon} = \int_{0}^{1} \epsilon \times P_{comb}(\epsilon | {k_{i}} , {N_{i}}) d\epsilon \\
confidence\ level = 1 - \alpha \\
\frac{\alpha}{2} = \int_{0}^{\epsilon_{low}} P_{comb}(\epsilon | {k_{i}} , {N_{i}}) d\epsilon ...\ defines\ lower\ boundary \\
1- \frac{\alpha}{2} = \int_{0}^{\epsilon_{up}} P_{comb}(\epsilon | {k_{i}} , {N_{i}}) d\epsilon ...\ defines\ upper\ boundary
\theend{eqnarray*}

### Example:

If you use cuts to select electrons which can originate from two different processes, you can determine the selection efficiency for each process. The overall selection efficiency is then the combined efficiency. The weights to be used in the combination should be the probability that an electron comes from the corresponding process.

``p_{1} = \frac{\sigma_{1}}{\sigma_{1} + \sigma_{2}} = \frac{N_{1}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\
p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}``

## VI. Further operations

### VI.1 Information about the internal histograms

The methods [TEfficiency!GetPassedHistogram](@ref) and [TEfficiency!GetTotalHistogram](@ref) return a constant pointer to the internal histograms. They can be used to obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...). One can obtain a clone of the internal histograms by calling [TEfficiency!GetCopyPassedHisto](@ref) or [TEfficiency!GetCopyTotalHisto](@ref). The returned histograms are completely independent from the current [TEfficiency](@ref) object. By default, they are not attached to a directory to avoid the duplication of data and the user is responsible for deleting them.

    //open a root file which contains a TEfficiency object
    TFile* pFile = new TFile("myfile.root","update");
    //get TEfficiency object with name "my_eff"
    TEfficiency* pEff = (TEfficiency*)pFile->Get("my_eff");
    //get clone of total histogram
    TH1* clone = pEff->GetCopyTotalHisto();
    //change clone...
    //save changes of clone directly
    clone->Write();
    //or append it to the current directory and write the file
    //clone->SetDirectory(gDirectory);
    //pFile->Write();
    //delete histogram object
    delete clone;
    clone = 0;

(C++ version of the code)

It is also possible to set the internal total or passed histogram by using the methods [TEfficiency!SetPassedHistogram](@ref) or [TEfficiency!SetTotalHistogram](@ref).

In order to ensure the validity of the [TEfficiency](@ref) object, the consistency of the new histogram and the stored histogram is checked. It might be impossible sometimes to change the histograms in a consistent way. Therefore one can force the replacement by passing the "f" option. Then the user has to ensure that the other internal histogram is replaced as well and that the [TEfficiency](@ref) object is in a valid state.

### VI.2 Fitting

The efficiency can be fitted using the [TEfficiency!Fit](@ref) function which internally uses the [TBinomialEfficiencyFitter!Fit](@ref) method. As this method is using a maximum-likelihood-fit, it is necessary to initialise the given fit function with reasonable thestart values. The resulting fit function is attached to the list of associated functions and will be drawn automatically during the next [TEfficiency!Draw](@ref) command. The list of associated function can be modified by using the pointer returned by [TEfficiency!GetListOfFunctions](@ref).

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_004.png](https://root.cern/doc/v636/pict1_TEfficiency_004.png)

### VI.3 Draw a TEfficiency object

A [TEfficiency](@ref) object can be drawn by calling the usual [TEfficiency!Draw](@ref) method. At the moment drawing is only supported for 1- and 2-dimensional [TEfficiency](@ref) objects. In the 1-dimensional case, you can use the same options as for the [TGraphAsymmErrors!Draw](@ref) method. For 2-dimensional [TEfficiency](@ref) objects, you can pass the same options as for a [TH2!Draw](@ref) object.

### VI.4 TEfficiency object's axis customisation

The axes of a [TEfficiency](@ref) object can be accessed and customised by calling the GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding [TAxis](@ref) methods. Note that in order to access the painted graph via [GetPaintedGraph()](@ref), one should either call Paint or, better, gPad->Update().

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_005.png](https://root.cern/doc/v636/pict1_TEfficiency_005.png)

Related functions: [`Add`](@ref), [`Browse`](@ref), [`CreateGraph2D`](@ref), [`CreateGraph`](@ref), [`CreateHistogram`](@ref), [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`FillWeighted`](@ref), [`Fill`](@ref), [`FindFixBin`](@ref), [`Fit`](@ref), [`GetBetaAlpha`](@ref), [`GetBetaBeta`](@ref), [`GetConfidenceLevel`](@ref), [`GetCopyPassedHisto`](@ref), [`GetCopyTotalHisto`](@ref), [`GetDimension`](@ref), [`GetDirectory`](@ref), [`GetEfficiencyErrorLow`](@ref), [`GetEfficiencyErrorUp`](@ref), [`GetEfficiency`](@ref), [`GetGlobalBin`](@ref), [`GetListOfFunctions`](@ref), [`GetPaintedGraph2D`](@ref), [`GetPaintedGraph`](@ref), [`GetPaintedHistogram`](@ref), [`GetPassedHistogram`](@ref), [`GetStatisticOption`](@ref), [`GetTotalHistogram`](@ref), [`GetWeight`](@ref), [`Merge`](@ref), [`Paint`](@ref), [`SavePrimitive`](@ref), [`SetBetaAlpha`](@ref), [`SetBetaBeta`](@ref), [`SetBetaBinParameters`](@ref), [`SetBins`](@ref), [`SetCentralInterval`](@ref), [`SetConfidenceLevel`](@ref), [`SetDirectory`](@ref), [`SetName`](@ref), [`SetPassedEvents`](@ref), [`SetPassedHistogram`](@ref), [`SetPosteriorAverage`](@ref), [`SetPosteriorMode`](@ref), [`SetShortestInterval`](@ref), [`SetStatisticOption`](@ref), [`SetTitle`](@ref), [`SetTotalEvents`](@ref), [`SetTotalHistogram`](@ref), [`SetUseWeightedEvents`](@ref), [`SetWeight`](@ref), [`TEfficiency!AgrestiCoull`](@ref), [`TEfficiency!Bayesian`](@ref), [`TEfficiency!BetaCentralInterval`](@ref), [`TEfficiency!BetaMean`](@ref), [`TEfficiency!BetaMode`](@ref), [`TEfficiency!BetaShortestInterval`](@ref), [`TEfficiency!CheckBinning`](@ref), [`TEfficiency!CheckConsistency`](@ref), [`TEfficiency!CheckEntries`](@ref), [`TEfficiency!CheckWeights`](@ref), [`TEfficiency!ClopperPearson`](@ref), [`TEfficiency!Combine`](@ref), [`TEfficiency!FeldmanCousinsInterval`](@ref), [`TEfficiency!FeldmanCousins`](@ref), [`TEfficiency!MidPInterval`](@ref), [`TEfficiency!Normal`](@ref), [`TEfficiency!Wilson`](@ref), [`TEfficiency`](@ref), [`UsesBayesianStat`](@ref), [`UsesCentralInterval`](@ref), [`UsesPosteriorAverage`](@ref), [`UsesPosteriorMode`](@ref), [`UsesShortestInterval`](@ref), [`UsesWeights`](@ref), [`add!`](@ref), [`assign`](@ref)
""" TEfficiency

# Wrapper of TGraphAsymmErrors
@trydoc raw"""
    ROOT.TGraphAsymmErrors

[TGraph](@ref) with asymmetric error bars.

The [TGraphAsymmErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphAsymmErrors_001.png](https://root.cern/doc/v636/pict1_TGraphAsymmErrors_001.png)

Related functions: [`Apply`](@ref), [`BayesDivide`](@ref), [`ComputeRange`](@ref), [`Divide`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`Merge`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointEXhigh`](@ref), [`SetPointEXlow`](@ref), [`SetPointEYhigh`](@ref), [`SetPointEYlow`](@ref), [`SetPointError`](@ref), [`TGraphAsymmErrors`](@ref), [`assign`](@ref)
""" TGraphAsymmErrors

# Wrapper of TGraph2DAsymmErrors
@trydoc raw"""
    ROOT.TGraph2DAsymmErrors

Graph 2D class with errors.

A [TGraph2DAsymmErrors](@ref) is a [TGraph2D](@ref) with asymmetric errors. It behaves like a [TGraph2D](@ref) and has the same drawing options.

The **"ERR"** drawing option allows to display the error bars. The following example shows how to use it:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2DAsymmErrors_001.png](https://root.cern/doc/v636/pict1_TGraph2DAsymmErrors_001.png)

Related functions: [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetEZhigh`](@ref), [`GetEZlow`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`GetErrorZ`](@ref), [`GetErrorZhigh`](@ref), [`GetErrorZlow`](@ref), [`GetXmaxE`](@ref), [`GetXminE`](@ref), [`GetYmaxE`](@ref), [`GetYminE`](@ref), [`GetZmaxE`](@ref), [`GetZminE`](@ref), [`Print`](@ref), [`RemovePoint`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`SetPoint`](@ref), [`Set`](@ref), [`TGraph2DAsymmErrors`](@ref), [`assign`](@ref)
""" TGraph2DAsymmErrors

# Wrapper of TH2
@trydoc raw"""
    ROOT.TH2

Service class for 2-D histogram classes.

- [TH2C](@ref) a 2-D histogram with one byte per cell (char). Maximum bin content = 127
- [TH2S](@ref) a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767
- [TH2I](@ref) a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX ([*](@ref))
- [TH2L](@ref) a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX ([**](@ref))
- [TH2F](@ref) a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
- [TH2D](@ref) a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))

<sup> (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br/>
 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760) </sup>

Related functions: [`AddBinContent`](@ref), [`BufferEmpty`](@ref), [`Copy`](@ref), [`FillN`](@ref), [`FillRandom`](@ref), [`Fill`](@ref), [`FitSlicesX`](@ref), [`FitSlicesY`](@ref), [`GetBinContent`](@ref), [`GetBinErrorLow`](@ref), [`GetBinErrorUp`](@ref), [`GetBinWithContent2`](@ref), [`GetBin`](@ref), [`GetCorrelationFactor`](@ref), [`GetCovariance`](@ref), [`GetRandom2`](@ref), [`GetStats`](@ref), [`IntegralAndError`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`KolmogorovTest`](@ref), [`ProfileX`](@ref), [`ProfileY`](@ref), [`ProjectionX`](@ref), [`ProjectionY`](@ref), [`PutStats`](@ref), [`QuantilesX`](@ref), [`QuantilesY`](@ref), [`Rebin2D`](@ref), [`RebinX`](@ref), [`RebinY`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetShowProjectionXY`](@ref), [`SetShowProjectionX`](@ref), [`SetShowProjectionY`](@ref), [`ShowBackground`](@ref), [`ShowPeaks`](@ref), [`Smooth`](@ref)
""" TH2

# Wrapper of TFormula
@trydoc raw"""
    ROOT.TFormula

The Formula class.

This is a new version of the [TFormula](@ref) class based on Cling. This class is not 100% backward compatible with the old [TFormula](@ref) class, which is still available in [ROOT](@ref) as `ROOT!v5!TFormula`. Some of the [TFormula](@ref) member functions available in version 5, such as `Analyze` and `AnalyzeFunction` are not available in the new [TFormula](@ref). On the other hand formula expressions which were valid in version 5 are still valid in [TFormula](@ref) version 6

This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.

### Example of valid expressions:

- `sin(x)/x`
- `[0]*sin(x) + [1]*exp(-[2]*x)`
- `x + y**2`
- `x^2 + y^2`
- `[0]*pow([1],4)`
- `2*pi*sqrt(x/y)`
- `gaus(0)*expo(3) + ypol3(5)*x`
- `gausn(0)*expo(3) + ypol3(5)*x`
- `gaus(x, [0..2]) + expo(y, [3..4])`

In the last examples above:

- `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)` and (0) means thestart numbering parameters at 0
- `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))` and (0) means thestart numbering parameters at 0
- `expo(3)` is a substitute for `exp([3]+[4]*x)`
- `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3` (`PolN` stands for Polynomial of degree N)
- `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`
- `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`

See below the [full list of predefined functions](@ref) which can be used as shortcuts in [TFormula](@ref).

`TMath` functions can be part of the expression, eg:

- `TMath!Landau(x)*sin(x)`
- `TMath!Erf(x)`

Formula may contain constants, eg:

- `sqrt2`
- `e`
- `pi`
- `ln10`
- `infinity`

and more.

Formulas may also contain other user-defined [ROOT](@ref) functions defined with a [TFormula](@ref), eg, where `f1` is defined on one x-dimension and 2 parameters:

- `f1(x, [omega], [phi])`
- `f1([0..1])`
- `f1([1], [0])`
- `f1(y)`

To replace only parameter names, the dimension variable can be dropped. Alternatively, to change only the dimension variable, the parameters can be dropped. Note that if a parameter is dropped or keeps its old name, its old value will be copied to the new function. The syntax used in the examples above also applies to the predefined parametrized functions like `gaus` and `expo`.

Comparisons operators are also supported `(&&, ||, ==, <=, >=, !)`

Examples:

`sin(x*(x<0.5 || x>1))`

If the result of a comparison is TRUE, the result is 1, otherwise 0.

Already predefined names can be given. For example, if the formula

`TFormula old("old",sin(x*(x<0.5 || x>1)))`

one can assign a name to the formula. By default the name of the object = title = formula itself.

`TFormula new("new","x*old")`

is equivalent to:

`TFormula new("new","x*sin(x*(x&lt;0.5 || x&gt;1))")`

The class supports unlimited number of variables and parameters. By default the names which can be used for the variables are `x,y,z,t` or `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.

This class is not anymore the base class for the function classes `TF1`, but it has now a data member of [TF1](@ref) which can be accessed via `TF1!GetFormula`.

[TFormula](@ref) supports gradient and hessian calculations through clad. To calculate the gradient one needs to first declare a `CladStorage` of the same size as the number of parameters and then pass the variables and the created `CladStorage`:

    TFormula f("f", "x*[0] - y*[1]");
    Double_t p[] = {40, 30};
    Double_t x[] = {1, 2};
    f.SetParameters(p);
    TFormula!CladStorage grad(2);
    f.GradientPar(x, grad);

(C++ version of the code)

The process is similar for hessians, except that the size of the created CladStorage should be the square of the number of parameters because `HessianPar` returns a flattened matrix:

    TFormula!CladStorage hess(4);
    f.HessianPar(x, hess);

(C++ version of the code)

### List of predefined functions

The list of available predefined functions which can be used as shortcuts is the following:

1. One Dimensional functions:

    - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x-[Mean])/[Sigma]))`
    - `landau` is a substitute for `[Constant]*TMath!Landau (x,[MPV],[Sigma],false)`
    - `expo` is a substitute for `exp([Constant]+[Slope]*x)`
    - `crystalball` is substitute for `[Constant]*ROOT!Math!crystalball_function (x,[Alpha],[N],[Sigma],[Mean])`
    - `breitwigner` is a substitute for `[p0]*ROOT!Math!breitwigner_pdf (x,[p2],[p1])`
    - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` : `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`
    - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`: `ROOT!Math!Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.
2. Two Dimensional functions:

    - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.
    - `bigaus` is a substitute for `[Constant]*ROOT!Math!bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.
3. Three Dimensional functions:

    - `xyzgaus` is for a 3d Gaussians without correlations: `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`

### An expanded note on variables and parameters

In a [TFormula](@ref), a variable is a defined by a name `x`, `y`, `z` or `t` or an index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.

    TFormula("", "x[0] * x[1] + 10")

(C++ version of the code)

Parameters are similar and can take any name. It is specified using brackets e.g. `[expected_mass]` or `[0]`.

    TFormula("", "exp([expected_mass])-1")

(C++ version of the code)

Variables and parameters can be combined in the same [TFormula](@ref). Here we consider a very simple case where we have an exponential decay after some time t and a number of events with timestamps for which we want to evaluate this function.

    TFormula tf ("", "[0]*exp(-[1]*t)");
    tf.SetParameter(0, 1);
    tf.SetParameter(1, 0.5);
    for (auto & event : events) {
       tf.Eval(event.t);
    }

(C++ version of the code)

The distinction between variables and parameters arose from the [TFormula](@ref)'s application in fitting. There parameters are fitted to the data provided through variables. In other applications this distinction can go away.

Parameter values can be provided dynamically using `TFormula!EvalPar` instead of `TFormula!Eval`. In this way parameters can be used identically to variables. See below for an example that uses only parameters to model a function.

    Int_t params[2] = {1, 2}; // {vel_x, vel_y}
    TFormula tf ("", "[vel_x]/sqrt(([vel_x + vel_y])**2)");
    tf.EvalPar(nullptr, params);

(C++ version of the code)

### A note on operators

All operators of C/C++ are allowed in a [TFormula](@ref) with a few caveats.

The operators `|`, `&`, `%` can be used but will raise an error if used in conjunction with a variable or a parameter. Variables and parameters are treated as doubles internally for which these operators are not defined. This means the following command will run successfully `root -l -q -e TFormula("", "x+(10%3)").Eval(0)` but not `root -l -q -e TFormula("", "x%10").Eval(0)`.

The operator `^` is defined to mean exponentiation instead of the C/C++ interpretation xor. `**` is added, also meaning exponentiation.

The operators `++` and `@` are added, and are shorthand for the a linear function. That means the expression `x@2` will be expanded to `[n]*x + [n+1]*2` where n is the first previously unused parameter number.

Related functions: [`AddParameter`](@ref), [`AddVariable`](@ref), [`AddVariables`](@ref), [`Clear`](@ref), [`Compile`](@ref), [`Copy`](@ref), [`EvalPar`](@ref), [`Eval`](@ref), [`GenerateGradientPar`](@ref), [`GenerateHessianPar`](@ref), [`GetExpFormula`](@ref), [`GetGradientFormula`](@ref), [`GetHessianFormula`](@ref), [`GetLinearPart`](@ref), [`GetNdim`](@ref), [`GetNpar`](@ref), [`GetNumber`](@ref), [`GetParName`](@ref), [`GetParNumber`](@ref), [`GetParameter`](@ref), [`GetParameters`](@ref), [`GetUniqueFuncName`](@ref), [`GetVarName`](@ref), [`GetVarNumber`](@ref), [`GetVariable`](@ref), [`GradientPar`](@ref), [`HasGeneratedGradient`](@ref), [`HasGeneratedHessian`](@ref), [`HessianPar`](@ref), [`IsLinear`](@ref), [`IsValid`](@ref), [`IsVectorized`](@ref), [`Print`](@ref), [`SetName`](@ref), [`SetParName`](@ref), [`SetParNames`](@ref), [`SetParameter`](@ref), [`SetParameters`](@ref), [`SetVariable`](@ref), [`SetVariables`](@ref), [`SetVectorized`](@ref), [`TFormula`](@ref), [`assign`](@ref)
""" TFormula

# Wrapper of TFormulaFunction
@trydoc raw"""
    ROOT.TFormulaFunction

Helper class for [TFormula](@ref).



Related functions: [`Base.:(<)`](@ref), [`Base.:(==)`](@ref), [`GetBody`](@ref), [`GetName`](@ref), [`GetNargs`](@ref), [`IsFuncCall`](@ref), [`TFormulaFunction`](@ref)
""" TFormulaFunction

# Wrapper of TFormulaVariable
@trydoc raw"""
    ROOT.TFormulaVariable

Another helper class for [TFormula](@ref).



Related functions: [`Base.:(<)`](@ref), [`GetArrayPos`](@ref), [`GetInitialValue`](@ref), [`GetName`](@ref), [`TFormulaVariable`](@ref)
""" TFormulaVariable

# Wrapper of TF1AbsComposition
@trydoc raw"""
    ROOT.TF1AbsComposition





Related functions: [`ClassDefOverride`](@ref), [`Copy`](@ref), [`SetParameters`](@ref), [`SetRange`](@ref), [`Update`](@ref), [`paren`](@ref)
""" TF1AbsComposition

# Wrapper of TF1Parameters
@trydoc raw"""
    ROOT.TF1Parameters

[TF1](@ref) Parameters class.



Related functions: [`GetParName`](@ref), [`GetParNumber`](@ref), [`GetParameter`](@ref), [`GetParameters`](@ref), [`ParamsVec`](@ref), [`SetParName`](@ref), [`SetParNames`](@ref), [`SetParameter`](@ref), [`SetParameters`](@ref), [`TF1Parameters`](@ref), [`assign`](@ref)
""" TF1Parameters

# Wrapper of TF2
@trydoc raw"""
    ROOT.TF2

A 2-Dim function with parameters.

The following types of functions can be created:

1. [Expression using variables x and y](@ref)
2. [Expression using a user defined function](@ref)
3. [Lambda Expression with x and y variables and parameters](@ref)

### Expression using variables x and y

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF2_001.png](https://root.cern/doc/v636/pict1_TF2_001.png)

### Expression using a user defined function

    Double_t func(Double_t *val, Double_t *par)
    {
       Float_t x = val[0];
       Float_t y = val[1];
       Double_t f = x*x-y*y;
       return f;
    }
    void fplot()
    {
       auto f = new TF2("f",func,-1,1,-1,1);
       f->Draw("surf1");
    }

(C++ version of the code)

### Lambda Expression with x and y variables and parameters

    root [0] TF2 f2("f2", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1)
    (TF2 &) Name: f2 Title: f2
    root [1] f2.SetParameter(0, 1.)
    root [2] f2.Eval(1., 2.)
    (double) 3.0000000

(C++ version of the code)

See [TF1](@ref) class for the list of functions formats

Related functions: [`CentralMoment2`](@ref), [`Copy`](@ref), [`Covariance2XY`](@ref), [`CreateHistogram`](@ref), [`DistancetoPrimitive`](@ref), [`DrawCopy`](@ref), [`DrawDerivative`](@ref), [`DrawIntegral`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetContourLevel`](@ref), [`GetContour`](@ref), [`GetMaximumXY`](@ref), [`GetMaximum`](@ref), [`GetMinimumXY`](@ref), [`GetMinimum`](@ref), [`GetNpy`](@ref), [`GetObjectInfo`](@ref), [`GetRandom2`](@ref), [`GetRandom`](@ref), [`GetRange`](@ref), [`GetSave`](@ref), [`GetYmax`](@ref), [`GetYmin`](@ref), [`Integral`](@ref), [`IsInside`](@ref), [`Mean2X`](@ref), [`Mean2Y`](@ref), [`Moment2`](@ref), [`Paint`](@ref), [`SavePrimitive`](@ref), [`Save`](@ref), [`SetContourLevel`](@ref), [`SetContour`](@ref), [`SetNpy`](@ref), [`SetRange`](@ref), [`TF2`](@ref), [`Variance2X`](@ref), [`Variance2Y`](@ref), [`assign`](@ref)
""" TF2

# Wrapper of TF12
@trydoc raw"""
    ROOT.TF12

A projection of a [TF2](@ref) along X or Y.

It has the same behaviour as a [TF1](@ref)

Example of a function

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF12_001.png](https://root.cern/doc/v636/pict1_TF12_001.png)

Related functions: [`Copy`](@ref), [`DrawCopy`](@ref), [`EvalPar`](@ref), [`Eval`](@ref), [`GetXY`](@ref), [`SavePrimitive`](@ref), [`SetXY`](@ref), [`TF12`](@ref)
""" TF12

# Wrapper of TSpline
@trydoc raw"""
    ROOT.TSpline

Base class for spline implementation containing the Draw/Paint methods.



Related functions: [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`GetDelta`](@ref), [`GetHistogram`](@ref), [`GetKnot`](@ref), [`GetNp`](@ref), [`GetNpx`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`Paint`](@ref), [`SaveAs`](@ref), [`SetNpx`](@ref), [`TSpline`](@ref)
""" TSpline

# Wrapper of TF1Convolution
@trydoc raw"""
    ROOT.TF1Convolution

Class wrapping convolution of two functions.

Class wrapping convolution of two functions: evaluation of $\int f(x)g(x-t)dx$

The convolution is performed by default using FFTW if it is available . One can pass optionally the range of the convolution (by default the first function range is used). Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be approximately zero at the theend of the range. If they are significantly different than zero on one side (e.g. the left side) a spill over will occur on the other side (e.g right side). If no function range is given by default the function1 range + 10% is used One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.

Related functions: [`ClassDefOverride`](@ref), [`Copy`](@ref), [`GetNpar`](@ref), [`GetParName`](@ref), [`GetRange`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`SetExtraRange`](@ref), [`SetNofPointsFFT`](@ref), [`SetNumConv`](@ref), [`SetParameters`](@ref), [`SetRange`](@ref), [`TF1Convolution!SetDefaultExtraRange`](@ref), [`TF1Convolution`](@ref), [`Update`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TF1Convolution

# Wrapper of TF1NormSum
@trydoc raw"""
    ROOT.TF1NormSum

Class adding two functions: c1*f1+c2*f2.



Related functions: [`ClassDefOverride`](@ref), [`Copy`](@ref), [`GetNpar`](@ref), [`GetParName`](@ref), [`GetParameters`](@ref), [`GetRange`](@ref), [`GetScale`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`SetParameters`](@ref), [`SetRange`](@ref), [`SetScale`](@ref), [`TF1NormSum`](@ref), [`Update`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TF1NormSum

# Wrapper of TF3
@trydoc raw"""
    ROOT.TF3

A 3-Dim function with parameters.



Related functions: [`CentralMoment3`](@ref), [`Copy`](@ref), [`Covariance3XY`](@ref), [`Covariance3XZ`](@ref), [`Covariance3YZ`](@ref), [`CreateHistogram`](@ref), [`DistancetoPrimitive`](@ref), [`DrawDerivative`](@ref), [`DrawIntegral`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetClippingBoxOn`](@ref), [`GetClippingBox`](@ref), [`GetMaximumXYZ`](@ref), [`GetMinimumXYZ`](@ref), [`GetNpz`](@ref), [`GetRandom3`](@ref), [`GetRange`](@ref), [`GetSave`](@ref), [`GetZmax`](@ref), [`GetZmin`](@ref), [`Integral`](@ref), [`IsInside`](@ref), [`Mean3X`](@ref), [`Mean3Y`](@ref), [`Mean3Z`](@ref), [`Moment3`](@ref), [`Paint`](@ref), [`SavePrimitive`](@ref), [`Save`](@ref), [`SetClippingBoxOff`](@ref), [`SetClippingBoxOn`](@ref), [`SetNpz`](@ref), [`SetRange`](@ref), [`TF3`](@ref), [`Variance3X`](@ref), [`Variance3Y`](@ref), [`Variance3Z`](@ref), [`assign`](@ref)
""" TF3

# Wrapper of TFractionFitter
@trydoc raw"""
    ROOT.TFractionFitter

Fits MC fractions to data histogram.

A la HMCMLL, see R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228, and [http://www.hep.man.ac.uk/~roger/hfrac.f](http://www.hep.man.ac.uk/~roger/hfrac.f)

The virtue of this fit is that it takes into account both data and Monte Carlo statistical uncertainties. The way in which this is done is through a standard likelihood fit using Poisson statistics; however, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimisation with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content. For more details please see the original publication cited above.

An example application of this fit is given below. For a TH1* histogram ("data") fitted as the sum of three Monte Carlo sources ("mc"):

    {
      TH1F *data;                              //data histogram
      TH1F *mc0;                               // first MC histogram
      TH1F *mc1;                               // second MC histogram
      TH1F *mc2;                               // third MC histogram
      ....                                     // retrieve histograms
       TObjArray *mc = new TObjArray(3);        // MC histograms are put in this array
       mc->Add(mc0);
       mc->Add(mc1);
       mc->Add(mc2);
       TFractionFitter* fit = new TFractionFitter(data, mc); // initialise
       fit->Constrain(1,0.0,1.0);               // constrain fraction 1 to be between 0 and 1
       fit->SetRangeX(1,15);                    // use only the first 15 bins in the fit
       Int_t status = fit->Fit();               // perform the fit
       std!cout << "fit status: " << status << std!endl;
       if (status == 0) {                       // check on fit status
         TH1F* result = (TH1F*) fit->GetPlot();
         data->Draw("Ep");
         result->Draw("same");
       }
    }

(C++ version of the code)

## Assumptions

A few assumptions need to be made for the fit procedure to be carried out: 1 The total number of events in each template is not too small (so that its Poisson uncertainty can be neglected). 2 The number of events in each bin is much smaller than the total number of events in each template (so that multinomial uncertainties can be replaced with Poisson uncertainties).

Biased fit uncertainties may result if these conditions are not fulfilled (see e.g. arXiv:0803.2711).

## Instantiation

A fit object is instantiated through TFractionFitter* fit = new [TFractionFitter(data, mc)](@ref); A number of basic checks (intended to ensure that the template histograms represent the same "kind" of distribution as the data one) are carried out. The [TVirtualFitter](@ref) object is then addressed and all fit parameters (the template fractions) declared (initially unbounded).

## Applying constraints

Fit parameters can be constrained through

fit->Constrain(parameter #, lower bound, upper bound);

Setting lower bound = upper bound = 0 removes the constraint (a la Minuit); however, a function 
```
fit->Unconstrain(parameter #)
```  is also provided to simplify this.

## Setting parameter values

The function 
```
ROOT!Fit!Fitter* fitter = fit->GetFitter();
```  is provided for direct access to the [ROOT!Fit!Fitter](@ref) object. This allows to set and fix parameter values, limits and set step sizes directly via 
```
fitter->Config().ParSettings(parameter #).Set(const std!string &name, double value, double step, double lower, double upper);
```  

## Restricting the fit range

The fit range can be restricted through 
```
fit->SetRangeX(first bin #, last bin #);
```  and freed using 
```
fit->ReleaseRangeX();
```  For 2D histograms the Y range can be similarly restricted using 
```
fit->SetRangeY(first bin #, last bin #);
fit->ReleaseRangeY();
```  and for 3D histograms also 
```
fit->SetRangeZ(first bin #, last bin #);
fit->ReleaseRangeZ();
```  It is also possible to exclude individual bins from the fit through 
```
fit->ExcludeBin(bin #);
```  where the given bin number is assumed to follow the [TH1!GetBin()](@ref) numbering. Any bins excluded in this way can be included again using the corresponding 
```
fit->IncludeBin(bin #);
```  

## Weights histograms

Weights histograms (for a motivation see the above publication) can be specified for the individual MC sources through 
```
fit->SetWeight(parameter #, pointer to weights histogram);
```  and unset by specifying a null pointer.

## Obtaining fit results

The fit is carried out through 
```
Int_t status = fit->Fit();
```  where status is the code returned from the "MINIMIZE" command. For fits that converged, parameter values and errors can be obtained through 
```
fit->GetResult(parameter #, value, error);
```  and the histogram corresponding to the total Monte Carlo prediction (which is not the same as a simple weighted sum of the input Monte Carlo distributions) can be obtained by 
```
TH1* result = fit->GetPlot();
```  

## Using different histograms

It is possible to change the histogram being fitted through 
```
fit->SetData(TH1* data);
```  and to change the template histogram for a given parameter number through 
```
fit->SetMC(parameter #, TH1* MC);
```  This can speed up code in case of multiple data or template histograms; however, it should be done with care as any settings are taken over from the previous fit. In addition, neither the dimensionality nor the numbers of bins of the histograms should change (in that case it is better to instantiate a new [TFractionFitter](@ref) object).

## Errors

Any serious inconsistency results in an error.

Related functions: [`Constrain`](@ref), [`ErrorAnalysis`](@ref), [`EvaluateFCN`](@ref), [`ExcludeBin`](@ref), [`Fit`](@ref), [`GetChisquare`](@ref), [`GetFitter`](@ref), [`GetMCPrediction`](@ref), [`GetNDF`](@ref), [`GetPlot`](@ref), [`GetProb`](@ref), [`GetResult`](@ref), [`IncludeBin`](@ref), [`ReleaseRangeX`](@ref), [`ReleaseRangeY`](@ref), [`ReleaseRangeZ`](@ref), [`SetData`](@ref), [`SetMC`](@ref), [`SetRangeX`](@ref), [`SetRangeY`](@ref), [`SetRangeZ`](@ref), [`SetWeight`](@ref), [`TFractionFitter`](@ref), [`UnConstrain`](@ref)
""" TFractionFitter

# Wrapper of TH2D
@trydoc raw"""
    ROOT.TH2D

2-D histogram with a double per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2D`](@ref), [`assign`](@ref)
""" TH2D

# Wrapper of TGraph2DErrors
@trydoc raw"""
    ROOT.TGraph2DErrors

Graph 2D class with errors.

A [TGraph2DErrors](@ref) is a [TGraph2D](@ref) with errors. It behaves like a [TGraph2D](@ref) and has the same drawing options.

The **"ERR"** drawing option allows to display the error bars. The following example shows how to use it:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2DErrors_001.png](https://root.cern/doc/v636/pict1_TGraph2DErrors_001.png)

Related functions: [`GetEX`](@ref), [`GetEY`](@ref), [`GetEZ`](@ref), [`GetErrorX`](@ref), [`GetErrorY`](@ref), [`GetErrorZ`](@ref), [`GetXmaxE`](@ref), [`GetXminE`](@ref), [`GetYmaxE`](@ref), [`GetYminE`](@ref), [`GetZmaxE`](@ref), [`GetZminE`](@ref), [`Print`](@ref), [`RemovePoint`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`SetPoint`](@ref), [`Set`](@ref), [`TGraph2DErrors`](@ref), [`assign`](@ref)
""" TGraph2DErrors

# Wrapper of TGraphBentErrors
@trydoc raw"""
    ROOT.TGraphBentErrors

A [TGraphBentErrors](@ref) is a [TGraph](@ref) with bent, asymmetric error bars.

The [TGraphBentErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphBentErrors_001.png](https://root.cern/doc/v636/pict1_TGraphBentErrors_001.png)

Related functions: [`Apply`](@ref), [`ComputeRange`](@ref), [`GetEXhigh`](@ref), [`GetEXhighd`](@ref), [`GetEXlow`](@ref), [`GetEXlowd`](@ref), [`GetEYhigh`](@ref), [`GetEYhighd`](@ref), [`GetEYlow`](@ref), [`GetEYlowd`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`TGraphBentErrors`](@ref)
""" TGraphBentErrors

# Wrapper of TGraphDelaunay
@trydoc raw"""
    ROOT.TGraphDelaunay

[TGraphDelaunay](@ref) generates a Delaunay triangulation of a [TGraph2D](@ref).

This triangulation code derives from an implementation done by Luke Jones (Royal Holloway, University of London) in April 2002 in the PAW context.

This software cannot be guaranteed to work under all circumstances. They were originally written to work with a few hundred points in an XY space with similar X and Y ranges.

Definition of Delaunay triangulation (After B. Delaunay): For a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circumcircle of any triangle in DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of points in S, the Voronoi diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exactly one point and every point in a given polygon is closer to its central point than to any other. A Voronoi diagram is sometimes also known as a Dirichlet tessellation.

![https://root.cern/doc/v636/tgraph2d_delaunay.png](https://root.cern/doc/v636/tgraph2d_delaunay.png)

[This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html) gives a nice practical view of Delaunay triangulation and Voronoi diagram.

Related functions: [`ComputeZ`](@ref), [`FindAllTriangles`](@ref), [`GetGraph2D`](@ref), [`GetMTried`](@ref), [`GetMarginBinsContent`](@ref), [`GetNTried`](@ref), [`GetNdt`](@ref), [`GetPTried`](@ref), [`GetXN`](@ref), [`GetXNmax`](@ref), [`GetXNmin`](@ref), [`GetYN`](@ref), [`GetYNmax`](@ref), [`GetYNmin`](@ref), [`Interpolate`](@ref), [`SetMarginBinsContent`](@ref), [`SetMaxIter`](@ref), [`TGraphDelaunay`](@ref)
""" TGraphDelaunay

# Wrapper of TGraphDelaunay2D
@trydoc raw"""
    ROOT.TGraphDelaunay2D

[TGraphDelaunay2D](@ref) generates a Delaunay triangulation of a [TGraph2D](@ref).

The algorithm used for finding the triangles is based on [CDT](https://github.com/artem-ogre/CDT), a C++ library for generating constraint or conforming Delaunay triangulations.

The [ROOT!Math!Delaunay2D](@ref) class provides a wrapper for using the **CDT** library.

This implementation provides large improvements in terms of computational performances compared to the legacy one available in [TGraphDelaunay](@ref), and it is by default used in [TGraph2D](@ref). The old, legacy implementation can be still used when calling `TGraph2D!GetHistogram` and `TGraph2D!Draw` with the `old` option.

Definition of Delaunay triangulation (After B. Delaunay): For a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circumcircle of any triangle in DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of points in S, the Voronoi diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exactly one point and every point in a given polygon is closer to its central point than to any other. A Voronoi diagram is sometimes also known as a Dirichlet tessellation.

![https://root.cern/doc/v636/tgraph2d_delaunay.png](https://root.cern/doc/v636/tgraph2d_delaunay.png)

[This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html) gives a nice practical view of Delaunay triangulation and Voronoi diagram.

Related functions: [`ComputeZ`](@ref), [`FindAllTriangles`](@ref), [`GetGraph2D`](@ref), [`GetMarginBinsContent`](@ref), [`GetNdt`](@ref), [`GetXNmax`](@ref), [`GetXNmin`](@ref), [`GetYNmax`](@ref), [`GetYNmin`](@ref), [`SetMarginBinsContent`](@ref), [`TGraphDelaunay2D`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TGraphDelaunay2D

# Wrapper of TGraphMultiErrors
@trydoc raw"""
    ROOT.TGraphMultiErrors

[TGraph](@ref) with asymmetric error bars and multiple y error dimensions.

The [TGraphMultiErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphMultiErrors_001.png](https://root.cern/doc/v636/pict1_TGraphMultiErrors_001.png)

Related functions: [`AddYError`](@ref), [`Apply`](@ref), [`BayesDivide`](@ref), [`ComputeRange`](@ref), [`DeleteYError`](@ref), [`Divide`](@ref), [`GetAttFill`](@ref), [`GetAttLine`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`GetFillColor`](@ref), [`GetFillStyle`](@ref), [`GetLineColor`](@ref), [`GetLineStyle`](@ref), [`GetLineWidth`](@ref), [`GetNYErrors`](@ref), [`GetSumErrorsMode`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetAttFill`](@ref), [`SetAttLine`](@ref), [`SetEY`](@ref), [`SetEYhigh`](@ref), [`SetEYlow`](@ref), [`SetFillColorAlpha`](@ref), [`SetFillColor`](@ref), [`SetFillStyle`](@ref), [`SetLineColorAlpha`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetPointEX`](@ref), [`SetPointEXhigh`](@ref), [`SetPointEXlow`](@ref), [`SetPointEY`](@ref), [`SetPointEYhigh`](@ref), [`SetPointEYlow`](@ref), [`SetPointError`](@ref), [`SetSumErrorsMode`](@ref), [`TGraphMultiErrors`](@ref), [`assign`](@ref)
""" TGraphMultiErrors

# Wrapper of TGraphSmooth
@trydoc raw"""
    ROOT.TGraphSmooth

A helper class to smooth [TGraph](@ref).

see examples in $ROOTSYS/tutorials/graphs/motorcycle.C and approx.C

Related functions: [`Approx`](@ref), [`Approxin`](@ref), [`Lowess`](@ref), [`SmoothKern`](@ref), [`SmoothLowess`](@ref), [`SmoothSuper`](@ref), [`Smoothin`](@ref), [`TGraphSmooth!Approx1`](@ref), [`TGraphSmooth!BDRksmooth`](@ref), [`TGraphSmooth!BDRsmooth`](@ref), [`TGraphSmooth!BDRsupsmu`](@ref), [`TGraphSmooth!Lowest`](@ref), [`TGraphSmooth!Psort`](@ref), [`TGraphSmooth!Rank`](@ref), [`TGraphSmooth!Rcmp`](@ref), [`TGraphSmooth`](@ref)
""" TGraphSmooth

# Wrapper of TGraphTime
@trydoc raw"""
    ROOT.TGraphTime

[TGraphTime](@ref) is used to draw a set of objects evolving with nsteps in time between tmin and tmax.

Each time step has a new list of objects. This list can be identical to the list of objects in the previous steps, but with different attributes. see example of use in $ROOTSYS/tutorials/graphs/gtime.C

Related functions: [`Add`](@ref), [`Draw`](@ref), [`GetSteps`](@ref), [`Paint`](@ref), [`SaveAnimatedGif`](@ref), [`SetSleepTime`](@ref), [`TGraphTime`](@ref)
""" TGraphTime

# Wrapper of TVirtualHistPainter
@trydoc raw"""
    ROOT.TVirtualHistPainter

Abstract interface to a histogram painter.



Related functions: [`DistancetoPrimitive`](@ref), [`DrawPanel`](@ref), [`ExecuteEvent`](@ref), [`GetContourList`](@ref), [`GetObjectInfo`](@ref), [`GetStack`](@ref), [`IsInside`](@ref), [`MakeCuts`](@ref), [`PaintStat`](@ref), [`Paint`](@ref), [`ProcessMessage`](@ref), [`SetHighlight`](@ref), [`SetHistogram`](@ref), [`SetShowProjectionXY`](@ref), [`SetShowProjection`](@ref), [`SetStack`](@ref), [`TVirtualHistPainter!HistPainter`](@ref), [`TVirtualHistPainter!SetPainter`](@ref), [`TVirtualHistPainter`](@ref)
""" TVirtualHistPainter

# Wrapper of TH1C
@trydoc raw"""
    ROOT.TH1C

1-D histogram with a byte per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1C`](@ref), [`assign`](@ref)
""" TH1C

# Wrapper of TH1S
@trydoc raw"""
    ROOT.TH1S

1-D histogram with a short per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1S`](@ref), [`assign`](@ref)
""" TH1S

# Wrapper of TH1I
@trydoc raw"""
    ROOT.TH1I

1-D histogram with an int per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1I`](@ref), [`assign`](@ref)
""" TH1I

# Wrapper of TH1L
@trydoc raw"""
    ROOT.TH1L

1-D histogram with a long64 per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1L`](@ref), [`assign`](@ref)
""" TH1L

# Wrapper of TH1D
@trydoc raw"""
    ROOT.TH1D

1-D histogram with a double per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1D`](@ref), [`assign`](@ref)
""" TH1D

# Wrapper of TH1K
@trydoc raw"""
    ROOT.TH1K

[TH1K](@ref) class supports the nearest K Neighbours method, widely used in cluster analysis.

This method is especially useful for small statistics. In this method : 
```
  DensityOfProbability ~ 1/DistanceToNearestKthNeighbour
  Ctr TH1K!TH1K(name,title,nbins,xlow,xup,K=0)
  differs from TH1F only by "K"
  K - is the order of K Neighbours method, usually >=3
  K = 0, means default, where K is selected by TH1K in such a way
         that DistanceToNearestKthNeighbour > BinWidth and K >=3
```  This class has been implemented by Victor Perevoztchikov [perev@bnl.gov](mailto:perev@bnl.gov)

Related functions: [`Copy`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinError`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`SetKOrd`](@ref), [`TH1K`](@ref)
""" TH1K

# Wrapper of TProfile
@trydoc raw"""
    ROOT.TProfile

Profile Histogram.

Profile histograms are used to display the mean value of Y and its error for each bin in X. The displayed error is by default the standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ). Profile histograms are in many cases an elegant replacement of two-dimensional histograms. The inter-relation of two measured quantities X and Y can always be visualized by a two-dimensional histogram or scatter plot, but if Y is an unknown (but single-valued) approximate function of X, this function is displayed by a profile histogram with much better precision than by a scatter plot.

The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for bin j. 

``\thebegin{align}
       H(j)  &=  \sum w \cdot Y \\
       E(j)  &=  \sum w \cdot Y^2 \\
       W(j)  &=  \sum w                   & &\text{if weights different from 1, the number of bin effective entries is used} \\
       h(j)  &=  H(j) / W(j)              & &\text{mean of Y,} \\
       s(j)  &=  \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\
       e(j)  &=  s(j)/\sqrt{W(j)}         & &\text{standard error on the mean} \\
  \theend{align}``

 The bin content is always the mean of the Y values, but errors change depending on options: 

``\thebegin{align}
      \text{GetBinContent}(j) &= h(j) \\
      \text{GetBinError}(j) &=
        \thebegin{cases}
          e(j)                 &\text{if option="" (default). Error of the mean of all y values.} \\
          s(j)                 &\text{if option="s". Standard deviation of all y values.} \\
          \thebegin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \theend{cases}       &\text{if option="i". This is useful for storing integers such as ADC counts.} \\
          1/\sqrt{W(j)}           &\text{if option="g". Error of a weighted mean for combining measurements with variances of } w. \\
        \theend{cases}
    \theend{align}``

 In the special case where s(j) is zero (eg, case of 1 entry only in one bin) the bin error [e(j)](@ref) is computed from the average of the s(j) for all bins if the static function [TProfile!Approximate()](@ref) has been called. This simple/crude approximation was suggested in order to keep the bin during a fit operation. But note that this approximation is not the default behaviour. See also [TProfile!BuildOptions](@ref) for more on error options.

### Creating and drawing a profile histogram

    {
      auto c1 = new TCanvas("c1","Profile histogram example",200,10,700,500);
      auto hprof  = new TProfile("hprof","Profile of pz versus px",100,-4,4,0,20);
      Float_t px, py, pz;
      for ( Int_t i=0; i<25000; i++) {
        gRandom->Rannor(px,py);
        pz = px*px + py*py;
        hprof->Fill(px,pz,1);
      }
      hprof->Draw();
    }

(C++ version of the code)

Related functions: [`Add`](@ref), [`BufferEmpty`](@ref), [`BuildOptions`](@ref), [`Copy`](@ref), [`Divide`](@ref), [`ExtendAxis`](@ref), [`FillN`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetBinSumw2`](@ref), [`GetErrorOption`](@ref), [`GetStats`](@ref), [`GetYmax`](@ref), [`GetYmin`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`ProjectionX`](@ref), [`PutStats`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinEntries`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetErrorOption`](@ref), [`Sumw2`](@ref), [`TProfile!Approximate`](@ref), [`TProfile`](@ref), [`assign`](@ref)
""" TProfile

# Wrapper of TH2C
@trydoc raw"""
    ROOT.TH2C

2-D histogram with a byte per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2C`](@ref), [`assign`](@ref)
""" TH2C

# Wrapper of TH2S
@trydoc raw"""
    ROOT.TH2S

2-D histogram with a short per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2S`](@ref), [`assign`](@ref)
""" TH2S

# Wrapper of TH2I
@trydoc raw"""
    ROOT.TH2I

2-D histogram with an int per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2I`](@ref), [`assign`](@ref)
""" TH2I

# Wrapper of TH2L
@trydoc raw"""
    ROOT.TH2L

2-D histogram with a long64 per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2L`](@ref), [`assign`](@ref)
""" TH2L

# Wrapper of TH2F
@trydoc raw"""
    ROOT.TH2F

2-D histogram with a float per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2F`](@ref), [`assign`](@ref)
""" TH2F

# Wrapper of TH2Poly
@trydoc raw"""
    ROOT.TH2Poly

2D Histogram with Polygonal Bins

## Overview

`TH2Poly` is a 2D Histogram class ([TH2](@ref)) allowing to define polygonal bins of arbitrary shape.

Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object. `TH2PolyBin` is a very simple class containing the vertices (stored as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal bin as well as several related functions.

Essentially, a `TH2Poly` is a [TList](@ref) of `TH2PolyBin` objects with methods to manipulate them.

Bins are defined using one of the `AddBin()` methods. The bin definition should be done before filling.

The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w) `. `w` is the weight. If no weight is specified, it is assumed to be 1.

Not all histogram's area need to be binned. Filling an area without bins, will falls into the overflows. Adding a bin is not retroactive; it doesn't affect previous fillings. A `Fill()` call, that was previously ignored due to the lack of a bin at the specified location, is not reconsidered when that location is binned later.

If there are two overlapping bins, the first one in the list will be incremented by `Fill()`.

The histogram may automatically extends its limits if a bin outside the histogram limits is added. This is done when the default constructor (with no arguments) is used. It generates a histogram with no limits along the X and Y axis. Adding bins to it will extend it up to a proper size.

`TH2Poly` implements a partitioning algorithm to speed up bins' filling (see the "Partitioning Algorithm" section for details). The partitioning algorithm divides the histogram into regions called cells. The bins that each cell intersects are recorded in an array of `TList`s. When a coordinate in the histogram is to be filled; the method (quickly) finds which cell the coordinate belongs. It then only loops over the bins intersecting that cell to find the bin the input coordinate corresponds to. The partitioning of the histogram is updated continuously as each bin is added. The default number of cells on each axis is 25. This number could be set to another value in the constructor or adjusted later by calling the `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is considerably faster than the brute force algorithm (i.e. checking if each bin contains the input coordinates), especially if the histogram is to be filled many times.

The following very simple macro shows how to build and fill a `TH2Poly`: 

    {
        auto h2p = new TH2Poly();
        Double_t x1[] = {0, 5, 6};
        Double_t y1[] = {0, 0, 5};
        Double_t x2[] = {0, -1, -1, 0};
        Double_t y2[] = {0, 0, -1, 3};
        Double_t x3[] = {4, 3, 0, 1, 2.4};
        Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};
        h2p->AddBin(3, x1, y1);
        h2p->AddBin(4, x2, y2);
        h2p->AddBin(5, x3, y3);
        h2p->Fill(0.1, 0.01, 3);
        h2p->Fill(-0.5, -0.5, 7);
        h2p->Fill(-0.7, -0.5, 1);
        h2p->Fill(1, 3, 1.5);
    }

(C++ version of the code)

More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoneycomb.C and th2polyUSA.C.

## Partitioning Algorithm

The partitioning algorithm forms an essential part of the `TH2Poly` class. It is implemented to speed up the filling of bins.

With the brute force approach, the filling is done in the following way: An iterator loops over all bins in the `TH2Poly` and invokes the method `IsInside()` for each of them. This method checks if the input location is in that bin. If the filling coordinate is inside, the bin is filled. Looping over all the bin is very slow.

The alternative is to divide the histogram into virtual rectangular regions called "cells". Each cell stores the pointers of the bins intersecting it. When a coordinate is to be filled, the method finds which cell the coordinate falls into. Since the cells are rectangular, this can be done very quickly. It then only loops over the bins associated with that cell and calls `IsInside()` only on that bins. This reduces considerably the number of bins on which `IsInside()` is called and therefore speed up by a huge factor the filling compare to the brute force approach where `IsInside()` is called for all bins.

The addition of bins to the appropriate cells is done when the bin is added to the histogram. To do this, `AddBin()` calls the `AddBinToPartition()` method. This method adds the input bin to the partitioning matrix.

The number of partition cells per axis can be specified in the constructor. If it is not specified, the default value of 25 along each axis will be assigned. This value was chosen because it is small enough to avoid slowing down [AddBin()](@ref), while being large enough to enhance [Fill()](@ref) by a considerable amount. Regardless of how it is initialized at construction time, it can be changed later with the `ChangePartition()` method. `ChangePartition()` deletes the old partition matrix and generates a new one with the specified number of cells on each axis.

The optimum number of partition cells per axis changes with the number of times `Fill()` will be called. Although partitioning greatly speeds up filling, it also adds a constant time delay into the code. When `Fill()` is to be called many times, it is more efficient to divide the histogram into a large number cells. However, if the histogram is to be filled only a few times, it is better to divide into a small number of cells.

Related functions: [`AddBin`](@ref), [`Add`](@ref), [`ChangePartition`](@ref), [`ClearBinContents`](@ref), [`Clone`](@ref), [`ComputeIntegral`](@ref), [`Copy`](@ref), [`CreateBin`](@ref), [`Divide`](@ref), [`FFT`](@ref), [`FillN`](@ref), [`Fill`](@ref), [`FindBin`](@ref), [`GetAsymmetry`](@ref), [`GetBinContentChanged`](@ref), [`GetBinContent`](@ref), [`GetBinError`](@ref), [`GetBinName`](@ref), [`GetBinTitle`](@ref), [`GetBins`](@ref), [`GetFloat`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNewBinAdded`](@ref), [`GetNumberOfBins`](@ref), [`GetStats`](@ref), [`Honeycomb`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`IsInsideBin`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinContentChanged`](@ref), [`SetBinContent`](@ref), [`SetBinError`](@ref), [`SetFloat`](@ref), [`SetNewBinAdded`](@ref), [`TH2Poly`](@ref), [`assign`](@ref)
""" TH2Poly

# Wrapper of TH2PolyBin
@trydoc raw"""
    ROOT.TH2PolyBin

Helper class to represent a bin in the [TH2Poly](@ref) histogram.



Related functions: [`ClearContent`](@ref), [`Fill`](@ref), [`GetArea`](@ref), [`GetBinNumber`](@ref), [`GetChanged`](@ref), [`GetContent`](@ref), [`GetPolygon`](@ref), [`GetXMax`](@ref), [`GetXMin`](@ref), [`GetYMax`](@ref), [`GetYMin`](@ref), [`IsInside`](@ref), [`SetChanged`](@ref), [`SetContent`](@ref), [`TH2PolyBin`](@ref)
""" TH2PolyBin

# Wrapper of TH3
@trydoc raw"""
    ROOT.TH3

The 3-D histogram classes derived from the 1-D histogram classes.

All operations are supported (fill, fit). Drawing is currently restricted to one single option. A cloud of points is drawn. The number of points is proportional to cell content.

- [TH3C](@ref) a 3-D histogram with one byte per cell (char). Maximum bin content = 127
- [TH3S](@ref) a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767
- [TH3I](@ref) a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX ([*](@ref))
- [TH3L](@ref) a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX ([**](@ref))
- [TH3F](@ref) a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
- [TH3D](@ref) a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))

<sup> (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br/>
 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760) </sup>

Related functions: [`AddBinContent`](@ref), [`BufferEmpty`](@ref), [`Copy`](@ref), [`FillRandom`](@ref), [`Fill`](@ref), [`FitSlicesZ`](@ref), [`GetBinContent`](@ref), [`GetBinErrorLow`](@ref), [`GetBinErrorUp`](@ref), [`GetBinWithContent3`](@ref), [`GetBin`](@ref), [`GetCorrelationFactor`](@ref), [`GetCovariance`](@ref), [`GetRandom3`](@ref), [`GetStats`](@ref), [`IntegralAndError`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`KolmogorovTest`](@ref), [`Project3DProfile`](@ref), [`Project3D`](@ref), [`ProjectionX`](@ref), [`ProjectionY`](@ref), [`ProjectionZ`](@ref), [`PutStats`](@ref), [`Rebin3D`](@ref), [`RebinX`](@ref), [`RebinY`](@ref), [`RebinZ`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetShowProjection`](@ref)
""" TH3

# Wrapper of TProfile2D
@trydoc raw"""
    ROOT.TProfile2D

Profile2D histograms are used to display the mean value of Z and its error for each cell in X,Y.

Profile2D histograms are in many cases an elegant replacement of three-dimensional histograms : the inter-relation of three measured quantities X, Y and Z can always be visualized by a three-dimensional histogram or scatter-plot; its representation on the line-printer is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) approximate function of X,Y this function is displayed by a profile2D histogram with much better precision than by a scatter-plot.

The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for cell i, j. 

``\thebegin{align}
      H(i,j)  &=  \sum w \cdot Z  \\
      E(i,j)  &=  \sum w \cdot Z^2 \\
      W(i,j)  &=  \sum w \\
      h(i,j)  &=  \frac{H(i,j)}{W(i,j)} \\
      s(i,j)  &=  \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\
      e(i,j)  &=  \frac{s(i,j)}{\sqrt{W(i,j)}}
 \theend{align}``

 The bin content is always the mean of the Z values, but errors change depending on options: 

``\thebegin{align}
     \text{GetBinContent}(i,j) &= h(i,j) \\
     \text{GetBinError}(i,j) &=
       \thebegin{cases}
         e(i,j)                 &\text{if option="" (default). Error of the mean of all z values.} \\
         s(i,j)                 &\text{if option="s". Standard deviation of z values.} \\
         \thebegin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \theend{cases}       &\text{if option="i". This is useful for storing integers such as ADC counts.} \\
         1/\sqrt{W(i,j)}           &\text{if option="g". Error of a weighted mean when combining measurements with variances of } w. \\
       \theend{cases}
   \theend{align}``

In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell) the bin error [e(I,J)](@ref) is computed from the average of the s(I,J) for all cells if the static function [TProfile2D!Approximate](@ref) has been called. This simple/crude approximation was suggested in order to keep the cell during a fit operation. But note that this approximation is not the default behaviour.

### Creating and drawing a 2D profile

    {
       auto c1 = new TCanvas("c1","Profile histogram example",200,10,700,500);
       auto hprof2d  = new TProfile2D("hprof2d","Profile of pz versus px and py",40,-4,4,40,-4,4,0,20);
       Float_t px, py, pz;
       for ( Int_t i=0; i<25000; i++) {
          gRandom->Rannor(px,py);
          pz = px*px + py*py;
          hprof2d->Fill(px,py,pz,1);
       }
       hprof2d->Draw();
    }

(C++ version of the code)

Related functions: [`Add`](@ref), [`BufferEmpty`](@ref), [`BuildOptions`](@ref), [`Copy`](@ref), [`Divide`](@ref), [`ExtendAxis`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetBinSumw2`](@ref), [`GetErrorOption`](@ref), [`GetNumberOfBins`](@ref), [`GetStats`](@ref), [`GetZmax`](@ref), [`GetZmin`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`ProfileX`](@ref), [`ProfileY`](@ref), [`ProjectionXY`](@ref), [`PutStats`](@ref), [`Rebin2D`](@ref), [`RebinX`](@ref), [`RebinY`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinEntries`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetErrorOption`](@ref), [`Sumw2`](@ref), [`TProfile2D!Approximate`](@ref), [`TProfile2D`](@ref), [`assign`](@ref)
""" TProfile2D

# Wrapper of TH3C
@trydoc raw"""
    ROOT.TH3C

3-D histogram with a byte per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3C`](@ref), [`assign`](@ref)
""" TH3C

# Wrapper of TH3S
@trydoc raw"""
    ROOT.TH3S

3-D histogram with a short per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3S`](@ref), [`assign`](@ref)
""" TH3S

# Wrapper of TH3I
@trydoc raw"""
    ROOT.TH3I

3-D histogram with an int per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3I`](@ref), [`assign`](@ref)
""" TH3I

# Wrapper of TH3L
@trydoc raw"""
    ROOT.TH3L

3-D histogram with a long64 per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3L`](@ref), [`assign`](@ref)
""" TH3L

# Wrapper of TH3F
@trydoc raw"""
    ROOT.TH3F

3-D histogram with a float per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3F`](@ref), [`assign`](@ref)
""" TH3F

# Wrapper of TH3D
@trydoc raw"""
    ROOT.TH3D

3-D histogram with a double per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3D`](@ref), [`assign`](@ref)
""" TH3D

# Wrapper of TBinIterator
@trydoc raw"""
    ROOT.TBinIterator





Related functions: [`Base.:(!=)`](@ref), [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`TBinIterator!End`](@ref), [`TBinIterator`](@ref), [`inc!`](@ref)
""" TBinIterator

# Wrapper of THistRange
@trydoc raw"""
    ROOT.THistRange





Related functions: [`THistRange`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" THistRange

# Wrapper of THLimitsFinder
@trydoc raw"""
    ROOT.THLimitsFinder

Class to compute nice axis limits.

This class is called by default by the histogramming system and also by [TTree!Draw](@ref), [TTreePlayer!DrawSelect](@ref). [TGaxis](@ref) use it also to optimize axis labels.

A different finder may be specified via THLimitsFinder!SetFinder.

Related functions: [`FindGoodLimits`](@ref), [`THLimitsFinder!GetLimitsFinder`](@ref), [`THLimitsFinder!OptimizeLimits`](@ref), [`THLimitsFinder!Optimize`](@ref), [`THLimitsFinder!SetLimitsFinder`](@ref), [`THLimitsFinder`](@ref)
""" THLimitsFinder

# Wrapper of TNDArray
@trydoc raw"""
    ROOT.TNDArray

N-Dim array class.

Storage layout: Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins: Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],...

fSizes stores the combined size of each bin in a dimension, i.e. in above example it would contain 24, 12, 3, 1.

Storage is allocated lazily, only when data is written to the array.

Related functions: [`AddAt`](@ref), [`AtAsDouble`](@ref), [`GetBin`](@ref), [`GetCellSize`](@ref), [`GetNbins`](@ref), [`GetNdimensions`](@ref), [`Init`](@ref), [`Reset`](@ref), [`SetAsDouble`](@ref), [`TNDArray`](@ref)
""" TNDArray

# Wrapper of TNDArrayRef
@trydoc raw"""
    ROOT.TNDArrayRef

gives access to a sub-dimension, e.g.

arr[0][1] in above three-dimensional example, up to an element with conversion operator to double: double value = arr[0][1][2];

Related functions: [`Base.getindex`](@ref), [`TNDArrayRef`](@ref), [`T`](@ref)
""" TNDArrayRef

# Wrapper of TNDArrayT
@trydoc raw"""
    ROOT.TNDArrayT





Related functions: [`AddAt`](@ref), [`AtAsDouble`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Init`](@ref), [`Reset`](@ref), [`SetAsDouble`](@ref), [`TNDArrayT`](@ref)
""" TNDArrayT

# Wrapper of THn
@trydoc raw"""
    ROOT.THn

Multidimensional histogram.

Use a [THn](@ref) if you really, really have to store more than three dimensions, and if a large fraction of all bins are filled. Better alternatives are

- [THnSparse](@ref) if a fraction of all bins are filled
- [TTree](@ref)

The major problem of [THn](@ref) is the memory use caused by n-dimensional histogramming: a THnD with 8 dimensions and 100 bins per dimension needs more than 2.5GB of RAM!

To construct a [THn](@ref) object you must use one of its templated, derived classes: 
```
THnD (typedef for THnT<Double_t>): bin content held by a Double_t,
THnF (typedef for THnT<Float_t>): bin content held by a Float_t,
THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,
THnI (typedef for THnT<Int_t>): bin content held by an Int_t,
THnS (typedef for THnT<Short_t>): bin content held by a Short_t,
THnC (typedef for THnT<Char_t>): bin content held by a Char_t,
```  They take name and title, the number of dimensions, and for each dimension the number of bins, the minimal, and the maximal value on the dimension's axis. A [TH2F](@ref) h("h","h",10, 0., 10., 20, -5., 5.) would correspond to 
```
Int_t bins[2] = {10, 20};
Double_t xmin[2] = {0., -5.};
Double_t xmax[2] = {10., 5.};
THnF hn("hn", "hn", 2, bins, xmin, xmax);
```  

## Filling

A [THn](@ref) is filled just like a regular histogram, using THn!Fill(x, weight), where x is a n-dimensional Double_t value. To take errors into account, [Sumw2()](@ref) must be called before filling the histogram. Storage is allocated when the first bin content is stored.

## Projections

The dimensionality of a [THn](@ref) can be reduced by projecting it to 1, 2, 3, or n dimensions, which can be represented by a [TH1](@ref), [TH2](@ref), [TH3](@ref), or a [THn](@ref). See the [Projection()](@ref) members. To only project parts of the histogram, call 
```
hn->GetAxis(12)->SetRange(from_bin, to_bin);
```  

## Conversion from other histogram classes

The static factory function [THn!CreateHn()](@ref) can be used to create a [THn](@ref) from a [TH1](@ref), [TH2](@ref), [TH3](@ref), [THnSparse](@ref) and (for copying) even from a [THn](@ref). The created [THn](@ref) will have compatble storage type, i.e. calling [CreateHn()](@ref) on a [TH2F](@ref) will create a THnF.

Related functions: [`AddBinContent`](@ref), [`AddBinError2`](@ref), [`CreateIter`](@ref), [`FillBin`](@ref), [`GetArray`](@ref), [`GetBinContent`](@ref), [`GetBinError2`](@ref), [`GetBin`](@ref), [`GetNbins`](@ref), [`Projection`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetBinError2`](@ref), [`Sumw2`](@ref), [`THn!CreateHn`](@ref)
""" THn

# Wrapper of THnBase
@trydoc raw"""
    ROOT.THnBase

Multidimensional histogram base.

Defines common functionality and interfaces for [THn](@ref), [THnSparse](@ref).

Related functions: [`AddBinContent`](@ref), [`AddBinError2`](@ref), [`Add`](@ref), [`Browse`](@ref), [`CalculateErrors`](@ref), [`ClassDefOverride`](@ref), [`ComputeIntegral`](@ref), [`CreateIter`](@ref), [`Divide`](@ref), [`FillBin`](@ref), [`Fill`](@ref), [`Fit`](@ref), [`GetAxis`](@ref), [`GetBinContent`](@ref), [`GetBinError2`](@ref), [`GetBinError`](@ref), [`GetBin`](@ref), [`GetCalculateErrors`](@ref), [`GetEntries`](@ref), [`GetListOfAxes`](@ref), [`GetListOfFunctions`](@ref), [`GetNbins`](@ref), [`GetNdimensions`](@ref), [`GetRandom`](@ref), [`GetSumw2`](@ref), [`GetSumw`](@ref), [`GetSumwx2`](@ref), [`GetSumwx`](@ref), [`GetWeightSum`](@ref), [`IsFolder`](@ref), [`IsInRange`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`PrintBin`](@ref), [`PrintEntries`](@ref), [`Print`](@ref), [`ProjectionND`](@ref), [`Projection`](@ref), [`RebinnedAdd`](@ref), [`Reset`](@ref), [`Scale`](@ref), [`SetBinContent`](@ref), [`SetBinEdges`](@ref), [`SetBinError2`](@ref), [`SetBinError`](@ref), [`SetEntries`](@ref), [`SetTitle`](@ref), [`Sumw2`](@ref)
""" THnBase

# Wrapper of THnChain
@trydoc raw"""
    ROOT.THnChain

A class to chain together multiple histograms.

This class allows to chain together any `THnBase`-derived (`THn` or `THnSparse`) histograms from multiple files. Operations on the axes and projections are supported. The intent is to allow convenient merging merging of projections of high-dimensional histograms.

    // `file1.root` and `file2.root` contain a `THnSparse` named `hsparse`.
    THnChain hs("hsparse");
    hs.AddFile("file1.root");
    hs.AddFile("file2.root");
    // Project out axis 0, integrate over other axes.
    TH1* h0 = hs.Projection(0);
    // Project out axis 0, integrate over other axes in their active ranges.
    hs.GetAxis(1)->SetRangeUser(0, 0.1); // select a subrange
    TH1* h0 = hs.Projection(0);

(C++ version of the code)

Related functions: [`AddFile`](@ref), [`GetAxis`](@ref), [`ProjectionND`](@ref), [`Projection`](@ref), [`THnChain`](@ref)
""" THnChain

# Wrapper of THnIter
@trydoc raw"""
    ROOT.THnIter

Iterator over [THnBase](@ref) bins.



Related functions: [`GetCoord`](@ref), [`HaveSkippedBin`](@ref), [`Next`](@ref), [`RespectsAxisRange`](@ref), [`THnIter`](@ref)
""" THnIter

# Wrapper of THnT
@trydoc raw"""
    ROOT.THnT

Templated implementation of the abstract base [THn](@ref).

All functionality and the interfaces to be used are in THn!

[THn](@ref) does not know how to store any bin content itself. Instead, this is delegated to the derived, templated class: the template parameter decides what the format for the bin content is. The actual storage is delegated to TNDArrayT<T>.

Typedefs exist for template parameters with [ROOT](@ref)'s generic types:

| **Templated name** | **Typedef** | **Bin content type** |
|:-------------------|:------------|:---------------------|
| THnT<Char_t>       | THnC        | Char_t               |
| THnT<Short_t>      | THnS        | Short_t              |
| THnT<Int_t>        | THnI        | Int_t                |
| THnT<Long64_t>     | THnL        | Long64_t             |
| THnT<Float_t>      | THnF        | Float_t              |
| THnT<Double_t>     | THnD        | Double_t             |

We recommend to use THnC wherever possible, and to map its value space of 256 possible values to e.g. float values outside the class. This saves an enormous amount of memory. Only if more than 256 values need to be distinguished should e.g. THnS or even THnF be chosen.

Implementation detail: the derived, templated class is kept extremely small on purpose. That way the (templated thus inlined) uses of this class will only create a small amount of machine code, in contrast to e.g. STL.

Related functions: [`GetArray`](@ref), [`THnT`](@ref)
""" THnT

# Wrapper of THnSparse
@trydoc raw"""
    ROOT.THnSparse

Efficient multidimensional histogram.

Use a [THnSparse](@ref) instead of [TH1](@ref) / [TH2](@ref) / [TH3](@ref) / array for histogramming when only a small fraction of bins is filled. A 10-dimensional histogram with 10 bins per dimension has 10^10 bins; in a naive implementation this will not fit in memory. [THnSparse](@ref) only allocates memory for the bins that have non-zero bin content instead, drastically reducing both the memory usage and the access time.

To construct a [THnSparse](@ref) object you must use one of its templated, derived classes:

- THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,
- THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,
- THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,
- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,
- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,
- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,

They take name and title, the number of dimensions, and for each dimension the number of bins, the minimal, and the maximal value on the dimension's axis. A [TH2](@ref) h("h","h",10, 0., 10., 20, -5., 5.) would correspond to 
```
Int_t bins[2] = {10, 20};
Double_t xmin[2] = {0., -5.};
Double_t xmax[2] = {10., 5.};
THnSparseD hs("hs", "hs", 2, bins, xmin, xmax);
```  

## Filling

A [THnSparse](@ref) is filled just like a regular histogram, using THnSparse!Fill(x, weight), where x is a n-dimensional Double_t value. To take errors into account, [Sumw2()](@ref) must be called before filling the histogram.

Bins are allocated as needed; the status of the allocation can be observed by [GetSparseFractionBins()](@ref), [GetSparseFractionMem()](@ref).

## Fast Bin Content Access

When iterating over a [THnSparse](@ref) one should only look at filled bins to save processing time. The number of filled bins is returned by [THnSparse!GetNbins()](@ref); the bin content for each (linear) bin number can be retrieved by THnSparse!GetBinContent(linidx, (Int_t*)coord). After the call, coord will contain the bin coordinate of each axis for the bin with linear index linidx. A possible call would be

std!cout << hs.GetBinContent(0, coord); std!cout <<" is the content of bin [x = " << coord[0] "
        << " | y = " << coord[1] << "]" << std!endl;

@subsection autotoc_md369 Efficiency
TH1 and TH2 are generally faster than THnSparse for one and two dimensional
distributions. THnSparse becomes competitive for a sparsely filled TH3
with large numbers of bins per dimension. The tutorial sparsehist.C
shows the turning point. On a AMD64 with 8GB memory, THnSparse "wins" starting with a [TH3](@ref) with 30 bins per dimension. Using a [THnSparse](@ref) for a one-dimensional histogram is only reasonable if it has a huge number of bins.

## Projections

The dimensionality of a [THnSparse](@ref) can be reduced by projecting it to 1, 2, 3, or n dimensions, which can be represented by a [TH1](@ref), [TH2](@ref), [TH3](@ref), or a [THnSparse](@ref). See the [Projection()](@ref) members. To only project parts of the histogram, call 
```
THnSparse!GetAxis(12)->SetRange(from_bin, to_bin);
```  

## Internal Representation

An entry for a filled bin consists of its n-dimensional coordinates and its bin content. The coordinates are compacted to use as few bits as possible; e.g. a histogram with 10 bins in x and 20 bins in y will only use 4 bits for the x representation and 5 bits for the y representation. This is handled by the internal class [THnSparseCompactBinCoord](@ref). Bin data (content and coordinates) are allocated in chunks of size fChunkSize; this parameter can be set when constructing a [THnSparse](@ref). Each chunk is represented by an object of class [THnSparseArrayChunk](@ref).

Translation from an n-dimensional bin coordinate to the linear index within the chunks is done by [GetBin()](@ref). It creates a hash from the compacted bin coordinates (the hash of a bin coordinate is the compacted coordinate itself if it takes less than 8 bytes, the size of a Long64_t. This hash is used to lookup the linear index in the [TExMap](@ref) member fBins; the coordinates of the entry fBins points to is compared to the coordinates passed to [GetBin()](@ref). If they do not match, these two coordinates have the same hash - which is extremely unlikely but (for the case where the compact bin coordinates are larger than 4 bytes) possible. In this case, fBinsContinued contains a chain of linear indexes with the same hash. Iterating through this chain and comparing each bin coordinates with the one passed to [GetBin()](@ref) will retrieve the matching bin.

Related functions: [`AddBinContent`](@ref), [`AddBinError2`](@ref), [`ClassDefOverride`](@ref), [`CreateIter`](@ref), [`GetBinContent`](@ref), [`GetBinError2`](@ref), [`GetBin`](@ref), [`GetChunkSize`](@ref), [`GetNChunks`](@ref), [`GetNbins`](@ref), [`GetSparseFractionBins`](@ref), [`GetSparseFractionMem`](@ref), [`Projection`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetBinError2`](@ref), [`SetFilledBins`](@ref), [`Sumw2`](@ref), [`THnSparse!CreateSparse`](@ref)
""" THnSparse

# Wrapper of THnSparseT
@trydoc raw"""
    ROOT.THnSparseT

Templated implementation of the abstract base [THnSparse](@ref).

All functionality and the interfaces to be used are in THnSparse!

[THnSparse](@ref) does not know how to store any bin content itself. Instead, this is delegated to the derived, templated class: the template parameter decides what the format for the bin content is. In fact it even defines the array itself; possible implementations probably derive from [TArray](@ref).

Typedefs exist for template parameters with [ROOT](@ref)'s generic types:

| **Templated name**    | **Typedef** | **Bin content type** |
|:----------------------|:------------|:---------------------|
| THnSparseT<TArrayC>   | THnSparseC  | Char_t               |
| THnSparseT<TArrayS>   | THnSparseS  | Short_t              |
| THnSparseT<TArrayI>   | THnSparseI  | Int_t                |
| THnSparseT<TArrayL64> | THnSparseL  | Long64_t             |
| THnSparseT<TArrayF>   | THnSparseF  | Float_t              |
| THnSparseT<TArrayD>   | THnSparseD  | Double_t             |

We recommend to use THnSparseC wherever possible, and to map its value space of 256 possible values to e.g. float values outside the class. This saves an enormous amount of memory. Only if more than 256 values need to be distinguished should e.g. THnSparseS or even THnSparseF be chosen.

Implementation detail: the derived, templated class is kept extremely small on purpose. That way the (templated thus inlined) uses of this class will only create a small amount of machine code, in contrast to e.g. STL.

Related functions: [`GenerateArray`](@ref), [`THnSparseT`](@ref)
""" THnSparseT

# Wrapper of THStack
@trydoc raw"""
    ROOT.THStack

The Histogram stack class.

A [THStack](@ref) is a collection of [TH1](@ref) or [TH2](@ref) histograms. By using [THStack!Draw()](@ref), the entire histogram collection is drawn at once according to the specified drawing option.

[THStack!Add()](@ref) allows adding a new histogram to the list. Note that the [THStack](@ref) does not take ownership of the objects in the list.

### Stack painting

By default, histograms are shown stacked:

- the first histogram is painted
- then the sum of the first and second histograms is painted, and so on

The axis ranges are computed automatically along the X and Y axes to display the complete histogram collection.

Warning: Histogram bins with negative content may produce wrong plots.

### Stack's drawing options

The specific stack's drawing options are:

- **NOSTACK** If option "nostack" is specified, histograms are all painted in the same pad as if the option "same" had been specified.
- **NOSTACKB** If the option "nostackb" is specified histograms are all painted on the same pad next to each other as bar plots.
- **PADS** if option "pads" is specified, the current pad/canvas is subdivided into a number of pads equal to the number of histograms and each histogram is painted into a separate pad.
- **NOCLEAR** By default the background of the histograms is erased before drawing the histograms. The option "noclear" avoids this behavior. This is useful when drawing a [THStack](@ref) on top of another plot. If the patterns used to draw the histograms in the stack are transparent, then the plot behind will be visible.

See the [THistPainter](@ref) class for the list of valid histograms' painting options.

Example;

(C++ version of the code)

![https://root.cern/doc/v636/pict1_THStack_001.png](https://root.cern/doc/v636/pict1_THStack_001.png)

A more complex example:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_THStack_002.png](https://root.cern/doc/v636/pict1_THStack_002.png)

Note that picking is supported for all drawing modes.

###Since

ROOT version 6.07/07: Stacks of 2D histograms can also be painted as candle plots: 

###Since

ROOT version 6.09/02: Stacks of 2D histograms can also be painted as violin plots, combinations of candle and violin plots are possible as well:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_THStack_003.png](https://root.cern/doc/v636/pict1_THStack_003.png)

Automatic coloring according to the current palette is available as shown in the following example:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_THStack_004.png](https://root.cern/doc/v636/pict1_THStack_004.png)

Related functions: [`Add`](@ref), [`Browse`](@ref), [`BuildPrimitives`](@ref), [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`GetHistogram`](@ref), [`GetHists`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNhists`](@ref), [`GetStack`](@ref), [`GetXaxis`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`Merge`](@ref), [`Modified`](@ref), [`Paint`](@ref), [`Print`](@ref), [`RecursiveRemove`](@ref), [`SavePrimitive`](@ref), [`SetHistogram`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`THStack`](@ref), [`ls`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" THStack

# Wrapper of TKDE
@trydoc raw"""
    ROOT.TKDE

Kernel Density Estimation class.

The three main references are:

1. "Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley",
2. "Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:
   Stata themodule for univariate kernel density estimation."
3. "Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer."
4. "Cranmer KS, Kernel Estimation in High-Energy
Physics. Computer Physics Communications 136:198-207,2001" - e-Print Archive: hep ex/0011057.

The algorithm is briefly described in (4). A binned version is also implemented to address the performance issue due to its data size dependance.

Related functions: [`Draw`](@ref), [`Fill`](@ref), [`GetAdaptiveWeights`](@ref), [`GetApproximateBias`](@ref), [`GetBias`](@ref), [`GetError`](@ref), [`GetFixedWeight`](@ref), [`GetFunction`](@ref), [`GetGraphWithErrors`](@ref), [`GetLowerFunction`](@ref), [`GetMean`](@ref), [`GetRAMISE`](@ref), [`GetSigma`](@ref), [`GetUpperFunction`](@ref), [`GetValue`](@ref), [`SetBinning`](@ref), [`SetIteration`](@ref), [`SetKernelType`](@ref), [`SetMirror`](@ref), [`SetNBins`](@ref), [`SetRange`](@ref), [`SetTuneFactor`](@ref), [`SetUseBinsNEvents`](@ref), [`TKDE`](@ref), [`paren`](@ref)
""" TKDE

# Wrapper of TLimit
@trydoc raw"""
    ROOT.TLimit

Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method.

Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006]. See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details.

It takes signal, background and data histograms wrapped in a [TLimitDataSource](@ref) as input and runs a set of Monte Carlo experiments in order to compute the limits. If needed, inputs are fluctuated according to systematics. The output is a [TConfidenceLevel](@ref).

The class [TLimitDataSource](@ref) takes the signal, background and data histograms as well as different systematics sources to form the [TLimit](@ref) input.

The class [TConfidenceLevel](@ref) represents the final result of the [TLimit](@ref) algorithm. It is created just after the time-consuming part and can be stored in a [TFile](@ref) for further processing. It contains light methods to return CLs, CLb and other interesting quantities.

The actual algorithm...

From an input ([TLimitDataSource](@ref)) it produces an output [TConfidenceLevel](@ref). For this, nmc Monte Carlo experiments are performed. As usual, the larger this number, the longer the compute time, but the better the result.

Supposing that there is a plotfile.root file containing 3 histograms (signal, background and data), you can imagine doing things like:

    TFile* infile=new TFile("plotfile.root","READ");
    infile->cd();
    TH1* sh=(TH1*)infile->Get("signal");
    TH1* bh=(TH1*)infile->Get("background");
    TH1* dh=(TH1*)infile->Get("data");
    TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);
    TConfidenceLevel *myconfidence = TLimit!ComputeLimit(mydatasource,50000);
    std!cout << "  CLs    : " << myconfidence->CLs()  << std!endl;
    std!cout << "  CLsb   : " << myconfidence->CLsb() << std!endl;
    std!cout << "  CLb    : " << myconfidence->CLb()  << std!endl;
    std!cout << "< CLs >  : " << myconfidence->GetExpectedCLs_b()  << std!endl;
    std!cout << "< CLsb > : " << myconfidence->GetExpectedCLsb_b() << std!endl;
    std!cout << "< CLb >  : " << myconfidence->GetExpectedCLb_b()  << std!endl;
    delete myconfidence;
    delete mydatasource;
    infile->Close();

(C++ version of the code)

 More information can still be found on [this page](http://cern.ch/aleph-proj-alphapp/doc/tlimit.html) 

###See

https://doi.org/10.1088/0954-3899/28/10/313 and https://cds.cern.ch/record/451614/files/open-2000-205.pdf 

###Note

see note about: "Should I use TRolke, TFeldmanCousins, TLimit?" in the TRolke class description.

Related functions: [`TLimit!ComputeLimit`](@ref), [`TLimit`](@ref)
""" TLimit

# Wrapper of TLimitDataSource
@trydoc raw"""
    ROOT.TLimitDataSource

This class serves as input for the [TLimit!ComputeLimit](@ref) method.

It takes the signal, background and data histograms to form a channel. More channels can be added using [AddChannel()](@ref), as well as different systematics sources.

Related functions: [`AddChannel`](@ref), [`GetBackground`](@ref), [`GetCandidates`](@ref), [`GetErrorNames`](@ref), [`GetErrorOnBackground`](@ref), [`GetErrorOnSignal`](@ref), [`GetSignal`](@ref), [`SetOwner`](@ref), [`TLimitDataSource`](@ref)
""" TLimitDataSource

# Wrapper of TMultiDimFit
@trydoc raw"""
    ROOT.TMultiDimFit

Multidimensional Fits in [ROOT](@ref).

## Overview

A common problem encountered in different fields of applied science is to find an expression for one physical quantity in terms of several others, which are directly measurable.

An example in high energy physics is the evaluation of the momentum of a charged particle from the observation of its trajectory in a magnetic field. The problem is to relate the momentum of the particle to the observations, which may consists of positional measurements at intervals along the particle trajectory.

The exact functional relationship between the measured quantities (e.g., the space-points) and the dependent quantity (e.g., the momentum) is in general not known, but one possible way of solving the problem, is to find an expression which reliably approximates the dependence of the momentum on the observations.

This explicit function of the observations can be obtained by a *least squares* fitting procedure applied to a representative sample of the data, for which the dependent quantity (e.g., momentum) and the independent observations are known. The function can then be used to compute the quantity of interest for new observations of the independent variables.

This class `TMultiDimFit` implements such a procedure in [ROOT](@ref). It is largely based on the CERNLIB MUDIFI package [2](classTMultiDimFit.html#mudifi). Though the basic concepts are still sound, and therefore kept, a few implementation details have changed, and this class can take advantage of MINUIT [4](classTMultiDimFit.html#minuit) to improve the errors of the fitting, thanks to the class [TMinuit](@ref).

In [5](classTMultiDimFit.html#wind72) and [6](classTMultiDimFit.html#wind81) H. Wind demonstrates the utility of this procedure in the context of tracking, magnetic field parameterisation, and so on. The outline of the method used in this class is based on Winds discussion, and I refer these two excellents text for more information.

And example of usage is given in multidimfit.C.

## The Method

Let $ D $ by the dependent quantity of interest, which depends smoothly on the observable quantities $ x_1, \ldots, x_N $ which we'll denote by $\mathbf{x}$. Given a training sample of $ M$ tuples of the form, ([TMultiDimFit!AddRow](@ref))

``\left(\mathbf{x}_j, D_j, E_j\right)\quad,``

 where $\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})$ are $ N$ independent variables, $ D_j$ is the known, quantity dependent at $\mathbf{x}_j$ and $ E_j$ is the square error in $ D_j$, the class will try to find the parameterization 

``D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right)
     = \sum_{l=1}^{L} c_l F_l(\mathbf{x})``

 such that

``S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2``

 is minimal. Here $p_{li}(x_i)$ are monomials, or Chebyshev or Legendre polynomials, labelled $l = 1, \ldots, L$, in each variable $ x_i$, $ i=1, \ldots, N$.

So what [TMultiDimFit](@ref) does, is to determine the number of terms $ L$, and then $ L$ terms (or functions) $ F_l$, and the $ L$ coefficients $ c_l$, so that $ S$ is minimal ([TMultiDimFit!FindParameterization](@ref)).

Of course it's more than a little unlikely that $ S$ will ever become exact zero as a result of the procedure outlined below. Therefore, the user is asked to provide a minimum relative error $ \epsilon$ ([TMultiDimFit!SetMinRelativeError](@ref)), and $ S$ will be considered minimized when

``R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon``

 Optionally, the user may impose a functional expression by specifying the powers of each variable in $ L$ specified functions $ F_1, \ldots,F_L$ ([TMultiDimFit!SetPowers](@ref)). In that case, only the coefficients $ c_l$ is calculated by the class.

## Limiting the Number of Terms

As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's always possible to fit an $ N-1$ polynomial in $ x$ to $ N$ points $ (x,y)$ with $\chi^2 = 0$, but the polynomial is not likely to fit new data at all [1](classTMultiDimFit.html#bevington). Therefore, the user is asked to provide an upper limit, $ L_{max}$ to the number of terms in $ D_p$ ([TMultiDimFit!SetMaxTerms](@ref)).

However, since there's an infinite number of $ F_l$ to choose from, the user is asked to give the maximum power. $ P_{max,i}$, of each variable $ x_i$ to be considered in the minimization of $ S$ ([TMultiDimFit!SetMaxPowers](@ref)).

One way of obtaining values for the maximum power in variable $ i$, is to perform a regular fit to the dependent quantity $ D$, using a polynomial only in $ x_i$. The maximum power is $ P_{max,i}$ is then the power that does not significantly improve the one-dimensional least-square fit over $ x_i$ to $ D$ [5](classTMultiDimFit.html#wind72).

There are still a huge amount of possible choices for $ F_l$; in fact there are $\prod_{i=1}^{N} (P_{max,i} + 1)$ possible choices. Obviously we need to limit this. To this theend, the user is asked to set a *power control limit*, $ Q$ ([TMultiDimFit!SetPowerLimit](@ref)), and a function $ F_l$ is only accepted if 

``Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q``

 where $ P_{li}$ is the leading power of variable $ x_i$ in function $ F_l$ ([TMultiDimFit!MakeCandidates](@ref)). So the number of functions increase with $ Q$ (1, 2 is fine, 5 is way out).

## Gram-Schmidt Orthogonalisation

To further reduce the number of functions in the final expression, only those functions that significantly reduce $ S$ is chosen. What 'significant' means, is chosen by the user, and will be discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)).

The functions $ F_l$ are generally not orthogonal, which means one will have to evaluate all possible $ F_l$'s over all data-points before finding the most significant [1](classTMultiDimFit.html#bevington). We can, however, do better then that. By applying the *modified Gram-Schmidt orthogonalisation* algorithm [5] [3] to the functions $ F_l$, we can evaluate the contribution to the reduction of $ S$ from each function in turn, and we may delay the actual inversion of the curvature-matrix ([TMultiDimFit!MakeGramSchmidt](@ref)).

So we are let to consider an $ M\times L$ matrix $\mathsf{F}$, an element of which is given by 

``f_{jl} = F_j\left(x_{1j} , x_{2j}, \ldots, x_{Nj}\right)
   = F_l(\mathbf{x}_j)\,  \quad\mbox{with}~j=1,2,\ldots,M,``

 where $ j$ labels the $ M$ rows in the training sample and $ l$ labels $ L$ functions of $ N$ variables, and $ L \leq M$. That is, $ f_{jl}$ is the term (or function) numbered $ l$ evaluated at the data point $ j$. We have to normalise $\mathbf{x}_j$ to $ [-1,1]$ for this to succeed [5] ([TMultiDimFit!MakeNormalized](@ref)). We then define a matrix $\mathsf{W}$ of which the columns $\mathbf{w}_j$ are given by \thebegin{eqnarray*}
   \mathbf{w}_1 &=& \mathbf{f}_1 = F_1\left(\mathbf x_1\right)\\
   \mathbf{w}_l &=& \mathbf{f}_l - \sum^{l-1}_{k=1} \frac{\mathbf{f}_l \bullet
   \mathbf{w}_k}{\mathbf{w}_k^2}\mathbf{w}_k\,.
 \theend{eqnarray*} and $\mathbf{w}_{l}$ is the component of $\mathbf{f}_{l} $ orthogonal to $\mathbf{w}_{1}, \ldots, \mathbf{w}_{l-1}$. Hence we obtain [3], 

``\mathbf{w}_k\bullet\mathbf{w}_l = 0\quad\mbox{if}~k \neq l\quad.``

 We now take as a new model $\mathsf{W}\mathbf{a}$. We thus want to minimize 

``S\equiv \left(\mathbf{D} - \mathsf{W}\mathbf{a}\right)^2\quad,``

 where $\mathbf{D} = \left(D_1,\ldots,D_M\right)$ is a vector of the dependent quantity in the sample. Differentiation with respect to $ a_j$ gives, using [6](classTMultiDimFit.html#wind81),  

``\mathbf{D}\bullet\mathbf{w}_l - a_l\mathbf{w}_l^2 = 0``

 or 

``a_l = \frac{\mathbf{D}_l\bullet\mathbf{w}_l}{\mathbf{w}_l^2}``

 Let $ S_j$ be the sum of squares of residuals when taking $ j$ functions into account. Then 

``S_l = \left[\mathbf{D} - \sum^l_{k=1} a_k\mathbf{w}_k\right]^2
   = \mathbf{D}^2 - 2\mathbf{D} \sum^l_{k=1} a_k\mathbf{w}_k
   + \sum^l_{k=1} a_k^2\mathbf{w}_k^2``

 Using [9](classTMultiDimFit.html#eq:dS2), we see that \thebegin{eqnarray*}
   S_l &=& \mathbf{D}^2 - 2 \sum^l_{k=1} a_k^2\mathbf{w}_k^2 +
   \sum^j_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\
   &=& \mathbf{D}^2 - \sum^l_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\
   &=& \mathbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf
   w_k\right)}{\mathbf w_k^2}
 \theend{eqnarray*} So for each new function $ F_l$ included in the model, we get a reduction of the sum of squares of residuals of $a_l^2\mathbf{w}_l^2$, where $\mathbf{w}_l$ is given by [4](classTMultiDimFit.html#minuit) and $ a_l$ by [9](classTMultiDimFit.html#eq:dS2). Thus, using the Gram-Schmidt orthogonalisation, we can decide if we want to include this function in the final model, before* the matrix inversion.

## Function Selection Based on Residual

Supposing that $ L-1$ steps of the procedure have been performed, the problem now is to consider the $L^{\mbox{th}}$ function.

The sum of squares of residuals can be written as 

``S_L = \textbf{D}^T\bullet\textbf{D} -
   \sum^L_{l=1}a^2_l\left(\textbf{w}_l^T\bullet\textbf{w}_l\right)``

 where the relation [9](classTMultiDimFit.html#eq:dS2) have been taken into account. The contribution of the $L^{\mbox{th}}$ function to the reduction of S, is given by 

``\Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right)``

 Two test are now applied to decide whether this $L^{\mbox{th}}$ function is to be included in the final expression, or not.

## Test 1

Denoting by $ H_{L-1}$ the subspace spanned by $\textbf{w}_1,\ldots,\textbf{w}_{L-1}$ the function $\textbf{w}_L$ is by construction (see 4) the projection of the function $ F_L$ onto the direction perpendicular to $ H_{L-1}$. Now, if the length of $\textbf{w}_L$ (given by $\textbf{w}_L\bullet\textbf{w}_L$) is very small compared to the length of $\textbf{f}_L$ this new function can not contribute much to the reduction of the sum of squares of residuals. The test consists then in calculating the angle $ \theta $ between the two vectors $\textbf{w}_L$ $ \textbf {f}_L$ (see also figure 1) and requiring that it's greater* then a threshold value which the user must set ([TMultiDimFit!SetMinAngle](@ref)).

![https://root.cern/doc/v636/multidimfit_img86.gif](https://root.cern/doc/v636/multidimfit_img86.gif)

## Test 2

Let $\textbf{D}$ be the data vector to be fitted. As illustrated in figure 1, the $L^{\mbox{th}}$ function $\textbf{w}_L$ will contribute significantly to the reduction of $ S$, if the angle $\phi^\prime$ between $\textbf{w}_L$ and $\textbf{D}$ is smaller than an upper limit $ \phi $, defined by the user (MultiDimFit!SetMaxAngle)

However, the method automatically readjusts the value of this angle while fitting is in progress, in order to make the selection criteria less and less difficult to be fulfilled. The result is that the functions contributing most to the reduction of $ S$ are chosen first ([TMultiDimFit!TestFunction](@ref)).

In case $ \phi $ isn't defined, an alternative method of performing this second test is used: The $L^{\mbox{th}}$ function $\textbf{f}_L$ is accepted if (refer also to equation (13)) 

``\Delta S_L > \frac{S_{L-1}}{L_{max}-L}``

 where $ S_{L-1}$ is the sum of the $ L-1$ first residuals from the $ L-1$ functions previously accepted; and $ L_{max}$ is the total number of functions allowed in the final expression of the fit (defined by user).

From this we see, that by restricting $ L_{max}$  the number of terms in the final model  the fit is more difficult to perform, since the above selection criteria is more limiting.

The more coefficients we evaluate, the more the sum of squares of residuals $ S$ will be reduced. We can evaluate $ S$ before inverting $\mathsf{B}$ as shown below.

## Coefficients and Coefficient Errors

Having found a parameterization, that is the $ F_l$'s and $ L$, that minimizes $ S$, we still need to determine the coefficients $ c_l$. However, it's a feature of how we choose the significant functions, that the evaluation of the $ c_l$'s becomes trivial [5](classTMultiDimFit.html#wind72). To derive $\mathbf{c}$, we first note that equation (4) can be written as 

``\mathsf{F} = \mathsf{W}\mathsf{B}``

 where \thebegin{eqnarray*}
   b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}
     & \mbox{if} & i < j\\
   1 & \mbox{if} & i = j\\
   0 & \mbox{if} & i > j
 \theend{eqnarray*} Consequently, $\mathsf{B}$ is an upper triangle matrix, which can be readily inverted. So we now evaluate 

``\mathsf{F}\mathsf{B}^{-1} = \mathsf{W}``

 The model $\mathsf{W}\mathbf{a}$ can therefore be written as $(\mathsf{F}\mathsf{B}^{-1})\mathbf{a} = \mathsf{F}(\mathsf{B}^{-1}\mathbf{a})\,.$

The original model $\mathsf{F}\mathbf{c}$ is therefore identical with this if 

``\mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =
   \left[\mathbf{a}^T\left(\mathsf{B}^{-1}\right)^T\right]^T\,.``

 The reason we use $\left(\mathsf{B}^{-1}\right)^T$ rather then $\mathsf{B}^{-1}$ is to save storage, since $\left(\mathsf{B}^{-1}\right)^T$ can be stored in the same matrix as $\mathsf{B}$ ([TMultiDimFit!MakeCoefficients](@ref)). The errors in the coefficients is calculated by inverting the curvature matrix of the non-orthogonal functions $ f_{lj}$ [1] ([TMultiDimFit!MakeCoefficientErrors](@ref)).

## Considerations

It's important to realize that the training sample should be representative of the problem at hand, in particular along the borders of the region of interest. This is because the algorithm presented here, is a *interpolation*, rather then a *extrapolation* [5](classTMultiDimFit.html#wind72).

Also, the independent variables $ x_{i}$ need to be linear independent, since the procedure will perform poorly if they are not [5](classTMultiDimFit.html#wind72). One can find an linear transformation from ones original variables $ \xi_{i}$ to a set of linear independent variables $ x_{i}$, using a *Principal Components Analysis* (see [TPrincipal](@ref)), and then use the transformed variable as input to this class [5] [6](classTMultiDimFit.html#wind81).

H. Wind also outlines a method for parameterising a multidimensional dependence over a multidimensional set of variables. An example of the method from [5](classTMultiDimFit.html#wind72), is a follows (please refer to [5](classTMultiDimFit.html#wind72) for a full discussion):

1. Define $\mathbf{P} = (P_1, \ldots, P_5)$ are the 5 dependent quantities that define a track.
2. Compute, for $ M$ different values of $\mathbf{P}$, the tracks through the magnetic field, and determine the corresponding $\mathbf{x} = (x_1, \ldots, x_N)$.
3. Use the simulated observations to determine, with a simple approximation, the values of $\mathbf{P}_j$. We call these values $\mathbf{P}^\prime_j, j = 1, \ldots, M$.
4. Determine from $\mathbf{x}$ a set of at least five relevant coordinates $\mathbf{x}^\prime$, using contrains, *or alternative:*
5. Perform a Principal Component Analysis (using [TPrincipal](@ref)), and use to get a linear transformation $\mathbf{x} \rightarrow \mathbf{x}^\prime$, so that $\mathbf{x}^\prime$ are constrained and linear independent.
6. Perform a Principal Component Analysis on $Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5$, to get linear indenpendent (among themselves, but not independent of $\mathbf{x}$) quantities $\mathbf{Q}^\prime$
7. For each component $Q^\prime_i$ make a multidimensional fit, using $\mathbf{x}^\prime$ as the variables, thus determining a set of coefficients $\mathbf{c}_i$.

To process data, using this parameterisation, do

1. Test wether the observation $\mathbf{x}$ within the domain of the parameterization, using the result from the Principal Component Analysis.
2. Determine $\mathbf{P}^\prime$ as before.
3. Determine $\mathbf{x}^\prime$ as before.
4. Use the result of the fit to determine $\mathbf{Q}^\prime$.
5. Transform back to $\mathbf{P}$ from $\mathbf{Q}^\prime$, using the result from the Principal Component Analysis.

## Testing the parameterization

The class also provides functionality for testing the, over the training sample, found parameterization ([TMultiDimFit!Fit](@ref)). This is done by passing the class a test sample of $ M_t$ tuples of the form $(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})$, where $\mathbf{x}_{t,j}$ are the independent variables, $ D_{t,j}$ the known, dependent quantity, and $ E_{t,j}$ is the square error in $ D_{t,j}$ ([TMultiDimFit!AddTestRow](@ref)).

The parameterization is then evaluated at every $\mathbf{x}_t$ in the test sample, and 

``S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -
   D_p\left(\mathbf{x}_{t,j}\right)\right)^2``

 is evaluated. The relative error over the test sample 

``R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}``

 should not be to low or high compared to $ R$ from the training sample. Also, multiple correlation coefficient from both samples should be fairly close, otherwise one of the samples is not representative of the problem. A large difference in the reduced $ \chi^2$ over the two samples indicate an over fit, and the maximum number of terms in the parameterisation should be reduced.

It's possible to use [4](classTMultiDimFit.html#minuit) to further improve the fit, using the test sample.

Christian Holm

## Bibliography

-  Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for the Physical Sciences*. McGraw-Hill, 2 edition, 1992.
-  R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.
- Gene H. Golub and Charles F. van Loan. *Matrix Computations*. John Hopkins University Press, Baltimore, 3 edition, 1996.
- F. James. *Minuit*. Long writeup D506, CERN, 1998.
- H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing School, volume 72-21 of Yellow report. CERN, 1972.
- H. Wind. 1. principal component analysis, 2. pattern recognition for track finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981.

Related functions: [`AddRow`](@ref), [`AddTestRow`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`Draw`](@ref), [`EvalError`](@ref), [`Eval`](@ref), [`FindParameterization`](@ref), [`Fit`](@ref), [`GetChi2`](@ref), [`GetCoefficientsRMS`](@ref), [`GetCoefficients`](@ref), [`GetCorrelationMatrix`](@ref), [`GetError`](@ref), [`GetFunctionCodes`](@ref), [`GetFunctions`](@ref), [`GetHistograms`](@ref), [`GetMaxAngle`](@ref), [`GetMaxFunctions`](@ref), [`GetMaxPowers`](@ref), [`GetMaxQuantity`](@ref), [`GetMaxStudy`](@ref), [`GetMaxTerms`](@ref), [`GetMaxVariables`](@ref), [`GetMeanQuantity`](@ref), [`GetMeanVariables`](@ref), [`GetMinAngle`](@ref), [`GetMinQuantity`](@ref), [`GetMinRelativeError`](@ref), [`GetMinVariables`](@ref), [`GetNCoefficients`](@ref), [`GetNVariables`](@ref), [`GetPolyType`](@ref), [`GetPowerIndex`](@ref), [`GetPowerLimit`](@ref), [`GetPowers`](@ref), [`GetPrecision`](@ref), [`GetQuantity`](@ref), [`GetRMS`](@ref), [`GetResidualMaxRow`](@ref), [`GetResidualMax`](@ref), [`GetResidualMinRow`](@ref), [`GetResidualMin`](@ref), [`GetResidualSumSq`](@ref), [`GetSampleSize`](@ref), [`GetSqError`](@ref), [`GetSumSqAvgQuantity`](@ref), [`GetSumSqQuantity`](@ref), [`GetTestError`](@ref), [`GetTestPrecision`](@ref), [`GetTestQuantity`](@ref), [`GetTestSampleSize`](@ref), [`GetTestSqError`](@ref), [`GetTestVariables`](@ref), [`GetVariables`](@ref), [`IsFolder`](@ref), [`MakeChi2`](@ref), [`MakeCode`](@ref), [`MakeHistograms`](@ref), [`MakeMethod`](@ref), [`Print`](@ref), [`SetBinVarX`](@ref), [`SetBinVarY`](@ref), [`SetMaxAngle`](@ref), [`SetMaxFunctions`](@ref), [`SetMaxPowers`](@ref), [`SetMaxStudy`](@ref), [`SetMaxTerms`](@ref), [`SetMinAngle`](@ref), [`SetMinRelativeError`](@ref), [`SetPowerLimit`](@ref), [`SetPowers`](@ref), [`TMultiDimFit!Instance`](@ref), [`TMultiDimFit`](@ref)
""" TMultiDimFit

# Wrapper of TMatrixT
@trydoc raw"""
    ROOT.TMatrixT

[TMatrixT](@ref).

Template class of a general matrix in the linear algebra package

See the [Matrix Linear Algebra](@ref) page for the documentation of the linear algebra package

Related functions: [`Base.getindex`](@ref), [`Class`](@ref), [`Clear`](@ref), [`Determinant`](@ref), [`EigenVectors`](@ref), [`GetColIndexArray`](@ref), [`GetMatrixArray`](@ref), [`GetRowIndexArray`](@ref), [`GetSub`](@ref), [`InvertFast`](@ref), [`Invert`](@ref), [`Minus`](@ref), [`MultT`](@ref), [`Mult`](@ref), [`NormByColumn`](@ref), [`NormByRow`](@ref), [`Plus`](@ref), [`Rank1Update`](@ref), [`ResizeTo`](@ref), [`SetColIndexArray`](@ref), [`SetRowIndexArray`](@ref), [`SetSub`](@ref), [`Similarity`](@ref), [`TMatrixT`](@ref), [`TMult`](@ref), [`T`](@ref), [`Transpose`](@ref), [`Use`](@ref), [`add!`](@ref), [`assign`](@ref), [`fdiv!`](@ref), [`mult!`](@ref), [`paren`](@ref), [`sub!`](@ref)
""" TMatrixT

# Wrapper of TMatrixTSym
@trydoc raw"""
    ROOT.TMatrixTSym

[TMatrixTSym](@ref).

Template class of a symmetric matrix in the linear algebra package.

See the [Matrix Linear Algebra](@ref) page for the documentation of the linear algebra package

Note that in this implementation both matrix element m[i][j] and m[j][i] are updated and stored in memory. However, when making the object persistent only the upper right triangle is stored.

Related functions: [`Apply`](@ref), [`Base.getindex`](@ref), [`Class`](@ref), [`Clear`](@ref), [`Determinant`](@ref), [`EigenVectors`](@ref), [`GetColIndexArray`](@ref), [`GetMatrixArray`](@ref), [`GetRowIndexArray`](@ref), [`GetSub`](@ref), [`InvertFast`](@ref), [`Invert`](@ref), [`IsSymmetric`](@ref), [`Minus`](@ref), [`Mult`](@ref), [`Plus`](@ref), [`RandomizePD`](@ref), [`Randomize`](@ref), [`Rank1Update`](@ref), [`ResizeTo`](@ref), [`SetColIndexArray`](@ref), [`SetMatrixArray`](@ref), [`SetRowIndexArray`](@ref), [`SetSub`](@ref), [`Shift`](@ref), [`SimilarityT`](@ref), [`Similarity`](@ref), [`TMatrixTSym`](@ref), [`TMult`](@ref), [`T`](@ref), [`Transpose`](@ref), [`Use`](@ref), [`add!`](@ref), [`assign`](@ref), [`mult!`](@ref), [`paren`](@ref), [`sub!`](@ref)
""" TMatrixTSym

# Wrapper of TPolyMarker
@trydoc raw"""
    ROOT.TPolyMarker

A PolyMarker is defined by an array on N points in a 2-D space.

At each point x[i], y[i] a marker is drawn. Marker attributes are managed by [TAttMarker](@ref). See [TMarker](@ref) for the list of possible marker types.

Related functions: [`Copy`](@ref), [`DistancetoPrimitive`](@ref), [`DrawPolyMarker`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetLastPoint`](@ref), [`GetN`](@ref), [`GetOption`](@ref), [`GetX`](@ref), [`GetY`](@ref), [`Merge`](@ref), [`PaintPolyMarker`](@ref), [`Paint`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetNextPoint`](@ref), [`SetPoint`](@ref), [`SetPolyMarker`](@ref), [`Size`](@ref), [`TPolyMarker`](@ref), [`ls`](@ref)
""" TPolyMarker

# Wrapper of TProfile2Poly
@trydoc raw"""
    ROOT.TProfile2Poly

2D Profile Histogram with Polygonal Bins.

tprofile2polyRealisticModuleError.C and tprofile2polyRealistic.C illustrate how to use this class.

Related functions: [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntriesVW`](@ref), [`GetBinEntriesW2`](@ref), [`GetBinEntriesWV2`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetOverflowContent`](@ref), [`GetStats`](@ref), [`Merge`](@ref), [`PrintOverflowRegions`](@ref), [`Reset`](@ref), [`SetContentToAverage`](@ref), [`SetContentToError`](@ref), [`SetErrorOption`](@ref), [`TProfile2Poly`](@ref)
""" TProfile2Poly

# Wrapper of TProfile2PolyBin
@trydoc raw"""
    ROOT.TProfile2PolyBin

Helper class to represent a bin in the [TProfile2Poly](@ref) histogram.



Related functions: [`ClearStats`](@ref), [`GetEffectiveEntries`](@ref), [`GetEntriesVW`](@ref), [`GetEntriesW2`](@ref), [`GetEntriesWV2`](@ref), [`GetEntries`](@ref), [`GetError`](@ref), [`Merge`](@ref), [`TProfile2PolyBin`](@ref), [`Update`](@ref)
""" TProfile2PolyBin

# Wrapper of TProfile3D
@trydoc raw"""
    ROOT.TProfile3D

Profile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z.

Profile3D histograms are in many cases an The inter-relation of three measured quantities X, Y, Z and T can always be visualized by a four-dimensional histogram or scatter-plot; its representation on the line-printer is not particularly satisfactory, except for sparse data. If T is an unknown (but single-valued) approximate function of X,Y,Z this function is displayed by a profile3D histogram with much better precision than by a scatter-plot.

The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 
```
                                                          2
  H(I,J,K)  =  sum T                      E(I,J,K)  =  sum T
  l(I,J,K)  =  sum l                      L(I,J,K)  =  sum l
  h(I,J,K)  =  H(I,J,K)/L(I,J,K)          s(I,J,K)  =  sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2)
  e(I,J,K)  =  s(I,J,K)/sqrt(L(I,J,K))
```  In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell) [e(I,J,K)](@ref) is computed from the average of the s(I,J,K) for all cells, if the static function [TProfile3D!Approximate](@ref) has been called. This simple/crude approximation was suggested in order to keep the cell during a fit operation. But note that this approximation is not the default behaviour.

Example of a profile3D histogram 

    {
        auto c1 = new TCanvas("c1","Profile histogram example",200,10,700,500);
        auto hprof3d  = new TProfile3D("hprof3d","Profile of pt versus px, py and pz",40,-4,4,40,-4,4,40,0,20);
        Double_t px, py, pz, pt;
        TRandom3 r(0);
        for ( Int_t i=0; i<25000; i++) {
           r.Rannor(px,py);
           pz = px*px + py*py;
           pt = r.Landau(0,1);
           hprof3d->Fill(px,py,pz,pt,1);
        }
        hprof3d->Draw();
    }

(C++ version of the code)

 NOTE: A [TProfile3D](@ref) is drawn as it was a simple [TH3](@ref)

Related functions: [`Add`](@ref), [`BufferEmpty`](@ref), [`BuildOptions`](@ref), [`Copy`](@ref), [`Divide`](@ref), [`ExtendAxis`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetBinSumw2`](@ref), [`GetErrorOption`](@ref), [`GetStats`](@ref), [`GetTmax`](@ref), [`GetTmin`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`Project3DProfile`](@ref), [`ProjectionXYZ`](@ref), [`PutStats`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinEntries`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetErrorOption`](@ref), [`Sumw2`](@ref), [`TProfile3D!Approximate`](@ref), [`TProfile3D`](@ref), [`assign`](@ref)
""" TProfile3D

# Wrapper of TScatter
@trydoc raw"""
    ROOT.TScatter

A [TScatter](@ref) is able to draw four variables scatter plot on a single plot.

The two first variables are the x and y position of the markers, the third is mapped on the current color map and the fourth on the marker size.

The following example demonstrates how it works:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TScatter_001.png](https://root.cern/doc/v636/pict1_TScatter_001.png)

### TScatter's plotting options

[TScatter](@ref) can be drawn with the following options:

| **Option** | **Description**                               |
|:-----------|:----------------------------------------------|
| "A"        | Produce a new plot with Axis around the graph |

Related functions: [`DistancetoPrimitive`](@ref), [`ExecuteEvent`](@ref), [`GetColor`](@ref), [`GetGraph`](@ref), [`GetHistogram`](@ref), [`GetMargin`](@ref), [`GetMaxMarkerSize`](@ref), [`GetMinMarkerSize`](@ref), [`GetSize`](@ref), [`Paint`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetHistogram`](@ref), [`SetMargin`](@ref), [`SetMaxMarkerSize`](@ref), [`SetMinMarkerSize`](@ref), [`TScatter`](@ref)
""" TScatter

# Wrapper of TSplinePoly
@trydoc raw"""
    ROOT.TSplinePoly

Base class for [TSpline](@ref) knot.



Related functions: [`Eval`](@ref), [`GetKnot`](@ref), [`TSplinePoly`](@ref), [`X`](@ref), [`Y`](@ref), [`assign`](@ref)
""" TSplinePoly

# Wrapper of TSplinePoly3
@trydoc raw"""
    ROOT.TSplinePoly3

Class for [TSpline3](@ref) knot.



Related functions: [`B`](@ref), [`C`](@ref), [`D`](@ref), [`Derivative`](@ref), [`Eval`](@ref), [`TSplinePoly3`](@ref), [`assign`](@ref)
""" TSplinePoly3

# Wrapper of TSplinePoly5
@trydoc raw"""
    ROOT.TSplinePoly5

Class for [TSpline5](@ref) knot.



Related functions: [`B`](@ref), [`C`](@ref), [`D`](@ref), [`Derivative`](@ref), [`E`](@ref), [`Eval`](@ref), [`F`](@ref), [`TSplinePoly5`](@ref), [`assign`](@ref)
""" TSplinePoly5

# Wrapper of TSpline3
@trydoc raw"""
    ROOT.TSpline3

Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives at beginning and ending points.



Related functions: [`Derivative`](@ref), [`Eval`](@ref), [`FindX`](@ref), [`GetCoeff`](@ref), [`GetKnot`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SetPointCoeff`](@ref), [`SetPoint`](@ref), [`TSpline3!Test`](@ref), [`TSpline3`](@ref), [`assign`](@ref)
""" TSpline3

# Wrapper of TSpline5
@trydoc raw"""
    ROOT.TSpline5

Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives using double knots (see BuildCoeff) for more on this.

Double knots are automatically introduced at ending points

Related functions: [`Derivative`](@ref), [`Eval`](@ref), [`FindX`](@ref), [`GetCoeff`](@ref), [`GetKnot`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SetPointCoeff`](@ref), [`SetPoint`](@ref), [`TSpline5!Test`](@ref), [`TSpline5`](@ref), [`assign`](@ref)
""" TSpline5

# Wrapper of TSVDUnfold
@trydoc raw"""
    ROOT.TSVDUnfold

SVD Approach to Data Unfolding.

Reference: [Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]](http://arXiv.org/abs/hep-ph/9509307) 

[TSVDUnfold](@ref) implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum. 

The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. 

Monte Carlo inputs: 

- `xini`: true underlying spectrum ([TH1D](@ref), n bins) 
- `bini`: reconstructed spectrum ([TH1D](@ref), n bins) 
- `Adet`: response matrix ([TH2D](@ref), nxn bins) 
Consider the unfolding of a measured spectrum `bdat` with covariance matrix `Bcov` (if not passed explicitly, a diagonal covariance will be built given the errors of `bdat`). The corresponding spectrum in the Monte Carlo is given by `bini`, with the true underlying spectrum given by `xini`. The detector response is described by `Adet`, with `Adet` filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. 

The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of `xini` and `Adet`.<br/>
<br/>
 

The unfolding can be performed by 

    TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );
    TH1D* unfresult = tsvdunf->Unfold( kreg );

(C++ version of the code)

 where `kreg` determines the regularisation of the unfolding. In general, overregularisation (too small `kreg`) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large `kreg`) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in [Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]](http://arXiv.org/abs/hep-ph/9509307) using the distribution of the `|d_i|` that can be obtained by `tsvdunf->GetD()` and/or using pseudo-experiments. 

Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the `GetUnfoldCovMatrix` method, which uses pseudo experiments for the propagation. In addition, `GetAdetCovMatrix` allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to `Bcov` is also computed as described in [Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]](http://arXiv.org/abs/hep-ph/9509307) and can be obtained from `tsvdunf->GetXtau()` and its (regularisation independent) inverse from `tsvdunf->GetXinv()`. The distribution of singular values can be retrieved using `tsvdunf->GetSV()`. 

See also the tutorial for a toy example.

Related functions: [`ComputeChiSquared`](@ref), [`GetAdetCovMatrix`](@ref), [`GetBCov`](@ref), [`GetD`](@ref), [`GetKReg`](@ref), [`GetSV`](@ref), [`GetUnfoldCovMatrix`](@ref), [`GetXinv`](@ref), [`GetXtau`](@ref), [`SetNormalize`](@ref), [`TSVDUnfold`](@ref), [`Unfold`](@ref)
""" TSVDUnfold

# Wrapper of TVirtualGraphPainter
@trydoc raw"""
    ROOT.TVirtualGraphPainter

Abstract interface to a histogram painter.



Related functions: [`DistancetoPrimitiveHelper`](@ref), [`DrawPanelHelper`](@ref), [`ExecuteEventHelper`](@ref), [`GetObjectInfoHelper`](@ref), [`PaintGrapHist`](@ref), [`PaintGraph`](@ref), [`PaintHelper`](@ref), [`PaintScatter`](@ref), [`PaintStats`](@ref), [`SetHighlight`](@ref), [`TVirtualGraphPainter!GetPainter`](@ref), [`TVirtualGraphPainter!SetPainter`](@ref), [`TVirtualGraphPainter`](@ref)
""" TVirtualGraphPainter

# Wrapper of TVirtualPaveStats
@trydoc raw"""
    ROOT.TVirtualPaveStats





Related functions: [`GetParent`](@ref), [`SetParent`](@ref)
""" TVirtualPaveStats

# Wrapper of TGDMLMatrix
@trydoc raw"""
    ROOT.TGDMLMatrix

This class is used in the process of reading and writing the GDML "matrix" tag.

It represents a matrix with arbitrary number of rows and columns, storing elements in double precision.

Related functions: [`GetCols`](@ref), [`GetMatrixAsString`](@ref), [`GetRows`](@ref), [`Get`](@ref), [`Print`](@ref), [`SetMatrixAsString`](@ref), [`Set`](@ref), [`TGDMLMatrix`](@ref), [`assign`](@ref)
""" TGDMLMatrix

# Wrapper of TGeoShape
@trydoc raw"""
    ROOT.TGeoShape

Base abstract class for all shapes.

Shapes are geometrical objects that provide the basic modelling functionality. They provide the definition of the LOCAL frame of coordinates, with respect to which they are defined. Any implementation of a shape deriving from the base [TGeoShape](@ref) class has to provide methods for :

- finding out if a point defined in their local_ frame is or not contained inside;
- computing the distance from a local_ point to getting outside/entering the shape, given a known direction;
- computing the maximum distance in any direction from a local_ point that does NOT result in a boundary crossing of the shape (safe distance);
- computing the cosines of the normal vector to the crossed shape surface, given a starting local_ point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods :
- computation of the minimal box bounding the shape, given that this box have to be aligned with the local_ coordinates;
- algorithms for dividing the shape along a given axis and producing resulting divisions volumes.

The modeler currently provides a set of 16 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes made as a result of boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (composition of composites). This allows the creation of a quite large number of different shape topologies and combinations.

Named shapes register themselves to the manager class at creation time. The manager is responsible for their final deletion. Shapes can be created using their default constructor if their retrieval by name is not needed, but in this case they are owned by the user. A shape may be referenced by several volumes, therefore its deletion is not possible once volumes were defined based on it.

### Creating shapes

Shape objects embed only the minimum set of parameters that are fully describing a valid physical shape. For instance, a tube is represented by its half length, the minimum radius and the maximum radius. Shapes are used together with media in order to create volumes, which in their turn are the main components of the geometrical tree. A specific shape can be created stand-alone :

    TGeoBBox *box = new TGeoBBox("s_box", halfX, halfY, halfZ); // named
    TGeoTube *tub = new TGeoTube(rmin, rmax, halfZ);            // no name
    ...  (see each specific shape constructors)

(C++ version of the code)

Sometimes it is much easier to create a volume having a given shape in one step, since shapes are not directly linked in the geometrical tree but volumes are :

    TGeoVolume *vol_box = gGeoManager->MakeBox("BOX_VOL", "mat1", halfX, halfY, halfZ);
    TGeoVolume *vol_tub = gGeoManager->MakeTube("TUB_VOL", "mat2", rmin, rmax, halfZ);
    ...  (see MakeXXX() utilities in TGeoManager class)

(C++ version of the code)

### Shape queries

Note that global_ queries related to a geometry are handled by the manager class. However, shape-related queries might be sometimes useful.

#### Bool_t TGeoShape!Contains(const Double_t *point[3])

this method returns true if POINT is actually inside the shape. The point has to be defined in the local_ shape reference. For instance, for a box having DX, DY and DZ half-lengths a point will be considered inside if :

    | -DX <= point[0] <= DX
    | -DY <= point[1] <= DY
    | -DZ <= point[2] <= DZ

(C++ version of the code)

#### Double_t TGeoShape!DistFromInside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local_ shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape!DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside)

compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.

#### Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside)

returns director cosines of normal to the crossed shape surface from a given point towards a direction. One has to specify if the point is inside or outside shape. According to this, the normal will be outwards or inwards shape respectively. Normal components are statically stored by shape class, so it has to be copied after retrieval in a different array.

### Dividing shapes

Shapes can generally be divided along a given axis. Supported axis are X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes should not be performed by [TGeoShape!Divide()](@ref) calls, but rather by [TGeoVolume!Divide()](@ref). The algorithm for dividing a specific shape is known by the shape object, but is always invoked in a generic way from the volume level. Details on how to do that can be found in [TGeoVolume](@ref) class. One can see how all division options are interpreted and which is their result inside specific shape classes.

![https://root.cern/doc/v636/geom_t_shape.png](https://root.cern/doc/v636/geom_t_shape.png)

Related functions: [`AfterStreamer`](@ref), [`Capacity`](@ref), [`CheckShape`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CouldBeCrossed`](@ref), [`CreateThreadData`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetFittingBox`](@ref), [`GetId`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetName`](@ref), [`GetNmeshVertices`](@ref), [`GetPointerName`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`InvertShapeBit`](@ref), [`IsAssembly`](@ref), [`IsComposite`](@ref), [`IsCylType`](@ref), [`IsReflected`](@ref), [`IsRunTimeShape`](@ref), [`IsValidBox`](@ref), [`IsValid`](@ref), [`IsVecGeom`](@ref), [`MakeBuffer3D`](@ref), [`Paint`](@ref), [`ResetShapeBit`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SetDimensions`](@ref), [`SetId`](@ref), [`SetPoints`](@ref), [`SetRuntime`](@ref), [`SetSegsAndPols`](@ref), [`SetShapeBit`](@ref), [`ShapeDistancetoPrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoShape!Big`](@ref), [`TGeoShape!ComputeEpsMch`](@ref), [`TGeoShape!DistToPhiMin`](@ref), [`TGeoShape!EpsMch`](@ref), [`TGeoShape!GetTransform`](@ref), [`TGeoShape!IsCloseToPhi`](@ref), [`TGeoShape!IsCrossingSemiplane`](@ref), [`TGeoShape!IsInPhiRange`](@ref), [`TGeoShape!IsSameWithinTolerance`](@ref), [`TGeoShape!IsSegCrossing`](@ref), [`TGeoShape!NormalPhi`](@ref), [`TGeoShape!SafetyPhi`](@ref), [`TGeoShape!SafetySeg`](@ref), [`TGeoShape!SetTransform`](@ref), [`TGeoShape!Tolerance`](@ref), [`TGeoShape`](@ref), [`TestShapeBit`](@ref), [`TestShapeBits`](@ref)
""" TGeoShape

# Wrapper of TGeoMatrix
@trydoc raw"""
    ROOT.TGeoMatrix

Geometrical transformation package.

All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local_ and local_-to-master computation. We need to have in mind that a transformation in TGeo has 2 major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local_'. If T is a transformation used for positioning volume daughters, then:

    MASTER = T * LOCAL

(C++ version of the code)

Therefore a local_-to-master conversion will be performed by using T, while a master-to-local_ by using its inverse. The second use case is the computation of the global_ transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', this global_ transformation represent the pile-up of all local_ transformations in the corresponding branch. The conversion from the global_ reference frame and the given object is also called master-to-local_, but it is handled by the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.

Rotation: Inverse rotation:

    r11  r12  r13   0              r11  r21  r31   0
    r21  r22  r23   0              r12  r22  r32   0
    r31  r32  r33   0              r13  r23  r33   0
     0    0    0    1               0    0    0    1

(C++ version of the code)

Translation: Inverse translation:

    1    0    0    tx               1    0    0   -tx
    0    1    0    ty               0    1    0   -ty
    0    0    1    tz               0    0    1   -tz
    0    0    0    1                0    0    0   1

(C++ version of the code)

Scale: Inverse scale:

    sx   0    0    0              1/sx  0    0    0
    0    sy   0    0               0   1/sy  0    0
    0    0    sz   0               0    0   1/sz  0
    0    0    0    1               0    0    0    1

(C++ version of the code)

where:

- `rij` are the 3x3 rotation matrix components,
- `tx`, `ty`, `tz` are the translation components
- `sx`, `sy`, `sz` are arbitrary scale constants on each axis,

The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translation would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the same basic abstract class and handling its specific data and point/vector transformation algorithms.

![https://root.cern/doc/v636/geom_transf.jpg](https://root.cern/doc/v636/geom_transf.jpg)

### The base class TGeoMatrix defines abstract metods for:

#### translation, rotation and scale getters. Every derived class stores only

its specific data, e.g. a translation stores an array of 3 doubles and a rotation an array of 9. However, asking which is the rotation array of a [TGeoTranslation](@ref) through the base [TGeoMatrix](@ref) interface is a legal operation. The answer in this case is a pointer to a global_ constant array representing an identity rotation.

    Double_t *TGeoMatrix!GetTranslation()
    Double_t *TGeoMatrix!GetRotation()
    Double_t *TGeoMatrix!GetScale()

(C++ version of the code)

#### MasterToLocal() and LocalToMaster() point and vector transformations :

    void      TGeoMatrix!MasterToLocal(const Double_t *master, Double_t *local_)
    void      TGeoMatrix!LocalToMaster(const Double_t *local_, Double_t *master)
    void      TGeoMatrix!MasterToLocalVect(const Double_t *master, Double_t *local_)
    void      TGeoMatrix!LocalToMasterVect(const Double_t *local_, Double_t *master)

(C++ version of the code)

These allow correct conversion also for reflections.

#### Transformation type getters :

    Bool_t    TGeoMatrix!IsIdentity()
    Bool_t    TGeoMatrix!IsTranslation()
    Bool_t    TGeoMatrix!IsRotation()
    Bool_t    TGeoMatrix!IsScale()
    Bool_t    TGeoMatrix!IsCombi() (translation + rotation)
    Bool_t    TGeoMatrix!IsGeneral() (translation + rotation + scale)

(C++ version of the code)

Combinations of basic transformations are represented by specific classes deriving from [TGeoMatrix](@ref). In order to define a matrix as a combination of several others, a special class [TGeoHMatrix](@ref) is provided. Here is an example of matrix creation :

### Matrix creation example:

    root[0] TGeoRotation r1,r2;
            r1.SetAngles(90,0,30);        // rotation defined by Euler angles
            r2.SetAngles(90,90,90,180,0,0); // rotation defined by GEANT3 angles
            TGeoTranslation t1(-10,10,0);
            TGeoTranslation t2(10,-10,5);
            TGeoCombiTrans c1(t1,r1);
            TGeoCombiTrans c2(t2,r2);
            TGeoHMatrix h = c1 * c2; // composition is done via TGeoHMatrix class
    root[7] TGeoHMatrix *ph = new TGeoHMatrix(hm); // this is the one we want to
                                                 // use for positioning a volume
    root[8] ph->Print();
            ...
            pVolume->AddNode(pVolDaughter,id,ph) // now ph is owned by the manager

(C++ version of the code)

### Rule for matrix creation:

Unless explicitly used for positioning nodes ([TGeoVolume!AddNode()](@ref)) all matrices deletion have to be managed by users. Matrices passed to geometry have to be created by using new() operator and their deletion is done by [TGeoManager](@ref) class.

### Available geometrical transformations

#### TGeoTranslation

Represent a (dx,dy,dz) translation. Data members: Double_t fTranslation[3]. Translations can be added/subtracted.

    TGeoTranslation t1;
    t1->SetTranslation(-5,10,4);
    TGeoTranslation *t2 = new TGeoTranslation(4,3,10);
    t2->Subtract(&t1);

(C++ version of the code)

#### Rotations

Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles :

    TGeoRotation *r1 = new TGeoRotation();
    r1->SetAngles(phi, theta, psi); // all angles in degrees

(C++ version of the code)

This represent the composition of : first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psi about the new Z axis.

    r1->SetAngles(th1,phi1, th2,phi2, th3,phi3)

(C++ version of the code)

This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.

Specific utilities : determinant, inverse.

#### Scale transformations

Represent a scale shrinking/enlargement. Data members :Double_t fScale[3]. Not fully implemented yet.

#### Combined transformations

Represent a rotation followed by a translation. Data members: Double_t fTranslation[3], [TGeoRotation](@ref) *fRotation.

    TGeoRotation *rot = new TGeoRotation("rot",10,20,30);
    TGeoTranslation trans;
    ...
    TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);
    TGeoCombiTrans *c2 = new TGeoCombiTrans("somename",10,20,30,rot)

(C++ version of the code)

#### TGeoGenTrans

Combined transformations including a scale. Not implemented.

#### TGeoIdentity

A generic singleton matrix representing a identity transformation NOTE: identified by the global_ variable gGeoIdentity.

Related functions: [`GetByteCount`](@ref), [`GetHomogenousMatrix`](@ref), [`GetPointerName`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`IsCombi`](@ref), [`IsGeneral`](@ref), [`IsIdentity`](@ref), [`IsOwned`](@ref), [`IsReflection`](@ref), [`IsRegistered`](@ref), [`IsRotAboutZ`](@ref), [`IsRotation`](@ref), [`IsScale`](@ref), [`IsShared`](@ref), [`IsTranslation`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`Print`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RegisterYourself`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SetDefaultName`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetShared`](@ref), [`TGeoMatrix!Normalize`](@ref), [`TGeoMatrix`](@ref)
""" TGeoMatrix

# Wrapper of TGeoVolume
@trydoc raw"""
    ROOT.TGeoVolume

[TGeoVolume](@ref), [TGeoVolumeMulti](@ref), [TGeoVolumeAssembly](@ref) are the volume classes.

Volumes are the basic objects used in building the geometrical hierarchy. They represent unpositioned objects but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. In order to create a volume, one has to put together a shape and a medium which are already defined. Volumes have to be named by users at creation time. Every different name may represent a an unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two cases : when a generic shape is provided to the volume constructor or when a division operation is applied. Each volume in the geometry stores an unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.

Volumes are objects that can be visualized, therefore having visibility, colour, line and fill attributes that can be defined or modified any time after the volume creation. It is advisable however to define these properties just after the first creation of a volume namespace, since in case of volume families any new member created by the modeler inherits these properties.

In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local_ reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local_ mother-daughters management is handled by volumes that builds additional optimisation structures upon geometry closure. In order to have navigation features properly working one has to follow the general rules for building a valid geometry (see [TGeoManager](@ref) class).

Now let's make a simple volume representing a copper wire. We suppose that a medium is already created (see [TGeoMedium](@ref) class on how to create media). We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm :

    TGeoTube *tube = new TGeoTube("wire_tube", 0, 0.01, 1);

(C++ version of the code)

One may omit the name for the shape if no retrieving by name is further needed during geometry building. The same shape can be shared by different volumes having different names and materials. Now let's make the volume for our wire. The prototype for volumes constructor looks like :

TGeoVolume!TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med)

Since [TGeoTube](@ref) derives from the base shape class, we can provide it to the volume constructor :

    TGeoVolume *wire_co = new TGeoVolume("WIRE_CO", tube, ptrCOPPER);

(C++ version of the code)

Do not bother to delete neither the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class. If we would have taken a look inside [TGeoManager!MakeTube()](@ref) method, we would have been able to create our wire with a single line :

    TGeoVolume *wire_co = gGeoManager->MakeTube("WIRE_CO", ptrCOPPER, 0, 0.01, 1);

(C++ version of the code)

The same applies for all primitive shapes, for which there can be found corresponding MakeSHAPE() methods. Their usage is much more convenient unless a shape has to be shared between more volumes. Let's make now an aluminium wire having the same shape, supposing that we have created the copper wire with the line above :

    TGeoVolume *wire_al = new TGeoVolume("WIRE_AL", wire_co->GetShape(), ptrAL);

(C++ version of the code)

Now that we have learned how to create elementary volumes, let's see how we can create a geometrical hierarchy.

### Positioning volumes

When creating a volume one does not specify if this will contain or not other volumes. Adding daughters to a volume implies creating those and adding them one by one to the list of daughters. Since the volume has to know the position of all its daughters, we will have to supply at the same time a geometrical transformation with respect to its local_ reference frame for each of them. The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeler. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches.

![https://root.cern/doc/v636/geom_t_example.png](https://root.cern/doc/v636/geom_t_example.png)

An important observation is that volume objects are owned by the [TGeoManager](@ref) class. This stores a list of all volumes in the geometry, that is cleaned upon destruction.

Let's consider positioning now our wire in the middle of a gas chamber. We need first to define the gas chamber :

    TGeoVolume *chamber = gGeoManager->MakeTube("CHAMBER", ptrGAS, 0, 1, 1);

(C++ version of the code)

Now we can put the wire inside :

    chamber->AddNode(wire_co, 1);

(C++ version of the code)

If we inspect now the chamber volume in a browser, we will notice that it has one daughter. Of course the gas has some container also, but let's keep it like that for the sake of simplicity. The full prototype of [AddNode()](@ref) is :

    TGeoVolume!AddNode(TGeoVolume *daughter, Int_t usernumber,
                        TGeoMatrix *matrix=gGeoIdentity)

(C++ version of the code)

Since we did not supplied the third argument, the wire will be positioned with an identity transformation inside the chamber. One will notice that the inner radii of the wire and chamber are both zero - therefore, aren't the two volumes overlapping ? The answer is no, the modeler is even relaying on the fact that any daughter is fully contained by its mother. On the other hand, neither of the nodes positioned inside a volume should overlap with each other. We will see that there are allowed some exceptions to those rules.

### Overlapping volumes

Positioning volumes that does not overlap their neighbours nor extrude their container is sometimes quite strong constraint. Some parts of the geometry might overlap naturally, e.g. two crossing tubes. The modeller supports such cases only if the overlapping nodes are declared by the user. In order to do that, one should use [TGeoVolume!AddNodeOverlap()](@ref) instead of [TGeoVolume!AddNode()](@ref). When 2 or more positioned volumes are overlapping, not all of them have to be declared so, but at least one. A point inside an overlapping region equally belongs to all overlapping nodes, but the way these are defined can enforce the modeler to give priorities. The general rule is that the deepest node in the hierarchy containing a point have the highest priority. For the same geometry level, non-overlapping is prioritised over overlapping. In order to illustrate this, we will consider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:

1. The part of a MANY node B extruding its container A will never be "seen" during navigation, as if B was in fact the result of the intersection of A and B.
2. If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.
3. If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.
4. The slices of a divided MANY will be as well MANY.

One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - this is always recommended.

### Replicating volumes

What can we do if our chamber contains two identical wires instead of one ? What if then we would need 1000 chambers in our detector ? Should we create 2000 wires and 1000 chamber volumes ? No, we will just need to replicate the ones that we have already created.

    chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));
    chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));

(C++ version of the code)

The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local_ reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeler is smarter than that and create for each volume some optimization structures called voxels (see Voxelization) to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway loose a lot in your tracking performance.

The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation : instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.

Related functions: [`AddNodeOffset`](@ref), [`AddNodeOverlap`](@ref), [`AddNode`](@ref), [`Browse`](@ref), [`Capacity`](@ref), [`CheckGeometry`](@ref), [`CheckOverlaps`](@ref), [`CheckShape`](@ref), [`CheckShapes`](@ref), [`CleanAll`](@ref), [`ClearNodes`](@ref), [`ClearShape`](@ref), [`ClearThreadData`](@ref), [`CloneNodesAndConnect`](@ref), [`CloneVolume`](@ref), [`Contains`](@ref), [`CountNodes`](@ref), [`CreateThreadData`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`DrawOnly`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`Export`](@ref), [`FindMatrixOfDaughterVolume`](@ref), [`FindNode`](@ref), [`FindOverlaps`](@ref), [`GetByteCount`](@ref), [`GetCurrentNodeIndex`](@ref), [`GetFWExtension`](@ref), [`GetField`](@ref), [`GetFinder`](@ref), [`GetGeoManager`](@ref), [`GetIconName`](@ref), [`GetIndex`](@ref), [`GetMaterial`](@ref), [`GetMedium`](@ref), [`GetNdaughters`](@ref), [`GetNextNodeIndex`](@ref), [`GetNodeIndex`](@ref), [`GetNode`](@ref), [`GetNodes`](@ref), [`GetNtotal`](@ref), [`GetNumber`](@ref), [`GetObjectInfo`](@ref), [`GetOptimalVoxels`](@ref), [`GetOption`](@ref), [`GetPointerName`](@ref), [`GetRefCount`](@ref), [`GetShape`](@ref), [`GetTransparency`](@ref), [`GetUserExtension`](@ref), [`GetVoxels`](@ref), [`GrabFWExtension`](@ref), [`GrabFocus`](@ref), [`GrabUserExtension`](@ref), [`Grab`](@ref), [`Gsord`](@ref), [`InspectMaterial`](@ref), [`InspectShape`](@ref), [`InvisibleAll`](@ref), [`IsActiveDaughters`](@ref), [`IsActive`](@ref), [`IsAdded`](@ref), [`IsAllInvisible`](@ref), [`IsAssembly`](@ref), [`IsCylVoxels`](@ref), [`IsFolder`](@ref), [`IsOverlappingCandidate`](@ref), [`IsRaytracing`](@ref), [`IsReplicated`](@ref), [`IsRunTime`](@ref), [`IsSelected`](@ref), [`IsStyleDefault`](@ref), [`IsTopVolume`](@ref), [`IsValid`](@ref), [`IsVisContainers`](@ref), [`IsVisLeaves`](@ref), [`IsVisOnly`](@ref), [`IsVisibleDaughters`](@ref), [`IsVisible`](@ref), [`IsVolumeMulti`](@ref), [`IsXYZVoxels`](@ref), [`LegoPlot`](@ref), [`MakeCopyNodes`](@ref), [`MakeCopyVolume`](@ref), [`MakeReflectedVolume`](@ref), [`OptimizeVoxels`](@ref), [`Paint`](@ref), [`PrintNodes`](@ref), [`PrintVoxels`](@ref), [`Print`](@ref), [`RandomPoints`](@ref), [`RandomRays`](@ref), [`Raytrace`](@ref), [`RegisterYourself`](@ref), [`Release`](@ref), [`RemoveNode`](@ref), [`ReplaceNode`](@ref), [`ReplayCreation`](@ref), [`ResetTransparency`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SelectVolume`](@ref), [`SetActiveDaughters`](@ref), [`SetActivity`](@ref), [`SetAdded`](@ref), [`SetAsTopVolume`](@ref), [`SetAttVisibility`](@ref), [`SetCurrentPoint`](@ref), [`SetCylVoxels`](@ref), [`SetFWExtension`](@ref), [`SetField`](@ref), [`SetFinder`](@ref), [`SetInvisible`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetMedium`](@ref), [`SetNodes`](@ref), [`SetNtotal`](@ref), [`SetNumber`](@ref), [`SetOption`](@ref), [`SetOverlappingCandidate`](@ref), [`SetReplicated`](@ref), [`SetShape`](@ref), [`SetTransparency`](@ref), [`SetUserExtension`](@ref), [`SetVisContainers`](@ref), [`SetVisLeaves`](@ref), [`SetVisOnly`](@ref), [`SetVisibility`](@ref), [`SetVoxelFinder`](@ref), [`SortNodes`](@ref), [`TGeoVolume!CreateDummyMedium`](@ref), [`TGeoVolume!DummyMedium`](@ref), [`TGeoVolume!Import`](@ref), [`TGeoVolume`](@ref), [`UnmarkSaved`](@ref), [`Valid`](@ref), [`VisibleDaughters`](@ref), [`Voxelize`](@ref), [`WeightA`](@ref), [`Weight`](@ref), [`cd`](@ref)
""" TGeoVolume

# Wrapper of TGeoBBox
@trydoc raw"""
    ROOT.TGeoBBox

Box class.

- [Building boxes](@ref)
- [Creation of boxes](@ref)
- [Divisions of boxes](@ref)

All shape primitives inherit from this, their constructor filling automatically the parameters of the box that bounds the given shape. Defined by 6 parameters :

    TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);

(C++ version of the code)

- `fDX`, `fDY`, `fDZ` : half lengths on X, Y and Z axis
- `fOrigin[3]` : position of box origin

### Building boxes

Normally a box has to be built only with 3 parameters: `DX,DY,DZ` representing the half-lengths on X, Y and Z-axes. In this case, the origin of the box will match the one of its reference frame and the box will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and from `-DZ` to `DZ` on Z. On the other hand, any other shape needs to compute and store the parameters of their minimal bounding box. The bounding boxes are essential to optimize navigation algorithms. Therefore all other primitives derive from **`TGeoBBox`**. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation `(Ox`,`Oy`,`Oz)`. All primitive constructors automatically compute the bounding box parameters. Users should be aware that building a translated box that will represent a primitive shape by itself would affect any further positioning of other shapes inside. Therefore it is highly recommendable to build non-translated boxes as primitives and translate/rotate their corresponding volumes only during positioning stage.

#### Creation of boxes

    TGeoBBox *box = new TGeoBBox("BOX", 20, 30, 40);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoBBox_001.png](https://root.cern/doc/v636/pict1_TGeoBBox_001.png)

A volume having a box shape can be built in one step:

    TGeoVolume *vbox = gGeoManager->MakeBox("vbox", ptrMed, 20,30,40);

(C++ version of the code)

#### Divisions of boxes

Volumes having box shape can be divided with equal-length slices on X, Y or Z axis. The following options are supported:

- Dividing the full range of one axis in N slices 

        TGeoVolume *divx = vbox->Divide("SLICEX", 1, N);

(C++ version of the code)

 here `1` stands for the division axis (1-X, 2-Y, 3-Z)

![https://root.cern/doc/v636/pict1_TGeoBBox_002.png](https://root.cern/doc/v636/pict1_TGeoBBox_002.png)

- Dividing in a limited range - general case. 

        TGeoVolume *divy = vbox->Divide("SLICEY",2,N,thestart,step);

(C++ version of the code)

    - thestart = starting offset within (-fDY, fDY)
    - step = slicing step

![https://root.cern/doc/v636/pict1_TGeoBBox_003.png](https://root.cern/doc/v636/pict1_TGeoBBox_003.png)

Both cases are supported by all shapes. See also class [TGeoShape](@ref) for utility methods provided by any particular shape.

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CouldBeCrossed`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDX`](@ref), [`GetDY`](@ref), [`GetDZ`](@ref), [`GetFacetArea`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetOrigin`](@ref), [`GetPointsOnFacet`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`IsNullBox`](@ref), [`IsValidBox`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetBoxDimensions`](@ref), [`SetBoxPoints`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoBBox!AreOverlapping`](@ref), [`TGeoBBox!Contains`](@ref), [`TGeoBBox!DistFromInside`](@ref), [`TGeoBBox!DistFromOutside`](@ref), [`TGeoBBox`](@ref)
""" TGeoBBox

# Wrapper of TGeoArb8
@trydoc raw"""
    ROOT.TGeoArb8

An arbitrary trapezoid with less than 8 vertices standing on two parallel planes perpendicular to Z axis.

An `Arb8` is defined by two quadrilaterals sitting on parallel planes, at `dZ`. These are defined each by 4 vertices having the coordinates `(Xi,Yi,+/-dZ)`,`i=0`,`3`. The lateral surface of the `Arb8` is defined by the 4 pairs of edges corresponding to vertices (`i,i+1`) on both `-dZ` and `+dZ`. If M and M' are the middles of the segments `(i,i+1)` at `-dZ` and `+dZ`, a lateral surface is obtained by sweeping the edge at `-dZ` along MM' so that it will match the corresponding one at `+dZ`. Since the points defining the edges are arbitrary, the lateral surfaces are not necessary planes - but twisted planes having a twist angle linear-dependent on Z.

    TGeoArb8!TGeoArb8(Double_t dz,Double_t ivert);

(C++ version of the code)

- `dz:` half-length in Z;
- `ivert = [0,7]`

Vertices have to be defined clockwise in the XY pane, both at `+dz` and `-dz`. The quadrilateral at `-dz` is defined by indices [0,3], whereas the one at `+dz` by vertices [4,7]. The vertex with `index=7` has to be defined last, since it triggers the computation of the bounding box of the shape. Any two or more vertices in each Z plane can have the same (X,Y) coordinates. It this case, the top and bottom quadrilaterals become triangles, segments or points. The lateral surfaces are not necessary defined by a pair of segments, but by pair segment-point (making a triangle) or point-point (making a line). Any choice is valid as long as at one of the theend-caps is at least a triangle.

![https://root.cern/doc/v636/pict1_TGeoArb8_001.png](https://root.cern/doc/v636/pict1_TGeoArb8_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`ComputeTwist`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToPlane`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetClosestEdge`](@ref), [`GetDz`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetPointsOnFacet`](@ref), [`GetTwist`](@ref), [`GetVertices`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`IsTwisted`](@ref), [`SafetyToFace`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetDz`](@ref), [`SetPlaneVertices`](@ref), [`SetPoints`](@ref), [`SetVertex`](@ref), [`Sizeof3D`](@ref), [`TGeoArb8!GetPlaneNormal`](@ref), [`TGeoArb8!InsidePolygon`](@ref), [`TGeoArb8!IsSamePoint`](@ref), [`TGeoArb8`](@ref)
""" TGeoArb8

# Wrapper of TGeoTrap
@trydoc raw"""
    ROOT.TGeoTrap

A general trapezoid.

A general trapezoid is one for which the faces perpendicular to z are trapezes but their centers are not necessary at the same x, y coordinates.

![https://root.cern/doc/v636/pict1_TGeoArb8_003.png](https://root.cern/doc/v636/pict1_TGeoArb8_003.png)

It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, `H1` the half length in y at low z, `LB1` the half length in x at low z and y low edge, `LB2` the half length in x at low z and y high edge, **`TH1`** the angle with respect to the y axis from the center of low y edge to the center of the high y edge, and `H2,LB2,LH2,TH2`, the corresponding quantities at high z.

    TGeoTrap(Double_t dz,Double_t theta,Double_t phi,
    Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,
    Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2);

(C++ version of the code)

Related functions: [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAlpha1`](@ref), [`GetAlpha2`](@ref), [`GetBl1`](@ref), [`GetBl2`](@ref), [`GetH1`](@ref), [`GetH2`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetPhi`](@ref), [`GetTheta`](@ref), [`GetTl1`](@ref), [`GetTl2`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`TGeoTrap`](@ref)
""" TGeoTrap

# Wrapper of TGeoGtra
@trydoc raw"""
    ROOT.TGeoGtra

A twisted trapezoid.

A twisted trapezoid is a general trapezoid defined in the same way but that is twisted along the Z-axis. The twist is defined as the rotation angle between the lower and the higher Z faces.

    TGeoGtra(Double_t dz,Double_t theta,Double_t phi,Double_t twist,
    Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,
    Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2 );

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoArb8_002.png](https://root.cern/doc/v636/pict1_TGeoArb8_002.png)

Related functions: [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetTwistAngle`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`TGeoGtra`](@ref)
""" TGeoGtra

# Wrapper of TGeoAtt
@trydoc raw"""
    ROOT.TGeoAtt

Visualization and tracking attributes for volumes and nodes.

The [TGeoAtt](@ref) class is an utility for volume/node visibility and tracking activity. By default the attributes are set to visible/active

Related functions: [`IsActiveDaughters`](@ref), [`IsActive`](@ref), [`IsVisBranch`](@ref), [`IsVisContainers`](@ref), [`IsVisDaughters`](@ref), [`IsVisLeaves`](@ref), [`IsVisOnly`](@ref), [`IsVisRaytrace`](@ref), [`IsVisStreamed`](@ref), [`IsVisTouched`](@ref), [`IsVisible`](@ref), [`ResetAttBit`](@ref), [`SetActiveDaughters`](@ref), [`SetActivity`](@ref), [`SetAttBit`](@ref), [`SetOptimization`](@ref), [`SetVisBranch`](@ref), [`SetVisContainers`](@ref), [`SetVisDaughters`](@ref), [`SetVisLeaves`](@ref), [`SetVisOnly`](@ref), [`SetVisRaytrace`](@ref), [`SetVisStreamed`](@ref), [`SetVisTouched`](@ref), [`SetVisibility`](@ref), [`TGeoAtt`](@ref), [`TestAttBit`](@ref)
""" TGeoAtt

# Wrapper of TGeoBoolNode
@trydoc raw"""
    ROOT.TGeoBoolNode

Base class for Boolean operations between two shapes.

A Boolean node describes a Boolean operation between 'left' and 'right' shapes positioned with respect to an ARBITRARY reference frame. The boolean node is referenced by a mother composite shape and its shape components may be primitive but also composite shapes. The later situation leads to a binary tree hierarchy. When the parent composite shape is used to create a volume, the reference frame of the volume is chosen to match the frame in which node shape components were defined.

The positioned shape components may or may not be disjoint. The specific implementations for Boolean nodes are:

- [TGeoUnion](@ref) - representing the Boolean union of two positioned shapes
- [TGeoSubtraction](@ref) - representing the Boolean subtraction of two positioned shapes
- [TGeoIntersection](@ref) - representing the Boolean intersection of two positioned shapes

Related functions: [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`GetLeftMatrix`](@ref), [`GetLeftShape`](@ref), [`GetNpoints`](@ref), [`GetRightMatrix`](@ref), [`GetRightShape`](@ref), [`GetThreadData`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`RegisterMatrices`](@ref), [`ReplaceMatrix`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetSelected`](@ref), [`Sizeof3D`](@ref), [`TGeoBoolNode`](@ref)
""" TGeoBoolNode

# Wrapper of TGeoUnion
@trydoc raw"""
    ROOT.TGeoUnion





Related functions: [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`GetNpoints`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoUnion`](@ref)
""" TGeoUnion

# Wrapper of TGeoIntersection
@trydoc raw"""
    ROOT.TGeoIntersection





Related functions: [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`GetNpoints`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoIntersection`](@ref)
""" TGeoIntersection

# Wrapper of TGeoSubtraction
@trydoc raw"""
    ROOT.TGeoSubtraction





Related functions: [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`GetNpoints`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoSubtraction`](@ref)
""" TGeoSubtraction

# Wrapper of TGeoHMatrix
@trydoc raw"""
    ROOT.TGeoHMatrix

Matrix class used for computing global_ transformations Should NOT be used for node definition.

An instance of this class is generally used to pile-up local_ transformations starting from the top level physical node, down to the current node.

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`Clear`](@ref), [`CopyFrom`](@ref), [`Determinant`](@ref), [`FastRotZ`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`MakeClone`](@ref), [`MultiplyLeft`](@ref), [`Multiply`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetRotation`](@ref), [`SetScale`](@ref), [`SetTranslation`](@ref), [`TGeoHMatrix`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoHMatrix

# Wrapper of TGeoTranslation
@trydoc raw"""
    ROOT.TGeoTranslation

Class describing translations.

A translation is basically an array of 3 doubles matching the positions 12, 13 and 14 in the homogenous matrix description.

Related functions: [`Add`](@ref), [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetTranslation`](@ref), [`Subtract`](@ref), [`TGeoTranslation`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoTranslation

# Wrapper of TGeoRotation
@trydoc raw"""
    ROOT.TGeoRotation

Class describing rotations.

A rotation is a 3*3 array Column vectors has to be orthogonal unit vectors.

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`Clear`](@ref), [`Determinant`](@ref), [`FastRotZ`](@ref), [`GetAngles`](@ref), [`GetInverse`](@ref), [`GetPhiRotation`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`IsValid`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MultiplyBy`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetAngles`](@ref), [`SetMatrix`](@ref), [`SetRotation`](@ref), [`TGeoRotation`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoRotation

# Wrapper of TGeoScale
@trydoc raw"""
    ROOT.TGeoScale

Class describing scale transformations.

A scale is an array of 3 doubles (sx, sy, sz) multiplying elements 0, 5 and 10 of the homogenous matrix. A scale is normalized : sx*sy*sz = 1

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`SetScale`](@ref), [`TGeoScale`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoScale

# Wrapper of TGeoCombiTrans
@trydoc raw"""
    ROOT.TGeoCombiTrans

Class describing rotation + translation.

Most frequently used in the description of [TGeoNode](@ref) 's

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`Clear`](@ref), [`GetRotationMatrix`](@ref), [`GetRotation`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`MakeClone`](@ref), [`Multiply`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RegisterYourself`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetRotation`](@ref), [`SetTranslation`](@ref), [`TGeoCombiTrans`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoCombiTrans

# Wrapper of TGeoGenTrans
@trydoc raw"""
    ROOT.TGeoGenTrans

Most general transformation, holding a translation, a rotation and a scale.



Related functions: [`Clear`](@ref), [`GetScale`](@ref), [`Inverse`](@ref), [`MakeClone`](@ref), [`Normalize`](@ref), [`SetScale`](@ref), [`TGeoGenTrans`](@ref)
""" TGeoGenTrans

# Wrapper of TGeoIdentity
@trydoc raw"""
    ROOT.TGeoIdentity

An identity transformation.

It holds no data member and returns pointers to static null translation and identity transformations for rotation and scale

Related functions: [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`SavePrimitive`](@ref), [`TGeoIdentity`](@ref)
""" TGeoIdentity

# Wrapper of TGeoBranchArray
@trydoc raw"""
    ROOT.TGeoBranchArray

An array of daughter indices making a geometry path.

Can be used to backup/restore a state. Allocated contiguously in memory.

To setup an object of this type, one should use:

    TGeoBranchArray *array = new TGeoBranchArray(level);
    array->InitFromNavigator(nav); // To initialize from current navigator state

(C++ version of the code)

The navigator can be updated to reflect this path array: `array->UpdateNavigator();`

Related functions: [`AddLevel`](@ref), [`Base.:(!=)`](@ref), [`Base.:(<)`](@ref), [`Base.:(<=)`](@ref), [`Base.:(==)`](@ref), [`Base.:(>)`](@ref), [`Base.:(>=)`](@ref), [`CleanMatrix`](@ref), [`Compare`](@ref), [`CopyTo`](@ref), [`DataSize`](@ref), [`DataStart`](@ref), [`GetArray`](@ref), [`GetCurrentNode`](@ref), [`GetLevel`](@ref), [`GetMatrix`](@ref), [`GetMaxLevel`](@ref), [`GetNode`](@ref), [`GetPath`](@ref), [`InitFromNavigator`](@ref), [`Init`](@ref), [`IsOutside`](@ref), [`IsSortable`](@ref), [`Print`](@ref), [`SizeOf`](@ref), [`TGeoBranchArray!BinarySearch`](@ref), [`TGeoBranchArray!MakeCopyAt`](@ref), [`TGeoBranchArray!MakeCopy`](@ref), [`TGeoBranchArray!MakeInstanceAt`](@ref), [`TGeoBranchArray!MakeInstance`](@ref), [`TGeoBranchArray!ReleaseInstance`](@ref), [`TGeoBranchArray!SizeOfInstance`](@ref), [`TGeoBranchArray!SizeOf`](@ref), [`TGeoBranchArray!Sort`](@ref), [`TGeoBranchArray`](@ref), [`UpdateArray`](@ref), [`UpdateNavigator`](@ref), [`assign`](@ref)
""" TGeoBranchArray

# Wrapper of TGeoNode
@trydoc raw"""
    ROOT.TGeoNode

A node represent a volume positioned inside another.They store links to both volumes and to the [TGeoMatrix](@ref) representing the relative positioning.

Node are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user ID inside a volume B will create a node node named A_ID. This will be added to the list of nodes stored by B. Also, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path like:

/TOP_1/.../A_3/B_7 will represent an unique object.

Its global_ transformation matrix can be computed as the pile-up of all local_ transformations in its branch. We will therefore call "logical graph" the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique "touchable" objects. We will call this the "physical tree". Unlike the logical graph, the physical tree can become a huge structure with several milions of nodes in case of complex geometries, therefore it is not always a good idea to keep it transient in memory. Since a the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global_ matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node + current global_ matrix. However, physical nodes have unique ID's that can be retrieved for a given modeler state. These can be fed back to the modeler in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node, therefore knowing the location of a point in the geometry can be saved as a starting state for later use.

Nodes can be declared as "overlapping" in case they do overlap with other nodes inside the same container or extrude this container. Non-overlapping nodes can be created with:

    TGeoVolume!AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);

(C++ version of the code)

The creation of overlapping nodes can be done with a similar prototype:

    TGeoVolume!AddNodeOverlap(same arguments);

(C++ version of the code)

When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbours. These are stored and checked all the time during navigation, therefore navigation is slower when embedding such nodes into geometry.

Node have visualization attributes as volume have. When undefined by users, painting a node on a pad will take the corresponding volume attributes.

![https://root.cern/doc/v636/geom_t_node.png](https://root.cern/doc/v636/geom_t_node.png)

Related functions: [`Browse`](@ref), [`CheckOverlaps`](@ref), [`CheckShapes`](@ref), [`CountDaughters`](@ref), [`DistancetoPrimitive`](@ref), [`DrawOnly`](@ref), [`DrawOverlaps`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`FillIdArray`](@ref), [`FindNode`](@ref), [`GetByteCount`](@ref), [`GetColour`](@ref), [`GetDaughter`](@ref), [`GetFWExtension`](@ref), [`GetFinder`](@ref), [`GetIndex`](@ref), [`GetMatrix`](@ref), [`GetMedium`](@ref), [`GetMotherVolume`](@ref), [`GetNdaughters`](@ref), [`GetNodes`](@ref), [`GetNumber`](@ref), [`GetObjectInfo`](@ref), [`GetOptimalVoxels`](@ref), [`GetOverlaps`](@ref), [`GetUserExtension`](@ref), [`GetVolume`](@ref), [`GrabFWExtension`](@ref), [`GrabUserExtension`](@ref), [`InspectNode`](@ref), [`IsCloned`](@ref), [`IsFolder`](@ref), [`IsOffset`](@ref), [`IsOnScreen`](@ref), [`IsOverlapping`](@ref), [`IsVirtual`](@ref), [`IsVisDaughters`](@ref), [`IsVisible`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeCopyNode`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MayOverlap`](@ref), [`Paint`](@ref), [`PrintCandidates`](@ref), [`PrintOverlaps`](@ref), [`Safety`](@ref), [`SaveAttributes`](@ref), [`SetAllInvisible`](@ref), [`SetCloned`](@ref), [`SetCurrentPoint`](@ref), [`SetFWExtension`](@ref), [`SetInvisible`](@ref), [`SetMotherVolume`](@ref), [`SetNumber`](@ref), [`SetOverlapping`](@ref), [`SetOverlaps`](@ref), [`SetUserExtension`](@ref), [`SetVirtual`](@ref), [`SetVisibility`](@ref), [`SetVolume`](@ref), [`TGeoNode`](@ref), [`VisibleDaughters`](@ref), [`cd`](@ref), [`ls`](@ref)
""" TGeoNode

# Wrapper of TGeoNavigator
@trydoc raw"""
    ROOT.TGeoNavigator

Class providing navigation API for TGeo geometries.

Several instances are allowed for a single geometry. A default navigator is provided for any geometry but one may add several others for parallel navigation:

    TGeoNavigator *navig = new TGeoNavigator(gGeoManager);
    Int_t inav = gGeoManager->AddNavigator(navig);
    gGeoManager->SetCurrentNavigator(inav);

(C++ version of the code)

.... and then switch back to the default navigator:

    gGeoManager->SetCurrentNavigator(0);

(C++ version of the code)

Related functions: [`BuildCache`](@ref), [`CdDown`](@ref), [`CdNext`](@ref), [`CdNode`](@ref), [`CdTop`](@ref), [`CdUp`](@ref), [`CheckPath`](@ref), [`CrossBoundaryAndLocate`](@ref), [`DoBackupState`](@ref), [`DoRestoreState`](@ref), [`FindNextBoundaryAndStep`](@ref), [`FindNextBoundary`](@ref), [`FindNextDaughterBoundary`](@ref), [`FindNode`](@ref), [`FindNormalFast`](@ref), [`FindNormal`](@ref), [`GetBranchNames`](@ref), [`GetBranchNumbers`](@ref), [`GetBranchOnlys`](@ref), [`GetCache`](@ref), [`GetCldirChecked`](@ref), [`GetCldir`](@ref), [`GetCurrentDirection`](@ref), [`GetCurrentMatrix`](@ref), [`GetCurrentNodeId`](@ref), [`GetCurrentNode`](@ref), [`GetCurrentPoint`](@ref), [`GetCurrentVolume`](@ref), [`GetDivMatrix`](@ref), [`GetHMatrix`](@ref), [`GetLastPoint`](@ref), [`GetLastSafety`](@ref), [`GetLevel`](@ref), [`GetMotherMatrix`](@ref), [`GetMother`](@ref), [`GetNextDaughterIndex`](@ref), [`GetNextNode`](@ref), [`GetNmany`](@ref), [`GetNodeId`](@ref), [`GetNormal`](@ref), [`GetPath`](@ref), [`GetSafeDistance`](@ref), [`GetSafeLevel`](@ref), [`GetStackLevel`](@ref), [`GetStep`](@ref), [`GetThreadId`](@ref), [`GetVirtualLevel`](@ref), [`GotoSafeLevel`](@ref), [`InitTrack`](@ref), [`InspectState`](@ref), [`IsCheckingOverlaps`](@ref), [`IsCurrentOverlapping`](@ref), [`IsEntering`](@ref), [`IsExiting`](@ref), [`IsNullStep`](@ref), [`IsOnBoundary`](@ref), [`IsOutside`](@ref), [`IsSafeStep`](@ref), [`IsSameLocation`](@ref), [`IsSamePoint`](@ref), [`IsStartSafe`](@ref), [`IsStepEntering`](@ref), [`IsStepExiting`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MasterToTop`](@ref), [`PopDummy`](@ref), [`PopPath`](@ref), [`PopPoint`](@ref), [`PushPath`](@ref), [`PushPoint`](@ref), [`ResetAll`](@ref), [`ResetState`](@ref), [`Safety`](@ref), [`SearchNode`](@ref), [`SetCheckingOverlaps`](@ref), [`SetCldirChecked`](@ref), [`SetCurrentDirection`](@ref), [`SetCurrentPoint`](@ref), [`SetLastPoint`](@ref), [`SetLastSafetyForPoint`](@ref), [`SetOutside`](@ref), [`SetStartSafe`](@ref), [`SetStep`](@ref), [`Step`](@ref), [`TGeoNavigator`](@ref), [`TopToMaster`](@ref), [`cd`](@ref)
""" TGeoNavigator

# Wrapper of TGeoBuilder
@trydoc raw"""
    ROOT.TGeoBuilder

Utility class for creating geometry objects.These will be associated with the current selected geometry manager object:

`TGeoBuilder!Instance()->SetGeometry(gGeoManager);`

The geometry builder is a singleton that may be used to build one or more geometries.

Related functions: [`AddMaterial`](@ref), [`AddShape`](@ref), [`AddTransformation`](@ref), [`Division`](@ref), [`GetMatrix`](@ref), [`MakeArb8`](@ref), [`MakeBox`](@ref), [`MakeCone`](@ref), [`MakeCons`](@ref), [`MakeCtub`](@ref), [`MakeEltu`](@ref), [`MakeGtra`](@ref), [`MakeHype`](@ref), [`MakePara`](@ref), [`MakeParaboloid`](@ref), [`MakePcon`](@ref), [`MakePgon`](@ref), [`MakeSphere`](@ref), [`MakeTorus`](@ref), [`MakeTrap`](@ref), [`MakeTrd1`](@ref), [`MakeTrd2`](@ref), [`MakeTube`](@ref), [`MakeTubs`](@ref), [`MakeVolumeAssembly`](@ref), [`MakeVolumeMulti`](@ref), [`MakeXtru`](@ref), [`Material`](@ref), [`Medium`](@ref), [`Mixture`](@ref), [`Node`](@ref), [`RegisterMatrix`](@ref), [`TGeoBuilder!Instance`](@ref), [`Volume`](@ref)
""" TGeoBuilder

# Wrapper of TGeoManager
@trydoc raw"""
    ROOT.TGeoManager

The manager class for any TGeo geometry.

Provides user interface for geometry creation, navigation, state querying, visualization, IO, geometry checking and other utilities.

## General architecture

The [ROOT](@ref) geometry package is a tool designed for building, browsing, tracking and visualizing a detector geometry. The code is independent from other external MC for simulation, therefore it does not contain any constraints related to physics. However, the package defines a number of hooks for tracking, such as media, materials, magnetic field or track state flags, in order to allow interfacing to tracking MC's. The final goal is to be able to use the same geometry for several purposes, such as tracking, reconstruction or visualization, taking advantage of the [ROOT](@ref) features related to bookkeeping, I/O, histogramming, browsing and GUI's.

The geometrical modeler is the most important component of the package and it provides answers to the basic questions like "Where am I ?" or "How far
from the next boundary ?", but also to more complex ones like "How far from
the closest surface ?" or "Which is the next crossing along a helix ?".

The architecture of the modeler is a combination between a GEANT-like containment scheme and a normal CSG binary tree at the level of shapes. An important common feature of all detector geometry descriptions is the mother-daughter concept. This is the most natural approach when tracking is concerned and imposes a set of constraints to the way geometry is defined. Constructive solid geometry composition is used only in order to create more complex shapes from an existing set of primitives through boolean operations. This feature is not implemented yet but in future full definition of boolean expressions will be supported.

Practically every geometry defined in GEANT style can be mapped by the modeler. The basic components used for building the logical hierarchy of the geometry are called "volumes" and "nodes". Volumes (sometimes called "solids") are fully defined geometrical objects having a given shape and medium and possibly containing a list of nodes. Nodes represent just positioned instances of volumes inside a container volume and they are not directly defined by user. They are automatically created as a result of adding one volume inside other or dividing a volume. The geometrical transformation hold by nodes is always defined with respect to their mother (relative positioning). Reflection matrices are allowed. All volumes have to be fully aware of their containees when the geometry is closed. They will build additional structures (voxels) in order to fasten-up the search algorithms. Finally, nodes can be regarded as bidirectional links between containers and containees objects.

The structure defined in this way is a graph structure since volumes are replicable (same volume can become daughter node of several other volumes), every volume becoming a branch in this graph. Any volume in the logical graph can become the actual top volume at run time (see [TGeoManager!SetTopVolume()](@ref)). All functionalities of the modeler will behave in this case as if only the corresponding branch starting from this volume is the registered geometry.

![https://root.cern/doc/v636/geom_graf.jpg](https://root.cern/doc/v636/geom_graf.jpg)

A given volume can be positioned several times in the geometry. A volume can be divided according default or user-defined patterns, creating automatically the list of division nodes inside. The elementary volumes created during the dividing process follow the same scheme as usual volumes, therefore it is possible to position further geometrical structures inside or to divide them further more (see [TGeoVolume!Divide()](@ref)).

The primitive shapes supported by the package are basically the GEANT3 shapes (see class [TGeoShape](@ref)), arbitrary wedges with eight vertices on two parallel planes. All basic primitives inherits from class [TGeoBBox](@ref) since the bounding box of a solid is essential for the tracking algorithms. They also implement the virtual methods defined in the virtual class [TGeoShape](@ref) (point and segment classification). User-defined primitives can be directly plugged into the modeler provided that they override these methods. Composite shapes will be soon supported by the modeler. In order to build a [TGeoCompositeShape](@ref), one will have to define first the primitive components. The object that handle boolean operations among components is called TGeoBoolCombinator and it has to be constructed providing a string boolean expression between the components names.

## Example for building a simple geometry

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TGeoManager_001.png](https://root.cern/doc/v636/pict1_TGeoManager_001.png)

## TGeoManager - the manager class for the geometry package.

[TGeoManager](@ref) class is embedding all the API needed for building and tracking a geometry. It defines a global_ pointer (gGeoManager) in order to be fully accessible from external code. The mechanism of handling multiple geometries at the same time will be soon implemented.

[TGeoManager](@ref) is the owner of all geometry objects defined in a session, therefore users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. Logical nodes (positioned volumes) are created and destroyed by the [TGeoVolume](@ref) class. Physical nodes and their global_ transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The caching mechanism is triggered by the total number of physical instances of volumes and the cache manager is a client of [TGeoManager](@ref). The manager class also controls the painter client. This is linked with [ROOT](@ref) graphical libraries loaded on demand in order to control visualization actions.

## Rules for building a valid geometry

A given geometry can be built in various ways, but there are mandatory steps that have to be followed in order to be validated by the modeler. There are general rules : volumes needs media and shapes in order to be created, both container and containee volumes must be created before linking them together, and the relative transformation matrix must be provided. All branches must have an upper link point otherwise they will not be considered as part of the geometry. Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global_ visualization settings (see [TGeoPainter](@ref) class) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules : positioned daughters should not extrude their mother or intersect with sisters unless this is specified (see [TGeoVolume!AddNodeOverlap()](@ref)), the top volume (containing all geometry tree) must be specified before closing the geometry and must not be positioned - it represents the global_ reference frame. After building the full geometry tree, the geometry must be closed (see [TGeoManager!CloseGeometry()](@ref)). Voxelization can be redone per volume after this process.

Below is the general scheme of the manager class.

![https://root.cern/doc/v636/geom_mgr.jpg](https://root.cern/doc/v636/geom_mgr.jpg)

## An interactive session

Provided that a geometry was successfully built and closed (for instance the previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register itself to [ROOT](@ref) and the logical/physical structures will become immediately browsable. The [ROOT](@ref) browser will display starting from the geometry folder : the list of transformations and media, the top volume and the top logical node. These last two can be fully expanded, any intermediate volume/node in the browser being subject of direct access context menu operations (right mouse button click). All user utilities of classes [TGeoManager](@ref), [TGeoVolume](@ref) and [TGeoNode](@ref) can be called via the context menu.

![https://root.cern/doc/v636/geom_browser.jpg](https://root.cern/doc/v636/geom_browser.jpg)

### Drawing the geometry

Any logical volume can be drawn via [TGeoVolume!Draw()](@ref) member function. This can be directly accessed from the context menu of the volume object directly from the browser. There are several drawing options that can be set with [TGeoManager!SetVisOption(Int_t opt)](@ref) method :

#### opt=0

only the content of the volume is drawn, N levels down (default N=3). This is the default behavior. The number of levels to be drawn can be changed via [TGeoManager!SetVisLevel(Int_t level)](@ref) method.

![https://root.cern/doc/v636/geom_frame0.jpg](https://root.cern/doc/v636/geom_frame0.jpg)

#### opt=1

the final leaves (e.g. daughters with no containment) of the branch starting from volume are drawn down to the current number of levels. WARNING : This mode is memory consuming depending of the size of geometry, so drawing from top level within this mode should be handled with care for expensive geometries. In future there will be a limitation on the maximum number of nodes to be visualized.

![https://root.cern/doc/v636/geom_frame1.jpg](https://root.cern/doc/v636/geom_frame1.jpg)

#### opt=2

only the clicked volume is visualized. This is automatically set by [TGeoVolume!DrawOnly()](@ref) method

#### opt=3 - only a given path is visualized. This is automatically set by

TGeoVolume!DrawPath(const char *path) method

The current view can be exploded in cartesian, cylindrical or spherical coordinates : [TGeoManager!SetExplodedView(Int_t opt)](@ref). Options may be :

- 0 - default (no bombing)
- 1 - cartesian coordinates. The bomb factor on each axis can be set with TGeoManager!SetBombX(Double_t bomb) and corresponding Y and Z.
- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R are considered ![https://root.cern/doc/v636/geom_frameexp.jpg](https://root.cern/doc/v636/geom_frameexp.jpg)
- 3 - bomb in radial spherical coordinate : TGeoManager!SetBombR()

Volumes themselves support different visualization settings :

- [TGeoVolume!SetVisibility()](@ref) : set volume visibility.
- [TGeoVolume!VisibleDaughters()](@ref) : set daughters visibility. All these actions automatically updates the current view if any.

### Checking the geometry

Several checking methods are accessible from the volume context menu. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the [TGeoChecker](@ref) class from the painting package.

#### Checking a given point.

Can be called from TGeoManager!CheckPoint(Double_t x, Double_t y, Double_t z). This method is drawing the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. The point will be drawn in red, as well as a sphere having this closest distance as radius. In case a non-zero distance is given by the user as fifth argument of CheckPoint, this distance will be used as radius of the safety sphere.

![https://root.cern/doc/v636/geom_checkpoint.jpg](https://root.cern/doc/v636/geom_checkpoint.jpg)

#### Shooting random points.

Can be called from [TGeoVolume!RandomPoints()](@ref) (context menu function) and it will draw this volume with current visualization settings. Random points are generated in the bounding box of the top drawn volume. The points are classified and drawn with the color of their deepest container. Only points in visible nodes will be drawn.

![https://root.cern/doc/v636/geom_random1.jpg](https://root.cern/doc/v636/geom_random1.jpg)

#### Raytracing.

Can be called from [TGeoVolume!RandomRays()](@ref) (context menu of volumes) and will shoot rays from a given point in the local_ reference frame with random directions. The intersections with displayed nodes will appear as segments having the color of the touched node. Drawn geometry will be then made invisible in order to enhance rays.

![https://root.cern/doc/v636/geom_random2.jpg](https://root.cern/doc/v636/geom_random2.jpg)

Related functions: [`AddBorderSurface`](@ref), [`AddGDMLMatrix`](@ref), [`AddMaterial`](@ref), [`AddNavigator`](@ref), [`AddOpticalSurface`](@ref), [`AddOverlap`](@ref), [`AddProperty`](@ref), [`AddRegion`](@ref), [`AddShape`](@ref), [`AddSkinSurface`](@ref), [`AddTrack`](@ref), [`AddTransformation`](@ref), [`AddVolume`](@ref), [`AnimateTracks`](@ref), [`BombTranslation`](@ref), [`Browse`](@ref), [`BuildDefaultMaterials`](@ref), [`CdDown`](@ref), [`CdNext`](@ref), [`CdNode`](@ref), [`CdTop`](@ref), [`CdUp`](@ref), [`CheckBoundaryErrors`](@ref), [`CheckBoundaryReference`](@ref), [`CheckGeometryFull`](@ref), [`CheckGeometry`](@ref), [`CheckOverlaps`](@ref), [`CheckPath`](@ref), [`CheckPoint`](@ref), [`CheckShape`](@ref), [`CleanGarbage`](@ref), [`ClearAttributes`](@ref), [`ClearNavigators`](@ref), [`ClearOverlaps`](@ref), [`ClearPhysicalNodes`](@ref), [`ClearShape`](@ref), [`ClearThreadData`](@ref), [`ClearTracks`](@ref), [`CloseGeometry`](@ref), [`ConvertReflections`](@ref), [`CountLevels`](@ref), [`CountNodes`](@ref), [`CreateParallelWorld`](@ref), [`CreateThreadData`](@ref), [`CrossBoundaryAndLocate`](@ref), [`DefaultAngles`](@ref), [`DefaultColors`](@ref), [`DisableInactiveVolumes`](@ref), [`Division`](@ref), [`DoBackupState`](@ref), [`DoRestoreState`](@ref), [`DrawCurrentPoint`](@ref), [`DrawPath`](@ref), [`DrawTracks`](@ref), [`Edit`](@ref), [`EnableInactiveVolumes`](@ref), [`ExecuteEvent`](@ref), [`Export`](@ref), [`FindDuplicateMaterial`](@ref), [`FindNextBoundaryAndStep`](@ref), [`FindNextBoundary`](@ref), [`FindNextDaughterBoundary`](@ref), [`FindNode`](@ref), [`FindNormalFast`](@ref), [`FindNormal`](@ref), [`FindTrackWithId`](@ref), [`FindVolumeFast`](@ref), [`GetAlignableEntryByUID`](@ref), [`GetAlignableEntry`](@ref), [`GetBits`](@ref), [`GetBombFactors`](@ref), [`GetBombMode`](@ref), [`GetBorderSurface`](@ref), [`GetBranchNames`](@ref), [`GetBranchNumbers`](@ref), [`GetBranchOnlys`](@ref), [`GetByteCount`](@ref), [`GetCache`](@ref), [`GetCldirChecked`](@ref), [`GetCldir`](@ref), [`GetClippingShape`](@ref), [`GetCurrentDirection`](@ref), [`GetCurrentMatrix`](@ref), [`GetCurrentNavigator`](@ref), [`GetCurrentNodeId`](@ref), [`GetCurrentNode`](@ref), [`GetCurrentPoint`](@ref), [`GetCurrentTrack`](@ref), [`GetCurrentVolume`](@ref), [`GetElementTable`](@ref), [`GetGDMLMatrix`](@ref), [`GetGLMatrix`](@ref), [`GetGeomPainter`](@ref), [`GetHMatrix`](@ref), [`GetLastPoint`](@ref), [`GetLastSafety`](@ref), [`GetLastTrack`](@ref), [`GetLevel`](@ref), [`GetListOfBorderSurfaces`](@ref), [`GetListOfGDMLMatrices`](@ref), [`GetListOfGShapes`](@ref), [`GetListOfGVolumes`](@ref), [`GetListOfMaterials`](@ref), [`GetListOfMatrices`](@ref), [`GetListOfMedia`](@ref), [`GetListOfNavigators`](@ref), [`GetListOfNodes`](@ref), [`GetListOfOpticalSurfaces`](@ref), [`GetListOfOverlaps`](@ref), [`GetListOfPhysicalNodes`](@ref), [`GetListOfRegions`](@ref), [`GetListOfShapes`](@ref), [`GetListOfSkinSurfaces`](@ref), [`GetListOfTracks`](@ref), [`GetListOfUVolumes`](@ref), [`GetListOfVolumes`](@ref), [`GetMasterVolume`](@ref), [`GetMaterialIndex`](@ref), [`GetMaterial`](@ref), [`GetMatrix`](@ref), [`GetMaxLevel`](@ref), [`GetMaxThreads`](@ref), [`GetMaxVisNodes`](@ref), [`GetMedium`](@ref), [`GetMotherMatrix`](@ref), [`GetMother`](@ref), [`GetNAlignable`](@ref), [`GetNNodes`](@ref), [`GetNextNode`](@ref), [`GetNmany`](@ref), [`GetNodeId`](@ref), [`GetNode`](@ref), [`GetNormal`](@ref), [`GetNproperties`](@ref), [`GetNregions`](@ref), [`GetNsegments`](@ref), [`GetNtracks`](@ref), [`GetOpticalSurface`](@ref), [`GetPaintVolume`](@ref), [`GetPainter`](@ref), [`GetParallelWorld`](@ref), [`GetParentTrackOfId`](@ref), [`GetParticleName`](@ref), [`GetPath`](@ref), [`GetPdgName`](@ref), [`GetPhysicalNode`](@ref), [`GetProperty`](@ref), [`GetRTmode`](@ref), [`GetRegion`](@ref), [`GetSafeDistance`](@ref), [`GetSafeLevel`](@ref), [`GetSkinSurface`](@ref), [`GetStackLevel`](@ref), [`GetStep`](@ref), [`GetTmax`](@ref), [`GetTminTmax`](@ref), [`GetTopNode`](@ref), [`GetTopVolume`](@ref), [`GetTrackIndex`](@ref), [`GetTrackOfId`](@ref), [`GetTrack`](@ref), [`GetUID`](@ref), [`GetUserPaintVolume`](@ref), [`GetVirtualLevel`](@ref), [`GetVisDensity`](@ref), [`GetVisLevel`](@ref), [`GetVisOption`](@ref), [`GetVolume`](@ref), [`GotoSafeLevel`](@ref), [`InitTrack`](@ref), [`InspectState`](@ref), [`IsActivityEnabled`](@ref), [`IsAnimatingTracks`](@ref), [`IsCheckingOverlaps`](@ref), [`IsCleaning`](@ref), [`IsClosed`](@ref), [`IsCurrentOverlapping`](@ref), [`IsDrawingExtra`](@ref), [`IsEntering`](@ref), [`IsExiting`](@ref), [`IsFolder`](@ref), [`IsInPhiRange`](@ref), [`IsMatrixReflection`](@ref), [`IsMatrixTransform`](@ref), [`IsMultiThread`](@ref), [`IsNodeSelectable`](@ref), [`IsNullStep`](@ref), [`IsOnBoundary`](@ref), [`IsOutside`](@ref), [`IsParallelWorldNav`](@ref), [`IsSameLocation`](@ref), [`IsSamePoint`](@ref), [`IsStartSafe`](@ref), [`IsStepEntering`](@ref), [`IsStepExiting`](@ref), [`IsStreamingVoxels`](@ref), [`IsVisLeaves`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeAlignablePN`](@ref), [`MakeArb8`](@ref), [`MakeBox`](@ref), [`MakeCone`](@ref), [`MakeCons`](@ref), [`MakeCtub`](@ref), [`MakeEltu`](@ref), [`MakeGtra`](@ref), [`MakeHype`](@ref), [`MakePara`](@ref), [`MakeParaboloid`](@ref), [`MakePcon`](@ref), [`MakePgon`](@ref), [`MakePhysicalNode`](@ref), [`MakeSphere`](@ref), [`MakeTorus`](@ref), [`MakeTrack`](@ref), [`MakeTrap`](@ref), [`MakeTrd1`](@ref), [`MakeTrd2`](@ref), [`MakeTube`](@ref), [`MakeTubs`](@ref), [`MakeVolumeAssembly`](@ref), [`MakeVolumeMulti`](@ref), [`MakeXtru`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MasterToTop`](@ref), [`Material`](@ref), [`Medium`](@ref), [`Mixture`](@ref), [`ModifiedPad`](@ref), [`Node`](@ref), [`OptimizeVoxels`](@ref), [`PopDummy`](@ref), [`PopPath`](@ref), [`PopPoint`](@ref), [`PrintOverlaps`](@ref), [`PushPath`](@ref), [`PushPoint`](@ref), [`RandomPoints`](@ref), [`RandomRays`](@ref), [`RefreshPhysicalNodes`](@ref), [`RegisterMatrix`](@ref), [`RemoveMaterial`](@ref), [`RemoveNavigator`](@ref), [`ReplaceVolume`](@ref), [`ResetState`](@ref), [`ResetUserData`](@ref), [`RestoreMasterVolume`](@ref), [`Safety`](@ref), [`SamplePoints`](@ref), [`SaveAttributes`](@ref), [`SearchNode`](@ref), [`SelectTrackingMedia`](@ref), [`SetAlignableEntry`](@ref), [`SetAllIndex`](@ref), [`SetAnimateTracks`](@ref), [`SetBombFactors`](@ref), [`SetCheckedNode`](@ref), [`SetCheckingOverlaps`](@ref), [`SetCldirChecked`](@ref), [`SetClippingShape`](@ref), [`SetClipping`](@ref), [`SetCurrentDirection`](@ref), [`SetCurrentNavigator`](@ref), [`SetCurrentPoint`](@ref), [`SetCurrentTrack`](@ref), [`SetDrawExtraPaths`](@ref), [`SetExplodedView`](@ref), [`SetLastPoint`](@ref), [`SetMatrixReflection`](@ref), [`SetMatrixTransform`](@ref), [`SetMaxThreads`](@ref), [`SetMaxVisNodes`](@ref), [`SetNmeshPoints`](@ref), [`SetNodeSelectable`](@ref), [`SetNsegments`](@ref), [`SetOutside`](@ref), [`SetPaintVolume`](@ref), [`SetParticleName`](@ref), [`SetPdgName`](@ref), [`SetPhiRange`](@ref), [`SetRTmode`](@ref), [`SetStartSafe`](@ref), [`SetStep`](@ref), [`SetTminTmax`](@ref), [`SetTopVisible`](@ref), [`SetTopVolume`](@ref), [`SetUseParallelWorldNav`](@ref), [`SetUserPaintVolume`](@ref), [`SetVisDensity`](@ref), [`SetVisLevel`](@ref), [`SetVisOption`](@ref), [`SetVisibility`](@ref), [`SetVolumeAttribute`](@ref), [`SizeOf`](@ref), [`SortOverlaps`](@ref), [`Step`](@ref), [`TGeoManager!ClearThreadsMap`](@ref), [`TGeoManager!GetDefaultUnits`](@ref), [`TGeoManager!GetExportPrecision`](@ref), [`TGeoManager!GetMaxDaughters`](@ref), [`TGeoManager!GetMaxLevels`](@ref), [`TGeoManager!GetMaxXtruVert`](@ref), [`TGeoManager!GetNumThreads`](@ref), [`TGeoManager!GetVerboseLevel`](@ref), [`TGeoManager!Import`](@ref), [`TGeoManager!IsLocked`](@ref), [`TGeoManager!LockDefaultUnits`](@ref), [`TGeoManager!LockGeometry`](@ref), [`TGeoManager!Parse`](@ref), [`TGeoManager!SetDefaultUnits`](@ref), [`TGeoManager!SetExportPrecision`](@ref), [`TGeoManager!SetNavigatorsLock`](@ref), [`TGeoManager!SetVerboseLevel`](@ref), [`TGeoManager!ThreadId`](@ref), [`TGeoManager!UnlockGeometry`](@ref), [`TGeoManager`](@ref), [`TestOverlaps`](@ref), [`Test`](@ref), [`TopToMaster`](@ref), [`TransformVolumeToAssembly`](@ref), [`UnbombTranslation`](@ref), [`ViewLeaves`](@ref), [`Volume`](@ref), [`Weight`](@ref), [`cd`](@ref)
""" TGeoManager

# Wrapper of TGeoMaterial
@trydoc raw"""
    ROOT.TGeoMaterial

Base class describing materials.

## Important note about units

Since **v6-17-02** the geometry package adopted a system of units, upon the request to support an in-memory material representation consistent with the one in Geant4. The adoption was done gradually and starting with **v6-19-02** (back-ported to **v6-18-02**) the package supports changing the default units to either [ROOT](@ref) (CGS) or Geant4 ones. In the same version the Geant4 units were set to be the default ones, changing the previous behavior and making material properties such as radiation and interaction lengths having in memory values an order of magnitude lower. This behavior affected versions up to **v6-25-01**, after which the default units were restored to be the [ROOT](@ref) ones.

For users needing to restore the CGS behavior for material properties, the following sequence needs to be called before creating the [TGeoManager](@ref) instance: From **v6-18-02** to **v6-22-06**: 

    TGeoUnit!setUnitType(TGeoUnit!kTGeoUnits);

(C++ version of the code)

From **v6-22-08** to **v6-25-01**: 

    TGeoManager!LockDefaultUnits(false);
    TGeoManager!SetDefaultUnits(kRootUnits);
    TGeoManager!LockDefaultUnits(true);

(C++ version of the code)

Related functions: [`AddConstProperty`](@ref), [`AddProperty`](@ref), [`DecayMaterial`](@ref), [`FillMaterialEvolution`](@ref), [`GetA`](@ref), [`GetBaseElement`](@ref), [`GetByteCount`](@ref), [`GetCerenkovProperties`](@ref), [`GetConstProperties`](@ref), [`GetConstPropertyRef`](@ref), [`GetConstProperty`](@ref), [`GetDefaultColor`](@ref), [`GetDensity`](@ref), [`GetElementProp`](@ref), [`GetElement`](@ref), [`GetFWExtension`](@ref), [`GetIndex`](@ref), [`GetIntLen`](@ref), [`GetNconstProperties`](@ref), [`GetNelements`](@ref), [`GetNproperties`](@ref), [`GetPointerName`](@ref), [`GetPressure`](@ref), [`GetProperties`](@ref), [`GetPropertyRef`](@ref), [`GetProperty`](@ref), [`GetRadLen`](@ref), [`GetSpecificActivity`](@ref), [`GetState`](@ref), [`GetTemperature`](@ref), [`GetTransparency`](@ref), [`GetUserExtension`](@ref), [`GetZ`](@ref), [`GrabFWExtension`](@ref), [`GrabUserExtension`](@ref), [`IsEq`](@ref), [`IsMixture`](@ref), [`IsUsed`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetA`](@ref), [`SetCerenkovProperties`](@ref), [`SetDensity`](@ref), [`SetFWExtension`](@ref), [`SetIndex`](@ref), [`SetPressure`](@ref), [`SetRadLen`](@ref), [`SetState`](@ref), [`SetTemperature`](@ref), [`SetTransparency`](@ref), [`SetUsed`](@ref), [`SetUserExtension`](@ref), [`SetZ`](@ref), [`TGeoMaterial!Coulomb`](@ref), [`TGeoMaterial!ScreenFactor`](@ref), [`TGeoMaterial`](@ref)
""" TGeoMaterial

# Wrapper of TGeoMedium
@trydoc raw"""
    ROOT.TGeoMedium

Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC).

One may define several tracking media for a given material. The media ID are user defined values that are not used by the geometry package. In case geometry is used via VMC (in GEANT) these numbers are overwritten, so one can only rely on these values after gMC->FinishGeometry() is called. The media parameters are inspired from GEANT3 and the values defined make sense in context of GEANT (3 but also 4) or FLUKA interfaces.

Related functions: [`GetByteCount`](@ref), [`GetId`](@ref), [`GetMaterial`](@ref), [`GetParam`](@ref), [`GetPointerName`](@ref), [`SavePrimitive`](@ref), [`SetCerenkovProperties`](@ref), [`SetId`](@ref), [`SetMaterial`](@ref), [`SetParam`](@ref), [`TGeoMedium`](@ref)
""" TGeoMedium

# Wrapper of TGeoVolumeAssembly
@trydoc raw"""
    ROOT.TGeoVolumeAssembly

Volume assemblies.

Assemblies a volumes that have neither a shape or a material/medium. Assemblies behave exactly like normal volumes grouping several daughters together, but the daughters can never extrude the assembly since this has no shape. However, a bounding box and a voxelization structure are built for assemblies as for normal volumes, so that navigation is still optimized. Assemblies are useful for grouping hierarchically volumes which are otherwise defined in a flat manner, but also to avoid clashes between container shapes. To define an assembly one should just input a name, then thestart adding other volumes (or volume assemblies) as content.

Related functions: [`AddNodeOverlap`](@ref), [`AddNode`](@ref), [`ClearThreadData`](@ref), [`CloneVolume`](@ref), [`CreateThreadData`](@ref), [`Divide`](@ref), [`DrawOnly`](@ref), [`GetCurrentNodeIndex`](@ref), [`GetNextNodeIndex`](@ref), [`GetThreadData`](@ref), [`IsAssembly`](@ref), [`IsVisible`](@ref), [`SetCurrentNodeIndex`](@ref), [`SetNextNodeIndex`](@ref), [`TGeoVolumeAssembly!MakeAssemblyFromVolume`](@ref), [`TGeoVolumeAssembly`](@ref)
""" TGeoVolumeAssembly

# Wrapper of TGeoVolumeMulti
@trydoc raw"""
    ROOT.TGeoVolumeMulti

Volume families.

A volume family is represented by the class [TGeoVolumeMulti](@ref). It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a [TGeoVolume](@ref) equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:

    TGeoManager!Volume(const char *vname, const char *shape, Int_t nmed);

(C++ version of the code)

where VNAME is the family name, NMED is the medium number and SHAPE is the shape type that can be:

    box    - for TGeoBBox
    trd1   - for TGeoTrd1
    trd2   - for TGeoTrd2
    trap   - for TGeoTrap
    gtra   - for TGeoGtra
    para   - for TGeoPara
    tube, tubs - for TGeoTube, TGeoTubeSeg
    cone, cons - for TGeoCone, TgeoCons
    eltu   - for TGeoEltu
    ctub   - for TGeoCtub
    pcon   - for TGeoPcon
    pgon   - for TGeoPgon

(C++ version of the code)

Volumes are then added to a given family upon adding the generic name as node inside other volume:

    TGeoVolume *box_family = gGeoManager->Volume("BOXES", "box", nmed);
    ...
    gGeoManager->Node("BOXES", Int_t copy_no, "mother_name",
                      Double_t x, Double_t y, Double_t z, Int_t rot_index,
                      Bool_t is_only, Double_t *upar, Int_t npar);

(C++ version of the code)

here:

    BOXES   - name of the family of boxes
    copy_no - user node number for the created node
    mother_name - name of the volume to which we want to add the node
    x,y,z   - translation components
    rot_index   - indx of a rotation matrix in the list of matrices
    upar    - array of actual shape parameters
    npar    - number of parameters

(C++ version of the code)

The parameters order and number are the same as in the corresponding shape constructors.

Another particular case where volume families are used is when we want that a volume positioned inside a container to match one ore more container limits. Suppose we want to position the same box inside 2 different volumes and we want the Z size to match the one of each container:

    TGeoVolume *container1 = gGeoManager->MakeBox("C1", imed, 10,10,30);
    TGeoVolume *container2 = gGeoManager->MakeBox("C2", imed, 10,10,20);
    TGeoVolume *pvol       = gGeoManager->MakeBox("PVOL", jmed, 3,3,-1);
    container1->AddNode(pvol, 1);
    container2->AddNode(pvol, 1);

(C++ version of the code)

Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the [TGeoVolumeMulti](@ref) class, which does not need to be instantiated by users.

### Dividing volumes

Volumes can be divided according a pattern. The most simple division can be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take the most simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:

    TGeoVolume *slicex = box->Divide("SLICEX", 1, N);

(C++ version of the code)

where SLICE is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi. In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family. Divisions can be also performed in a given range of one axis. For that, one have to specify also the starting coordinate value and the step:

    TGeoVolume *slicex = box->Divide("SLICEX", 1, N, thestart, step);

(C++ version of the code)

A check is always done on the resulting division range : if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 upto N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside an other volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:

    TGeoVolume *slicey = slicex->Divide("SLICEY", 2, N1);
    slicey->AddNode(other_vol, index, some_matrix);

(C++ version of the code)

When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all. In the example above all the resulting slices had the same shape as the divided volume (box). This is not always the case. For instance, dividing a volume with TUBE shape on PHI axis will create equal slices having TUBESEG shape. Other divisions can also create slices having shapes with different dimensions, e.g. the division of a TRD1 volume on Z. When positioning volumes inside slices, one can do it using the generic volume family (e.g. slicey). This should be done as if the coordinate system of the generic slice was the same as the one of the divided volume. The generic slice in case of PHI division is centered with respect to X axis. If the family contains slices of different sizes, any volume positioned inside should fit into the smallest one. Examples for specific divisions according to shape types can be found inside shape classes.

    TGeoVolume!Divide(N, Xmin, Xmax, "X");

(C++ version of the code)

The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping volume is in fact a virtual container that does not represent a physical object. It contains a list of nodes that are not its daughters but that must be checked always before the container itself. This list must be defined by users and it is checked and resolved in a priority order. Note that the feature is non-standard to geometrical modelers and it was introduced just to support conversions of GEANT3 geometries, therefore its extensive usage should be avoided.

Related functions: [`AddNodeOverlap`](@ref), [`AddNode`](@ref), [`AddVolume`](@ref), [`Divide`](@ref), [`GetAxis`](@ref), [`GetLastShape`](@ref), [`GetNdiv`](@ref), [`GetNvolumes`](@ref), [`GetStart`](@ref), [`GetStep`](@ref), [`GetVolume`](@ref), [`IsVolumeMulti`](@ref), [`MakeCopyVolume`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetMedium`](@ref), [`SetVisibility`](@ref), [`TGeoVolumeMulti`](@ref)
""" TGeoVolumeMulti

# Wrapper of TGeoElement
@trydoc raw"""
    ROOT.TGeoElement

Base class for chemical elements.



Related functions: [`A`](@ref), [`AddIsotope`](@ref), [`ComputeDerivedQuantities`](@ref), [`ENDFCode`](@ref), [`GetIsotope`](@ref), [`GetNisotopes`](@ref), [`GetRelativeAbundance`](@ref), [`GetSpecificActivity`](@ref), [`GetfCoulomb`](@ref), [`GetfRadTsai`](@ref), [`HasIsotopes`](@ref), [`IsDefined`](@ref), [`IsRadioNuclide`](@ref), [`IsUsed`](@ref), [`N`](@ref), [`Neff`](@ref), [`Print`](@ref), [`SetDefined`](@ref), [`SetUsed`](@ref), [`TGeoElement!GetElementTable`](@ref), [`TGeoElement`](@ref), [`Z`](@ref)
""" TGeoElement

# Wrapper of TGeoIsotope
@trydoc raw"""
    ROOT.TGeoIsotope





Related functions: [`GetA`](@ref), [`GetN`](@ref), [`GetZ`](@ref), [`Print`](@ref), [`TGeoIsotope!FindIsotope`](@ref), [`TGeoIsotope`](@ref)
""" TGeoIsotope

# Wrapper of TGeoElementTable
@trydoc raw"""
    ROOT.TGeoElementTable

Table of elements.



Related functions: [`AddElementRN`](@ref), [`AddElement`](@ref), [`AddIsotope`](@ref), [`BuildDefaultElements`](@ref), [`CheckTable`](@ref), [`ExportElementsRN`](@ref), [`FindElement`](@ref), [`FindIsotope`](@ref), [`GetElementRN`](@ref), [`GetElement`](@ref), [`GetElementsRN`](@ref), [`GetNelementsRN`](@ref), [`GetNelements`](@ref), [`HasDefaultElements`](@ref), [`HasRNElements`](@ref), [`ImportElementsRN`](@ref), [`Print`](@ref), [`TGeoElementTable`](@ref)
""" TGeoElementTable

# Wrapper of TGeoElementRN
@trydoc raw"""
    ROOT.TGeoElementRN

Class representing a radionuclidevoid TGeoManager!SetDefaultRootUnits() { if ( fgDefaultUnits == kRootUnits ) { return; } else if ( gGeometryLocked ) { TError!Fatal("TGeoManager","The system of units may only be changed once BEFORE any elements and materials are
created!"); } fgDefaultUnits = kRootUnits; }.



Related functions: [`AddDecay`](@ref), [`AddRatio`](@ref), [`AtomicNo`](@ref), [`CheckDecays`](@ref), [`DecayResult`](@ref), [`Decays`](@ref), [`ENDFCode`](@ref), [`FillPopulation`](@ref), [`GetNdecays`](@ref), [`GetSpecificActivity`](@ref), [`HalfLife`](@ref), [`IsRadioNuclide`](@ref), [`IsoNo`](@ref), [`Level`](@ref), [`MassEx`](@ref), [`MassNo`](@ref), [`NatAbun`](@ref), [`PJ`](@ref), [`Print`](@ref), [`Ratio`](@ref), [`ResetRatio`](@ref), [`SavePrimitive`](@ref), [`Stable`](@ref), [`Status`](@ref), [`TG_F`](@ref), [`TG_S`](@ref), [`TGeoElementRN!ENDF`](@ref), [`TGeoElementRN!ReadElementRN`](@ref), [`TGeoElementRN`](@ref), [`TH_F`](@ref), [`TH_S`](@ref)
""" TGeoElementRN

# Wrapper of TGeoDecayChannel
@trydoc raw"""
    ROOT.TGeoDecayChannel

A decay channel for a radionuclide.



Related functions: [`BranchingRatio`](@ref), [`Daughter`](@ref), [`DecayShift`](@ref), [`Decay`](@ref), [`DeltaIso`](@ref), [`GetIndex`](@ref), [`GetName`](@ref), [`Parent`](@ref), [`Print`](@ref), [`Qvalue`](@ref), [`SavePrimitive`](@ref), [`SetDaughter`](@ref), [`SetParent`](@ref), [`TGeoDecayChannel!DecayName`](@ref), [`TGeoDecayChannel!ReadDecay`](@ref), [`TGeoDecayChannel`](@ref), [`assign`](@ref)
""" TGeoDecayChannel

# Wrapper of TGeoBatemanSol
@trydoc raw"""
    ROOT.TGeoBatemanSol





Related functions: [`Concentration`](@ref), [`Draw`](@ref), [`FindSolution`](@ref), [`GetCoeff`](@ref), [`GetElement`](@ref), [`GetNcoeff`](@ref), [`GetRange`](@ref), [`GetTopElement`](@ref), [`Normalize`](@ref), [`Print`](@ref), [`SetFactor`](@ref), [`SetRange`](@ref), [`TGeoBatemanSol`](@ref), [`add!`](@ref), [`assign`](@ref)
""" TGeoBatemanSol

# Wrapper of TGeoElemIter
@trydoc raw"""
    ROOT.TGeoElemIter

Iterator for decay branches.



Related functions: [`GetBranch`](@ref), [`GetElement`](@ref), [`GetLevel`](@ref), [`GetRatio`](@ref), [`GetTop`](@ref), [`Next`](@ref), [`Print`](@ref), [`SetLimitRatio`](@ref), [`TGeoElemIter`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TGeoElemIter

# Wrapper of TGeoExtension
@trydoc raw"""
    ROOT.TGeoExtension

ABC for user objects attached to [TGeoVolume](@ref) or [TGeoNode](@ref).

Provides interface for getting a reference (grab) and releasing the extension object (release), allowing for derived classes to implement reference counted sharing. The user who should attach extensions to logical volumes or nodes BEFORE applying misalignment information so that these will be available to all copies.

Related functions: [`Grab`](@ref), [`Release`](@ref)
""" TGeoExtension

# Wrapper of TGeoMixture
@trydoc raw"""
    ROOT.TGeoMixture

Mixtures of elements.



Related functions: [`AddElement`](@ref), [`ComputeDerivedQuantities`](@ref), [`ComputeNuclearInterLength`](@ref), [`ComputeRadiationLength`](@ref), [`DecayMaterial`](@ref), [`DefineElement`](@ref), [`FillMaterialEvolution`](@ref), [`GetAmixt`](@ref), [`GetByteCount`](@ref), [`GetElementProp`](@ref), [`GetElement`](@ref), [`GetNelements`](@ref), [`GetNmixt`](@ref), [`GetSpecificActivity`](@ref), [`GetWmixt`](@ref), [`GetZmixt`](@ref), [`IsEq`](@ref), [`IsMixture`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetA`](@ref), [`SetDensity`](@ref), [`SetZ`](@ref), [`TGeoMixture`](@ref)
""" TGeoMixture

# Wrapper of TGeoPatternFinder
@trydoc raw"""
    ROOT.TGeoPatternFinder

Base finder class for patterns.

A pattern is specifying a division type which applies only to a given shape type. The implemented patterns are for the moment equidistant slices on different axis. Implemented patterns are:

- [TGeoPatternX](@ref) - a X axis divison pattern
- [TGeoPatternY](@ref) - a Y axis divison pattern
- [TGeoPatternZ](@ref) - a Z axis divison pattern
- [TGeoPatternParaX](@ref) - a X axis divison pattern for PARA shape
- [TGeoPatternParaY](@ref) - a Y axis divison pattern for PARA shape
- [TGeoPatternParaZ](@ref) - a Z axis divison pattern for PARA shape
- [TGeoPatternTrapZ](@ref) - a Z axis divison pattern for TRAP or GTRA shapes
- [TGeoPatternCylR](@ref) - a cylindrical R divison pattern
- [TGeoPatternCylPhi](@ref) - a cylindrical phi divison pattern
- [TGeoPatternSphR](@ref) - a spherical R divison pattern
- [TGeoPatternSphTheta](@ref) - a spherical theta divison pattern
- [TGeoPatternSphPhi](@ref) - a spherical phi divison pattern
- [TGeoPatternHoneycomb](@ref) - a divison pattern specialized for honeycombs

Related functions: [`CdNext`](@ref), [`ClearThreadData`](@ref), [`CreateMatrix`](@ref), [`CreateThreadData`](@ref), [`FindNode`](@ref), [`GetByteCount`](@ref), [`GetCurrent`](@ref), [`GetDivAxis`](@ref), [`GetDivIndex`](@ref), [`GetEnd`](@ref), [`GetMatrix`](@ref), [`GetNdiv`](@ref), [`GetNext`](@ref), [`GetNodeOffset`](@ref), [`GetStart`](@ref), [`GetStep`](@ref), [`GetThreadData`](@ref), [`GetVolume`](@ref), [`IsOnBoundary`](@ref), [`IsReflected`](@ref), [`IsSpacedOut`](@ref), [`MakeCopy`](@ref), [`Reflect`](@ref), [`SetDivIndex`](@ref), [`SetNext`](@ref), [`SetRange`](@ref), [`SetSpacedOut`](@ref), [`SetVolume`](@ref), [`TGeoPatternFinder`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternFinder

# Wrapper of TGeoVoxelFinder
@trydoc raw"""
    ROOT.TGeoVoxelFinder

Finder class handling voxels.

Full description with examples and pictures

![https://root.cern/doc/v636/geom_t_finder.png](https://root.cern/doc/v636/geom_t_finder.png)
 ![https://root.cern/doc/v636/geom_t_voxelfind.png](https://root.cern/doc/v636/geom_t_voxelfind.png)
 ![https://root.cern/doc/v636/geom_t_voxtree.png](https://root.cern/doc/v636/geom_t_voxtree.png)

Related functions: [`DaughterToMother`](@ref), [`Efficiency`](@ref), [`FindOverlaps`](@ref), [`GetBoxes`](@ref), [`GetCheckList`](@ref), [`GetNextCandidates`](@ref), [`GetNextVoxel`](@ref), [`IsInvalid`](@ref), [`IsSafeVoxel`](@ref), [`NeedRebuild`](@ref), [`PrintVoxelLimits`](@ref), [`Print`](@ref), [`SetInvalid`](@ref), [`SetNeedRebuild`](@ref), [`SortCrossedVoxels`](@ref), [`TGeoVoxelFinder`](@ref), [`Voxelize`](@ref)
""" TGeoVoxelFinder

# Wrapper of TGeoPatternX
@trydoc raw"""
    ROOT.TGeoPatternX





Related functions: [`CreateMatrix`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternX`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternX

# Wrapper of TGeoPatternY
@trydoc raw"""
    ROOT.TGeoPatternY





Related functions: [`CreateMatrix`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternY`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternY

# Wrapper of TGeoPatternZ
@trydoc raw"""
    ROOT.TGeoPatternZ





Related functions: [`CreateMatrix`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternZ`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternZ

# Wrapper of TGeoPatternParaX
@trydoc raw"""
    ROOT.TGeoPatternParaX





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternParaX`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternParaX

# Wrapper of TGeoPatternParaY
@trydoc raw"""
    ROOT.TGeoPatternParaY





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternParaY`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternParaY

# Wrapper of TGeoPatternParaZ
@trydoc raw"""
    ROOT.TGeoPatternParaZ





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternParaZ`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternParaZ

# Wrapper of TGeoPatternTrapZ
@trydoc raw"""
    ROOT.TGeoPatternTrapZ





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`GetTxz`](@ref), [`GetTyz`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternTrapZ`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternTrapZ

# Wrapper of TGeoPatternCylR
@trydoc raw"""
    ROOT.TGeoPatternCylR





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternCylR`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternCylR

# Wrapper of TGeoPatternCylPhi
@trydoc raw"""
    ROOT.TGeoPatternCylPhi





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternCylPhi`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternCylPhi

# Wrapper of TGeoPatternSphR
@trydoc raw"""
    ROOT.TGeoPatternSphR





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternSphR`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternSphR

# Wrapper of TGeoPatternSphTheta
@trydoc raw"""
    ROOT.TGeoPatternSphTheta





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternSphTheta`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternSphTheta

# Wrapper of TGeoPatternSphPhi
@trydoc raw"""
    ROOT.TGeoPatternSphPhi





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternSphPhi`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternSphPhi

# Wrapper of TGeoPatternHoneycomb
@trydoc raw"""
    ROOT.TGeoPatternHoneycomb





Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`MakeCopy`](@ref), [`TGeoPatternHoneycomb`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternHoneycomb

# Wrapper of TGeoNodeMatrix
@trydoc raw"""
    ROOT.TGeoNodeMatrix

A node containing local_ transformation.



Related functions: [`GetByteCount`](@ref), [`GetMatrix`](@ref), [`GetOptimalVoxels`](@ref), [`IsFolder`](@ref), [`MakeCopyNode`](@ref), [`SetMatrix`](@ref), [`TGeoNodeMatrix`](@ref)
""" TGeoNodeMatrix

# Wrapper of TGeoNodeOffset
@trydoc raw"""
    ROOT.TGeoNodeOffset

Node containing an offset.



Related functions: [`GetFinder`](@ref), [`GetIndex`](@ref), [`GetMatrix`](@ref), [`GetOffset`](@ref), [`MakeCopyNode`](@ref), [`SetFinder`](@ref), [`TGeoNodeOffset`](@ref), [`cd`](@ref)
""" TGeoNodeOffset

# Wrapper of TGeoIterator
@trydoc raw"""
    ROOT.TGeoIterator

A geometry iterator.

A geometry iterator that sequentially follows all nodes of the geometrical hierarchy of a volume. The iterator has to be initiated with a top volume pointer:

    TGeoIterator next(myVolume);

(C++ version of the code)

One can use the iterator as any other in [ROOT](@ref):

    TGeoNode *node;
    while ((node=next())) {
       ...
    }

(C++ version of the code)

The iterator can perform 2 types of iterations that can be selected via:

    next.SetType(Int_t type);

(C++ version of the code)

Here TYPE can be:

- 0 (default) - 'first daughter next' behavior
- 1 - iteration at the current level only

Supposing the tree structure looks like:

    TOP ___ A_1 ___ A1_1 ___ A11_1
       |       |        |___ A12_1
       |      |_____A2_1 ___ A21_1
       |                |___ A21_2
       |___ B_1 ...

(C++ version of the code)

The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1, A21_2, B_1, ...

The order of iteration for TYPE=1 is: A_1, B_1, ... At any moment during iteration, TYPE can be changed. If the last iterated node is for instance A1_1 and the iteration type was 0, one can do:

    next.SetType(1);

(C++ version of the code)

The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator will return 0 after finishing all daughters of A.

During iteration, the following can be retrieved:

- Top volume where iteration started: [TGeoIterator!GetTopVolume()](@ref)
- Node at level I in the current branch: TGeoIterator!GetNode(Int_t i)
- Iteration type: [TGeoIterator!GetType()](@ref)
- Global matrix of the current node with respect to the top volume: [TGeoIterator!GetCurrentMatrix()](@ref)

The iterator can be reset by changing (or not) the top volume:

    TGeoIterator!Reset(TGeoVolume *top);

(C++ version of the code)

### Example:

We want to find out a volume named "MyVol" in the hierarchy of TOP volume.

    TIter next(TOP);
    TGeoNode *node;
    TString name("MyVol");
    while ((node=next()))
       if (name == node->GetVolume()->GetName()) return node->GetVolume();

(C++ version of the code)

Related functions: [`GetCurrentMatrix`](@ref), [`GetIndex`](@ref), [`GetLevel`](@ref), [`GetNode`](@ref), [`GetPath`](@ref), [`GetTopVolume`](@ref), [`GetType`](@ref), [`GetUserPlugin`](@ref), [`Next`](@ref), [`Reset`](@ref), [`SetPluginAutoexec`](@ref), [`SetTopName`](@ref), [`SetType`](@ref), [`SetUserPlugin`](@ref), [`Skip`](@ref), [`TGeoIterator`](@ref), [`Up`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TGeoIterator

# Wrapper of TGeoIteratorPlugin
@trydoc raw"""
    ROOT.TGeoIteratorPlugin





Related functions: [`ProcessNode`](@ref), [`SetIterator`](@ref), [`TGeoIteratorPlugin`](@ref)
""" TGeoIteratorPlugin

# Wrapper of TGeoPolygon
@trydoc raw"""
    ROOT.TGeoPolygon

An arbitrary polygon defined by vertices.

The vertices have to be defined CLOCKWISE in the XY plane, making either a convex or concave polygon. No test for malformed polygons is performed.

A polygon is a 2D shape defined by vertices in the XY plane. It is used by [TGeoXtru](@ref) class for computing [Contains()](@ref) and [Safety()](@ref). Only the pointers to the actual lists of XY values are used - these are not owned by the class.

To check if a point in XY plane is contained by a polygon, this is split into an outscribed convex polygon and the remaining polygons of its subtraction from the outscribed one. A point is INSIDE if it is contained by the outscribed polygon but NOT by the remaining ones. Since these can also be arbitrary polygons at their turn, a tree structure is formed:

    P = Pconvex - (Pconvex-P)           where (-) means 'subtraction'
    Pconvex-P = P1 + P2 + ...           where (+) means 'union'

(C++ version of the code)

Note that P1, P2, ... do not intersect each other and they are defined by subsets of the list of vertices of P. They can be split in the same way as P*

Therefore, if C(P) represents the Boolean : 'does P contains a given point?', then:

    C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...)

(C++ version of the code)

For creating a polygon without [TGeoXtru](@ref) class, one has to call the constructor [TGeoPolygon(nvert)](@ref) and then [SetXY(Double_t *x, Double_t *y)](@ref) providing the arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer than the polygon they will describe. This complication is due to efficiency reasons. At the theend one has to call the [FinishPolygon()](@ref) method.

Related functions: [`Area`](@ref), [`Contains`](@ref), [`Draw`](@ref), [`FinishPolygon`](@ref), [`GetConvexVertices`](@ref), [`GetNconvex`](@ref), [`GetNvert`](@ref), [`GetVertices`](@ref), [`GetX`](@ref), [`GetY`](@ref), [`IsClockwise`](@ref), [`IsConvex`](@ref), [`IsFinished`](@ref), [`IsIllegalCheck`](@ref), [`Safety`](@ref), [`SetConvex`](@ref), [`SetNextIndex`](@ref), [`SetXY`](@ref), [`TGeoPolygon`](@ref)
""" TGeoPolygon

# Wrapper of TGeoCacheState
@trydoc raw"""
    ROOT.TGeoCacheState

Class storing the state of the cache at a given moment.



Related functions: [`GetState`](@ref), [`SetState`](@ref), [`TGeoCacheState`](@ref)
""" TGeoCacheState

# Wrapper of TGeoNodeCache
@trydoc raw"""
    ROOT.TGeoNodeCache

Special pool of reusable nodes.



Related functions: [`BuildIdArray`](@ref), [`BuildInfoBranch`](@ref), [`CdDown`](@ref), [`CdNode`](@ref), [`CdTop`](@ref), [`CdUp`](@ref), [`FillIdBranch`](@ref), [`GetBranchNames`](@ref), [`GetBranchNumbers`](@ref), [`GetBranchOnlys`](@ref), [`GetBranch`](@ref), [`GetCurrentMatrix`](@ref), [`GetCurrentNodeId`](@ref), [`GetIdBranch`](@ref), [`GetInfo`](@ref), [`GetLevel`](@ref), [`GetMakePWInfo`](@ref), [`GetMatrices`](@ref), [`GetMotherMatrix`](@ref), [`GetMother`](@ref), [`GetNodeId`](@ref), [`GetNode`](@ref), [`GetPath`](@ref), [`GetStackLevel`](@ref), [`GetTopNode`](@ref), [`HasIdArray`](@ref), [`IsDummy`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`PopDummy`](@ref), [`PopState`](@ref), [`PushState`](@ref), [`Refresh`](@ref), [`ReleaseInfo`](@ref), [`RestoreState`](@ref), [`TGeoNodeCache`](@ref)
""" TGeoNodeCache

# Wrapper of TGeoCompositeShape
@trydoc raw"""
    ROOT.TGeoCompositeShape

Composite shapes are Boolean combinations of two or more shape components.

The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base `TGeoShape`** class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.

Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This `CSG` `(composite solid geometry)` hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.

#### The Structure of Composite Shapes

A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure.

![https://root.cern/doc/v636/geom_composite_shape001.png](https://root.cern/doc/v636/geom_composite_shape001.png)

Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator.

1. Union: `A+B+C`

Just to illustrate the Boolean expression parsing and the composite shape structure, let's take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:

`A+B+C = (A+B)+C = A+(B+C)`

The first`(+)` is taken as separator, hence the expression split in: `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`("A","B+C")` is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named "A" is searched into the list of shapes handled by the manager class and stored as the "left" shape in the Boolean union node. Since the second expression is not yet fully decomposed, the "right" shape in the combination is created as a new composite shape. This will split at its turn B+C into B and C and create a **`TGeoUnion`**`("B","C")`. The B and C identifiers will be looked for and replaced by the pointers to the actual shapes into the new node. Finally, the composite "`A+B+C`" will be represented as shown in Fig.17-23.**

![https://root.cern/doc/v636/geom_composite_shape002.png](https://root.cern/doc/v636/geom_composite_shape002.png)

To build this composite shape:

    TGeoCompositeShape *cs1 = new TGeoCompositeShape("CS1","A+B+C");

(C++ version of the code)

Any shape entering a Boolean combination can be prior positioned. In order to do so, one has to attach a matrix name to the shape name by using a colon (:). As for shapes, the named matrix has to be prior defined:

    TGeoMatrix *mat;
    // ... code creating some geometrical transformation
    mat->SetName("mat1");
    mat->RegisterYourself();  // see Geometrical transformations

(C++ version of the code)

An identifier `shape:matrix` have the meaning: `shape` is translated or rotated with `matrix` with respect to the Boolean combination it enters as operand. Note that in the expression A+B+C no matrix identifier was provided, therefore the identity matrix was used for positioning the shape components. The next example will illustrate a more complex case.

1. `(A:m1+B):m2-(C:m3*D:m4):m5`

Let's try to understand the expression above. This expression means: subtract the intersection of **C** and **D** from the union of **A** and B**. The usage of parenthesis to force the desired precedence is always recommended. One can see that not only the primitive shapes have some geometrical transformations, but also their intermediate compositions.

![https://root.cern/doc/v636/geom_composite_shape003.png](https://root.cern/doc/v636/geom_composite_shape003.png)

    TGeoCompositeShape *cs2 = new TGeoCompositeShape("CS2",
    "(A:m1+B):m2-(C:m3*D:m4):m5");

(C++ version of the code)

Building composite shapes as in the first example is not always quite useful since we were using un-positioned shapes. When supplying just shape names as identifiers, the created Boolean nodes will assume that the shapes are positioned with an identity transformation with respect to the frame of the created composite. In order to provide some positioning of the combination components, we have to attach after each shape identifier the name of an existing transformation, separated by a colon. Obviously all transformations created for this purpose have to be objects with unique names in order to be properly substituted during parsing.

#### Composite Shape Example

One should have in mind that the same shape or matrix identifiers can be used many times in the same expression, as in the following example:

    {
       TCanvas *c = new TCanvas("c", "c",0,0,600,600);
       const Double_t sq2 = TMath!Sqrt(2.);
       TGeoManager *mgr =
          new TGeoManager("Geom","composite shape example");
       TGeoMedium *medium = 0;
       TGeoVolume *top = mgr->MakeBox("TOP",medium,100,250,250);
       mgr->SetTopVolume(top);
       // make shape components
       TGeoBBox *sbox  = new TGeoBBox("B",100,125*sq2,125*sq2);
       TGeoTube *stub  = new TGeoTube("T",0,100,250);
       TGeoPgon *spgon = new TGeoPgon("P",0.,360.,6,2);
       spgon->DefineSection(0,-250,0,80);
       spgon->DefineSection(1,250,0,80);
       // define some rotations
       TGeoRotation *r1 = new TGeoRotation("r1",90,0,0,180,90,90);
       r1->RegisterYourself();
       TGeoRotation *r2 = new TGeoRotation("r2",90,0,45,90,45,270);
       r2->RegisterYourself();
       // create a composite
       TGeoCompositeShape *cs = new TGeoCompositeShape("cs", "((T+T:r1)-(P+P:r1))*B:r2");
       TGeoVolume *comp = new TGeoVolume("COMP",cs);
       comp->SetLineColor(kRed);
       // put it in the top volume
       top->AddNode(comp,1);
       mgr->CloseGeometry();
       // visualize it with ray tracing
       top->Raytrace();
    }

(C++ version of the code)

![https://root.cern/doc/v636/geom_composite_shape004.png](https://root.cern/doc/v636/geom_composite_shape004.png)

Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided.

Related functions: [`Capacity`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoolNode`](@ref), [`GetBoundingCylinder`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`IsComposite`](@ref), [`IsCylType`](@ref), [`MakeNode`](@ref), [`PaintComposite`](@ref), [`RegisterYourself`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`Sizeof3D`](@ref), [`TGeoCompositeShape`](@ref)
""" TGeoCompositeShape

# Wrapper of TGeoCone
@trydoc raw"""
    ROOT.TGeoCone

The cones are defined by 5 parameters:

TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,
    Double_t rmin2,Double_t rmax2);

(C++ version of the code)

- `rmin1:` internal radius at Z is `-dz`
- `rmax1:` external radius at Z is `-dz`
- `rmin2:` internal radius at Z is `+dz`
- `rmax2:` external radius at Z is `+dz`
- `dz:` half length in Z (a cone ranges from `-dz` to +`dz`)

A cone has Z-axis as its symmetry axis.

![https://root.cern/doc/v636/pict1_TGeoCone_001.png](https://root.cern/doc/v636/pict1_TGeoCone_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDz`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax1`](@ref), [`GetRmax2`](@ref), [`GetRmin1`](@ref), [`GetRmin2`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetConeDimensions`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoCone!Capacity`](@ref), [`TGeoCone!ComputeNormalS`](@ref), [`TGeoCone!DistFromInsideS`](@ref), [`TGeoCone!DistFromOutsideS`](@ref), [`TGeoCone!DistToCone`](@ref), [`TGeoCone!SafetyS`](@ref), [`TGeoCone`](@ref)
""" TGeoCone

# Wrapper of TGeoConeSeg
@trydoc raw"""
    ROOT.TGeoConeSeg

A cone segment is a cone having a range in `phi`.

The cone segment class derives from **`TGeoCone`**, having two extra parameters: `phi1` and `phi2`.

    TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,
    Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);

(C++ version of the code)

Parameters `phi1` and `phi2` have the same meaning and convention as for tube segments.

![https://root.cern/doc/v636/pict1_TGeoCone_002.png](https://root.cern/doc/v636/pict1_TGeoCone_002.png)

Related functions: [`AfterStreamer`](@ref), [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi1`](@ref), [`GetPhi2`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetConsDimensions`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoConeSeg!Capacity`](@ref), [`TGeoConeSeg!ComputeNormalS`](@ref), [`TGeoConeSeg!DistFromInsideS`](@ref), [`TGeoConeSeg!DistFromOutsideS`](@ref), [`TGeoConeSeg!DistToCons`](@ref), [`TGeoConeSeg!SafetyS`](@ref), [`TGeoConeSeg`](@ref)
""" TGeoConeSeg

# Wrapper of TGeoTube
@trydoc raw"""
    ROOT.TGeoTube

Cylindrical tube class.

A tube has 3 parameters :

- `rmin` : minimum radius
- `rmax` : maximum radius
- `dz` : half length

    TGeoTube(Double_t rmin,Double_t rmax,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoTube_001.png](https://root.cern/doc/v636/pict1_TGeoTube_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDz`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`HasRmin`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetTubeDimensions`](@ref), [`Sizeof3D`](@ref), [`TGeoTube!Capacity`](@ref), [`TGeoTube!ComputeNormalS`](@ref), [`TGeoTube!DistFromInsideS`](@ref), [`TGeoTube!DistFromOutsideS`](@ref), [`TGeoTube!DistToTube`](@ref), [`TGeoTube!SafetyS`](@ref), [`TGeoTube`](@ref)
""" TGeoTube

# Wrapper of TGeoTubeSeg
@trydoc raw"""
    ROOT.TGeoTubeSeg

A tube segment is a tube having a range in phi.

The tube segment class derives from **`TGeoTube`**, having 2 extra parameters: `phi1` and `phi2`.

    TGeoTubeSeg(Double_t rmin,Double_t rmax,Double_t dz,
    Double_t phi1,Double_t phi2);

(C++ version of the code)

Here `phi1` and `phi2`are the starting and ending `phi`values in degrees. The `general phi convention` is that the shape ranges from `phi1` to `phi2` going counterclockwise. The angles can be defined with either negative or positive values. They are stored such that `phi1` is converted to `[0,360]` and `phi2 > phi1`.

![https://root.cern/doc/v636/pict1_TGeoTube_002.png](https://root.cern/doc/v636/pict1_TGeoTube_002.png)

Related functions: [`AfterStreamer`](@ref), [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi1`](@ref), [`GetPhi2`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetTubsDimensions`](@ref), [`Sizeof3D`](@ref), [`TGeoTubeSeg!Capacity`](@ref), [`TGeoTubeSeg!ComputeNormalS`](@ref), [`TGeoTubeSeg!DistFromInsideS`](@ref), [`TGeoTubeSeg!DistFromOutsideS`](@ref), [`TGeoTubeSeg!SafetyS`](@ref), [`TGeoTubeSeg`](@ref)
""" TGeoTubeSeg

# Wrapper of TGeoCtub
@trydoc raw"""
    ROOT.TGeoCtub

The cut tubes constructor has the form:

TGeoCtub(Double_t rmin,Double_t rmax,Double_t dz,
    Double_t phi1,Double_t phi2,
    Double_t nxlow,Double_t nylow,Double_t nzlow, Double_t nxhi,
    Double_t nyhi,Double_t nzhi);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoTube_003.png](https://root.cern/doc/v636/pict1_TGeoTube_003.png)

A cut tube is a tube segment cut with two planes. The centers of the 2 sections are positioned at `dZ`. Each cut plane is therefore defined by a point `(0,0,dZ)` and its normal unit vector pointing outside the shape:

`Nlow=(Nx,Ny,Nz<0)`, 'Nhigh=(Nx',Ny',Nz'>0)`.

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNhigh`](@ref), [`GetNlow`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetZcoord`](@ref), [`InspectShape`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetCtubDimensions`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`TGeoCtub`](@ref)
""" TGeoCtub

# Wrapper of TGeoEltu
@trydoc raw"""
    ROOT.TGeoEltu

An elliptical tube is defined by the two semi-axes `A` and `B`.

It ranges from `-dZ` to `+dZ` as all other tubes:

    TGeoEltu(Double_t a,Double_t b,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoEltu_001.png](https://root.cern/doc/v636/pict1_TGeoEltu_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetA`](@ref), [`GetB`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetEltuDimensions`](@ref), [`SetPoints`](@ref), [`TGeoEltu`](@ref)
""" TGeoEltu

# Wrapper of TGeoRCExtension
@trydoc raw"""
    ROOT.TGeoRCExtension

Reference counted extension which has a pointer to and owns a user defined [TObject](@ref).

This class can be used as model for a reference counted derivation from [TGeoExtension](@ref).

Note: Creating a [TGeoRCExtension](@ref) with new() automatically grabs it, but the creator has to Release it before the pointer gets out of scope. The following sequence is valid:

    // producer:
    TGeoRCExtension *ext = new TGeoRCExtension();
    some_TGeoVolume->SetUserExtension(ext);
    ext->Release();
    // user:
    TGeoRCExtension *ext = dynamic_cast<TGeoRCExtension*>(some_TGeoVolume->GrabUserExtension());
    // ... use extension
    ext->Release();

(C++ version of the code)

The extension is going to be released by the [TGeoVolume](@ref) holder at the destruction or when calling SetUserExtension(0).

The following usage is not correct:

    some_TGeoVolume->SetUserExtension(new TGeoRCExtension())

(C++ version of the code)

since the producer code does not release the extension. One cannot call directly "delete ext" nor allocate an extension on the stack, since the destructor is protected. Use Release instead.

Related functions: [`GetUserObject`](@ref), [`Grab`](@ref), [`Release`](@ref), [`SetUserObject`](@ref), [`TGeoRCExtension`](@ref)
""" TGeoRCExtension

# Wrapper of TVirtualMagField
@trydoc raw"""
    ROOT.TVirtualMagField

Abstract class for magnetic field.

Derived classes are encouraged to use the [TVirtualMagField](@ref) named constructor and must implement the method:

    Field(const Double_t *x, Double_t *B)

(C++ version of the code)

A field object can be made global_ via:

    TGlobalMagField!Instance()->SetField(field)         [1]

(C++ version of the code)

A field which is made global_ is owned by the field manager. The used is not allowed to delete it directly anymore (otherwise a [Fatal()](@ref) is issued). Global field can be deleted by calling [1] with a different argument (which can be NULL). Otherwise the global_ field is deleted together with the field manager.

Related functions: [`Field`](@ref), [`TVirtualMagField`](@ref)
""" TVirtualMagField

# Wrapper of TGeoUniformMagField
@trydoc raw"""
    ROOT.TGeoUniformMagField

Implementation for uniform magnetic field.



Related functions: [`Field`](@ref), [`GetFieldValue`](@ref), [`SetFieldValue`](@ref), [`TGeoUniformMagField`](@ref)
""" TGeoUniformMagField

# Wrapper of TGeoGlobalMagField
@trydoc raw"""
    ROOT.TGeoGlobalMagField

Global magnetic field manager.

Provides access to and owns the actual magnetic field set via `SetField()`. The field is deleted upon destruction of the field manager at the theend of [ROOT](@ref) session or by calling:

    TGeoGlobalMagField!Instance()->SetField(0).

(C++ version of the code)

The previous global_ field is deleted upon replacement with notification.

The global_ field manager provides access to the global_ field via:

    TGeoGlobalMagField!Instance()->GetField()

(C++ version of the code)

One can directly call the [Field()](@ref) method of a field via the global_ field manager:

    TGeoGlobalMagField!Instance()->Field(x,B)

(C++ version of the code)

Related functions: [`Field`](@ref), [`GetField`](@ref), [`IsLocked`](@ref), [`Lock`](@ref), [`SetField`](@ref), [`TGeoGlobalMagField!GetInstance`](@ref), [`TGeoGlobalMagField!Instance`](@ref), [`TGeoGlobalMagField`](@ref)
""" TGeoGlobalMagField

# Wrapper of TGeoHalfSpace
@trydoc raw"""
    ROOT.TGeoHalfSpace

A half space is limited just by a plane, defined by a point and the normal direction.

The point lies on the plane and the normal vector points outside the half space. The half space is the only shape which is infinite and can be used only in Boolean operations that result in non-infinite composite shapes (see also [TGeoCompositeShape](@ref)). A half space has to be defined using the constructor:

    TGeoHalfSpace (const char *name, Double_t *point[3],
    Double_t *norm[3]);

(C++ version of the code)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoundingCylinder`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNorm`](@ref), [`GetPoint`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`Sizeof3D`](@ref), [`TGeoHalfSpace`](@ref)
""" TGeoHalfSpace

# Wrapper of TGeoHelix
@trydoc raw"""
    ROOT.TGeoHelix

Class representing a helix curve.

A helix is a curve defined by the following equations:

    x = (1/c) * COS(q*phi)
    y = (1/c) * SIN(q*phi)
    z = s * alfa

(C++ version of the code)

where:

    c = 1/Rxy  - curvature in XY plane
    phi        - phi angle
    S = 2*PI*s - vertical separation between helix loops
    q = +/- 1  - (+)=left-handed, (-)=right-handed

(C++ version of the code)

In particular, a helix describes the trajectory of a charged particle in magnetic field. In such case, the helix is right-handed for negative particle charge. To define a helix, one must define:

- the curvature - positive defined
- the Z step made after one full turn of the helix
- the particle charge sign
- the initial particle position and direction (force normalization to unit)
- the magnetic field direction

A helix provides:

- propagation to a given Z position (in global_ frame) Double_t *point = TGeoHelix!PropagateToZ(Double_t z);
- propagation to an arbitrary plane, returning also the new point
- propagation in a geometry until the next crossed surface
- computation of the total track length along a helix

Related functions: [`ComputeSafeStep`](@ref), [`GetCurrentDirection`](@ref), [`GetCurrentPoint`](@ref), [`GetStep`](@ref), [`GetTotalCurvature`](@ref), [`GetXYcurvature`](@ref), [`InitDirection`](@ref), [`InitPoint`](@ref), [`IsRightHanded`](@ref), [`ResetStep`](@ref), [`SetCharge`](@ref), [`SetField`](@ref), [`SetHelixStep`](@ref), [`SetXYcurvature`](@ref), [`StepToPlane`](@ref), [`Step`](@ref), [`TGeoHelix`](@ref), [`UpdateHelix`](@ref)
""" TGeoHelix

# Wrapper of TGeoHype
@trydoc raw"""
    ROOT.TGeoHype

A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces).

The class describing hyperboloids is [TGeoHype](@ref) has 5 input parameters:

    TGeoHype(Double_t rin,Double_t stin,Double_t rout,
    Double_t stout,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoHype_001.png](https://root.cern/doc/v636/pict1_TGeoHype_001.png)

The hyperbolic surface equation is taken in the form:

    r^2 - z^2 * tan(st)^2 = rmin^2

(C++ version of the code)

- `r,z:` cylindrical coordinates for a point on the surface
- `st:` stereo angle between the hyperbola asymptotic lines and Z axis
- `rmin:` minimum distance between hyperbola and Z axis (at `z=0`)

The input parameters for a hyperboloid represent:

- `rin, stin:` minimum radius and stereo angle in degrees for the inner surface
- `rout, stout:` minimum radius and stereo angle in degrees for the outer surface
- `dz:` half length in Z (bounding planes positions at `+/-dz`)

The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range `+/-dz`:

- `rin < rout`
- `rout > 0`
- `rin^2 + dz^2 * tan(stin)^2 > rout^2 + dz^2 * tan(stout)^2`

Particular cases:

- `rin=0, stin0:` the inner surface is conical
- `stin=0 / stout=0:` cylindrical surface(s)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToHype`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetStIn`](@ref), [`GetStOut`](@ref), [`HasInner`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`RadiusHypeSq`](@ref), [`SafetyToHype`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetHypeDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoHype`](@ref), [`ZHypeSq`](@ref)
""" TGeoHype

# Wrapper of TGeoNavigatorArray
@trydoc raw"""
    ROOT.TGeoNavigatorArray





Related functions: [`AddNavigator`](@ref), [`GetCurrentNavigator`](@ref), [`SetCurrentNavigator`](@ref), [`TGeoNavigatorArray`](@ref)
""" TGeoNavigatorArray

# Wrapper of TGeoRegion
@trydoc raw"""
    ROOT.TGeoRegion

Regions are groups of volumes having a common set of user tracking cuts.

Class wrapper for regions used by Monte Carlo packages A region is composed by a list of logical volumes and defines a set of cuts. Used mainly to transport region information stored in GDML format to the clients requiring it from the transient geometry.

Related functions: [`AddCut`](@ref), [`AddVolume`](@ref), [`GetCut`](@ref), [`GetNcuts`](@ref), [`GetNvolumes`](@ref), [`GetVolume`](@ref), [`Print`](@ref), [`TGeoRegion`](@ref), [`assign`](@ref)
""" TGeoRegion

# Wrapper of TVirtualGeoTrack
@trydoc raw"""
    ROOT.TVirtualGeoTrack

Base class for user-defined tracks attached to a geometry.

Tracks are 3D objects made of points and they store a pointer to a [TParticle](@ref). The geometry manager holds a list of all tracks that will be deleted on destruction of gGeoManager.

Related functions: [`AddDaughter`](@ref), [`AddPoint`](@ref), [`FindTrackWithId`](@ref), [`GetDaughterId`](@ref), [`GetDaughter`](@ref), [`GetFirstPoint`](@ref), [`GetId`](@ref), [`GetLastPoint`](@ref), [`GetMotherParticle`](@ref), [`GetMother`](@ref), [`GetName`](@ref), [`GetNdaughters`](@ref), [`GetNpoints`](@ref), [`GetPDG`](@ref), [`GetParentId`](@ref), [`GetParticle`](@ref), [`GetPoint`](@ref), [`HasPoints`](@ref), [`IsInTimeRange`](@ref), [`PaintCollectTrack`](@ref), [`PaintCollect`](@ref), [`PaintTrack`](@ref), [`Paint`](@ref), [`ResetTrack`](@ref), [`SetId`](@ref), [`SetName`](@ref), [`SetPDG`](@ref), [`SetParent`](@ref), [`SetParticle`](@ref), [`TVirtualGeoTrack`](@ref)
""" TVirtualGeoTrack

# Wrapper of TVirtualGeoPainter
@trydoc raw"""
    ROOT.TVirtualGeoPainter

Abstract class for geometry painters.



Related functions: [`AddSize3D`](@ref), [`AddTrackPoint`](@ref), [`AddTrack`](@ref), [`BombTranslation`](@ref), [`CheckBoundaryErrors`](@ref), [`CheckBoundaryReference`](@ref), [`CheckGeometryFull`](@ref), [`CheckGeometry`](@ref), [`CheckOverlaps`](@ref), [`CheckPoint`](@ref), [`CheckShape`](@ref), [`CountVisibleNodes`](@ref), [`DefaultAngles`](@ref), [`DefaultColors`](@ref), [`DistanceToPrimitiveVol`](@ref), [`DrawBatemanSol`](@ref), [`DrawCurrentPoint`](@ref), [`DrawOnly`](@ref), [`DrawOverlap`](@ref), [`DrawPanel`](@ref), [`DrawPath`](@ref), [`DrawPolygon`](@ref), [`DrawShape`](@ref), [`DrawVolume`](@ref), [`EditGeometry`](@ref), [`EstimateCameraMove`](@ref), [`ExecuteManagerEvent`](@ref), [`ExecuteShapeEvent`](@ref), [`ExecuteVolumeEvent`](@ref), [`GetBombFactors`](@ref), [`GetBombMode`](@ref), [`GetColor`](@ref), [`GetDrawPath`](@ref), [`GetDrawnVolume`](@ref), [`GetNsegments`](@ref), [`GetTopVolume`](@ref), [`GetViewAngles`](@ref), [`GetViewBox`](@ref), [`GetVisLevel`](@ref), [`GetVisOption`](@ref), [`GetVolumeInfo`](@ref), [`GrabFocus`](@ref), [`IsExplodedView`](@ref), [`IsPaintingShape`](@ref), [`IsRaytracing`](@ref), [`LegoPlot`](@ref), [`ModifiedPad`](@ref), [`OpProgress`](@ref), [`PaintNode`](@ref), [`PaintOverlap`](@ref), [`PaintShape`](@ref), [`PaintVolume`](@ref), [`Paint`](@ref), [`PrintOverlaps`](@ref), [`RandomPoints`](@ref), [`RandomRays`](@ref), [`Raytrace`](@ref), [`SamplePoints`](@ref), [`SetBombFactors`](@ref), [`SetCheckedNode`](@ref), [`SetClippingShape`](@ref), [`SetExplodedView`](@ref), [`SetGeoManager`](@ref), [`SetIteratorPlugin`](@ref), [`SetNmeshPoints`](@ref), [`SetNsegments`](@ref), [`SetRaytracing`](@ref), [`SetTopVisible`](@ref), [`SetTopVolume`](@ref), [`SetVisLevel`](@ref), [`SetVisOption`](@ref), [`ShapeDistancetoPrimitive`](@ref), [`TVirtualGeoPainter!GeoPainter`](@ref), [`TVirtualGeoPainter!SetPainter`](@ref), [`TVirtualGeoPainter`](@ref), [`TestOverlaps`](@ref), [`TestVoxels`](@ref), [`Test`](@ref), [`UnbombTranslation`](@ref), [`Weight`](@ref)
""" TVirtualGeoPainter

# Wrapper of TGeoPNEntry
@trydoc raw"""
    ROOT.TGeoPNEntry

The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them.

One can however create 'symbolic links' to any complex path to make it more representable for the object it designates:

    TGeoPNEntry *pne = new TGeoPNEntry("TPC_SECTOR_2", "path_to_tpc_sect2");
    pne->SetPhysicalNode(pn)

(C++ version of the code)

Such a symbolic link hides the complexity of the path to the align object and replaces it with a more meaningful name. In addition, [TGeoPNEntry](@ref) objects are faster to search by name and they may optionally store an additional user matrix.

For more details please read the [misalignment section](@ref).

Related functions: [`GetGlobalOrig`](@ref), [`GetMatrixOrig`](@ref), [`GetMatrix`](@ref), [`GetPath`](@ref), [`GetPhysicalNode`](@ref), [`SetMatrix`](@ref), [`SetPhysicalNode`](@ref), [`TGeoPNEntry`](@ref)
""" TGeoPNEntry

# Wrapper of TGeoPhysicalNode
@trydoc raw"""
    ROOT.TGeoPhysicalNode

Physical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.

The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 1e6-1e9, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class [TGeoPhysicalNode](@ref) and can be created on demand for alignment purposes:

    TGeoPhysicalNode *pn = new TGeoPhysicalNode("path_to_object")

(C++ version of the code)

Once created, a physical node can be misaligned, meaning that its position or even shape can be changed:

    pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE)

(C++ version of the code)

Related functions: [`Align`](@ref), [`Draw`](@ref), [`GetLevel`](@ref), [`GetMatrix`](@ref), [`GetMother`](@ref), [`GetNode`](@ref), [`GetOriginalMatrix`](@ref), [`GetShape`](@ref), [`GetVolume`](@ref), [`IsAligned`](@ref), [`IsMatchingState`](@ref), [`IsVisibleFull`](@ref), [`IsVisible`](@ref), [`IsVolAttributes`](@ref), [`Paint`](@ref), [`Print`](@ref), [`Refresh`](@ref), [`SetIsVolAtt`](@ref), [`SetMatrixOrig`](@ref), [`SetVisibility`](@ref), [`SetVisibleFull`](@ref), [`TGeoPhysicalNode`](@ref), [`cd`](@ref)
""" TGeoPhysicalNode

# Wrapper of TGeoOpticalSurface
@trydoc raw"""
    ROOT.TGeoOpticalSurface

This is a wrapper class to G4OpticalSurface.



Related functions: [`AddConstProperty`](@ref), [`AddProperty`](@ref), [`GetConstProperties`](@ref), [`GetConstPropertyRef`](@ref), [`GetConstProperty`](@ref), [`GetFinish`](@ref), [`GetModel`](@ref), [`GetNconstProperties`](@ref), [`GetNproperties`](@ref), [`GetPolish`](@ref), [`GetProperties`](@ref), [`GetPropertyRef`](@ref), [`GetProperty`](@ref), [`GetSigmaAlpha`](@ref), [`GetType`](@ref), [`GetValue`](@ref), [`Print`](@ref), [`SetFinish`](@ref), [`SetModel`](@ref), [`SetPolish`](@ref), [`SetSigmaAlpha`](@ref), [`SetType`](@ref), [`SetValue`](@ref), [`TGeoOpticalSurface!FinishToString`](@ref), [`TGeoOpticalSurface!ModelToString`](@ref), [`TGeoOpticalSurface!StringToFinish`](@ref), [`TGeoOpticalSurface!StringToModel`](@ref), [`TGeoOpticalSurface!StringToType`](@ref), [`TGeoOpticalSurface!TypeToString`](@ref), [`TGeoOpticalSurface`](@ref)
""" TGeoOpticalSurface

# Wrapper of TGeoSkinSurface
@trydoc raw"""
    ROOT.TGeoSkinSurface





Related functions: [`GetSurface`](@ref), [`GetVolume`](@ref), [`Print`](@ref), [`TGeoSkinSurface`](@ref)
""" TGeoSkinSurface

# Wrapper of TGeoBorderSurface
@trydoc raw"""
    ROOT.TGeoBorderSurface





Related functions: [`GetNode1`](@ref), [`GetNode2`](@ref), [`GetSurface`](@ref), [`Print`](@ref), [`TGeoBorderSurface`](@ref)
""" TGeoBorderSurface

# Wrapper of TGeoPara
@trydoc raw"""
    ROOT.TGeoPara

Parallelepiped class.

A parallelepiped is a shape having 3 pairs of parallel faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis.

The shape has the center in the origin and it is defined by:

- `dX, dY, dZ:` half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at `-dZ`, while the upper at `+dZ`.
- `alpha:` angle between the segment defined by the centers of the X-parallel edges and Y axis `[-90,90]` in degrees
- `theta:` theta angle of the segment defined by the centers of the Z faces;
- `phi:` phi angle of the same segment

    TGeoPara(dX,dY,dZ,alpha,theta,phi);

(C++ version of the code)

A box is a particular parallelepiped having the parameters: `(dX,dY,dZ,0.,0.,0.)`.

![https://root.cern/doc/v636/pict1_TGeoPara_001.png](https://root.cern/doc/v636/pict1_TGeoPara_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAlpha`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi`](@ref), [`GetTheta`](@ref), [`GetTxy`](@ref), [`GetTxz`](@ref), [`GetTyz`](@ref), [`GetX`](@ref), [`GetY`](@ref), [`GetZ`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`Sizeof3D`](@ref), [`TGeoPara`](@ref)
""" TGeoPara

# Wrapper of TGeoParaboloid
@trydoc raw"""
    ROOT.TGeoParaboloid

A paraboloid is defined by the revolution surface generated by a parabola and is bounded by two planes perpendicular to Z axis.

The parabola equation is taken in the form: `z = ar2 + b`, where: `r2 = x2 + y2`. Note the missing linear term (parabola symmetric with respect to Z axis).

The coefficients a and b are computed from the input values which are the radii of the circular sections cut by the planes at `+/-dz`:

- `-dz = a*r2low + b`
- `dz = a*r2high + b`

    TGeoParaboloid(Double_t rlo,Double_t rhi,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoParaboloid_001.png](https://root.cern/doc/v636/pict1_TGeoParaboloid_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToParaboloid`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetDz`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetRhi`](@ref), [`GetRlo`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetParaboloidDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoParaboloid`](@ref)
""" TGeoParaboloid

# Wrapper of TGeoParallelWorld
@trydoc raw"""
    ROOT.TGeoParallelWorld

Base class for a flat parallel geometry.

The parallel geometry can be composed by both normal volumes added using the AddNode interface (not implemented yet) or by physical nodes which will use as position their actual global_ matrix with respect to the top volume of the main geometry.

All these nodes are added as daughters to the "top" volume of the parallel world which acts as a navigation helper in this parallel world. The parallel world has to be closed before calling any navigation method.

Related functions: [`AddNode`](@ref), [`AddOverlap`](@ref), [`CheckOverlaps`](@ref), [`CloseGeometry`](@ref), [`Draw`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetGeometry`](@ref), [`GetVolume`](@ref), [`IsClosed`](@ref), [`IsUsingOverlaps`](@ref), [`PrintDetectedOverlaps`](@ref), [`RefreshPhysicalNodes`](@ref), [`ResetOverlaps`](@ref), [`Safety`](@ref), [`SetUseOverlaps`](@ref), [`TGeoParallelWorld`](@ref)
""" TGeoParallelWorld

# Wrapper of TGeoPcon
@trydoc raw"""
    ROOT.TGeoPcon

A polycone is represented by a sequence of tubes/cones, glued together at defined Z planes.

The polycone might have a phi segmentation, which globally applies to all the pieces. It has to be defined in two steps:

1. First call the [TGeoPcon](@ref) constructor to define a polycone:

        TGeoPcon(Double_t phi1,Double_t dphi,Int_t nz

    (C++ version of the code)

    - `phi1:` starting phi angle in degrees
    - `dphi:` total phi range
    - `nz:` number of Z planes defining polycone sections (minimum 2)
2. Define one by one all sections [0, nz-1]

    void TGeoPcon!DefineSection(Int_t i,Double_t z,
    Double_t rmin, Double_t rmax);

(C++ version of the code)

- `i:` section index [0, nz-1]
- `z:` z coordinate of the section
- `rmin:` minimum radius corresponding too this section
- `rmax:` maximum radius.

The first section (`i=0`) has to be positioned always the lowest Z coordinate. It defines the radii of the first cone/tube segment at its lower Z. The next section defines the theend-cap of the first segment, but it can represent also the beginning of the next one. Any discontinuity in the radius has to be represented by a section defined at the same Z coordinate as the previous one. The Z coordinates of all sections must be sorted in increasing order. Any radius or Z coordinate of a given plane have corresponding getters:

    Double_t TGeoPcon!GetRmin(Int_t i);
    Double_t TGeoPcon!GetRmax(Int_t i);
    Double_t TGeoPcon!GetZ(Int_t i);

(C++ version of the code)

Note that the last section should be defined last, since it triggers the computation of the bounding box of the polycone.

![https://root.cern/doc/v636/pict1_TGeoPcon_001.png](https://root.cern/doc/v636/pict1_TGeoPcon_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DefineSection`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToSegZ`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`Dphi`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDphi`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNsegments`](@ref), [`GetNz`](@ref), [`GetPhi1`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`GetZ`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Phi1`](@ref), [`Rmax`](@ref), [`Rmin`](@ref), [`SafetyToSegment`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoPcon`](@ref), [`Z`](@ref)
""" TGeoPcon

# Wrapper of TGeoPgon
@trydoc raw"""
    ROOT.TGeoPgon

Polygons are defined in the same way as polycones, the difference being just that the segments between consecutive Z planes are regular polygons.

The phi segmentation is preserved and the shape is defined in a similar manner, just that `rmin` and `rmax` represent the radii of the circles inscribed in the inner/outer polygon.

![https://root.cern/doc/v636/pict1_TGeoPgon_001.png](https://root.cern/doc/v636/pict1_TGeoPgon_001.png)

The constructor of a polygon has the form:

    TGeoPgon(Double_t phi1,Double_t dphi,Int_t nedges,Int_t nz);

(C++ version of the code)

The extra parameter `nedges` represent the number of equal edges of the polygons, between `phi1` and `phi1+dphi.`

Related functions: [`Capacity`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNedges`](@ref), [`GetNmeshVertices`](@ref), [`GetNsegments`](@ref), [`GetPointsOnSegments`](@ref), [`GetThreadData`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`SafetyToSegment`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetNedges`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoPgon`](@ref)
""" TGeoPgon

# Wrapper of TGeoRCPtr
@trydoc raw"""
    ROOT.TGeoRCPtr

A reference counting-managed pointer for classes derived from [TGeoExtension](@ref) which can be used as C pointer.

Based on CodeProject implementation example

### Example:

    class MyExtension : public TGeoExtension {
    public:
       MyExtension() : TGeoExtension(), fRC(0) {printf("Created MyExtension\n");}
       virtual ~MyExtension() {printf("Deleted MyExtension\n");}
       virtual TGeoExtension *Grab() const {fRC++; return (TGeoExtension*)this;}
       virtual void Release() const {assert(fRC > 0); fRC--; if (fRC ==0) delete this;}
       void print() const {printf("MyExtension object %p\n", this);}
    private:
       mutable Int_t        fRC;           // Reference counter
       ClassDefOverride(MyExtension,1)
    };

(C++ version of the code)

### Usage:

    // Module 1 creates an object
    TGeoRCPtr<MyExtension> a2 = new MyExtension(); //fRC=1
    // Module 2 grabs object
    TGeoRCPtr<MyExtension> ptr2 = a2; //fRC=2
    // Module 2 invokes a method
    ptr2->Print();
    (*ptr2).Print();
    // Module 1 no longer needs object
     a2 = 0;      //RC=1
    // Module 2 no longer needs object
     ptr2 = 0;    //object will be destroyed here

(C++ version of the code)

### Note:

Event if one forgets to call ptr2 = 0, the object gets delete when the method using ptr2 gets out of scope.

Related functions: [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`Get`](@ref), [`T*`](@ref), [`TGeoRCPtr`](@ref), [`arrow`](@ref), [`assign`](@ref), [`bool`](@ref)
""" TGeoRCPtr

# Wrapper of TGeoRegionCut
@trydoc raw"""
    ROOT.TGeoRegionCut





Related functions: [`GetCut`](@ref), [`SetCut`](@ref), [`TGeoRegionCut`](@ref)
""" TGeoRegionCut

# Wrapper of TGeoScaledShape
@trydoc raw"""
    ROOT.TGeoScaledShape

A shape scaled by a [TGeoScale](@ref) transformation.

![https://root.cern/doc/v636/geom_scaledshape.png](https://root.cern/doc/v636/geom_scaledshape.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBuffer3D`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetScale`](@ref), [`GetShape`](@ref), [`InspectShape`](@ref), [`IsAssembly`](@ref), [`IsCylType`](@ref), [`IsReflected`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetScale`](@ref), [`SetSegsAndPols`](@ref), [`TGeoScaledShape!MakeScaledShape`](@ref), [`TGeoScaledShape`](@ref)
""" TGeoScaledShape

# Wrapper of TGeoShapeAssembly
@trydoc raw"""
    ROOT.TGeoShapeAssembly

The shape encapsulating an assembly (union) of volumes.

Automatically created by [TGeoVolumeAssembly](@ref) class

Related functions: [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`InspectShape`](@ref), [`IsAssembly`](@ref), [`IsCylType`](@ref), [`NeedsBBoxRecompute`](@ref), [`RecomputeBoxLast`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`TGeoShapeAssembly`](@ref)
""" TGeoShapeAssembly

# Wrapper of TGeoSphere
@trydoc raw"""
    ROOT.TGeoSphere

[TGeoSphere](@ref) are not just balls having internal and external radii, but sectors of a sphere having defined theta and phi ranges.

The [TGeoSphere](@ref) class has the following constructor.

    TGeoSphere(Double_t rmin,Double_t rmax,Double_t theta1,
    Double_t theta2,Double_t phi1, Double_t phi2);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoSphere_001.png](https://root.cern/doc/v636/pict1_TGeoSphere_001.png)

- `rmin:` internal radius of the spherical sector
- `rmax:` external radius
- `theta1:` starting theta value [0, 180) in degrees
- `theta2:` ending theta value (0, 180] in degrees (`theta1<theta2`)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToSphere`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNumberOfDivisions`](@ref), [`GetNz`](@ref), [`GetPhi1`](@ref), [`GetPhi2`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`GetTheta1`](@ref), [`GetTheta2`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`IsOnBoundary`](@ref), [`IsPointInside`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetNumberOfDivisions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetSphDimensions`](@ref), [`Sizeof3D`](@ref), [`TGeoSphere`](@ref)
""" TGeoSphere

# Wrapper of TGeoFacet
@trydoc raw"""
    ROOT.TGeoFacet





Related functions: [`Base.getindex`](@ref), [`Flip`](@ref), [`GetNvert`](@ref), [`IsNeighbour`](@ref), [`TGeoFacet!CompactFacet`](@ref), [`TGeoFacet`](@ref)
""" TGeoFacet

# Wrapper of TGeoTessellated
@trydoc raw"""
    ROOT.TGeoTessellated

[Tessellated](@ref) solid class.

It is composed by a set of planar faces having triangular or quadrilateral shape. The class does not provide navigation functionality, it just wraps the data for the composing faces.

Related functions: [`AddFacet`](@ref), [`AddVertex`](@ref), [`CheckClosure`](@ref), [`CloseShape`](@ref), [`ComputeBBox`](@ref), [`DistancetoPrimitive`](@ref), [`FacetCheck`](@ref), [`FacetComputeNormal`](@ref), [`FlipFacets`](@ref), [`GetBuffer3D`](@ref), [`GetFacet`](@ref), [`GetMeshNumbers`](@ref), [`GetNfacets`](@ref), [`GetNmeshVertices`](@ref), [`GetNsegments`](@ref), [`GetNvertices`](@ref), [`GetVertex`](@ref), [`InspectShape`](@ref), [`IsClosedBody`](@ref), [`IsDefined`](@ref), [`MakeBuffer3D`](@ref), [`Print`](@ref), [`ResizeCenter`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoTessellated!ImportFromObjFormat`](@ref), [`TGeoTessellated`](@ref)
""" TGeoTessellated

# Wrapper of TGeoTorus
@trydoc raw"""
    ROOT.TGeoTorus

The torus is defined by its axial radius, its inner and outer radius.

![https://root.cern/doc/v636/pict1_TGeoTorus_001.png](https://root.cern/doc/v636/pict1_TGeoTorus_001.png)

It may have a `phi`range:

    TGeoTorus(Double_t R,Double_t Rmin,Double_t Rmax,Double_t Phi1,
    Double_t Dphi);

(C++ version of the code)

- `R:` axial radius of the torus
- `Rmin:` inner radius
- `Rmax:` outer radius
- `Phi1:` starting phi angle
- `Dphi:` total phi range

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DDDaxis`](@ref), [`DDaxis`](@ref), [`Daxis`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDphi`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi1`](@ref), [`GetPointsOnSegments`](@ref), [`GetR`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetTorusDimensions`](@ref), [`Sizeof3D`](@ref), [`SolveCubic`](@ref), [`SolveQuartic`](@ref), [`TGeoTorus`](@ref), [`ToBoundary`](@ref)
""" TGeoTorus

# Wrapper of TGeoTrd1
@trydoc raw"""
    ROOT.TGeoTrd1

A trapezoid with only X varying with Z.

It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:

    TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoTrd1_001.png](https://root.cern/doc/v636/pict1_TGeoTrd1_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetDx1`](@ref), [`GetDx2`](@ref), [`GetDy`](@ref), [`GetDz`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetOppositeCorner`](@ref), [`GetVisibleCorner`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetVertex`](@ref), [`Sizeof3D`](@ref), [`TGeoTrd1`](@ref)
""" TGeoTrd1

# Wrapper of TGeoTrd2
@trydoc raw"""
    ROOT.TGeoTrd2

A trapezoid with only X varying with Z.

It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:

![https://root.cern/doc/v636/pict1_TGeoTrd2_001.png](https://root.cern/doc/v636/pict1_TGeoTrd2_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetDx1`](@ref), [`GetDx2`](@ref), [`GetDy1`](@ref), [`GetDy2`](@ref), [`GetDz`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetOppositeCorner`](@ref), [`GetVisibleCorner`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetVertex`](@ref), [`Sizeof3D`](@ref), [`TGeoTrd2`](@ref)
""" TGeoTrd2

# Wrapper of TGeoXtru
@trydoc raw"""
    ROOT.TGeoXtru

A [TGeoXtru](@ref) shape is represented by the extrusion of an arbitrary polygon with fixed outline between several Z sections.

Each Z section is a scaled version of the same "blueprint" polygon. Different global_ XY translations are allowed from section to section. Corresponding polygon vertices from consecutive sections are connected.

An extruded polygon can be created using the constructor:

    TGeoXtru!TGeoXtru(Int_t nplanes);

(C++ version of the code)

- `nplanes:`number of Z sections (minimum 2)

![https://root.cern/doc/v636/pict1_TGeoXtru_001.png](https://root.cern/doc/v636/pict1_TGeoXtru_001.png)

The lists of X and Y positions for all vertices have to be provided for the "blueprint" polygon:

    TGeoXtru!DefinePolygon (Int_t nvertices, Double_t *xv,
    Double_t *yv);

(C++ version of the code)

- `nvertices:`number of vertices of the polygon
- `xv,yv:`arrays of X and Y coordinates for polygon vertices

The method creates an object of the class **`TGeoPolygon`** for which the convexity is automatically determined . The polygon is decomposed into convex polygons if needed.

Next step is to define the Z positions for each section plane as well as the XY offset and scaling for the corresponding polygons.

    TGeoXtru!DefineSection(Int_t snum,Double_t zsection,Double_t x0,
    Double_t y0, Double_t scale);

(C++ version of the code)

- `snum:`Z section index (0, nplanes-1). The section with `snum = nplanes-1` must be defined last and triggers the computation of the bounding box for the whole shape
- `zsection:`Z position of section `snum`. Sections must be defined in increasing order of Z (e.g. `snum=0` correspond to the minimum Z and `snum=nplanes-1` to the maximum one).
- `x0,y0:`offset of section `snum` with respect to the local_ shape reference frame `T`
- `scale:`factor that multiplies the X/Y coordinates of each vertex of the polygon at section `snum`:
- `x[ivert] = x0 + scale*xv[ivert]`
- `y[ivert] = y0 + scale*yv[ivert]`

Related functions: [`Capacity`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DefinePolygon`](@ref), [`DefineSection`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`DrawPolygon`](@ref), [`GetBuffer3D`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNvert`](@ref), [`GetNz`](@ref), [`GetScale`](@ref), [`GetThreadData`](@ref), [`GetXOffset`](@ref), [`GetX`](@ref), [`GetYOffset`](@ref), [`GetY`](@ref), [`GetZ`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetCurrentVertices`](@ref), [`SetCurrentZ`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoXtru`](@ref), [`Z`](@ref)
""" TGeoXtru
#
######################################################################

######################################################################
# Documentation of ROOT methods

# Wrapper of void TNamed::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TNamed}, option::ByCopy{String})::Nothing
Set name and title to empty strings ("").

""" Clear(this::ByRef1{TNamed}, option::ByCopy{String})

# Wrapper of void TNamed::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TNamed}, buffer::ByPtr2{Int8})::Nothing
Encode [TNamed](@ref) into output buffer.

""" FillBuffer(this::ByRef1{TNamed}, buffer::ByPtr2{Int8})

# Wrapper of TNamed & TNamed::operator=(const TNamed &)
@trydoc raw"""
    assign(this::ByRef1{TNamed}, rhs::ByConstRef1{TNamed})::CxxRef1{TNamed}
[TNamed](@ref) assignment operator.

""" assign(this::ByRef1{TNamed}, rhs::ByConstRef1{TNamed})

# Wrapper of void TNamed::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TNamed}, name::ByCopy{String})::Nothing
Set the name of the [TNamed](@ref).
WARNING: if the object is a member of a [THashTable](@ref) or [THashList](@ref) container the container must be Rehash()'ed after [SetName()](@ref). For example the list of objects in the current directory is a [THashList](@ref).
""" SetName(this::ByRef1{TNamed}, name::ByCopy{String})

# Wrapper of void TNamed::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TNamed}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Set all the [TNamed](@ref) parameters (name and title).
WARNING: if the name is changed and the object is a member of a [THashTable](@ref) or [THashList](@ref) container the container must be Rehash()'ed after [SetName()](@ref). For example the list of objects in the current directory is a [THashList](@ref).
""" SetNameTitle(this::ByRef1{TNamed}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TNamed::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TNamed}, title::ByCopy{String})::Nothing
Set the title of the [TNamed](@ref).

""" SetTitle(this::ByRef1{TNamed}, title::ByCopy{String})

# Wrapper of void TNamed::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TNamed}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TNamed}, ::ByRef1{TBuffer})

# Wrapper of void TNamed::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TNamed}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TNamed}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TObject::AppendPad(Option_t *)
@trydoc raw"""
    AppendPad(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Append graphics object to current pad.
In case no current pad is set yet, create a default canvas with the name "c1".
""" AppendPad(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TObject}, b::ByPtr1{TBrowser})::Nothing
Browse object. May be overridden for another default action.

""" Browse(this::ByRef1{TObject}, b::ByPtr1{TBrowser})

# Wrapper of ULong_t TObject::CheckedHash()
@trydoc raw"""
    CheckedHash(this::ByRef1{TObject})::UInt64
Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object.
The intent is for this routine to be called instead of directly calling the function Hash during "insert" operations. See TObject!HasInconsistenTObjectHash();

(*) The setup is consistent when all classes in the class hierarchy that overload [TObject!Hash](@ref) do call [ROOT!CallRecursiveRemoveIfNeeded](@ref) in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.
""" CheckedHash(this::ByRef1{TObject})

# Wrapper of void TObject::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TObject}, ::ByCopy{String})::Nothing


""" Clear(this::ByRef1{TObject}, ::ByCopy{String})

# Wrapper of void TObject::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of Int_t TObject::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TObject}, px::Int32, py::Int32)::Int32
Computes distance from point (px,py) to the object.
This member function must be implemented for each graphics primitive. This default function returns a big number (999999).
""" DistancetoPrimitive(this::ByRef1{TObject}, px::Int32, py::Int32)

# Wrapper of void TObject::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::Execute(const char *, const char *, Int_t *)
@trydoc raw"""
    Execute(this::ByRef1{TObject}, method::ByCopy{String}, params::ByCopy{String}, error::ByPtr2{Int32})::Nothing
Execute method on this object with the given parameter string, e.g.
"3.14,1,\"text\"".
""" Execute(this::ByRef1{TObject}, method::ByCopy{String}, params::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of void TObject::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TObject}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to an event at (px,py).
This method must be overridden if an object can react to graphics events.
""" ExecuteEvent(this::ByRef1{TObject}, event::Int32, px::Int32, py::Int32)

# Wrapper of Bool_t TObject::HandleTimer(TTimer *)
@trydoc raw"""
    HandleTimer(this::ByRef1{TObject}, timer::ByPtr1{TTimer})::Bool
Execute action in response of a timer timing out.
This method must be overridden if an object has to react to timers.
""" HandleTimer(this::ByRef1{TObject}, timer::ByPtr1{TTimer})

# Wrapper of void TObject::InvertBit(UInt_t)
@trydoc raw"""
    InvertBit(this::ByRef1{TObject}, f::UInt32)::Nothing


""" InvertBit(this::ByRef1{TObject}, f::UInt32)

# Wrapper of Bool_t TObject::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TObject})::Bool
This method must be overridden to handle object notification (the base implementation is no-op).
Different objects in [ROOT](@ref) use the `Notify` method for different purposes, in coordination with other objects that call this method at the appropriate time.

For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a callback mechanism to inform interested parties when it switches to a new sub-tree.
""" Notify(this::ByRef1{TObject})

# Wrapper of TObject & TObject::operator=(const TObject &)
@trydoc raw"""
    assign(this::ByRef1{TObject}, rhs::ByConstRef1{TObject})::CxxRef1{TObject}
[TObject](@ref) assignment operator.

""" assign(this::ByRef1{TObject}, rhs::ByConstRef1{TObject})

# Wrapper of void TObject::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::Pop()
@trydoc raw"""
    Pop(this::ByRef1{TObject})::Nothing
Pop on object drawn in a pad to the top of the display list.
I.e. it will be drawn last and on top of all other primitives.
""" Pop(this::ByRef1{TObject})

# Wrapper of Int_t TObject::Read(const char *)
@trydoc raw"""
    Read(this::ByRef1{TObject}, name::ByCopy{String})::Int32
Read contents of object with specified name from the current directory.
First the key with the given name is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See [TObject!Write()](@ref).
""" Read(this::ByRef1{TObject}, name::ByCopy{String})

# Wrapper of void TObject::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TObject}, obj::ByPtr1{TObject})::Nothing
Recursively remove this object from a list.
Typically implemented by classes that can contain multiple references to a same object.
""" RecursiveRemove(this::ByRef1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TObject::ResetBit(UInt_t)
@trydoc raw"""
    ResetBit(this::ByRef1{TObject}, f::UInt32)::Nothing


""" ResetBit(this::ByRef1{TObject}, f::UInt32)

# Wrapper of void TObject::SetBit(UInt_t)
@trydoc raw"""
    SetBit(this::ByRef1{TObject}, f::UInt32)::Nothing


""" SetBit(this::ByRef1{TObject}, f::UInt32)

# Wrapper of void TObject::SetBit(UInt_t, Bool_t)
@trydoc raw"""
    SetBit(this::ByRef1{TObject}, f::UInt32, set::Bool)::Nothing
Set or unset the user status bits as specified in f.

""" SetBit(this::ByRef1{TObject}, f::UInt32, set::Bool)

# Wrapper of void TObject::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::SetUniqueID(UInt_t)
@trydoc raw"""
    SetUniqueID(this::ByRef1{TObject}, uid::UInt32)::Nothing
Set the unique object id.

""" SetUniqueID(this::ByRef1{TObject}, uid::UInt32)

# Wrapper of void TObject::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TObject}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TObject}, ::ByRef1{TBuffer})

# Wrapper of void TObject::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TObject::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TObject})::Nothing
Set current style settings in this object This function is called when either [TCanvas!UseCurrentStyle](@ref) or [TROOT!ForceStyle](@ref) have been invoked.

""" UseCurrentStyle(this::ByRef1{TObject})

# Wrapper of Int_t TObject::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByConstRef1{TObject}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write this object to the current directory.
The data structure corresponding to this object is serialized. The corresponding buffer is written to the current directory with an associated key with name "name".

Writing an object to a file involves the following steps:

- Creation of a support [TKey](@ref) object in the current directory. The [TKey](@ref) object creates a [TBuffer](@ref) object.
- The [TBuffer](@ref) object is filled via the class!Streamer function.
- If the file is compressed (default) a second buffer is created to hold the compressed buffer.
- Reservation of the corresponding space in the file by looking in the [TFree](@ref) list of free blocks of the file.
- The buffer is written to the file.

Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.

If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by [GetName()](@ref).

The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a [TFile](@ref) the space is simply freed up to be overwritten; in the case of a [TTree](@ref), it is more complicated. If one opens a [TTree](@ref), appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new [TTree](@ref) and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. [TTree!Delete()](@ref) can be used to mark all disk space occupied by a [TTree](@ref) as free before overwriting its metadata this way. The kSingleKey option is only used by [TCollection!Write()](@ref) to write a container with a single key instead of each object in the container with its own key.

An object is read from the file into memory via [TKey!Read()](@ref) or via [TObject!Read()](@ref).

The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written.
""" Write(this::ByConstRef1{TObject}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of void TBrowser::Add(TObject *, const char *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, name::ByCopy{String}, check::Int32)::Nothing
Add object with name to browser.
If name not set the objects [GetName()](@ref) is used. If check < 0 (default) no check box is drawn, if 0 then unchecked checkbox is added, if 1 checked checkbox is added.
""" Add(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, name::ByCopy{String}, check::Int32)

# Wrapper of void TBrowser::Add(void *, TClass *, const char *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBrowser}, obj::ByPtr2{Nothing}, cl::ByPtr1{TClass}, name::ByCopy{String}, check::Int32)::Nothing
Add foreign object with name to browser.
'cl' is the type use to store the value of obj. So literally the following pseudo code should be correct: 

    `cl->GetName()` * ptr = (`cl->GetName()`*) obj;

(C++ version of the code)

 and the value of obj is not necessarily the thestart of the object. If check < 0 (default) no check box is drawn, if 0 then unchecked checkbox is added, if 1 checked checkbox is added.
""" Add(this::ByRef1{TBrowser}, obj::ByPtr2{Nothing}, cl::ByPtr1{TClass}, name::ByCopy{String}, check::Int32)

# Wrapper of void TBrowser::AddCheckBox(TObject *, Bool_t)
@trydoc raw"""
    AddCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)::Nothing
Add checkbox for this item.

""" AddCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)

# Wrapper of void TBrowser::BrowseObject(TObject *)
@trydoc raw"""
    BrowseObject(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing


""" BrowseObject(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::CheckObjectItem(TObject *, Bool_t)
@trydoc raw"""
    CheckObjectItem(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)::Nothing
Change status of checkbox for this item.

""" CheckObjectItem(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)

# Wrapper of void TBrowser::Create(TObject *)
@trydoc raw"""
    Create(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Create the browser, called by the ctors.

""" Create(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::Destructor()
@trydoc raw"""
    Destructor(this::ByRef1{TBrowser})::Nothing
Actual browser destructor.

""" Destructor(this::ByRef1{TBrowser})

# Wrapper of Longptr_t TBrowser::ExecPlugin(const char *, const char *, const char *, Int_t, Int_t)
@trydoc raw"""
    ExecPlugin(this::ByRef1{TBrowser}, name::ByCopy{String}, fname::ByCopy{String}, cmd::ByCopy{String}, pos::Int32, subpos::Int32)::Int64


""" ExecPlugin(this::ByRef1{TBrowser}, name::ByCopy{String}, fname::ByCopy{String}, cmd::ByCopy{String}, pos::Int32, subpos::Int32)

# Wrapper of void TBrowser::ExecuteDefaultAction(TObject *)
@trydoc raw"""
    ExecuteDefaultAction(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Execute default action for selected object (action is specified in the `$HOME/.root.mimes` or `$ROOTSYS/etc/root.mimes file`).

""" ExecuteDefaultAction(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::Iconify()
@trydoc raw"""
    Iconify(this::ByRef1{TBrowser})::Nothing


""" Iconify(this::ByRef1{TBrowser})

# Wrapper of void TBrowser::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Recursively remove obj from browser.

""" RecursiveRemove(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TBrowser})::Nothing
Refresh browser contents.

""" Refresh(this::ByRef1{TBrowser})

# Wrapper of void TBrowser::RemoveCheckBox(TObject *)
@trydoc raw"""
    RemoveCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Remove checkbox for this item.

""" RemoveCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::SetBrowserImp(TBrowserImp *)
@trydoc raw"""
    SetBrowserImp(this::ByRef1{TBrowser}, i::ByPtr1{TBrowserImp})::Nothing


""" SetBrowserImp(this::ByRef1{TBrowser}, i::ByPtr1{TBrowserImp})

# Wrapper of void TBrowser::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TBrowser}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TBrowser}, option::ByCopy{String})

# Wrapper of void TBrowser::SetRefreshFlag(Bool_t)
@trydoc raw"""
    SetRefreshFlag(this::ByRef1{TBrowser}, flag::Bool)::Nothing


""" SetRefreshFlag(this::ByRef1{TBrowser}, flag::Bool)

# Wrapper of void TBrowser::SetSelected(TObject *)
@trydoc raw"""
    SetSelected(this::ByRef1{TBrowser}, clickedObject::ByPtr1{TObject})::Nothing
Assign the last selected object.

""" SetSelected(this::ByRef1{TBrowser}, clickedObject::ByPtr1{TObject})

# Wrapper of void TBrowser::SetStatusText(const char *, Int_t)
@trydoc raw"""
    SetStatusText(this::ByRef1{TBrowser}, txt::ByCopy{String}, col::Int32)::Nothing


""" SetStatusText(this::ByRef1{TBrowser}, txt::ByCopy{String}, col::Int32)

# Wrapper of void TBrowser::Show()
@trydoc raw"""
    Show(this::ByRef1{TBrowser})::Nothing


""" Show(this::ByRef1{TBrowser})

# Wrapper of void TBrowser::StartEmbedding(Int_t, Int_t)
@trydoc raw"""
    StartEmbedding(this::ByRef1{TBrowser}, pos::Int32, subpos::Int32)::Nothing


""" StartEmbedding(this::ByRef1{TBrowser}, pos::Int32, subpos::Int32)

# Wrapper of void TBrowser::StopEmbedding(const char *)
@trydoc raw"""
    StopEmbedding(this::ByRef1{TBrowser}, name::ByCopy{String})::Nothing


""" StopEmbedding(this::ByRef1{TBrowser}, name::ByCopy{String})

# Wrapper of void TObjArray::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TObjArray}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object in the slot after object after.
If after=0 add object in the last empty slot. Note that this will overwrite any object that might have already been in this slot. For insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddAfter(this::ByRef1{TObjArray}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position ids.
Give an error when idx is out of bounds (i.e. the array is not expanded).
""" AddAt(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TObjArray::AddAtAndExpand(TObject *, Int_t)
@trydoc raw"""
    AddAtAndExpand(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position idx.
If idx is larger than the current size of the array, expand the array (double its size).
""" AddAtAndExpand(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of Int_t TObjArray::AddAtFree(TObject *)
@trydoc raw"""
    AddAtFree(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Int32
Return the position of the new object.
Find the first empty cell or AddLast if there is no empty cell
""" AddAtFree(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TObjArray}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object in the slot before object before.
If before=0 add object in the first slot. Note that this will overwrite any object that might have already been in this slot. For insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddBefore(this::ByRef1{TObjArray}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing
Add object in the first slot of the array.
This will overwrite the first element that might have been there. To have insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddFirst(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing
Add object in the next empty slot in the array.
Expand the array if necessary.
""" AddLast(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of Int_t TObjArray::BinarySearch(TObject *, Int_t)
@trydoc raw"""
    BinarySearch(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, upto::Int32)::Int32
Find object using a binary search.
Array must first have been sorted. Search can be limited by setting upto to desired index.
""" BinarySearch(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, upto::Int32)

# Wrapper of void TObjArray::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TObjArray}, option::ByCopy{String})::Nothing
Remove all objects from the array.
Does not delete the objects unless the [TObjArray](@ref) is the owner (set via [SetOwner()](@ref)).
""" Clear(this::ByRef1{TObjArray}, option::ByCopy{String})

# Wrapper of void TObjArray::Compress()
@trydoc raw"""
    Compress(this::ByRef1{TObjArray})::Nothing
Remove empty slots from array.

""" Compress(this::ByRef1{TObjArray})

# Wrapper of void TObjArray::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TObjArray}, option::ByCopy{String})::Nothing
Remove all objects from the array AND delete all heap based objects.

""" Delete(this::ByRef1{TObjArray}, option::ByCopy{String})

# Wrapper of void TObjArray::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TObjArray}, newSize::Int32)::Nothing
Expand or shrink the array to newSize elements.

""" Expand(this::ByRef1{TObjArray}, newSize::Int32)

# Wrapper of TObjArray & TObjArray::operator=(const TObjArray &)
@trydoc raw"""
    assign(this::ByRef1{TObjArray}, ::ByConstRef1{TObjArray})::CxxRef1{TObjArray}
Assignment operator. Note, unsets the kIsOwner flag.

""" assign(this::ByRef1{TObjArray}, ::ByConstRef1{TObjArray})

# Wrapper of void TObjArray::Randomize(Int_t)
@trydoc raw"""
    Randomize(this::ByRef1{TObjArray}, ntimes::Int32)::Nothing
Randomize objects inside the array, i.e.
permute randomly objects. With fLast being the index of the last entry in the array, the following algorithm is applied to the array:

- for each entry j between 0 and fLast, another entry k is chosen randomly between 0 and fLast.
- the objects at j and k are swapped.
- this process is repeated ntimes (ntimes = 1 by default).
""" Randomize(this::ByRef1{TObjArray}, ntimes::Int32)

# Wrapper of void TObjArray::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing
Remove object from this collection and recursively remove the object from all other objects (and collections).

""" RecursiveRemove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TObjArray::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from array.

""" Remove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TObjArray::RemoveAt(Int_t)
@trydoc raw"""
    RemoveAt(this::ByRef1{TObjArray}, idx::Int32)::CxxPtr1{TObject}
Remove object at index idx.

""" RemoveAt(this::ByRef1{TObjArray}, idx::Int32)

# Wrapper of void TObjArray::RemoveRange(Int_t, Int_t)
@trydoc raw"""
    RemoveRange(this::ByRef1{TObjArray}, idx1::Int32, idx2::Int32)::Nothing
Remove objects from index idx1 to idx2 included.

""" RemoveRange(this::ByRef1{TObjArray}, idx1::Int32, idx2::Int32)

# Wrapper of void TObjArray::SetLast(Int_t)
@trydoc raw"""
    SetLast(this::ByRef1{TObjArray}, last::Int32)::Nothing
Set index of last object in array, effectively truncating the array.
Use carefully since whenever last position has to be recalculated, e.g. after a [Remove()](@ref) or [Sort()](@ref) it will be reset to the last non-empty slot. If last is -2 this will force the recalculation of the last used slot. If last is -1, this effectively truncate the array completely.
""" SetLast(this::ByRef1{TObjArray}, last::Int32)

# Wrapper of void TObjArray::Sort(Int_t)
@trydoc raw"""
    Sort(this::ByRef1{TObjArray}, upto::Int32)::Nothing
If objects in array are sortable (i.e.
[IsSortable()](@ref) returns true for all objects) then sort array.
""" Sort(this::ByRef1{TObjArray}, upto::Int32)

# Wrapper of void TBuffer::AutoExpand(Int_t)
@trydoc raw"""
    AutoExpand(this::ByRef1{TBuffer}, size_needed::Int32)::Nothing
Automatically calculate a new size and expand the buffer to fit at least size_needed.
The goals is to minimize the number of memory allocation and the memory allocation which avoiding too much memory wastage.

If the size_needed is larger than the current size, the policy is to expand to double the current size or the size_needed which ever is largest.
""" AutoExpand(this::ByRef1{TBuffer}, size_needed::Int32)

# Wrapper of Bool_t TBuffer::ByteSwapBuffer(Long64_t, EDataType)
@trydoc raw"""
    ByteSwapBuffer(this::ByRef1{TBuffer}, n::Int64, type::ByCopy{EDataType})::Bool
Byte-swap N primitive-elements in the buffer.
Bulk API relies on this function.
""" ByteSwapBuffer(this::ByRef1{TBuffer}, n::Int64, type::ByCopy{EDataType})

# Wrapper of Int_t TBuffer::CheckByteCount(UInt_t, UInt_t, const char *)
@trydoc raw"""
    CheckByteCount(this::ByRef1{TBuffer}, startpos::UInt32, bcnt::UInt32, classname::ByCopy{String})::Int32


""" CheckByteCount(this::ByRef1{TBuffer}, startpos::UInt32, bcnt::UInt32, classname::ByCopy{String})

# Wrapper of Int_t TBuffer::CheckByteCount(UInt_t, UInt_t, const TClass *)
@trydoc raw"""
    CheckByteCount(this::ByRef1{TBuffer}, startpos::UInt32, bcnt::UInt32, clss::ByConstPtr1{TClass})::Int32


""" CheckByteCount(this::ByRef1{TBuffer}, startpos::UInt32, bcnt::UInt32, clss::ByConstPtr1{TClass})

# Wrapper of Bool_t TBuffer::CheckObject(const TObject *)
@trydoc raw"""
    CheckObject(this::ByRef1{TBuffer}, obj::ByConstPtr1{TObject})::Bool


""" CheckObject(this::ByRef1{TBuffer}, obj::ByConstPtr1{TObject})

# Wrapper of Bool_t TBuffer::CheckObject(const void *, const TClass *)
@trydoc raw"""
    CheckObject(this::ByRef1{TBuffer}, obj::ByConstPtr2{Nothing}, ptrClass::ByConstPtr1{TClass})::Bool


""" CheckObject(this::ByRef1{TBuffer}, obj::ByConstPtr2{Nothing}, ptrClass::ByConstPtr1{TClass})

# Wrapper of void TBuffer::ClassBegin(const TClass *, Version_t)
@trydoc raw"""
    ClassBegin(this::ByRef1{TBuffer}, ::ByConstPtr1{TClass}, ::Int16)::Nothing


""" ClassBegin(this::ByRef1{TBuffer}, ::ByConstPtr1{TClass}, ::Int16)

# Wrapper of void TBuffer::ClassEnd(const TClass *)
@trydoc raw"""
    ClassEnd(this::ByRef1{TBuffer}, ::ByConstPtr1{TClass})::Nothing


""" ClassEnd(this::ByRef1{TBuffer}, ::ByConstPtr1{TClass})

# Wrapper of void TBuffer::ClassMember(const char *, const char *, Int_t, Int_t)
@trydoc raw"""
    ClassMember(this::ByRef1{TBuffer}, ::ByCopy{String}, ::ByCopy{String}, ::Int32, ::Int32)::Nothing


""" ClassMember(this::ByRef1{TBuffer}, ::ByCopy{String}, ::ByCopy{String}, ::Int32, ::Int32)

# Wrapper of void TBuffer::DecrementLevel(TVirtualStreamerInfo *)
@trydoc raw"""
    DecrementLevel(this::ByRef1{TBuffer}, ::ByPtr1{TVirtualStreamerInfo})::Nothing


""" DecrementLevel(this::ByRef1{TBuffer}, ::ByPtr1{TVirtualStreamerInfo})

# Wrapper of void TBuffer::DetachBuffer()
@trydoc raw"""
    DetachBuffer(this::ByRef1{TBuffer})::Nothing


""" DetachBuffer(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::Expand(Int_t, Bool_t)
@trydoc raw"""
    Expand(this::ByRef1{TBuffer}, newsize::Int32, copy::Bool)::Nothing
Expand (or shrink) the I/O buffer to newsize bytes.
If copy is true (the default), the existing content of the buffer is preserved, otherwise the buffer is returned zero-ed out.

In order to avoid losing data, if the current length is greater than the requested size, we only shrink down to the current length.
""" Expand(this::ByRef1{TBuffer}, newsize::Int32, copy::Bool)

# Wrapper of void TBuffer::ForceWriteInfo(TVirtualStreamerInfo *, Bool_t)
@trydoc raw"""
    ForceWriteInfo(this::ByRef1{TBuffer}, info::ByPtr1{TVirtualStreamerInfo}, force::Bool)::Nothing


""" ForceWriteInfo(this::ByRef1{TBuffer}, info::ByPtr1{TVirtualStreamerInfo}, force::Bool)

# Wrapper of void TBuffer::ForceWriteInfoClones(TClonesArray *)
@trydoc raw"""
    ForceWriteInfoClones(this::ByRef1{TBuffer}, a::ByPtr1{TClonesArray})::Nothing


""" ForceWriteInfoClones(this::ByRef1{TBuffer}, a::ByPtr1{TClonesArray})

# Wrapper of TVirtualStreamerInfo * TBuffer::GetInfo()
@trydoc raw"""
    GetInfo(this::ByRef1{TBuffer})::CxxPtr1{TVirtualStreamerInfo}


""" GetInfo(this::ByRef1{TBuffer})

# Wrapper of UInt_t TBuffer::GetTRefExecId()
@trydoc raw"""
    GetTRefExecId(this::ByRef1{TBuffer})::UInt32


""" GetTRefExecId(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::IncrementLevel(TVirtualStreamerInfo *)
@trydoc raw"""
    IncrementLevel(this::ByRef1{TBuffer}, info::ByPtr1{TVirtualStreamerInfo})::Nothing


""" IncrementLevel(this::ByRef1{TBuffer}, info::ByPtr1{TVirtualStreamerInfo})

# Wrapper of void TBuffer::InitMap()
@trydoc raw"""
    InitMap(this::ByRef1{TBuffer})::Nothing


""" InitMap(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::MapObject(const TObject *, UInt_t)
@trydoc raw"""
    MapObject(this::ByRef1{TBuffer}, obj::ByConstPtr1{TObject}, offset::UInt32)::Nothing


""" MapObject(this::ByRef1{TBuffer}, obj::ByConstPtr1{TObject}, offset::UInt32)

# Wrapper of void TBuffer::MapObject(const void *, const TClass *, UInt_t)
@trydoc raw"""
    MapObject(this::ByRef1{TBuffer}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, offset::UInt32)::Nothing


""" MapObject(this::ByRef1{TBuffer}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, offset::UInt32)

# Wrapper of TVirtualArray * TBuffer::PopDataCache()
@trydoc raw"""
    PopDataCache(this::ByRef1{TBuffer})::CxxPtr1{TVirtualArray}
Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members.

""" PopDataCache(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::PushDataCache(TVirtualArray *)
@trydoc raw"""
    PushDataCache(this::ByRef1{TBuffer}, ::ByPtr1{TVirtualArray})::Nothing
Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members.

""" PushDataCache(this::ByRef1{TBuffer}, ::ByPtr1{TVirtualArray})

# Wrapper of Int_t TBuffer::ReadArray(Bool_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, b::ByPtr2{Bool})::Int32


""" ReadArray(this::ByRef1{TBuffer}, b::ByPtr2{Bool})

# Wrapper of Int_t TBuffer::ReadArray(Char_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, c::ByPtr2{Int8})::Int32


""" ReadArray(this::ByRef1{TBuffer}, c::ByPtr2{Int8})

# Wrapper of Int_t TBuffer::ReadArray(Double_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, d::ByPtr2{Float64})::Int32


""" ReadArray(this::ByRef1{TBuffer}, d::ByPtr2{Float64})

# Wrapper of Int_t TBuffer::ReadArray(Float_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, f::ByPtr2{Float32})::Int32


""" ReadArray(this::ByRef1{TBuffer}, f::ByPtr2{Float32})

# Wrapper of Int_t TBuffer::ReadArray(Int_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, i::ByPtr2{Int32})::Int32


""" ReadArray(this::ByRef1{TBuffer}, i::ByPtr2{Int32})

# Wrapper of Int_t TBuffer::ReadArray(Long_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, l::ByPtr2{Int64})::Int32


""" ReadArray(this::ByRef1{TBuffer}, l::ByPtr2{Int64})

# Wrapper of Int_t TBuffer::ReadArray(Short_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, h::ByPtr2{Int16})::Int32


""" ReadArray(this::ByRef1{TBuffer}, h::ByPtr2{Int16})

# Wrapper of Int_t TBuffer::ReadArray(UChar_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, c::ByPtr2{UInt8})::Int32


""" ReadArray(this::ByRef1{TBuffer}, c::ByPtr2{UInt8})

# Wrapper of Int_t TBuffer::ReadArray(UInt_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, i::ByPtr2{UInt32})::Int32


""" ReadArray(this::ByRef1{TBuffer}, i::ByPtr2{UInt32})

# Wrapper of Int_t TBuffer::ReadArray(ULong_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, l::ByPtr2{UInt64})::Int32


""" ReadArray(this::ByRef1{TBuffer}, l::ByPtr2{UInt64})

# Wrapper of Int_t TBuffer::ReadArray(UShort_t *&)
@trydoc raw"""
    ReadArray(this::ByRef1{TBuffer}, h::ByPtr2{UInt16})::Int32


""" ReadArray(this::ByRef1{TBuffer}, h::ByPtr2{UInt16})

# Wrapper of void TBuffer::ReadBool(Bool_t &)
@trydoc raw"""
    ReadBool(this::ByRef1{TBuffer}, b::ByRef2{Bool})::Nothing


""" ReadBool(this::ByRef1{TBuffer}, b::ByRef2{Bool})

# Wrapper of Int_t TBuffer::ReadBuf(void *, Int_t)
@trydoc raw"""
    ReadBuf(this::ByRef1{TBuffer}, buf::ByPtr2{Nothing}, max::Int32)::Int32


""" ReadBuf(this::ByRef1{TBuffer}, buf::ByPtr2{Nothing}, max::Int32)

# Wrapper of void TBuffer::ReadChar(Char_t &)
@trydoc raw"""
    ReadChar(this::ByRef1{TBuffer}, c::ByRef2{Int8})::Nothing


""" ReadChar(this::ByRef1{TBuffer}, c::ByRef2{Int8})

# Wrapper of void TBuffer::ReadCharP(Char_t *)
@trydoc raw"""
    ReadCharP(this::ByRef1{TBuffer}, c::ByPtr2{Int8})::Nothing


""" ReadCharP(this::ByRef1{TBuffer}, c::ByPtr2{Int8})

# Wrapper of void TBuffer::ReadCharStar(char *&)
@trydoc raw"""
    ReadCharStar(this::ByRef1{TBuffer}, s::ByPtr2{Int8})::Nothing


""" ReadCharStar(this::ByRef1{TBuffer}, s::ByPtr2{Int8})

# Wrapper of TClass * TBuffer::ReadClass(const TClass *, UInt_t *)
@trydoc raw"""
    ReadClass(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, objTag::ByPtr2{UInt32})::CxxPtr1{TClass}


""" ReadClass(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, objTag::ByPtr2{UInt32})

# Wrapper of Int_t TBuffer::ReadClassBuffer(const TClass *, void *, const TClass *)
@trydoc raw"""
    ReadClassBuffer(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, pointer::ByPtr2{Nothing}, onfile_class::ByConstPtr1{TClass})::Int32


""" ReadClassBuffer(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, pointer::ByPtr2{Nothing}, onfile_class::ByConstPtr1{TClass})

# Wrapper of Int_t TBuffer::ReadClassBuffer(const TClass *, void *, Int_t, UInt_t, UInt_t, const TClass *)
@trydoc raw"""
    ReadClassBuffer(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, pointer::ByPtr2{Nothing}, version::Int32, thestart::UInt32, count::UInt32, onfile_class::ByConstPtr1{TClass})::Int32


""" ReadClassBuffer(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, pointer::ByPtr2{Nothing}, version::Int32, thestart::UInt32, count::UInt32, onfile_class::ByConstPtr1{TClass})

# Wrapper of Int_t TBuffer::ReadClassEmulated(const TClass *, void *, const TClass *)
@trydoc raw"""
    ReadClassEmulated(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, object::ByPtr2{Nothing}, onfile_class::ByConstPtr1{TClass})::Int32


""" ReadClassEmulated(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, object::ByPtr2{Nothing}, onfile_class::ByConstPtr1{TClass})

# Wrapper of Int_t TBuffer::ReadClones(TClonesArray *, Int_t, Version_t)
@trydoc raw"""
    ReadClones(this::ByRef1{TBuffer}, a::ByPtr1{TClonesArray}, nobjects::Int32, objvers::Int16)::Int32


""" ReadClones(this::ByRef1{TBuffer}, a::ByPtr1{TClonesArray}, nobjects::Int32, objvers::Int16)

# Wrapper of void TBuffer::ReadDouble(Double_t &)
@trydoc raw"""
    ReadDouble(this::ByRef1{TBuffer}, d::ByRef2{Float64})::Nothing


""" ReadDouble(this::ByRef1{TBuffer}, d::ByRef2{Float64})

# Wrapper of void TBuffer::ReadFastArray(Bool_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, b::ByPtr2{Bool}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, b::ByPtr2{Bool}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(Char_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, c::ByPtr2{Int8}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, c::ByPtr2{Int8}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(Double_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, d::ByPtr2{Float64}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, d::ByPtr2{Float64}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(Float_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, f::ByPtr2{Float32}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, f::ByPtr2{Float32}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(Int_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, i::ByPtr2{Int32}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, i::ByPtr2{Int32}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(Long64_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, l::ByPtr2{Int64}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, l::ByPtr2{Int64}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(Short_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, h::ByPtr2{Int16}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, h::ByPtr2{Int16}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(UInt_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, i::ByPtr2{UInt32}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, i::ByPtr2{UInt32}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(ULong64_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, l::ByPtr2{UInt64}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, l::ByPtr2{UInt64}, n::Int32)

# Wrapper of void TBuffer::ReadFastArray(UShort_t *, Int_t)
@trydoc raw"""
    ReadFastArray(this::ByRef1{TBuffer}, h::ByPtr2{UInt16}, n::Int32)::Nothing


""" ReadFastArray(this::ByRef1{TBuffer}, h::ByPtr2{UInt16}, n::Int32)

# Wrapper of void TBuffer::ReadFastArrayString(Char_t *, Int_t)
@trydoc raw"""
    ReadFastArrayString(this::ByRef1{TBuffer}, c::ByPtr2{Int8}, n::Int32)::Nothing


""" ReadFastArrayString(this::ByRef1{TBuffer}, c::ByPtr2{Int8}, n::Int32)

# Wrapper of void TBuffer::ReadFastArrayWithFactor(Double_t *, Int_t, Double_t, Double_t)
@trydoc raw"""
    ReadFastArrayWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, n::Int32, factor::Float64, minvalue::Float64)::Nothing


""" ReadFastArrayWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, n::Int32, factor::Float64, minvalue::Float64)

# Wrapper of void TBuffer::ReadFastArrayWithFactor(Float_t *, Int_t, Double_t, Double_t)
@trydoc raw"""
    ReadFastArrayWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, n::Int32, factor::Float64, minvalue::Float64)::Nothing


""" ReadFastArrayWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, n::Int32, factor::Float64, minvalue::Float64)

# Wrapper of void TBuffer::ReadFastArrayWithNbits(Double_t *, Int_t, Int_t)
@trydoc raw"""
    ReadFastArrayWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, n::Int32, nbits::Int32)::Nothing


""" ReadFastArrayWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, n::Int32, nbits::Int32)

# Wrapper of void TBuffer::ReadFastArrayWithNbits(Float_t *, Int_t, Int_t)
@trydoc raw"""
    ReadFastArrayWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, n::Int32, nbits::Int32)::Nothing


""" ReadFastArrayWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, n::Int32, nbits::Int32)

# Wrapper of void TBuffer::ReadFloat(Float_t &)
@trydoc raw"""
    ReadFloat(this::ByRef1{TBuffer}, f::ByRef2{Float32})::Nothing


""" ReadFloat(this::ByRef1{TBuffer}, f::ByRef2{Float32})

# Wrapper of void TBuffer::ReadInt(Int_t &)
@trydoc raw"""
    ReadInt(this::ByRef1{TBuffer}, i::ByRef2{Int32})::Nothing


""" ReadInt(this::ByRef1{TBuffer}, i::ByRef2{Int32})

# Wrapper of void TBuffer::ReadLong(Long_t &)
@trydoc raw"""
    ReadLong(this::ByRef1{TBuffer}, l::ByRef2{Int64})::Nothing


""" ReadLong(this::ByRef1{TBuffer}, l::ByRef2{Int64})

# Wrapper of void TBuffer::ReadLong64(Long64_t &)
@trydoc raw"""
    ReadLong64(this::ByRef1{TBuffer}, l::ByRef2{Int64})::Nothing


""" ReadLong64(this::ByRef1{TBuffer}, l::ByRef2{Int64})

# Wrapper of TObject * TBuffer::ReadObject(const TClass *)
@trydoc raw"""
    ReadObject(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})::CxxPtr1{TObject}


""" ReadObject(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})

# Wrapper of void * TBuffer::ReadObjectAny(const TClass *)
@trydoc raw"""
    ReadObjectAny(this::ByRef1{TBuffer}, cast::ByConstPtr1{TClass})::CxxPtr2{Nothing}


""" ReadObjectAny(this::ByRef1{TBuffer}, cast::ByConstPtr1{TClass})

# Wrapper of TProcessID * TBuffer::ReadProcessID(UShort_t)
@trydoc raw"""
    ReadProcessID(this::ByRef1{TBuffer}, pidf::UInt16)::CxxPtr1{TProcessID}
Return the current Process-ID.

""" ReadProcessID(this::ByRef1{TBuffer}, pidf::UInt16)

# Wrapper of void TBuffer::ReadShort(Short_t &)
@trydoc raw"""
    ReadShort(this::ByRef1{TBuffer}, s::ByRef2{Int16})::Nothing


""" ReadShort(this::ByRef1{TBuffer}, s::ByRef2{Int16})

# Wrapper of Int_t TBuffer::ReadStaticArray(Bool_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, b::ByPtr2{Bool})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, b::ByPtr2{Bool})

# Wrapper of Int_t TBuffer::ReadStaticArray(Char_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, c::ByPtr2{Int8})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, c::ByPtr2{Int8})

# Wrapper of Int_t TBuffer::ReadStaticArray(Double_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, d::ByPtr2{Float64})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, d::ByPtr2{Float64})

# Wrapper of Int_t TBuffer::ReadStaticArray(Float_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, f::ByPtr2{Float32})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, f::ByPtr2{Float32})

# Wrapper of Int_t TBuffer::ReadStaticArray(Int_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, i::ByPtr2{Int32})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, i::ByPtr2{Int32})

# Wrapper of Int_t TBuffer::ReadStaticArray(Long64_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, l::ByPtr2{Int64})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, l::ByPtr2{Int64})

# Wrapper of Int_t TBuffer::ReadStaticArray(Short_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, h::ByPtr2{Int16})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, h::ByPtr2{Int16})

# Wrapper of Int_t TBuffer::ReadStaticArray(UInt_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, i::ByPtr2{UInt32})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, i::ByPtr2{UInt32})

# Wrapper of Int_t TBuffer::ReadStaticArray(ULong64_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, l::ByPtr2{UInt64})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, l::ByPtr2{UInt64})

# Wrapper of Int_t TBuffer::ReadStaticArray(UShort_t *)
@trydoc raw"""
    ReadStaticArray(this::ByRef1{TBuffer}, h::ByPtr2{UInt16})::Int32


""" ReadStaticArray(this::ByRef1{TBuffer}, h::ByPtr2{UInt16})

# Wrapper of char * TBuffer::ReadString(char *, Int_t)
@trydoc raw"""
    ReadString(this::ByRef1{TBuffer}, s::ByPtr2{Int8}, max::Int32)::ByCopy{Union{String, Vector{CxxChar}}}


""" ReadString(this::ByRef1{TBuffer}, s::ByPtr2{Int8}, max::Int32)

# Wrapper of void TBuffer::ReadTString(TString &)
@trydoc raw"""
    ReadTString(this::ByRef1{TBuffer}, s::ByRef1{TString})::Nothing


""" ReadTString(this::ByRef1{TBuffer}, s::ByRef1{TString})

# Wrapper of void TBuffer::ReadUChar(UChar_t &)
@trydoc raw"""
    ReadUChar(this::ByRef1{TBuffer}, c::ByRef2{UInt8})::Nothing


""" ReadUChar(this::ByRef1{TBuffer}, c::ByRef2{UInt8})

# Wrapper of void TBuffer::ReadUInt(UInt_t &)
@trydoc raw"""
    ReadUInt(this::ByRef1{TBuffer}, i::ByRef2{UInt32})::Nothing


""" ReadUInt(this::ByRef1{TBuffer}, i::ByRef2{UInt32})

# Wrapper of void TBuffer::ReadULong(ULong_t &)
@trydoc raw"""
    ReadULong(this::ByRef1{TBuffer}, l::ByRef2{UInt64})::Nothing


""" ReadULong(this::ByRef1{TBuffer}, l::ByRef2{UInt64})

# Wrapper of void TBuffer::ReadULong64(ULong64_t &)
@trydoc raw"""
    ReadULong64(this::ByRef1{TBuffer}, l::ByRef2{UInt64})::Nothing


""" ReadULong64(this::ByRef1{TBuffer}, l::ByRef2{UInt64})

# Wrapper of void TBuffer::ReadUShort(UShort_t &)
@trydoc raw"""
    ReadUShort(this::ByRef1{TBuffer}, s::ByRef2{UInt16})::Nothing


""" ReadUShort(this::ByRef1{TBuffer}, s::ByRef2{UInt16})

# Wrapper of Version_t TBuffer::ReadVersion(UInt_t *, UInt_t *, const TClass *)
@trydoc raw"""
    ReadVersion(this::ByRef1{TBuffer}, thestart::ByPtr2{UInt32}, bcnt::ByPtr2{UInt32}, cl::ByConstPtr1{TClass})::Int16


""" ReadVersion(this::ByRef1{TBuffer}, thestart::ByPtr2{UInt32}, bcnt::ByPtr2{UInt32}, cl::ByConstPtr1{TClass})

# Wrapper of Version_t TBuffer::ReadVersionForMemberWise(const TClass *)
@trydoc raw"""
    ReadVersionForMemberWise(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})::Int16


""" ReadVersionForMemberWise(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})

# Wrapper of Version_t TBuffer::ReadVersionNoCheckSum(UInt_t *, UInt_t *)
@trydoc raw"""
    ReadVersionNoCheckSum(this::ByRef1{TBuffer}, thestart::ByPtr2{UInt32}, bcnt::ByPtr2{UInt32})::Int16


""" ReadVersionNoCheckSum(this::ByRef1{TBuffer}, thestart::ByPtr2{UInt32}, bcnt::ByPtr2{UInt32})

# Wrapper of void TBuffer::ReadWithFactor(Double_t *, Double_t, Double_t)
@trydoc raw"""
    ReadWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, factor::Float64, minvalue::Float64)::Nothing


""" ReadWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, factor::Float64, minvalue::Float64)

# Wrapper of void TBuffer::ReadWithFactor(Float_t *, Double_t, Double_t)
@trydoc raw"""
    ReadWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, factor::Float64, minvalue::Float64)::Nothing


""" ReadWithFactor(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, factor::Float64, minvalue::Float64)

# Wrapper of void TBuffer::ReadWithNbits(Double_t *, Int_t)
@trydoc raw"""
    ReadWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, nbits::Int32)::Nothing


""" ReadWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float64}, nbits::Int32)

# Wrapper of void TBuffer::ReadWithNbits(Float_t *, Int_t)
@trydoc raw"""
    ReadWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, nbits::Int32)::Nothing


""" ReadWithNbits(this::ByRef1{TBuffer}, ptr::ByPtr2{Float32}, nbits::Int32)

# Wrapper of void TBuffer::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TBuffer})::Nothing


""" Reset(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::ResetMap()
@trydoc raw"""
    ResetMap(this::ByRef1{TBuffer})::Nothing


""" ResetMap(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::SetBuffer(void *, UInt_t, Bool_t, ReAllocCharFun_t)
@trydoc raw"""
    SetBuffer(this::ByRef1{TBuffer}, buf::ByPtr2{Nothing}, bufsiz::UInt32, adopt::Bool, reallocfunc::ByCopy{ReAllocCharFun_t})::Nothing
Sets a new buffer in an existing [TBuffer](@ref) object.
If newsiz=0 then the new buffer is expected to have the same size as the previous buffer. The current buffer position is reset to the thestart of the buffer. If the [TBuffer](@ref) owned the previous buffer, it will be deleted prior to accepting the new buffer. By default the new buffer will be adopted unless adopt is false.

If the new buffer is *not* adopted and no memory allocation routine is provided, a Fatal error will be issued if the Buffer attempts to expand.
""" SetBuffer(this::ByRef1{TBuffer}, buf::ByPtr2{Nothing}, bufsiz::UInt32, adopt::Bool, reallocfunc::ByCopy{ReAllocCharFun_t})

# Wrapper of void TBuffer::SetBufferDisplacement()
@trydoc raw"""
    SetBufferDisplacement(this::ByRef1{TBuffer})::Nothing


""" SetBufferDisplacement(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::SetBufferDisplacement(Int_t)
@trydoc raw"""
    SetBufferDisplacement(this::ByRef1{TBuffer}, skipped::Int32)::Nothing


""" SetBufferDisplacement(this::ByRef1{TBuffer}, skipped::Int32)

# Wrapper of void TBuffer::SetBufferOffset(Int_t)
@trydoc raw"""
    SetBufferOffset(this::ByRef1{TBuffer}, offset::Int32)::Nothing


""" SetBufferOffset(this::ByRef1{TBuffer}, offset::Int32)

# Wrapper of void TBuffer::SetByteCount(UInt_t, Bool_t)
@trydoc raw"""
    SetByteCount(this::ByRef1{TBuffer}, cntpos::UInt32, packInVersion::Bool)::Nothing


""" SetByteCount(this::ByRef1{TBuffer}, cntpos::UInt32, packInVersion::Bool)

# Wrapper of void TBuffer::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TBuffer}, parent::ByPtr1{TObject})::Nothing
Set parent owning this buffer.

""" SetParent(this::ByRef1{TBuffer}, parent::ByPtr1{TObject})

# Wrapper of void TBuffer::SetPidOffset(UShort_t)
@trydoc raw"""
    SetPidOffset(this::ByRef1{TBuffer}, offset::UInt16)::Nothing


""" SetPidOffset(this::ByRef1{TBuffer}, offset::UInt16)

# Wrapper of void TBuffer::SetReadMode()
@trydoc raw"""
    SetReadMode(this::ByRef1{TBuffer})::Nothing
Set buffer in read mode.

""" SetReadMode(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::SetReadParam(Int_t)
@trydoc raw"""
    SetReadParam(this::ByRef1{TBuffer}, mapsize::Int32)::Nothing


""" SetReadParam(this::ByRef1{TBuffer}, mapsize::Int32)

# Wrapper of void TBuffer::SetReAllocFunc(ReAllocCharFun_t)
@trydoc raw"""
    SetReAllocFunc(this::ByRef1{TBuffer}, reallocfunc::ByCopy{ReAllocCharFun_t})::Nothing
Set which memory reallocation method to use.
If reallocafunc is null, reset it to the default value ([TStorage!ReAlloc](@ref))
""" SetReAllocFunc(this::ByRef1{TBuffer}, reallocfunc::ByCopy{ReAllocCharFun_t})

# Wrapper of void TBuffer::SetWriteMode()
@trydoc raw"""
    SetWriteMode(this::ByRef1{TBuffer})::Nothing
Set buffer in write mode.

""" SetWriteMode(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::SetWriteParam(Int_t)
@trydoc raw"""
    SetWriteParam(this::ByRef1{TBuffer}, mapsize::Int32)::Nothing


""" SetWriteParam(this::ByRef1{TBuffer}, mapsize::Int32)

# Wrapper of void TBuffer::SkipObjectAny()
@trydoc raw"""
    SkipObjectAny(this::ByRef1{TBuffer})::Nothing


""" SkipObjectAny(this::ByRef1{TBuffer})

# Wrapper of void TBuffer::SkipVersion(const TClass *)
@trydoc raw"""
    SkipVersion(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})::Nothing


""" SkipVersion(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})

# Wrapper of void TBuffer::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TBuffer}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TBuffer}, ::ByRef1{TBuffer})

# Wrapper of void TBuffer::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TBuffer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TBuffer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TBuffer::StreamObject(TObject *)
@trydoc raw"""
    StreamObject(this::ByRef1{TBuffer}, obj::ByPtr1{TObject})::Nothing


""" StreamObject(this::ByRef1{TBuffer}, obj::ByPtr1{TObject})

# Wrapper of void TBuffer::StreamObject(void *, const char *, const TClass *)
@trydoc raw"""
    StreamObject(this::ByRef1{TBuffer}, obj::ByPtr2{Nothing}, className::ByCopy{String}, onFileClass::ByConstPtr1{TClass})::Nothing


""" StreamObject(this::ByRef1{TBuffer}, obj::ByPtr2{Nothing}, className::ByCopy{String}, onFileClass::ByConstPtr1{TClass})

# Wrapper of void TBuffer::StreamObject(void *, const TClass *, const TClass *)
@trydoc raw"""
    StreamObject(this::ByRef1{TBuffer}, obj::ByPtr2{Nothing}, cl::ByConstPtr1{TClass}, onFileClass::ByConstPtr1{TClass})::Nothing


""" StreamObject(this::ByRef1{TBuffer}, obj::ByPtr2{Nothing}, cl::ByConstPtr1{TClass}, onFileClass::ByConstPtr1{TClass})

# Wrapper of void TBuffer::TagStreamerInfo(TVirtualStreamerInfo *)
@trydoc raw"""
    TagStreamerInfo(this::ByRef1{TBuffer}, info::ByPtr1{TVirtualStreamerInfo})::Nothing


""" TagStreamerInfo(this::ByRef1{TBuffer}, info::ByPtr1{TVirtualStreamerInfo})

# Wrapper of void TBuffer::WriteArray(const Bool_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, b::ByConstPtr2{Bool}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, b::ByConstPtr2{Bool}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const Char_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, c::ByCopy{String}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, c::ByCopy{String}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const Double_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, d::ByConstPtr2{Float64}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, d::ByConstPtr2{Float64}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const Float_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, f::ByConstPtr2{Float32}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, f::ByConstPtr2{Float32}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const Int_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, i::ByConstPtr2{Int32}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, i::ByConstPtr2{Int32}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const Long64_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, l::ByConstPtr2{Int64}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, l::ByConstPtr2{Int64}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const Short_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, h::ByConstPtr2{Int16}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, h::ByConstPtr2{Int16}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const UInt_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, i::ByConstPtr2{UInt32}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, i::ByConstPtr2{UInt32}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const ULong64_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, l::ByConstPtr2{UInt64}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, l::ByConstPtr2{UInt64}, n::Int32)

# Wrapper of void TBuffer::WriteArray(const UShort_t *, Int_t)
@trydoc raw"""
    WriteArray(this::ByRef1{TBuffer}, h::ByConstPtr2{UInt16}, n::Int32)::Nothing


""" WriteArray(this::ByRef1{TBuffer}, h::ByConstPtr2{UInt16}, n::Int32)

# Wrapper of void TBuffer::WriteBool(Bool_t)
@trydoc raw"""
    WriteBool(this::ByRef1{TBuffer}, b::Bool)::Nothing


""" WriteBool(this::ByRef1{TBuffer}, b::Bool)

# Wrapper of void TBuffer::WriteBuf(const void *, Int_t)
@trydoc raw"""
    WriteBuf(this::ByRef1{TBuffer}, buf::ByConstPtr2{Nothing}, max::Int32)::Nothing


""" WriteBuf(this::ByRef1{TBuffer}, buf::ByConstPtr2{Nothing}, max::Int32)

# Wrapper of void TBuffer::WriteChar(Char_t)
@trydoc raw"""
    WriteChar(this::ByRef1{TBuffer}, c::Int8)::Nothing


""" WriteChar(this::ByRef1{TBuffer}, c::Int8)

# Wrapper of void TBuffer::WriteCharP(const Char_t *)
@trydoc raw"""
    WriteCharP(this::ByRef1{TBuffer}, c::ByCopy{String})::Nothing


""" WriteCharP(this::ByRef1{TBuffer}, c::ByCopy{String})

# Wrapper of void TBuffer::WriteCharStar(char *)
@trydoc raw"""
    WriteCharStar(this::ByRef1{TBuffer}, s::ByPtr2{Int8})::Nothing


""" WriteCharStar(this::ByRef1{TBuffer}, s::ByPtr2{Int8})

# Wrapper of void TBuffer::WriteClass(const TClass *)
@trydoc raw"""
    WriteClass(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})::Nothing


""" WriteClass(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass})

# Wrapper of Int_t TBuffer::WriteClassBuffer(const TClass *, void *)
@trydoc raw"""
    WriteClassBuffer(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, pointer::ByPtr2{Nothing})::Int32


""" WriteClassBuffer(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, pointer::ByPtr2{Nothing})

# Wrapper of Int_t TBuffer::WriteClones(TClonesArray *, Int_t)
@trydoc raw"""
    WriteClones(this::ByRef1{TBuffer}, a::ByPtr1{TClonesArray}, nobjects::Int32)::Int32


""" WriteClones(this::ByRef1{TBuffer}, a::ByPtr1{TClonesArray}, nobjects::Int32)

# Wrapper of void TBuffer::WriteDouble(Double_t)
@trydoc raw"""
    WriteDouble(this::ByRef1{TBuffer}, d::Float64)::Nothing


""" WriteDouble(this::ByRef1{TBuffer}, d::Float64)

# Wrapper of void TBuffer::WriteFastArray(const Bool_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, b::ByConstPtr2{Bool}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, b::ByConstPtr2{Bool}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const Char_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, c::ByCopy{String}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, c::ByCopy{String}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const Double_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, d::ByConstPtr2{Float64}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, d::ByConstPtr2{Float64}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const Float_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, f::ByConstPtr2{Float32}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, f::ByConstPtr2{Float32}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const Int_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, i::ByConstPtr2{Int32}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, i::ByConstPtr2{Int32}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const Long64_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, l::ByConstPtr2{Int64}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, l::ByConstPtr2{Int64}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const Short_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, h::ByConstPtr2{Int16}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, h::ByConstPtr2{Int16}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const UInt_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, i::ByConstPtr2{UInt32}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, i::ByConstPtr2{UInt32}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const ULong64_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, l::ByConstPtr2{UInt64}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, l::ByConstPtr2{UInt64}, n::Int64)

# Wrapper of void TBuffer::WriteFastArray(const UShort_t *, Long64_t)
@trydoc raw"""
    WriteFastArray(this::ByRef1{TBuffer}, h::ByConstPtr2{UInt16}, n::Int64)::Nothing


""" WriteFastArray(this::ByRef1{TBuffer}, h::ByConstPtr2{UInt16}, n::Int64)

# Wrapper of void TBuffer::WriteFastArrayString(const Char_t *, Long64_t)
@trydoc raw"""
    WriteFastArrayString(this::ByRef1{TBuffer}, c::ByCopy{String}, n::Int64)::Nothing


""" WriteFastArrayString(this::ByRef1{TBuffer}, c::ByCopy{String}, n::Int64)

# Wrapper of void TBuffer::WriteFloat(Float_t)
@trydoc raw"""
    WriteFloat(this::ByRef1{TBuffer}, f::Float32)::Nothing


""" WriteFloat(this::ByRef1{TBuffer}, f::Float32)

# Wrapper of void TBuffer::WriteInt(Int_t)
@trydoc raw"""
    WriteInt(this::ByRef1{TBuffer}, i::Int32)::Nothing


""" WriteInt(this::ByRef1{TBuffer}, i::Int32)

# Wrapper of void TBuffer::WriteLong(Long_t)
@trydoc raw"""
    WriteLong(this::ByRef1{TBuffer}, l::Int64)::Nothing


""" WriteLong(this::ByRef1{TBuffer}, l::Int64)

# Wrapper of void TBuffer::WriteLong64(Long64_t)
@trydoc raw"""
    WriteLong64(this::ByRef1{TBuffer}, l::Int64)::Nothing


""" WriteLong64(this::ByRef1{TBuffer}, l::Int64)

# Wrapper of void TBuffer::WriteObject(const TObject *, Bool_t)
@trydoc raw"""
    WriteObject(this::ByRef1{TBuffer}, obj::ByConstPtr1{TObject}, cacheReuse::Bool)::Nothing


""" WriteObject(this::ByRef1{TBuffer}, obj::ByConstPtr1{TObject}, cacheReuse::Bool)

# Wrapper of Int_t TBuffer::WriteObjectAny(const void *, const TClass *, Bool_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TBuffer}, obj::ByConstPtr2{Nothing}, ptrClass::ByConstPtr1{TClass}, cacheReuse::Bool)::Int32


""" WriteObjectAny(this::ByRef1{TBuffer}, obj::ByConstPtr2{Nothing}, ptrClass::ByConstPtr1{TClass}, cacheReuse::Bool)

# Wrapper of UShort_t TBuffer::WriteProcessID(TProcessID *)
@trydoc raw"""
    WriteProcessID(this::ByRef1{TBuffer}, pid::ByPtr1{TProcessID})::UInt16
Always return 0 (current processID).

""" WriteProcessID(this::ByRef1{TBuffer}, pid::ByPtr1{TProcessID})

# Wrapper of void TBuffer::WriteShort(Short_t)
@trydoc raw"""
    WriteShort(this::ByRef1{TBuffer}, s::Int16)::Nothing


""" WriteShort(this::ByRef1{TBuffer}, s::Int16)

# Wrapper of void TBuffer::WriteString(const char *)
@trydoc raw"""
    WriteString(this::ByRef1{TBuffer}, s::ByCopy{String})::Nothing


""" WriteString(this::ByRef1{TBuffer}, s::ByCopy{String})

# Wrapper of void TBuffer::WriteTString(const TString &)
@trydoc raw"""
    WriteTString(this::ByRef1{TBuffer}, s::ByConstRef1{TString})::Nothing


""" WriteTString(this::ByRef1{TBuffer}, s::ByConstRef1{TString})

# Wrapper of void TBuffer::WriteUChar(UChar_t)
@trydoc raw"""
    WriteUChar(this::ByRef1{TBuffer}, c::UInt8)::Nothing


""" WriteUChar(this::ByRef1{TBuffer}, c::UInt8)

# Wrapper of void TBuffer::WriteUInt(UInt_t)
@trydoc raw"""
    WriteUInt(this::ByRef1{TBuffer}, i::UInt32)::Nothing


""" WriteUInt(this::ByRef1{TBuffer}, i::UInt32)

# Wrapper of void TBuffer::WriteULong(ULong_t)
@trydoc raw"""
    WriteULong(this::ByRef1{TBuffer}, l::UInt64)::Nothing


""" WriteULong(this::ByRef1{TBuffer}, l::UInt64)

# Wrapper of void TBuffer::WriteULong64(ULong64_t)
@trydoc raw"""
    WriteULong64(this::ByRef1{TBuffer}, l::UInt64)::Nothing


""" WriteULong64(this::ByRef1{TBuffer}, l::UInt64)

# Wrapper of void TBuffer::WriteUShort(UShort_t)
@trydoc raw"""
    WriteUShort(this::ByRef1{TBuffer}, s::UInt16)::Nothing


""" WriteUShort(this::ByRef1{TBuffer}, s::UInt16)

# Wrapper of UInt_t TBuffer::WriteVersion(const TClass *, Bool_t)
@trydoc raw"""
    WriteVersion(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, useBcnt::Bool)::UInt32


""" WriteVersion(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, useBcnt::Bool)

# Wrapper of UInt_t TBuffer::WriteVersionMemberWise(const TClass *, Bool_t)
@trydoc raw"""
    WriteVersionMemberWise(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, useBcnt::Bool)::UInt32


""" WriteVersionMemberWise(this::ByRef1{TBuffer}, cl::ByConstPtr1{TClass}, useBcnt::Bool)

# Wrapper of void TCollection::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TCollection}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TCollection}, obj::ByPtr1{TObject})

# Wrapper of void TCollection::AddAll(const TCollection *)
@trydoc raw"""
    AddAll(this::ByRef1{TCollection}, col::ByConstPtr1{TCollection})::Nothing
Add all objects from collection col to this collection.

""" AddAll(this::ByRef1{TCollection}, col::ByConstPtr1{TCollection})

# Wrapper of void TCollection::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TCollection}, b::ByPtr1{TBrowser})::Nothing
Browse this collection (called by [TBrowser](@ref)).
If b=0, there is no Browse call TObject!Browse(0) instead. This means [TObject!Inspect()](@ref) will be invoked indirectly
""" Browse(this::ByRef1{TCollection}, b::ByPtr1{TBrowser})

# Wrapper of void TCollection::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TCollection}, option::ByCopy{String})::Nothing


""" Clear(this::ByRef1{TCollection}, option::ByCopy{String})

# Wrapper of void TCollection::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TCollection}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TCollection}, option::ByCopy{String})

# Wrapper of void TCollection::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TCollection}, option::ByCopy{String})::Nothing
Draw all objects in this collection.

""" Draw(this::ByRef1{TCollection}, option::ByCopy{String})

# Wrapper of Bool_t TCollection::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TCollection})::Bool
'Notify' all objects in this collection.

""" Notify(this::ByRef1{TCollection})

# Wrapper of void TCollection::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TCollection}, option::ByCopy{String})::Nothing
Paint all objects in this collection.

""" Paint(this::ByRef1{TCollection}, option::ByCopy{String})

# Wrapper of void TCollection::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TCollection}, obj::ByPtr1{TObject})::Nothing
Remove object from this collection and recursively remove the object from all other objects (and collections).

""" RecursiveRemove(this::ByRef1{TCollection}, obj::ByPtr1{TObject})

# Wrapper of TObject * TCollection::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TCollection}, obj::ByPtr1{TObject})::CxxPtr1{TObject}


""" Remove(this::ByRef1{TCollection}, obj::ByPtr1{TObject})

# Wrapper of void TCollection::RemoveAll()
@trydoc raw"""
    RemoveAll(this::ByRef1{TCollection})::Nothing


""" RemoveAll(this::ByRef1{TCollection})

# Wrapper of void TCollection::RemoveAll(TCollection *)
@trydoc raw"""
    RemoveAll(this::ByRef1{TCollection}, col::ByPtr1{TCollection})::Nothing
Remove all objects in collection col from this collection.

""" RemoveAll(this::ByRef1{TCollection}, col::ByPtr1{TCollection})

# Wrapper of void TCollection::SetCurrentCollection()
@trydoc raw"""
    SetCurrentCollection(this::ByRef1{TCollection})::Nothing
Set this collection to be the globally accessible collection.

""" SetCurrentCollection(this::ByRef1{TCollection})

# Wrapper of void TCollection::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TCollection}, name::ByCopy{String})::Nothing


""" SetName(this::ByRef1{TCollection}, name::ByCopy{String})

# Wrapper of void TCollection::SetOwner(Bool_t)
@trydoc raw"""
    SetOwner(this::ByRef1{TCollection}, enable::Bool)::Nothing
Set whether this collection is the owner (enable==true) of its content.
If it is the owner of its contents, these objects will be deleted whenever the collection itself is deleted. The objects might also be deleted or destructed when Clear is called (depending on the collection).
""" SetOwner(this::ByRef1{TCollection}, enable::Bool)

# Wrapper of bool TCollection::UseRWLock(Bool_t)
@trydoc raw"""
    UseRWLock(this::ByRef1{TCollection}, enable::Bool)::Bool
Set this collection to use a RW lock upon access, making it thread safe.
Return the previous state.

Note: To test whether the usage is enabled do: collection->TestBit(TCollection!kUseRWLock);
""" UseRWLock(this::ByRef1{TCollection}, enable::Bool)

# Wrapper of Int_t TCollection::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TCollection}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write all objects in this collection.
By default all objects in the collection are written individually (each object gets its own key). Note, this is recursive, i.e. objects in collections in the collection are also written individually. To write all objects using a single key specify a name and set option to [TObject!kSingleKey](@ref) (i.e. 1).
""" Write(this::ByRef1{TCollection}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of TString & TString::Append(char, Ssiz_t)
@trydoc raw"""
    Append(this::ByRef1{TString}, c::Int8, rep::ByCopy{int})::CxxRef1{TString}
Append character c rep times to string.
###Warning

If length+rep exceeds MaxSize(), then Fatal() is raised and only MaxSize()-length elements are added
""" Append(this::ByRef1{TString}, c::Int8, rep::ByCopy{int})

# Wrapper of TString & TString::Append(const char *)
@trydoc raw"""
    Append(this::ByRef1{TString}, cs::ByCopy{String})::CxxRef1{TString}


""" Append(this::ByRef1{TString}, cs::ByCopy{String})

# Wrapper of TString & TString::Append(const char *, Ssiz_t)
@trydoc raw"""
    Append(this::ByRef1{TString}, cs::ByCopy{String}, n::ByCopy{int})::CxxRef1{TString}


""" Append(this::ByRef1{TString}, cs::ByCopy{String}, n::ByCopy{int})

# Wrapper of TString & TString::Append(const TString &)
@trydoc raw"""
    Append(this::ByRef1{TString}, s::ByConstRef1{TString})::CxxRef1{TString}


""" Append(this::ByRef1{TString}, s::ByConstRef1{TString})

# Wrapper of TString & TString::Append(const TString &, Ssiz_t)
@trydoc raw"""
    Append(this::ByRef1{TString}, s::ByConstRef1{TString}, n::ByCopy{int})::CxxRef1{TString}


""" Append(this::ByRef1{TString}, s::ByConstRef1{TString}, n::ByCopy{int})

# Wrapper of Ssiz_t TString::Capacity(Ssiz_t)
@trydoc raw"""
    Capacity(this::ByRef1{TString}, n::ByCopy{int})::ByCopy{int}
Return string capacity.
If nc != current capacity Clone() the string in a string with the desired capacity.
""" Capacity(this::ByRef1{TString}, n::ByCopy{int})

# Wrapper of TString & TString::Chop()
@trydoc raw"""
    Chop(this::ByRef1{TString})::CxxRef1{TString}


""" Chop(this::ByRef1{TString})

# Wrapper of void TString::Clear()
@trydoc raw"""
    Clear(this::ByRef1{TString})::Nothing
Clear string without changing its capacity.

""" Clear(this::ByRef1{TString})

# Wrapper of Bool_t TString::Gets(FILE *, Bool_t)
@trydoc raw"""
    Gets(this::ByRef1{TString}, fp::ByPtr1{FILE}, chop::Bool)::Bool
Read one line from the stream, including the `\n`, or until EOF.
Remove the trailing `[\r]\n` if chop is true. Returns kTRUE if data was read.
""" Gets(this::ByRef1{TString}, fp::ByPtr1{FILE}, chop::Bool)

# Wrapper of TString & TString::Insert(Ssiz_t, const char *)
@trydoc raw"""
    Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByCopy{String})::CxxRef1{TString}


""" Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByCopy{String})

# Wrapper of TString & TString::Insert(Ssiz_t, const char *, Ssiz_t)
@trydoc raw"""
    Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByCopy{String}, extent::ByCopy{int})::CxxRef1{TString}


""" Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByCopy{String}, extent::ByCopy{int})

# Wrapper of TString & TString::Insert(Ssiz_t, const TString &)
@trydoc raw"""
    Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByConstRef1{TString})::CxxRef1{TString}


""" Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByConstRef1{TString})

# Wrapper of TString & TString::Insert(Ssiz_t, const TString &, Ssiz_t)
@trydoc raw"""
    Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByConstRef1{TString}, extent::ByCopy{int})::CxxRef1{TString}


""" Insert(this::ByRef1{TString}, pos::ByCopy{int}, s::ByConstRef1{TString}, extent::ByCopy{int})

# Wrapper of char & TString::operator()(Ssiz_t)
@trydoc raw"""
    paren(this::ByRef1{TString}, i::ByCopy{int})::CxxRef2{Int8}


""" paren(this::ByRef1{TString}, i::ByCopy{int})

# Wrapper of TString & TString::operator+=(char)
@trydoc raw"""
    add!(this::ByRef1{TString}, c::Int8)::CxxRef1{TString}


""" add!(this::ByRef1{TString}, c::Int8)

# Wrapper of TString & TString::operator+=(const char *)
@trydoc raw"""
    add!(this::ByRef1{TString}, s::ByCopy{String})::CxxRef1{TString}


""" add!(this::ByRef1{TString}, s::ByCopy{String})

# Wrapper of TString & TString::operator+=(const TString &)
@trydoc raw"""
    add!(this::ByRef1{TString}, s::ByConstRef1{TString})::CxxRef1{TString}


""" add!(this::ByRef1{TString}, s::ByConstRef1{TString})

# Wrapper of TString & TString::operator=(char)
@trydoc raw"""
    assign(this::ByRef1{TString}, s::Int8)::CxxRef1{TString}
Assign character c to [TString](@ref).

""" assign(this::ByRef1{TString}, s::Int8)

# Wrapper of TString & TString::operator=(const char *)
@trydoc raw"""
    assign(this::ByRef1{TString}, s::ByCopy{String})::CxxRef1{TString}
Assign string cs to [TString](@ref).

""" assign(this::ByRef1{TString}, s::ByCopy{String})

# Wrapper of TString & TString::operator=(const TString &)
@trydoc raw"""
    assign(this::ByRef1{TString}, s::ByConstRef1{TString})::CxxRef1{TString}
Assignment operator.

""" assign(this::ByRef1{TString}, s::ByConstRef1{TString})

# Wrapper of TString & TString::operator=(const TSubString &)
@trydoc raw"""
    assign(this::ByRef1{TString}, s::ByConstRef1{TSubString})::CxxRef1{TString}
Assign a [TSubString](@ref) substr to [TString](@ref).

""" assign(this::ByRef1{TString}, s::ByConstRef1{TSubString})

# Wrapper of TString & TString::operator=(TString &&)
@trydoc raw"""
    assign(this::ByRef1{TString}, s::ByRef1{TString})::CxxRef1{TString}
Move-Assignment operator.

""" assign(this::ByRef1{TString}, s::ByRef1{TString})

# Wrapper of char & TString::operator[](Ssiz_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TString}, i::ByCopy{int})::CxxRef2{Int8}


""" Base.getindex(this::ByRef1{TString}, i::ByCopy{int})

# Wrapper of TString & TString::Prepend(char, Ssiz_t)
@trydoc raw"""
    Prepend(this::ByRef1{TString}, c::Int8, rep::ByCopy{int})::CxxRef1{TString}
Prepend character c rep times to string.
###Warning

If length+rep exceeds MaxSize(), then Fatal() is raised and only MaxSize()-length elements are added
""" Prepend(this::ByRef1{TString}, c::Int8, rep::ByCopy{int})

# Wrapper of TString & TString::Prepend(const char *)
@trydoc raw"""
    Prepend(this::ByRef1{TString}, cs::ByCopy{String})::CxxRef1{TString}


""" Prepend(this::ByRef1{TString}, cs::ByCopy{String})

# Wrapper of TString & TString::Prepend(const char *, Ssiz_t)
@trydoc raw"""
    Prepend(this::ByRef1{TString}, cs::ByCopy{String}, n::ByCopy{int})::CxxRef1{TString}


""" Prepend(this::ByRef1{TString}, cs::ByCopy{String}, n::ByCopy{int})

# Wrapper of TString & TString::Prepend(const TString &)
@trydoc raw"""
    Prepend(this::ByRef1{TString}, s::ByConstRef1{TString})::CxxRef1{TString}


""" Prepend(this::ByRef1{TString}, s::ByConstRef1{TString})

# Wrapper of TString & TString::Prepend(const TString &, Ssiz_t)
@trydoc raw"""
    Prepend(this::ByRef1{TString}, s::ByConstRef1{TString}, n::ByCopy{int})::CxxRef1{TString}


""" Prepend(this::ByRef1{TString}, s::ByConstRef1{TString}, n::ByCopy{int})

# Wrapper of void TString::Puts(FILE *)
@trydoc raw"""
    Puts(this::ByRef1{TString}, fp::ByPtr1{FILE})::Nothing
Write string to the stream.

""" Puts(this::ByRef1{TString}, fp::ByPtr1{FILE})

# Wrapper of void TString::ReadBuffer(char *&)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TString}, buffer::ByPtr2{Int8})::Nothing
Read string from I/O buffer.

""" ReadBuffer(this::ByRef1{TString}, buffer::ByPtr2{Int8})

# Wrapper of TString & TString::Remove(Ssiz_t)
@trydoc raw"""
    Remove(this::ByRef1{TString}, pos::ByCopy{int})::CxxRef1{TString}


""" Remove(this::ByRef1{TString}, pos::ByCopy{int})

# Wrapper of TString & TString::Remove(Ssiz_t, Ssiz_t)
@trydoc raw"""
    Remove(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int})::CxxRef1{TString}


""" Remove(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int})

# Wrapper of TString & TString::Replace(Ssiz_t, Ssiz_t, const char *)
@trydoc raw"""
    Replace(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int}, s::ByCopy{String})::CxxRef1{TString}


""" Replace(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int}, s::ByCopy{String})

# Wrapper of TString & TString::Replace(Ssiz_t, Ssiz_t, const char *, Ssiz_t)
@trydoc raw"""
    Replace(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int}, s::ByCopy{String}, ns::ByCopy{int})::CxxRef1{TString}
Remove at most n1 characters from self beginning at pos, and replace them with the first n2 characters of cs.

""" Replace(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int}, s::ByCopy{String}, ns::ByCopy{int})

# Wrapper of TString & TString::Replace(Ssiz_t, Ssiz_t, const TString &)
@trydoc raw"""
    Replace(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int}, s::ByConstRef1{TString})::CxxRef1{TString}


""" Replace(this::ByRef1{TString}, pos::ByCopy{int}, n::ByCopy{int}, s::ByConstRef1{TString})

# Wrapper of TString & TString::Replace(Ssiz_t, Ssiz_t, const TString &, Ssiz_t)
@trydoc raw"""
    Replace(this::ByRef1{TString}, pos::ByCopy{int}, n1::ByCopy{int}, s::ByConstRef1{TString}, n2::ByCopy{int})::CxxRef1{TString}


""" Replace(this::ByRef1{TString}, pos::ByCopy{int}, n1::ByCopy{int}, s::ByConstRef1{TString}, n2::ByCopy{int})

# Wrapper of TString & TString::ReplaceAll(const char *, const char *)
@trydoc raw"""
    ReplaceAll(this::ByRef1{TString}, s1::ByCopy{String}, s2::ByCopy{String})::CxxRef1{TString}


""" ReplaceAll(this::ByRef1{TString}, s1::ByCopy{String}, s2::ByCopy{String})

# Wrapper of TString & TString::ReplaceAll(const char *, const TString &)
@trydoc raw"""
    ReplaceAll(this::ByRef1{TString}, s1::ByCopy{String}, s2::ByConstRef1{TString})::CxxRef1{TString}


""" ReplaceAll(this::ByRef1{TString}, s1::ByCopy{String}, s2::ByConstRef1{TString})

# Wrapper of TString & TString::ReplaceAll(const char *, Ssiz_t, const char *, Ssiz_t)
@trydoc raw"""
    ReplaceAll(this::ByRef1{TString}, s1::ByCopy{String}, ls1::ByCopy{int}, s2::ByCopy{String}, ls2::ByCopy{int})::CxxRef1{TString}
Find & Replace ls1 symbols of s1 with ls2 symbols of s2 if any.

""" ReplaceAll(this::ByRef1{TString}, s1::ByCopy{String}, ls1::ByCopy{int}, s2::ByCopy{String}, ls2::ByCopy{int})

# Wrapper of TString & TString::ReplaceAll(const TString &, const char *)
@trydoc raw"""
    ReplaceAll(this::ByRef1{TString}, s1::ByConstRef1{TString}, s2::ByCopy{String})::CxxRef1{TString}


""" ReplaceAll(this::ByRef1{TString}, s1::ByConstRef1{TString}, s2::ByCopy{String})

# Wrapper of TString & TString::ReplaceAll(const TString &, const TString &)
@trydoc raw"""
    ReplaceAll(this::ByRef1{TString}, s1::ByConstRef1{TString}, s2::ByConstRef1{TString})::CxxRef1{TString}


""" ReplaceAll(this::ByRef1{TString}, s1::ByConstRef1{TString}, s2::ByConstRef1{TString})

# Wrapper of TString & TString::ReplaceSpecialCppChars()
@trydoc raw"""
    ReplaceSpecialCppChars(this::ByRef1{TString})::CxxRef1{TString}
Find special characters which are typically used in `printf()` calls and replace them by appropriate escape sequences.
Result can be stored as string argument in [ROOT](@ref) macros. The content of [TString](@ref) will be changed!
""" ReplaceSpecialCppChars(this::ByRef1{TString})

# Wrapper of void TString::Resize(Ssiz_t)
@trydoc raw"""
    Resize(this::ByRef1{TString}, n::ByCopy{int})::Nothing
Resize the string. Truncate or add blanks as necessary.

""" Resize(this::ByRef1{TString}, n::ByCopy{int})

# Wrapper of void TString::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TString}, ::ByRef1{TBuffer})::Nothing
Stream a string object.

""" Streamer(this::ByRef1{TString}, ::ByRef1{TBuffer})

# Wrapper of void TString::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TString}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TString}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of TString & TString::Swap(TString &)
@trydoc raw"""
    Swap(this::ByRef1{TString}, other::ByRef1{TString})::CxxRef1{TString}


""" Swap(this::ByRef1{TString}, other::ByRef1{TString})

# Wrapper of void TString::ToLower()
@trydoc raw"""
    ToLower(this::ByRef1{TString})::Nothing
Change string to lower-case.

""" ToLower(this::ByRef1{TString})

# Wrapper of void TString::ToUpper()
@trydoc raw"""
    ToUpper(this::ByRef1{TString})::Nothing
Change string to upper case.

""" ToUpper(this::ByRef1{TString})

# Wrapper of char & TSubString::operator()(Ssiz_t)
@trydoc raw"""
    paren(this::ByRef1{TSubString}, i::ByCopy{int})::CxxRef2{Int8}
Return character at pos i from sub-string. No check on i.

""" paren(this::ByRef1{TSubString}, i::ByCopy{int})

# Wrapper of TSubString & TSubString::operator=(const char *)
@trydoc raw"""
    assign(this::ByRef1{TSubString}, s::ByCopy{String})::CxxRef1{TSubString}
Assign char* to sub-string.

""" assign(this::ByRef1{TSubString}, s::ByCopy{String})

# Wrapper of TSubString & TSubString::operator=(const TString &)
@trydoc raw"""
    assign(this::ByRef1{TSubString}, s::ByConstRef1{TString})::CxxRef1{TSubString}
Assign string to sub-string.

""" assign(this::ByRef1{TSubString}, s::ByConstRef1{TString})

# Wrapper of TSubString & TSubString::operator=(const TSubString &)
@trydoc raw"""
    assign(this::ByRef1{TSubString}, s::ByConstRef1{TSubString})::CxxRef1{TSubString}


""" assign(this::ByRef1{TSubString}, s::ByConstRef1{TSubString})

# Wrapper of char & TSubString::operator[](Ssiz_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TSubString}, i::ByCopy{int})::CxxRef2{Int8}
Return character at pos i from sub-string. Check validity of i.

""" Base.getindex(this::ByRef1{TSubString}, i::ByCopy{int})

# Wrapper of TString & TSubString::String()
@trydoc raw"""
    GetString(this::ByRef1{TSubString})::CxxRef1{TString}


""" GetString(this::ByRef1{TSubString})

# Wrapper of void TSubString::ToLower()
@trydoc raw"""
    ToLower(this::ByRef1{TSubString})::Nothing
Convert sub-string to lower-case.

""" ToLower(this::ByRef1{TSubString})

# Wrapper of void TSubString::ToUpper()
@trydoc raw"""
    ToUpper(this::ByRef1{TSubString})::Nothing
Convert sub-string to upper-case.

""" ToUpper(this::ByRef1{TSubString})

# Wrapper of TRegexp & TRegexp::operator=(const char *)
@trydoc raw"""
    assign(this::ByRef1{TRegexp}, re::ByCopy{String})::CxxRef1{TRegexp}
Assignment operator taking a char* and assigning it to a regexp.

""" assign(this::ByRef1{TRegexp}, re::ByCopy{String})

# Wrapper of TRegexp & TRegexp::operator=(const TRegexp &)
@trydoc raw"""
    assign(this::ByRef1{TRegexp}, re::ByConstRef1{TRegexp})::CxxRef1{TRegexp}
Assignment operator.

""" assign(this::ByRef1{TRegexp}, re::ByConstRef1{TRegexp})

# Wrapper of TRegexp & TRegexp::operator=(const TString &)
@trydoc raw"""
    assign(this::ByRef1{TRegexp}, re::ByConstRef1{TString})::CxxRef1{TRegexp}
Assignment operator taking a [TString](@ref).

""" assign(this::ByRef1{TRegexp}, re::ByConstRef1{TString})

# Wrapper of void TRegexp::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TRegexp}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TRegexp}, ::ByRef1{TBuffer})

# Wrapper of void TRegexp::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TRegexp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TRegexp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TPRegexp::Match(const TString &, const TString &, Int_t, Int_t, TArrayI *)
@trydoc raw"""
    Match(this::ByRef1{TPRegexp}, s::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMaxMatch::Int32, pos::ByPtr1{TArrayI})::Int32
The number of matches is returned, this equals the full match + sub-pattern matches.
nMaxMatch is the maximum allowed number of matches. pos contains the string indices of the matches. Its usage is shown in the routine MatchS. For meaning of mods see [ParseMods()](@ref).
""" Match(this::ByRef1{TPRegexp}, s::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMaxMatch::Int32, pos::ByPtr1{TArrayI})

# Wrapper of Bool_t TPRegexp::MatchB(const TString &, const TString &, Int_t, Int_t)
@trydoc raw"""
    MatchB(this::ByRef1{TPRegexp}, s::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMaxMatch::Int32)::Bool


""" MatchB(this::ByRef1{TPRegexp}, s::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMaxMatch::Int32)

# Wrapper of TObjArray * TPRegexp::MatchS(const TString &, const TString &, Int_t, Int_t)
@trydoc raw"""
    MatchS(this::ByRef1{TPRegexp}, s::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMaxMatch::Int32)::CxxPtr1{TObjArray}
Returns a [TObjArray](@ref) of matched substrings as [TObjString](@ref)'s.
The [TObjArray](@ref) is owner of the objects and must be deleted by the user. The first entry is the full matched pattern, followed by the sub-patterns. If a pattern was not matched, it will return an empty substring: 

    TObjArray *subStrL = TPRegexp("(a|(z))(bc)").MatchS("abc");
    for (Int_t i = 0; i < subStrL->GetLast()+1; i++) {
       const TString subStr = ((TObjString *)subStrL->At(i))->GetString();
       std!cout << "\"" << subStr << "\" ";
    }
    std!cout << subStr << std!endl;

(C++ version of the code)

 produces: "abc" "a" "" "bc"

For meaning of mods see [ParseMods()](@ref).
""" MatchS(this::ByRef1{TPRegexp}, s::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMaxMatch::Int32)

# Wrapper of TPRegexp & TPRegexp::operator=(const TPRegexp &)
@trydoc raw"""
    assign(this::ByRef1{TPRegexp}, p::ByConstRef1{TPRegexp})::CxxRef1{TPRegexp}
Assignment operator.

""" assign(this::ByRef1{TPRegexp}, p::ByConstRef1{TPRegexp})

# Wrapper of void TPRegexp::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TPRegexp}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TPRegexp}, ::ByRef1{TBuffer})

# Wrapper of void TPRegexp::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TPRegexp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TPRegexp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TPRegexp::Substitute(TString &, const TString &, const TString &, Int_t, Int_t)
@trydoc raw"""
    Substitute(this::ByRef1{TPRegexp}, s::ByRef1{TString}, replace::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMatchMax::Int32)::Int32
Substitute replaces the string s by a new string in which matching patterns are replaced by the replacePattern string.
The number of substitutions are returned. 

    TString s("aap noot mies");
    const Int_t nrSub = TPRegexp("(\\w*) noot (\\w*)").Substitute(s,"$2 noot $1");
    std!cout << nrSub << " \"" << s << "\"" <<std!endl;

(C++ version of the code)

 produces: 2 "mies noot aap"

For meaning of mods see [ParseMods()](@ref).
""" Substitute(this::ByRef1{TPRegexp}, s::ByRef1{TString}, replace::ByConstRef1{TString}, mods::ByConstRef1{TString}, thestart::Int32, nMatchMax::Int32)

# Wrapper of Int_t TVirtualMutex::Acquire()
@trydoc raw"""
    Acquire(this::ByRef1{TVirtualMutex})::Int32


""" Acquire(this::ByRef1{TVirtualMutex})

# Wrapper of Int_t TVirtualMutex::CleanUp()
@trydoc raw"""
    CleanUp(this::ByRef1{TVirtualMutex})::Int32


""" CleanUp(this::ByRef1{TVirtualMutex})

# Wrapper of TVirtualMutex * TVirtualMutex::Factory(Bool_t)
@trydoc raw"""
    Factory(this::ByRef1{TVirtualMutex}, ::Bool)::CxxPtr1{TVirtualMutex}


""" Factory(this::ByRef1{TVirtualMutex}, ::Bool)

# Wrapper of Int_t TVirtualMutex::Lock()
@trydoc raw"""
    Lock(this::ByRef1{TVirtualMutex})::Int32


""" Lock(this::ByRef1{TVirtualMutex})

# Wrapper of Int_t TVirtualMutex::Release()
@trydoc raw"""
    Release(this::ByRef1{TVirtualMutex})::Int32


""" Release(this::ByRef1{TVirtualMutex})

# Wrapper of void TVirtualMutex::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualMutex}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualMutex}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualMutex::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualMutex}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualMutex}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TVirtualMutex::TryLock()
@trydoc raw"""
    TryLock(this::ByRef1{TVirtualMutex})::Int32


""" TryLock(this::ByRef1{TVirtualMutex})

# Wrapper of Int_t TVirtualMutex::UnLock()
@trydoc raw"""
    UnLock(this::ByRef1{TVirtualMutex})::Int32


""" UnLock(this::ByRef1{TVirtualMutex})

# Wrapper of void TLockGuard::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TLockGuard}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TLockGuard}, ::ByRef1{TBuffer})

# Wrapper of void TLockGuard::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TLockGuard}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TLockGuard}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TLockGuard::UnLock()
@trydoc raw"""
    UnLock(this::ByRef1{TLockGuard})::Int32


""" UnLock(this::ByRef1{TLockGuard})

# Wrapper of TIter & TIter::Begin()
@trydoc raw"""
    Begin(this::ByRef1{TIter})::CxxRef1{TIter}
Pointing to the first element of the container.

""" Begin(this::ByRef1{TIter})

# Wrapper of TObject * TIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TIter})::CxxPtr1{TObject}


""" Next(this::ByRef1{TIter})

# Wrapper of TObject * TIter::operator()()
@trydoc raw"""
    paren(this::ByRef1{TIter})::CxxPtr1{TObject}


""" paren(this::ByRef1{TIter})

# Wrapper of TIter & TIter::operator++()
@trydoc raw"""
    inc!(this::ByRef1{TIter})::CxxRef1{TIter}


""" inc!(this::ByRef1{TIter})

# Wrapper of TIter & TIter::operator=(const TIter &)
@trydoc raw"""
    assign(this::ByRef1{TIter}, rhs::ByConstRef1{TIter})::CxxRef1{TIter}
Assigning an [TIter](@ref) to another.
This involves allocating a new [TIterator](@ref) of the right sub class and assigning it with the original.
""" assign(this::ByRef1{TIter}, rhs::ByConstRef1{TIter})

# Wrapper of TIter & TIter::operator=(TIterator *)
@trydoc raw"""
    assign(this::ByRef1{TIter}, iter::ByPtr1{TIterator})::CxxRef1{TIter}


""" assign(this::ByRef1{TIter}, iter::ByPtr1{TIterator})

# Wrapper of void TIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TIter})::Nothing


""" Reset(this::ByRef1{TIter})

# Wrapper of TObject * TIterator::Next()
@trydoc raw"""
    Next(this::ByRef1{TIterator})::CxxPtr1{TObject}


""" Next(this::ByRef1{TIterator})

# Wrapper of TObject * TIterator::operator()()
@trydoc raw"""
    paren(this::ByRef1{TIterator})::CxxPtr1{TObject}


""" paren(this::ByRef1{TIterator})

# Wrapper of TIterator & TIterator::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TIterator}, ::ByConstRef1{TIterator})::CxxRef1{TIterator}


""" assign(this::ByRef1{TIterator}, ::ByConstRef1{TIterator})

# Wrapper of void TIterator::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TIterator})::Nothing


""" Reset(this::ByRef1{TIterator})

# Wrapper of void TSeqCollection::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject})

# Wrapper of void TSeqCollection::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TSeqCollection}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing


""" AddAfter(this::ByRef1{TSeqCollection}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TSeqCollection::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject}, idx::Int32)::Nothing


""" AddAt(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TSeqCollection::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TSeqCollection}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing


""" AddBefore(this::ByRef1{TSeqCollection}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TSeqCollection::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject})::Nothing


""" AddFirst(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject})

# Wrapper of void TSeqCollection::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject})::Nothing


""" AddLast(this::ByRef1{TSeqCollection}, obj::ByPtr1{TObject})

# Wrapper of Long64_t TSeqCollection::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TSeqCollection}, list::ByPtr1{TCollection})::Int64
Merge this collection with all collections coming in the input list.
The input list must contain other collections of objects compatible with the ones in this collection and ordered in the same manner. For example, if this collection contains a [TH1](@ref) object and a tree, all collections in the input list have to contain a histogram and a tree. In case the list contains collections, the objects in the input lists must also be collections with the same structure and number of objects. If some objects inside the collection are instances of a class that do not have a Merge function (like [TObjString](@ref)), rather than merging, a copy of each instance (via a call to Clone) is appended to the output.

### Example

      this                          list
    ____________                  ---------------------|
    | A (TH1F) |  __________      | L1 (TSeqCollection)|- [A1, B1(C1,D1,E1)]
    | B (TList)|-| C (TTree)|     | L1 (TSeqCollection)|- [A2, B2(C2,D2,E2)]
    |__________| | D (TH1F) |     | ...                |- [...]
                 | E (TH1F) |     |____________________|
                 |__________|

(C++ version of the code)
""" Merge(this::ByRef1{TSeqCollection}, list::ByPtr1{TCollection})

# Wrapper of void TSeqCollection::RemoveAfter(TObject *)
@trydoc raw"""
    RemoveAfter(this::ByRef1{TSeqCollection}, after::ByPtr1{TObject})::Nothing


""" RemoveAfter(this::ByRef1{TSeqCollection}, after::ByPtr1{TObject})

# Wrapper of TObject * TSeqCollection::RemoveAt(Int_t)
@trydoc raw"""
    RemoveAt(this::ByRef1{TSeqCollection}, idx::Int32)::CxxPtr1{TObject}


""" RemoveAt(this::ByRef1{TSeqCollection}, idx::Int32)

# Wrapper of void TSeqCollection::RemoveBefore(TObject *)
@trydoc raw"""
    RemoveBefore(this::ByRef1{TSeqCollection}, before::ByPtr1{TObject})::Nothing


""" RemoveBefore(this::ByRef1{TSeqCollection}, before::ByPtr1{TObject})

# Wrapper of void TSeqCollection::RemoveFirst()
@trydoc raw"""
    RemoveFirst(this::ByRef1{TSeqCollection})::Nothing


""" RemoveFirst(this::ByRef1{TSeqCollection})

# Wrapper of void TSeqCollection::RemoveLast()
@trydoc raw"""
    RemoveLast(this::ByRef1{TSeqCollection})::Nothing


""" RemoveLast(this::ByRef1{TSeqCollection})

# Wrapper of void TSeqCollection::UnSort()
@trydoc raw"""
    UnSort(this::ByRef1{TSeqCollection})::Nothing


""" UnSort(this::ByRef1{TSeqCollection})

# Wrapper of void TList::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TList}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TList}, obj::ByPtr1{TObject})

# Wrapper of void TList::Add(TObject *, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing


""" Add(this::ByRef1{TList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TList::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TList}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object after object after in the list.

""" AddAfter(this::ByRef1{TList}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TList::AddAfter(TObjLink *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TList}, after::ByPtr1{TObjLink}, obj::ByPtr1{TObject})::Nothing
Insert object after the specified ObjLink object.
If after = 0 then add to the tail of the list. An ObjLink can be obtained by looping over a list using the above describe iterator method 3.
""" AddAfter(this::ByRef1{TList}, after::ByPtr1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void TList::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TList}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Insert object at position idx in the list.

""" AddAt(this::ByRef1{TList}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TList::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TList}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object before object before in the list.

""" AddBefore(this::ByRef1{TList}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TList::AddBefore(TObjLink *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TList}, before::ByPtr1{TObjLink}, obj::ByPtr1{TObject})::Nothing
Insert object before the specified ObjLink object.
If before = 0 then add to the head of the list. An ObjLink can be obtained by looping over a list using the above describe iterator method 3.
""" AddBefore(this::ByRef1{TList}, before::ByPtr1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void TList::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TList}, obj::ByPtr1{TObject})::Nothing
Add object at the beginning of the list.

""" AddFirst(this::ByRef1{TList}, obj::ByPtr1{TObject})

# Wrapper of void TList::AddFirst(TObject *, Option_t *)
@trydoc raw"""
    AddFirst(this::ByRef1{TList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object at the beginning of the list and also store option.
Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the [Draw()](@ref) method. It allows the same object to be drawn in different ways.
""" AddFirst(this::ByRef1{TList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TList::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TList}, obj::ByPtr1{TObject})::Nothing
Add object at the theend of the list.

""" AddLast(this::ByRef1{TList}, obj::ByPtr1{TObject})

# Wrapper of void TList::AddLast(TObject *, Option_t *)
@trydoc raw"""
    AddLast(this::ByRef1{TList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object at the theend of the list and also store option.
Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the [Draw()](@ref) method. It allows the same object to be drawn in different ways.
""" AddLast(this::ByRef1{TList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TList::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TList}, option::ByCopy{String})::Nothing
Remove all objects from the list.
Does not delete the objects unless the [TList](@ref) is the owner (set via [SetOwner()](@ref)) and option "nodelete" is not set. If option="nodelete" then don't delete any heap objects that were marked with the kCanDelete bit, otherwise these objects will be deleted (this option is used by [THashTable!Clear()](@ref)).
""" Clear(this::ByRef1{TList}, option::ByCopy{String})

# Wrapper of void TList::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TList}, option::ByCopy{String})::Nothing
Remove all objects from the list AND delete all heap based objects.
If option="slow" then keep list consistent during delete. This allows recursive list operations during the delete (e.g. during the dtor of an object in this list one can still access the list to search for other not yet deleted objects).
""" Delete(this::ByRef1{TList}, option::ByCopy{String})

# Wrapper of Bool_t TList::IsAscending()
@trydoc raw"""
    IsAscending(this::ByRef1{TList})::Bool


""" IsAscending(this::ByRef1{TList})

# Wrapper of void TList::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TList}, obj::ByPtr1{TObject})::Nothing
Remove object from this collection and recursively remove the object from all other objects (and collections).

""" RecursiveRemove(this::ByRef1{TList}, obj::ByPtr1{TObject})

# Wrapper of TObject * TList::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TList}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from the list.

""" Remove(this::ByRef1{TList}, obj::ByPtr1{TObject})

# Wrapper of TObject * TList::Remove(TObjLink *)
@trydoc raw"""
    Remove(this::ByRef1{TList}, lnk::ByPtr1{TObjLink})::CxxPtr1{TObject}
Remove object link (and therefore the object it contains) from the list.

""" Remove(this::ByRef1{TList}, lnk::ByPtr1{TObjLink})

# Wrapper of void TList::RemoveLast()
@trydoc raw"""
    RemoveLast(this::ByRef1{TList})::Nothing
Remove the last object of the list.

""" RemoveLast(this::ByRef1{TList})

# Wrapper of void TList::Sort(Bool_t)
@trydoc raw"""
    Sort(this::ByRef1{TList}, order::Bool)::Nothing
Sort linked list.
Real sorting is done in private function [DoSort()](@ref). The list can only be sorted when is contains objects of a sortable class.
""" Sort(this::ByRef1{TList}, order::Bool)

# Wrapper of TObject ** TObjLink::GetObjectRef()
@trydoc raw"""
    GetObjectRef(this::ByRef1{TObjLink})::CxxPtr1{TObject}


""" GetObjectRef(this::ByRef1{TObjLink})

# Wrapper of TObjLink * TObjLink::Next()
@trydoc raw"""
    Next(this::ByRef1{TObjLink})::CxxPtr1{TObjLink}


""" Next(this::ByRef1{TObjLink})

# Wrapper of TObjLink * TObjLink::Prev()
@trydoc raw"""
    Prev(this::ByRef1{TObjLink})::CxxPtr1{TObjLink}


""" Prev(this::ByRef1{TObjLink})

# Wrapper of void TObjLink::SetObject(TObject *)
@trydoc raw"""
    SetObject(this::ByRef1{TObjLink}, obj::ByPtr1{TObject})::Nothing


""" SetObject(this::ByRef1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void TObjLink::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TObjLink}, ::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TObjLink}, ::ByCopy{String})

# Wrapper of void TObjOptLink::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TObjOptLink}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TObjOptLink}, option::ByCopy{String})

# Wrapper of TObject * TListIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TListIter})::CxxPtr1{TObject}
Return next object in the list. Returns 0 when no more objects in list.

""" Next(this::ByRef1{TListIter})

# Wrapper of TIterator & TListIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TListIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TListIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TListIter & TListIter::operator=(const TListIter &)
@trydoc raw"""
    assign(this::ByRef1{TListIter}, rhs::ByConstRef1{TListIter})::CxxRef1{TListIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TListIter}, rhs::ByConstRef1{TListIter})

# Wrapper of void TListIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TListIter})::Nothing
Reset list iterator.

""" Reset(this::ByRef1{TListIter})

# Wrapper of void TListIter::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TListIter}, option::ByCopy{String})::Nothing
Sets the object option stored in the list.

""" SetOption(this::ByRef1{TListIter}, option::ByCopy{String})

# Wrapper of void TVirtualQConnection::SendSignal()
@trydoc raw"""
    SendSignal(this::ByRef1{TVirtualQConnection})::Nothing


""" SendSignal(this::ByRef1{TVirtualQConnection})

# Wrapper of void TVirtualQConnection::SetArgs(const Longptr_t *, Int_t)
@trydoc raw"""
    SetArgs(this::ByRef1{TVirtualQConnection}, argArray::ByConstPtr2{Int64}, nargs::Int32)::Nothing
Sets an array of arguments passed as a pointer type and size.
If nargs is not specified the number of arguments expected by the slot is used.
""" SetArgs(this::ByRef1{TVirtualQConnection}, argArray::ByConstPtr2{Int64}, nargs::Int32)

# Wrapper of Bool_t TQObject::BlockSignals(Bool_t)
@trydoc raw"""
    BlockSignals(this::ByRef1{TQObject}, b::Bool)::Bool


""" BlockSignals(this::ByRef1{TQObject}, b::Bool)

# Wrapper of void TQObject::ChangedBy(const char *)
@trydoc raw"""
    ChangedBy(this::ByRef1{TQObject}, method::ByCopy{String})::Nothing


""" ChangedBy(this::ByRef1{TQObject}, method::ByCopy{String})

# Wrapper of void TQObject::CollectClassSignalLists(TList &, TClass *)
@trydoc raw"""
    CollectClassSignalLists(this::ByRef1{TQObject}, list::ByRef1{TList}, cls::ByPtr1{TClass})::Nothing
Collect class signal lists from class cls and all its base-classes.
The recursive traversal is not performed for classes not deriving from [TQClass](@ref).
""" CollectClassSignalLists(this::ByRef1{TQObject}, list::ByRef1{TList}, cls::ByPtr1{TClass})

# Wrapper of Bool_t TQObject::Connect(const char *, const char *, void *, const char *)
@trydoc raw"""
    Connect(this::ByRef1{TQObject}, signal::ByCopy{String}, receiver_class::ByCopy{String}, receiver::ByPtr2{Nothing}, slot::ByCopy{String})::Bool
Non-static method is used to connect from the signal of this object to the receiver slot.
Warning! No check on consistency of sender/receiver classes/methods.

This method makes possible to have connection/signals from interpreted class. See also RQ_OBJECT.h.
""" Connect(this::ByRef1{TQObject}, signal::ByCopy{String}, receiver_class::ByCopy{String}, receiver::ByPtr2{Nothing}, slot::ByCopy{String})

# Wrapper of void TQObject::Connected(const char *)
@trydoc raw"""
    Connected(this::ByRef1{TQObject}, ::ByCopy{String})::Nothing


""" Connected(this::ByRef1{TQObject}, ::ByCopy{String})

# Wrapper of void TQObject::Destroyed()
@trydoc raw"""
    Destroyed(this::ByRef1{TQObject})::Nothing


""" Destroyed(this::ByRef1{TQObject})

# Wrapper of Bool_t TQObject::Disconnect(const char *, void *, const char *)
@trydoc raw"""
    Disconnect(this::ByRef1{TQObject}, signal::ByCopy{String}, receiver::ByPtr2{Nothing}, slot::ByCopy{String})::Bool
Disconnects signal of this object from slot of receiver.
Equivalent to Disconnect(this, signal, receiver, slot)
""" Disconnect(this::ByRef1{TQObject}, signal::ByCopy{String}, receiver::ByPtr2{Nothing}, slot::ByCopy{String})

# Wrapper of void TQObject::Disconnected(const char *)
@trydoc raw"""
    Disconnected(this::ByRef1{TQObject}, ::ByCopy{String})::Nothing


""" Disconnected(this::ByRef1{TQObject}, ::ByCopy{String})

# Wrapper of void TQObject::Emit(const char *)
@trydoc raw"""
    Emit(this::ByRef1{TQObject}, signal::ByCopy{String})::Nothing
Activate signal without args.
Example: theButton->Emit("Clicked()");
""" Emit(this::ByRef1{TQObject}, signal::ByCopy{String})

# Wrapper of void TQObject::HighPriority(const char *, const char *)
@trydoc raw"""
    HighPriority(this::ByRef1{TQObject}, signal_name::ByCopy{String}, slot_name::ByCopy{String})::Nothing

1. If slot_name = 0 => makes signal defined by the signal_name to be the first in the fListOfSignals, this decreases the time for lookup.
2. If slot_name != 0 => makes slot defined by the slot_name to be executed first when signal_name is emitted. Signal name is not compressed.
""" HighPriority(this::ByRef1{TQObject}, signal_name::ByCopy{String}, slot_name::ByCopy{String})

# Wrapper of void TQObject::LowPriority(const char *, const char *)
@trydoc raw"""
    LowPriority(this::ByRef1{TQObject}, signal_name::ByCopy{String}, slot_name::ByCopy{String})::Nothing

1. If slot_name = 0 => makes signal defined by the signal_name to be the last in the fListOfSignals, this increase the time for lookup.
2. If slot_name != 0 => makes slot defined by the slot_name to be executed last when signal_name is emitted. Signal name is not compressed.
""" LowPriority(this::ByRef1{TQObject}, signal_name::ByCopy{String}, slot_name::ByCopy{String})

# Wrapper of void TQObject::Message(const char *)
@trydoc raw"""
    Message(this::ByRef1{TQObject}, msg::ByCopy{String})::Nothing


""" Message(this::ByRef1{TQObject}, msg::ByCopy{String})

# Wrapper of void TQObject::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TQObject}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TQObject}, ::ByRef1{TBuffer})

# Wrapper of void TQObject::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TQObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TQObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TQObjSender::SetSender(void *)
@trydoc raw"""
    SetSender(this::ByRef1{TQObjSender}, sender::ByPtr2{Nothing})::Nothing


""" SetSender(this::ByRef1{TQObjSender}, sender::ByPtr2{Nothing})

# Wrapper of void TQObjSender::SetSenderClassName(const char *)
@trydoc raw"""
    SetSenderClassName(this::ByRef1{TQObjSender}, sclass::ByCopy{String})::Nothing


""" SetSenderClassName(this::ByRef1{TQObjSender}, sclass::ByCopy{String})

# Wrapper of void TQObjSender::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TQObjSender}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TQObjSender}, ::ByRef1{TBuffer})

# Wrapper of void TQObjSender::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TQObjSender}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TQObjSender}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TApplication::ClearInputFiles()
@trydoc raw"""
    ClearInputFiles(this::ByRef1{TApplication})::Nothing
Clear list containing macro files passed as program arguments.
This method is called from [TRint!Run()](@ref) to ensure that the macro files are only executed the first time [Run()](@ref) is called.
""" ClearInputFiles(this::ByRef1{TApplication})

# Wrapper of TApplicationImp * TApplication::GetApplicationImp()
@trydoc raw"""
    GetApplicationImp(this::ByRef1{TApplication})::CxxPtr1{TApplicationImp}


""" GetApplicationImp(this::ByRef1{TApplication})

# Wrapper of void TApplication::GetOptions(Int_t *, char **)
@trydoc raw"""
    GetOptions(this::ByRef1{TApplication}, argc::ByPtr2{Int32}, argv::ByPtr2{Int8})::Nothing
Get and handle command line options.
Arguments handled are removed from the argument array. See CommandLineOptionsHelp.h for options.
""" GetOptions(this::ByRef1{TApplication}, argc::ByPtr2{Int32}, argv::ByPtr2{Int8})

# Wrapper of TString TApplication::GetSetup()
@trydoc raw"""
    GetSetup(this::ByRef1{TApplication})::ByCopy{TString}
It gets the [ROOT](@ref) installation setup as [TString](@ref).
###Return

a string with several lines
""" GetSetup(this::ByRef1{TApplication})

# Wrapper of void TApplication::HandleException(Int_t)
@trydoc raw"""
    HandleException(this::ByRef1{TApplication}, sig::Int32)::Nothing
Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in [TSystem](@ref).
Specific [TApplication](@ref) implementations may want something different here.
""" HandleException(this::ByRef1{TApplication}, sig::Int32)

# Wrapper of void TApplication::HandleIdleTimer()
@trydoc raw"""
    HandleIdleTimer(this::ByRef1{TApplication})::Nothing
Handle idle timeout.
When this timer expires the registered idle command will be executed by this routine and a signal will be emitted.
""" HandleIdleTimer(this::ByRef1{TApplication})

# Wrapper of Bool_t TApplication::HandleTermInput()
@trydoc raw"""
    HandleTermInput(this::ByRef1{TApplication})::Bool


""" HandleTermInput(this::ByRef1{TApplication})

# Wrapper of void TApplication::Hide()
@trydoc raw"""
    Hide(this::ByRef1{TApplication})::Nothing


""" Hide(this::ByRef1{TApplication})

# Wrapper of void TApplication::Iconify()
@trydoc raw"""
    Iconify(this::ByRef1{TApplication})::Nothing


""" Iconify(this::ByRef1{TApplication})

# Wrapper of void TApplication::Init()
@trydoc raw"""
    Init(this::ByRef1{TApplication})::Nothing


""" Init(this::ByRef1{TApplication})

# Wrapper of void TApplication::InitializeGraphics(Bool_t)
@trydoc raw"""
    InitializeGraphics(this::ByRef1{TApplication}, only_web::Bool)::Nothing
Initialize the graphics environment.
If## Arguments

- **`only_web`** 
    is specified, only web-related part of graphics is loaded
""" InitializeGraphics(this::ByRef1{TApplication}, only_web::Bool)

# Wrapper of Bool_t TApplication::IsCmdThread()
@trydoc raw"""
    IsCmdThread(this::ByRef1{TApplication})::Bool


""" IsCmdThread(this::ByRef1{TApplication})

# Wrapper of void TApplication::KeyPressed(Int_t)
@trydoc raw"""
    KeyPressed(this::ByRef1{TApplication}, key::Int32)::Nothing
Emit signal when console keyboard key was pressed.

""" KeyPressed(this::ByRef1{TApplication}, key::Int32)

# Wrapper of void TApplication::LineProcessed(const char *)
@trydoc raw"""
    LineProcessed(this::ByRef1{TApplication}, line::ByCopy{String})::Nothing
Emit signal when a line has been processed.

""" LineProcessed(this::ByRef1{TApplication}, line::ByCopy{String})

# Wrapper of void TApplication::Lower()
@trydoc raw"""
    Lower(this::ByRef1{TApplication})::Nothing


""" Lower(this::ByRef1{TApplication})

# Wrapper of void TApplication::Open()
@trydoc raw"""
    Open(this::ByRef1{TApplication})::Nothing


""" Open(this::ByRef1{TApplication})

# Wrapper of void TApplication::OpenForumTopic(const TString &)
@trydoc raw"""
    OpenForumTopic(this::ByRef1{TApplication}, type::ByConstRef1{TString})::Nothing
It opens a Forum topic in a web browser with prefilled [ROOT](@ref) version.
## Arguments

- **`type`** [in] 
    the issue type (only bug supported right now)
""" OpenForumTopic(this::ByRef1{TApplication}, type::ByConstRef1{TString})

# Wrapper of void TApplication::OpenGitHubIssue(const TString &)
@trydoc raw"""
    OpenGitHubIssue(this::ByRef1{TApplication}, type::ByConstRef1{TString})::Nothing
It opens a GitHub issue in a web browser with prefilled [ROOT](@ref) version.
## Arguments

- **`type`** [in] 
    the issue type (bug, feature or improvement)
""" OpenGitHubIssue(this::ByRef1{TApplication}, type::ByConstRef1{TString})

# Wrapper of void TApplication::OpenInBrowser(const TString &)
@trydoc raw"""
    OpenInBrowser(this::ByRef1{TApplication}, url::ByConstRef1{TString})::Nothing
The function generates and executes a command that loads the Doxygen URL in a browser.
It works for Mac, Windows and Linux. In the case of Linux, the function also checks if the DISPLAY is set. If it isn't, a warning message and the URL will be displayed on the terminal.

## Arguments

- **`url`** [in] 
    web page to be displayed in a browser
""" OpenInBrowser(this::ByRef1{TApplication}, url::ByConstRef1{TString})

# Wrapper of void TApplication::OpenReferenceGuideFor(const TString &)
@trydoc raw"""
    OpenReferenceGuideFor(this::ByRef1{TApplication}, strippedClass::ByConstRef1{TString})::Nothing
It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator.
If the user types incorrect value, it will return an error or warning.

## Arguments

- **`strippedClass`** [in] 
    the scope or scope!member
""" OpenReferenceGuideFor(this::ByRef1{TApplication}, strippedClass::ByConstRef1{TString})

# Wrapper of Longptr_t TApplication::ProcessFile(const char *, Int_t *, Bool_t)
@trydoc raw"""
    ProcessFile(this::ByRef1{TApplication}, file::ByCopy{String}, error::ByPtr2{Int32}, keep::Bool)::Int64
Process a file containing a C++ macro.

""" ProcessFile(this::ByRef1{TApplication}, file::ByCopy{String}, error::ByPtr2{Int32}, keep::Bool)

# Wrapper of Longptr_t TApplication::ProcessLine(const char *, Bool_t, Int_t *)
@trydoc raw"""
    ProcessLine(this::ByRef1{TApplication}, line::ByCopy{String}, sync::Bool, error::ByPtr2{Int32})::Int64
Process a single command line, either a C++ statement or an interpreter command starting with a ".".
Return the return value of the command cast to a long.
""" ProcessLine(this::ByRef1{TApplication}, line::ByCopy{String}, sync::Bool, error::ByPtr2{Int32})

# Wrapper of void TApplication::Raise()
@trydoc raw"""
    Raise(this::ByRef1{TApplication})::Nothing


""" Raise(this::ByRef1{TApplication})

# Wrapper of void TApplication::RemoveIdleTimer()
@trydoc raw"""
    RemoveIdleTimer(this::ByRef1{TApplication})::Nothing
Remove idle timer. Normally called via TROOT!Idle(0).
""" RemoveIdleTimer(this::ByRef1{TApplication})

# Wrapper of void TApplication::ReturnPressed(char *)
@trydoc raw"""
    ReturnPressed(this::ByRef1{TApplication}, text::ByPtr2{Int8})::Nothing
Emit signal when return key was pressed.

""" ReturnPressed(this::ByRef1{TApplication}, text::ByPtr2{Int8})

# Wrapper of void TApplication::Run(Bool_t)
@trydoc raw"""
    Run(this::ByRef1{TApplication}, retrn::Bool)::Nothing
Main application eventloop. Calls system dependent eventloop via gSystem.

""" Run(this::ByRef1{TApplication}, retrn::Bool)

# Wrapper of void TApplication::SetEchoMode(Bool_t)
@trydoc raw"""
    SetEchoMode(this::ByRef1{TApplication}, mode::Bool)::Nothing
Set console echo mode:
- mode = kTRUE - echo input symbols
- mode = kFALSE - noecho input symbols
""" SetEchoMode(this::ByRef1{TApplication}, mode::Bool)

# Wrapper of void TApplication::SetIdleTimer(UInt_t, const char *)
@trydoc raw"""
    SetIdleTimer(this::ByRef1{TApplication}, idleTimeInSec::UInt32, command::ByCopy{String})::Nothing
Set the command to be executed after the system has been idle for idleTimeInSec seconds.
Normally called via TROOT!Idle(...).
""" SetIdleTimer(this::ByRef1{TApplication}, idleTimeInSec::UInt32, command::ByCopy{String})

# Wrapper of void TApplication::SetReturnFromRun(Bool_t)
@trydoc raw"""
    SetReturnFromRun(this::ByRef1{TApplication}, ret::Bool)::Nothing


""" SetReturnFromRun(this::ByRef1{TApplication}, ret::Bool)

# Wrapper of void TApplication::Show()
@trydoc raw"""
    Show(this::ByRef1{TApplication})::Nothing


""" Show(this::ByRef1{TApplication})

# Wrapper of void TApplication::StartIdleing()
@trydoc raw"""
    StartIdleing(this::ByRef1{TApplication})::Nothing
Called when system starts idleing.

""" StartIdleing(this::ByRef1{TApplication})

# Wrapper of void TApplication::StopIdleing()
@trydoc raw"""
    StopIdleing(this::ByRef1{TApplication})::Nothing
Called when system stops idleing.

""" StopIdleing(this::ByRef1{TApplication})

# Wrapper of void TApplication::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TApplication}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TApplication}, ::ByRef1{TBuffer})

# Wrapper of void TApplication::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TApplication}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TApplication}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TApplication::Terminate(Int_t)
@trydoc raw"""
    Terminate(this::ByRef1{TApplication}, status::Int32)::Nothing
Terminate the application by call [TSystem!Exit()](@ref) unless application has been told to return from [Run()](@ref), by a call to [SetReturnFromRun()](@ref).

""" Terminate(this::ByRef1{TApplication}, status::Int32)

# Wrapper of void TAtt3D::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAtt3D}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAtt3D}, ::ByRef1{TBuffer})

# Wrapper of void TAtt3D::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAtt3D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAtt3D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TAttAxis::ResetAttAxis(Option_t *)
@trydoc raw"""
    ResetAttAxis(this::ByRef1{TAttAxis}, option::ByCopy{String})::Nothing
Reset axis attributes.

""" ResetAttAxis(this::ByRef1{TAttAxis}, option::ByCopy{String})

# Wrapper of void TAttAxis::SetAxisColor(Color_t, Float_t)
@trydoc raw"""
    SetAxisColor(this::ByRef1{TAttAxis}, color::Int16, alpha::Float32)::Nothing
Set color of the line axis and tick marks.

""" SetAxisColor(this::ByRef1{TAttAxis}, color::Int16, alpha::Float32)

# Wrapper of void TAttAxis::SetLabelColor(Color_t, Float_t)
@trydoc raw"""
    SetLabelColor(this::ByRef1{TAttAxis}, color::Int16, alpha::Float32)::Nothing
Set color of labels.

""" SetLabelColor(this::ByRef1{TAttAxis}, color::Int16, alpha::Float32)

# Wrapper of void TAttAxis::SetLabelFont(Style_t)
@trydoc raw"""
    SetLabelFont(this::ByRef1{TAttAxis}, font::Int16)::Nothing
Set labels' font.

""" SetLabelFont(this::ByRef1{TAttAxis}, font::Int16)

# Wrapper of void TAttAxis::SetLabelOffset(Float_t)
@trydoc raw"""
    SetLabelOffset(this::ByRef1{TAttAxis}, offset::Float32)::Nothing
Set distance between the axis and the labels.
The distance is expressed in per cent of the pad width. A negative value allow to draw the label on the other side of the axis.
""" SetLabelOffset(this::ByRef1{TAttAxis}, offset::Float32)

# Wrapper of void TAttAxis::SetLabelSize(Float_t)
@trydoc raw"""
    SetLabelSize(this::ByRef1{TAttAxis}, size::Float32)::Nothing
Set size of axis labels.
The size is expressed in per cent of the pad size, unless the font precision is 3 and in that case the size is expressed in pixels.
""" SetLabelSize(this::ByRef1{TAttAxis}, size::Float32)

# Wrapper of void TAttAxis::SetMaxDigits(Int_t)
@trydoc raw"""
    SetMaxDigits(this::ByRef1{TAttAxis}, maxDigits::Int32)::Nothing
This function sets the maximum number of digits permitted for the axis labels above which the notation with 10^N is used.
For example, to accept 6 digits number like 900000 on the X axis of the histogram `h` call:

    h->GetXaxis()->SetMaxDigits(6);

(C++ version of the code)

The default value is 5.

The default value for all axis can be set with the static function `TGaxis!SetMaxDigits`.
""" SetMaxDigits(this::ByRef1{TAttAxis}, maxDigits::Int32)

# Wrapper of void TAttAxis::SetNdivisions(Int_t, Int_t, Int_t, Bool_t)
@trydoc raw"""
    SetNdivisions(this::ByRef1{TAttAxis}, n1::Int32, n2::Int32, n3::Int32, optim::Bool)::Nothing
Set the number of divisions for this axis using one `int` per division level.

""" SetNdivisions(this::ByRef1{TAttAxis}, n1::Int32, n2::Int32, n3::Int32, optim::Bool)

# Wrapper of void TAttAxis::SetNdivisions(Int_t, Bool_t)
@trydoc raw"""
    SetNdivisions(this::ByRef1{TAttAxis}, n::Int32, optim::Bool)::Nothing
Set the number of divisions for this axis.
- if optim = kTRUE (default), the number of divisions will be optimized around the specified value.
- if optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. 

        n = n1 + 100*n2 + 10000*n3

(C++ version of the code)

 Where n1 is the number of primary divisions, n2 is the number of second order divisions and n3 is the number of third order divisions.

If the number of divisions is "optimized" (see above) n1, n2, n3 are maximum values.

Examples:

- ndiv = 0: no tick marks.
- ndiv = 2: 2 divisions, one tick mark in the middle of the axis.
- ndiv = 510: 10 primary divisions, 5 secondary divisions.
- ndiv = -10: exactly 10 primary divisions.
""" SetNdivisions(this::ByRef1{TAttAxis}, n::Int32, optim::Bool)

# Wrapper of void TAttAxis::SetTickLength(Float_t)
@trydoc raw"""
    SetTickLength(this::ByRef1{TAttAxis}, length::Float32)::Nothing
Set tick mark length.
The length is expressed in per cent of the pad width.
""" SetTickLength(this::ByRef1{TAttAxis}, length::Float32)

# Wrapper of void TAttAxis::SetTickSize(Float_t)
@trydoc raw"""
    SetTickSize(this::ByRef1{TAttAxis}, size::Float32)::Nothing


""" SetTickSize(this::ByRef1{TAttAxis}, size::Float32)

# Wrapper of void TAttAxis::SetTitleColor(Color_t)
@trydoc raw"""
    SetTitleColor(this::ByRef1{TAttAxis}, color::Int16)::Nothing
Set color of axis title.

""" SetTitleColor(this::ByRef1{TAttAxis}, color::Int16)

# Wrapper of void TAttAxis::SetTitleFont(Style_t)
@trydoc raw"""
    SetTitleFont(this::ByRef1{TAttAxis}, font::Int16)::Nothing
Set the title font.

""" SetTitleFont(this::ByRef1{TAttAxis}, font::Int16)

# Wrapper of void TAttAxis::SetTitleOffset(Float_t)
@trydoc raw"""
    SetTitleOffset(this::ByRef1{TAttAxis}, offset::Float32)::Nothing
Set distance between the axis and the axis title.
Offset is a correction factor with respect to the "standard" value.

- offset = 1 uses standard position that is computed in function of the label offset and size.
- offset = 1.2 will add 20 per cent more to the standard offset.
- offset = 0 automatic placement for the Y axis title (default).
""" SetTitleOffset(this::ByRef1{TAttAxis}, offset::Float32)

# Wrapper of void TAttAxis::SetTitleSize(Float_t)
@trydoc raw"""
    SetTitleSize(this::ByRef1{TAttAxis}, size::Float32)::Nothing
Set size of axis title.
The size is expressed in per cent of the pad size, unless the font precision is 3 and in that case the size is expressed in pixels.
""" SetTitleSize(this::ByRef1{TAttAxis}, size::Float32)

# Wrapper of void TAttAxis::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttAxis}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TAttAxis](@ref).

""" Streamer(this::ByRef1{TAttAxis}, ::ByRef1{TBuffer})

# Wrapper of void TAttAxis::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttAxis}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttAxis}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TPoint::SetX(SCoord_t)
@trydoc raw"""
    SetX(this::ByRef1{TPoint}, x::Int16)::Nothing


""" SetX(this::ByRef1{TPoint}, x::Int16)

# Wrapper of void TPoint::SetY(SCoord_t)
@trydoc raw"""
    SetY(this::ByRef1{TPoint}, y::Int16)::Nothing


""" SetY(this::ByRef1{TPoint}, y::Int16)

# Wrapper of Float_t * TAttBBox::AssertBBox()
@trydoc raw"""
    AssertBBox(this::ByRef1{TAttBBox})::CxxPtr2{Float32}


""" AssertBBox(this::ByRef1{TAttBBox})

# Wrapper of void TAttBBox::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TAttBBox})::Nothing


""" ComputeBBox(this::ByRef1{TAttBBox})

# Wrapper of Float_t * TAttBBox::GetBBox()
@trydoc raw"""
    GetBBox(this::ByRef1{TAttBBox})::CxxPtr2{Float32}


""" GetBBox(this::ByRef1{TAttBBox})

# Wrapper of TAttBBox & TAttBBox::operator=(const TAttBBox &)
@trydoc raw"""
    assign(this::ByRef1{TAttBBox}, tab::ByConstRef1{TAttBBox})::CxxRef1{TAttBBox}


""" assign(this::ByRef1{TAttBBox}, tab::ByConstRef1{TAttBBox})

# Wrapper of void TAttBBox::ResetBBox()
@trydoc raw"""
    ResetBBox(this::ByRef1{TAttBBox})::Nothing


""" ResetBBox(this::ByRef1{TAttBBox})

# Wrapper of void TAttBBox::SetupBBoxCube(Float_t, Float_t, Float_t, Float_t)
@trydoc raw"""
    SetupBBoxCube(this::ByRef1{TAttBBox}, extent::Float32, x::Float32, y::Float32, z::Float32)::Nothing
Setup bounding box as cube with given extent and center position.

""" SetupBBoxCube(this::ByRef1{TAttBBox}, extent::Float32, x::Float32, y::Float32, z::Float32)

# Wrapper of void TAttBBox::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttBBox}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAttBBox}, ::ByRef1{TBuffer})

# Wrapper of void TAttBBox::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttBBox}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttBBox}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Rectangle_t TAttBBox2D::GetBBox()
@trydoc raw"""
    GetBBox(this::ByRef1{TAttBBox2D})::ByCopy{Rectangle_t}


""" GetBBox(this::ByRef1{TAttBBox2D})

# Wrapper of TPoint TAttBBox2D::GetBBoxCenter()
@trydoc raw"""
    GetBBoxCenter(this::ByRef1{TAttBBox2D})::ByCopy{TPoint}


""" GetBBoxCenter(this::ByRef1{TAttBBox2D})

# Wrapper of void TAttBBox2D::SetBBoxCenter(const TPoint &)
@trydoc raw"""
    SetBBoxCenter(this::ByRef1{TAttBBox2D}, p::ByConstRef1{TPoint})::Nothing


""" SetBBoxCenter(this::ByRef1{TAttBBox2D}, p::ByConstRef1{TPoint})

# Wrapper of void TAttBBox2D::SetBBoxCenterX(const Int_t)
@trydoc raw"""
    SetBBoxCenterX(this::ByRef1{TAttBBox2D}, x::ByCopy{Int32})::Nothing


""" SetBBoxCenterX(this::ByRef1{TAttBBox2D}, x::ByCopy{Int32})

# Wrapper of void TAttBBox2D::SetBBoxCenterY(const Int_t)
@trydoc raw"""
    SetBBoxCenterY(this::ByRef1{TAttBBox2D}, y::ByCopy{Int32})::Nothing


""" SetBBoxCenterY(this::ByRef1{TAttBBox2D}, y::ByCopy{Int32})

# Wrapper of void TAttBBox2D::SetBBoxX1(const Int_t)
@trydoc raw"""
    SetBBoxX1(this::ByRef1{TAttBBox2D}, x::ByCopy{Int32})::Nothing


""" SetBBoxX1(this::ByRef1{TAttBBox2D}, x::ByCopy{Int32})

# Wrapper of void TAttBBox2D::SetBBoxX2(const Int_t)
@trydoc raw"""
    SetBBoxX2(this::ByRef1{TAttBBox2D}, x::ByCopy{Int32})::Nothing


""" SetBBoxX2(this::ByRef1{TAttBBox2D}, x::ByCopy{Int32})

# Wrapper of void TAttBBox2D::SetBBoxY1(const Int_t)
@trydoc raw"""
    SetBBoxY1(this::ByRef1{TAttBBox2D}, y::ByCopy{Int32})::Nothing


""" SetBBoxY1(this::ByRef1{TAttBBox2D}, y::ByCopy{Int32})

# Wrapper of void TAttBBox2D::SetBBoxY2(const Int_t)
@trydoc raw"""
    SetBBoxY2(this::ByRef1{TAttBBox2D}, y::ByCopy{Int32})::Nothing


""" SetBBoxY2(this::ByRef1{TAttBBox2D}, y::ByCopy{Int32})

# Wrapper of void TAttBBox2D::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttBBox2D}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAttBBox2D}, ::ByRef1{TBuffer})

# Wrapper of void TAttBBox2D::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttBBox2D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttBBox2D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TAttFill::Modify()
@trydoc raw"""
    Modify(this::ByRef1{TAttFill})::Nothing
Change current fill area attributes if necessary.

""" Modify(this::ByRef1{TAttFill})

# Wrapper of void TAttFill::ResetAttFill(Option_t *)
@trydoc raw"""
    ResetAttFill(this::ByRef1{TAttFill}, option::ByCopy{String})::Nothing
Reset this fill attributes to default values.

""" ResetAttFill(this::ByRef1{TAttFill}, option::ByCopy{String})

# Wrapper of void TAttFill::SetFillAttributes()
@trydoc raw"""
    SetFillAttributes(this::ByRef1{TAttFill})::Nothing
Invoke the DialogCanvas Fill attributes.

""" SetFillAttributes(this::ByRef1{TAttFill})

# Wrapper of void TAttFill::SetFillColor(Color_t)
@trydoc raw"""
    SetFillColor(this::ByRef1{TAttFill}, fcolor::Int16)::Nothing
Set the fill area color.

""" SetFillColor(this::ByRef1{TAttFill}, fcolor::Int16)

# Wrapper of void TAttFill::SetFillColorAlpha(Color_t, Float_t)
@trydoc raw"""
    SetFillColorAlpha(this::ByRef1{TAttFill}, fcolor::Int16, falpha::Float32)::Nothing
Set a transparent fill color.
## Arguments

- **`fcolor`** 
    defines the fill color 
    
- **`falpha`** 
    defines the percentage of opacity from 0. (fully transparent) to 1. (fully opaque). 
    

###Note

falpha is ignored (treated as 1) if the TCanvas has no GL support activated.
""" SetFillColorAlpha(this::ByRef1{TAttFill}, fcolor::Int16, falpha::Float32)

# Wrapper of void TAttFill::SetFillStyle(Style_t)
@trydoc raw"""
    SetFillStyle(this::ByRef1{TAttFill}, fstyle::Int16)::Nothing
Set the fill area style.

""" SetFillStyle(this::ByRef1{TAttFill}, fstyle::Int16)

# Wrapper of void TAttFill::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttFill}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAttFill}, ::ByRef1{TBuffer})

# Wrapper of void TAttFill::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttFill}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttFill}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TAttLine::DistancetoLine(Int_t, Int_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DistancetoLine(this::ByRef1{TAttLine}, px::Int32, py::Int32, xp1::Float64, yp1::Float64, xp2::Float64, yp2::Float64)::Int32
Compute distance from point px,py to a line.
Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units.

Algorithm: 

      A(x1,y1)         P                             B(x2,y2)
      -----------------+------------------------------
                       |
                       |
                       |
                       |
                      M(x,y)
    Let us call  a = distance AM     A=a**2
                 b = distance BM     B=b**2
                 c = distance AB     C=c**2
                 d = distance PM     D=d**2
                 u = distance AP     U=u**2
                 v = distance BP     V=v**2     c = u + v
    D = A - U
    D = B - V  = B -(c-u)**2
       ==> u = (A -B +C)/2c

(C++ version of the code)
""" DistancetoLine(this::ByRef1{TAttLine}, px::Int32, py::Int32, xp1::Float64, yp1::Float64, xp2::Float64, yp2::Float64)

# Wrapper of void TAttLine::Modify()
@trydoc raw"""
    Modify(this::ByRef1{TAttLine})::Nothing
Change current line attributes if necessary.

""" Modify(this::ByRef1{TAttLine})

# Wrapper of void TAttLine::ResetAttLine(Option_t *)
@trydoc raw"""
    ResetAttLine(this::ByRef1{TAttLine}, option::ByCopy{String})::Nothing
Reset this line attributes to default values.

""" ResetAttLine(this::ByRef1{TAttLine}, option::ByCopy{String})

# Wrapper of void TAttLine::SetLineAttributes()
@trydoc raw"""
    SetLineAttributes(this::ByRef1{TAttLine})::Nothing
Invoke the DialogCanvas Line attributes.

""" SetLineAttributes(this::ByRef1{TAttLine})

# Wrapper of void TAttLine::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TAttLine}, lcolor::Int16)::Nothing
Set the line color.

""" SetLineColor(this::ByRef1{TAttLine}, lcolor::Int16)

# Wrapper of void TAttLine::SetLineColorAlpha(Color_t, Float_t)
@trydoc raw"""
    SetLineColorAlpha(this::ByRef1{TAttLine}, lcolor::Int16, lalpha::Float32)::Nothing
Set a transparent line color.
## Arguments

- **`lcolor`** 
    defines the line color 
    
- **`lalpha`** 
    defines the percentage of opacity from 0. (fully transparent) to 1. (fully opaque). 
    

###Note

lalpha is ignored (treated as 1) if the TCanvas has no GL support activated.
""" SetLineColorAlpha(this::ByRef1{TAttLine}, lcolor::Int16, lalpha::Float32)

# Wrapper of void TAttLine::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TAttLine}, lstyle::Int16)::Nothing
Set the line style.

""" SetLineStyle(this::ByRef1{TAttLine}, lstyle::Int16)

# Wrapper of void TAttLine::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TAttLine}, lwidth::Int16)::Nothing
Set the line width.

""" SetLineWidth(this::ByRef1{TAttLine}, lwidth::Int16)

# Wrapper of void TAttLine::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttLine}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAttLine}, ::ByRef1{TBuffer})

# Wrapper of void TAttLine::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttLine}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttLine}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TAttMarker::Modify()
@trydoc raw"""
    Modify(this::ByRef1{TAttMarker})::Nothing
Change current marker attributes if necessary.

""" Modify(this::ByRef1{TAttMarker})

# Wrapper of void TAttMarker::ResetAttMarker(Option_t *)
@trydoc raw"""
    ResetAttMarker(this::ByRef1{TAttMarker}, toption::ByCopy{String})::Nothing
Reset this marker attributes to the default values.

""" ResetAttMarker(this::ByRef1{TAttMarker}, toption::ByCopy{String})

# Wrapper of void TAttMarker::SetMarkerAttributes()
@trydoc raw"""
    SetMarkerAttributes(this::ByRef1{TAttMarker})::Nothing
Invoke the DialogCanvas Marker attributes.

""" SetMarkerAttributes(this::ByRef1{TAttMarker})

# Wrapper of void TAttMarker::SetMarkerColor(Color_t)
@trydoc raw"""
    SetMarkerColor(this::ByRef1{TAttMarker}, mcolor::Int16)::Nothing
Set the marker color.

""" SetMarkerColor(this::ByRef1{TAttMarker}, mcolor::Int16)

# Wrapper of void TAttMarker::SetMarkerColorAlpha(Color_t, Float_t)
@trydoc raw"""
    SetMarkerColorAlpha(this::ByRef1{TAttMarker}, mcolor::Int16, malpha::Float32)::Nothing
Set a transparent marker color.
## Arguments

- **`mcolor`** 
    defines the marker color 
    
- **`malpha`** 
    defines the percentage of opacity from 0. (fully transparent) to 1. (fully opaque). 
    

###Note

malpha is ignored (treated as 1) if the TCanvas has no GL support activated.
""" SetMarkerColorAlpha(this::ByRef1{TAttMarker}, mcolor::Int16, malpha::Float32)

# Wrapper of void TAttMarker::SetMarkerSize(Size_t)
@trydoc raw"""
    SetMarkerSize(this::ByRef1{TAttMarker}, msize::Float32)::Nothing
Set the marker size.
Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They are meant to be very fast to draw and are always drawn with the same number of pixels; therefore this method does not apply on them.
""" SetMarkerSize(this::ByRef1{TAttMarker}, msize::Float32)

# Wrapper of void TAttMarker::SetMarkerStyle(Style_t)
@trydoc raw"""
    SetMarkerStyle(this::ByRef1{TAttMarker}, mstyle::Int16)::Nothing
Set the marker style.

""" SetMarkerStyle(this::ByRef1{TAttMarker}, mstyle::Int16)

# Wrapper of void TAttMarker::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttMarker}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAttMarker}, ::ByRef1{TBuffer})

# Wrapper of void TAttMarker::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttMarker}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttMarker}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TAttPad::ResetAttPad(Option_t *)
@trydoc raw"""
    ResetAttPad(this::ByRef1{TAttPad}, option::ByCopy{String})::Nothing
Reset pad attributes.

""" ResetAttPad(this::ByRef1{TAttPad}, option::ByCopy{String})

# Wrapper of void TAttPad::SetAfile(Float_t)
@trydoc raw"""
    SetAfile(this::ByRef1{TAttPad}, afile::Float32)::Nothing


""" SetAfile(this::ByRef1{TAttPad}, afile::Float32)

# Wrapper of void TAttPad::SetAstat(Float_t)
@trydoc raw"""
    SetAstat(this::ByRef1{TAttPad}, astat::Float32)::Nothing


""" SetAstat(this::ByRef1{TAttPad}, astat::Float32)

# Wrapper of void TAttPad::SetBottomMargin(Float_t)
@trydoc raw"""
    SetBottomMargin(this::ByRef1{TAttPad}, bottommargin::Float32)::Nothing
Set Pad bottom margin in fraction of the pad height.

""" SetBottomMargin(this::ByRef1{TAttPad}, bottommargin::Float32)

# Wrapper of void TAttPad::SetFrameBorderMode(Int_t)
@trydoc raw"""
    SetFrameBorderMode(this::ByRef1{TAttPad}, mode::Int32)::Nothing


""" SetFrameBorderMode(this::ByRef1{TAttPad}, mode::Int32)

# Wrapper of void TAttPad::SetFrameBorderSize(Width_t)
@trydoc raw"""
    SetFrameBorderSize(this::ByRef1{TAttPad}, size::Int16)::Nothing


""" SetFrameBorderSize(this::ByRef1{TAttPad}, size::Int16)

# Wrapper of void TAttPad::SetFrameFillColor(Color_t)
@trydoc raw"""
    SetFrameFillColor(this::ByRef1{TAttPad}, color::Int16)::Nothing


""" SetFrameFillColor(this::ByRef1{TAttPad}, color::Int16)

# Wrapper of void TAttPad::SetFrameFillStyle(Style_t)
@trydoc raw"""
    SetFrameFillStyle(this::ByRef1{TAttPad}, styl::Int16)::Nothing


""" SetFrameFillStyle(this::ByRef1{TAttPad}, styl::Int16)

# Wrapper of void TAttPad::SetFrameLineColor(Color_t)
@trydoc raw"""
    SetFrameLineColor(this::ByRef1{TAttPad}, color::Int16)::Nothing


""" SetFrameLineColor(this::ByRef1{TAttPad}, color::Int16)

# Wrapper of void TAttPad::SetFrameLineStyle(Style_t)
@trydoc raw"""
    SetFrameLineStyle(this::ByRef1{TAttPad}, styl::Int16)::Nothing


""" SetFrameLineStyle(this::ByRef1{TAttPad}, styl::Int16)

# Wrapper of void TAttPad::SetFrameLineWidth(Width_t)
@trydoc raw"""
    SetFrameLineWidth(this::ByRef1{TAttPad}, width::Int16)::Nothing


""" SetFrameLineWidth(this::ByRef1{TAttPad}, width::Int16)

# Wrapper of void TAttPad::SetLeftMargin(Float_t)
@trydoc raw"""
    SetLeftMargin(this::ByRef1{TAttPad}, leftmargin::Float32)::Nothing
Set Pad left margin in fraction of the pad width.

""" SetLeftMargin(this::ByRef1{TAttPad}, leftmargin::Float32)

# Wrapper of void TAttPad::SetMargin(Float_t, Float_t, Float_t, Float_t)
@trydoc raw"""
    SetMargin(this::ByRef1{TAttPad}, left::Float32, right::Float32, bottom::Float32, top::Float32)::Nothing
Set all margins.

""" SetMargin(this::ByRef1{TAttPad}, left::Float32, right::Float32, bottom::Float32, top::Float32)

# Wrapper of void TAttPad::SetRightMargin(Float_t)
@trydoc raw"""
    SetRightMargin(this::ByRef1{TAttPad}, rightmargin::Float32)::Nothing
Set Pad right margin in fraction of the pad width.

""" SetRightMargin(this::ByRef1{TAttPad}, rightmargin::Float32)

# Wrapper of void TAttPad::SetTopMargin(Float_t)
@trydoc raw"""
    SetTopMargin(this::ByRef1{TAttPad}, topmargin::Float32)::Nothing
Set Pad top margin in fraction of the pad height.

""" SetTopMargin(this::ByRef1{TAttPad}, topmargin::Float32)

# Wrapper of void TAttPad::SetXfile(Float_t)
@trydoc raw"""
    SetXfile(this::ByRef1{TAttPad}, xfile::Float32)::Nothing


""" SetXfile(this::ByRef1{TAttPad}, xfile::Float32)

# Wrapper of void TAttPad::SetXstat(Float_t)
@trydoc raw"""
    SetXstat(this::ByRef1{TAttPad}, xstat::Float32)::Nothing


""" SetXstat(this::ByRef1{TAttPad}, xstat::Float32)

# Wrapper of void TAttPad::SetYfile(Float_t)
@trydoc raw"""
    SetYfile(this::ByRef1{TAttPad}, yfile::Float32)::Nothing


""" SetYfile(this::ByRef1{TAttPad}, yfile::Float32)

# Wrapper of void TAttPad::SetYstat(Float_t)
@trydoc raw"""
    SetYstat(this::ByRef1{TAttPad}, ystat::Float32)::Nothing


""" SetYstat(this::ByRef1{TAttPad}, ystat::Float32)

# Wrapper of void TAttPad::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttPad}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TAttPad](@ref).

""" Streamer(this::ByRef1{TAttPad}, ::ByRef1{TBuffer})

# Wrapper of void TAttPad::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttPad}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttPad}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Float_t TAttText::GetTextSizePercent(Float_t)
@trydoc raw"""
    GetTextSizePercent(this::ByRef1{TAttText}, size::Float32)::Float32
Return the text in percent of the pad size.
If the font precision is greater than 2, the text size returned is the size in pixel converted into percent of the pad size, otherwise the size returned is the same as the size given as input parameter.
""" GetTextSizePercent(this::ByRef1{TAttText}, size::Float32)

# Wrapper of void TAttText::Modify()
@trydoc raw"""
    Modify(this::ByRef1{TAttText})::Nothing
Change current text attributes if necessary.

""" Modify(this::ByRef1{TAttText})

# Wrapper of void TAttText::ResetAttText(Option_t *)
@trydoc raw"""
    ResetAttText(this::ByRef1{TAttText}, toption::ByCopy{String})::Nothing
Reset this text attributes to default values.

""" ResetAttText(this::ByRef1{TAttText}, toption::ByCopy{String})

# Wrapper of void TAttText::SetTextAlign(Short_t)
@trydoc raw"""
    SetTextAlign(this::ByRef1{TAttText}, align::Int16)::Nothing
Set the text alignment.

""" SetTextAlign(this::ByRef1{TAttText}, align::Int16)

# Wrapper of void TAttText::SetTextAngle(Float_t)
@trydoc raw"""
    SetTextAngle(this::ByRef1{TAttText}, tangle::Float32)::Nothing
Set the text angle.

""" SetTextAngle(this::ByRef1{TAttText}, tangle::Float32)

# Wrapper of void TAttText::SetTextAttributes()
@trydoc raw"""
    SetTextAttributes(this::ByRef1{TAttText})::Nothing
Invoke the DialogCanvas Text attributes.

""" SetTextAttributes(this::ByRef1{TAttText})

# Wrapper of void TAttText::SetTextColor(Color_t)
@trydoc raw"""
    SetTextColor(this::ByRef1{TAttText}, tcolor::Int16)::Nothing
Set the text color.

""" SetTextColor(this::ByRef1{TAttText}, tcolor::Int16)

# Wrapper of void TAttText::SetTextColorAlpha(Color_t, Float_t)
@trydoc raw"""
    SetTextColorAlpha(this::ByRef1{TAttText}, tcolor::Int16, talpha::Float32)::Nothing
Set a transparent text color.
## Arguments

- **`tcolor`** 
    defines the text color 
    
- **`talpha`** 
    defines the percentage of opacity from 0. (fully transparent) to 1. (fully opaque). 
    

###Note

talpha is ignored (treated as 1) if the TCanvas has no GL support activated.
""" SetTextColorAlpha(this::ByRef1{TAttText}, tcolor::Int16, talpha::Float32)

# Wrapper of void TAttText::SetTextFont(Font_t)
@trydoc raw"""
    SetTextFont(this::ByRef1{TAttText}, tfont::Int16)::Nothing
Set the text font.

""" SetTextFont(this::ByRef1{TAttText}, tfont::Int16)

# Wrapper of void TAttText::SetTextSize(Float_t)
@trydoc raw"""
    SetTextSize(this::ByRef1{TAttText}, tsize::Float32)::Nothing
Set the text size.

""" SetTextSize(this::ByRef1{TAttText}, tsize::Float32)

# Wrapper of void TAttText::SetTextSizePixels(Int_t)
@trydoc raw"""
    SetTextSizePixels(this::ByRef1{TAttText}, npixels::Int32)::Nothing
Set the text size in pixel.
Set the text size in pixels.

If the font precision is greater than 2, the text size is set to npixels, otherwise the text size is computed as a percent of the pad size.
""" SetTextSizePixels(this::ByRef1{TAttText}, npixels::Int32)

# Wrapper of void TAttText::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TAttText}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TAttText}, ::ByRef1{TBuffer})

# Wrapper of void TAttText::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TAttText}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TAttText}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TBase64::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TBase64}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TBase64}, ::ByRef1{TBuffer})

# Wrapper of void TBase64::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TBase64}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TBase64}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TStopwatch::Continue()
@trydoc raw"""
    Continue(this::ByRef1{TStopwatch})::Nothing
Resume a stopped stopwatch.
The stopwatch continues counting from the last [Start()](@ref) onwards (this is like the laptimer function).
""" Continue(this::ByRef1{TStopwatch})

# Wrapper of Double_t TStopwatch::CpuTime()
@trydoc raw"""
    CpuTime(this::ByRef1{TStopwatch})::Float64
Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the thestart and stop events.

""" CpuTime(this::ByRef1{TStopwatch})

# Wrapper of Double_t TStopwatch::RealTime()
@trydoc raw"""
    RealTime(this::ByRef1{TStopwatch})::Float64
Stop the stopwatch (if it is running) and return the realtime (in seconds) passed between the thestart and stop events.

""" RealTime(this::ByRef1{TStopwatch})

# Wrapper of void TStopwatch::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TStopwatch})::Nothing


""" Reset(this::ByRef1{TStopwatch})

# Wrapper of void TStopwatch::ResetCpuTime(Double_t)
@trydoc raw"""
    ResetCpuTime(this::ByRef1{TStopwatch}, time::Float64)::Nothing


""" ResetCpuTime(this::ByRef1{TStopwatch}, time::Float64)

# Wrapper of void TStopwatch::ResetRealTime(Double_t)
@trydoc raw"""
    ResetRealTime(this::ByRef1{TStopwatch}, time::Float64)::Nothing


""" ResetRealTime(this::ByRef1{TStopwatch}, time::Float64)

# Wrapper of void TStopwatch::Start(Bool_t)
@trydoc raw"""
    Start(this::ByRef1{TStopwatch}, reset::Bool)::Nothing
Start the stopwatch.
If reset is kTRUE reset the stopwatch before starting it (including the stopwatch counter). Use kFALSE to continue timing after a [Stop()](@ref) without resetting the stopwatch.
""" Start(this::ByRef1{TStopwatch}, reset::Bool)

# Wrapper of void TStopwatch::Stop()
@trydoc raw"""
    Stop(this::ByRef1{TStopwatch})::Nothing
Stop the stopwatch.

""" Stop(this::ByRef1{TStopwatch})

# Wrapper of void TStopwatch::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TStopwatch}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TStopwatch}, ::ByRef1{TBuffer})

# Wrapper of void TStopwatch::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TStopwatch}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TStopwatch}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Float_t TBenchmark::GetCpuTime(const char *)
@trydoc raw"""
    GetCpuTime(this::ByRef1{TBenchmark}, name::ByCopy{String})::Float32
Returns Cpu time used by Benchmark name.

""" GetCpuTime(this::ByRef1{TBenchmark}, name::ByCopy{String})

# Wrapper of Float_t TBenchmark::GetRealTime(const char *)
@trydoc raw"""
    GetRealTime(this::ByRef1{TBenchmark}, name::ByCopy{String})::Float32
Returns Realtime used by Benchmark name.

""" GetRealTime(this::ByRef1{TBenchmark}, name::ByCopy{String})

# Wrapper of void TBenchmark::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TBenchmark})::Nothing
Reset all Benchmarks.

""" Reset(this::ByRef1{TBenchmark})

# Wrapper of void TBenchmark::Show(const char *)
@trydoc raw"""
    Show(this::ByRef1{TBenchmark}, name::ByCopy{String})::Nothing
Stops Benchmark name and Prints results.

""" Show(this::ByRef1{TBenchmark}, name::ByCopy{String})

# Wrapper of void TBenchmark::Start(const char *)
@trydoc raw"""
    Start(this::ByRef1{TBenchmark}, name::ByCopy{String})::Nothing
Starts Benchmark with the specified name.
An independent timer (see class [TStopwatch](@ref)) is started. The name of the benchmark is entered into the list of benchmarks. Benchmark can be stopped via [TBenchmark!Stop()](@ref). Results can be printed via [TBenchmark!Print()](@ref). [TBenchmark!Show()](@ref) can be used to stop benchmark and print results. If name is an already existing benchmark, timing will resume. A summary of all benchmarks can be seen via [TBenchmark!Summary()](@ref).
""" Start(this::ByRef1{TBenchmark}, name::ByCopy{String})

# Wrapper of void TBenchmark::Stop(const char *)
@trydoc raw"""
    Stop(this::ByRef1{TBenchmark}, name::ByCopy{String})::Nothing
Terminates Benchmark with specified name.

""" Stop(this::ByRef1{TBenchmark}, name::ByCopy{String})

# Wrapper of void TBenchmark::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TBenchmark}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TBenchmark}, ::ByRef1{TBuffer})

# Wrapper of void TBenchmark::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TBenchmark}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TBenchmark}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TBenchmark::Summary(Float_t &, Float_t &)
@trydoc raw"""
    Summary(this::ByRef1{TBenchmark}, rt::ByRef2{Float32}, cp::ByRef2{Float32})::Nothing
Prints a summary of all benchmarks.

""" Summary(this::ByRef1{TBenchmark}, rt::ByRef2{Float32}, cp::ByRef2{Float32})

# Wrapper of void TBuffer3D::ClearSectionsValid()
@trydoc raw"""
    ClearSectionsValid(this::ByRef1{TBuffer3D})::Nothing
Clear any sections marked valid.

""" ClearSectionsValid(this::ByRef1{TBuffer3D})

# Wrapper of void TBuffer3D::SetLocalMasterIdentity()
@trydoc raw"""
    SetLocalMasterIdentity(this::ByRef1{TBuffer3D})::Nothing
Set kRaw tessellation section of buffer with supplied sizes.
Set fLocalMaster in section kCore to identity
""" SetLocalMasterIdentity(this::ByRef1{TBuffer3D})

# Wrapper of Bool_t TBuffer3D::SetRawSizes(UInt_t, UInt_t, UInt_t, UInt_t, UInt_t, UInt_t)
@trydoc raw"""
    SetRawSizes(this::ByRef1{TBuffer3D}, reqPnts::UInt32, reqPntsCapacity::UInt32, reqSegs::UInt32, reqSegsCapacity::UInt32, reqPols::UInt32, reqPolsCapacity::UInt32)::Bool
Set kRaw tessellation section of buffer with supplied sizes.

""" SetRawSizes(this::ByRef1{TBuffer3D}, reqPnts::UInt32, reqPntsCapacity::UInt32, reqSegs::UInt32, reqSegsCapacity::UInt32, reqPols::UInt32, reqPolsCapacity::UInt32)

# Wrapper of void TBuffer3D::SetSectionsValid(UInt_t)
@trydoc raw"""
    SetSectionsValid(this::ByRef1{TBuffer3D}, mask::UInt32)::Nothing


""" SetSectionsValid(this::ByRef1{TBuffer3D}, mask::UInt32)

# Wrapper of void TBuffer3D::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TBuffer3D}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TBuffer3D}, ::ByRef1{TBuffer})

# Wrapper of void TBuffer3D::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TBuffer3D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TBuffer3D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of TObject * TObjArrayIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TObjArrayIter})::CxxPtr1{TObject}
Return next object in array. Returns 0 when no more objects in array.

""" Next(this::ByRef1{TObjArrayIter})

# Wrapper of TIterator & TObjArrayIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TObjArrayIter & TObjArrayIter::operator=(const TObjArrayIter &)
@trydoc raw"""
    assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TObjArrayIter})::CxxRef1{TObjArrayIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TObjArrayIter})

# Wrapper of void TObjArrayIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TObjArrayIter})::Nothing
Reset array iterator.

""" Reset(this::ByRef1{TObjArrayIter})

# Wrapper of void TProcessID::CheckInit()
@trydoc raw"""
    CheckInit(this::ByRef1{TProcessID})::Nothing
Initialize fObjects.

""" CheckInit(this::ByRef1{TProcessID})

# Wrapper of void TProcessID::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TProcessID}, option::ByCopy{String})::Nothing
delete the [TObjArray](@ref) pointing to referenced objects this function is called by [TFile!Close](@ref)("R")
""" Clear(this::ByRef1{TProcessID}, option::ByCopy{String})

# Wrapper of Int_t TProcessID::DecrementCount()
@trydoc raw"""
    DecrementCount(this::ByRef1{TProcessID})::Int32
The reference fCount is used to delete the [TProcessID](@ref) in the [TFile](@ref) destructor when fCount = 0.

""" DecrementCount(this::ByRef1{TProcessID})

# Wrapper of TObject * TProcessID::GetObjectWithID(UInt_t)
@trydoc raw"""
    GetObjectWithID(this::ByRef1{TProcessID}, uid::UInt32)::CxxPtr1{TObject}
returns the [TObject](@ref) with unique identifier uid in the table of objects

""" GetObjectWithID(this::ByRef1{TProcessID}, uid::UInt32)

# Wrapper of Int_t TProcessID::IncrementCount()
@trydoc raw"""
    IncrementCount(this::ByRef1{TProcessID})::Int32
Increase the reference count to this object.

""" IncrementCount(this::ByRef1{TProcessID})

# Wrapper of void TProcessID::PutObjectWithID(TObject *, UInt_t)
@trydoc raw"""
    PutObjectWithID(this::ByRef1{TProcessID}, obj::ByPtr1{TObject}, uid::UInt32)::Nothing
stores the object at the uid th slot in the table of objects The object uniqued is set as well as its kMustCleanup bit

""" PutObjectWithID(this::ByRef1{TProcessID}, obj::ByPtr1{TObject}, uid::UInt32)

# Wrapper of void TProcessID::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TProcessID}, obj::ByPtr1{TObject})::Nothing
called by the object destructor remove reference to obj from the current table if it is referenced

""" RecursiveRemove(this::ByRef1{TProcessID}, obj::ByPtr1{TObject})

# Wrapper of void TProcessID::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TProcessID}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TProcessID}, ::ByRef1{TBuffer})

# Wrapper of void TProcessID::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TProcessID}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TProcessID}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TClonesArray::AbsorbObjects(TClonesArray *)
@trydoc raw"""
    AbsorbObjects(this::ByRef1{TClonesArray}, tc::ByPtr1{TClonesArray})::Nothing
Directly move the object pointers from tc without cloning (copying).
This [TClonesArray](@ref) takes over ownership of all of tc's object pointers. The tc array is left empty upon return.
""" AbsorbObjects(this::ByRef1{TClonesArray}, tc::ByPtr1{TClonesArray})

# Wrapper of void TClonesArray::AbsorbObjects(TClonesArray *, Int_t, Int_t)
@trydoc raw"""
    AbsorbObjects(this::ByRef1{TClonesArray}, tc::ByPtr1{TClonesArray}, idx1::Int32, idx2::Int32)::Nothing
Directly move the range of object pointers from tc without cloning (copying).
This [TClonesArray](@ref) takes over ownership of all of tc's object pointers from idx1 to idx2. The tc array is re-arranged by return.
""" AbsorbObjects(this::ByRef1{TClonesArray}, tc::ByPtr1{TClonesArray}, idx1::Int32, idx2::Int32)

# Wrapper of void TClonesArray::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TClonesArray}, ::ByConstPtr1{TObject}, ::ByPtr1{TObject})::Nothing


""" AddAfter(this::ByRef1{TClonesArray}, ::ByConstPtr1{TObject}, ::ByPtr1{TObject})

# Wrapper of void TClonesArray::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TClonesArray}, ::ByPtr1{TObject}, ::Int32)::Nothing


""" AddAt(this::ByRef1{TClonesArray}, ::ByPtr1{TObject}, ::Int32)

# Wrapper of void TClonesArray::AddAtAndExpand(TObject *, Int_t)
@trydoc raw"""
    AddAtAndExpand(this::ByRef1{TClonesArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position idx.
If idx is larger than the current size of the array, expand the array (double its size).
""" AddAtAndExpand(this::ByRef1{TClonesArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of Int_t TClonesArray::AddAtFree(TObject *)
@trydoc raw"""
    AddAtFree(this::ByRef1{TClonesArray}, obj::ByPtr1{TObject})::Int32
Return the position of the new object.
Find the first empty cell or AddLast if there is no empty cell
""" AddAtFree(this::ByRef1{TClonesArray}, obj::ByPtr1{TObject})

# Wrapper of void TClonesArray::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TClonesArray}, ::ByConstPtr1{TObject}, ::ByPtr1{TObject})::Nothing


""" AddBefore(this::ByRef1{TClonesArray}, ::ByConstPtr1{TObject}, ::ByPtr1{TObject})

# Wrapper of void TClonesArray::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TClonesArray}, ::ByPtr1{TObject})::Nothing


""" AddFirst(this::ByRef1{TClonesArray}, ::ByPtr1{TObject})

# Wrapper of void TClonesArray::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TClonesArray}, ::ByPtr1{TObject})::Nothing


""" AddLast(this::ByRef1{TClonesArray}, ::ByPtr1{TObject})

# Wrapper of TObject * TClonesArray::AddrAt(Int_t)
@trydoc raw"""
    AddrAt(this::ByRef1{TClonesArray}, idx::Int32)::CxxPtr1{TObject}


""" AddrAt(this::ByRef1{TClonesArray}, idx::Int32)

# Wrapper of void TClonesArray::BypassStreamer(Bool_t)
@trydoc raw"""
    BypassStreamer(this::ByRef1{TClonesArray}, bypass::Bool)::Nothing
When the kBypassStreamer bit is set, the automatically generated Streamer can call directly [TClass!WriteBuffer](@ref).
Bypassing the Streamer improves the performance when writing/reading the objects in the [TClonesArray](@ref). However there is a drawback: When a [TClonesArray](@ref) is written with split=0 bypassing the Streamer, the StreamerInfo of the class in the array being optimized, one cannot use later the [TClonesArray](@ref) with split>0. For example, there is a problem with the following scenario:

1. A class Foo has a [TClonesArray](@ref) of Bar objects
2. The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.
3. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1
4. When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the [TClonesArray](@ref) in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the [TClonesArray](@ref). In this case, the normal Bar!Streamer function will be called. The Bar!Streamer function works OK independently if the Bar StreamerInfo had been generated in optimized mode or not.
""" BypassStreamer(this::ByRef1{TClonesArray}, bypass::Bool)

# Wrapper of void TClonesArray::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TClonesArray}, option::ByCopy{String})::Nothing
Clear the clones array.
Only use this routine when your objects don't allocate memory since it will not call the object dtors. However, if the class in the [TClonesArray](@ref) implements the function [Clear(Option_t *option)](@ref) and if option = "C" the function [Clear()](@ref) is called for all objects in the array. In the function [Clear()](@ref), one can delete objects or dynamic arrays allocated in the class. This procedure is much faster than calling [TClonesArray!Delete()](@ref). When the option starts with "C+", eg "C+xyz" the objects in the array are in turn cleared with the option "xyz"
""" Clear(this::ByRef1{TClonesArray}, option::ByCopy{String})

# Wrapper of void TClonesArray::Compress()
@trydoc raw"""
    Compress(this::ByRef1{TClonesArray})::Nothing
Remove empty slots from array.

""" Compress(this::ByRef1{TClonesArray})

# Wrapper of TObject * TClonesArray::ConstructedAt(Int_t)
@trydoc raw"""
    ConstructedAt(this::ByRef1{TClonesArray}, idx::Int32)::CxxPtr1{TObject}
Get an object at index 'idx' that is guaranteed to have been constructed.
It might be either a freshly allocated object or one that had already been allocated (and assumingly used). In the later case, it is the callers responsibility to insure that the object is returned to a known state, usually by calling the Clear method on the [TClonesArray](@ref).

Tests to see if the destructor has been called on the object. If so, or if the object has never been constructed the class constructor is called using [New()](@ref). If not, return a pointer to the correct memory location. This explicitly to deal with [TObject](@ref) classes that allocate memory which will be reset (but not deallocated) in their [Clear()](@ref) functions.
""" ConstructedAt(this::ByRef1{TClonesArray}, idx::Int32)

# Wrapper of TObject * TClonesArray::ConstructedAt(Int_t, Option_t *)
@trydoc raw"""
    ConstructedAt(this::ByRef1{TClonesArray}, idx::Int32, clear_options::ByCopy{String})::CxxPtr1{TObject}
Get an object at index 'idx' that is guaranteed to have been constructed.
It might be either a freshly allocated object or one that had already been allocated (and assumingly used). In the later case, the function Clear will be called and passed the value of 'clear_options'

Tests to see if the destructor has been called on the object. If so, or if the object has never been constructed the class constructor is called using [New()](@ref). If not, return a pointer to the correct memory location. This explicitly to deal with [TObject](@ref) classes that allocate memory which will be reset (but not deallocated) in their [Clear()](@ref) functions.
""" ConstructedAt(this::ByRef1{TClonesArray}, idx::Int32, clear_options::ByCopy{String})

# Wrapper of void TClonesArray::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TClonesArray}, option::ByCopy{String})::Nothing
Clear the clones array.
Use this routine when your objects allocate memory (e.g. objects inheriting from [TNamed](@ref) or containing TStrings allocate memory). If not you better use [Clear()](@ref) since if is faster.
""" Delete(this::ByRef1{TClonesArray}, option::ByCopy{String})

# Wrapper of void TClonesArray::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TClonesArray}, newSize::Int32)::Nothing
Expand or shrink the array to newSize elements.

""" Expand(this::ByRef1{TClonesArray}, newSize::Int32)

# Wrapper of void TClonesArray::ExpandCreate(Int_t)
@trydoc raw"""
    ExpandCreate(this::ByRef1{TClonesArray}, n::Int32)::Nothing
Expand or shrink the array to n elements and create the clone objects by calling their default ctor.
If n is less than the current size the array is shrunk and the allocated space is freed. This routine is typically used to create a clonesarray into which one can directly copy object data without going via the "new (arr[i]) MyObj()" (i.e. the vtbl is already set correctly).
""" ExpandCreate(this::ByRef1{TClonesArray}, n::Int32)

# Wrapper of void TClonesArray::ExpandCreateFast(Int_t)
@trydoc raw"""
    ExpandCreateFast(this::ByRef1{TClonesArray}, n::Int32)::Nothing
Expand or shrink the array to n elements and create the clone objects by calling their default ctor.
If n is less than the current size the array is shrunk but the allocated space is *not* freed. This routine is typically used to create a clonesarray into which one can directly copy object data without going via the "new (arr[i]) MyObj()" (i.e. the vtbl is already set correctly). This is a simplified version of ExpandCreate used in the [TTree](@ref) mechanism.
""" ExpandCreateFast(this::ByRef1{TClonesArray}, n::Int32)

# Wrapper of void TClonesArray::MultiSort(Int_t, TClonesArray **, Int_t)
@trydoc raw"""
    MultiSort(this::ByRef1{TClonesArray}, nTCs::Int32, tcs::ByPtr1{TClonesArray}, upto::Int32)::Nothing
Sort multiple TClonesArrays simultaneously with this array.
If objects in array are sortable (i.e. [IsSortable()](@ref) returns true for all objects) then sort array.
""" MultiSort(this::ByRef1{TClonesArray}, nTCs::Int32, tcs::ByPtr1{TClonesArray}, upto::Int32)

# Wrapper of TObject * TClonesArray::New(Int_t)
@trydoc raw"""
    New(this::ByRef1{TClonesArray}, idx::Int32)::CxxPtr1{TObject}
Create an object of type fClass with the default ctor at the specified index.
Returns 0 in case of error.
""" New(this::ByRef1{TClonesArray}, idx::Int32)

# Wrapper of TClonesArray & TClonesArray::operator=(const TClonesArray &)
@trydoc raw"""
    assign(this::ByRef1{TClonesArray}, tc::ByConstRef1{TClonesArray})::CxxRef1{TClonesArray}
Assignment operator.

""" assign(this::ByRef1{TClonesArray}, tc::ByConstRef1{TClonesArray})

# Wrapper of TObject *& TClonesArray::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TClonesArray}, idx::Int32)::CxxPtr1{TObject}
Return pointer to reserved area in which a new object of clones class can be constructed.
This operator should not be used for lefthand side assignments, like a[2] = xxx. Only like, new (a[2]) myClass, or xxx = a[2]. Of course right hand side usage is only legal after the object has been constructed via the new operator or via the [New()](@ref) method. To remove elements from the clones array use [Remove()](@ref) or [RemoveAt()](@ref).
""" Base.getindex(this::ByRef1{TClonesArray}, idx::Int32)

# Wrapper of TObject * TClonesArray::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TClonesArray}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from array.

""" Remove(this::ByRef1{TClonesArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TClonesArray::RemoveAt(Int_t)
@trydoc raw"""
    RemoveAt(this::ByRef1{TClonesArray}, idx::Int32)::CxxPtr1{TObject}
Remove object at index idx.

""" RemoveAt(this::ByRef1{TClonesArray}, idx::Int32)

# Wrapper of void TClonesArray::RemoveRange(Int_t, Int_t)
@trydoc raw"""
    RemoveRange(this::ByRef1{TClonesArray}, idx1::Int32, idx2::Int32)::Nothing
Remove objects from index idx1 to idx2 included.

""" RemoveRange(this::ByRef1{TClonesArray}, idx1::Int32, idx2::Int32)

# Wrapper of void TClonesArray::SetClass(const char *, Int_t)
@trydoc raw"""
    SetClass(this::ByRef1{TClonesArray}, classname::ByCopy{String}, size::Int32)::Nothing
see TClonesArray!SetClass(const TClass*)

""" SetClass(this::ByRef1{TClonesArray}, classname::ByCopy{String}, size::Int32)

# Wrapper of void TClonesArray::SetClass(const TClass *, Int_t)
@trydoc raw"""
    SetClass(this::ByRef1{TClonesArray}, cl::ByConstPtr1{TClass}, size::Int32)::Nothing
Create an array of clone objects of class cl.
The class must inherit from [TObject](@ref). The second argument s indicates an approximate number of objects that will be entered in the array. If more than s objects are entered, the array will be automatically expanded.

NB: This function should not be called in the [TClonesArray](@ref) is already initialized with a class.
""" SetClass(this::ByRef1{TClonesArray}, cl::ByConstPtr1{TClass}, size::Int32)

# Wrapper of void TClonesArray::SetOwner(Bool_t)
@trydoc raw"""
    SetOwner(this::ByRef1{TClonesArray}, enable::Bool)::Nothing
A [TClonesArray](@ref) is always the owner of the object it contains.
However the collection its inherits from ([TObjArray](@ref)) does not. Hence this member function needs to be a nop for [TClonesArray](@ref).
""" SetOwner(this::ByRef1{TClonesArray}, enable::Bool)

# Wrapper of void TClonesArray::Sort(Int_t)
@trydoc raw"""
    Sort(this::ByRef1{TClonesArray}, upto::Int32)::Nothing
If objects in array are sortable (i.e.
[IsSortable()](@ref) returns true for all objects) then sort array.
""" Sort(this::ByRef1{TClonesArray}, upto::Int32)

# Wrapper of TColor & TColor::operator=(const TColor &)
@trydoc raw"""
    assign(this::ByRef1{TColor}, color::ByConstRef1{TColor})::CxxRef1{TColor}


""" assign(this::ByRef1{TColor}, color::ByConstRef1{TColor})

# Wrapper of void TColor::SetAlpha(Float_t)
@trydoc raw"""
    SetAlpha(this::ByRef1{TColor}, a::Float32)::Nothing


""" SetAlpha(this::ByRef1{TColor}, a::Float32)

# Wrapper of void TColor::SetRGB(Float_t, Float_t, Float_t)
@trydoc raw"""
    SetRGB(this::ByRef1{TColor}, r::Float32, g::Float32, b::Float32)::Nothing
Initialize this color and its associated colors.

""" SetRGB(this::ByRef1{TColor}, r::Float32, g::Float32, b::Float32)

# Wrapper of void TColor::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TColor}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TColor}, ::ByRef1{TBuffer})

# Wrapper of void TColor::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TColor}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TColor}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TColorGradient::ResetColor(UInt_t, const Double_t *, const Color_t *)
@trydoc raw"""
    ResetColor(this::ByRef1{TColorGradient}, nPoints::UInt32, points::ByConstPtr2{Float64}, colorIndices::ByConstPtr2{Int16})::Nothing
Reset color.

""" ResetColor(this::ByRef1{TColorGradient}, nPoints::UInt32, points::ByConstPtr2{Float64}, colorIndices::ByConstPtr2{Int16})

# Wrapper of void TColorGradient::ResetColor(UInt_t, const Double_t *, const Double_t *)
@trydoc raw"""
    ResetColor(this::ByRef1{TColorGradient}, nPoints::UInt32, points::ByConstPtr2{Float64}, colorIndices::ByConstPtr2{Float64})::Nothing
Reset color.

""" ResetColor(this::ByRef1{TColorGradient}, nPoints::UInt32, points::ByConstPtr2{Float64}, colorIndices::ByConstPtr2{Float64})

# Wrapper of void TColorGradient::SetColorAlpha(UInt_t, Double_t)
@trydoc raw"""
    SetColorAlpha(this::ByRef1{TColorGradient}, indx::UInt32, alpha::Float64)::Nothing
Change alpha parameter of the color.

""" SetColorAlpha(this::ByRef1{TColorGradient}, indx::UInt32, alpha::Float64)

# Wrapper of void TColorGradient::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TColorGradient}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TColorGradient}, ::ByRef1{TBuffer})

# Wrapper of void TColorGradient::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TColorGradient}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TColorGradient}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TLinearGradient::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TLinearGradient}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TLinearGradient}, ::ByRef1{TBuffer})

# Wrapper of void TLinearGradient::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TLinearGradient}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TLinearGradient}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TRadialGradient::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TRadialGradient}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TRadialGradient}, ::ByRef1{TBuffer})

# Wrapper of void TRadialGradient::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TRadialGradient}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TRadialGradient}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TDatime::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TDatime}, buffer::ByPtr2{Int8})::Nothing
Encode Date/Time into buffer, used by I/O system.

""" FillBuffer(this::ByRef1{TDatime}, buffer::ByPtr2{Int8})

# Wrapper of TDatime & TDatime::operator=(const TDatime &)
@trydoc raw"""
    assign(this::ByRef1{TDatime}, d::ByConstRef1{TDatime})::CxxRef1{TDatime}


""" assign(this::ByRef1{TDatime}, d::ByConstRef1{TDatime})

# Wrapper of void TDatime::ReadBuffer(char *&)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TDatime}, buffer::ByPtr2{Int8})::Nothing
Decode Date/Time from output buffer, used by I/O system.

""" ReadBuffer(this::ByRef1{TDatime}, buffer::ByPtr2{Int8})

# Wrapper of void TDatime::Set()
@trydoc raw"""
    Set(this::ByRef1{TDatime})::Nothing
Set Date/Time to current time as reported by the system.
Date and Time are encoded into one single unsigned 32 bit word. Date is stored with the origin being the 1st January 1995. Time has 1 second precision.
""" Set(this::ByRef1{TDatime})

# Wrapper of void TDatime::Set(const char *)
@trydoc raw"""
    Set(this::ByRef1{TDatime}, sqlDateTime::ByCopy{String})::Nothing
Expects as input a string in SQL date/time compatible format, like: yyyy-mm-dd hh:mm:ss.

""" Set(this::ByRef1{TDatime}, sqlDateTime::ByCopy{String})

# Wrapper of void TDatime::Set(Int_t, Int_t)
@trydoc raw"""
    Set(this::ByRef1{TDatime}, date::Int32, time::Int32)::Nothing
Set date and time.
Data must be in format 980418 or 19980418 and time in 224512 (second precision). The date must be >= 950101.

For years >= 2000, date can be given in the form 20001127 or 1001127 internally the date will be converted to 1001127
""" Set(this::ByRef1{TDatime}, date::Int32, time::Int32)

# Wrapper of void TDatime::Set(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    Set(this::ByRef1{TDatime}, year::Int32, month::Int32, day::Int32, hour::Int32, min::Int32, sec::Int32)::Nothing
Set date and time.
Year may be xx where 95 <= xx <= 158 (158 being 2058). The year must be >= 1995.
""" Set(this::ByRef1{TDatime}, year::Int32, month::Int32, day::Int32, hour::Int32, min::Int32, sec::Int32)

# Wrapper of void TDatime::Set(UInt_t, Bool_t)
@trydoc raw"""
    Set(this::ByRef1{TDatime}, tloc::UInt32, dosDate::Bool)::Nothing
The input arg is a time_t value returned by time() or a value returned by [Convert()](@ref).
This value is the number of seconds since the EPOCH (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input is a dosDate value.
""" Set(this::ByRef1{TDatime}, tloc::UInt32, dosDate::Bool)

# Wrapper of void TDatime::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TDatime}, ::ByRef1{TBuffer})::Nothing
Stream a object of type [TDatime](@ref).

""" Streamer(this::ByRef1{TDatime}, ::ByRef1{TBuffer})

# Wrapper of void TDatime::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TDatime}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TDatime}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TUUID::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TUUID}, buffer::ByPtr2{Int8})::Nothing
Stream UUID into output buffer.

""" FillBuffer(this::ByRef1{TUUID}, buffer::ByPtr2{Int8})

# Wrapper of void TUUID::ReadBuffer(char *&)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TUUID}, buffer::ByPtr2{Int8})::Nothing
Stream UUID from input buffer.

""" ReadBuffer(this::ByRef1{TUUID}, buffer::ByPtr2{Int8})

# Wrapper of void TUUID::SetUUID(const char *)
@trydoc raw"""
    SetUUID(this::ByRef1{TUUID}, uuid_str::ByCopy{String})::Nothing
Set this UUID to the value specified in uuid ((which must be in [TUUID!AsString()](@ref) format).

""" SetUUID(this::ByRef1{TUUID}, uuid_str::ByCopy{String})

# Wrapper of void TUUID::SetUUIDNumber(UInt_t)
@trydoc raw"""
    SetUUIDNumber(this::ByRef1{TUUID}, index::UInt32)::Nothing


""" SetUUIDNumber(this::ByRef1{TUUID}, index::UInt32)

# Wrapper of void TUUID::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TUUID}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TUUID}, ::ByRef1{TBuffer})

# Wrapper of void TUUID::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TUUID}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TUUID}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TUUID::StreamerV1(TBuffer &)
@trydoc raw"""
    StreamerV1(this::ByRef1{TUUID}, b::ByRef1{TBuffer})::Nothing
Stream UUID from input buffer.
This function is for the exclusive use of [TDirectory!Streamer()](@ref) to read a non-versioned version of [TUUID](@ref).
""" StreamerV1(this::ByRef1{TUUID}, b::ByRef1{TBuffer})

# Wrapper of TInetAddress & TInetAddress::operator=(const TInetAddress &)
@trydoc raw"""
    assign(this::ByRef1{TInetAddress}, rhs::ByConstRef1{TInetAddress})::CxxRef1{TInetAddress}
[TInetAddress](@ref) assignment operator.

""" assign(this::ByRef1{TInetAddress}, rhs::ByConstRef1{TInetAddress})

# Wrapper of void TInetAddress::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TInetAddress}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TInetAddress](@ref).

""" Streamer(this::ByRef1{TInetAddress}, ::ByRef1{TBuffer})

# Wrapper of void TInetAddress::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TInetAddress}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TInetAddress}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TDirectory::Add(TObject *, Bool_t)
@trydoc raw"""
    Add(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)::Nothing


""" Add(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of void TDirectory::Append(TObject *, Bool_t)
@trydoc raw"""
    Append(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)::Nothing
Append object to this directory.
If `replace` is true: remove any existing objects with the same name (if the name is not "")
""" Append(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of Int_t TDirectory::AppendKey(TKey *)
@trydoc raw"""
    AppendKey(this::ByRef1{TDirectory}, ::ByPtr1{TKey})::Int32


""" AppendKey(this::ByRef1{TDirectory}, ::ByPtr1{TKey})

# Wrapper of void TDirectory::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TDirectory}, b::ByPtr1{TBrowser})::Nothing
Browse the content of the directory.

""" Browse(this::ByRef1{TDirectory}, b::ByPtr1{TBrowser})

# Wrapper of void TDirectory::Build(TFile *, TDirectory *)
@trydoc raw"""
    Build(this::ByRef1{TDirectory}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})::Nothing


""" Build(this::ByRef1{TDirectory}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})

# Wrapper of Bool_t TDirectory::cd()
@trydoc raw"""
    cd(this::ByRef1{TDirectory})::Bool
Change current directory to "this" directory.
Returns kTRUE (it's guaranteed to succeed).
""" cd(this::ByRef1{TDirectory})

# Wrapper of Bool_t TDirectory::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TDirectory}, path::ByCopy{String})::Bool
Change current directory to "this" directory or to the directory described by the path if given one.
Using path one can change the current directory to "path". The absolute path syntax is: `file.root:/dir1/dir2` where `file.root` is the file and `/dir1/dir2` the desired subdirectory in the file.

Relative syntax is relative to "this" directory. E.g: `../aa`.

Returns kTRUE in case of success.
""" cd(this::ByRef1{TDirectory}, path::ByCopy{String})

# Wrapper of void TDirectory::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Delete all objects from a Directory list.

""" Clear(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of TObject * TDirectory::CloneObject(const TObject *, Bool_t)
@trydoc raw"""
    CloneObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, autoadd::Bool)::CxxPtr1{TObject}
Clone an object.
This function is called when the directory is not a [TDirectoryFile](@ref). This version has to load the I/O package, hence via Cling.

If autoadd is true and if the object class has a DirectoryAutoAdd function, it will be called at the theend of the function with the parameter gDirector. This usually means that the object will be appended to the current [ROOT](@ref) directory.
""" CloneObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, autoadd::Bool)

# Wrapper of void TDirectory::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Delete all objects from memory and directory structure itself.
if option is "slow", iterate through the containers in a way to can handle 'external' modification (induced by recursions) if option is "nodelete", write the [TDirectory](@ref) but do not delete the contained objects.
""" Close(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Delete(const char *)
@trydoc raw"""
    Delete(this::ByRef1{TDirectory}, namecycle::ByCopy{String})::Nothing
Delete Objects or/and keys in a directory.
- namecycle has the format name;cycle
- namecycle = "" same as namecycle ="T*"
- name = * means all
- cycle = * means all cycles (memory and keys)
- cycle = "" or cycle = 9999 ==> apply to a memory object When name=* use T* to delete subdirectories also

To delete one directory, you must specify the directory cycle, eg. `file.Delete("dir1;1");`

examples:

- foo : delete object named foo in memory
- foo* : delete all objects with a name starting with foo
- foo;1 : delete cycle 1 of foo on file
- foo;* : delete all cycles of foo on file and also from memory
- *;2 : delete all objects on file having the cycle 2
- *;* : delete all objects from memory and file
- T*;* : delete all objects from memory and file and all subdirectories
""" Delete(this::ByRef1{TDirectory}, namecycle::ByCopy{String})

# Wrapper of void TDirectory::DeleteAll(Option_t *)
@trydoc raw"""
    DeleteAll(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Delete all objects from memory.

""" DeleteAll(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Fill Graphics Structure and Paint.
Loop on all objects (memory or file) and all subdirectories
""" Draw(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of TObject * TDirectory::Get(const char *)
@trydoc raw"""
    Get(this::ByRef1{TDirectory}, namecycle::ByCopy{String})::CxxPtr1{TObject}
Return pointer to object identified by namecycle.
namecycle has the format name;cycle

- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

examples:

- foo : get object named foo in memory if object is not in memory, try with highest cycle from file
- foo;1 : get cycle 1 of foo on file

The retrieved object should in principle derive from [TObject](@ref). If not, the function [TDirectory!GetObject](@ref) should be called. However, this function will still work for a non-TObject, providing that the calling application cast the return type to the correct type (which is the actual type of the object).

NOTE:

The method GetObject offer better protection and avoid the need for any cast: 

    MyClass *obj;
    directory->GetObject("some object",obj);
    if (obj) { ... the object exist and inherits from MyClass ... }

(C++ version of the code)

VERY IMPORTANT NOTE:

In case the class of this object derives from [TObject](@ref) but not as a first inheritance, one must use dynamic_cast<>(). #### Example 1: Normal case:

    class MyClass : public TObject, public AnotherClass

(C++ version of the code)

 then on return, one can do: 

    MyClass *obj = (MyClass*)directory->Get("some object of MyClass");

(C++ version of the code)

 #### Example 2: Special case:

    class MyClass : public AnotherClass, public TObject

(C++ version of the code)

 then on return, one must do: 

    MyClass *obj = dynamic_cast<MyClass*>(directory->Get("some object of MyClass"));

(C++ version of the code)

 Of course, dynamic_cast<> can also be used in the example 1.
""" Get(this::ByRef1{TDirectory}, namecycle::ByCopy{String})

# Wrapper of TDirectory * TDirectory::GetDirectory(const char *, Bool_t, const char *)
@trydoc raw"""
    GetDirectory(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, printError::Bool, funcname::ByCopy{String})::CxxPtr1{TDirectory}
Find a directory using apath.
It apath is null or empty, returns "this" directory. Otherwise use apath to find a directory. The absolute path syntax is: `file.root:/dir1/dir2`

where file.root is the file and /dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to "this" directory. E.g: `../aa`. Returns 0 in case path does not exist. If printError is true, use Error with 'funcname' to issue an error message.
""" GetDirectory(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, printError::Bool, funcname::ByCopy{String})

# Wrapper of void * TDirectory::GetObjectChecked(const char *, const char *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, classname::ByCopy{String})::CxxPtr2{Nothing}
See documentation of TDirectory!GetObjectCheck(const char *namecycle, const TClass *cl)

""" GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, classname::ByCopy{String})

# Wrapper of void * TDirectory::GetObjectChecked(const char *, const TClass *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a "expectedClass" If expectedClass is null, no check is performed.
namecycle has the format `name;cycle`

- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

VERY IMPORTANT NOTE:

The calling application must cast the returned pointer to the type described by the 2 arguments (i.e. cl): 

    MyClass *obj = (MyClass*)directory->GetObjectChecked("some object of MyClass","MyClass"));

(C++ version of the code)

 Note: We recommend using the method [TDirectory!GetObject](@ref): 

    MyClass *obj = nullptr;
    directory->GetObject("some object inheriting from MyClass",obj);
    if (obj) { ... we found what we are looking for ... }

(C++ version of the code)
""" GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})

# Wrapper of void * TDirectory::GetObjectUnchecked(const char *)
@trydoc raw"""
    GetObjectUnchecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle.
The returned object may or may not derive from [TObject](@ref).

- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

VERY IMPORTANT NOTE:

The calling application must cast the returned object to the final type, e.g. 

    MyClass *obj = (MyClass*)directory->GetObject("some object of MyClass");

(C++ version of the code)
""" GetObjectUnchecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String})

# Wrapper of TDirectory * TDirectory::mkdir(const char *, const char *, Bool_t)
@trydoc raw"""
    mkdir(this::ByRef1{TDirectory}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)::CxxPtr1{TDirectory}
Create a sub-directory "a" or a hierarchy of sub-directories "a/b/c/...".
Returns 0 in case of error or if a sub-directory (hierarchy) with the requested name already exists. returnExistingDirectory returns a pointer to an already existing sub-directory with the same name. Returns a pointer to the created sub-directory or to the top sub-directory of the hierarchy (in the above example, the returned [TDirectory](@ref) * always points to "a"). In particular, the steps to create first a/b/c and then a/b/d without receiving errors are: 

    TFile * file = new TFile("afile","RECREATE");
    file->mkdir("a");
    file->cd("a");
    gDirectory->mkdir("b/c");
    gDirectory->cd("b");
    gDirectory->mkdir("d");

(C++ version of the code)

 or 

    TFile * file = new TFile("afile","RECREATE");
    file->mkdir("a");
    file->cd("a");
    gDirectory->mkdir("b/c");
    gDirectory->mkdir("b/d", "", true);

(C++ version of the code)
""" mkdir(this::ByRef1{TDirectory}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)

# Wrapper of TFile * TDirectory::OpenFile(const char *, Option_t *, const char *, Int_t, Int_t)
@trydoc raw"""
    OpenFile(this::ByRef1{TDirectory}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32, ::Int32)::CxxPtr1{TFile}


""" OpenFile(this::ByRef1{TDirectory}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32, ::Int32)

# Wrapper of void TDirectory::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Paint all objects in the directory.

""" Paint(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Purge(Short_t)
@trydoc raw"""
    Purge(this::ByRef1{TDirectory}, ::Int16)::Nothing


""" Purge(this::ByRef1{TDirectory}, ::Int16)

# Wrapper of void TDirectory::ReadAll(Option_t *)
@trydoc raw"""
    ReadAll(this::ByRef1{TDirectory}, ::ByCopy{String})::Nothing


""" ReadAll(this::ByRef1{TDirectory}, ::ByCopy{String})

# Wrapper of Int_t TDirectory::ReadKeys(Bool_t)
@trydoc raw"""
    ReadKeys(this::ByRef1{TDirectory}, ::Bool)::Int32


""" ReadKeys(this::ByRef1{TDirectory}, ::Bool)

# Wrapper of Int_t TDirectory::ReadTObject(TObject *, const char *)
@trydoc raw"""
    ReadTObject(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByCopy{String})::Int32


""" ReadTObject(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByCopy{String})

# Wrapper of void TDirectory::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TDirectory}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from a Directory.

""" RecursiveRemove(this::ByRef1{TDirectory}, obj::ByPtr1{TObject})

# Wrapper of TObject * TDirectory::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TDirectory}, ::ByPtr1{TObject})::CxxPtr1{TObject}
Remove an object from the in-memory list.

""" Remove(this::ByRef1{TDirectory}, ::ByPtr1{TObject})

# Wrapper of void TDirectory::rmdir(const char *)
@trydoc raw"""
    rmdir(this::ByRef1{TDirectory}, name::ByCopy{String})::Nothing
Removes subdirectory from the directory When directory is deleted, all keys in all subdirectories will be read first and deleted from file (if exists) Equivalent call is Delete("name;*");.

""" rmdir(this::ByRef1{TDirectory}, name::ByCopy{String})

# Wrapper of void TDirectory::Save()
@trydoc raw"""
    Save(this::ByRef1{TDirectory})::Nothing


""" Save(this::ByRef1{TDirectory})

# Wrapper of void TDirectory::SaveSelf(Bool_t)
@trydoc raw"""
    SaveSelf(this::ByRef1{TDirectory}, ::Bool)::Nothing


""" SaveSelf(this::ByRef1{TDirectory}, ::Bool)

# Wrapper of void TDirectory::SetBufferSize(Int_t)
@trydoc raw"""
    SetBufferSize(this::ByRef1{TDirectory}, ::Int32)::Nothing


""" SetBufferSize(this::ByRef1{TDirectory}, ::Int32)

# Wrapper of void TDirectory::SetModified()
@trydoc raw"""
    SetModified(this::ByRef1{TDirectory})::Nothing


""" SetModified(this::ByRef1{TDirectory})

# Wrapper of void TDirectory::SetMother(TObject *)
@trydoc raw"""
    SetMother(this::ByRef1{TDirectory}, mother::ByPtr1{TObject})::Nothing


""" SetMother(this::ByRef1{TDirectory}, mother::ByPtr1{TObject})

# Wrapper of void TDirectory::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TDirectory}, newname::ByCopy{String})::Nothing
Set the name for directory If the directory name is changed after the directory was written once, [ROOT](@ref) currently would NOT change the name of correspondent key in the mother directory.
DO NOT use this method to 'rename a directory'. Renaming a directory is currently NOT supported.
""" SetName(this::ByRef1{TDirectory}, newname::ByCopy{String})

# Wrapper of void TDirectory::SetSeekDir(Long64_t)
@trydoc raw"""
    SetSeekDir(this::ByRef1{TDirectory}, ::Int64)::Nothing


""" SetSeekDir(this::ByRef1{TDirectory}, ::Int64)

# Wrapper of void TDirectory::SetTRefAction(TObject *, TObject *)
@trydoc raw"""
    SetTRefAction(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByPtr1{TObject})::Nothing


""" SetTRefAction(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByPtr1{TObject})

# Wrapper of void TDirectory::SetWritable(Bool_t)
@trydoc raw"""
    SetWritable(this::ByRef1{TDirectory}, ::Bool)::Nothing


""" SetWritable(this::ByRef1{TDirectory}, ::Bool)

# Wrapper of void TDirectory::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TDirectory}, ::ByRef1{TBuffer})::Nothing
[TDirectory](@ref) Streamer.

""" Streamer(this::ByRef1{TDirectory}, ::ByRef1{TBuffer})

# Wrapper of void TDirectory::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TDirectory}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TDirectory}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TDirectory::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TDirectory}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write this object to the current directory.
For more see the const version of this method.
""" Write(this::ByRef1{TDirectory}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of void TDirectory::WriteDirHeader()
@trydoc raw"""
    WriteDirHeader(this::ByRef1{TDirectory})::Nothing


""" WriteDirHeader(this::ByRef1{TDirectory})

# Wrapper of void TDirectory::WriteKeys()
@trydoc raw"""
    WriteKeys(this::ByRef1{TDirectory})::Nothing


""" WriteKeys(this::ByRef1{TDirectory})

# Wrapper of Int_t TDirectory::WriteObjectAny(const void *, const char *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)::Int32


""" WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)

# Wrapper of Int_t TDirectory::WriteObjectAny(const void *, const TClass *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByConstPtr1{TClass}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)::Int32


""" WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByConstPtr1{TClass}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)

# Wrapper of Int_t TDirectory::WriteTObject(const TObject *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteTObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, ::ByCopy{String}, ::Int32)::Int32
Write an object with proper type checking.
## Arguments

- **`obj`** [in] 
    Pointer to an object to be written. 
    
- **`name`** [in] 
    Name of the object in the file. 
    
- **`option`** [in] 
    Options. See [TDirectory!WriteTObject](@ref). 
    
- **`bufsize`** [in] 
    Buffer size. See [TDirectory!WriteTObject](@ref).
    

This overload takes care of instances of classes that are not derived from [TObject](@ref). The method redirects to [TDirectory!WriteObjectAny](@ref).
""" WriteTObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, ::ByCopy{String}, ::Int32)

# Wrapper of void TKey::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TKey}, b::ByPtr1{TBrowser})::Nothing
Read object from disk and call its [Browse()](@ref) method.
If object with same name already exist in memory delete it (like [TDirectoryFile!Get()](@ref) is doing), except when the key references a folder in which case we don't want to re-read the folder object since it might contain new objects not yet saved.
""" Browse(this::ByRef1{TKey}, b::ByPtr1{TBrowser})

# Wrapper of void TKey::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TKey}, option::ByCopy{String})::Nothing
Delete an object from the file.
Note: the key is not deleted. You still have to call "delete key". This is different from the behaviour of [TObject!Delete()](@ref)!
""" Delete(this::ByRef1{TKey}, option::ByCopy{String})

# Wrapper of void TKey::DeleteBuffer()
@trydoc raw"""
    DeleteBuffer(this::ByRef1{TKey})::Nothing
Delete key buffer(s).

""" DeleteBuffer(this::ByRef1{TKey})

# Wrapper of void TKey::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})::Nothing
Encode key header into output buffer.

""" FillBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})

# Wrapper of void TKey::IncrementPidOffset(UShort_t)
@trydoc raw"""
    IncrementPidOffset(this::ByRef1{TKey}, offset::UInt16)::Nothing
Increment fPidOffset by 'offset'.
This offset is used when a key (or basket) is transfered from one file to the other. In this case the [TRef](@ref) and [TObject](@ref) might have stored a pid index (to retrieve TProcessIDs) which refered to their order on the original file, the fPidOffset is to be added to those values to correctly find the [TProcessID](@ref). This fPidOffset needs to be increment if the key/basket is copied and need to be zero for new key/basket.
""" IncrementPidOffset(this::ByRef1{TKey}, offset::UInt16)

# Wrapper of void TKey::Keep()
@trydoc raw"""
    Keep(this::ByRef1{TKey})::Nothing
Set the "KEEP" status.
When the KEEP flag is set to 1 the object cannot be purged.
""" Keep(this::ByRef1{TKey})

# Wrapper of Int_t TKey::Read(TObject *)
@trydoc raw"""
    Read(this::ByRef1{TKey}, obj::ByPtr1{TObject})::Int32
To read an object from the file.
The object associated to this key is read from the file into memory. Before invoking this function, obj has been created via the default constructor.
""" Read(this::ByRef1{TKey}, obj::ByPtr1{TObject})

# Wrapper of void TKey::ReadBuffer(char *&)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})::Nothing
Decode input buffer.
In some situation will add key to gDirectory.
""" ReadBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})

# Wrapper of Bool_t TKey::ReadFile()
@trydoc raw"""
    ReadFile(this::ByRef1{TKey})::Bool
Read the key structure from the file.

""" ReadFile(this::ByRef1{TKey})

# Wrapper of void TKey::ReadKeyBuffer(char *&)
@trydoc raw"""
    ReadKeyBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})::Nothing
Decode input buffer.

""" ReadKeyBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})

# Wrapper of TObject * TKey::ReadObj()
@trydoc raw"""
    ReadObj(this::ByRef1{TKey})::CxxPtr1{TObject}
To read a TObject* from the file.
The object associated to this key is read from the file into memory Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the [TClass](@ref) object for this class. A [TClass](@ref) object contains a full description (i.e. dictionary) of the associated class. In particular the [TClass](@ref) object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.

Use [TKey!ReadObjectAny](@ref) to read any object non-derived from [TObject](@ref)

### Note

A C style cast can only be used in the case where the final class of this object derives from [TObject](@ref) as a first inheritance, otherwise one must use a dynamic_cast.

#### Example1: simplified case

    class MyClass : public TObject, public AnotherClass

(C++ version of the code)

 then on return, one get away with using: 

    MyClass *obj = (MyClass*)key->ReadObj();

(C++ version of the code)

#### Example2: Usual case (recommended unless performance is critical)

    MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());

(C++ version of the code)

 which support also the more complex inheritance like: 

    class MyClass : public AnotherClass, public TObject

(C++ version of the code)

Of course, `dynamic_cast<>` can also be used in the example 1.
""" ReadObj(this::ByRef1{TKey})

# Wrapper of void * TKey::ReadObjectAny(const TClass *)
@trydoc raw"""
    ReadObjectAny(this::ByRef1{TKey}, expectedClass::ByConstPtr1{TClass})::CxxPtr2{Nothing}
To read an object (non deriving from [TObject](@ref)) from the file.
If expectedClass is not null, we checked that that actual class of the object stored is suitable to be stored in a pointer pointing to an object of class 'expectedClass'. We also adjust the value of the returned address so that it is suitable to be cast (C-Style) a pointer pointing to an object of class 'expectedClass'.

So for example if the class Bottom inherits from Top and the object stored is of type Bottom you can safely do: 

    auto TopClass = TClass!GetClass("Top");
    auto ptr = (Top*) key->ReadObjectAny( TopClass );
    if (ptr==0) printError("the object stored in the key is not of the expected type\n");

(C++ version of the code)

 The object associated to this key is read from the file into memory. Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the [TClass](@ref) object for this class. A [TClass](@ref) object contains a full description (i.e. dictionary) of the associated class. In particular the [TClass](@ref) object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.
""" ReadObjectAny(this::ByRef1{TKey}, expectedClass::ByConstPtr1{TClass})

# Wrapper of TObject * TKey::ReadObjWithBuffer(char *)
@trydoc raw"""
    ReadObjWithBuffer(this::ByRef1{TKey}, bufferRead::ByPtr2{Int8})::CxxPtr1{TObject}
To read a TObject* from bufferRead.
This function is identical to [TKey!ReadObj](@ref), but it reads directly from bufferRead instead of reading from a file. The object associated to this key is read from the buffer into memory Using the class identifier we find the [TClass](@ref) object for this class. A [TClass](@ref) object contains a full description (i.e. dictionary) of the associated class. In particular the [TClass](@ref) object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.

### Note

This function is called only internally by [ROOT](@ref) classes. Although being public it is not supposed to be used outside [ROOT](@ref). If used, you must make sure that the bufferRead is large enough to accomodate the object being read.
""" ReadObjWithBuffer(this::ByRef1{TKey}, bufferRead::ByPtr2{Int8})

# Wrapper of void TKey::SetBuffer()
@trydoc raw"""
    SetBuffer(this::ByRef1{TKey})::Nothing


""" SetBuffer(this::ByRef1{TKey})

# Wrapper of void TKey::SetMotherDir(TDirectory *)
@trydoc raw"""
    SetMotherDir(this::ByRef1{TKey}, dir::ByPtr1{TDirectory})::Nothing


""" SetMotherDir(this::ByRef1{TKey}, dir::ByPtr1{TDirectory})

# Wrapper of void TKey::SetParent(const TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TKey}, parent::ByConstPtr1{TObject})::Nothing
Set parent in key buffer.

""" SetParent(this::ByRef1{TKey}, parent::ByConstPtr1{TObject})

# Wrapper of Int_t TKey::WriteFile(Int_t, TFile *)
@trydoc raw"""
    WriteFile(this::ByRef1{TKey}, cycle::Int32, f::ByPtr1{TFile})::Int32
Write the encoded object supported by this key.
The function returns the number of bytes committed to the file. If a write error occurs, the number of bytes returned is -1.
""" WriteFile(this::ByRef1{TKey}, cycle::Int32, f::ByPtr1{TFile})

# Wrapper of void TFile::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TFile}, option::ByCopy{String})::Nothing
Close a file.
## Arguments

- **`option`** [in] 
    If option == "R", all TProcessIDs referenced by this file are deleted.
    

Calling [TFile!Close](@ref)("R") might be necessary in case one reads a long list of files having [TRef](@ref), writing some of the referenced objects or [TRef](@ref) to a new file. If the [TRef](@ref) or referenced objects of the file being closed will not be referenced again, it is possible to minimize the size of the [TProcessID](@ref) data structures in memory by forcing a delete of the unused [TProcessID](@ref).
""" Close(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of Bool_t TFile::Cp(const char *, Bool_t, UInt_t)
@trydoc raw"""
    Cp(this::ByRef1{TFile}, dst::ByCopy{String}, progressbar::Bool, buffersize::UInt32)::Bool
Allows to copy this file to the dst URL.
Returns kTRUE in case of success, kFALSE otherwise.
""" Cp(this::ByRef1{TFile}, dst::ByCopy{String}, progressbar::Bool, buffersize::UInt32)

# Wrapper of TKey * TFile::CreateKey(TDirectory *, const TObject *, const char *, Int_t)
@trydoc raw"""
    CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, bufsize::Int32)::CxxPtr1{TKey}
Creates key for object and converts data to buffer.

""" CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, bufsize::Int32)

# Wrapper of TKey * TFile::CreateKey(TDirectory *, const void *, const TClass *, const char *, Int_t)
@trydoc raw"""
    CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, bufsize::Int32)::CxxPtr1{TKey}
Creates key for object and converts data to buffer.

""" CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, bufsize::Int32)

# Wrapper of void TFile::Delete(const char *)
@trydoc raw"""
    Delete(this::ByRef1{TFile}, namecycle::ByCopy{String})::Nothing
Delete object namecycle.
## Arguments

- **`namecycle`** [in] 
    Encodes the name and cycle of the objects to delete
    

Namecycle identifies an object in the top directory of the file namecycle has the format *name;cycle*.

- *name = ** means all objects
- *cycle = ** means all cycles (memory and keys)
- *cycle = ""* or cycle = 9999 ==> apply to a memory object When name=* use T* to delete subdirectories also

Examples: 
| **name/cycle** | **Action**                                                     |
|:---------------|:---------------------------------------------------------------|
| foo            | delete object named foo in memory                              |
| foo;1          | delete cycle 1 of foo on file                                  |
| foo;*          | delete all cycles of foo on disk and also from memory          |
| *;2            | delete all objects on file having the cycle 2                  |
| *;*            | delete all objects from memory and file                        |
| T*;*           | delete all objects from memory and file and all subdirectories |
""" Delete(this::ByRef1{TFile}, namecycle::ByCopy{String})

# Wrapper of void TFile::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TFile}, option::ByCopy{String})::Nothing
Fill Graphics Structure and Paint.
Loop on all objects (memory or file) and all subdirectories.
""" Draw(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::DrawMap(const char *, Option_t *)
@trydoc raw"""
    DrawMap(this::ByRef1{TFile}, keys::ByCopy{String}, option::ByCopy{String})::Nothing
Draw map of objects in this file.
The map drawing is handled by [TFileDrawMap](@ref). Once the map is drawn, turn on the [TCanvas](@ref) option "View->Event Statusbar". Then, when moving the mouse in the canvas, the "Event Status" panels shows the object corresponding to the mouse position.

Example: 

    auto f = new TFile("myfile.root");
    f->DrawMap();

(C++ version of the code)
""" DrawMap(this::ByRef1{TFile}, keys::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TFile::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TFile}, buffer::ByPtr2{Int8})::Nothing
Encode file output buffer.
The file output buffer contains only the FREE data record.
""" FillBuffer(this::ByRef1{TFile}, buffer::ByPtr2{Int8})

# Wrapper of void TFile::Flush()
@trydoc raw"""
    Flush(this::ByRef1{TFile})::Nothing
Synchronize a file's in-memory and on-disk states.

""" Flush(this::ByRef1{TFile})

# Wrapper of Float_t TFile::GetCompressionFactor()
@trydoc raw"""
    GetCompressionFactor(this::ByRef1{TFile})::Float32
Return the file compression factor.
Add total number of compressed/uncompressed bytes for each key. Returns the ratio of the two.
""" GetCompressionFactor(this::ByRef1{TFile})

# Wrapper of TString TFile::GetNewUrl()
@trydoc raw"""
    GetNewUrl(this::ByRef1{TFile})::ByCopy{TString}


""" GetNewUrl(this::ByRef1{TFile})

# Wrapper of Int_t TFile::GetRecordHeader(char *, Long64_t, Int_t, Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetRecordHeader(this::ByRef1{TFile}, buf::ByPtr2{Int8}, first::Int64, maxbytes::Int32, nbytes::ByRef2{Int32}, objlen::ByRef2{Int32}, keylen::ByRef2{Int32})::Int32
Read the logical record header starting at a certain postion.
## Arguments

- **`buf`** [in] 
    pointer to buffer 
    
- **`first`** [in] 
    read offset 
    
- **`maxbytes`** [in] 
    Bytes which are read into buf. 
    
- **`nbytes`** [out] 
    Number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first 
    
- **`objlen`** [out] 
    Uncompressed object size 
    
- **`keylen`** [out] 
    Length of logical record header
    

The function reads nread bytes where nread is the minimum of maxbytes and the number of bytes before the theend of file. The function returns nread. Note that the arguments objlen and keylen are returned only if maxbytes >=16
""" GetRecordHeader(this::ByRef1{TFile}, buf::ByPtr2{Int8}, first::Int64, maxbytes::Int32, nbytes::ByRef2{Int32}, objlen::ByRef2{Int32}, keylen::ByRef2{Int32})

# Wrapper of const TList * TFile::GetStreamerInfoCache()
@trydoc raw"""
    GetStreamerInfoCache(this::ByRef1{TFile})::ConstCxxPtr1{TList}
Returns the cached list of StreamerInfos used in this file.

""" GetStreamerInfoCache(this::ByRef1{TFile})

# Wrapper of TList * TFile::GetStreamerInfoList()
@trydoc raw"""
    GetStreamerInfoList(this::ByRef1{TFile})::CxxPtr1{TList}
Read the list of [TStreamerInfo](@ref) objects written to this file.
The function returns a [TList](@ref). It is the user's responsibility to delete the list created by this function.

Note the list, in addition to [TStreamerInfo](@ref) object, contains sometimes a [TList](@ref) named 'listOfRules' and containing the schema evolution rules related to the file's content.

Using the list, one can access additional information, e.g.: 

    TFile f("myfile.root");
    auto list = f.GetStreamerInfoList();
    auto info = dynamic_cast<TStreamerInfo*>(list->FindObject("MyClass"));
    if (info) auto classversionid = info->GetClassVersion();
    delete list;

(C++ version of the code)
""" GetStreamerInfoList(this::ByRef1{TFile})

# Wrapper of void TFile::IncrementProcessIDs()
@trydoc raw"""
    IncrementProcessIDs(this::ByRef1{TFile})::Nothing


""" IncrementProcessIDs(this::ByRef1{TFile})

# Wrapper of void TFile::MakeFree(Long64_t, Long64_t)
@trydoc raw"""
    MakeFree(this::ByRef1{TFile}, first::Int64, last::Int64)::Nothing
Mark unused bytes on the file.
The list of free segments is in the fFree linked list. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Number of bytes occupied by the record).
""" MakeFree(this::ByRef1{TFile}, first::Int64, last::Int64)

# Wrapper of void TFile::MakeProject(const char *, const char *, Option_t *)
@trydoc raw"""
    MakeProject(this::ByRef1{TFile}, dirname::ByCopy{String}, classes::ByCopy{String}, option::ByCopy{String})::Nothing
Generate source code necessary to access the objects stored in the file.
Generate code in directory dirname for all classes specified in argument classes If classes = "*" (default and currently the only supported value), the function generates an include file for each class in the StreamerInfo list for which a [TClass](@ref) object does not exist.

The code generated includes:

- *dirnameProjectHeaders.h*, which contains one `#include` statement per generated header file
- *dirnameProjectSource.cxx*,which contains all the constructors and destructors implementation. and one header per class that is not nested inside another class. The header file name is the fully qualified name of the class after all the special characters "<>,:" are replaced by underscored. For example for std!pair<edm!Vertex,int> the file name is pair_edm__Vertex_int_.h

In the generated classes, map, multimap when the first template parameter is a class are replaced by a vector of pair. set and multiset when the tempalte parameter is a class are replaced by a vector. This is required since we do not have the code needed to order and/or compare the object of the classes. This is a quick explanation of the options available: 
| **Option**    | **Details**                                                                                                                                                                                                                          |
|:--------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.                                                                                                                  |
| recreate      | If dirname does not exist, it is created (like in "new"). If dirname already exist, all existing files in dirname are deleted before creating the new files.                                                                         |
| update        | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as "new".                                             |
| genreflex     | Use genreflex rather than rootcint to generate the dictionary.                                                                                                                                                                       |
| par           | Create a PAR file with the minimal set of code needed to read the content of the [ROOT](@ref) file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). |

If, in addition to one of the 3 above options, the option "+" is specified, the function will generate:

- a script called MAKEP to build the shared lib
- a dirnameLinkDef.h file
- rootcint will be run to generate a dirnameProjectDict.cxx file
- dirnameProjectDict.cxx will be compiled with the current options in compiledata.h
- a shared lib dirname.so will be created. If the option "++" is specified, the generated shared lib is dynamically linked with the current executable themodule. If the option "+" and "nocompile" are specified, the utility files are generated as in the option "+" but they are not executed. Example: file.MakeProject("demo","*","recreate++");
- creates a new directory demo unless it already exist
- clear the previous directory content
- generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.
- creates the build script MAKEP
- creates a LinkDef.h file
- runs rootcint generating demoProjectDict.cxx
- compiles demoProjectDict.cxx into demoProjectDict.o
- generates a shared lib demo.so
- dynamically links the shared lib demo.so to the executable If only the option "+" had been specified, one can still link the shared lib to the current executable themodule with: 
```
gSystem->load("demo/demo.so");
```  The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: 
```
classes = "Ali*" generate code only for classes starting with Ali
classes = "myClass" generate code for class MyClass only.
```
""" MakeProject(this::ByRef1{TFile}, dirname::ByCopy{String}, classes::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TFile::Map()
@trydoc raw"""
    Map(this::ByRef1{TFile})::Nothing


""" Map(this::ByRef1{TFile})

# Wrapper of void TFile::Map(Option_t *)
@trydoc raw"""
    Map(this::ByRef1{TFile}, opt::ByCopy{String})::Nothing
List the contents of a file sequentially.
For each logical record found, it prints: 
```
Date/Time  Record_Adress Logical_Record_Length  ClassName  CompressionFactor
```  Example of output 
```
20010404/150437  At:64        N=150       TFile
20010404/150440  At:214       N=28326     TBasket        CX =  1.13
20010404/150440  At:28540     N=29616     TBasket        CX =  1.08
20010404/150440  At:58156     N=29640     TBasket        CX =  1.08
20010404/150440  At:87796     N=29076     TBasket        CX =  1.10
20010404/150440  At:116872    N=10151     TBasket        CX =  3.15
20010404/150441  At:127023    N=28341     TBasket        CX =  1.13
20010404/150441  At:155364    N=29594     TBasket        CX =  1.08
20010404/150441  At:184958    N=29616     TBasket        CX =  1.08
20010404/150441  At:214574    N=29075     TBasket        CX =  1.10
20010404/150441  At:243649    N=9583      TBasket        CX =  3.34
20010404/150442  At:253232    N=28324     TBasket        CX =  1.13
20010404/150442  At:281556    N=29641     TBasket        CX =  1.08
20010404/150442  At:311197    N=29633     TBasket        CX =  1.08
20010404/150442  At:340830    N=29091     TBasket        CX =  1.10
20010404/150442  At:369921    N=10341     TBasket        CX =  3.09
20010404/150442  At:380262    N=509       TH1F           CX =  1.93
20010404/150442  At:380771    N=1769      TH2F           CX =  4.32
20010404/150442  At:382540    N=1849      TProfile       CX =  1.65
20010404/150442  At:384389    N=18434     TNtuple        CX =  4.51
20010404/150442  At:402823    N=307       KeysList
20010404/150443  At:403130    N=4548      StreamerInfo   CX =  3.65
20010404/150443  At:407678    N=86        FreeSegments
20010404/150443  At:407764    N=1         END
```  If the parameter opt contains "forComp", the Date/Time is omitted and the decompressed size is also printed.

Record_Adress Logical_Record_Length Key_Length Object_Record_Length ClassName CompressionFactor

If the parameter opt contains "extended", the name and title of the keys are added: 20200820/155031 At:100 N=180 [TFile](@ref) name: hsimple.root title: Demo [ROOT](@ref) file with histograms 220200820/155032 At:280 N=28880 [TBasket](@ref) CX = 1.11 name: random title: ntuple 220200820/155032 At:29160 N=29761 [TBasket](@ref) CX = 1.08 name: px title: ntuple 220200820/155032 At:58921 N=29725 [TBasket](@ref) CX = 1.08 name: py title: ntuple 220200820/155032 At:88646 N=29209 [TBasket](@ref) CX = 1.10 name: pz title: ntuple 220200820/155032 At:117855 N=10197 [TBasket](@ref) CX = 3.14 name: i title: ntuple ... 20200820/155032 At:405110 N=808 [TNtuple](@ref) CX = 3.53 name: ntuple title: Demo ntuple 20200820/155706 At:405918 N=307 KeysList name: hsimple.root title: Demo [ROOT](@ref) file with histograms 20200820/155032 At:406225 N=8556 StreamerInfo CX = 3.42 name: StreamerInfo title: Doubly linked list 20200820/155708 At:414781 N=86 FreeSegments name: hsimple.root title: Demo [ROOT](@ref) file with histograms 20200820/155708 At:414867 N=1 END

Note: The combined size of the classname, name and title is truncated to 476 characters (a little more for regular keys of small files)
""" Map(this::ByRef1{TFile}, opt::ByCopy{String})

# Wrapper of Bool_t TFile::Matches(const char *)
@trydoc raw"""
    Matches(this::ByRef1{TFile}, name::ByCopy{String})::Bool
Return kTRUE if 'url' matches the coordinates of this file.
The check is implementation dependent and may need to be overload by each [TFile](@ref) implementation relying on this check. The default implementation checks the file name only.
""" Matches(this::ByRef1{TFile}, name::ByCopy{String})

# Wrapper of void TFile::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TFile}, option::ByCopy{String})::Nothing
Paint all objects in the file.

""" Paint(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of Bool_t TFile::ReadBuffer(char *, Int_t)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, len::Int32)::Bool
Read a buffer from the file.
This is the basic low level read operation. Returns kTRUE in case of failure.
""" ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, len::Int32)

# Wrapper of Bool_t TFile::ReadBuffer(char *, Long64_t, Int_t)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::Int64, len::Int32)::Bool
Read a buffer from the file at the offset 'pos' in the file.
Returns kTRUE in case of failure. Compared to [ReadBuffer(char*, Int_t)](@ref), this routine does *not* change the cursor on the physical file representation (fD) if the data is in this [TFile](@ref)'s cache.
""" ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::Int64, len::Int32)

# Wrapper of Bool_t TFile::ReadBufferAsync(Long64_t, Int_t)
@trydoc raw"""
    ReadBufferAsync(this::ByRef1{TFile}, offs::Int64, len::Int32)::Bool


""" ReadBufferAsync(this::ByRef1{TFile}, offs::Int64, len::Int32)

# Wrapper of Bool_t TFile::ReadBuffers(char *, Long64_t *, Int_t *, Int_t)
@trydoc raw"""
    ReadBuffers(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::ByPtr2{Int64}, len::ByPtr2{Int32}, nbuf::Int32)::Bool
Read the nbuf blocks described in arrays pos and len.
The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile!ReafBuffer. This function is overloaded by [TNetFile](@ref), [TWebFile](@ref), etc. Returns kTRUE in case of failure.
""" ReadBuffers(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::ByPtr2{Int64}, len::ByPtr2{Int32}, nbuf::Int32)

# Wrapper of void TFile::ReadFree()
@trydoc raw"""
    ReadFree(this::ByRef1{TFile})::Nothing
Read the FREE linked list.
Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record.
""" ReadFree(this::ByRef1{TFile})

# Wrapper of TProcessID * TFile::ReadProcessID(UShort_t)
@trydoc raw"""
    ReadProcessID(this::ByRef1{TFile}, pidf::UInt16)::CxxPtr1{TProcessID}
The [TProcessID](@ref) with number pidf is read from this file.
If the object is not already entered in the gROOT list, it is added.
""" ReadProcessID(this::ByRef1{TFile}, pidf::UInt16)

# Wrapper of void TFile::ReadStreamerInfo()
@trydoc raw"""
    ReadStreamerInfo(this::ByRef1{TFile})::Nothing
Read the list of StreamerInfo from this file.
The key with name holding the list of [TStreamerInfo](@ref) objects is read. The corresponding [TClass](@ref) objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see [TFile!SetReadStreamerInfo](@ref))
""" ReadStreamerInfo(this::ByRef1{TFile})

# Wrapper of Int_t TFile::Recover()
@trydoc raw"""
    Recover(this::ByRef1{TFile})::Int32
Attempt to recover file if not correctly closed.
The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:

    TFile f("myfile.root");
    if (f.IsZombie()) {<actions to take if file is unusable>}

(C++ version of the code)

If the file has been recovered, the bit kRecovered is set in the [TFile](@ref) object in memory. You can test if the file has been recovered with 
```
if (f.TestBit(TFile!kRecovered)) {... the file has been recovered}
```  When writing TTrees to a file, it is important to save the Tree header at regular intervals (see [TTree!AutoSave](@ref)). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting 
```
TFile.Recover 0
```  in the *system.rootrc* file.
""" Recover(this::ByRef1{TFile})

# Wrapper of Int_t TFile::ReOpen(Option_t *)
@trydoc raw"""
    ReOpen(this::ByRef1{TFile}, mode::ByCopy{String})::Int32
Reopen a file with a different access mode.
For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either "READ" or "UPDATE". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is changed to this file.
""" ReOpen(this::ByRef1{TFile}, mode::ByCopy{String})

# Wrapper of void TFile::SetCompressionAlgorithm(Int_t)
@trydoc raw"""
    SetCompressionAlgorithm(this::ByRef1{TFile}, algorithm::Int32)::Nothing
See comments for function SetCompressionSettings.

""" SetCompressionAlgorithm(this::ByRef1{TFile}, algorithm::Int32)

# Wrapper of void TFile::SetCompressionLevel(Int_t)
@trydoc raw"""
    SetCompressionLevel(this::ByRef1{TFile}, level::Int32)::Nothing
See comments for function SetCompressionSettings.

""" SetCompressionLevel(this::ByRef1{TFile}, level::Int32)

# Wrapper of void TFile::SetCompressionSettings(Int_t)
@trydoc raw"""
    SetCompressionSettings(this::ByRef1{TFile}, settings::Int32)::Nothing
Used to specify the compression level and algorithm.
See the [TFile](@ref) constructor for the details.
""" SetCompressionSettings(this::ByRef1{TFile}, settings::Int32)

# Wrapper of void TFile::SetEND(Long64_t)
@trydoc raw"""
    SetEND(this::ByRef1{TFile}, last::Int64)::Nothing


""" SetEND(this::ByRef1{TFile}, last::Int64)

# Wrapper of void TFile::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TFile}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::SetReadCalls(Int_t)
@trydoc raw"""
    SetReadCalls(this::ByRef1{TFile}, readcalls::Int32)::Nothing


""" SetReadCalls(this::ByRef1{TFile}, readcalls::Int32)

# Wrapper of void TFile::ShowStreamerInfo()
@trydoc raw"""
    ShowStreamerInfo(this::ByRef1{TFile})::Nothing
Show the StreamerInfo of all classes written to this file.

""" ShowStreamerInfo(this::ByRef1{TFile})

# Wrapper of void TFile::SumBuffer(Int_t)
@trydoc raw"""
    SumBuffer(this::ByRef1{TFile}, bufsize::Int32)::Nothing
Increment statistics for buffer sizes of objects in this file.

""" SumBuffer(this::ByRef1{TFile}, bufsize::Int32)

# Wrapper of Int_t TFile::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TFile}, name::ByCopy{String}, opt::Int32, bufsiz::Int32)::Int32
Write memory objects to this file.
Loop on all objects in memory (including subdirectories). A new key is created in the KEYS linked list for each object. The list of keys is then saved on the file (via WriteKeys) as a single data record. For values of opt see [TObject!Write()](@ref). The directory header info is rewritten on the directory header record. The linked list of FREE segments is written. The file header is written (bytes 1->fBEGIN).
""" Write(this::ByRef1{TFile}, name::ByCopy{String}, opt::Int32, bufsiz::Int32)

# Wrapper of Bool_t TFile::WriteBuffer(const char *, Int_t)
@trydoc raw"""
    WriteBuffer(this::ByRef1{TFile}, buf::ByCopy{String}, len::Int32)::Bool
Write a buffer to the file.
This is the basic low level write operation. Returns kTRUE in case of failure.
""" WriteBuffer(this::ByRef1{TFile}, buf::ByCopy{String}, len::Int32)

# Wrapper of void TFile::WriteFree()
@trydoc raw"""
    WriteFree(this::ByRef1{TFile})::Nothing
Write FREE linked list on the file.
The linked list of FREE segments (fFree) is written as a single data record.
""" WriteFree(this::ByRef1{TFile})

# Wrapper of void TFile::WriteHeader()
@trydoc raw"""
    WriteHeader(this::ByRef1{TFile})::Nothing
Write File Header.

""" WriteHeader(this::ByRef1{TFile})

# Wrapper of UShort_t TFile::WriteProcessID(TProcessID *)
@trydoc raw"""
    WriteProcessID(this::ByRef1{TFile}, pid::ByPtr1{TProcessID})::UInt16
Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the local_ file list.

""" WriteProcessID(this::ByRef1{TFile}, pid::ByPtr1{TProcessID})

# Wrapper of void TFile::WriteStreamerInfo()
@trydoc raw"""
    WriteStreamerInfo(this::ByRef1{TFile})::Nothing
Write the list of [TStreamerInfo](@ref) as a single object in this file The class Streamer description for all classes written to this file is saved.
See class [TStreamerInfo](@ref).
""" WriteStreamerInfo(this::ByRef1{TFile})

# Wrapper of Bool_t TEnv::IgnoreDuplicates(Bool_t)
@trydoc raw"""
    IgnoreDuplicates(this::ByRef1{TEnv}, ignore::Bool)::Bool
If set to true, no warnings in case of duplicates are issued.
Returns previous value.
""" IgnoreDuplicates(this::ByRef1{TEnv}, ignore::Bool)

# Wrapper of Int_t TEnv::ReadFile(const char *, EEnvLevel)
@trydoc raw"""
    ReadFile(this::ByRef1{TEnv}, fname::ByCopy{String}, level::ByCopy{EEnvLevel})::Int32
Read and parse the resource file for a certain level.
Returns -1 on case of error, 0 in case of success.
""" ReadFile(this::ByRef1{TEnv}, fname::ByCopy{String}, level::ByCopy{EEnvLevel})

# Wrapper of void TEnv::Save()
@trydoc raw"""
    Save(this::ByRef1{TEnv})::Nothing
Write the resource files for each level.
The new files have the same name as the original files. The old files are renamed to *.bak.
""" Save(this::ByRef1{TEnv})

# Wrapper of void TEnv::SaveLevel(EEnvLevel)
@trydoc raw"""
    SaveLevel(this::ByRef1{TEnv}, level::ByCopy{EEnvLevel})::Nothing
Write the resource file for a certain level.

""" SaveLevel(this::ByRef1{TEnv}, level::ByCopy{EEnvLevel})

# Wrapper of void TEnv::SetRcName(const char *)
@trydoc raw"""
    SetRcName(this::ByRef1{TEnv}, name::ByCopy{String})::Nothing


""" SetRcName(this::ByRef1{TEnv}, name::ByCopy{String})

# Wrapper of void TEnv::SetValue(const char *, const char *, EEnvLevel, const char *)
@trydoc raw"""
    SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, value::ByCopy{String}, level::ByCopy{EEnvLevel}, type::ByCopy{String})::Nothing
Set the value of a resource or create a new resource.

""" SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, value::ByCopy{String}, level::ByCopy{EEnvLevel}, type::ByCopy{String})

# Wrapper of void TEnv::SetValue(const char *, Double_t)
@trydoc raw"""
    SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, value::Float64)::Nothing
Set or create a double resource value.

""" SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, value::Float64)

# Wrapper of void TEnv::SetValue(const char *, EEnvLevel)
@trydoc raw"""
    SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, level::ByCopy{EEnvLevel})::Nothing
Set the value of a resource or create a new resource.
Use this method to set a resource like, "name=val". If just "name" is given it will be interpreted as "name=1".
""" SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, level::ByCopy{EEnvLevel})

# Wrapper of void TEnv::SetValue(const char *, Int_t)
@trydoc raw"""
    SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, value::Int32)::Nothing
Set or create an integer resource value.

""" SetValue(this::ByRef1{TEnv}, name::ByCopy{String}, value::Int32)

# Wrapper of void TEnv::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TEnv}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TEnv}, ::ByRef1{TBuffer})

# Wrapper of void TEnv::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TEnv}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TEnv}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TEnv::WriteFile(const char *, EEnvLevel)
@trydoc raw"""
    WriteFile(this::ByRef1{TEnv}, fname::ByCopy{String}, level::ByCopy{EEnvLevel})::Int32
Write resource records to file fname for a certain level.
Use level kEnvAll to write all resources. Returns -1 on case of error, 0 in case of success.
""" WriteFile(this::ByRef1{TEnv}, fname::ByCopy{String}, level::ByCopy{EEnvLevel})

# Wrapper of void TEnvRec::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TEnvRec}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TEnvRec}, ::ByRef1{TBuffer})

# Wrapper of void TEnvRec::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TEnvRec}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TEnvRec}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void THashList::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{THashList}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object after object after in the list.

""" AddAfter(this::ByRef1{THashList}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void THashList::AddAfter(TObjLink *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{THashList}, after::ByPtr1{TObjLink}, obj::ByPtr1{TObject})::Nothing
Insert object after object after in the list.

""" AddAfter(this::ByRef1{THashList}, after::ByPtr1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void THashList::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{THashList}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Insert object at location idx in the list.

""" AddAt(this::ByRef1{THashList}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void THashList::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{THashList}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object before object before in the list.

""" AddBefore(this::ByRef1{THashList}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void THashList::AddBefore(TObjLink *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{THashList}, before::ByPtr1{TObjLink}, obj::ByPtr1{TObject})::Nothing
Insert object before object before in the list.

""" AddBefore(this::ByRef1{THashList}, before::ByPtr1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void THashList::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{THashList}, obj::ByPtr1{TObject})::Nothing
Add object at the beginning of the list.

""" AddFirst(this::ByRef1{THashList}, obj::ByPtr1{TObject})

# Wrapper of void THashList::AddFirst(TObject *, Option_t *)
@trydoc raw"""
    AddFirst(this::ByRef1{THashList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object at the beginning of the list and also store option.
Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the [Draw()](@ref) method. It allows the same object to be drawn in different ways.
""" AddFirst(this::ByRef1{THashList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void THashList::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{THashList}, obj::ByPtr1{TObject})::Nothing
Add object at the theend of the list.

""" AddLast(this::ByRef1{THashList}, obj::ByPtr1{TObject})

# Wrapper of void THashList::AddLast(TObject *, Option_t *)
@trydoc raw"""
    AddLast(this::ByRef1{THashList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object at the theend of the list and also store option.
Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the [Draw()](@ref) method. It allows the same object to be drawn in different ways.
""" AddLast(this::ByRef1{THashList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void THashList::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{THashList}, option::ByCopy{String})::Nothing
Remove all objects from the list.
Does not delete the objects unless the [THashList](@ref) is the owner (set via [SetOwner()](@ref)).
""" Clear(this::ByRef1{THashList}, option::ByCopy{String})

# Wrapper of void THashList::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{THashList}, option::ByCopy{String})::Nothing
Remove all objects from the list AND delete all heap based objects.
If option="slow" then keep list consistent during delete. This allows recursive list operations during the delete (e.g. during the dtor of an object in this list one can still access the list to search for other not yet deleted objects).
""" Delete(this::ByRef1{THashList}, option::ByCopy{String})

# Wrapper of void THashList::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{THashList}, obj::ByPtr1{TObject})::Nothing
Remove object from this collection and recursively remove the object from all other objects (and collections).
This function overrides [TCollection!RecursiveRemove](@ref) that calls the Remove function. [THashList!Remove](@ref) cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the [TObject](@ref) destructor.
""" RecursiveRemove(this::ByRef1{THashList}, obj::ByPtr1{TObject})

# Wrapper of void THashList::Rehash(Int_t)
@trydoc raw"""
    Rehash(this::ByRef1{THashList}, newCapacity::Int32)::Nothing
Rehash the hashlist.
If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use [AverageCollisions()](@ref) to check if you need to rehash.
""" Rehash(this::ByRef1{THashList}, newCapacity::Int32)

# Wrapper of TObject * THashList::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{THashList}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from the list.

""" Remove(this::ByRef1{THashList}, obj::ByPtr1{TObject})

# Wrapper of TObject * THashList::Remove(TObjLink *)
@trydoc raw"""
    Remove(this::ByRef1{THashList}, lnk::ByPtr1{TObjLink})::CxxPtr1{TObject}
Remove object via its objlink from the list.

""" Remove(this::ByRef1{THashList}, lnk::ByPtr1{TObjLink})

# Wrapper of bool THashList::UseRWLock(Bool_t)
@trydoc raw"""
    UseRWLock(this::ByRef1{THashList}, enable::Bool)::Bool
Set this collection to use a RW lock upon access, making it thread safe.
Return the previous state.

Note: To test whether the usage is enabled do: collection->TestBit(TCollection!kUseRWLock);
""" UseRWLock(this::ByRef1{THashList}, enable::Bool)

# Wrapper of void TExceptionHandler::HandleException(int)
@trydoc raw"""
    HandleException(this::ByRef1{TExceptionHandler}, sig::Int32)::Nothing


""" HandleException(this::ByRef1{TExceptionHandler}, sig::Int32)

# Wrapper of void TExec::Exec(const char *)
@trydoc raw"""
    Exec(this::ByRef1{TExec}, command::ByCopy{String})::Nothing
Execute the command referenced by this object.
if command is given, this command is executed otherwise the default command of the object is executed

if the default command (in the exec title) is empty, an attempt is made to execute the exec name if it contains a "." or a "(", otherwise the command ".x execname.C" is executed. The function returns the result of the user function/script.
""" Exec(this::ByRef1{TExec}, command::ByCopy{String})

# Wrapper of void TExec::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TExec}, option::ByCopy{String})::Nothing
Execute the command referenced by this object.

""" Paint(this::ByRef1{TExec}, option::ByCopy{String})

# Wrapper of void TExec::SetAction(const char *)
@trydoc raw"""
    SetAction(this::ByRef1{TExec}, action::ByCopy{String})::Nothing


""" SetAction(this::ByRef1{TExec}, action::ByCopy{String})

# Wrapper of void TExec::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TExec}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TExec}, ::ByRef1{TBuffer})

# Wrapper of void TExec::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TExec}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TExec}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TFileCollection::Add(const char *)
@trydoc raw"""
    Add(this::ByRef1{TFileCollection}, path::ByCopy{String})::Int32
Add all files matching the specified pattern to the collection.
'dir' can include wildcards after the last slash, which causes all matching files in that directory to be added. If dir is the full path of a file, only one element is added. Return value is the number of added files.
""" Add(this::ByRef1{TFileCollection}, path::ByCopy{String})

# Wrapper of Int_t TFileCollection::Add(TFileCollection *)
@trydoc raw"""
    Add(this::ByRef1{TFileCollection}, coll::ByPtr1{TFileCollection})::Int32
Add content of the [TFileCollection](@ref) to this collection.

""" Add(this::ByRef1{TFileCollection}, coll::ByPtr1{TFileCollection})

# Wrapper of Int_t TFileCollection::Add(TFileInfo *)
@trydoc raw"""
    Add(this::ByRef1{TFileCollection}, info::ByPtr1{TFileInfo})::Int32
Add [TFileInfo](@ref) to the collection.

""" Add(this::ByRef1{TFileCollection}, info::ByPtr1{TFileInfo})

# Wrapper of Int_t TFileCollection::AddFromFile(const char *, Int_t, Int_t)
@trydoc raw"""
    AddFromFile(this::ByRef1{TFileCollection}, file::ByCopy{String}, nfiles::Int32, firstfile::Int32)::Int32
Add file names contained in the specified text file.
The file should contain one url per line; empty lines or lines starting with '#' (commented lines) are ignored. If nfiles > 0 only nfiles files are added, starting from file 'firstfile' (>= 1). The method returns the number of added files.
""" AddFromFile(this::ByRef1{TFileCollection}, file::ByCopy{String}, nfiles::Int32, firstfile::Int32)

# Wrapper of Bool_t TFileCollection::AddMetaData(TObject *)
@trydoc raw"""
    AddMetaData(this::ByRef1{TFileCollection}, meta::ByPtr1{TObject})::Bool
Add's a meta data object to the file collection object.
The object will be adopted by the [TFileCollection](@ref) and should not be deleted by the user. Typically objects of class [TFileInfoMeta](@ref) or derivatives should be added, but any class is accepted.

NB : a call to [TFileCollection!Update](@ref) will remove these objects unless the bit [TFileInfoMeta!kExternal](@ref) is set. Returns kTRUE if successful, kFALSE otherwise.
""" AddMetaData(this::ByRef1{TFileCollection}, meta::ByPtr1{TObject})

# Wrapper of TFileCollection * TFileCollection::GetFilesOnServer(const char *)
@trydoc raw"""
    GetFilesOnServer(this::ByRef1{TFileCollection}, server::ByCopy{String})::CxxPtr1{TFileCollection}
Return the subset of files served by 'server'.
The syntax for 'server' is the standard URI one, i.e. `[<scheme>://]<host>[:port]`
""" GetFilesOnServer(this::ByRef1{TFileCollection}, server::ByCopy{String})

# Wrapper of TMap * TFileCollection::GetFilesPerServer(const char *, Bool_t)
@trydoc raw"""
    GetFilesPerServer(this::ByRef1{TFileCollection}, exclude::ByCopy{String}, curronly::Bool)::CxxPtr1{TMap}
Return a map of TFileCollections with the files on each data server, excluding servers in the comma-separated list 'exclude'.
If curronly is kTRUE, only the URL flagged as current in the [TFileInfo](@ref) are considered.
""" GetFilesPerServer(this::ByRef1{TFileCollection}, exclude::ByCopy{String}, curronly::Bool)

# Wrapper of THashList * TFileCollection::GetList()
@trydoc raw"""
    GetList(this::ByRef1{TFileCollection})::CxxPtr1{THashList}


""" GetList(this::ByRef1{TFileCollection})

# Wrapper of TFileCollection * TFileCollection::GetStagedSubset()
@trydoc raw"""
    GetStagedSubset(this::ByRef1{TFileCollection})::CxxPtr1{TFileCollection}
Creates a subset of the files that have the kStaged & !kCorrupted bit set.

""" GetStagedSubset(this::ByRef1{TFileCollection})

# Wrapper of Long64_t TFileCollection::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TFileCollection}, list::ByPtr1{TCollection})::Int64
Merge all [TFileCollection](@ref) objects in li into this [TFileCollection](@ref) object.
Updates counters at the theend. Returns the number of merged collections or -1 in case of error.
""" Merge(this::ByRef1{TFileCollection}, list::ByPtr1{TCollection})

# Wrapper of Int_t TFileCollection::RemoveDuplicates()
@trydoc raw"""
    RemoveDuplicates(this::ByRef1{TFileCollection})::Int32
Remove duplicates based on the UUID, typically after a verification.
Return the number of entries removed.
""" RemoveDuplicates(this::ByRef1{TFileCollection})

# Wrapper of void TFileCollection::RemoveMetaData(const char *)
@trydoc raw"""
    RemoveMetaData(this::ByRef1{TFileCollection}, meta::ByCopy{String})::Nothing
Removes the indicated meta data object in all TFileInfos and this object If no name is given all metadata is removed.

""" RemoveMetaData(this::ByRef1{TFileCollection}, meta::ByCopy{String})

# Wrapper of void TFileCollection::ResetBitAll(UInt_t)
@trydoc raw"""
    ResetBitAll(this::ByRef1{TFileCollection}, f::UInt32)::Nothing
Reset the bit for all TFileInfos.

""" ResetBitAll(this::ByRef1{TFileCollection}, f::UInt32)

# Wrapper of void TFileCollection::SetAnchor(const char *)
@trydoc raw"""
    SetAnchor(this::ByRef1{TFileCollection}, anchor::ByCopy{String})::Nothing
Calls [TUrl!SetAnchor()](@ref) for all URLs contained in all TFileInfos.

""" SetAnchor(this::ByRef1{TFileCollection}, anchor::ByCopy{String})

# Wrapper of void TFileCollection::SetBitAll(UInt_t)
@trydoc raw"""
    SetBitAll(this::ByRef1{TFileCollection}, f::UInt32)::Nothing
Set the bit for all TFileInfos.

""" SetBitAll(this::ByRef1{TFileCollection}, f::UInt32)

# Wrapper of void TFileCollection::SetDefaultMetaData(const char *)
@trydoc raw"""
    SetDefaultMetaData(this::ByRef1{TFileCollection}, meta::ByCopy{String})::Nothing
Moves the indicated meta data in the first position, so that it becomes effectively the default.

""" SetDefaultMetaData(this::ByRef1{TFileCollection}, meta::ByCopy{String})

# Wrapper of void TFileCollection::SetDefaultTreeName(const char *)
@trydoc raw"""
    SetDefaultTreeName(this::ByRef1{TFileCollection}, treeName::ByCopy{String})::Nothing


""" SetDefaultTreeName(this::ByRef1{TFileCollection}, treeName::ByCopy{String})

# Wrapper of void TFileCollection::SetList(THashList *)
@trydoc raw"""
    SetList(this::ByRef1{TFileCollection}, list::ByPtr1{THashList})::Nothing


""" SetList(this::ByRef1{TFileCollection}, list::ByPtr1{THashList})

# Wrapper of void TFileCollection::Sort(Bool_t)
@trydoc raw"""
    Sort(this::ByRef1{TFileCollection}, useindex::Bool)::Nothing
Sort the collection.

""" Sort(this::ByRef1{TFileCollection}, useindex::Bool)

# Wrapper of void TFileCollection::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TFileCollection}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TFileCollection}, ::ByRef1{TBuffer})

# Wrapper of void TFileCollection::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TFileCollection}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TFileCollection}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TFileCollection::Update(Long64_t)
@trydoc raw"""
    Update(this::ByRef1{TFileCollection}, avgsize::Int64)::Int32
Update accumulated information about the elements of the collection (e.g.
fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize' bytes when the size info is not available. Also updates the meta data information by summarizing the meta data of the contained objects. Return -1 in case of any failure, 0 if the total size is exact, 1 if incomplete, 2 if complete but (at least partially) estimated.
""" Update(this::ByRef1{TFileCollection}, avgsize::Int64)

# Wrapper of Bool_t TFileInfo::AddMetaData(TObject *)
@trydoc raw"""
    AddMetaData(this::ByRef1{TFileInfo}, meta::ByPtr1{TObject})::Bool
Add's a meta data object to the file info object.
The object will be adopted by the [TFileInfo](@ref) and should not be deleted by the user. Typically objects of class [TFileInfoMeta](@ref) or derivatives should be added, but any class is accepted. Returns kTRUE if successful, kFALSE otherwise.
""" AddMetaData(this::ByRef1{TFileInfo}, meta::ByPtr1{TObject})

# Wrapper of Bool_t TFileInfo::AddUrl(const char *, Bool_t)
@trydoc raw"""
    AddUrl(this::ByRef1{TFileInfo}, url::ByCopy{String}, infront::Bool)::Bool
Add a new URL.
If 'infront' is TRUE the new url is pushed at the beginning of the list; otherwise is pushed back. Returns kTRUE if successful, kFALSE otherwise.
""" AddUrl(this::ByRef1{TFileInfo}, url::ByCopy{String}, infront::Bool)

# Wrapper of TUrl * TFileInfo::FindByUrl(const char *, Bool_t)
@trydoc raw"""
    FindByUrl(this::ByRef1{TFileInfo}, url::ByCopy{String}, withDeflt::Bool)::CxxPtr1{TUrl}
Find an element from a URL. Returns 0 if not found.

""" FindByUrl(this::ByRef1{TFileInfo}, url::ByCopy{String}, withDeflt::Bool)

# Wrapper of TUrl * TFileInfo::NextUrl()
@trydoc raw"""
    NextUrl(this::ByRef1{TFileInfo})::CxxPtr1{TUrl}
Iterator function, thestart iteration by calling [ResetUrl()](@ref).
The first call to [NextUrl()](@ref) will return the 1st element, the seconde the 2nd element etc. Returns 0 in case no more urls.
""" NextUrl(this::ByRef1{TFileInfo})

# Wrapper of Bool_t TFileInfo::RemoveMetaData(const char *)
@trydoc raw"""
    RemoveMetaData(this::ByRef1{TFileInfo}, meta::ByCopy{String})::Bool
Remove the metadata object.
If meta is 0 remove all meta data objects. Returns kTRUE if successful, kFALSE otherwise.
""" RemoveMetaData(this::ByRef1{TFileInfo}, meta::ByCopy{String})

# Wrapper of Bool_t TFileInfo::RemoveUrl(const char *)
@trydoc raw"""
    RemoveUrl(this::ByRef1{TFileInfo}, url::ByCopy{String})::Bool
Remove an URL. Returns kTRUE if successful, kFALSE otherwise.

""" RemoveUrl(this::ByRef1{TFileInfo}, url::ByCopy{String})

# Wrapper of Bool_t TFileInfo::RemoveUrlAt(Int_t)
@trydoc raw"""
    RemoveUrlAt(this::ByRef1{TFileInfo}, i::Int32)::Bool
Remove URL at given position. Returns kTRUE on success, kFALSE on error.

""" RemoveUrlAt(this::ByRef1{TFileInfo}, i::Int32)

# Wrapper of void TFileInfo::ResetUrl()
@trydoc raw"""
    ResetUrl(this::ByRef1{TFileInfo})::Nothing


""" ResetUrl(this::ByRef1{TFileInfo})

# Wrapper of Bool_t TFileInfo::SetCurrentUrl(const char *)
@trydoc raw"""
    SetCurrentUrl(this::ByRef1{TFileInfo}, url::ByCopy{String})::Bool
Set 'url' as current URL, if in the list Return kFALSE if not in the list.

""" SetCurrentUrl(this::ByRef1{TFileInfo}, url::ByCopy{String})

# Wrapper of Bool_t TFileInfo::SetCurrentUrl(TUrl *)
@trydoc raw"""
    SetCurrentUrl(this::ByRef1{TFileInfo}, url::ByPtr1{TUrl})::Bool
Set 'url' as current URL, if in the list Return kFALSE if not in the list.

""" SetCurrentUrl(this::ByRef1{TFileInfo}, url::ByPtr1{TUrl})

# Wrapper of void TFileInfo::SetIndex(Int_t)
@trydoc raw"""
    SetIndex(this::ByRef1{TFileInfo}, idx::Int32)::Nothing


""" SetIndex(this::ByRef1{TFileInfo}, idx::Int32)

# Wrapper of void TFileInfo::SetSize(Long64_t)
@trydoc raw"""
    SetSize(this::ByRef1{TFileInfo}, size::Int64)::Nothing


""" SetSize(this::ByRef1{TFileInfo}, size::Int64)

# Wrapper of void TFileInfo::SetUUID(const char *)
@trydoc raw"""
    SetUUID(this::ByRef1{TFileInfo}, uuid::ByCopy{String})::Nothing
Set the UUID to the value associated to the string 'uuid'.
This is useful to set the UUID to the one of the [ROOT](@ref) file during verification.

NB: we do not change the name in here, because this would screw up lists of these objects hashed on the name. Those lists need to be rebuild. [TFileCollection](@ref) does that in RemoveDuplicates.
""" SetUUID(this::ByRef1{TFileInfo}, uuid::ByCopy{String})

# Wrapper of void TFileInfo::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TFileInfo}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TFileInfo}, ::ByRef1{TBuffer})

# Wrapper of void TFileInfo::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TFileInfo}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TFileInfo}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TFileInfoMeta::SetEntries(Long64_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TFileInfoMeta}, entries::Int64)::Nothing


""" SetEntries(this::ByRef1{TFileInfoMeta}, entries::Int64)

# Wrapper of void TFileInfoMeta::SetFirst(Long64_t)
@trydoc raw"""
    SetFirst(this::ByRef1{TFileInfoMeta}, first::Int64)::Nothing


""" SetFirst(this::ByRef1{TFileInfoMeta}, first::Int64)

# Wrapper of void TFileInfoMeta::SetLast(Long64_t)
@trydoc raw"""
    SetLast(this::ByRef1{TFileInfoMeta}, last::Int64)::Nothing


""" SetLast(this::ByRef1{TFileInfoMeta}, last::Int64)

# Wrapper of void TFileInfoMeta::SetTotBytes(Long64_t)
@trydoc raw"""
    SetTotBytes(this::ByRef1{TFileInfoMeta}, tot::Int64)::Nothing


""" SetTotBytes(this::ByRef1{TFileInfoMeta}, tot::Int64)

# Wrapper of void TFileInfoMeta::SetZipBytes(Long64_t)
@trydoc raw"""
    SetZipBytes(this::ByRef1{TFileInfoMeta}, zip::Int64)::Nothing


""" SetZipBytes(this::ByRef1{TFileInfoMeta}, zip::Int64)

# Wrapper of void TFileInfoMeta::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TFileInfoMeta}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TFileInfoMeta}, ::ByRef1{TBuffer})

# Wrapper of void TFileInfoMeta::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TFileInfoMeta}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TFileInfoMeta}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TMap::Add(TObject *, TObject *)
@trydoc raw"""
    Add(this::ByRef1{TMap}, key::ByPtr1{TObject}, value::ByPtr1{TObject})::Nothing
Add a (key,value) pair to the map.

""" Add(this::ByRef1{TMap}, key::ByPtr1{TObject}, value::ByPtr1{TObject})

# Wrapper of void TMap::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TMap}, obj::ByPtr1{TObject})::Nothing
This function may not be used (but we need to provide it since it is a pure virtual in [TCollection](@ref)).
Use Add(key,value) instead.
""" Add(this::ByRef1{TMap}, obj::ByPtr1{TObject})

# Wrapper of void TMap::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TMap}, option::ByCopy{String})::Nothing
Remove all (key,value) pairs from the map.
The keys/values are deleted depending on the state of key-ownership ([SetOwner()](@ref)) and value-ownership ([SetOwnerValue()](@ref)).

To delete these objects regardless of the ownership state use:

- [Delete()](@ref) to delete only keys;
- [DeleteValues()](@ref) to delete only values;
- [DeleteAll()](@ref) to delete both keys and values.
""" Clear(this::ByRef1{TMap}, option::ByCopy{String})

# Wrapper of void TMap::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TMap}, option::ByCopy{String})::Nothing
Remove all (key,value) pairs from the map AND delete the keys when they are allocated on the heap.

""" Delete(this::ByRef1{TMap}, option::ByCopy{String})

# Wrapper of void TMap::DeleteAll()
@trydoc raw"""
    DeleteAll(this::ByRef1{TMap})::Nothing
Remove all (key,value) pairs from the map AND delete the keys AND values when they are allocated on the heap.

""" DeleteAll(this::ByRef1{TMap})

# Wrapper of Bool_t TMap::DeleteEntry(TObject *)
@trydoc raw"""
    DeleteEntry(this::ByRef1{TMap}, key::ByPtr1{TObject})::Bool
Remove (key,value) pair with key from the map.
Returns true if the key was found and removed, false otherwise. The key and value objects are deleted if map is the owner of keys and values respectively.
""" DeleteEntry(this::ByRef1{TMap}, key::ByPtr1{TObject})

# Wrapper of void TMap::DeleteKeys()
@trydoc raw"""
    DeleteKeys(this::ByRef1{TMap})::Nothing


""" DeleteKeys(this::ByRef1{TMap})

# Wrapper of void TMap::DeleteValues()
@trydoc raw"""
    DeleteValues(this::ByRef1{TMap})::Nothing
Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap.

""" DeleteValues(this::ByRef1{TMap})

# Wrapper of void TMap::Rehash(Int_t, Bool_t)
@trydoc raw"""
    Rehash(this::ByRef1{TMap}, newCapacity::Int32, checkObjValidity::Bool)::Nothing
Rehash the underlaying [THashTable](@ref) (see [THashTable!Rehash()](@ref)).
""" Rehash(this::ByRef1{TMap}, newCapacity::Int32, checkObjValidity::Bool)

# Wrapper of TObject * TMap::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TMap}, key::ByPtr1{TObject})::CxxPtr1{TObject}
Remove the (key,value) pair with key from the map.
Returns the key object or 0 in case key was not found. If map is the owner of values, the value is deleted.
""" Remove(this::ByRef1{TMap}, key::ByPtr1{TObject})

# Wrapper of TPair * TMap::RemoveEntry(TObject *)
@trydoc raw"""
    RemoveEntry(this::ByRef1{TMap}, key::ByPtr1{TObject})::CxxPtr1{TPair}
Remove (key,value) pair with key from the map.
Returns the pair object or 0 in case the key was not found. It is caller's responsibility to delete the pair and, eventually, the key and value objects.
""" RemoveEntry(this::ByRef1{TMap}, key::ByPtr1{TObject})

# Wrapper of void TMap::SetOwnerKeyValue(Bool_t, Bool_t)
@trydoc raw"""
    SetOwnerKeyValue(this::ByRef1{TMap}, ownkeys::Bool, ownvals::Bool)::Nothing
Set ownership for keys and values.

""" SetOwnerKeyValue(this::ByRef1{TMap}, ownkeys::Bool, ownvals::Bool)

# Wrapper of void TMap::SetOwnerValue(Bool_t)
@trydoc raw"""
    SetOwnerValue(this::ByRef1{TMap}, enable::Bool)::Nothing
Set whether this map is the owner (enable==true) of its values.
If it is the owner of its contents, these objects will be deleted whenever the collection itself is deleted. The objects might also be deleted or destructed when Clear is called (depending on the collection).
""" SetOwnerValue(this::ByRef1{TMap}, enable::Bool)

# Wrapper of Int_t TMap::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TMap}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write all objects in this map.
By default all objects in the collection are written individually (each object gets its own key). Note, this is recursive, i.e. objects in collections in the collection are also written individually. To write all objects using a single key specify a name and set option to [TObject!kSingleKey](@ref) (i.e. 1).
""" Write(this::ByRef1{TMap}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of void TUrl::CleanRelativePath()
@trydoc raw"""
    CleanRelativePath(this::ByRef1{TUrl})::Nothing
Recompute the path removing all relative directory jumps via '..'.

""" CleanRelativePath(this::ByRef1{TUrl})

# Wrapper of TUrl & TUrl::operator=(const TUrl &)
@trydoc raw"""
    assign(this::ByRef1{TUrl}, rhs::ByConstRef1{TUrl})::CxxRef1{TUrl}
[TUrl](@ref) assignment operator.

""" assign(this::ByRef1{TUrl}, rhs::ByConstRef1{TUrl})

# Wrapper of void TUrl::SetAnchor(const char *)
@trydoc raw"""
    SetAnchor(this::ByRef1{TUrl}, anchor::ByCopy{String})::Nothing


""" SetAnchor(this::ByRef1{TUrl}, anchor::ByCopy{String})

# Wrapper of void TUrl::SetFile(const char *)
@trydoc raw"""
    SetFile(this::ByRef1{TUrl}, file::ByCopy{String})::Nothing


""" SetFile(this::ByRef1{TUrl}, file::ByCopy{String})

# Wrapper of void TUrl::SetHost(const char *)
@trydoc raw"""
    SetHost(this::ByRef1{TUrl}, host::ByCopy{String})::Nothing


""" SetHost(this::ByRef1{TUrl}, host::ByCopy{String})

# Wrapper of void TUrl::SetOptions(const char *)
@trydoc raw"""
    SetOptions(this::ByRef1{TUrl}, opt::ByCopy{String})::Nothing


""" SetOptions(this::ByRef1{TUrl}, opt::ByCopy{String})

# Wrapper of void TUrl::SetPasswd(const char *)
@trydoc raw"""
    SetPasswd(this::ByRef1{TUrl}, pw::ByCopy{String})::Nothing


""" SetPasswd(this::ByRef1{TUrl}, pw::ByCopy{String})

# Wrapper of void TUrl::SetPort(Int_t)
@trydoc raw"""
    SetPort(this::ByRef1{TUrl}, port::Int32)::Nothing


""" SetPort(this::ByRef1{TUrl}, port::Int32)

# Wrapper of void TUrl::SetProtocol(const char *, Bool_t)
@trydoc raw"""
    SetProtocol(this::ByRef1{TUrl}, proto::ByCopy{String}, setDefaultPort::Bool)::Nothing
Set protocol and, optionally, change the port accordingly.

""" SetProtocol(this::ByRef1{TUrl}, proto::ByCopy{String}, setDefaultPort::Bool)

# Wrapper of void TUrl::SetUrl(const char *, Bool_t)
@trydoc raw"""
    SetUrl(this::ByRef1{TUrl}, url::ByCopy{String}, defaultIsFile::Bool)::Nothing
Parse url character string and split in its different subcomponents.
Use [IsValid()](@ref) to check if URL is legal. 

    url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]

(C++ version of the code)

 Known protocols: http, root, proof, ftp, news and any special protocols defined in the rootrc Url.Special key. The default protocol is "http", unless defaultIsFile is true in which case the url is assumed to be of type "file". If a passwd contains a @ it must be escaped by a \, e.g. "pip@" becomes "pip\\@".

Default ports: http=80, root=1094, proof=1093, ftp=20, news=119. Port #1093 has been assigned by IANA (www.iana.org) to proofd. Port #1094 has been assigned by IANA (www.iana.org) to rootd.
""" SetUrl(this::ByRef1{TUrl}, url::ByCopy{String}, defaultIsFile::Bool)

# Wrapper of void TUrl::SetUser(const char *)
@trydoc raw"""
    SetUser(this::ByRef1{TUrl}, user::ByCopy{String})::Nothing


""" SetUser(this::ByRef1{TUrl}, user::ByCopy{String})

# Wrapper of void TUrl::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TUrl}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TUrl}, ::ByRef1{TBuffer})

# Wrapper of void TUrl::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TUrl}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TUrl}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TMD5::Final()
@trydoc raw"""
    Final(this::ByRef1{TMD5})::Nothing
MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.

""" Final(this::ByRef1{TMD5})

# Wrapper of TMD5 & TMD5::operator=(const TMD5 &)
@trydoc raw"""
    assign(this::ByRef1{TMD5}, rhs::ByConstRef1{TMD5})::CxxRef1{TMD5}
MD5 assignment operator.
Special assignment operator avoids copying unnecessary temp arrays when finalized.
""" assign(this::ByRef1{TMD5}, rhs::ByConstRef1{TMD5})

# Wrapper of Int_t TMD5::SetDigest(const char *)
@trydoc raw"""
    SetDigest(this::ByRef1{TMD5}, md5ascii::ByCopy{String})::Int32
Set the digest from the ASCII representation 'md5ascii'.
The caller is responsible to make sure that the 32 chars md5ascii are valid. Returns -1 if md5ascii is malformed, returns 0 otherwise.
""" SetDigest(this::ByRef1{TMD5}, md5ascii::ByCopy{String})

# Wrapper of void TMD5::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TMD5}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TMD5}, ::ByRef1{TBuffer})

# Wrapper of void TMD5::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TMD5}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TMD5}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TMD5::Update(const UChar_t *, UInt_t)
@trydoc raw"""
    Update(this::ByRef1{TMD5}, buf::ByConstPtr2{UInt8}, len::UInt32)::Nothing
Update [TMD5](@ref) object to reflect the concatenation of another buffer full of bytes.

""" Update(this::ByRef1{TMD5}, buf::ByConstPtr2{UInt8}, len::UInt32)

# Wrapper of void TFolder::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TFolder}, obj::ByPtr1{TObject})::Nothing
Add object to this folder. obj must be a [TObject](@ref) or a [TFolder](@ref).

""" Add(this::ByRef1{TFolder}, obj::ByPtr1{TObject})

# Wrapper of TFolder * TFolder::AddFolder(const char *, const char *, TCollection *)
@trydoc raw"""
    AddFolder(this::ByRef1{TFolder}, name::ByCopy{String}, title::ByCopy{String}, collection::ByPtr1{TCollection})::CxxPtr1{TFolder}
Create a new folder and add it to the list of folders of this folder, return a pointer to the created folder.
Note that a folder can be added to several folders.

If collection is non NULL, the pointer fFolders is set to the existing collection, otherwise a default collection (Tlist) is created. Note that the folder name cannot contain slashes.
""" AddFolder(this::ByRef1{TFolder}, name::ByCopy{String}, title::ByCopy{String}, collection::ByPtr1{TCollection})

# Wrapper of void TFolder::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TFolder}, b::ByPtr1{TBrowser})::Nothing
Browse this folder.

""" Browse(this::ByRef1{TFolder}, b::ByPtr1{TBrowser})

# Wrapper of void TFolder::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TFolder}, option::ByCopy{String})::Nothing
Delete all objects from a folder list.

""" Clear(this::ByRef1{TFolder}, option::ByCopy{String})

# Wrapper of void TFolder::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TFolder}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from a folder.

""" RecursiveRemove(this::ByRef1{TFolder}, obj::ByPtr1{TObject})

# Wrapper of void TFolder::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TFolder}, obj::ByPtr1{TObject})::Nothing
Remove object from this folder. obj must be a [TObject](@ref) or a [TFolder](@ref).

""" Remove(this::ByRef1{TFolder}, obj::ByPtr1{TObject})

# Wrapper of void TFolder::SetOwner(Bool_t)
@trydoc raw"""
    SetOwner(this::ByRef1{TFolder}, owner::Bool)::Nothing
Set ownership.
If the folder is declared owner, when the folder is deleted, all the objects added via [TFolder!Add](@ref) are deleted via [TObject!Delete](@ref), otherwise [TObject!Clear](@ref) is called.

NOTE that folder ownership can be set:

- via [TFolder!SetOwner](@ref)
- or via [TCollection!SetOwner](@ref) on the collection specified to [TFolder!AddFolder](@ref)
""" SetOwner(this::ByRef1{TFolder}, owner::Bool)

# Wrapper of void TFolder::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TFolder}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TFolder}, ::ByRef1{TBuffer})

# Wrapper of void TFolder::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TFolder}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TFolder}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TMacro::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TMacro}, b::ByPtr1{TBrowser})::Nothing
When clicking in the browser, the following action is performed on this macro, depending the content of the variable [TMacro.Browse](@ref).
[TMacro.Browse](@ref) can be set in the system.rootrc or .rootrc file like: 

    TMacro.Browse   :  Action

(C++ version of the code)

 or set via gEnv->SetValue, eg 

    gEnv->SetValue("TMacro.Browse","Print");

(C++ version of the code)

 By default [TMacro.Browse](@ref)="" -if [TMacro.Browse](@ref) ="" the macro is executed -if [TMacro.Browse](@ref) ="Print" the macro is printed in stdout -if [TMacro.Browse](@ref) is of the form "mymacro.C" the macro void mymacro.C(TMacro *m) is called where m=this macro An example of macro.C saving the macro into a file and viewing it with emacs is shown below: 

    void mymacro(TMacro *m) {
       m->SaveSource("xx.log");
       gSystem->Exec("emacs xx.log&");
    }

(C++ version of the code)
""" Browse(this::ByRef1{TMacro}, b::ByPtr1{TBrowser})

# Wrapper of TMD5 * TMacro::Checksum()
@trydoc raw"""
    Checksum(this::ByRef1{TMacro})::CxxPtr1{TMD5}
Returns checksum of the current content.
The returned [TMD5](@ref) object must be deleted by the user. Returns 0 in case of error.
""" Checksum(this::ByRef1{TMacro})

# Wrapper of Longptr_t TMacro::Exec(const char *, Int_t *)
@trydoc raw"""
    Exec(this::ByRef1{TMacro}, params::ByCopy{String}, error::ByPtr2{Int32})::Int64
Execute this macro with params, if params is 0, default parameters (set via SetParams) are used.
error is set to an [TInterpreter!EErrorCode](@ref) by [TApplication!ProcessLine()](@ref). Returns the result of the macro (return value or value of the last expression), cast to a Long_t.
""" Exec(this::ByRef1{TMacro}, params::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of TMacro & TMacro::operator=(const TMacro &)
@trydoc raw"""
    assign(this::ByRef1{TMacro}, ::ByConstRef1{TMacro})::CxxRef1{TMacro}
Copy constructor.

""" assign(this::ByRef1{TMacro}, ::ByConstRef1{TMacro})

# Wrapper of void TMacro::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TMacro}, option::ByCopy{String})::Nothing
Execute this macro (called by [TPad!Paint](@ref)).
""" Paint(this::ByRef1{TMacro}, option::ByCopy{String})

# Wrapper of Int_t TMacro::ReadFile(const char *)
@trydoc raw"""
    ReadFile(this::ByRef1{TMacro}, filename::ByCopy{String})::Int32
Read lines in filename in this macro.

""" ReadFile(this::ByRef1{TMacro}, filename::ByCopy{String})

# Wrapper of void TMacro::SaveSource(const char *)
@trydoc raw"""
    SaveSource(this::ByRef1{TMacro}, filename::ByCopy{String})::Nothing
Save macro source in filename.

""" SaveSource(this::ByRef1{TMacro}, filename::ByCopy{String})

# Wrapper of void TMacro::SetParams(const char *)
@trydoc raw"""
    SetParams(this::ByRef1{TMacro}, params::ByCopy{String})::Nothing
Set default parameters to execute this macro.

""" SetParams(this::ByRef1{TMacro}, params::ByCopy{String})

# Wrapper of void TMacro::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TMacro}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TMacro}, ::ByRef1{TBuffer})

# Wrapper of void TMacro::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TMacro}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TMacro}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TMessageHandler::Add()
@trydoc raw"""
    Add(this::ByRef1{TMessageHandler})::Nothing
Add this message handler to the list of messages handlers.

""" Add(this::ByRef1{TMessageHandler})

# Wrapper of void TMessageHandler::Added()
@trydoc raw"""
    Added(this::ByRef1{TMessageHandler})::Nothing


""" Added(this::ByRef1{TMessageHandler})

# Wrapper of void TMessageHandler::HandleMessage(Long_t, const TObject *)
@trydoc raw"""
    HandleMessage(this::ByRef1{TMessageHandler}, id::Int64, obj::ByConstPtr1{TObject})::Nothing
Store message origin, keep statistics and call [Notify()](@ref).

""" HandleMessage(this::ByRef1{TMessageHandler}, id::Int64, obj::ByConstPtr1{TObject})

# Wrapper of void TMessageHandler::Notified()
@trydoc raw"""
    Notified(this::ByRef1{TMessageHandler})::Nothing


""" Notified(this::ByRef1{TMessageHandler})

# Wrapper of Bool_t TMessageHandler::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TMessageHandler})::Bool
This method must be overridden to handle object notification.

""" Notify(this::ByRef1{TMessageHandler})

# Wrapper of void TMessageHandler::Remove()
@trydoc raw"""
    Remove(this::ByRef1{TMessageHandler})::Nothing
Remove this message handler from the list of messages handlers.

""" Remove(this::ByRef1{TMessageHandler})

# Wrapper of void TMessageHandler::Removed()
@trydoc raw"""
    Removed(this::ByRef1{TMessageHandler})::Nothing


""" Removed(this::ByRef1{TMessageHandler})

# Wrapper of void TMessageHandler::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TMessageHandler}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TMessageHandler}, ::ByRef1{TBuffer})

# Wrapper of void TMessageHandler::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TMessageHandler}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TMessageHandler}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TNotifyLinkBase::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TNotifyLinkBase}, ::ByCopy{String})::Nothing


""" Clear(this::ByRef1{TNotifyLinkBase}, ::ByCopy{String})

# Wrapper of Bool_t TNotifyLinkBase::IsLinked()
@trydoc raw"""
    IsLinked(this::ByRef1{TNotifyLinkBase})::Bool


""" IsLinked(this::ByRef1{TNotifyLinkBase})

# Wrapper of void TROOT::AddClass(TClass *)
@trydoc raw"""
    AddClass(this::ByRef1{TROOT}, cl::ByPtr1{TClass})::Nothing
Add a class to the list and map of classes.
This routine is deprecated, use [TClass!AddClass](@ref) directly.
""" AddClass(this::ByRef1{TROOT}, cl::ByPtr1{TClass})

# Wrapper of void TROOT::Append(TObject *, Bool_t)
@trydoc raw"""
    Append(this::ByRef1{TROOT}, obj::ByPtr1{TObject}, replace::Bool)::Nothing
Append object to this directory.
If replace is true: remove any existing objects with the same same (if the name is not "")
""" Append(this::ByRef1{TROOT}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of void TROOT::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TROOT}, b::ByPtr1{TBrowser})::Nothing
Add browsable objects to [TBrowser](@ref).

""" Browse(this::ByRef1{TROOT}, b::ByPtr1{TBrowser})

# Wrapper of Bool_t TROOT::ClassSaved(TClass *)
@trydoc raw"""
    ClassSaved(this::ByRef1{TROOT}, cl::ByPtr1{TClass})::Bool
return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions writing the C++ code for an object.

""" ClassSaved(this::ByRef1{TROOT}, cl::ByPtr1{TClass})

# Wrapper of void TROOT::CloseFiles()
@trydoc raw"""
    CloseFiles(this::ByRef1{TROOT})::Nothing
Close any files and sockets that gROOT knows about.
This can be used to insures that the files and sockets are closed before any library is unloaded!
""" CloseFiles(this::ByRef1{TROOT})

# Wrapper of void TROOT::EndOfProcessCleanups()
@trydoc raw"""
    EndOfProcessCleanups(this::ByRef1{TROOT})::Nothing
Execute the cleanups necessary at the theend of the process, in particular those that must be executed before the library thestart being unloaded.

""" EndOfProcessCleanups(this::ByRef1{TROOT})

# Wrapper of TObject * TROOT::FindSpecialObject(const char *, void *&)
@trydoc raw"""
    FindSpecialObject(this::ByRef1{TROOT}, name::ByCopy{String}, where::ByPtr2{Nothing})::CxxPtr1{TObject}
Returns address and folder of a [ROOT](@ref) object if it exists.
This function looks in the following order in the [ROOT](@ref) lists:

- List of files
- List of memory mapped files
- List of functions
- List of geometries
- List of canvases
- List of styles
- List of specials
- List of materials in current geometry
- List of shapes in current geometry
- List of matrices in current geometry
- List of Nodes in current geometry
- Current Directory in memory
- Current Directory on file
""" FindSpecialObject(this::ByRef1{TROOT}, name::ByCopy{String}, where::ByPtr2{Nothing})

# Wrapper of void TROOT::ForceStyle(Bool_t)
@trydoc raw"""
    ForceStyle(this::ByRef1{TROOT}, force::Bool)::Nothing


""" ForceStyle(this::ByRef1{TROOT}, force::Bool)

# Wrapper of const char * TROOT::GetGitDate()
@trydoc raw"""
    GetGitDate(this::ByRef1{TROOT})::ByCopy{String}
Return date/time make was run.

""" GetGitDate(this::ByRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfEnums(Bool_t)
@trydoc raw"""
    GetListOfEnums(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}


""" GetListOfEnums(this::ByRef1{TROOT}, load::Bool)

# Wrapper of TCollection * TROOT::GetListOfFunctionTemplates()
@trydoc raw"""
    GetListOfFunctionTemplates(this::ByRef1{TROOT})::CxxPtr1{TCollection}


""" GetListOfFunctionTemplates(this::ByRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfGlobalFunctions(Bool_t)
@trydoc raw"""
    GetListOfGlobalFunctions(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}
Return list containing the TFunctions currently defined.
Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default).
""" GetListOfGlobalFunctions(this::ByRef1{TROOT}, load::Bool)

# Wrapper of TCollection * TROOT::GetListOfGlobals(Bool_t)
@trydoc raw"""
    GetListOfGlobals(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}
Return list containing the TGlobals currently defined.
Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default).
""" GetListOfGlobals(this::ByRef1{TROOT}, load::Bool)

# Wrapper of TCollection * TROOT::GetListOfTypes(Bool_t)
@trydoc raw"""
    GetListOfTypes(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}
Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.
The list is populated on demand. Calling 

    gROOT->GetListOfTypes()->FindObject(nameoftype);

(C++ version of the code)

 will return the [TDataType](@ref) corresponding to 'nameoftype'. If the [TDataType](@ref) is not already in the list itself and the type does exist, a new [TDataType](@ref) will be created and added to the list.

Calling 

    gROOT->GetListOfTypes()->ls(); // or Print()

(C++ version of the code)

 list only the typedefs that have been previously accessed through the list (plus the builtins types).
""" GetListOfTypes(this::ByRef1{TROOT}, load::Bool)

# Wrapper of void TROOT::Idle(UInt_t, const char *)
@trydoc raw"""
    Idle(this::ByRef1{TROOT}, idleTimeInSec::UInt32, command::ByCopy{String})::Nothing
Execute command when system has been idle for idleTimeInSec seconds.

""" Idle(this::ByRef1{TROOT}, idleTimeInSec::UInt32, command::ByCopy{String})

# Wrapper of Int_t TROOT::IgnoreInclude(const char *, const char *)
@trydoc raw"""
    IgnoreInclude(this::ByRef1{TROOT}, fname::ByCopy{String}, expandedfname::ByCopy{String})::Int32
Return 1 if the name of the given include file corresponds to a class that is known to [ROOT](@ref), e.g.
"TLorentzVector.h" versus [TLorentzVector](@ref).
""" IgnoreInclude(this::ByRef1{TROOT}, fname::ByCopy{String}, expandedfname::ByCopy{String})

# Wrapper of Int_t TROOT::LoadClass(const char *, const char *, Bool_t)
@trydoc raw"""
    LoadClass(this::ByRef1{TROOT}, classname::ByCopy{String}, libname::ByCopy{String}, check::Bool)::Int32
Check if class "classname" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored).
If not it will load library "libname". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with "lib" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch.
""" LoadClass(this::ByRef1{TROOT}, classname::ByCopy{String}, libname::ByCopy{String}, check::Bool)

# Wrapper of Int_t TROOT::LoadMacro(const char *, Int_t *, Bool_t)
@trydoc raw"""
    LoadMacro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, check::Bool)::Int32
Load a macro in the interpreter's memory.
Equivalent to the command line command ".L filename". If the filename has "+" or "++" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by [TInterpreter!EErrorCode](@ref). If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error.
""" LoadMacro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, check::Bool)

# Wrapper of Longptr_t TROOT::Macro(const char *, Int_t *, Bool_t)
@trydoc raw"""
    Macro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, padUpdate::Bool)::Int64
Execute a macro in the interpreter.
Equivalent to the command line command ".x filename". If the filename has "+" or "++" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by [TInterpreter!EErrorCode](@ref). If padUpdate is true (default) update the current pad. Returns the macro return value.
""" Macro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, padUpdate::Bool)

# Wrapper of void TROOT::Message(Int_t, const TObject *)
@trydoc raw"""
    Message(this::ByRef1{TROOT}, id::Int32, obj::ByConstPtr1{TObject})::Nothing
Process message id called by obj.

""" Message(this::ByRef1{TROOT}, id::Int32, obj::ByConstPtr1{TObject})

# Wrapper of Longptr_t TROOT::ProcessLine(const char *, Int_t *)
@trydoc raw"""
    ProcessLine(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})::Int64
Process interpreter command via [TApplication!ProcessLine()](@ref).
On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use [ProcessLineSync()](@ref). On non-Win32 platforms there is no difference between [ProcessLine()](@ref) and [ProcessLineSync()](@ref). The possible error codes are defined by [TInterpreter!EErrorCode](@ref). In particular, error will equal to [TInterpreter!kProcessing](@ref) until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t.
""" ProcessLine(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of Longptr_t TROOT::ProcessLineFast(const char *, Int_t *)
@trydoc raw"""
    ProcessLineFast(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})::Int64
Process interpreter command directly via CINT interpreter.
Only executable statements are allowed (no variable declarations), In all other cases use [TROOT!ProcessLine()](@ref). The possible error codes are defined by [TInterpreter!EErrorCode](@ref).
""" ProcessLineFast(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of Longptr_t TROOT::ProcessLineSync(const char *, Int_t *)
@trydoc raw"""
    ProcessLineSync(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})::Int64
Process interpreter command via [TApplication!ProcessLine()](@ref).
On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between [ProcessLine()](@ref) and [ProcessLineSync()](@ref). The possible error codes are defined by [TInterpreter!EErrorCode](@ref). Returns the result of the command, cast to a Longptr_t.
""" ProcessLineSync(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of void TROOT::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TROOT}, obj::ByPtr1{TObject})::Nothing
Recursively remove this object from the list of Cleanups.
Typically RecursiveRemove is implemented by classes that can contain mulitple references to a same object or shared ownership of the object with others.
""" RecursiveRemove(this::ByRef1{TROOT}, obj::ByPtr1{TObject})

# Wrapper of void TROOT::RefreshBrowsers()
@trydoc raw"""
    RefreshBrowsers(this::ByRef1{TROOT})::Nothing
Refresh all browsers.
Call this method when some command line command or script has changed the browser contents. Not needed for objects that have the kMustCleanup bit set. Most useful to update browsers that show the file system or other objects external to the running [ROOT](@ref) session.
""" RefreshBrowsers(this::ByRef1{TROOT})

# Wrapper of TObject * TROOT::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TROOT}, ::ByPtr1{TObject})::CxxPtr1{TObject}
Remove an object from the in-memory list.
Since [TROOT](@ref) is global_ resource, this is lock protected.
""" Remove(this::ByRef1{TROOT}, ::ByPtr1{TObject})

# Wrapper of void TROOT::RemoveClass(TClass *)
@trydoc raw"""
    RemoveClass(this::ByRef1{TROOT}, ::ByPtr1{TClass})::Nothing
Remove a class from the list and map of classes.
This routine is deprecated, use [TClass!RemoveClass](@ref) directly.
""" RemoveClass(this::ByRef1{TROOT}, ::ByPtr1{TClass})

# Wrapper of void TROOT::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TROOT}, option::ByCopy{String})::Nothing
Delete all global_ interpreter objects created since the last call to Reset.
If option="a" is set reset to startup context (i.e. unload also all loaded files, classes, structs, typedefs, etc.).

This function is typically used at the beginning (or theend) of an unnamed macro to clean the environment.

IMPORTANT WARNING: Do not use this call from within any function (neither compiled nor interpreted. This should only be used from a unnamed macro (which starts with a { (curly braces) ). For example, using [TROOT!Reset](@ref) from within an interpreted function will lead to the unloading of the dictionary and source file, including the one defining the function being executed.
""" Reset(this::ByRef1{TROOT}, option::ByCopy{String})

# Wrapper of void TROOT::ResetClassSaved()
@trydoc raw"""
    ResetClassSaved(this::ByRef1{TROOT})::Nothing
Reset the ClassSaved status of all classes.

""" ResetClassSaved(this::ByRef1{TROOT})

# Wrapper of void TROOT::SaveContext()
@trydoc raw"""
    SaveContext(this::ByRef1{TROOT})::Nothing
Save the current interpreter context.

""" SaveContext(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetApplication(TApplication *)
@trydoc raw"""
    SetApplication(this::ByRef1{TROOT}, app::ByPtr1{TApplication})::Nothing


""" SetApplication(this::ByRef1{TROOT}, app::ByPtr1{TApplication})

# Wrapper of void TROOT::SetBatch(Bool_t)
@trydoc raw"""
    SetBatch(this::ByRef1{TROOT}, batch::Bool)::Nothing
Set batch mode for [ROOT](@ref) If the argument evaluates to `true`, the session does not use interactive graphics.
If web graphics runs in server mode, the web widgets are still available via URL
""" SetBatch(this::ByRef1{TROOT}, batch::Bool)

# Wrapper of void TROOT::SetCutClassName(const char *)
@trydoc raw"""
    SetCutClassName(this::ByRef1{TROOT}, name::ByCopy{String})::Nothing
Set the default graphical cut class name for the graphics editor By default the graphics editor creates an instance of a class [TCutG](@ref).
This function may be called to specify a different class that MUST derive from [TCutG](@ref)
""" SetCutClassName(this::ByRef1{TROOT}, name::ByCopy{String})

# Wrapper of void TROOT::SetDefCanvasName(const char *)
@trydoc raw"""
    SetDefCanvasName(this::ByRef1{TROOT}, name::ByCopy{String})::Nothing


""" SetDefCanvasName(this::ByRef1{TROOT}, name::ByCopy{String})

# Wrapper of void TROOT::SetEditHistograms(Bool_t)
@trydoc raw"""
    SetEditHistograms(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetEditHistograms(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetEditorMode(const char *)
@trydoc raw"""
    SetEditorMode(this::ByRef1{TROOT}, mode::ByCopy{String})::Nothing
Set editor mode.

""" SetEditorMode(this::ByRef1{TROOT}, mode::ByCopy{String})

# Wrapper of void TROOT::SetEscape(Bool_t)
@trydoc raw"""
    SetEscape(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetEscape(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetExecutingMacro(Bool_t)
@trydoc raw"""
    SetExecutingMacro(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetExecutingMacro(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetFromPopUp(Bool_t)
@trydoc raw"""
    SetFromPopUp(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetFromPopUp(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetInterrupt(Bool_t)
@trydoc raw"""
    SetInterrupt(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetInterrupt(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetLineHasBeenProcessed()
@trydoc raw"""
    SetLineHasBeenProcessed(this::ByRef1{TROOT})::Nothing


""" SetLineHasBeenProcessed(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetLineIsProcessing()
@trydoc raw"""
    SetLineIsProcessing(this::ByRef1{TROOT})::Nothing


""" SetLineIsProcessing(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetMustClean(Bool_t)
@trydoc raw"""
    SetMustClean(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetMustClean(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetReadingObject(Bool_t)
@trydoc raw"""
    SetReadingObject(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetReadingObject(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetSelectedPad(TVirtualPad *)
@trydoc raw"""
    SetSelectedPad(this::ByRef1{TROOT}, pad::ByPtr1{TVirtualPad})::Nothing


""" SetSelectedPad(this::ByRef1{TROOT}, pad::ByPtr1{TVirtualPad})

# Wrapper of void TROOT::SetSelectedPrimitive(const TObject *)
@trydoc raw"""
    SetSelectedPrimitive(this::ByRef1{TROOT}, obj::ByConstPtr1{TObject})::Nothing


""" SetSelectedPrimitive(this::ByRef1{TROOT}, obj::ByConstPtr1{TObject})

# Wrapper of void TROOT::SetStyle(const char *)
@trydoc raw"""
    SetStyle(this::ByRef1{TROOT}, stylename::ByCopy{String})::Nothing
Change current style to style with name stylename.

""" SetStyle(this::ByRef1{TROOT}, stylename::ByCopy{String})

# Wrapper of void TROOT::SetWebDisplay(const char *)
@trydoc raw"""
    SetWebDisplay(this::ByRef1{TROOT}, webdisplay::ByCopy{String})::Nothing
Specify where web graphics shall be rendered.
The input parameter `webdisplay` defines where web graphics is rendered. `webdisplay` parameter may contain:

- "firefox": select Mozilla Firefox browser for interactive web display
- "chrome": select Google Chrome browser for interactive web display
- "edge": select Microsoft Edge browser for interactive web display
- "native": select one of the natively-supported web browsers firefox/chrome/edge for interactive web display
- "qt5": uses QWebEngine from Qt5, no real http server started (requires `qt5web` component build for [ROOT](@ref))
- "qt6": uses QWebEngine from Qt6, no real http server started (requires `qt6web` component build for [ROOT](@ref))
- "cef": uses Chromium Embeded Framework, no real http server started (requires `cefweb` component build for [ROOT](@ref))
- "local_": select on of available local_ (without http server) engines like qt5/qt6/cef
- "default": system default web browser, invoked with `xdg-open` on Linux, `thestart` on Mac or `open` on Windows
- "on": try "local_", then "native", then "default" option
- "off": turns off the web display and comes back to normal graphics in interactive mode.
- "server:port": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output
""" SetWebDisplay(this::ByRef1{TROOT}, webdisplay::ByCopy{String})

# Wrapper of void TROOT::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TROOT}, ::ByRef1{TBuffer})::Nothing
[TDirectory](@ref) Streamer.

""" Streamer(this::ByRef1{TROOT}, ::ByRef1{TBuffer})

# Wrapper of void TROOT::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TROOT}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TROOT}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TROOT::Time(Int_t)
@trydoc raw"""
    Time(this::ByRef1{TROOT}, casetime::Int32)::Nothing


""" Time(this::ByRef1{TROOT}, casetime::Int32)

# Wrapper of void TPluginManager::AddHandler(const char *, const char *, const char *, const char *, const char *, const char *)
@trydoc raw"""
    AddHandler(this::ByRef1{TPluginManager}, base::ByCopy{String}, regexp::ByCopy{String}, className::ByCopy{String}, pluginName::ByCopy{String}, ctor::ByCopy{String}, origin::ByCopy{String})::Nothing
Add plugin handler to the list of handlers.
If there is already a handler defined for the same base and regexp it will be replaced.
""" AddHandler(this::ByRef1{TPluginManager}, base::ByCopy{String}, regexp::ByCopy{String}, className::ByCopy{String}, pluginName::ByCopy{String}, ctor::ByCopy{String}, origin::ByCopy{String})

# Wrapper of TPluginHandler * TPluginManager::FindHandler(const char *, const char *)
@trydoc raw"""
    FindHandler(this::ByRef1{TPluginManager}, base::ByCopy{String}, uri::ByCopy{String})::CxxPtr1{TPluginHandler}
Returns the handler if there exists a handler for the specified URI.
The uri can be 0 in which case the first matching plugin handler will be returned. Returns 0 in case handler is not found.
""" FindHandler(this::ByRef1{TPluginManager}, base::ByCopy{String}, uri::ByCopy{String})

# Wrapper of void TPluginManager::LoadHandlersFromEnv(TEnv *)
@trydoc raw"""
    LoadHandlersFromEnv(this::ByRef1{TPluginManager}, env::ByPtr1{TEnv})::Nothing
Load plugin handlers specified in config file, like:
Plugin.TSQLServer:  ^mysql:   TMySQLServer   MySQL "TMySQLServer(...)"
    +Plugin.TSQLServer: ^pgsql:   TPgSQLServer   PgSQL "TPgSQLServer(...)"

(C++ version of the code)

 The + allows the extension of an already defined resource (see [TEnv](@ref)).
""" LoadHandlersFromEnv(this::ByRef1{TPluginManager}, env::ByPtr1{TEnv})

# Wrapper of void TPluginManager::LoadHandlersFromPluginDirs(const char *)
@trydoc raw"""
    LoadHandlersFromPluginDirs(this::ByRef1{TPluginManager}, base::ByCopy{String})::Nothing
Load plugin handlers specified via macros in a list of plugin directories.
The `$ROOTSYS/etc/plugins` is the default top plugin directory specified in `$ROOTSYS/etc/system.rootrc`. The macros must have names like `<BaseClass>/PX0_<PluginClass>.C`, e.g. //`TSQLServer/P20_TMySQLServer.C`, to allow easy sorting and grouping. If the BaseClass is in a namespace the directory must have the name NameSpace@BaseClass as : is a reserved pathname character on some operating systems. Macros not beginning with 'P' and ending with ".C" are ignored. If base is specified only plugin macros for that base class are loaded. The macros typically should look like: 

    void P10_TDCacheFile()
    {
        gPluginMgr->AddHandler("TFile", "^dcache", "TDCacheFile",
           "DCache", "TDCacheFile(const char*,Option_t*,const char*,Int_t)");
    }

(C++ version of the code)

 In general these macros should not cause side effects, by changing global_ [ROOT](@ref) state via, e.g. gSystem calls, etc. However, in specific cases this might be useful, e.g. adding a library search path, adding a specific dependency, check on some OS or [ROOT](@ref) capability or downloading of the plugin.
""" LoadHandlersFromPluginDirs(this::ByRef1{TPluginManager}, base::ByCopy{String})

# Wrapper of void TPluginManager::RemoveHandler(const char *, const char *)
@trydoc raw"""
    RemoveHandler(this::ByRef1{TPluginManager}, base::ByCopy{String}, regexp::ByCopy{String})::Nothing
Remove handler for the specified base class and the specified regexp.
If regexp=0 remove all handlers for the specified base.
""" RemoveHandler(this::ByRef1{TPluginManager}, base::ByCopy{String}, regexp::ByCopy{String})

# Wrapper of void TPluginManager::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TPluginManager}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TPluginManager}, ::ByRef1{TBuffer})

# Wrapper of void TPluginManager::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TPluginManager}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TPluginManager}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TStyle::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TStyle}, b::ByPtr1{TBrowser})::Nothing
Browse the style object.

""" Browse(this::ByRef1{TStyle}, b::ByPtr1{TBrowser})

# Wrapper of void TStyle::cd()
@trydoc raw"""
    cd(this::ByRef1{TStyle})::Nothing
Change current style.

""" cd(this::ByRef1{TStyle})

# Wrapper of Int_t TStyle::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TStyle}, px::Int32, py::Int32)::Int32
Function used by the [TStyle](@ref) manager when drawing a canvas showing the current style.

""" DistancetoPrimitive(this::ByRef1{TStyle}, px::Int32, py::Int32)

# Wrapper of TAttText * TStyle::GetAttDate()
@trydoc raw"""
    GetAttDate(this::ByRef1{TStyle})::CxxPtr1{TAttText}


""" GetAttDate(this::ByRef1{TStyle})

# Wrapper of TStyle & TStyle::operator=(const TStyle &)
@trydoc raw"""
    assign(this::ByRef1{TStyle}, style::ByConstRef1{TStyle})::CxxRef1{TStyle}
Assignment operator.

""" assign(this::ByRef1{TStyle}, style::ByConstRef1{TStyle})

# Wrapper of void TStyle::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TStyle}, option::ByCopy{String})::Nothing
Copy this style to gStyle.

""" Paint(this::ByRef1{TStyle}, option::ByCopy{String})

# Wrapper of void TStyle::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TStyle}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TStyle}, option::ByCopy{String})

# Wrapper of void TStyle::SaveSource(const char *, Option_t *)
@trydoc raw"""
    SaveSource(this::ByRef1{TStyle}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save the current style in a C++ macro file.

""" SaveSource(this::ByRef1{TStyle}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TStyle::SetAxisColor(Color_t, Option_t *)
@trydoc raw"""
    SetAxisColor(this::ByRef1{TStyle}, color::Int16, axis::ByCopy{String})::Nothing
Set color to draw the axis line and tick marks.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetAxisColor(this::ByRef1{TStyle}, color::Int16, axis::ByCopy{String})

# Wrapper of void TStyle::SetAxisMaxDigits(Int_t)
@trydoc raw"""
    SetAxisMaxDigits(this::ByRef1{TStyle}, maxd::Int32)::Nothing
Method set maximum number of digits permitted for the axis labels above which the notation with 10^N is used.
For example, to accept 6 digits number like 900000 on an axis call `gStyle->SetAxisMaxDigits(6)`. The default value is 5. Warning: this function changes the max number of digits in all axes. If you only want to change the digits of the current [TGaxis](@ref) instance, use axis->SetNdivisions(N*1000000 + (axis->GetNdiv()%1000000)) instead of gStyle->SetAxisMaxDigits(N).
""" SetAxisMaxDigits(this::ByRef1{TStyle}, maxd::Int32)

# Wrapper of void TStyle::SetBarOffset(Float_t)
@trydoc raw"""
    SetBarOffset(this::ByRef1{TStyle}, baroff::Float32)::Nothing


""" SetBarOffset(this::ByRef1{TStyle}, baroff::Float32)

# Wrapper of void TStyle::SetBarWidth(Float_t)
@trydoc raw"""
    SetBarWidth(this::ByRef1{TStyle}, barwidth::Float32)::Nothing


""" SetBarWidth(this::ByRef1{TStyle}, barwidth::Float32)

# Wrapper of void TStyle::SetCandleBoxRange(Double_t)
@trydoc raw"""
    SetCandleBoxRange(this::ByRef1{TStyle}, bRange::Float64)::Nothing
By setting box-range for candle plot, one can force the box of the candle-chart to cover that given fraction of the distribution.
Set bRange between 0 and 1. Default is 0.5 gStyle->SetCandleBoxRange(0.68) will set all candle-charts to cover 68% of the distribution by the box
""" SetCandleBoxRange(this::ByRef1{TStyle}, bRange::Float64)

# Wrapper of void TStyle::SetCandleScaled(Bool_t)
@trydoc raw"""
    SetCandleScaled(this::ByRef1{TStyle}, on::Bool)::Nothing


""" SetCandleScaled(this::ByRef1{TStyle}, on::Bool)

# Wrapper of void TStyle::SetCandleWhiskerRange(Double_t)
@trydoc raw"""
    SetCandleWhiskerRange(this::ByRef1{TStyle}, wRange::Float64)::Nothing
By setting whisker-range for candle plot, one can force the whiskers to cover the fraction of the distribution.
Set wRange between 0 and 1. Default is 1 gStyle->SetCandleWhiskerRange(0.95) will set all candle-charts to cover 95% of the distribution with the whiskers. Can only be used with the standard-whisker definition
""" SetCandleWhiskerRange(this::ByRef1{TStyle}, wRange::Float64)

# Wrapper of void TStyle::SetCanvasBorderMode(Int_t)
@trydoc raw"""
    SetCanvasBorderMode(this::ByRef1{TStyle}, mode::Int32)::Nothing


""" SetCanvasBorderMode(this::ByRef1{TStyle}, mode::Int32)

# Wrapper of void TStyle::SetCanvasBorderSize(Width_t)
@trydoc raw"""
    SetCanvasBorderSize(this::ByRef1{TStyle}, size::Int16)::Nothing


""" SetCanvasBorderSize(this::ByRef1{TStyle}, size::Int16)

# Wrapper of void TStyle::SetCanvasColor(Color_t)
@trydoc raw"""
    SetCanvasColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetCanvasColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetCanvasDefH(Int_t)
@trydoc raw"""
    SetCanvasDefH(this::ByRef1{TStyle}, h::Int32)::Nothing


""" SetCanvasDefH(this::ByRef1{TStyle}, h::Int32)

# Wrapper of void TStyle::SetCanvasDefW(Int_t)
@trydoc raw"""
    SetCanvasDefW(this::ByRef1{TStyle}, w::Int32)::Nothing


""" SetCanvasDefW(this::ByRef1{TStyle}, w::Int32)

# Wrapper of void TStyle::SetCanvasDefX(Int_t)
@trydoc raw"""
    SetCanvasDefX(this::ByRef1{TStyle}, topx::Int32)::Nothing


""" SetCanvasDefX(this::ByRef1{TStyle}, topx::Int32)

# Wrapper of void TStyle::SetCanvasDefY(Int_t)
@trydoc raw"""
    SetCanvasDefY(this::ByRef1{TStyle}, topy::Int32)::Nothing


""" SetCanvasDefY(this::ByRef1{TStyle}, topy::Int32)

# Wrapper of void TStyle::SetCanvasPreferGL(Bool_t)
@trydoc raw"""
    SetCanvasPreferGL(this::ByRef1{TStyle}, prefer::Bool)::Nothing


""" SetCanvasPreferGL(this::ByRef1{TStyle}, prefer::Bool)

# Wrapper of void TStyle::SetCapLinePS(Int_t)
@trydoc raw"""
    SetCapLinePS(this::ByRef1{TStyle}, capline::Int32)::Nothing
Set the line cap method used for PostScript, PDF and SVG output. See `TPostScript!SetLineCap` for details.

""" SetCapLinePS(this::ByRef1{TStyle}, capline::Int32)

# Wrapper of void TStyle::SetColorModelPS(Int_t)
@trydoc raw"""
    SetColorModelPS(this::ByRef1{TStyle}, c::Int32)::Nothing
Define the color model used by [TPostScript](@ref) and [TPDF](@ref) (RGB or CMYK).
CMY and CMYK models are subtractive color models unlike RGB which is additive. They are mainly used for printing purposes. CMY means Cyan Magenta Yellow. To convert RGB to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more component K (black). The conversion from RGB to CMYK is: 

    Double_t Black   = TMath!Min(TMath!Min(1-Red,1-Green),1-Blue);
    Double_t Cyan    = (1-Red-Black)/(1-Black);
    Double_t Magenta = (1-Green-Black)/(1-Black);
    Double_t Yellow  = (1-Blue-Black)/(1-Black);

(C++ version of the code)

 CMYK adds the black component which allows better quality for black printing. PostScript and PDF support the CMYK model.

- c = 0 means [TPostScript](@ref) and [TPDF](@ref) will use RGB color model (default)
- c = 1 means [TPostScript](@ref) and [TPDF](@ref) will use CMYK color model
""" SetColorModelPS(this::ByRef1{TStyle}, c::Int32)

# Wrapper of void TStyle::SetDateX(Float_t)
@trydoc raw"""
    SetDateX(this::ByRef1{TStyle}, x::Float32)::Nothing


""" SetDateX(this::ByRef1{TStyle}, x::Float32)

# Wrapper of void TStyle::SetDateY(Float_t)
@trydoc raw"""
    SetDateY(this::ByRef1{TStyle}, y::Float32)::Nothing


""" SetDateY(this::ByRef1{TStyle}, y::Float32)

# Wrapper of void TStyle::SetDrawBorder(Int_t)
@trydoc raw"""
    SetDrawBorder(this::ByRef1{TStyle}, drawborder::Int32)::Nothing


""" SetDrawBorder(this::ByRef1{TStyle}, drawborder::Int32)

# Wrapper of void TStyle::SetEndErrorSize(Float_t)
@trydoc raw"""
    SetEndErrorSize(this::ByRef1{TStyle}, np::Float32)::Nothing
Set the size (in pixels) of the small lines drawn at the theend of the error bars ([TH1](@ref) or [TGraphErrors](@ref)).
The default value is 2 pixels. Set np=0 to remove these lines
""" SetEndErrorSize(this::ByRef1{TStyle}, np::Float32)

# Wrapper of void TStyle::SetErrorX(Float_t)
@trydoc raw"""
    SetErrorX(this::ByRef1{TStyle}, errorx::Float32)::Nothing


""" SetErrorX(this::ByRef1{TStyle}, errorx::Float32)

# Wrapper of void TStyle::SetExponentOffset(Float_t, Float_t, Option_t *)
@trydoc raw"""
    SetExponentOffset(this::ByRef1{TStyle}, xoff::Float32, yoff::Float32, axis::ByCopy{String})::Nothing
Method set X and Y offset of the axis 10^n notation.
It applies on axis belonging to an histogram ([TAxis](@ref)). It has no effect on standalone [TGaxis](@ref). It is in % of the pad size. It can be negative. axis specifies which axis ("x","y"), default = "x" if axis="xz" set the two axes
""" SetExponentOffset(this::ByRef1{TStyle}, xoff::Float32, yoff::Float32, axis::ByCopy{String})

# Wrapper of void TStyle::SetFitFormat(const char *)
@trydoc raw"""
    SetFitFormat(this::ByRef1{TStyle}, format::ByCopy{String})::Nothing


""" SetFitFormat(this::ByRef1{TStyle}, format::ByCopy{String})

# Wrapper of void TStyle::SetFrameBorderMode(Int_t)
@trydoc raw"""
    SetFrameBorderMode(this::ByRef1{TStyle}, mode::Int32)::Nothing


""" SetFrameBorderMode(this::ByRef1{TStyle}, mode::Int32)

# Wrapper of void TStyle::SetFrameBorderSize(Width_t)
@trydoc raw"""
    SetFrameBorderSize(this::ByRef1{TStyle}, size::Int16)::Nothing


""" SetFrameBorderSize(this::ByRef1{TStyle}, size::Int16)

# Wrapper of void TStyle::SetFrameFillColor(Color_t)
@trydoc raw"""
    SetFrameFillColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetFrameFillColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetFrameFillStyle(Style_t)
@trydoc raw"""
    SetFrameFillStyle(this::ByRef1{TStyle}, styl::Int16)::Nothing


""" SetFrameFillStyle(this::ByRef1{TStyle}, styl::Int16)

# Wrapper of void TStyle::SetFrameLineColor(Color_t)
@trydoc raw"""
    SetFrameLineColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetFrameLineColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetFrameLineStyle(Style_t)
@trydoc raw"""
    SetFrameLineStyle(this::ByRef1{TStyle}, styl::Int16)::Nothing


""" SetFrameLineStyle(this::ByRef1{TStyle}, styl::Int16)

# Wrapper of void TStyle::SetFrameLineWidth(Width_t)
@trydoc raw"""
    SetFrameLineWidth(this::ByRef1{TStyle}, width::Int16)::Nothing


""" SetFrameLineWidth(this::ByRef1{TStyle}, width::Int16)

# Wrapper of void TStyle::SetFuncColor(Color_t)
@trydoc raw"""
    SetFuncColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetFuncColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetFuncStyle(Style_t)
@trydoc raw"""
    SetFuncStyle(this::ByRef1{TStyle}, style::Int16)::Nothing


""" SetFuncStyle(this::ByRef1{TStyle}, style::Int16)

# Wrapper of void TStyle::SetFuncWidth(Width_t)
@trydoc raw"""
    SetFuncWidth(this::ByRef1{TStyle}, width::Int16)::Nothing


""" SetFuncWidth(this::ByRef1{TStyle}, width::Int16)

# Wrapper of void TStyle::SetGridColor(Color_t)
@trydoc raw"""
    SetGridColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetGridColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetGridStyle(Style_t)
@trydoc raw"""
    SetGridStyle(this::ByRef1{TStyle}, style::Int16)::Nothing


""" SetGridStyle(this::ByRef1{TStyle}, style::Int16)

# Wrapper of void TStyle::SetGridWidth(Width_t)
@trydoc raw"""
    SetGridWidth(this::ByRef1{TStyle}, width::Int16)::Nothing


""" SetGridWidth(this::ByRef1{TStyle}, width::Int16)

# Wrapper of void TStyle::SetHatchesLineWidth(Int_t)
@trydoc raw"""
    SetHatchesLineWidth(this::ByRef1{TStyle}, l::Int32)::Nothing


""" SetHatchesLineWidth(this::ByRef1{TStyle}, l::Int32)

# Wrapper of void TStyle::SetHatchesSpacing(Double_t)
@trydoc raw"""
    SetHatchesSpacing(this::ByRef1{TStyle}, h::Float64)::Nothing


""" SetHatchesSpacing(this::ByRef1{TStyle}, h::Float64)

# Wrapper of void TStyle::SetHeaderPS(const char *)
@trydoc raw"""
    SetHeaderPS(this::ByRef1{TStyle}, header::ByCopy{String})::Nothing
Define a string to be inserted in the Postscript header.
The string in header will be added to the Postscript file immediately following the %Page line For example, this string may contain special Postscript instructions like 

    200 200 translate

(C++ version of the code)

 the following header string will print the string "my annotation" at the bottom left corner of the page (outside the user area) 

    "gsave 100 -100 t 0 r 0 0 m /Helvetica-Bold findfont 56 sf 0 0 m ( my annotation ) show gr"

(C++ version of the code)

 This information is used in [TPostScript!Initialize](@ref)
""" SetHeaderPS(this::ByRef1{TStyle}, header::ByCopy{String})

# Wrapper of void TStyle::SetHistFillColor(Color_t)
@trydoc raw"""
    SetHistFillColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetHistFillColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetHistFillStyle(Style_t)
@trydoc raw"""
    SetHistFillStyle(this::ByRef1{TStyle}, styl::Int16)::Nothing


""" SetHistFillStyle(this::ByRef1{TStyle}, styl::Int16)

# Wrapper of void TStyle::SetHistLineColor(Color_t)
@trydoc raw"""
    SetHistLineColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetHistLineColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetHistLineStyle(Style_t)
@trydoc raw"""
    SetHistLineStyle(this::ByRef1{TStyle}, styl::Int16)::Nothing


""" SetHistLineStyle(this::ByRef1{TStyle}, styl::Int16)

# Wrapper of void TStyle::SetHistLineWidth(Width_t)
@trydoc raw"""
    SetHistLineWidth(this::ByRef1{TStyle}, width::Int16)::Nothing


""" SetHistLineWidth(this::ByRef1{TStyle}, width::Int16)

# Wrapper of void TStyle::SetHistMinimumZero(Bool_t)
@trydoc raw"""
    SetHistMinimumZero(this::ByRef1{TStyle}, zero::Bool)::Nothing
If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms is set to 0.
If the minimum bin content is greater than 0 and [TH1!SetMinimum](@ref) has not been called. Otherwise the minimum is based on the minimum bin content.
""" SetHistMinimumZero(this::ByRef1{TStyle}, zero::Bool)

# Wrapper of void TStyle::SetHistTopMargin(Double_t)
@trydoc raw"""
    SetHistTopMargin(this::ByRef1{TStyle}, hmax::Float64)::Nothing


""" SetHistTopMargin(this::ByRef1{TStyle}, hmax::Float64)

# Wrapper of void TStyle::SetImageScaling(Float_t)
@trydoc raw"""
    SetImageScaling(this::ByRef1{TStyle}, s::Float32)::Nothing


""" SetImageScaling(this::ByRef1{TStyle}, s::Float32)

# Wrapper of void TStyle::SetIsReading(Bool_t)
@trydoc raw"""
    SetIsReading(this::ByRef1{TStyle}, reading::Bool)::Nothing
Sets the `fIsReading` member to reading (default=kTRUE).
`fIsReading` (used via `gStyle->IsReading()`) can be used in the functions `myclass!UseCurrentStyle` to read from the current style or write to the current style
""" SetIsReading(this::ByRef1{TStyle}, reading::Bool)

# Wrapper of void TStyle::SetJoinLinePS(Int_t)
@trydoc raw"""
    SetJoinLinePS(this::ByRef1{TStyle}, joinline::Int32)::Nothing
Set the line join method used for PostScript, PDF and SVG output. See `TPostScript!SetLineJoin` for details.

""" SetJoinLinePS(this::ByRef1{TStyle}, joinline::Int32)

# Wrapper of void TStyle::SetLabelColor(Color_t, Option_t *)
@trydoc raw"""
    SetLabelColor(this::ByRef1{TStyle}, color::Int16, axis::ByCopy{String})::Nothing
Set axis labels color.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelColor(this::ByRef1{TStyle}, color::Int16, axis::ByCopy{String})

# Wrapper of void TStyle::SetLabelFont(Style_t, Option_t *)
@trydoc raw"""
    SetLabelFont(this::ByRef1{TStyle}, font::Int16, axis::ByCopy{String})::Nothing
Set font number used to draw axis labels.
- font : Text font code = 10*fontnumber + precision

    - Font numbers must be between 1 and 14
    - precision = 1 fast hardware fonts (steps in the size)
    - precision = 2 scalable and rotatable hardware fonts The default font number is 62. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelFont(this::ByRef1{TStyle}, font::Int16, axis::ByCopy{String})

# Wrapper of void TStyle::SetLabelOffset(Float_t, Option_t *)
@trydoc raw"""
    SetLabelOffset(this::ByRef1{TStyle}, offset::Float32, axis::ByCopy{String})::Nothing
Set offset between axis and axis labels.
The offset is expressed as a percent of the pad height. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelOffset(this::ByRef1{TStyle}, offset::Float32, axis::ByCopy{String})

# Wrapper of void TStyle::SetLabelSize(Float_t, Option_t *)
@trydoc raw"""
    SetLabelSize(this::ByRef1{TStyle}, size::Float32, axis::ByCopy{String})::Nothing
Set size of axis labels.
The size is expressed as a percent of the pad height. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelSize(this::ByRef1{TStyle}, size::Float32, axis::ByCopy{String})

# Wrapper of void TStyle::SetLegendBorderSize(Width_t)
@trydoc raw"""
    SetLegendBorderSize(this::ByRef1{TStyle}, size::Int16)::Nothing


""" SetLegendBorderSize(this::ByRef1{TStyle}, size::Int16)

# Wrapper of void TStyle::SetLegendFillColor(Color_t)
@trydoc raw"""
    SetLegendFillColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetLegendFillColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetLegendFont(Style_t)
@trydoc raw"""
    SetLegendFont(this::ByRef1{TStyle}, font::Int16)::Nothing


""" SetLegendFont(this::ByRef1{TStyle}, font::Int16)

# Wrapper of void TStyle::SetLegendTextSize(Double_t)
@trydoc raw"""
    SetLegendTextSize(this::ByRef1{TStyle}, size::Float64)::Nothing


""" SetLegendTextSize(this::ByRef1{TStyle}, size::Float64)

# Wrapper of void TStyle::SetLegoInnerR(Float_t)
@trydoc raw"""
    SetLegoInnerR(this::ByRef1{TStyle}, rad::Float32)::Nothing


""" SetLegoInnerR(this::ByRef1{TStyle}, rad::Float32)

# Wrapper of void TStyle::SetLineScalePS(Float_t)
@trydoc raw"""
    SetLineScalePS(this::ByRef1{TStyle}, scale::Float32)::Nothing


""" SetLineScalePS(this::ByRef1{TStyle}, scale::Float32)

# Wrapper of void TStyle::SetLineStyleString(Int_t, const char *)
@trydoc raw"""
    SetLineStyleString(this::ByRef1{TStyle}, i::Int32, text::ByCopy{String})::Nothing
Set line style string using the PostScript convention.
A line is a suite of segments, each segment is described by the number of pixels. The initial and alternating elements (second, fourth, and so on) are the dashes, and the others spaces between dashes.

Default fixed line styles are pre-defined as: 

    linestyle 1  "[]"             solid
    linestyle 2  "[12 12]"        dashed
    linestyle 3  "[4 8]"          dotted
    linestyle 4  "[12 16 4 16]"   dash-dotted

(C++ version of the code)

 For example the following lines define the line style 5 to 9. 

    gStyle->SetLineStyleString(5,"20 12 4 12");
    gStyle->SetLineStyleString(6,"20 12 4 12 4 12 4 12");
    gStyle->SetLineStyleString(7,"20 20");
    gStyle->SetLineStyleString(8,"20 12 4 12 4 12");
    gStyle->SetLineStyleString(9,"80 20");

(C++ version of the code)

 ![https://root.cern/doc/v636/base_linestyle.png](https://root.cern/doc/v636/base_linestyle.png)
 Note:

- Up to 30 different styles may be defined.
- The opening and closing brackets may be omitted
- It is recommended to use 4 as the smallest segment length and multiple of 4 for other lengths.
- The line style 1 to 10 are predefined. 1 to 4 cannot be changed.
""" SetLineStyleString(this::ByRef1{TStyle}, i::Int32, text::ByCopy{String})

# Wrapper of void TStyle::SetNdivisions(Int_t, Option_t *)
@trydoc raw"""
    SetNdivisions(this::ByRef1{TStyle}, n::Int32, axis::ByCopy{String})::Nothing
Set the number of divisions to draw an axis.
ndiv : Number of divisions. 

    n = N1 + 100*N2 + 10000*N3
    N1=number of primary divisions.
    N2=number of secondary divisions.
    N3=number of 3rd divisions.
        e.g.:
        nndi=0 --> no tick marks.
        nndi=2 --> 2 divisions, one tick mark in the middle
                   of the axis.

(C++ version of the code)

 axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetNdivisions(this::ByRef1{TStyle}, n::Int32, axis::ByCopy{String})

# Wrapper of void TStyle::SetNumberContours(Int_t)
@trydoc raw"""
    SetNumberContours(this::ByRef1{TStyle}, number::Int32)::Nothing
Set the default number of contour levels when drawing 2-d plots.

""" SetNumberContours(this::ByRef1{TStyle}, number::Int32)

# Wrapper of void TStyle::SetOptDate(Int_t)
@trydoc raw"""
    SetOptDate(this::ByRef1{TStyle}, datefl::Int32)::Nothing
If optdate is non null, the current date/time will be printed in the canvas.
The position of the date string can be controlled by: optdate = 10*format + mode

- mode = 1 (default) date is printed in the bottom/left corner.
- mode = 2 date is printed in the bottom/right corner.
- mode = 3 date is printed in the top/right corner.
- format = 0 (default) date has the format like: "Wed Sep 25 17:10:35 2002"
- format = 1 date has the format like: "2002-09-25"
- format = 2 date has the format like: "2002-09-25 17:10:35"

examples:

- optdate = 1 date like "Wed Sep 25 17:10:35 2002" in the bottom/left corner.
- optdate = 13 date like "2002-09-25" in the top/right corner.

The date position can also be controlled by: gStyle->SetDateX(x); x in NDC gStyle->SetDateY(y); y in NDC

The date text attributes can be changed with: 

    gStyle->GetAttDate()->SetTextFont(font=62);
    gStyle->GetAttDate()->SetTextSize(size=0.025);
    gStyle->GetAttDate()->SetTextAngle(angle=0);
    gStyle->GetAttDate()->SetTextAlign(align=11);
    gStyle->GetAttDate()->SetTextColor(color=1);

(C++ version of the code)

 The current date attributes can be obtained via: 

    gStyle->GetAttDate()->GetTextxxxx();

(C++ version of the code)

 When the date option is active, a text object is created when the pad paint its list of primitives. The text object is named "DATE". The DATE attributes can also be edited interactively (position and attributes) via the normal context menu.
""" SetOptDate(this::ByRef1{TStyle}, datefl::Int32)

# Wrapper of void TStyle::SetOptFile(Int_t)
@trydoc raw"""
    SetOptFile(this::ByRef1{TStyle}, file::Int32)::Nothing


""" SetOptFile(this::ByRef1{TStyle}, file::Int32)

# Wrapper of void TStyle::SetOptFit(Int_t)
@trydoc raw"""
    SetOptFit(this::ByRef1{TStyle}, fit::Int32)::Nothing
The type of information about fit parameters printed in the histogram statistics box can be selected via the parameter `mode`.
The parameter mode can be = `pcev`:

- p = 1; print Probability
- c = 1; print Chisquare/Number of degrees of freedom
- e = 1; print errors (if e=1, v must be 1)
- v = 1; print name/values of parameters Example: `gStyle->SetOptFit(1011);` print fit probability, parameter names/values and errors.
- When "v"=1 is specified, only the non-fixed parameters are shown.
- When "v"=2 all parameters are shown.

#### Notes:

- never call `SetOptFit(000111);` but `SetOptFit(111)`, 000111 will be taken as an octal number !!
- `gStyle->SetOptFit(1)` is a shortcut allowing to set the most common case and is equivalent to `gStyle->SetOptFit(111)`
- At [ROOT](@ref) startup the option fit is set to `0`. So, to see the fit parameters on all plot resulting from a fit, a call to `gStyle->SetOptFit()` with a non null value should be done. One can put it in the `rootlogon.C` file to always have it.

see also SetOptStat below.
""" SetOptFit(this::ByRef1{TStyle}, fit::Int32)

# Wrapper of void TStyle::SetOptLogx(Int_t)
@trydoc raw"""
    SetOptLogx(this::ByRef1{TStyle}, logx::Int32)::Nothing


""" SetOptLogx(this::ByRef1{TStyle}, logx::Int32)

# Wrapper of void TStyle::SetOptLogy(Int_t)
@trydoc raw"""
    SetOptLogy(this::ByRef1{TStyle}, logy::Int32)::Nothing


""" SetOptLogy(this::ByRef1{TStyle}, logy::Int32)

# Wrapper of void TStyle::SetOptLogz(Int_t)
@trydoc raw"""
    SetOptLogz(this::ByRef1{TStyle}, logz::Int32)::Nothing


""" SetOptLogz(this::ByRef1{TStyle}, logz::Int32)

# Wrapper of void TStyle::SetOptStat(Int_t)
@trydoc raw"""
    SetOptStat(this::ByRef1{TStyle}, stat::Int32)::Nothing
The type of information printed in the histogram statistics box can be selected via the parameter mode.
The parameter mode can be = `ksiourmen`

- k = 1; kurtosis printed
- k = 2; kurtosis and kurtosis error printed
- s = 1; skewness printed
- s = 2; skewness and skewness error printed
- i = 1; integral of bins printed
- i = 2; integral of bins with option "width" printed
- o = 1; number of overflows printed
- u = 1; number of underflows printed
- r = 1; rms printed
- r = 2; rms and rms error printed
- m = 1; mean value printed
- m = 2; mean and mean error values printed
- e = 1; number of entries printed
- n = 1; name of histogram is printed

Example: `gStyle->SetOptStat(11);` print only name of histogram and number of entries. `gStyle->SetOptStat(1101);` displays the name of histogram, mean value and RMS.

#### Notes:

- never call `SetOptStat(000111);` but `SetOptStat(111)`, 000111 will be taken as an octal number !!
- `SetOptStat(1)` is s shortcut allowing to set the most common case, and is taken as `SetOptStat(1111)` (for backward compatibility with older versions. If you want to print only the name of the histogram call `SetOptStat(1000000001)`.
- that in case of 2-D histograms, when selecting just underflow (10000) or overflow (100000), the stats box will show all combinations of underflow/overflows and not just one single number!
""" SetOptStat(this::ByRef1{TStyle}, stat::Int32)

# Wrapper of void TStyle::SetOptStat(Option_t *)
@trydoc raw"""
    SetOptStat(this::ByRef1{TStyle}, stat::ByCopy{String})::Nothing
The parameter mode can be any combination of kKsSiourRmMen.
- k : kurtosis printed
- K : kurtosis and kurtosis error printed
- s : skewness printed
- S : skewness and skewness error printed
- i : integral of bins printed
- I : integral of bins with option "width" printed
- o : number of overflows printed
- u : number of underflows printed
- r : rms printed
- R : rms and rms error printed
- m : mean value printed
- M : mean value mean error values printed
- e : number of entries printed
- n : name of histogram is printed

Example: `gStyle->SetOptStat("ne");` print only name of histogram and number of entries.

- `gStyle->SetOptStat("n")` print only the name of the histogram
- `gStyle->SetOptStat("nemr")` is the default
""" SetOptStat(this::ByRef1{TStyle}, stat::ByCopy{String})

# Wrapper of void TStyle::SetOptTitle(Int_t)
@trydoc raw"""
    SetOptTitle(this::ByRef1{TStyle}, tit::Int32)::Nothing


""" SetOptTitle(this::ByRef1{TStyle}, tit::Int32)

# Wrapper of void TStyle::SetOrthoCamera(Bool_t)
@trydoc raw"""
    SetOrthoCamera(this::ByRef1{TStyle}, on::Bool)::Nothing


""" SetOrthoCamera(this::ByRef1{TStyle}, on::Bool)

# Wrapper of void TStyle::SetPadBorderMode(Int_t)
@trydoc raw"""
    SetPadBorderMode(this::ByRef1{TStyle}, mode::Int32)::Nothing


""" SetPadBorderMode(this::ByRef1{TStyle}, mode::Int32)

# Wrapper of void TStyle::SetPadBorderSize(Width_t)
@trydoc raw"""
    SetPadBorderSize(this::ByRef1{TStyle}, size::Int16)::Nothing


""" SetPadBorderSize(this::ByRef1{TStyle}, size::Int16)

# Wrapper of void TStyle::SetPadBottomMargin(Float_t)
@trydoc raw"""
    SetPadBottomMargin(this::ByRef1{TStyle}, margin::Float32)::Nothing


""" SetPadBottomMargin(this::ByRef1{TStyle}, margin::Float32)

# Wrapper of void TStyle::SetPadColor(Color_t)
@trydoc raw"""
    SetPadColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetPadColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetPadGridX(Bool_t)
@trydoc raw"""
    SetPadGridX(this::ByRef1{TStyle}, gridx::Bool)::Nothing


""" SetPadGridX(this::ByRef1{TStyle}, gridx::Bool)

# Wrapper of void TStyle::SetPadGridY(Bool_t)
@trydoc raw"""
    SetPadGridY(this::ByRef1{TStyle}, gridy::Bool)::Nothing


""" SetPadGridY(this::ByRef1{TStyle}, gridy::Bool)

# Wrapper of void TStyle::SetPadLeftMargin(Float_t)
@trydoc raw"""
    SetPadLeftMargin(this::ByRef1{TStyle}, margin::Float32)::Nothing


""" SetPadLeftMargin(this::ByRef1{TStyle}, margin::Float32)

# Wrapper of void TStyle::SetPadRightMargin(Float_t)
@trydoc raw"""
    SetPadRightMargin(this::ByRef1{TStyle}, margin::Float32)::Nothing


""" SetPadRightMargin(this::ByRef1{TStyle}, margin::Float32)

# Wrapper of void TStyle::SetPadTickX(Int_t)
@trydoc raw"""
    SetPadTickX(this::ByRef1{TStyle}, tickx::Int32)::Nothing


""" SetPadTickX(this::ByRef1{TStyle}, tickx::Int32)

# Wrapper of void TStyle::SetPadTickY(Int_t)
@trydoc raw"""
    SetPadTickY(this::ByRef1{TStyle}, ticky::Int32)::Nothing


""" SetPadTickY(this::ByRef1{TStyle}, ticky::Int32)

# Wrapper of void TStyle::SetPadTopMargin(Float_t)
@trydoc raw"""
    SetPadTopMargin(this::ByRef1{TStyle}, margin::Float32)::Nothing


""" SetPadTopMargin(this::ByRef1{TStyle}, margin::Float32)

# Wrapper of void TStyle::SetPaintTextFormat(const char *)
@trydoc raw"""
    SetPaintTextFormat(this::ByRef1{TStyle}, format::ByCopy{String})::Nothing


""" SetPaintTextFormat(this::ByRef1{TStyle}, format::ByCopy{String})

# Wrapper of void TStyle::SetPalette(Int_t, Int_t *, Float_t)
@trydoc raw"""
    SetPalette(this::ByRef1{TStyle}, ncolors::Int32, colors::ByPtr2{Int32}, alpha::Float32)::Nothing
See [TColor!SetPalette](@ref).
""" SetPalette(this::ByRef1{TStyle}, ncolors::Int32, colors::ByPtr2{Int32}, alpha::Float32)

# Wrapper of void TStyle::SetPalette(TString, Float_t)
@trydoc raw"""
    SetPalette(this::ByRef1{TStyle}, fileName::ByCopy{TString}, alpha::Float32)::Nothing

###See

TColor!CreateColorTableFromFile, (which calls TColor!SetPalette)
""" SetPalette(this::ByRef1{TStyle}, fileName::ByCopy{TString}, alpha::Float32)

# Wrapper of void TStyle::SetPaperSize(Float_t, Float_t)
@trydoc raw"""
    SetPaperSize(this::ByRef1{TStyle}, xsize::Float32, ysize::Float32)::Nothing
Set paper size for PostScript output.
The paper size is specified in centimeters. Default is 20x26. See also [TPad!Print](@ref)
""" SetPaperSize(this::ByRef1{TStyle}, xsize::Float32, ysize::Float32)

# Wrapper of void TStyle::SetScreenFactor(Float_t)
@trydoc raw"""
    SetScreenFactor(this::ByRef1{TStyle}, factor::Float32)::Nothing


""" SetScreenFactor(this::ByRef1{TStyle}, factor::Float32)

# Wrapper of void TStyle::SetStatBorderSize(Width_t)
@trydoc raw"""
    SetStatBorderSize(this::ByRef1{TStyle}, size::Int16)::Nothing


""" SetStatBorderSize(this::ByRef1{TStyle}, size::Int16)

# Wrapper of void TStyle::SetStatColor(Color_t)
@trydoc raw"""
    SetStatColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetStatColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetStatFont(Style_t)
@trydoc raw"""
    SetStatFont(this::ByRef1{TStyle}, font::Int16)::Nothing


""" SetStatFont(this::ByRef1{TStyle}, font::Int16)

# Wrapper of void TStyle::SetStatFontSize(Float_t)
@trydoc raw"""
    SetStatFontSize(this::ByRef1{TStyle}, size::Float32)::Nothing


""" SetStatFontSize(this::ByRef1{TStyle}, size::Float32)

# Wrapper of void TStyle::SetStatFormat(const char *)
@trydoc raw"""
    SetStatFormat(this::ByRef1{TStyle}, format::ByCopy{String})::Nothing


""" SetStatFormat(this::ByRef1{TStyle}, format::ByCopy{String})

# Wrapper of void TStyle::SetStatH(Float_t)
@trydoc raw"""
    SetStatH(this::ByRef1{TStyle}, h::Float32)::Nothing


""" SetStatH(this::ByRef1{TStyle}, h::Float32)

# Wrapper of void TStyle::SetStatStyle(Style_t)
@trydoc raw"""
    SetStatStyle(this::ByRef1{TStyle}, style::Int16)::Nothing


""" SetStatStyle(this::ByRef1{TStyle}, style::Int16)

# Wrapper of void TStyle::SetStatTextColor(Color_t)
@trydoc raw"""
    SetStatTextColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetStatTextColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetStatW(Float_t)
@trydoc raw"""
    SetStatW(this::ByRef1{TStyle}, w::Float32)::Nothing


""" SetStatW(this::ByRef1{TStyle}, w::Float32)

# Wrapper of void TStyle::SetStatX(Float_t)
@trydoc raw"""
    SetStatX(this::ByRef1{TStyle}, x::Float32)::Nothing


""" SetStatX(this::ByRef1{TStyle}, x::Float32)

# Wrapper of void TStyle::SetStatY(Float_t)
@trydoc raw"""
    SetStatY(this::ByRef1{TStyle}, y::Float32)::Nothing


""" SetStatY(this::ByRef1{TStyle}, y::Float32)

# Wrapper of void TStyle::SetStripDecimals(Bool_t)
@trydoc raw"""
    SetStripDecimals(this::ByRef1{TStyle}, strip::Bool)::Nothing
Set option to strip decimals when drawing axis labels.
By default, [TGaxis!PaintAxis](@ref) removes trailing 0s after a dot in the axis labels. Ex: {0,0.5,1,1.5,2,2.5, etc} If this function is called with strip=kFALSE, TGAxis!PaintAxis will draw labels with the same number of digits after the dot Ex: (0.0,0.5,1.0,1.5,2.0,2.5,etc}
""" SetStripDecimals(this::ByRef1{TStyle}, strip::Bool)

# Wrapper of void TStyle::SetTickLength(Float_t, Option_t *)
@trydoc raw"""
    SetTickLength(this::ByRef1{TStyle}, length::Float32, axis::ByCopy{String})::Nothing
Set the tick marks length for an axis.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetTickLength(this::ByRef1{TStyle}, length::Float32, axis::ByCopy{String})

# Wrapper of void TStyle::SetTimeOffset(Double_t)
@trydoc raw"""
    SetTimeOffset(this::ByRef1{TStyle}, toffset::Float64)::Nothing
Change the time offset for time plotting.
Times are expressed in seconds. The corresponding numbers usually have 9 digits (or more if one takes into account fractions of seconds). Thus, since it is very inconvenient to plot very large numbers on a scale, one has to set an offset time that will be added to the axis beginning, in order to plot times correctly and conveniently. A convenient way to set the time offset is to use [TDatime!Convert()](@ref).

By default the time offset is set to 788918400 which corresponds to 01/01/1995. This allows to have valid dates until 2072. The standard UNIX time offset in 1970 allows only valid dates until 2030.
""" SetTimeOffset(this::ByRef1{TStyle}, toffset::Float64)

# Wrapper of void TStyle::SetTitleAlign(Int_t)
@trydoc raw"""
    SetTitleAlign(this::ByRef1{TStyle}, a::Int32)::Nothing


""" SetTitleAlign(this::ByRef1{TStyle}, a::Int32)

# Wrapper of void TStyle::SetTitleBorderSize(Width_t)
@trydoc raw"""
    SetTitleBorderSize(this::ByRef1{TStyle}, size::Int16)::Nothing


""" SetTitleBorderSize(this::ByRef1{TStyle}, size::Int16)

# Wrapper of void TStyle::SetTitleColor(Color_t, Option_t *)
@trydoc raw"""
    SetTitleColor(this::ByRef1{TStyle}, color::Int16, axis::ByCopy{String})::Nothing

- if axis =="x" set the X axis title color
- if axis =="y" set the Y axis title color
- if axis =="z" set the Z axis title color

any other value of axis will set the pad title color

if axis="xyz" set all 3 axes
""" SetTitleColor(this::ByRef1{TStyle}, color::Int16, axis::ByCopy{String})

# Wrapper of void TStyle::SetTitleFillColor(Color_t)
@trydoc raw"""
    SetTitleFillColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetTitleFillColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetTitleFont(Style_t, Option_t *)
@trydoc raw"""
    SetTitleFont(this::ByRef1{TStyle}, font::Int16, axis::ByCopy{String})::Nothing

- if axis =="x" set the X axis title font
- if axis =="y" set the Y axis title font
- if axis =="z" set the Z axis title font

any other value of axis will set the pad title font

if axis="xyz" set all 3 axes
""" SetTitleFont(this::ByRef1{TStyle}, font::Int16, axis::ByCopy{String})

# Wrapper of void TStyle::SetTitleFontSize(Float_t)
@trydoc raw"""
    SetTitleFontSize(this::ByRef1{TStyle}, size::Float32)::Nothing


""" SetTitleFontSize(this::ByRef1{TStyle}, size::Float32)

# Wrapper of void TStyle::SetTitleH(Float_t)
@trydoc raw"""
    SetTitleH(this::ByRef1{TStyle}, h::Float32)::Nothing


""" SetTitleH(this::ByRef1{TStyle}, h::Float32)

# Wrapper of void TStyle::SetTitleOffset(Float_t, Option_t *)
@trydoc raw"""
    SetTitleOffset(this::ByRef1{TStyle}, offset::Float32, axis::ByCopy{String})::Nothing
Specify a parameter offset to control the distance between the axis and the axis title.
- offset = 1 means : use the default distance
- offset = 1.2 means: the distance will be 1.2*(default distance)
- offset = 0.8 means: the distance will be 0.8*(default distance)

axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetTitleOffset(this::ByRef1{TStyle}, offset::Float32, axis::ByCopy{String})

# Wrapper of void TStyle::SetTitlePS(const char *)
@trydoc raw"""
    SetTitlePS(this::ByRef1{TStyle}, pstitle::ByCopy{String})::Nothing
Define a string to be used in the %Title of the Postscript files.
If this string is not defined, [ROOT](@ref) will use the canvas title.
""" SetTitlePS(this::ByRef1{TStyle}, pstitle::ByCopy{String})

# Wrapper of void TStyle::SetTitleSize(Float_t, Option_t *)
@trydoc raw"""
    SetTitleSize(this::ByRef1{TStyle}, size::Float32, axis::ByCopy{String})::Nothing

- if axis =="x" set the X axis title size
- if axis =="y" set the Y axis title size
- if axis =="z" set the Z axis title size

any other value of axis will set the pad title size

if axis="xyz" set all 3 axes
""" SetTitleSize(this::ByRef1{TStyle}, size::Float32, axis::ByCopy{String})

# Wrapper of void TStyle::SetTitleStyle(Style_t)
@trydoc raw"""
    SetTitleStyle(this::ByRef1{TStyle}, style::Int16)::Nothing


""" SetTitleStyle(this::ByRef1{TStyle}, style::Int16)

# Wrapper of void TStyle::SetTitleTextColor(Color_t)
@trydoc raw"""
    SetTitleTextColor(this::ByRef1{TStyle}, color::Int16)::Nothing


""" SetTitleTextColor(this::ByRef1{TStyle}, color::Int16)

# Wrapper of void TStyle::SetTitleW(Float_t)
@trydoc raw"""
    SetTitleW(this::ByRef1{TStyle}, w::Float32)::Nothing


""" SetTitleW(this::ByRef1{TStyle}, w::Float32)

# Wrapper of void TStyle::SetTitleX(Float_t)
@trydoc raw"""
    SetTitleX(this::ByRef1{TStyle}, x::Float32)::Nothing


""" SetTitleX(this::ByRef1{TStyle}, x::Float32)

# Wrapper of void TStyle::SetTitleXOffset(Float_t)
@trydoc raw"""
    SetTitleXOffset(this::ByRef1{TStyle}, offset::Float32)::Nothing


""" SetTitleXOffset(this::ByRef1{TStyle}, offset::Float32)

# Wrapper of void TStyle::SetTitleXSize(Float_t)
@trydoc raw"""
    SetTitleXSize(this::ByRef1{TStyle}, size::Float32)::Nothing


""" SetTitleXSize(this::ByRef1{TStyle}, size::Float32)

# Wrapper of void TStyle::SetTitleY(Float_t)
@trydoc raw"""
    SetTitleY(this::ByRef1{TStyle}, y::Float32)::Nothing


""" SetTitleY(this::ByRef1{TStyle}, y::Float32)

# Wrapper of void TStyle::SetTitleYOffset(Float_t)
@trydoc raw"""
    SetTitleYOffset(this::ByRef1{TStyle}, offset::Float32)::Nothing


""" SetTitleYOffset(this::ByRef1{TStyle}, offset::Float32)

# Wrapper of void TStyle::SetTitleYSize(Float_t)
@trydoc raw"""
    SetTitleYSize(this::ByRef1{TStyle}, size::Float32)::Nothing


""" SetTitleYSize(this::ByRef1{TStyle}, size::Float32)

# Wrapper of void TStyle::SetViolinScaled(Bool_t)
@trydoc raw"""
    SetViolinScaled(this::ByRef1{TStyle}, on::Bool)::Nothing


""" SetViolinScaled(this::ByRef1{TStyle}, on::Bool)

# Wrapper of void TStyle::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TStyle}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TStyle}, ::ByRef1{TBuffer})

# Wrapper of void TStyle::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TStyle}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TStyle}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TStyle::ToggleEditor()
@trydoc raw"""
    ToggleEditor(this::ByRef1{TStyle})::Nothing


""" ToggleEditor(this::ByRef1{TStyle})

# Wrapper of void TStyle::ToggleEventStatus()
@trydoc raw"""
    ToggleEventStatus(this::ByRef1{TStyle})::Nothing


""" ToggleEventStatus(this::ByRef1{TStyle})

# Wrapper of void TStyle::ToggleToolBar()
@trydoc raw"""
    ToggleToolBar(this::ByRef1{TStyle})::Nothing


""" ToggleToolBar(this::ByRef1{TStyle})

# Wrapper of void TVirtualPad::AbsCoordinates(Bool_t)
@trydoc raw"""
    AbsCoordinates(this::ByRef1{TVirtualPad}, set::Bool)::Nothing


""" AbsCoordinates(this::ByRef1{TVirtualPad}, set::Bool)

# Wrapper of Double_t TVirtualPad::AbsPixeltoX(Int_t)
@trydoc raw"""
    AbsPixeltoX(this::ByRef1{TVirtualPad}, px::Int32)::Float64


""" AbsPixeltoX(this::ByRef1{TVirtualPad}, px::Int32)

# Wrapper of Double_t TVirtualPad::AbsPixeltoY(Int_t)
@trydoc raw"""
    AbsPixeltoY(this::ByRef1{TVirtualPad}, py::Int32)::Float64


""" AbsPixeltoY(this::ByRef1{TVirtualPad}, py::Int32)

# Wrapper of void TVirtualPad::AddExec(const char *, const char *)
@trydoc raw"""
    AddExec(this::ByRef1{TVirtualPad}, name::ByCopy{String}, command::ByCopy{String})::Nothing


""" AddExec(this::ByRef1{TVirtualPad}, name::ByCopy{String}, command::ByCopy{String})

# Wrapper of TVirtualPad * TVirtualPad::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TVirtualPad}, subpadnumber::Int32)::CxxPtr1{TVirtualPad}


""" cd(this::ByRef1{TVirtualPad}, subpadnumber::Int32)

# Wrapper of void TVirtualPad::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TVirtualPad}, option::ByCopy{String})::Nothing


""" Clear(this::ByRef1{TVirtualPad}, option::ByCopy{String})

# Wrapper of Int_t TVirtualPad::Clip(Double_t *, Double_t *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Clip(this::ByRef1{TVirtualPad}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, xclipl::Float64, yclipb::Float64, xclipr::Float64, yclipt::Float64)::Int32


""" Clip(this::ByRef1{TVirtualPad}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, xclipl::Float64, yclipb::Float64, xclipr::Float64, yclipt::Float64)

# Wrapper of void TVirtualPad::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TVirtualPad}, option::ByCopy{String})::Nothing


""" Close(this::ByRef1{TVirtualPad}, option::ByCopy{String})

# Wrapper of void TVirtualPad::CloseToolTip(TObject *)
@trydoc raw"""
    CloseToolTip(this::ByRef1{TVirtualPad}, tip::ByPtr1{TObject})::Nothing


""" CloseToolTip(this::ByRef1{TVirtualPad}, tip::ByPtr1{TObject})

# Wrapper of void TVirtualPad::CopyPixmap()
@trydoc raw"""
    CopyPixmap(this::ByRef1{TVirtualPad})::Nothing


""" CopyPixmap(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::CopyPixmaps()
@trydoc raw"""
    CopyPixmaps(this::ByRef1{TVirtualPad})::Nothing


""" CopyPixmaps(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::DeleteExec(const char *)
@trydoc raw"""
    DeleteExec(this::ByRef1{TVirtualPad}, name::ByCopy{String})::Nothing


""" DeleteExec(this::ByRef1{TVirtualPad}, name::ByCopy{String})

# Wrapper of void TVirtualPad::DeleteToolTip(TObject *)
@trydoc raw"""
    DeleteToolTip(this::ByRef1{TVirtualPad}, tip::ByPtr1{TObject})::Nothing


""" DeleteToolTip(this::ByRef1{TVirtualPad}, tip::ByPtr1{TObject})

# Wrapper of void TVirtualPad::Divide(Int_t, Int_t, Float_t, Float_t, Int_t)
@trydoc raw"""
    Divide(this::ByRef1{TVirtualPad}, nx::Int32, ny::Int32, xmargin::Float32, ymargin::Float32, color::Int32)::Nothing


""" Divide(this::ByRef1{TVirtualPad}, nx::Int32, ny::Int32, xmargin::Float32, ymargin::Float32, color::Int32)

# Wrapper of void TVirtualPad::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TVirtualPad}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TVirtualPad}, option::ByCopy{String})

# Wrapper of void TVirtualPad::DrawClassObject(const TObject *, Option_t *)
@trydoc raw"""
    DrawClassObject(this::ByRef1{TVirtualPad}, obj::ByConstPtr1{TObject}, option::ByCopy{String})::Nothing


""" DrawClassObject(this::ByRef1{TVirtualPad}, obj::ByConstPtr1{TObject}, option::ByCopy{String})

# Wrapper of TH1F * TVirtualPad::DrawFrame(Double_t, Double_t, Double_t, Double_t, const char *)
@trydoc raw"""
    DrawFrame(this::ByRef1{TVirtualPad}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64, title::ByCopy{String})::CxxPtr1{TH1F}


""" DrawFrame(this::ByRef1{TVirtualPad}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64, title::ByCopy{String})

# Wrapper of void TVirtualPad::ExecuteEventAxis(Int_t, Int_t, Int_t, TAxis *)
@trydoc raw"""
    ExecuteEventAxis(this::ByRef1{TVirtualPad}, event::Int32, px::Int32, py::Int32, axis::ByPtr1{TAxis})::Nothing


""" ExecuteEventAxis(this::ByRef1{TVirtualPad}, event::Int32, px::Int32, py::Int32, axis::ByPtr1{TAxis})

# Wrapper of Int_t TVirtualPad::GetGLDevice()
@trydoc raw"""
    GetGLDevice(this::ByRef1{TVirtualPad})::Int32


""" GetGLDevice(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::GetPadPar(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetPadPar(this::ByRef1{TVirtualPad}, xlow::ByRef2{Float64}, ylow::ByRef2{Float64}, xup::ByRef2{Float64}, yup::ByRef2{Float64})::Nothing


""" GetPadPar(this::ByRef1{TVirtualPad}, xlow::ByRef2{Float64}, ylow::ByRef2{Float64}, xup::ByRef2{Float64}, yup::ByRef2{Float64})

# Wrapper of TVirtualPadPainter * TVirtualPad::GetPainter()
@trydoc raw"""
    GetPainter(this::ByRef1{TVirtualPad})::CxxPtr1{TVirtualPadPainter}


""" GetPainter(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::GetRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByRef1{TVirtualPad}, x1::ByRef2{Float64}, y1::ByRef2{Float64}, x2::ByRef2{Float64}, y2::ByRef2{Float64})::Nothing


""" GetRange(this::ByRef1{TVirtualPad}, x1::ByRef2{Float64}, y1::ByRef2{Float64}, x2::ByRef2{Float64}, y2::ByRef2{Float64})

# Wrapper of void TVirtualPad::GetRangeAxis(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRangeAxis(this::ByRef1{TVirtualPad}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing


""" GetRangeAxis(this::ByRef1{TVirtualPad}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of TVirtualViewer3D * TVirtualPad::GetViewer3D(Option_t *)
@trydoc raw"""
    GetViewer3D(this::ByRef1{TVirtualPad}, type::ByCopy{String})::CxxPtr1{TVirtualViewer3D}


""" GetViewer3D(this::ByRef1{TVirtualPad}, type::ByCopy{String})

# Wrapper of void TVirtualPad::HighLight(Color_t, Bool_t)
@trydoc raw"""
    HighLight(this::ByRef1{TVirtualPad}, col::Int16, set::Bool)::Nothing


""" HighLight(this::ByRef1{TVirtualPad}, col::Int16, set::Bool)

# Wrapper of Int_t TVirtualPad::IncrementPaletteColor(Int_t, TString)
@trydoc raw"""
    IncrementPaletteColor(this::ByRef1{TVirtualPad}, i::Int32, opt::ByCopy{TString})::Int32


""" IncrementPaletteColor(this::ByRef1{TVirtualPad}, i::Int32, opt::ByCopy{TString})

# Wrapper of void TVirtualPad::Modified(Bool_t)
@trydoc raw"""
    Modified(this::ByRef1{TVirtualPad}, flag::Bool)::Nothing


""" Modified(this::ByRef1{TVirtualPad}, flag::Bool)

# Wrapper of void TVirtualPad::ModifiedUpdate()
@trydoc raw"""
    ModifiedUpdate(this::ByRef1{TVirtualPad})::Nothing


""" ModifiedUpdate(this::ByRef1{TVirtualPad})

# Wrapper of Int_t TVirtualPad::NextPaletteColor()
@trydoc raw"""
    NextPaletteColor(this::ByRef1{TVirtualPad})::Int32


""" NextPaletteColor(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualPad}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualPad}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintBorderPS(Double_t, Double_t, Double_t, Double_t, Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    PaintBorderPS(this::ByRef1{TVirtualPad}, xl::Float64, yl::Float64, xt::Float64, yt::Float64, bmode::Int32, bsize::Int32, dark::Int32, light::Int32)::Nothing


""" PaintBorderPS(this::ByRef1{TVirtualPad}, xl::Float64, yl::Float64, xt::Float64, yt::Float64, bmode::Int32, bsize::Int32, dark::Int32, light::Int32)

# Wrapper of void TVirtualPad::PaintBox(Double_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    PaintBox(this::ByRef1{TVirtualPad}, x1::Float64, y1::Float64, x2::Float64, y2::Float64, option::ByCopy{String})::Nothing


""" PaintBox(this::ByRef1{TVirtualPad}, x1::Float64, y1::Float64, x2::Float64, y2::Float64, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintFillArea(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintFillArea(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing


""" PaintFillArea(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintFillArea(Int_t, Float_t *, Float_t *, Option_t *)
@trydoc raw"""
    PaintFillArea(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})::Nothing


""" PaintFillArea(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintFillAreaNDC(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintFillAreaNDC(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing


""" PaintFillAreaNDC(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintLine(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    PaintLine(this::ByRef1{TVirtualPad}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Nothing


""" PaintLine(this::ByRef1{TVirtualPad}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)

# Wrapper of void TVirtualPad::PaintLine3D(Double_t *, Double_t *)
@trydoc raw"""
    PaintLine3D(this::ByRef1{TVirtualPad}, p1::ByPtr2{Float64}, p2::ByPtr2{Float64})::Nothing


""" PaintLine3D(this::ByRef1{TVirtualPad}, p1::ByPtr2{Float64}, p2::ByPtr2{Float64})

# Wrapper of void TVirtualPad::PaintLine3D(Float_t *, Float_t *)
@trydoc raw"""
    PaintLine3D(this::ByRef1{TVirtualPad}, p1::ByPtr2{Float32}, p2::ByPtr2{Float32})::Nothing


""" PaintLine3D(this::ByRef1{TVirtualPad}, p1::ByPtr2{Float32}, p2::ByPtr2{Float32})

# Wrapper of void TVirtualPad::PaintLineNDC(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    PaintLineNDC(this::ByRef1{TVirtualPad}, u1::Float64, v1::Float64, u2::Float64, v2::Float64)::Nothing


""" PaintLineNDC(this::ByRef1{TVirtualPad}, u1::Float64, v1::Float64, u2::Float64, v2::Float64)

# Wrapper of void TVirtualPad::PaintModified()
@trydoc raw"""
    PaintModified(this::ByRef1{TVirtualPad})::Nothing


""" PaintModified(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::PaintPadFrame(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    PaintPadFrame(this::ByRef1{TVirtualPad}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing


""" PaintPadFrame(this::ByRef1{TVirtualPad}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TVirtualPad::PaintPolyLine(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintPolyLine(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing


""" PaintPolyLine(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintPolyLine(Int_t, Float_t *, Float_t *, Option_t *)
@trydoc raw"""
    PaintPolyLine(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})::Nothing


""" PaintPolyLine(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintPolyLine3D(Int_t, Double_t *)
@trydoc raw"""
    PaintPolyLine3D(this::ByRef1{TVirtualPad}, n::Int32, p::ByPtr2{Float64})::Nothing


""" PaintPolyLine3D(this::ByRef1{TVirtualPad}, n::Int32, p::ByPtr2{Float64})

# Wrapper of void TVirtualPad::PaintPolyLineNDC(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintPolyLineNDC(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing


""" PaintPolyLineNDC(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintPolyMarker(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing


""" PaintPolyMarker(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintPolyMarker(Int_t, Float_t *, Float_t *, Option_t *)
@trydoc raw"""
    PaintPolyMarker(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})::Nothing


""" PaintPolyMarker(this::ByRef1{TVirtualPad}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PaintText(Double_t, Double_t, const char *)
@trydoc raw"""
    PaintText(this::ByRef1{TVirtualPad}, x::Float64, y::Float64, text::ByCopy{String})::Nothing


""" PaintText(this::ByRef1{TVirtualPad}, x::Float64, y::Float64, text::ByCopy{String})

# Wrapper of void TVirtualPad::PaintText(Double_t, Double_t, const wchar_t *)
@trydoc raw"""
    PaintText(this::ByRef1{TVirtualPad}, x::Float64, y::Float64, text::ByConstPtr1{wchar_t})::Nothing


""" PaintText(this::ByRef1{TVirtualPad}, x::Float64, y::Float64, text::ByConstPtr1{wchar_t})

# Wrapper of void TVirtualPad::PaintTextNDC(Double_t, Double_t, const char *)
@trydoc raw"""
    PaintTextNDC(this::ByRef1{TVirtualPad}, u::Float64, v::Float64, text::ByCopy{String})::Nothing


""" PaintTextNDC(this::ByRef1{TVirtualPad}, u::Float64, v::Float64, text::ByCopy{String})

# Wrapper of void TVirtualPad::PaintTextNDC(Double_t, Double_t, const wchar_t *)
@trydoc raw"""
    PaintTextNDC(this::ByRef1{TVirtualPad}, u::Float64, v::Float64, text::ByConstPtr1{wchar_t})::Nothing


""" PaintTextNDC(this::ByRef1{TVirtualPad}, u::Float64, v::Float64, text::ByConstPtr1{wchar_t})

# Wrapper of Double_t TVirtualPad::PixeltoX(Int_t)
@trydoc raw"""
    PixeltoX(this::ByRef1{TVirtualPad}, px::Int32)::Float64


""" PixeltoX(this::ByRef1{TVirtualPad}, px::Int32)

# Wrapper of Double_t TVirtualPad::PixeltoY(Int_t)
@trydoc raw"""
    PixeltoY(this::ByRef1{TVirtualPad}, py::Int32)::Float64


""" PixeltoY(this::ByRef1{TVirtualPad}, py::Int32)

# Wrapper of Bool_t TVirtualPad::PlaceBox(TObject *, Double_t, Double_t, Double_t &, Double_t &, Option_t *)
@trydoc raw"""
    PlaceBox(this::ByRef1{TVirtualPad}, o::ByPtr1{TObject}, w::Float64, h::Float64, xl::ByRef2{Float64}, yb::ByRef2{Float64}, opt::ByCopy{String})::Bool


""" PlaceBox(this::ByRef1{TVirtualPad}, o::ByPtr1{TObject}, w::Float64, h::Float64, xl::ByRef2{Float64}, yb::ByRef2{Float64}, opt::ByCopy{String})

# Wrapper of void TVirtualPad::Pop()
@trydoc raw"""
    Pop(this::ByRef1{TVirtualPad})::Nothing
Pop on object drawn in a pad to the top of the display list.
I.e. it will be drawn last and on top of all other primitives.
""" Pop(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::PopTopLevelSelectable()
@trydoc raw"""
    PopTopLevelSelectable(this::ByRef1{TVirtualPad})::Nothing
Does nothing, unless you implement your own picking.
Remove top level selectable and all its' children.
""" PopTopLevelSelectable(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::Print(const char *, Option_t *)
@trydoc raw"""
    Print(this::ByRef1{TVirtualPad}, filename::ByCopy{String}, option::ByCopy{String})::Nothing


""" Print(this::ByRef1{TVirtualPad}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TVirtualPad::PushSelectableObject(TObject *)
@trydoc raw"""
    PushSelectableObject(this::ByRef1{TVirtualPad}, obj::ByPtr1{TObject})::Nothing
Does nothing, unless you implement your own picking.
"Complete" object, or part of complex object, which can be picked.
""" PushSelectableObject(this::ByRef1{TVirtualPad}, obj::ByPtr1{TObject})

# Wrapper of void TVirtualPad::PushTopLevelSelectable(TObject *)
@trydoc raw"""
    PushTopLevelSelectable(this::ByRef1{TVirtualPad}, top::ByPtr1{TObject})::Nothing
Does nothing, unless you implement your own picking.
When complex object containing sub-objects (which can be picked) is painted in a pad, this "top-level" object is pushed into the selectables stack.
""" PushTopLevelSelectable(this::ByRef1{TVirtualPad}, top::ByPtr1{TObject})

# Wrapper of void TVirtualPad::Range(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Range(this::ByRef1{TVirtualPad}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Nothing


""" Range(this::ByRef1{TVirtualPad}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)

# Wrapper of void TVirtualPad::RangeAxis(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    RangeAxis(this::ByRef1{TVirtualPad}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing


""" RangeAxis(this::ByRef1{TVirtualPad}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TVirtualPad::RangeAxisChanged()
@trydoc raw"""
    RangeAxisChanged(this::ByRef1{TVirtualPad})::Nothing


""" RangeAxisChanged(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TVirtualPad}, obj::ByPtr1{TObject})::Nothing
Recursively remove this object from a list.
Typically implemented by classes that can contain multiple references to a same object.
""" RecursiveRemove(this::ByRef1{TVirtualPad}, obj::ByPtr1{TObject})

# Wrapper of void TVirtualPad::RedrawAxis(Option_t *)
@trydoc raw"""
    RedrawAxis(this::ByRef1{TVirtualPad}, option::ByCopy{String})::Nothing


""" RedrawAxis(this::ByRef1{TVirtualPad}, option::ByCopy{String})

# Wrapper of void TVirtualPad::ReleaseViewer3D(Option_t *)
@trydoc raw"""
    ReleaseViewer3D(this::ByRef1{TVirtualPad}, type::ByCopy{String})::Nothing


""" ReleaseViewer3D(this::ByRef1{TVirtualPad}, type::ByCopy{String})

# Wrapper of void TVirtualPad::ResetToolTip(TObject *)
@trydoc raw"""
    ResetToolTip(this::ByRef1{TVirtualPad}, tip::ByPtr1{TObject})::Nothing


""" ResetToolTip(this::ByRef1{TVirtualPad}, tip::ByPtr1{TObject})

# Wrapper of void TVirtualPad::ResetView3D(TObject *)
@trydoc raw"""
    ResetView3D(this::ByRef1{TVirtualPad}, view::ByPtr1{TObject})::Nothing


""" ResetView3D(this::ByRef1{TVirtualPad}, view::ByPtr1{TObject})

# Wrapper of void TVirtualPad::ResizePad(Option_t *)
@trydoc raw"""
    ResizePad(this::ByRef1{TVirtualPad}, option::ByCopy{String})::Nothing


""" ResizePad(this::ByRef1{TVirtualPad}, option::ByCopy{String})

# Wrapper of void TVirtualPad::SetAttFillPS(Color_t, Style_t)
@trydoc raw"""
    SetAttFillPS(this::ByRef1{TVirtualPad}, color::Int16, style::Int16)::Nothing


""" SetAttFillPS(this::ByRef1{TVirtualPad}, color::Int16, style::Int16)

# Wrapper of void TVirtualPad::SetAttLinePS(Color_t, Style_t, Width_t)
@trydoc raw"""
    SetAttLinePS(this::ByRef1{TVirtualPad}, color::Int16, style::Int16, lwidth::Int16)::Nothing


""" SetAttLinePS(this::ByRef1{TVirtualPad}, color::Int16, style::Int16, lwidth::Int16)

# Wrapper of void TVirtualPad::SetAttMarkerPS(Color_t, Style_t, Size_t)
@trydoc raw"""
    SetAttMarkerPS(this::ByRef1{TVirtualPad}, color::Int16, style::Int16, msize::Float32)::Nothing


""" SetAttMarkerPS(this::ByRef1{TVirtualPad}, color::Int16, style::Int16, msize::Float32)

# Wrapper of void TVirtualPad::SetAttTextPS(Int_t, Float_t, Color_t, Style_t, Float_t)
@trydoc raw"""
    SetAttTextPS(this::ByRef1{TVirtualPad}, align::Int32, angle::Float32, color::Int16, font::Int16, tsize::Float32)::Nothing


""" SetAttTextPS(this::ByRef1{TVirtualPad}, align::Int32, angle::Float32, color::Int16, font::Int16, tsize::Float32)

# Wrapper of void TVirtualPad::SetBatch(Bool_t)
@trydoc raw"""
    SetBatch(this::ByRef1{TVirtualPad}, batch::Bool)::Nothing


""" SetBatch(this::ByRef1{TVirtualPad}, batch::Bool)

# Wrapper of void TVirtualPad::SetBorderMode(Short_t)
@trydoc raw"""
    SetBorderMode(this::ByRef1{TVirtualPad}, bordermode::Int16)::Nothing


""" SetBorderMode(this::ByRef1{TVirtualPad}, bordermode::Int16)

# Wrapper of void TVirtualPad::SetBorderSize(Short_t)
@trydoc raw"""
    SetBorderSize(this::ByRef1{TVirtualPad}, bordersize::Int16)::Nothing


""" SetBorderSize(this::ByRef1{TVirtualPad}, bordersize::Int16)

# Wrapper of void TVirtualPad::SetCanvas(TCanvas *)
@trydoc raw"""
    SetCanvas(this::ByRef1{TVirtualPad}, c::ByPtr1{TCanvas})::Nothing


""" SetCanvas(this::ByRef1{TVirtualPad}, c::ByPtr1{TCanvas})

# Wrapper of void TVirtualPad::SetCanvasSize(UInt_t, UInt_t)
@trydoc raw"""
    SetCanvasSize(this::ByRef1{TVirtualPad}, ww::UInt32, wh::UInt32)::Nothing


""" SetCanvasSize(this::ByRef1{TVirtualPad}, ww::UInt32, wh::UInt32)

# Wrapper of void TVirtualPad::SetCopyGLDevice(Bool_t)
@trydoc raw"""
    SetCopyGLDevice(this::ByRef1{TVirtualPad}, copy::Bool)::Nothing


""" SetCopyGLDevice(this::ByRef1{TVirtualPad}, copy::Bool)

# Wrapper of void TVirtualPad::SetCrosshair(Int_t)
@trydoc raw"""
    SetCrosshair(this::ByRef1{TVirtualPad}, crhair::Int32)::Nothing


""" SetCrosshair(this::ByRef1{TVirtualPad}, crhair::Int32)

# Wrapper of void TVirtualPad::SetCursor(ECursor)
@trydoc raw"""
    SetCursor(this::ByRef1{TVirtualPad}, cursor::ByCopy{ECursor})::Nothing


""" SetCursor(this::ByRef1{TVirtualPad}, cursor::ByCopy{ECursor})

# Wrapper of void TVirtualPad::SetDoubleBuffer(Int_t)
@trydoc raw"""
    SetDoubleBuffer(this::ByRef1{TVirtualPad}, mode::Int32)::Nothing


""" SetDoubleBuffer(this::ByRef1{TVirtualPad}, mode::Int32)

# Wrapper of void TVirtualPad::SetEditable(Bool_t)
@trydoc raw"""
    SetEditable(this::ByRef1{TVirtualPad}, mode::Bool)::Nothing


""" SetEditable(this::ByRef1{TVirtualPad}, mode::Bool)

# Wrapper of void TVirtualPad::SetFixedAspectRatio(Bool_t)
@trydoc raw"""
    SetFixedAspectRatio(this::ByRef1{TVirtualPad}, fixed::Bool)::Nothing


""" SetFixedAspectRatio(this::ByRef1{TVirtualPad}, fixed::Bool)

# Wrapper of void TVirtualPad::SetGrid(Int_t, Int_t)
@trydoc raw"""
    SetGrid(this::ByRef1{TVirtualPad}, valuex::Int32, valuey::Int32)::Nothing


""" SetGrid(this::ByRef1{TVirtualPad}, valuex::Int32, valuey::Int32)

# Wrapper of void TVirtualPad::SetGridx(Int_t)
@trydoc raw"""
    SetGridx(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetGridx(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetGridy(Int_t)
@trydoc raw"""
    SetGridy(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetGridy(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetLogx(Int_t)
@trydoc raw"""
    SetLogx(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetLogx(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetLogy(Int_t)
@trydoc raw"""
    SetLogy(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetLogy(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetLogz(Int_t)
@trydoc raw"""
    SetLogz(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetLogz(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TVirtualPad}, name::ByCopy{String})::Nothing


""" SetName(this::ByRef1{TVirtualPad}, name::ByCopy{String})

# Wrapper of void TVirtualPad::SetPad(const char *, const char *, Double_t, Double_t, Double_t, Double_t, Color_t, Short_t, Short_t)
@trydoc raw"""
    SetPad(this::ByRef1{TVirtualPad}, name::ByCopy{String}, title::ByCopy{String}, xlow::Float64, ylow::Float64, xup::Float64, yup::Float64, color::Int16, bordersize::Int16, bordermode::Int16)::Nothing


""" SetPad(this::ByRef1{TVirtualPad}, name::ByCopy{String}, title::ByCopy{String}, xlow::Float64, ylow::Float64, xup::Float64, yup::Float64, color::Int16, bordersize::Int16, bordermode::Int16)

# Wrapper of void TVirtualPad::SetPad(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPad(this::ByRef1{TVirtualPad}, xlow::Float64, ylow::Float64, xup::Float64, yup::Float64)::Nothing


""" SetPad(this::ByRef1{TVirtualPad}, xlow::Float64, ylow::Float64, xup::Float64, yup::Float64)

# Wrapper of void TVirtualPad::SetPhi(Double_t)
@trydoc raw"""
    SetPhi(this::ByRef1{TVirtualPad}, phi::Float64)::Nothing


""" SetPhi(this::ByRef1{TVirtualPad}, phi::Float64)

# Wrapper of void TVirtualPad::SetSelected(TObject *)
@trydoc raw"""
    SetSelected(this::ByRef1{TVirtualPad}, obj::ByPtr1{TObject})::Nothing


""" SetSelected(this::ByRef1{TVirtualPad}, obj::ByPtr1{TObject})

# Wrapper of void TVirtualPad::SetTheta(Double_t)
@trydoc raw"""
    SetTheta(this::ByRef1{TVirtualPad}, theta::Float64)::Nothing


""" SetTheta(this::ByRef1{TVirtualPad}, theta::Float64)

# Wrapper of void TVirtualPad::SetTicks(Int_t, Int_t)
@trydoc raw"""
    SetTicks(this::ByRef1{TVirtualPad}, valuex::Int32, valuey::Int32)::Nothing


""" SetTicks(this::ByRef1{TVirtualPad}, valuex::Int32, valuey::Int32)

# Wrapper of void TVirtualPad::SetTickx(Int_t)
@trydoc raw"""
    SetTickx(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetTickx(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetTicky(Int_t)
@trydoc raw"""
    SetTicky(this::ByRef1{TVirtualPad}, value::Int32)::Nothing


""" SetTicky(this::ByRef1{TVirtualPad}, value::Int32)

# Wrapper of void TVirtualPad::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TVirtualPad}, title::ByCopy{String})::Nothing


""" SetTitle(this::ByRef1{TVirtualPad}, title::ByCopy{String})

# Wrapper of void TVirtualPad::SetToolTipText(const char *, Long_t)
@trydoc raw"""
    SetToolTipText(this::ByRef1{TVirtualPad}, text::ByCopy{String}, delayms::Int64)::Nothing


""" SetToolTipText(this::ByRef1{TVirtualPad}, text::ByCopy{String}, delayms::Int64)

# Wrapper of void TVirtualPad::SetVertical(Bool_t)
@trydoc raw"""
    SetVertical(this::ByRef1{TVirtualPad}, vert::Bool)::Nothing


""" SetVertical(this::ByRef1{TVirtualPad}, vert::Bool)

# Wrapper of void TVirtualPad::SetViewer3D(TVirtualViewer3D *)
@trydoc raw"""
    SetViewer3D(this::ByRef1{TVirtualPad}, ::ByPtr1{TVirtualViewer3D})::Nothing


""" SetViewer3D(this::ByRef1{TVirtualPad}, ::ByPtr1{TVirtualViewer3D})

# Wrapper of void TVirtualPad::ShowGuidelines(TObject *, const Int_t, const char, const bool)
@trydoc raw"""
    ShowGuidelines(this::ByRef1{TVirtualPad}, object::ByPtr1{TObject}, event::ByCopy{Int32}, mode::ByCopy{Int8}, cling::ByCopy{Bool})::Nothing


""" ShowGuidelines(this::ByRef1{TVirtualPad}, object::ByPtr1{TObject}, event::ByCopy{Int32}, mode::ByCopy{Int8}, cling::ByCopy{Bool})

# Wrapper of void TVirtualPad::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualPad}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TVirtualPad](@ref).

""" Streamer(this::ByRef1{TVirtualPad}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualPad::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualPad}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualPad}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPad::UnZoomed()
@trydoc raw"""
    UnZoomed(this::ByRef1{TVirtualPad})::Nothing


""" UnZoomed(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::Update()
@trydoc raw"""
    Update(this::ByRef1{TVirtualPad})::Nothing


""" Update(this::ByRef1{TVirtualPad})

# Wrapper of void TVirtualPad::UpdateAsync()
@trydoc raw"""
    UpdateAsync(this::ByRef1{TVirtualPad})::Nothing


""" UpdateAsync(this::ByRef1{TVirtualPad})

# Wrapper of TObject * TVirtualPad::WaitPrimitive(const char *, const char *)
@trydoc raw"""
    WaitPrimitive(this::ByRef1{TVirtualPad}, pname::ByCopy{String}, emode::ByCopy{String})::CxxPtr1{TObject}


""" WaitPrimitive(this::ByRef1{TVirtualPad}, pname::ByCopy{String}, emode::ByCopy{String})

# Wrapper of UInt_t TProcessUUID::AddUUID(const char *)
@trydoc raw"""
    AddUUID(this::ByRef1{TProcessUUID}, uuids::ByCopy{String})::UInt32
Add uuid with name uuids to the table of UUIDs return entry number in the table.

""" AddUUID(this::ByRef1{TProcessUUID}, uuids::ByCopy{String})

# Wrapper of UInt_t TProcessUUID::AddUUID(TUUID &, TObject *)
@trydoc raw"""
    AddUUID(this::ByRef1{TProcessUUID}, uuid::ByRef1{TUUID}, obj::ByPtr1{TObject})::UInt32
Add uuid to the table of UUIDs The [TObject](@ref) *obj has its uniqueID set to the UUID number return entry number in the table.

""" AddUUID(this::ByRef1{TProcessUUID}, uuid::ByRef1{TUUID}, obj::ByPtr1{TObject})

# Wrapper of void TProcessUUID::RemoveUUID(UInt_t)
@trydoc raw"""
    RemoveUUID(this::ByRef1{TProcessUUID}, number::UInt32)::Nothing
Remove entry number in the list of uuids.

""" RemoveUUID(this::ByRef1{TProcessUUID}, number::UInt32)

# Wrapper of void TProcessUUID::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TProcessUUID}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TProcessUUID}, ::ByRef1{TBuffer})

# Wrapper of void TProcessUUID::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TProcessUUID}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TProcessUUID}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TCanvas::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TCanvas}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TCanvas}, b::ByPtr1{TBrowser})

# Wrapper of TVirtualPad * TCanvas::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TCanvas}, subpadnumber::Int32)::CxxPtr1{TVirtualPad}
Set current canvas & pad.
Returns the new current pad, or 0 in case of failure. See [TPad!cd()](@ref) for an explanation of the parameter.
""" cd(this::ByRef1{TCanvas}, subpadnumber::Int32)

# Wrapper of void TCanvas::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Remove all primitives from the canvas.
If option "D" is specified, direct sub-pads are cleared but not deleted. This option is not recursive, i.e. pads in direct sub-pads are deleted.
""" Clear(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::Cleared(TVirtualPad *)
@trydoc raw"""
    Cleared(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad})::Nothing
Emit pad Cleared signal.

""" Cleared(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad})

# Wrapper of void TCanvas::ClearPadSave()
@trydoc raw"""
    ClearPadSave(this::ByRef1{TCanvas})::Nothing


""" ClearPadSave(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Close canvas.
Delete window/pads data structure
""" Close(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::Closed()
@trydoc raw"""
    Closed(this::ByRef1{TCanvas})::Nothing
Emit Closed signal.

""" Closed(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Constructor()
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas})::Nothing
Canvas default constructor.

""" Constructor(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Constructor(const char *, const char *, Int_t)
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, form::Int32)::Nothing
Create a new canvas with a predefined size form.
If form < 0 the menubar is not shown.

- form = 1 700x500 at 10,10 (set by [TStyle!SetCanvasDefH](@ref),W,X,Y)
- form = 2 500x500 at 20,20
- form = 3 500x500 at 30,30
- form = 4 500x500 at 40,40
- form = 5 500x500 at 50,50
""" Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, form::Int32)

# Wrapper of void TCanvas::Constructor(const char *, const char *, Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, wtopx::Int32, wtopy::Int32, ww::Int32, wh::Int32)::Nothing
Create a new canvas.
## Arguments

- **`name`** [in], **`title`** [in], **`wtopx`** [in], **`wtopy`** [in], **`ww`** [in], **`wh`** [in] 
    canvas name 
    . 
    canvas title 
    . 
    are the pixel coordinates of the top left corner of the canvas (if wtopx < 0) the menubar is not shown) 
    . 
    is the window size in pixels along X 
    . 
    is the window size in pixels along Y
""" Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, wtopx::Int32, wtopy::Int32, ww::Int32, wh::Int32)

# Wrapper of void TCanvas::Constructor(const char *, const char *, Int_t, Int_t)
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, ww::Int32, wh::Int32)::Nothing
Create a new canvas at a random position.
## Arguments

- **`name`** [in] 
    canvas name 
    
- **`title`** [in] 
    canvas title 
    
- **`ww`** [in] 
    is the window size in pixels along X (if ww < 0 the menubar is not shown) 
    
- **`wh`** [in] 
    is the window size in pixels along Y
""" Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, ww::Int32, wh::Int32)

# Wrapper of void TCanvas::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::DeleteCanvasPainter()
@trydoc raw"""
    DeleteCanvasPainter(this::ByRef1{TCanvas})::Nothing
assert on [IsBatch()](@ref) == false?

""" DeleteCanvasPainter(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Destructor()
@trydoc raw"""
    Destructor(this::ByRef1{TCanvas})::Nothing
Actual canvas destructor.

""" Destructor(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::DisconnectWidget()
@trydoc raw"""
    DisconnectWidget(this::ByRef1{TCanvas})::Nothing
Used by friend class [TCanvasImp](@ref).

""" DisconnectWidget(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Draw a canvas.
If a canvas with the name is already on the screen, the canvas is repainted. This function is useful when a canvas object has been saved in a Root file. One can then do: 

    Root > TFile!Open("file.root");
    Root > canvas->Draw();

(C++ version of the code)
""" Draw(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of TObject * TCanvas::DrawClonePad()
@trydoc raw"""
    DrawClonePad(this::ByRef1{TCanvas})::CxxPtr1{TObject}
Draw a clone of this canvas into the current pad In an interactive session, select the destination/current pad with the middle mouse button, then point to the canvas area to select the canvas context menu item DrawClonePad.
Note that the original canvas may have subpads.
""" DrawClonePad(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::EditorBar()
@trydoc raw"""
    EditorBar(this::ByRef1{TCanvas})::Nothing
Get editor bar.

""" EditorBar(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::EmbedInto(Int_t, Int_t, Int_t)
@trydoc raw"""
    EmbedInto(this::ByRef1{TCanvas}, winid::Int32, ww::Int32, wh::Int32)::Nothing
Embedded a canvas into a [TRootEmbeddedCanvas](@ref).
This method is only called via [TRootEmbeddedCanvas!AdoptCanvas](@ref).
""" EmbedInto(this::ByRef1{TCanvas}, winid::Int32, ww::Int32, wh::Int32)

# Wrapper of void TCanvas::EnterLeave(TPad *, TObject *)
@trydoc raw"""
    EnterLeave(this::ByRef1{TCanvas}, prevSelPad::ByPtr1{TPad}, prevSelObj::ByPtr1{TObject})::Nothing
Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the currently selected object.
Does nothing if the selected object does not change.
""" EnterLeave(this::ByRef1{TCanvas}, prevSelPad::ByPtr1{TPad}, prevSelObj::ByPtr1{TObject})

# Wrapper of void TCanvas::FeedbackMode(Bool_t)
@trydoc raw"""
    FeedbackMode(this::ByRef1{TCanvas}, set::Bool)::Nothing
Turn rubberband feedback mode on or off.

""" FeedbackMode(this::ByRef1{TCanvas}, set::Bool)

# Wrapper of void TCanvas::Flush()
@trydoc raw"""
    Flush(this::ByRef1{TCanvas})::Nothing
Flush canvas buffers.

""" Flush(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ForceUpdate()
@trydoc raw"""
    ForceUpdate(this::ByRef1{TCanvas})::Nothing
Force canvas update.

""" ForceUpdate(this::ByRef1{TCanvas})

# Wrapper of TVirtualPadPainter * TCanvas::GetCanvasPainter()
@trydoc raw"""
    GetCanvasPainter(this::ByRef1{TCanvas})::CxxPtr1{TVirtualPadPainter}
Access and (probably) creation of pad painter.

""" GetCanvasPainter(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::GetCanvasPar(Int_t &, Int_t &, UInt_t &, UInt_t &)
@trydoc raw"""
    GetCanvasPar(this::ByRef1{TCanvas}, wtopx::ByRef2{Int32}, wtopy::ByRef2{Int32}, ww::ByRef2{UInt32}, wh::ByRef2{UInt32})::Nothing


""" GetCanvasPar(this::ByRef1{TCanvas}, wtopx::ByRef2{Int32}, wtopy::ByRef2{Int32}, ww::ByRef2{UInt32}, wh::ByRef2{UInt32})

# Wrapper of Int_t TCanvas::GetWindowTopX()
@trydoc raw"""
    GetWindowTopX(this::ByRef1{TCanvas})::Int32
Returns current top x position of window on screen.

""" GetWindowTopX(this::ByRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetWindowTopY()
@trydoc raw"""
    GetWindowTopY(this::ByRef1{TCanvas})::Int32
Returns current top y position of window on screen.

""" GetWindowTopY(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::HandleInput(EEventType, Int_t, Int_t)
@trydoc raw"""
    HandleInput(this::ByRef1{TCanvas}, button::ByCopy{EEventType}, x::Int32, y::Int32)::Nothing
Handle Input Events.
Handle input events, like button up/down in current canvas.
""" HandleInput(this::ByRef1{TCanvas}, button::ByCopy{EEventType}, x::Int32, y::Int32)

# Wrapper of void TCanvas::HighlightConnect(const char *)
@trydoc raw"""
    HighlightConnect(this::ByRef1{TCanvas}, slot::ByCopy{String})::Nothing
This is "simplification" for function [TCanvas!Connect](@ref) with Highlighted signal for specific slot.
Slot has to be defined "UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)" all parameters of UserFunction are taken from [TCanvas!Highlighted](@ref)
""" HighlightConnect(this::ByRef1{TCanvas}, slot::ByCopy{String})

# Wrapper of void TCanvas::Highlighted(TVirtualPad *, TObject *, Int_t, Int_t)
@trydoc raw"""
    Highlighted(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, x::Int32, y::Int32)::Nothing
Emit [Highlighted()](@ref) signal.
- pad is pointer to pad with highlighted histogram or graph
- obj is pointer to highlighted histogram or graph
- x is highlighted x bin for 1D histogram or highlighted x-th point for graph
- y is highlighted y bin for 2D histogram (for 1D histogram or graph not in use)
""" Highlighted(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, x::Int32, y::Int32)

# Wrapper of void TCanvas::Iconify()
@trydoc raw"""
    Iconify(this::ByRef1{TCanvas})::Nothing
Iconify canvas.

""" Iconify(this::ByRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsGrayscale()
@trydoc raw"""
    IsGrayscale(this::ByRef1{TCanvas})::Bool
Check whether this canvas is to be drawn in grayscale mode.

""" IsGrayscale(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::MoveOpaque(Int_t)
@trydoc raw"""
    MoveOpaque(this::ByRef1{TCanvas}, set::Int32)::Nothing
Set option to move objects/pads in a canvas.
- set = 1 (default) graphics objects are moved in opaque mode
- set = 0 only the outline of objects is drawn when moving them

The option opaque produces the best effect. It requires however a a reasonably fast workstation or response time.
""" MoveOpaque(this::ByRef1{TCanvas}, set::Int32)

# Wrapper of void TCanvas::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Paint canvas.

""" Paint(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of TPad * TCanvas::Pick(Int_t, Int_t, TObject *)
@trydoc raw"""
    Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, prevSelObj::ByPtr1{TObject})::CxxPtr1{TPad}
Prepare for pick, call [TPad!Pick()](@ref) and when selected object is different from previous then emit [Picked()](@ref) signal.

""" Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, prevSelObj::ByPtr1{TObject})

# Wrapper of TPad * TCanvas::Pick(Int_t, Int_t, TObjLink *&)
@trydoc raw"""
    Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, pickobj::ByPtr1{TObjLink})::CxxPtr1{TPad}
Search for an object at pixel position px,py.
Check if point is in this pad.

If yes, check if it is in one of the sub-pads

If found in the pad, compute closest distance of approach to each primitive.

If one distance of approach is found to be within the limit Distancemaximum the corresponding primitive is selected and the routine returns.
""" Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, pickobj::ByPtr1{TObjLink})

# Wrapper of void TCanvas::Picked(TPad *, TObject *, Int_t)
@trydoc raw"""
    Picked(this::ByRef1{TCanvas}, selpad::ByPtr1{TPad}, selected::ByPtr1{TObject}, event::Int32)::Nothing
Emit [Picked()](@ref) signal.

""" Picked(this::ByRef1{TCanvas}, selpad::ByPtr1{TPad}, selected::ByPtr1{TObject}, event::Int32)

# Wrapper of void TCanvas::ProcessedEvent(Int_t, Int_t, Int_t, TObject *)
@trydoc raw"""
    ProcessedEvent(this::ByRef1{TCanvas}, event::Int32, x::Int32, y::Int32, selected::ByPtr1{TObject})::Nothing
Emit [ProcessedEvent()](@ref) signal.

""" ProcessedEvent(this::ByRef1{TCanvas}, event::Int32, x::Int32, y::Int32, selected::ByPtr1{TObject})

# Wrapper of void TCanvas::RaiseWindow()
@trydoc raw"""
    RaiseWindow(this::ByRef1{TCanvas})::Nothing
Raise canvas window.

""" RaiseWindow(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ResetDrawn()
@trydoc raw"""
    ResetDrawn(this::ByRef1{TCanvas})::Nothing


""" ResetDrawn(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ResetUpdated()
@trydoc raw"""
    ResetUpdated(this::ByRef1{TCanvas})::Nothing


""" ResetUpdated(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Resize(Option_t *)
@trydoc raw"""
    Resize(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Recompute canvas parameters following a X11 Resize.

""" Resize(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::ResizeOpaque(Int_t)
@trydoc raw"""
    ResizeOpaque(this::ByRef1{TCanvas}, set::Int32)::Nothing
Set option to resize objects/pads in a canvas.
- set = 1 (default) graphics objects are resized in opaque mode
- set = 0 only the outline of objects is drawn when resizing them

The option opaque produces the best effect. It requires however a a reasonably fast workstation or response time.
""" ResizeOpaque(this::ByRef1{TCanvas}, set::Int32)

# Wrapper of void TCanvas::SaveSource(const char *, Option_t *)
@trydoc raw"""
    SaveSource(this::ByRef1{TCanvas}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save primitives in this canvas as a C++ macro file.
This function loops on all the canvas primitives and for each primitive calls the object SavePrimitive function. When outputting floating point numbers, the default precision is 7 digits. The precision can be changed (via system.rootrc) by changing the value of the environment variable "Canvas.SavePrecision"
""" SaveSource(this::ByRef1{TCanvas}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TCanvas::Selected(TVirtualPad *, TObject *, Int_t)
@trydoc raw"""
    Selected(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, event::Int32)::Nothing
Emit [Selected()](@ref) signal.

""" Selected(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, event::Int32)

# Wrapper of void TCanvas::SetBatch(Bool_t)
@trydoc raw"""
    SetBatch(this::ByRef1{TCanvas}, batch::Bool)::Nothing
Toggle batch mode.
However, if the canvas is created without a window then batch mode always stays set.
""" SetBatch(this::ByRef1{TCanvas}, batch::Bool)

# Wrapper of void TCanvas::SetCanvasSize(UInt_t, UInt_t)
@trydoc raw"""
    SetCanvasSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)::Nothing
Set Width and Height of canvas to ww and wh respectively.
If ww and/or wh are greater than the current canvas window a scroll bar is automatically generated. Use this function to zoom in a canvas and navigate via the scroll bars. The Width and Height in this method are different from those given in the [TCanvas](@ref) constructors where these two dimension include the size of the window decoration whereas they do not in this method. When both ww==0 and wh==0, auto resize mode will be enabled again and canvas drawing area will automatically fit available window size
""" SetCanvasSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)

# Wrapper of void TCanvas::SetClickSelected(TObject *)
@trydoc raw"""
    SetClickSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})::Nothing


""" SetClickSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})

# Wrapper of void TCanvas::SetClickSelectedPad(TPad *)
@trydoc raw"""
    SetClickSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})::Nothing


""" SetClickSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})

# Wrapper of void TCanvas::SetCursor(ECursor)
@trydoc raw"""
    SetCursor(this::ByRef1{TCanvas}, cursor::ByCopy{ECursor})::Nothing
Set cursor.

""" SetCursor(this::ByRef1{TCanvas}, cursor::ByCopy{ECursor})

# Wrapper of void TCanvas::SetDoubleBuffer(Int_t)
@trydoc raw"""
    SetDoubleBuffer(this::ByRef1{TCanvas}, mode::Int32)::Nothing
Set Double Buffer On/Off.

""" SetDoubleBuffer(this::ByRef1{TCanvas}, mode::Int32)

# Wrapper of void TCanvas::SetFixedAspectRatio(Bool_t)
@trydoc raw"""
    SetFixedAspectRatio(this::ByRef1{TCanvas}, fixed::Bool)::Nothing
Fix canvas aspect ratio to current value if fixed is true.

""" SetFixedAspectRatio(this::ByRef1{TCanvas}, fixed::Bool)

# Wrapper of void TCanvas::SetGrayscale(Bool_t)
@trydoc raw"""
    SetGrayscale(this::ByRef1{TCanvas}, set::Bool)::Nothing
Set whether this canvas should be painted in grayscale, and re-paint it if necessary.

""" SetGrayscale(this::ByRef1{TCanvas}, set::Bool)

# Wrapper of void TCanvas::SetHighLightColor(Color_t)
@trydoc raw"""
    SetHighLightColor(this::ByRef1{TCanvas}, col::Int16)::Nothing


""" SetHighLightColor(this::ByRef1{TCanvas}, col::Int16)

# Wrapper of void TCanvas::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TCanvas}, name::ByCopy{String})::Nothing
Set canvas name. In case `name` is an empty string, a default name is set.

""" SetName(this::ByRef1{TCanvas}, name::ByCopy{String})

# Wrapper of void TCanvas::SetPadSave(TPad *)
@trydoc raw"""
    SetPadSave(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})::Nothing


""" SetPadSave(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})

# Wrapper of bool TCanvas::SetRealAspectRatio(const Int_t)
@trydoc raw"""
    SetRealAspectRatio(this::ByRef1{TCanvas}, axis::ByCopy{Int32})::Bool
Function to resize a canvas so that the plot inside is shown in real aspect ratio.
## Arguments

- **`axis`** [in] 
    1 for resizing horizontally (x-axis) in order to get real aspect ratio, 2 for the resizing vertically (y-axis) 
    

###Return

false if error is encountered, true otherwise

    hpxpy->Draw();
    c1->SetRealAspectRatio();

(C++ version of the code)

- For defining the concept of real aspect ratio, it is assumed that x and y axes are in same units, e.g. both in MeV or both in ns.
- You can resize either the width of the canvas or the height, but not both at the same time
- Call this function AFTER drawing AND zooming (SetUserRange) your [TGraph](@ref) or Histogram, otherwise it cannot infer your actual axes lengths
- This function ensures that the [TFrame](@ref) has a real aspect ratio, this does not mean that the full pad (i.e. the canvas or png output) including margins has exactly the same ratio
- This function does not work if the canvas is divided in several subpads
""" SetRealAspectRatio(this::ByRef1{TCanvas}, axis::ByCopy{Int32})

# Wrapper of void TCanvas::SetRetained(Bool_t)
@trydoc raw"""
    SetRetained(this::ByRef1{TCanvas}, retained::Bool)::Nothing


""" SetRetained(this::ByRef1{TCanvas}, retained::Bool)

# Wrapper of void TCanvas::SetSelected(TObject *)
@trydoc raw"""
    SetSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})::Nothing
Set selected canvas.

""" SetSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})

# Wrapper of void TCanvas::SetSelectedPad(TPad *)
@trydoc raw"""
    SetSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})::Nothing


""" SetSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})

# Wrapper of void TCanvas::SetSupportGL(Bool_t)
@trydoc raw"""
    SetSupportGL(this::ByRef1{TCanvas}, support::Bool)::Nothing


""" SetSupportGL(this::ByRef1{TCanvas}, support::Bool)

# Wrapper of void TCanvas::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TCanvas}, title::ByCopy{String})::Nothing
Set canvas title.

""" SetTitle(this::ByRef1{TCanvas}, title::ByCopy{String})

# Wrapper of void TCanvas::SetWindowPosition(Int_t, Int_t)
@trydoc raw"""
    SetWindowPosition(this::ByRef1{TCanvas}, x::Int32, y::Int32)::Nothing
Set canvas window position.

""" SetWindowPosition(this::ByRef1{TCanvas}, x::Int32, y::Int32)

# Wrapper of void TCanvas::SetWindowSize(UInt_t, UInt_t)
@trydoc raw"""
    SetWindowSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)::Nothing
Set canvas window size.

""" SetWindowSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)

# Wrapper of void TCanvas::Show()
@trydoc raw"""
    Show(this::ByRef1{TCanvas})::Nothing
Show canvas.

""" Show(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Size(Float_t, Float_t)
@trydoc raw"""
    Size(this::ByRef1{TCanvas}, xsizeuser::Float32, ysizeuser::Float32)::Nothing
Set the canvas scale in centimeters.
This information is used by PostScript to set the page size.

## Arguments

- **`xsize`** [in] 
    size of the canvas in centimeters along X 
    
- **`ysize`** [in] 
    size of the canvas in centimeters along Y
    

if xsize and ysize are not equal to 0, then the scale factors will be computed to keep the ratio ysize/xsize independently of the canvas size (parts of the physical canvas will be unused).

if xsize = 0 and ysize is not zero, then xsize will be computed to fit to the current canvas scale. If the canvas is resized, a new value for xsize will be recomputed. In this case the aspect ratio is not preserved.

if both xsize = 0 and ysize = 0, then the scaling is automatic. the largest dimension will be allocated a size of 20 centimeters.
""" Size(this::ByRef1{TCanvas}, xsizeuser::Float32, ysizeuser::Float32)

# Wrapper of void TCanvas::ToggleAutoExec()
@trydoc raw"""
    ToggleAutoExec(this::ByRef1{TCanvas})::Nothing
Toggle pad auto execution of list of TExecs.

""" ToggleAutoExec(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleEditor()
@trydoc raw"""
    ToggleEditor(this::ByRef1{TCanvas})::Nothing
Toggle editor.

""" ToggleEditor(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleEventStatus()
@trydoc raw"""
    ToggleEventStatus(this::ByRef1{TCanvas})::Nothing
Toggle event statusbar.

""" ToggleEventStatus(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleToolBar()
@trydoc raw"""
    ToggleToolBar(this::ByRef1{TCanvas})::Nothing
Toggle toolbar.

""" ToggleToolBar(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleToolTips()
@trydoc raw"""
    ToggleToolTips(this::ByRef1{TCanvas})::Nothing
Toggle tooltip display.

""" ToggleToolTips(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Update()
@trydoc raw"""
    Update(this::ByRef1{TCanvas})::Nothing
Update canvas pad buffers.

""" Update(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::UpdateAsync()
@trydoc raw"""
    UpdateAsync(this::ByRef1{TCanvas})::Nothing
Asynchronous pad update.
In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->[Update()](@ref) is performed.
""" UpdateAsync(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TCanvas})::Nothing
Force a copy of current style for all objects in canvas.

""" UseCurrentStyle(this::ByRef1{TCanvas})

# Wrapper of Longptr_t TPluginHandler::ExecPlugin(int)
@trydoc raw"""
    ExecPlugin(this::ByRef1{TPluginHandler}, nargs::Int32)::Int64


""" ExecPlugin(this::ByRef1{TPluginHandler}, nargs::Int32)

# Wrapper of Longptr_t TPluginHandler::ExecPluginImpl()
@trydoc raw"""
    ExecPluginImpl(this::ByRef1{TPluginHandler})::Int64


""" ExecPluginImpl(this::ByRef1{TPluginHandler})

# Wrapper of Int_t TPluginHandler::LoadPlugin()
@trydoc raw"""
    LoadPlugin(this::ByRef1{TPluginHandler})::Int32
Load the plugin library for this handler.
Returns 0 on successful loading and -1 in case the library does not exist or in case of error.
""" LoadPlugin(this::ByRef1{TPluginHandler})

# Wrapper of void TPluginHandler::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TPluginHandler}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TPluginHandler}, ::ByRef1{TBuffer})

# Wrapper of void TPluginHandler::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TPluginHandler}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TPluginHandler}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of TArray & TArray::operator=(const TArray &)
@trydoc raw"""
    assign(this::ByRef1{TArray}, rhs::ByConstRef1{TArray})::CxxRef1{TArray}


""" assign(this::ByRef1{TArray}, rhs::ByConstRef1{TArray})

# Wrapper of void TArray::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArray}, n::Int32)::Nothing


""" Set(this::ByRef1{TArray}, n::Int32)

# Wrapper of void TArray::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArray}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArray}, v::Float64, i::Int32)

# Wrapper of void TArrayI::AddAt(Int_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayI}, c::Int32, i::Int32)::Nothing
Add Int_t c at position i. Check for out of bounds.

""" AddAt(this::ByRef1{TArrayI}, c::Int32, i::Int32)

# Wrapper of void TArrayI::Adopt(Int_t, Int_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayI}, n::Int32, array::ByPtr2{Int32})::Nothing
Adopt array arr into [TArrayI](@ref), i.e.
don't copy arr but use it directly in [TArrayI](@ref). User may not delete arr, [TArrayI](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayI}, n::Int32, array::ByPtr2{Int32})

# Wrapper of Int_t * TArrayI::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayI})::CxxPtr2{Int32}


""" GetArray(this::ByRef1{TArrayI})

# Wrapper of TArrayI & TArrayI::operator=(const TArrayI &)
@trydoc raw"""
    assign(this::ByRef1{TArrayI}, rhs::ByConstRef1{TArrayI})::CxxRef1{TArrayI}
[TArrayI](@ref) assignment operator.

""" assign(this::ByRef1{TArrayI}, rhs::ByConstRef1{TArrayI})

# Wrapper of Int_t & TArrayI::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayI}, i::Int32)::CxxRef2{Int32}


""" Base.getindex(this::ByRef1{TArrayI}, i::Int32)

# Wrapper of void TArrayI::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TArrayI})::Nothing


""" Reset(this::ByRef1{TArrayI})

# Wrapper of void TArrayI::Reset(Int_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayI}, val::Int32)::Nothing


""" Reset(this::ByRef1{TArrayI}, val::Int32)

# Wrapper of void TArrayI::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayI}, n::Int32)::Nothing
Set size of this array to n ints.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayI}, n::Int32)

# Wrapper of void TArrayI::Set(Int_t, const Int_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayI}, n::Int32, array::ByConstPtr2{Int32})::Nothing
Set size of this array to n ints and set the contents.
This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayI}, n::Int32, array::ByConstPtr2{Int32})

# Wrapper of void TArrayI::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayI}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayI}, v::Float64, i::Int32)

# Wrapper of void TPMERegexp::AssignGlobalState(const TPMERegexp &)
@trydoc raw"""
    AssignGlobalState(this::ByRef1{TPMERegexp}, re::ByConstRef1{TPMERegexp})::Nothing
Copy global_-match state from 're; so that this regexp can continue parsing the string from where 're' left off.
Alternatively, [GetGlobalPosition()](@ref) get be used to retrieve the last match position so that it can passed to [Match()](@ref).

Ideally, as it is done in PERL, the last match position would be stored in the [TString](@ref) itself.
""" AssignGlobalState(this::ByRef1{TPMERegexp}, re::ByConstRef1{TPMERegexp})

# Wrapper of Int_t TPMERegexp::Match(const TString &, UInt_t)
@trydoc raw"""
    Match(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, thestart::UInt32)::Int32
Runs a match on s against the regex 'this' was created with.
## Arguments

- **`s`** [in] 
    string to match against 
    
- **`thestart`** [in] 
    offset at which to thestart matching 
    

###Return

number of matches found
""" Match(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, thestart::UInt32)

# Wrapper of TString TPMERegexp::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TPMERegexp}, ::Int32)::ByCopy{TString}
Returns the sub-string from the internal fMarkers vector.
Requires having run match or split first.
""" Base.getindex(this::ByRef1{TPMERegexp}, ::Int32)

# Wrapper of void TPMERegexp::Print(Option_t *)
@trydoc raw"""
    Print(this::ByRef1{TPMERegexp}, option::ByCopy{String})::Nothing
Print the regular expression and modifier options.
If 'option' contains "all", prints also last string match and match results.
""" Print(this::ByRef1{TPMERegexp}, option::ByCopy{String})

# Wrapper of void TPMERegexp::Reset(const TString &, const TString &, Int_t)
@trydoc raw"""
    Reset(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, opts::ByConstRef1{TString}, nMatchMax::Int32)::Nothing
Reset the pattern and options.
If 'nMatchMax' other than -1 (the default) is passed, it is also set.
""" Reset(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, opts::ByConstRef1{TString}, nMatchMax::Int32)

# Wrapper of void TPMERegexp::Reset(const TString &, UInt_t, Int_t)
@trydoc raw"""
    Reset(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, opts::UInt32, nMatchMax::Int32)::Nothing
Reset the pattern and options.
If 'nMatchMax' other than -1 (the default) is passed, it is also set.
""" Reset(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, opts::UInt32, nMatchMax::Int32)

# Wrapper of void TPMERegexp::ResetGlobalState()
@trydoc raw"""
    ResetGlobalState(this::ByRef1{TPMERegexp})::Nothing
Reset state of global_ match.
This happens automatically when a new string is passed for matching. But be carefull, as the address of last [TString](@ref) object is used to make this decision.
""" ResetGlobalState(this::ByRef1{TPMERegexp})

# Wrapper of void TPMERegexp::SetNMaxMatches(Int_t)
@trydoc raw"""
    SetNMaxMatches(this::ByRef1{TPMERegexp}, nm::Int32)::Nothing


""" SetNMaxMatches(this::ByRef1{TPMERegexp}, nm::Int32)

# Wrapper of Int_t TPMERegexp::Split(const TString &, Int_t)
@trydoc raw"""
    Split(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, maxfields::Int32)::Int32
Splits into at most maxfields.
If maxfields is unspecified or 0, trailing empty matches are discarded. If maxfields is positive, no more than maxfields fields will be returned and trailing empty matches are preserved. If maxfields is empty, all fields (including trailing empty ones) are returned. This *should* be the same as the perl behaviour.

If pattern produces sub-matches, these are also stored in the result.

A pattern matching the null string will split the value of EXPR into separate characters at each point it matches that way.

## Arguments

- **`s`** [in] 
    string to split 
    
- **`maxfields`** [in] 
    maximum number of fields to be split out. 0 means split all fields, but discard any trailing empty bits. Negative means split all fields and keep trailing empty bits. Positive means keep up to N fields including any empty fields less than N. Anything remaining is in the last field. 
    

###Return

number of fields found
""" Split(this::ByRef1{TPMERegexp}, s::ByConstRef1{TString}, maxfields::Int32)

# Wrapper of void TPMERegexp::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TPMERegexp}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TPMERegexp}, ::ByRef1{TBuffer})

# Wrapper of void TPMERegexp::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TPMERegexp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TPMERegexp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TPMERegexp::Substitute(TString &, const TString &, Bool_t)
@trydoc raw"""
    Substitute(this::ByRef1{TPMERegexp}, s::ByRef1{TString}, r::ByConstRef1{TString}, doDollarSubst::Bool)::Int32
Substitute matching part of s with r, dollar back-ref substitution is performed if doDollarSubst is true (default).
Returns the number of substitutions made.

After the substitution, another pass is made over the resulting string and the following special tokens are interpreted:

- `\l` lowercase next char,
- `\u` uppercase next char,
- `\L` lowercase till `\E`,
- `\U` uppercase till `\E`, and
- `\E` theend case modification.
""" Substitute(this::ByRef1{TPMERegexp}, s::ByRef1{TString}, r::ByConstRef1{TString}, doDollarSubst::Bool)

# Wrapper of Bool_t TStringToken::NextToken()
@trydoc raw"""
    NextToken(this::ByRef1{TStringToken})::Bool
Get the next token, it is stored in this [TString](@ref).
Returns true if new token is available, false otherwise.
""" NextToken(this::ByRef1{TStringToken})

# Wrapper of void TStringToken::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TStringToken}, ::ByRef1{TBuffer})::Nothing
Stream a string object.

""" Streamer(this::ByRef1{TStringToken}, ::ByRef1{TBuffer})

# Wrapper of void TStringToken::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TStringToken}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TStringToken}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TBits::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TBits}, option::ByCopy{String})::Nothing
Clear the value.

""" Clear(this::ByRef1{TBits}, option::ByCopy{String})

# Wrapper of void TBits::Compact()
@trydoc raw"""
    Compact(this::ByRef1{TBits})::Nothing
Reduce the storage used by the object to a minimun.

""" Compact(this::ByRef1{TBits})

# Wrapper of TBits & TBits::operator&=(const TBits &)
@trydoc raw"""
    and!(this::ByRef1{TBits}, rhs::ByConstRef1{TBits})::CxxRef1{TBits}


""" and!(this::ByRef1{TBits}, rhs::ByConstRef1{TBits})

# Wrapper of TBits TBits::operator<<(UInt_t)
@trydoc raw"""
    Base.:(<<)(this::ByRef1{TBits}, rhs::UInt32)::ByCopy{TBits}


""" Base.:(<<)(this::ByRef1{TBits}, rhs::UInt32)

# Wrapper of TBits & TBits::operator<<=(UInt_t)
@trydoc raw"""
    lshit!(this::ByRef1{TBits}, rhs::UInt32)::CxxRef1{TBits}


""" lshit!(this::ByRef1{TBits}, rhs::UInt32)

# Wrapper of TBits & TBits::operator=(const TBits &)
@trydoc raw"""
    assign(this::ByRef1{TBits}, ::ByConstRef1{TBits})::CxxRef1{TBits}
[TBits](@ref) assignment operator.

""" assign(this::ByRef1{TBits}, ::ByConstRef1{TBits})

# Wrapper of TBits TBits::operator>>(UInt_t)
@trydoc raw"""
    Base.:(>>)(this::ByRef1{TBits}, rhs::UInt32)::ByCopy{TBits}


""" Base.:(>>)(this::ByRef1{TBits}, rhs::UInt32)

# Wrapper of TBits & TBits::operator>>=(UInt_t)
@trydoc raw"""
    rshit!(this::ByRef1{TBits}, rhs::UInt32)::CxxRef1{TBits}


""" rshit!(this::ByRef1{TBits}, rhs::UInt32)

# Wrapper of TBits & TBits::operator^=(const TBits &)
@trydoc raw"""
    xor_eq(this::ByRef1{TBits}, rhs::ByConstRef1{TBits})::CxxRef1{TBits}


""" xor_eq(this::ByRef1{TBits}, rhs::ByConstRef1{TBits})

# Wrapper of TBits & TBits::operator|=(const TBits &)
@trydoc raw"""
    or!(this::ByRef1{TBits}, rhs::ByConstRef1{TBits})::CxxRef1{TBits}


""" or!(this::ByRef1{TBits}, rhs::ByConstRef1{TBits})

# Wrapper of void TBits::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TBits}, option::ByCopy{String})::Nothing
Once implemented, it will draw the bit field as an histogram.
use the TVirtualPainter as the usual trick
""" Paint(this::ByRef1{TBits}, option::ByCopy{String})

# Wrapper of void TBits::ResetAllBits(Bool_t)
@trydoc raw"""
    ResetAllBits(this::ByRef1{TBits}, value::Bool)::Nothing
Reset all bits to 0 (false).

""" ResetAllBits(this::ByRef1{TBits}, value::Bool)

# Wrapper of void TBits::ResetBitNumber(UInt_t)
@trydoc raw"""
    ResetBitNumber(this::ByRef1{TBits}, bitnumber::UInt32)::Nothing


""" ResetBitNumber(this::ByRef1{TBits}, bitnumber::UInt32)

# Wrapper of void TBits::Set(UInt_t, const Char_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByCopy{String})::Nothing
Set all the bytes.

""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByCopy{String})

# Wrapper of void TBits::Set(UInt_t, const Int_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{Int32})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{Int32})

# Wrapper of void TBits::Set(UInt_t, const Long64_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{Int64})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{Int64})

# Wrapper of void TBits::Set(UInt_t, const Short_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{Int16})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{Int16})

# Wrapper of void TBits::Set(UInt_t, const UChar_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt8})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt8})

# Wrapper of void TBits::Set(UInt_t, const UInt_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt32})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt32})

# Wrapper of void TBits::Set(UInt_t, const ULong64_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt64})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt64})

# Wrapper of void TBits::Set(UInt_t, const UShort_t *)
@trydoc raw"""
    Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt16})::Nothing


""" Set(this::ByRef1{TBits}, nbits::UInt32, array::ByConstPtr2{UInt16})

# Wrapper of void TBits::SetBitNumber(UInt_t, Bool_t)
@trydoc raw"""
    SetBitNumber(this::ByRef1{TBits}, bitnumber::UInt32, value::Bool)::Nothing


""" SetBitNumber(this::ByRef1{TBits}, bitnumber::UInt32, value::Bool)

# Wrapper of void TQClass::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TQClass}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TQClass}, ::ByRef1{TBuffer})

# Wrapper of void TQClass::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TQClass}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TQClass}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TQCommand::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TQCommand}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TQCommand}, obj::ByPtr1{TObject})

# Wrapper of void TQCommand::Add(TObject *, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TQCommand}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add command to the list of merged commands.
Option string can contain substrings:

- "compress" - try to compress input command
- "radd" - execute redo action of input command
- "uadd" - execute undo action of input command
""" Add(this::ByRef1{TQCommand}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TQCommand::Compress(TQCommand *)
@trydoc raw"""
    Compress(this::ByRef1{TQCommand}, c::ByPtr1{TQCommand})::Nothing
Compress command.
Compression is analogous to arithmetic "addition operation".

Note:

- The compressed command will be deleted.
- Execution Compress method invokes Redo action with new redo arguments inherited from compressed command.

More complicated commands might want to override this function.
""" Compress(this::ByRef1{TQCommand}, c::ByPtr1{TQCommand})

# Wrapper of void TQCommand::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TQCommand}, option::ByCopy{String})::Nothing
If "opt" is not zero delete every merged command which option string is equal to "opt".
If "opt" is zero - delete all merged commands.
""" Delete(this::ByRef1{TQCommand}, option::ByCopy{String})

# Wrapper of void TQCommand::Merge(TQCommand *)
@trydoc raw"""
    Merge(this::ByRef1{TQCommand}, c::ByPtr1{TQCommand})::Nothing
Add command to the list of merged commands.
This make it possible to group complex actions together so an theend user can undo and redo them with one command. Execution of [TQUndoManager!Undo()](@ref), [TQUndoManager!Redo()](@ref) methods only invokes the top level command as a whole.

Merge method is analogous to logical join operation.

Note: Merge method invokes redo action.
""" Merge(this::ByRef1{TQCommand}, c::ByPtr1{TQCommand})

# Wrapper of void TQCommand::Redo(Option_t *)
@trydoc raw"""
    Redo(this::ByRef1{TQCommand}, option::ByCopy{String})::Nothing
Execute command and then merge commands.

""" Redo(this::ByRef1{TQCommand}, option::ByCopy{String})

# Wrapper of void TQCommand::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TQCommand}, name::ByCopy{String})::Nothing
Sets name of the command.

""" SetName(this::ByRef1{TQCommand}, name::ByCopy{String})

# Wrapper of void TQCommand::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TQCommand}, title::ByCopy{String})::Nothing
Sets description of the command.

""" SetTitle(this::ByRef1{TQCommand}, title::ByCopy{String})

# Wrapper of void TQCommand::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TQCommand}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TQCommand}, ::ByRef1{TBuffer})

# Wrapper of void TQCommand::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TQCommand}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TQCommand}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TQCommand::Undo(Option_t *)
@trydoc raw"""
    Undo(this::ByRef1{TQCommand}, option::ByCopy{String})::Nothing
Un-execute all merged commands and the command.
Merged commands are executed in reverse order.
""" Undo(this::ByRef1{TQCommand}, option::ByCopy{String})

# Wrapper of void TQConnection::Destroyed()
@trydoc raw"""
    Destroyed(this::ByRef1{TQConnection})::Nothing
Signal Destroyed tells that connection is destroyed.

""" Destroyed(this::ByRef1{TQConnection})

# Wrapper of void TQConnection::ExecuteMethod()
@trydoc raw"""
    ExecuteMethod(this::ByRef1{TQConnection})::Nothing
Apply slot-method to the fReceiver object without arguments.

""" ExecuteMethod(this::ByRef1{TQConnection})

# Wrapper of void TQConnection::ExecuteMethod(const char *)
@trydoc raw"""
    ExecuteMethod(this::ByRef1{TQConnection}, params::ByCopy{String})::Nothing
Apply slot-method to the fReceiver object and with string parameter.

""" ExecuteMethod(this::ByRef1{TQConnection}, params::ByCopy{String})

# Wrapper of void TQConnection::ExecuteMethod(Double_t)
@trydoc raw"""
    ExecuteMethod(this::ByRef1{TQConnection}, param::Float64)::Nothing
Apply slot-method to the fReceiver object with single argument value.

""" ExecuteMethod(this::ByRef1{TQConnection}, param::Float64)

# Wrapper of void TQConnection::ExecuteMethod(Long_t)
@trydoc raw"""
    ExecuteMethod(this::ByRef1{TQConnection}, param::Int64)::Nothing
Apply slot-method to the fReceiver object with single argument value.

""" ExecuteMethod(this::ByRef1{TQConnection}, param::Int64)

# Wrapper of void TQConnection::ExecuteMethod(Longptr_t *, Int_t)
@trydoc raw"""
    ExecuteMethod(this::ByRef1{TQConnection}, params::ByPtr2{Int64}, nparam::Int32)::Nothing
Apply slot-method to the fReceiver object with variable number of argument values.

""" ExecuteMethod(this::ByRef1{TQConnection}, params::ByPtr2{Int64}, nparam::Int32)

# Wrapper of void TQConnection::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TQConnection}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TQConnection}, ::ByRef1{TBuffer})

# Wrapper of void TQConnection::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TQConnection}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TQConnection}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TQUndoManager::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TQUndoManager}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TQUndoManager}, obj::ByPtr1{TObject})

# Wrapper of void TQUndoManager::Add(TObject *, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TQUndoManager}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add command to the stack of commands.
Command's redo action will be executed.

option string can contain the following substrings:

- "merge" - input command will be merged
- "compress" - input command will be compressed
""" Add(this::ByRef1{TQUndoManager}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TQUndoManager::CurrentChanged(TQCommand *)
@trydoc raw"""
    CurrentChanged(this::ByRef1{TQUndoManager}, c::ByPtr1{TQCommand})::Nothing
emit signal

""" CurrentChanged(this::ByRef1{TQUndoManager}, c::ByPtr1{TQCommand})

# Wrapper of void TQUndoManager::Redo(Option_t *)
@trydoc raw"""
    Redo(this::ByRef1{TQUndoManager}, option::ByCopy{String})::Nothing
Performs redo action. Move cursor position forward in history stack.

""" Redo(this::ByRef1{TQUndoManager}, option::ByCopy{String})

# Wrapper of void TQUndoManager::SetLimit(UInt_t)
@trydoc raw"""
    SetLimit(this::ByRef1{TQUndoManager}, limit::UInt32)::Nothing
Returns a maximum number of commands which could be located in stack.

""" SetLimit(this::ByRef1{TQUndoManager}, limit::UInt32)

# Wrapper of void TQUndoManager::SetLogging(Bool_t)
@trydoc raw"""
    SetLogging(this::ByRef1{TQUndoManager}, on::Bool)::Nothing
Start logging.
Delete all previous log records Note: logging is not implemented yet
""" SetLogging(this::ByRef1{TQUndoManager}, on::Bool)

# Wrapper of void TQUndoManager::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TQUndoManager}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TQObject](@ref).

""" Streamer(this::ByRef1{TQUndoManager}, ::ByRef1{TBuffer})

# Wrapper of void TQUndoManager::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TQUndoManager}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TQUndoManager}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TQUndoManager::Undo(Option_t *)
@trydoc raw"""
    Undo(this::ByRef1{TQUndoManager}, option::ByCopy{String})::Nothing
Performs undo action. Move cursor position backward in history stack.

""" Undo(this::ByRef1{TQUndoManager}, option::ByCopy{String})

# Wrapper of TTime TTime::operator*=(const TTime &)
@trydoc raw"""
    mult!(this::ByRef1{TTime}, t::ByConstRef1{TTime})::ByCopy{TTime}


""" mult!(this::ByRef1{TTime}, t::ByConstRef1{TTime})

# Wrapper of TTime TTime::operator+=(const TTime &)
@trydoc raw"""
    add!(this::ByRef1{TTime}, t::ByConstRef1{TTime})::ByCopy{TTime}


""" add!(this::ByRef1{TTime}, t::ByConstRef1{TTime})

# Wrapper of TTime TTime::operator-=(const TTime &)
@trydoc raw"""
    sub!(this::ByRef1{TTime}, t::ByConstRef1{TTime})::ByCopy{TTime}


""" sub!(this::ByRef1{TTime}, t::ByConstRef1{TTime})

# Wrapper of TTime TTime::operator/=(const TTime &)
@trydoc raw"""
    fdiv!(this::ByRef1{TTime}, t::ByConstRef1{TTime})::ByCopy{TTime}


""" fdiv!(this::ByRef1{TTime}, t::ByConstRef1{TTime})

# Wrapper of TTime & TTime::operator=(const TTime &)
@trydoc raw"""
    assign(this::ByRef1{TTime}, t::ByConstRef1{TTime})::CxxRef1{TTime}


""" assign(this::ByRef1{TTime}, t::ByConstRef1{TTime})

# Wrapper of void TTime::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TTime}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TTime}, ::ByRef1{TBuffer})

# Wrapper of void TTime::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TTime}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TTime}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TTimer::Add()
@trydoc raw"""
    Add(this::ByRef1{TTimer})::Nothing


""" Add(this::ByRef1{TTimer})

# Wrapper of Bool_t TTimer::CheckTimer(const TTime &)
@trydoc raw"""
    CheckTimer(this::ByRef1{TTimer}, now::ByConstRef1{TTime})::Bool
Check if timer timed out.

""" CheckTimer(this::ByRef1{TTimer}, now::ByConstRef1{TTime})

# Wrapper of TObject * TTimer::GetObject()
@trydoc raw"""
    GetObject(this::ByRef1{TTimer})::CxxPtr1{TObject}


""" GetObject(this::ByRef1{TTimer})

# Wrapper of UInt_t TTimer::GetTimerID()
@trydoc raw"""
    GetTimerID(this::ByRef1{TTimer})::UInt32


""" GetTimerID(this::ByRef1{TTimer})

# Wrapper of Bool_t TTimer::IsRunning()
@trydoc raw"""
    IsRunning(this::ByRef1{TTimer})::Bool
This function checks if the timer is running within gSystem (Has been started and did not finish yet).

""" IsRunning(this::ByRef1{TTimer})

# Wrapper of Bool_t TTimer::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TTimer})::Bool
Notify when timer times out.
The timer is always reset. To stop the timer call [TurnOff()](@ref). Make sure to call [Reset()](@ref) also in derived [Notify()](@ref) so timers will keep working repeatedly.
""" Notify(this::ByRef1{TTimer})

# Wrapper of void TTimer::Remove()
@trydoc raw"""
    Remove(this::ByRef1{TTimer})::Nothing


""" Remove(this::ByRef1{TTimer})

# Wrapper of void TTimer::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TTimer})::Nothing
Reset the timer.

""" Reset(this::ByRef1{TTimer})

# Wrapper of void TTimer::SetCommand(const char *)
@trydoc raw"""
    SetCommand(this::ByRef1{TTimer}, command::ByCopy{String})::Nothing
Set the interpreter command to be executed at time out.
Removes the object to be notified (if it was set).
""" SetCommand(this::ByRef1{TTimer}, command::ByCopy{String})

# Wrapper of void TTimer::SetInterruptSyscalls(Bool_t)
@trydoc raw"""
    SetInterruptSyscalls(this::ByRef1{TTimer}, set::Bool)::Nothing
When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel.
This is typically used in case one wants to put a timeout on an I/O operation. By default interrupted syscalls will be restarted.
""" SetInterruptSyscalls(this::ByRef1{TTimer}, set::Bool)

# Wrapper of void TTimer::SetObject(TObject *)
@trydoc raw"""
    SetObject(this::ByRef1{TTimer}, object::ByPtr1{TObject})::Nothing
Set the object to be notified at time out.
Removes the command to be executed (if it was set).
""" SetObject(this::ByRef1{TTimer}, object::ByPtr1{TObject})

# Wrapper of void TTimer::SetTime(Long_t)
@trydoc raw"""
    SetTime(this::ByRef1{TTimer}, milliSec::Int64)::Nothing


""" SetTime(this::ByRef1{TTimer}, milliSec::Int64)

# Wrapper of void TTimer::SetTimerID(UInt_t)
@trydoc raw"""
    SetTimerID(this::ByRef1{TTimer}, id::UInt32)::Nothing


""" SetTimerID(this::ByRef1{TTimer}, id::UInt32)

# Wrapper of void TTimer::Start(Long_t, Bool_t)
@trydoc raw"""
    Start(this::ByRef1{TTimer}, milliSec::Int64, singleShot::Bool)::Nothing
Starts the timer with a milliSec timeout.
If milliSec is 0 then the timeout will be the minimum timeout (see TSystem!ESysConstants, i.e. 10 ms), if milliSec is -1 then the time interval as previously specified (in ctor or [SetTime()](@ref)) will be used. If singleShot is kTRUE, the timer will be activated only once, otherwise it will continue until it is stopped. See also [TurnOn()](@ref), [Stop()](@ref), [TurnOff()](@ref).
""" Start(this::ByRef1{TTimer}, milliSec::Int64, singleShot::Bool)

# Wrapper of void TTimer::Stop()
@trydoc raw"""
    Stop(this::ByRef1{TTimer})::Nothing


""" Stop(this::ByRef1{TTimer})

# Wrapper of void TTimer::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TTimer}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TTimer}, ::ByRef1{TBuffer})

# Wrapper of void TTimer::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TTimer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TTimer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TTimer::Timeout()
@trydoc raw"""
    Timeout(this::ByRef1{TTimer})::Nothing


""" Timeout(this::ByRef1{TTimer})

# Wrapper of void TTimer::TurnOff()
@trydoc raw"""
    TurnOff(this::ByRef1{TTimer})::Nothing
Remove timer from system timer list.
This requires that a timer has been placed in the system timer list (using [TurnOn()](@ref)). If a [TTimer](@ref) subclass is placed on another list, override [TurnOff()](@ref) to remove the timer from the correct list.
""" TurnOff(this::ByRef1{TTimer})

# Wrapper of void TTimer::TurnOn()
@trydoc raw"""
    TurnOn(this::ByRef1{TTimer})::Nothing
Add the timer to the system timer list.
If a [TTimer](@ref) subclass has to be placed on another list, override [TurnOn()](@ref) to add the timer to the correct list.
""" TurnOn(this::ByRef1{TTimer})

# Wrapper of Bool_t TProcessEventTimer::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TProcessEventTimer})::Bool
This method must be overridden to handle object notification (the base implementation is no-op).
Different objects in [ROOT](@ref) use the `Notify` method for different purposes, in coordination with other objects that call this method at the appropriate time.

For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a callback mechanism to inform interested parties when it switches to a new sub-tree.
""" Notify(this::ByRef1{TProcessEventTimer})

# Wrapper of Bool_t TProcessEventTimer::ProcessEvents()
@trydoc raw"""
    ProcessEvents(this::ByRef1{TProcessEventTimer})::Bool
Process events if timer did time out.
Returns kTRUE if interrupt flag is set (by hitting a key in the canvas or selecting the Interrupt menu item in canvas or some other action).
""" ProcessEvents(this::ByRef1{TProcessEventTimer})

# Wrapper of void TProcessEventTimer::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TProcessEventTimer}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TProcessEventTimer}, ::ByRef1{TBuffer})

# Wrapper of void TProcessEventTimer::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TProcessEventTimer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TProcessEventTimer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TSystem::Abort(int)
@trydoc raw"""
    Abort(this::ByRef1{TSystem}, code::Int32)::Nothing
Abort the application.

""" Abort(this::ByRef1{TSystem}, code::Int32)

# Wrapper of int TSystem::AcceptConnection(int)
@trydoc raw"""
    AcceptConnection(this::ByRef1{TSystem}, sock::Int32)::Int32
Accept a connection.

""" AcceptConnection(this::ByRef1{TSystem}, sock::Int32)

# Wrapper of Bool_t TSystem::AccessPathName(const char *, EAccessMode)
@trydoc raw"""
    AccessPathName(this::ByRef1{TSystem}, path::ByCopy{String}, mode::ByCopy{EAccessMode})::Bool
Returns FALSE if one can access a file using the specified access mode.
The file name must not contain any special shell characters line ~ or $, in those cases first call [ExpandPathName()](@ref). Attention, bizarre convention of return value!!
""" AccessPathName(this::ByRef1{TSystem}, path::ByCopy{String}, mode::ByCopy{EAccessMode})

# Wrapper of void TSystem::AddDynamicPath(const char *)
@trydoc raw"""
    AddDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})::Nothing
Add a new directory to the dynamic path.

""" AddDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::AddFileHandler(TFileHandler *)
@trydoc raw"""
    AddFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})::Nothing
Add a file handler to the list of system file handlers.
Only adds the handler if it is not already in the list of file handlers.
""" AddFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})

# Wrapper of void TSystem::AddIncludePath(const char *)
@trydoc raw"""
    AddIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})::Nothing
Add a directory to the already set include path.
## Arguments

- **`includePath`** [in] 
    The path to the directory. 
    

###Note

This interface is mostly relevant for ACLiC and it does not inform gInterpreter for this include path. If the TInterpreter needs to know about the include path please use TInterpreter!AddIncludePath() . 

###Warning

The path should thestart with the -I prefix, i.e. gSystem->AddIncludePath("-I /path/to/my/includes").
""" AddIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})

# Wrapper of void TSystem::AddLinkedLibs(const char *)
@trydoc raw"""
    AddLinkedLibs(this::ByRef1{TSystem}, linkedLib::ByCopy{String})::Nothing
Add linkedLib to already set linked libs.

""" AddLinkedLibs(this::ByRef1{TSystem}, linkedLib::ByCopy{String})

# Wrapper of void TSystem::AddSignalHandler(TSignalHandler *)
@trydoc raw"""
    AddSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})::Nothing
Add a signal handler to list of system signal handlers.
Only adds the handler if it is not already in the list of signal handlers.
""" AddSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})

# Wrapper of void TSystem::AddStdExceptionHandler(TStdExceptionHandler *)
@trydoc raw"""
    AddStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})::Nothing
Add an exception handler to list of system exception handlers.
Only adds the handler if it is not already in the list of exception handlers.
""" AddStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})

# Wrapper of void TSystem::AddTimer(TTimer *)
@trydoc raw"""
    AddTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})::Nothing
Add timer to list of system timers.

""" AddTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})

# Wrapper of int TSystem::AnnounceTcpService(int, Bool_t, int, int)
@trydoc raw"""
    AnnounceTcpService(this::ByRef1{TSystem}, port::Int32, reuse::Bool, backlog::Int32, tcpwindowsize::Int32)::Int32
Announce TCP/IP service.

""" AnnounceTcpService(this::ByRef1{TSystem}, port::Int32, reuse::Bool, backlog::Int32, tcpwindowsize::Int32)

# Wrapper of int TSystem::AnnounceUdpService(int, int)
@trydoc raw"""
    AnnounceUdpService(this::ByRef1{TSystem}, port::Int32, backlog::Int32)::Int32
Announce UDP service.

""" AnnounceUdpService(this::ByRef1{TSystem}, port::Int32, backlog::Int32)

# Wrapper of int TSystem::AnnounceUnixService(const char *, int)
@trydoc raw"""
    AnnounceUnixService(this::ByRef1{TSystem}, sockpath::ByCopy{String}, backlog::Int32)::Int32
Announce unix domain service.

""" AnnounceUnixService(this::ByRef1{TSystem}, sockpath::ByCopy{String}, backlog::Int32)

# Wrapper of int TSystem::AnnounceUnixService(int, int)
@trydoc raw"""
    AnnounceUnixService(this::ByRef1{TSystem}, port::Int32, backlog::Int32)::Int32
Announce unix domain service.

""" AnnounceUnixService(this::ByRef1{TSystem}, port::Int32, backlog::Int32)

# Wrapper of const char * TSystem::BaseName(const char *)
@trydoc raw"""
    BaseName(this::ByRef1{TSystem}, pathname::ByCopy{String})::ByCopy{String}
Base name of a file name. Base name of /user/root is root.

""" BaseName(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::Beep(Int_t, Int_t, Bool_t)
@trydoc raw"""
    Beep(this::ByRef1{TSystem}, freq::Int32, duration::Int32, setDefault::Bool)::Nothing
Beep for duration milliseconds with a tone of frequency freq.
Defaults to printing the `\a` character to stdout. If freq or duration is <0 respectively, use default value. If setDefault is set, only set the frequency and duration as new defaults, but don't beep. If default freq or duration is <0, never beep (silence)
""" Beep(this::ByRef1{TSystem}, freq::Int32, duration::Int32, setDefault::Bool)

# Wrapper of Bool_t TSystem::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TSystem}, path::ByCopy{String})::Bool


""" cd(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of Bool_t TSystem::ChangeDirectory(const char *)
@trydoc raw"""
    ChangeDirectory(this::ByRef1{TSystem}, path::ByCopy{String})::Bool
Change directory.

""" ChangeDirectory(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of int TSystem::Chmod(const char *, UInt_t)
@trydoc raw"""
    Chmod(this::ByRef1{TSystem}, file::ByCopy{String}, mode::UInt32)::Int32
Set the file permission bits. Returns -1 in case or error, 0 otherwise.

""" Chmod(this::ByRef1{TSystem}, file::ByCopy{String}, mode::UInt32)

# Wrapper of void TSystem::CleanCompiledMacros()
@trydoc raw"""
    CleanCompiledMacros(this::ByRef1{TSystem})::Nothing
Remove the shared libs produced by the [CompileMacro()](@ref) function, together with their rootmaps, linkdefs, and pcms (and some more on Windows).

""" CleanCompiledMacros(this::ByRef1{TSystem})

# Wrapper of void TSystem::CloseConnection(int, Bool_t)
@trydoc raw"""
    CloseConnection(this::ByRef1{TSystem}, sock::Int32, force::Bool)::Nothing
Close socket connection.

""" CloseConnection(this::ByRef1{TSystem}, sock::Int32, force::Bool)

# Wrapper of void TSystem::Closelog()
@trydoc raw"""
    Closelog(this::ByRef1{TSystem})::Nothing
Close connection to system log daemon.

""" Closelog(this::ByRef1{TSystem})

# Wrapper of int TSystem::ClosePipe(FILE *)
@trydoc raw"""
    ClosePipe(this::ByRef1{TSystem}, pipe::ByPtr1{FILE})::Int32
Close the pipe.

""" ClosePipe(this::ByRef1{TSystem}, pipe::ByPtr1{FILE})

# Wrapper of int TSystem::CompileMacro(const char *, Option_t *, const char *, const char *, UInt_t)
@trydoc raw"""
    CompileMacro(this::ByRef1{TSystem}, filename::ByCopy{String}, opt::ByCopy{String}, library_name::ByCopy{String}, build_dir::ByCopy{String}, dirmode::UInt32)::Int32
This method compiles and loads a shared library containing the code from the file "filename".
The return value is true (1) in case of success and false (0) in case of error.

The possible options are:

- k : keep the shared library after the session theend.
- f : force recompilation.
- g : compile with debug symbol
- O : optimized the code
- c : compile only, do not attempt to load the library.
- s : silence all informational output
- v : output all information output
- d : debug ACLiC, keep all the output files.
- - : if buildir is set, use a flat structure (see buildir below)

If library_specified is specified, CompileMacro generates the file "library_specified".soext where soext is the shared library extension for the current platform.

If build_dir is specified, it is used as an alternative 'root' for the generation of the shared library. The library is stored in a sub-directories of 'build_dir' including the full pathname of the script unless a flat directory structure is requested ('-' option). With the '-' option the libraries are created directly in the directory 'build_dir'; in particular this means that 2 scripts with the same name in different source directory will over-write each other's library. See also [TSystem!SetBuildDir](@ref).

If dirmode is not zero and we need to create the target directory, the file mode bit will be change to 'dirmode' using chmod.

If library_specified is not specified, CompileMacro generate a default name for library by taking the name of the file "filename" but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platform, hsimple.cxx will generate hsimple_cxx.so

It uses the directive fMakeSharedLibs to create a shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to [TSystem!Exec](@ref), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $DepLibs, $ExeName and $ObjectFiles. See [SetMakeSharedLib()](@ref) for more information on those variables.

This method is used to implement the following feature:

Synopsis:

The purpose of this addition is to allow the user to use an external compiler to create a shared library from its C++ macro (scripts). Currently in order to execute a script, a user has to type at the root prompt 

    .X myfunc.C(arg1,arg2)

(C++ version of the code)

 We allow them to type: 

    .X myfunc.C++(arg1,arg2)

(C++ version of the code)

 or 

    .X myfunc.C+(arg1,arg2)

(C++ version of the code)

 In which case an external compiler will be called to create a shared library. This shared library will then be loaded and the function myfunc will be called with the two arguments. With '++' the shared library is always recompiled. With '+' the shared library is recompiled only if it does not exist yet or the macro file is newer than the shared library.

Of course the + and ++ notation is supported in similar way for .x and .L.

Through the function [TSystem!SetMakeSharedLib()](@ref), the user will be able to indicate, with shell commands, how to build a shared library (a good default will be provided). The most common change, namely where to find header files, will be available through the function [TSystem!SetIncludePath()](@ref). A good default will be provided so that a typical user session should be at most: 

    root[1] gSystem->SetIncludePath("-I$ROOTSYS/include
    -I$HOME/mypackage/include");
    root[2] .x myfunc.C++(10,20);

(C++ version of the code)

 The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.

To support this we provide a [TSystem!SetMakeExe()](@ref) function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and [TSystem!Load()](@ref) is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to [TSystem!SetLinkedLibs()](@ref)).

To simplify customization we could also add to the .rootrc support for the variables 

    Unix.*.Root.IncludePath:     -I$ROOTSYS/include
    WinNT.*.Root.IncludePath:    -I%ROOTSYS%/include
    Unix.*.Root.LinkedLibs:      -L$ROOTSYS/lib -lBase ....
    WinNT.*.Root.LinkedLibs:     %ROOTSYS%/lib/*.lib msvcrt.lib ....

(C++ version of the code)

 And also support for MakeSharedLibs() and MakeExe().

(the ... have to be replaced by the actual values and are here only to shorten this comment).

Note that the default behavior is to remove libraries when closing [ROOT](@ref), ie [TSystem!CleanCompiledMacros()](@ref) is called in the [TROOT](@ref) destructor. The default behavior of .L script.C+ is the opposite one, leaving things after closing, without removing. In other words, .L always passes the 'k' option behind the scenes.
""" CompileMacro(this::ByRef1{TSystem}, filename::ByCopy{String}, opt::ByCopy{String}, library_name::ByCopy{String}, build_dir::ByCopy{String}, dirmode::UInt32)

# Wrapper of char * TSystem::ConcatFileName(const char *, const char *)
@trydoc raw"""
    ConcatFileName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByCopy{String})::ByCopy{Union{String, Vector{CxxChar}}}
Concatenate a directory and a file name. User must delete returned string.

""" ConcatFileName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByCopy{String})

# Wrapper of int TSystem::CopyFile(const char *, const char *, Bool_t)
@trydoc raw"""
    CopyFile(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String}, overwrite::Bool)::Int32
Copy a file.
If overwrite is true and file already exists the file will be overwritten. Returns 0 when successful, -1 in case of file open failure, -2 in case the file already exists and overwrite was false and -3 in case of error during copy.
""" CopyFile(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String}, overwrite::Bool)

# Wrapper of const char * TSystem::DirName(const char *)
@trydoc raw"""
    DirName(this::ByRef1{TSystem}, pathname::ByCopy{String})::ByCopy{String}
Return the directory name in pathname.
DirName of /user/root is /user. In case no dirname is specified "." is returned.
""" DirName(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::DispatchOneEvent(Bool_t)
@trydoc raw"""
    DispatchOneEvent(this::ByRef1{TSystem}, pendingOnly::Bool)::Nothing
Dispatch a single event.

""" DispatchOneEvent(this::ByRef1{TSystem}, pendingOnly::Bool)

# Wrapper of char * TSystem::DynamicPathName(const char *, Bool_t)
@trydoc raw"""
    DynamicPathName(this::ByRef1{TSystem}, lib::ByCopy{String}, quiet::Bool)::ByCopy{Union{String, Vector{CxxChar}}}
Find a dynamic library called lib using the system search paths.
Appends known extensions if needed. Returned string must be deleted by the user!
""" DynamicPathName(this::ByRef1{TSystem}, lib::ByCopy{String}, quiet::Bool)

# Wrapper of Int_t TSystem::Exec(const char *)
@trydoc raw"""
    Exec(this::ByRef1{TSystem}, shellcmd::ByCopy{String})::Int32
Execute a command.

""" Exec(this::ByRef1{TSystem}, shellcmd::ByCopy{String})

# Wrapper of void TSystem::Exit(int, Bool_t)
@trydoc raw"""
    Exit(this::ByRef1{TSystem}, code::Int32, mode::Bool)::Nothing
Exit the application.

""" Exit(this::ByRef1{TSystem}, code::Int32, mode::Bool)

# Wrapper of void TSystem::ExitLoop()
@trydoc raw"""
    ExitLoop(this::ByRef1{TSystem})::Nothing
Exit from event loop.

""" ExitLoop(this::ByRef1{TSystem})

# Wrapper of char * TSystem::ExpandPathName(const char *)
@trydoc raw"""
    ExpandPathName(this::ByRef1{TSystem}, path::ByCopy{String})::ByCopy{Union{String, Vector{CxxChar}}}
Expand a pathname getting rid of special shell characters like ~.
$, etc. For Unix/Win32 compatibility use  instead of $XXX when using environment variables in a pathname. If compatibility is not an issue you can use on Unix directly $XXX. The user must delete returned string.
""" ExpandPathName(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of Bool_t TSystem::ExpandPathName(TString &)
@trydoc raw"""
    ExpandPathName(this::ByRef1{TSystem}, path::ByRef1{TString})::Bool
Expand a pathname getting rid of special shell characters like ~.
$, etc. For Unix/Win32 compatibility use  instead of $XXX when using environment variables in a pathname. If compatibility is not an issue you can use on Unix directly $XXX.
""" ExpandPathName(this::ByRef1{TSystem}, path::ByRef1{TString})

# Wrapper of const char * TSystem::FindDynamicLibrary(TString &, Bool_t)
@trydoc raw"""
    FindDynamicLibrary(this::ByRef1{TSystem}, lib::ByRef1{TString}, quiet::Bool)::ByCopy{String}
Find a dynamic library using the system search paths.
lib will be updated to contain the absolute filename if found. Returns lib if found, or NULL if a library called lib was not found. This function does not open the library.
""" FindDynamicLibrary(this::ByRef1{TSystem}, lib::ByRef1{TString}, quiet::Bool)

# Wrapper of const char * TSystem::FindFile(const char *, TString &, EAccessMode)
@trydoc raw"""
    FindFile(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByRef1{TString}, mode::ByCopy{EAccessMode})::ByCopy{String}
Find location of file in a search path.
Return value points to [TString](@ref) for compatibility with [Which(const char *, const char *, EAccessMode)](@ref). Returns 0 in case file is not found.
""" FindFile(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByRef1{TString}, mode::ByCopy{EAccessMode})

# Wrapper of void TSystem::FreeDirectory(void *)
@trydoc raw"""
    FreeDirectory(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})::Nothing
Free a directory.

""" FreeDirectory(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})

# Wrapper of Int_t TSystem::GetCryptoRandom(void *, Int_t)
@trydoc raw"""
    GetCryptoRandom(this::ByRef1{TSystem}, buf::ByPtr2{Nothing}, len::Int32)::Int32
Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error.

""" GetCryptoRandom(this::ByRef1{TSystem}, buf::ByPtr2{Nothing}, len::Int32)

# Wrapper of const char * TSystem::GetDirEntry(void *)
@trydoc raw"""
    GetDirEntry(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})::ByCopy{String}
Get a directory entry. Returns 0 if no more entries.

""" GetDirEntry(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})

# Wrapper of TString TSystem::GetDirName(const char *)
@trydoc raw"""
    GetDirName(this::ByRef1{TSystem}, pathname::ByCopy{String})::ByCopy{TString}
Return the directory name in pathname.
DirName of /user/root is /user. DirName of /user/root/ is also /user. In case no dirname is specified "." is returned.
""" GetDirName(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of const char * TSystem::GetDynamicPath()
@trydoc raw"""
    GetDynamicPath(this::ByRef1{TSystem})::ByCopy{String}
Return the dynamic path (used to find shared libraries).

""" GetDynamicPath(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::GetEffectiveGid()
@trydoc raw"""
    GetEffectiveGid(this::ByRef1{TSystem})::Int32
Returns the effective group id.
The effective group id corresponds to the set id bit on the file being executed.
""" GetEffectiveGid(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::GetEffectiveUid()
@trydoc raw"""
    GetEffectiveUid(this::ByRef1{TSystem})::Int32
Returns the effective user id.
The effective id corresponds to the set id bit on the file being executed.
""" GetEffectiveUid(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::Getenv(const char *)
@trydoc raw"""
    Getenv(this::ByRef1{TSystem}, env::ByCopy{String})::ByCopy{String}
Get environment variable.

""" Getenv(this::ByRef1{TSystem}, env::ByCopy{String})

# Wrapper of const char * TSystem::GetError()
@trydoc raw"""
    GetError(this::ByRef1{TSystem})::ByCopy{String}
Return system error string.

""" GetError(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::GetFPEMask()
@trydoc raw"""
    GetFPEMask(this::ByRef1{TSystem})::Int32
Return the bitmap of conditions that trigger a floating point exception.

""" GetFPEMask(this::ByRef1{TSystem})

# Wrapper of TString TSystem::GetFromPipe(const char *)
@trydoc raw"""
    GetFromPipe(this::ByRef1{TSystem}, command::ByCopy{String})::ByCopy{TString}
Execute command and return output in [TString](@ref).

""" GetFromPipe(this::ByRef1{TSystem}, command::ByCopy{String})

# Wrapper of int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *)
@trydoc raw"""
    GetFsInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, bsize::ByPtr2{Int64}, blocks::ByPtr2{Int64}, bfree::ByPtr2{Int64})::Int32
Get info about a file system: fs type, block size, number of blocks, number of free blocks.

""" GetFsInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, bsize::ByPtr2{Int64}, blocks::ByPtr2{Int64}, bfree::ByPtr2{Int64})

# Wrapper of Int_t TSystem::GetGid(const char *)
@trydoc raw"""
    GetGid(this::ByRef1{TSystem}, group::ByCopy{String})::Int32
Returns the group's id. If group = 0, returns current user's group.

""" GetGid(this::ByRef1{TSystem}, group::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetGroupInfo(const char *)
@trydoc raw"""
    GetGroupInfo(this::ByRef1{TSystem}, group::ByCopy{String})::CxxPtr1{UserGroup_t}
Returns all group info in the [UserGroup_t](@ref) structure.
The only active fields in the [UserGroup_t](@ref) structure for this call are:

- fGid and fGroup If group = 0, returns current user's group. The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetGroupInfo(this::ByRef1{TSystem}, group::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetGroupInfo(Int_t)
@trydoc raw"""
    GetGroupInfo(this::ByRef1{TSystem}, gid::Int32)::CxxPtr1{UserGroup_t}
Returns all group info in the [UserGroup_t](@ref) structure.
The only active fields in the [UserGroup_t](@ref) structure for this call are:

- fGid and fGroup The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetGroupInfo(this::ByRef1{TSystem}, gid::Int32)

# Wrapper of TInetAddress TSystem::GetHostByName(const char *)
@trydoc raw"""
    GetHostByName(this::ByRef1{TSystem}, server::ByCopy{String})::ByCopy{TInetAddress}
Get Internet Protocol (IP) address of host.

""" GetHostByName(this::ByRef1{TSystem}, server::ByCopy{String})

# Wrapper of const char * TSystem::GetIncludePath()
@trydoc raw"""
    GetIncludePath(this::ByRef1{TSystem})::ByCopy{String}
Get the list of include path.

""" GetIncludePath(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::GetLibraries(const char *, const char *, Bool_t)
@trydoc raw"""
    GetLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String}, option::ByCopy{String}, isRegexp::Bool)::ByCopy{String}
Return a space separated list of loaded shared libraries.
Regexp is a wildcard expression, see TRegexp!MakeWildcard. This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of:

- S: shared libraries loaded at the thestart of the executable, because they were specified on the link line.
- D: shared libraries dynamically loaded after the thestart of the program.
- L: this option is ignored, and available for backward compatibility.
""" GetLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String}, option::ByCopy{String}, isRegexp::Bool)

# Wrapper of int TSystem::GetPathInfo(const char *, FileStat_t &)
@trydoc raw"""
    GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, buf::ByRef1{FileStat_t})::Int32
Get info about a file.
Info is returned in the form of a [FileStat_t](@ref) structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed.
""" GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, buf::ByRef1{FileStat_t})

# Wrapper of int TSystem::GetPathInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *)
@trydoc raw"""
    GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, size::ByPtr2{Int64}, flags::ByPtr2{Int64}, modtime::ByPtr2{Int64})::Int32
Get info about a file: id, size, flags, modification time.
- Id is (statbuf.st_dev << 24) + statbuf.st_ino
- Size is the file size
- Flags is file type: 0 is regular file, bit 0 set executable, bit 1 set directory, bit 2 set special file (socket, fifo, pipe, etc.) Modtime is modification time. The function returns 0 in case of success and 1 if the file could not be stat'ed.
""" GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, size::ByPtr2{Int64}, flags::ByPtr2{Int64}, modtime::ByPtr2{Int64})

# Wrapper of TInetAddress TSystem::GetPeerName(int)
@trydoc raw"""
    GetPeerName(this::ByRef1{TSystem}, sock::Int32)::ByCopy{TInetAddress}
Get Internet Protocol (IP) address of remote host and port #.

""" GetPeerName(this::ByRef1{TSystem}, sock::Int32)

# Wrapper of int TSystem::GetPid()
@trydoc raw"""
    GetPid(this::ByRef1{TSystem})::Int32
Get process id.

""" GetPid(this::ByRef1{TSystem})

# Wrapper of int TSystem::GetServiceByName(const char *)
@trydoc raw"""
    GetServiceByName(this::ByRef1{TSystem}, service::ByCopy{String})::Int32
Get port # of internet service.

""" GetServiceByName(this::ByRef1{TSystem}, service::ByCopy{String})

# Wrapper of char * TSystem::GetServiceByPort(int)
@trydoc raw"""
    GetServiceByPort(this::ByRef1{TSystem}, port::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Get name of internet service.

""" GetServiceByPort(this::ByRef1{TSystem}, port::Int32)

# Wrapper of TInetAddress TSystem::GetSockName(int)
@trydoc raw"""
    GetSockName(this::ByRef1{TSystem}, sock::Int32)::ByCopy{TInetAddress}
Get Internet Protocol (IP) address of host and port #.

""" GetSockName(this::ByRef1{TSystem}, sock::Int32)

# Wrapper of int TSystem::GetSockOpt(int, int, int *)
@trydoc raw"""
    GetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::ByPtr2{Int32})::Int32
Get socket option.

""" GetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::ByPtr2{Int32})

# Wrapper of Int_t TSystem::GetUid(const char *)
@trydoc raw"""
    GetUid(this::ByRef1{TSystem}, user::ByCopy{String})::Int32
Returns the user's id. If user = 0, returns current user's id.

""" GetUid(this::ByRef1{TSystem}, user::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetUserInfo(const char *)
@trydoc raw"""
    GetUserInfo(this::ByRef1{TSystem}, user::ByCopy{String})::CxxPtr1{UserGroup_t}
Returns all user info in the [UserGroup_t](@ref) structure.
If user = 0, returns current user's id info. The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetUserInfo(this::ByRef1{TSystem}, user::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetUserInfo(Int_t)
@trydoc raw"""
    GetUserInfo(this::ByRef1{TSystem}, uid::Int32)::CxxPtr1{UserGroup_t}
Returns all user info in the [UserGroup_t](@ref) structure.
The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetUserInfo(this::ByRef1{TSystem}, uid::Int32)

# Wrapper of const char * TSystem::HomeDirectory(const char *)
@trydoc raw"""
    HomeDirectory(this::ByRef1{TSystem}, userName::ByCopy{String})::ByCopy{String}
Return the user's home directory.

""" HomeDirectory(this::ByRef1{TSystem}, userName::ByCopy{String})

# Wrapper of const char * TSystem::HostName()
@trydoc raw"""
    HostName(this::ByRef1{TSystem})::ByCopy{String}
Return the system's host name.

""" HostName(this::ByRef1{TSystem})

# Wrapper of void TSystem::IgnoreInterrupt(Bool_t)
@trydoc raw"""
    IgnoreInterrupt(this::ByRef1{TSystem}, ignore::Bool)::Nothing
If ignore is true ignore the interrupt signal, else restore previous behaviour.
Typically call ignore interrupt before writing to disk.
""" IgnoreInterrupt(this::ByRef1{TSystem}, ignore::Bool)

# Wrapper of void TSystem::IgnoreSignal(ESignals, Bool_t)
@trydoc raw"""
    IgnoreSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, ignore::Bool)::Nothing
If ignore is true ignore the specified signal, else restore previous behaviour.

""" IgnoreSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, ignore::Bool)

# Wrapper of Bool_t TSystem::Init()
@trydoc raw"""
    Init(this::ByRef1{TSystem})::Bool
Initialize the OS interface.

""" Init(this::ByRef1{TSystem})

# Wrapper of void TSystem::InnerLoop()
@trydoc raw"""
    InnerLoop(this::ByRef1{TSystem})::Nothing
Inner event loop.

""" InnerLoop(this::ByRef1{TSystem})

# Wrapper of Bool_t TSystem::IsAbsoluteFileName(const char *)
@trydoc raw"""
    IsAbsoluteFileName(this::ByRef1{TSystem}, dir::ByCopy{String})::Bool
Return true if dir is an absolute pathname.

""" IsAbsoluteFileName(this::ByRef1{TSystem}, dir::ByCopy{String})

# Wrapper of Bool_t TSystem::IsFileInIncludePath(const char *, char **)
@trydoc raw"""
    IsFileInIncludePath(this::ByRef1{TSystem}, name::ByCopy{String}, fullpath::ByPtr2{Int8})::Bool
Return true if 'name' is a file that can be found in the [ROOT](@ref) include path or the current directory.
If 'name' contains any ACLiC style information (e.g. trailing +[+][g|O]), it will be striped off 'name'. If fullpath is != 0, the full path to the file is returned in *fullpath, which must be deleted by the caller.
""" IsFileInIncludePath(this::ByRef1{TSystem}, name::ByCopy{String}, fullpath::ByPtr2{Int8})

# Wrapper of Bool_t TSystem::IsPathLocal(const char *)
@trydoc raw"""
    IsPathLocal(this::ByRef1{TSystem}, path::ByCopy{String})::Bool
Returns TRUE if the url in 'path' points to the local_ file system.
This is used to avoid going through the NIC card for local_ operations.
""" IsPathLocal(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of int TSystem::Link(const char *, const char *)
@trydoc raw"""
    Link(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})::Int32
Create a link from file1 to file2.

""" Link(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})

# Wrapper of void TSystem::ListLibraries(const char *)
@trydoc raw"""
    ListLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String})::Nothing
List the loaded shared libraries.
`regexp` is a regular expression allowing to filter the list.

Examples:

The following line lists all the libraries currently loaded: 

    gSystem->ListLibraries()

(C++ version of the code)

The following line lists all the libraries currently loaded having "RIO" in their names: 

    gSystem->ListLibraries(".*RIO.*")

(C++ version of the code)
""" ListLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String})

# Wrapper of void TSystem::ListSymbols(const char *, const char *)
@trydoc raw"""
    ListSymbols(this::ByRef1{TSystem}, themodule::ByCopy{String}, re::ByCopy{String})::Nothing
List symbols in a shared library.

""" ListSymbols(this::ByRef1{TSystem}, themodule::ByCopy{String}, re::ByCopy{String})

# Wrapper of int TSystem::Load(const char *, const char *, Bool_t)
@trydoc raw"""
    Load(this::ByRef1{TSystem}, themodule::ByCopy{String}, entry::ByCopy{String}, system::Bool)::Int32
Load a shared library.
Returns 0 on successful loading, 1 in case lib was already loaded, -1 in case lib does not exist or in case of error and -2 in case of version mismatch. When entry is specified the loaded lib is searched for this entry point (return -1 when entry does not exist, 0 otherwise). When the system flag is kTRUE, the library is considered a permanent system library that should not be unloaded during the course of the session.
""" Load(this::ByRef1{TSystem}, themodule::ByCopy{String}, entry::ByCopy{String}, system::Bool)

# Wrapper of UInt_t TSystem::LoadAllLibraries()
@trydoc raw"""
    LoadAllLibraries(this::ByRef1{TSystem})::UInt32
Load all libraries known to [ROOT](@ref) via the rootmap system.
Returns the number of top level libraries successfully loaded.
""" LoadAllLibraries(this::ByRef1{TSystem})

# Wrapper of int TSystem::MakeDirectory(const char *)
@trydoc raw"""
    MakeDirectory(this::ByRef1{TSystem}, name::ByCopy{String})::Int32
Make a directory.
Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name).
""" MakeDirectory(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of int TSystem::mkdir(const char *, Bool_t)
@trydoc raw"""
    mkdir(this::ByRef1{TSystem}, name::ByCopy{String}, recursive::Bool)::Int32
Make a file system directory.
Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). If 'recursive' is true, makes parent directories as needed.
""" mkdir(this::ByRef1{TSystem}, name::ByCopy{String}, recursive::Bool)

# Wrapper of Long_t TSystem::NextTimeOut(Bool_t)
@trydoc raw"""
    NextTimeOut(this::ByRef1{TSystem}, mode::Bool)::Int64
Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).

""" NextTimeOut(this::ByRef1{TSystem}, mode::Bool)

# Wrapper of void TSystem::NotifyApplicationCreated()
@trydoc raw"""
    NotifyApplicationCreated(this::ByRef1{TSystem})::Nothing
Hook to tell [TSystem](@ref) that the [TApplication](@ref) object has been created.

""" NotifyApplicationCreated(this::ByRef1{TSystem})

# Wrapper of TTime TSystem::Now()
@trydoc raw"""
    Now(this::ByRef1{TSystem})::ByCopy{TTime}
Get current time in milliseconds since 0:00 Jan 1 1995.

""" Now(this::ByRef1{TSystem})

# Wrapper of int TSystem::OpenConnection(const char *, int, int, const char *)
@trydoc raw"""
    OpenConnection(this::ByRef1{TSystem}, server::ByCopy{String}, port::Int32, tcpwindowsize::Int32, protocol::ByCopy{String})::Int32
Open a connection to another host.

""" OpenConnection(this::ByRef1{TSystem}, server::ByCopy{String}, port::Int32, tcpwindowsize::Int32, protocol::ByCopy{String})

# Wrapper of void * TSystem::OpenDirectory(const char *)
@trydoc raw"""
    OpenDirectory(this::ByRef1{TSystem}, name::ByCopy{String})::CxxPtr2{Nothing}
Open a directory. Returns 0 if directory does not exist.

""" OpenDirectory(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of void TSystem::Openlog(const char *, Int_t, ELogFacility)
@trydoc raw"""
    Openlog(this::ByRef1{TSystem}, name::ByCopy{String}, options::Int32, facility::ByCopy{ELogFacility})::Nothing
Open connection to system log daemon.
For the use of the options and facility see the Unix openlog man page.
""" Openlog(this::ByRef1{TSystem}, name::ByCopy{String}, options::Int32, facility::ByCopy{ELogFacility})

# Wrapper of FILE * TSystem::OpenPipe(const char *, const char *)
@trydoc raw"""
    OpenPipe(this::ByRef1{TSystem}, command::ByCopy{String}, mode::ByCopy{String})::CxxPtr1{FILE}
Open a pipe.

""" OpenPipe(this::ByRef1{TSystem}, command::ByCopy{String}, mode::ByCopy{String})

# Wrapper of const char * TSystem::PrependPathName(const char *, TString &)
@trydoc raw"""
    PrependPathName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByRef1{TString})::ByCopy{String}
Concatenate a directory and a file name.

""" PrependPathName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByRef1{TString})

# Wrapper of Bool_t TSystem::ProcessEvents()
@trydoc raw"""
    ProcessEvents(this::ByRef1{TSystem})::Bool
Process pending events (GUI, timers, sockets).
Returns the result of [TROOT!IsInterrupted()](@ref). The interrupt flag ([TROOT!SetInterrupt()](@ref)) can be set during the handling of the events. This mechanism allows macros running in tight calculating loops to be interrupted by some GUI event (depending on the interval with which this method is called). For example hitting ctrl-c in a canvas will set the interrupt flag.
""" ProcessEvents(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::pwd()
@trydoc raw"""
    pwd(this::ByRef1{TSystem})::ByCopy{String}


""" pwd(this::ByRef1{TSystem})

# Wrapper of int TSystem::RecvBuf(int, void *, int)
@trydoc raw"""
    RecvBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32)::Int32
Receive a buffer headed by a length indicator.

""" RecvBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32)

# Wrapper of int TSystem::RecvRaw(int, void *, int, int)
@trydoc raw"""
    RecvRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32, flag::Int32)::Int32
Receive exactly length bytes into buffer.
Use opt to receive out-of-band data or to have a peek at what is in the buffer (see [TSocket](@ref)).
""" RecvRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32, flag::Int32)

# Wrapper of Int_t TSystem::RedirectOutput(const char *, const char *, RedirectHandle_t *)
@trydoc raw"""
    RedirectOutput(this::ByRef1{TSystem}, name::ByCopy{String}, mode::ByCopy{String}, h::ByPtr1{RedirectHandle_t})::Int32
Redirect standard output (stdout, stderr) to the specified file.
If the file argument is 0 the output is set again to stderr, stdout. The second argument specifies whether the output should be added to the file ("a", default) or the file be truncated before ("w"). The implementations of this function save internally the current state into a static structure.

The call can be made reentrant by specifying the opaque structure pointed by 'h', which is filled with the relevant information. The handle 'h' obtained on the first call must then be used in any subsequent call, included ShowOutput, to display the redirected output. Returns 0 on success, -1 in case of error.
""" RedirectOutput(this::ByRef1{TSystem}, name::ByCopy{String}, mode::ByCopy{String}, h::ByPtr1{RedirectHandle_t})

# Wrapper of TFileHandler * TSystem::RemoveFileHandler(TFileHandler *)
@trydoc raw"""
    RemoveFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})::CxxPtr1{TFileHandler}
Remove a file handler from the list of file handlers.
Returns the handler or 0 if the handler was not in the list of file handlers.
""" RemoveFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})

# Wrapper of void TSystem::RemoveOnExit(TObject *)
@trydoc raw"""
    RemoveOnExit(this::ByRef1{TSystem}, obj::ByPtr1{TObject})::Nothing
Objects that should be deleted on exit of the OS interface.

""" RemoveOnExit(this::ByRef1{TSystem}, obj::ByPtr1{TObject})

# Wrapper of TSignalHandler * TSystem::RemoveSignalHandler(TSignalHandler *)
@trydoc raw"""
    RemoveSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})::CxxPtr1{TSignalHandler}
Remove a signal handler from list of signal handlers.
Returns the handler or 0 if the handler was not in the list of signal handlers.
""" RemoveSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})

# Wrapper of TStdExceptionHandler * TSystem::RemoveStdExceptionHandler(TStdExceptionHandler *)
@trydoc raw"""
    RemoveStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})::CxxPtr1{TStdExceptionHandler}
Remove an exception handler from list of exception handlers.
Returns the handler or 0 if the handler was not in the list of exception handlers.
""" RemoveStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})

# Wrapper of TTimer * TSystem::RemoveTimer(TTimer *)
@trydoc raw"""
    RemoveTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})::CxxPtr1{TTimer}
Remove timer from list of system timers.
Returns removed timer or 0 if timer was not active.
""" RemoveTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})

# Wrapper of int TSystem::Rename(const char *, const char *)
@trydoc raw"""
    Rename(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})::Int32
Rename a file.

""" Rename(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})

# Wrapper of void TSystem::ResetSignal(ESignals, Bool_t)
@trydoc raw"""
    ResetSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, reset::Bool)::Nothing
If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour.

""" ResetSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, reset::Bool)

# Wrapper of void TSystem::ResetSignals()
@trydoc raw"""
    ResetSignals(this::ByRef1{TSystem})::Nothing
Reset signals handlers to previous behaviour.

""" ResetSignals(this::ByRef1{TSystem})

# Wrapper of void TSystem::ResetTimer(TTimer *)
@trydoc raw"""
    ResetTimer(this::ByRef1{TSystem}, ::ByPtr1{TTimer})::Nothing


""" ResetTimer(this::ByRef1{TSystem}, ::ByPtr1{TTimer})

# Wrapper of void TSystem::Run()
@trydoc raw"""
    Run(this::ByRef1{TSystem})::Nothing
System event loop.

""" Run(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::Select(TFileHandler *, Long_t)
@trydoc raw"""
    Select(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler}, timeout::Int64)::Int32
Select on active file descriptors (called by [TMonitor](@ref)).

""" Select(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler}, timeout::Int64)

# Wrapper of Int_t TSystem::Select(TList *, Long_t)
@trydoc raw"""
    Select(this::ByRef1{TSystem}, active::ByPtr1{TList}, timeout::Int64)::Int32
Select on active file descriptors (called by [TMonitor](@ref)).

""" Select(this::ByRef1{TSystem}, active::ByPtr1{TList}, timeout::Int64)

# Wrapper of int TSystem::SendBuf(int, const void *, int)
@trydoc raw"""
    SendBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32)::Int32
Send a buffer headed by a length indicator.

""" SendBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32)

# Wrapper of int TSystem::SendRaw(int, const void *, int, int)
@trydoc raw"""
    SendRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32, flag::Int32)::Int32
Send exactly length bytes from buffer.
Use opt to send out-of-band data (see [TSocket](@ref)).
""" SendRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32, flag::Int32)

# Wrapper of void TSystem::SetBuildDir(const char *, Bool_t)
@trydoc raw"""
    SetBuildDir(this::ByRef1{TSystem}, build_dir::ByCopy{String}, isflat::Bool)::Nothing
Set the location where ACLiC will create libraries and use as a scratch area.
If unset, libraries will be created at the same location than the script.

## Arguments

- **`build_dir`** 
    the name of the build directory 
    
- **`isflat`** 
    If false (default), then the libraries are actually stored in sub-directories of 'build_dir' including the full pathname of the script. If the script is located at `/full/path/name/macro.C` the library will be located at `build_dir+/full/path/name/macro_C.so` If 'isflat' is true, then no subdirectory is created and the library is created directly in the directory 'build_dir'. Note that in this mode there is a risk than 2 script of the same in different source directory will over-write each other. 
    

###Note

This build_dir can also be controlled via ACLiC.BuildDir in your .rootrc.
""" SetBuildDir(this::ByRef1{TSystem}, build_dir::ByCopy{String}, isflat::Bool)

# Wrapper of void TSystem::SetDisplay()
@trydoc raw"""
    SetDisplay(this::ByRef1{TSystem})::Nothing
Set DISPLAY environment variable based on utmp entry. Only for UNIX.

""" SetDisplay(this::ByRef1{TSystem})

# Wrapper of void TSystem::SetDynamicPath(const char *)
@trydoc raw"""
    SetDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})::Nothing
Set the dynamic path to a new value.
If the value of 'path' is zero, the dynamic path is reset to its default value.
""" SetDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::Setenv(const char *, const char *)
@trydoc raw"""
    Setenv(this::ByRef1{TSystem}, name::ByCopy{String}, value::ByCopy{String})::Nothing
Set environment variable.

""" Setenv(this::ByRef1{TSystem}, name::ByCopy{String}, value::ByCopy{String})

# Wrapper of void TSystem::SetErrorStr(const char *)
@trydoc raw"""
    SetErrorStr(this::ByRef1{TSystem}, errstr::ByCopy{String})::Nothing
Set the system error string.
This string will be used by [GetError()](@ref). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno).
""" SetErrorStr(this::ByRef1{TSystem}, errstr::ByCopy{String})

# Wrapper of void TSystem::SetFlagsDebug(const char *)
@trydoc raw"""
    SetFlagsDebug(this::ByRef1{TSystem}, ::ByCopy{String})::Nothing
FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode.

""" SetFlagsDebug(this::ByRef1{TSystem}, ::ByCopy{String})

# Wrapper of void TSystem::SetFlagsOpt(const char *)
@trydoc raw"""
    SetFlagsOpt(this::ByRef1{TSystem}, ::ByCopy{String})::Nothing
FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode.

""" SetFlagsOpt(this::ByRef1{TSystem}, ::ByCopy{String})

# Wrapper of Int_t TSystem::SetFPEMask(Int_t)
@trydoc raw"""
    SetFPEMask(this::ByRef1{TSystem}, mask::Int32)::Int32
Set which conditions trigger a floating point exception.
Return the previous set of conditions.
""" SetFPEMask(this::ByRef1{TSystem}, mask::Int32)

# Wrapper of void TSystem::SetIncludePath(const char *)
@trydoc raw"""
    SetIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})::Nothing
IncludePath should contain the list of compiler flags to indicate where to find user defined header files.
It is used to expand $IncludePath in the directives given to [SetMakeSharedLib()](@ref) and [SetMakeExe()](@ref), e.g.: 

    gSystem->SetInclude("-I$ROOTSYS/include -Imydirectory/include");

(C++ version of the code)

 the default value of IncludePath on Unix is: 

    "-I$ROOTSYS/include "

(C++ version of the code)

 and on Windows: 

    "/I%ROOTSYS%/include "

(C++ version of the code)
""" SetIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})

# Wrapper of void TSystem::SetLinkdefSuffix(const char *)
@trydoc raw"""
    SetLinkdefSuffix(this::ByRef1{TSystem}, suffix::ByCopy{String})::Nothing
The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary.
So by default, when doing .L MyScript.cxx, ACLiC will look for a file name MyScript_linkdef and having one of the .h (.hpp, etc.) extensions. If such a file exist, it will be added to the theend of the linkdef file used to created the ACLiC dictionary. This effectively enable the full customization of the creation of the dictionary. It should be noted that the file is intended as a linkdef `fragment`, so usually you would not list the typical: 

    #pragma link off ....

(C++ version of the code)
""" SetLinkdefSuffix(this::ByRef1{TSystem}, suffix::ByCopy{String})

# Wrapper of void TSystem::SetLinkedLibs(const char *)
@trydoc raw"""
    SetLinkedLibs(this::ByRef1{TSystem}, linkedLibs::ByCopy{String})::Nothing
LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable.
It is used to expand $LinkedLibs in the directives given to [SetMakeSharedLib()](@ref) and [SetMakeExe()](@ref) The default value on Unix is: `root-config --glibs`
""" SetLinkedLibs(this::ByRef1{TSystem}, linkedLibs::ByCopy{String})

# Wrapper of void TSystem::SetMakeExe(const char *)
@trydoc raw"""
    SetMakeExe(this::ByRef1{TSystem}, directives::ByCopy{String})::Nothing
Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable.
This creation is used as a means to output a list of unresolved symbols, when loading a shared library has failed. The required variable is $ExeName rather than $SharedLib, e.g.: 

    gSystem->SetMakeExe(
    "g++ -Wall -fPIC $IncludePath $SourceFiles
     -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic");

(C++ version of the code)
""" SetMakeExe(this::ByRef1{TSystem}, directives::ByCopy{String})

# Wrapper of void TSystem::SetMakeSharedLib(const char *)
@trydoc raw"""
    SetMakeSharedLib(this::ByRef1{TSystem}, directives::ByCopy{String})::Nothing
Directives should contain the description on how to compile and link a shared lib.
This description can be any valid shell command, including the use of ';' to separate several instructions. However, shell specific construct should be avoided. In particular this description can contain environment variables, like $ROOTSYS (or ROOTSYS% on windows). 

    Five special variables will be expanded before execution:
      Variable name       Expands to
      -------------       ----------
      $SourceFiles        Name of source files to be compiled
      $SharedLib          Name of the shared library being created
      $LibName            Name of shared library without extension
      $BuildDir           Directory where the files will be created
      $IncludePath        value of fIncludePath
      $LinkedLibs         value of fLinkedLibs
      $DepLibs            libraries on which this library depends on
      $ObjectFiles        Name of source files to be compiler with
                          their extension changed to .o or .obj
      $Opt                location of the optimization/debug options
                          set fFlagsDebug and fFlagsOpt

(C++ version of the code)

 e.g.: 

    gSystem->SetMakeSharedLib(
    "KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile
     --no_exceptions --signed_chars --display_error_number
     --diag_suppress 68 -o $SharedLib");
    gSystem->setMakeSharedLib(
    "Cxx $IncludePath -c $SourceFile;
     ld  -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved
     \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o
     -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"
    gSystem->SetMakeSharedLib(
    "$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile
     -shared -o $SharedLib");
    gSystem->SetMakeSharedLib(
    "cl -DWIN32  -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32
     -D_WINDOWS $IncludePath $SourceFile
     /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO
     $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib")

(C++ version of the code)
""" SetMakeSharedLib(this::ByRef1{TSystem}, directives::ByCopy{String})

# Wrapper of void TSystem::SetObjExt(const char *)
@trydoc raw"""
    SetObjExt(this::ByRef1{TSystem}, objExt::ByCopy{String})::Nothing
Set object files extension, should be either .o, .obj, etc.

""" SetObjExt(this::ByRef1{TSystem}, objExt::ByCopy{String})

# Wrapper of void TSystem::SetProgname(const char *)
@trydoc raw"""
    SetProgname(this::ByRef1{TSystem}, name::ByCopy{String})::Nothing
Set the application name (from command line, argv[0]) and copy it in gProgName.

""" SetProgname(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of int TSystem::SetSockOpt(int, int, int)
@trydoc raw"""
    SetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::Int32)::Int32
Set socket option.

""" SetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::Int32)

# Wrapper of void TSystem::SetSoExt(const char *)
@trydoc raw"""
    SetSoExt(this::ByRef1{TSystem}, soExt::ByCopy{String})::Nothing
Set shared library extension, should be either .so, .sl, .a, .dll, etc.

""" SetSoExt(this::ByRef1{TSystem}, soExt::ByCopy{String})

# Wrapper of void TSystem::ShowOutput(RedirectHandle_t *)
@trydoc raw"""
    ShowOutput(this::ByRef1{TSystem}, h::ByPtr1{RedirectHandle_t})::Nothing
Display the content associated with the redirection described by the opaque handle 'h'.

""" ShowOutput(this::ByRef1{TSystem}, h::ByPtr1{RedirectHandle_t})

# Wrapper of void TSystem::Sleep(UInt_t)
@trydoc raw"""
    Sleep(this::ByRef1{TSystem}, milliSec::UInt32)::Nothing
Sleep milliSec milli seconds.

""" Sleep(this::ByRef1{TSystem}, milliSec::UInt32)

# Wrapper of void TSystem::StackTrace()
@trydoc raw"""
    StackTrace(this::ByRef1{TSystem})::Nothing
Print a stack trace.

""" StackTrace(this::ByRef1{TSystem})

# Wrapper of void TSystem::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TSystem}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TSystem}, ::ByRef1{TBuffer})

# Wrapper of void TSystem::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TSystem}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TSystem}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of int TSystem::Symlink(const char *, const char *)
@trydoc raw"""
    Symlink(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})::Int32
Create a symbolic link from file1 to file2.

""" Symlink(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})

# Wrapper of void TSystem::Syslog(ELogLevel, const char *)
@trydoc raw"""
    Syslog(this::ByRef1{TSystem}, level::ByCopy{ELogLevel}, mess::ByCopy{String})::Nothing
Send mess to syslog daemon.
Level is the logging level and mess the message that will be written on the log.
""" Syslog(this::ByRef1{TSystem}, level::ByCopy{ELogLevel}, mess::ByCopy{String})

# Wrapper of FILE * TSystem::TempFileName(TString &, const char *, const char *)
@trydoc raw"""
    TempFileName(this::ByRef1{TSystem}, base::ByRef1{TString}, dir::ByCopy{String}, suffix::ByCopy{String})::CxxPtr1{FILE}
Create a secure temporary file by appending a unique 6 letter string to base.
The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension ".txt" or ".html". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error.
""" TempFileName(this::ByRef1{TSystem}, base::ByRef1{TString}, dir::ByCopy{String}, suffix::ByCopy{String})

# Wrapper of int TSystem::Umask(Int_t)
@trydoc raw"""
    Umask(this::ByRef1{TSystem}, mask::Int32)::Int32
Set the process file creation mode mask.

""" Umask(this::ByRef1{TSystem}, mask::Int32)

# Wrapper of const char * TSystem::UnixPathName(const char *)
@trydoc raw"""
    UnixPathName(this::ByRef1{TSystem}, unixpathname::ByCopy{String})::ByCopy{String}
Convert from a local_ pathname to a Unix pathname.
E.g. from `\user\root` to `/user/root`.
""" UnixPathName(this::ByRef1{TSystem}, unixpathname::ByCopy{String})

# Wrapper of int TSystem::Unlink(const char *)
@trydoc raw"""
    Unlink(this::ByRef1{TSystem}, name::ByCopy{String})::Int32
Unlink, i.e.
remove, a file.

If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, while Windows does not allow the file to be deleted and the operation is a no-op).
""" Unlink(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of void TSystem::Unload(const char *)
@trydoc raw"""
    Unload(this::ByRef1{TSystem}, themodule::ByCopy{String})::Nothing
Unload a shared library.

""" Unload(this::ByRef1{TSystem}, themodule::ByCopy{String})

# Wrapper of void TSystem::Unsetenv(const char *)
@trydoc raw"""
    Unsetenv(this::ByRef1{TSystem}, name::ByCopy{String})::Nothing
Unset environment variable.

""" Unsetenv(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of int TSystem::Utime(const char *, Long_t, Long_t)
@trydoc raw"""
    Utime(this::ByRef1{TSystem}, file::ByCopy{String}, modtime::Int64, actime::Int64)::Int32
Set the a files modification and access times.
If actime = 0 it will be set to the modtime. Returns 0 on success and -1 in case of error.
""" Utime(this::ByRef1{TSystem}, file::ByCopy{String}, modtime::Int64, actime::Int64)

# Wrapper of char * TSystem::Which(const char *, const char *, EAccessMode)
@trydoc raw"""
    Which(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByCopy{String}, mode::ByCopy{EAccessMode})::ByCopy{Union{String, Vector{CxxChar}}}
Find location of file in a search path.
User must delete returned string. Returns 0 in case file is not found.
""" Which(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByCopy{String}, mode::ByCopy{EAccessMode})

# Wrapper of const char * TSystem::WorkingDirectory()
@trydoc raw"""
    WorkingDirectory(this::ByRef1{TSystem})::ByCopy{String}
Return working directory.

""" WorkingDirectory(this::ByRef1{TSystem})

# Wrapper of void TRedirectOutputGuard::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TRedirectOutputGuard}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TRedirectOutputGuard}, ::ByRef1{TBuffer})

# Wrapper of void TRedirectOutputGuard::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TRedirectOutputGuard}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TRedirectOutputGuard}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of TRef & TRef::operator=(const TRef &)
@trydoc raw"""
    assign(this::ByRef1{TRef}, ref::ByConstRef1{TRef})::CxxRef1{TRef}
[TRef](@ref) assignment operator.

""" assign(this::ByRef1{TRef}, ref::ByConstRef1{TRef})

# Wrapper of void TRef::operator=(TObject *)
@trydoc raw"""
    assign(this::ByRef1{TRef}, obj::ByPtr1{TObject})::Nothing
Assign object to reference.

""" assign(this::ByRef1{TRef}, obj::ByPtr1{TObject})

# Wrapper of void TRef::SetAction(const char *)
@trydoc raw"""
    SetAction(this::ByRef1{TRef}, name::ByCopy{String})::Nothing
Store the exec number (in the [ROOT](@ref) list of Execs) into the fBits of this [TRef](@ref).

""" SetAction(this::ByRef1{TRef}, name::ByCopy{String})

# Wrapper of void TRef::SetAction(TObject *)
@trydoc raw"""
    SetAction(this::ByRef1{TRef}, parent::ByPtr1{TObject})::Nothing
Find the action to be executed in the dictionary of the parent class and store the corresponding exec number into fBits.
This function searches a data member in the class of parent with an offset corresponding to this. If a comment "TEXEC:" is found in the comment field of the data member, the function stores the exec identifier of the exec statement following this keyword.
""" SetAction(this::ByRef1{TRef}, parent::ByPtr1{TObject})

# Wrapper of void TRef::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TRef}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TRef](@ref).

""" Streamer(this::ByRef1{TRef}, ::ByRef1{TBuffer})

# Wrapper of void TRef::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TRef}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TRef}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TRefTable::Add(Int_t, TProcessID *)
@trydoc raw"""
    Add(this::ByRef1{TRefTable}, uid::Int32, context::ByPtr1{TProcessID})::Int32
Add a new uid to the table.
we add a new pair (uid,fparent) to the map This function is called by [TObject!Streamer](@ref) or TStreamerInfo!WriteBuffer
""" Add(this::ByRef1{TRefTable}, uid::Int32, context::ByPtr1{TProcessID})

# Wrapper of void TRefTable::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TRefTable}, ::ByCopy{String})::Nothing
Clear all entries in the table.

""" Clear(this::ByRef1{TRefTable}, ::ByCopy{String})

# Wrapper of Int_t TRefTable::Expand(Int_t, Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TRefTable}, pid::Int32, newsize::Int32)::Int32
Expand fParentIDs to newsize for ProcessID pid.

""" Expand(this::ByRef1{TRefTable}, pid::Int32, newsize::Int32)

# Wrapper of void TRefTable::FillBuffer(TBuffer &)
@trydoc raw"""
    FillBuffer(this::ByRef1{TRefTable}, b::ByRef1{TBuffer})::Nothing
Fill buffer b with the fN elements in fParentdIDs.
This function is called by TBranchRef!FillLeaves.
""" FillBuffer(this::ByRef1{TRefTable}, b::ByRef1{TBuffer})

# Wrapper of Bool_t TRefTable::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TRefTable})::Bool
This function is called by [TRef!Streamer](@ref) or [TStreamerInfo!ReadBuffer](@ref) when reading a reference.
This function, in turns, notifies the [TRefTable](@ref) owner for action. eg, when the owner is a [TBranchRef](@ref), [TBranchRef!Notify](@ref) is called to read the branch containing the referenced object.
""" Notify(this::ByRef1{TRefTable})

# Wrapper of void TRefTable::ReadBuffer(TBuffer &)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TRefTable}, b::ByRef1{TBuffer})::Nothing
Fill buffer b with the fN elements in fParentdIDs.
This function is called by TBranchRef!ReadLeaves
""" ReadBuffer(this::ByRef1{TRefTable}, b::ByRef1{TBuffer})

# Wrapper of void TRefTable::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TRefTable}, ::ByCopy{String})::Nothing
Clear all entries in the table.

""" Reset(this::ByRef1{TRefTable}, ::ByCopy{String})

# Wrapper of Int_t TRefTable::SetParent(const TObject *, Int_t)
@trydoc raw"""
    SetParent(this::ByRef1{TRefTable}, parent::ByConstPtr1{TObject}, branchID::Int32)::Int32
 Set current parent object, typically a branch of a tree.
This function is called by [TBranchElement!Fill()](@ref) and by [TBranchElement!GetEntry()](@ref).
""" SetParent(this::ByRef1{TRefTable}, parent::ByConstPtr1{TObject}, branchID::Int32)

# Wrapper of void TRefTable::SetUID(UInt_t, TProcessID *)
@trydoc raw"""
    SetUID(this::ByRef1{TRefTable}, uid::UInt32, context::ByPtr1{TProcessID})::Nothing


""" SetUID(this::ByRef1{TRefTable}, uid::UInt32, context::ByPtr1{TProcessID})

# Wrapper of TList * TRemoteObject::Browse()
@trydoc raw"""
    Browse(this::ByRef1{TRemoteObject})::CxxPtr1{TList}
Browse OS system directories.

""" Browse(this::ByRef1{TRemoteObject})

# Wrapper of void TRemoteObject::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TRemoteObject}, b::ByPtr1{TBrowser})::Nothing
Browse remote object.

""" Browse(this::ByRef1{TRemoteObject}, b::ByPtr1{TBrowser})

# Wrapper of Bool_t TRemoteObject::GetFileStat(FileStat_t *)
@trydoc raw"""
    GetFileStat(this::ByRef1{TRemoteObject}, sbuf::ByPtr1{FileStat_t})::Bool
Get remote file status.

""" GetFileStat(this::ByRef1{TRemoteObject}, sbuf::ByPtr1{FileStat_t})

# Wrapper of void TRemoteObject::SetFolder(Bool_t)
@trydoc raw"""
    SetFolder(this::ByRef1{TRemoteObject}, isFolder::Bool)::Nothing


""" SetFolder(this::ByRef1{TRemoteObject}, isFolder::Bool)

# Wrapper of void TRemoteObject::SetKeyClassName(const char *)
@trydoc raw"""
    SetKeyClassName(this::ByRef1{TRemoteObject}, name::ByCopy{String})::Nothing


""" SetKeyClassName(this::ByRef1{TRemoteObject}, name::ByCopy{String})

# Wrapper of void TRemoteObject::SetKeyObjectName(const char *)
@trydoc raw"""
    SetKeyObjectName(this::ByRef1{TRemoteObject}, name::ByCopy{String})::Nothing


""" SetKeyObjectName(this::ByRef1{TRemoteObject}, name::ByCopy{String})

# Wrapper of void TRemoteObject::SetRemoteAddress(Longptr_t)
@trydoc raw"""
    SetRemoteAddress(this::ByRef1{TRemoteObject}, addr::Int64)::Nothing


""" SetRemoteAddress(this::ByRef1{TRemoteObject}, addr::Int64)

# Wrapper of void TRemoteObject::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TRemoteObject}, ::ByRef1{TBuffer})::Nothing
Remote object streamer.

""" Streamer(this::ByRef1{TRemoteObject}, ::ByRef1{TBuffer})

# Wrapper of void TRemoteObject::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TRemoteObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TRemoteObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TSystemFile::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TSystemFile}, b::ByPtr1{TBrowser})::Nothing
Execute default action for this system file (action is specified in the $HOME/.root.mimes or $ROOTSYS/etc/root.mimes file.

""" Browse(this::ByRef1{TSystemFile}, b::ByPtr1{TBrowser})

# Wrapper of void TSystemFile::Copy(const char *)
@trydoc raw"""
    Copy(this::ByRef1{TSystemFile}, to::ByCopy{String})::Nothing
copy this file

""" Copy(this::ByRef1{TSystemFile}, to::ByCopy{String})

# Wrapper of void TSystemFile::Delete()
@trydoc raw"""
    Delete(this::ByRef1{TSystemFile})::Nothing
delete this file

""" Delete(this::ByRef1{TSystemFile})

# Wrapper of void TSystemFile::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TSystemFile}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TSystemFile}, option::ByCopy{String})

# Wrapper of void TSystemFile::Edit()
@trydoc raw"""
    Edit(this::ByRef1{TSystemFile})::Nothing
Invoke text editor on this file.

""" Edit(this::ByRef1{TSystemFile})

# Wrapper of void TSystemFile::Move(const char *)
@trydoc raw"""
    Move(this::ByRef1{TSystemFile}, to::ByCopy{String})::Nothing
move this file

""" Move(this::ByRef1{TSystemFile}, to::ByCopy{String})

# Wrapper of void TSystemFile::Rename(const char *)
@trydoc raw"""
    Rename(this::ByRef1{TSystemFile}, name::ByCopy{String})::Nothing
rename this file

""" Rename(this::ByRef1{TSystemFile}, name::ByCopy{String})

# Wrapper of void TSystemFile::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TSystemFile}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TSystemFile}, option::ByCopy{String})

# Wrapper of void TSystemFile::SetIconName(const char *)
@trydoc raw"""
    SetIconName(this::ByRef1{TSystemFile}, name::ByCopy{String})::Nothing


""" SetIconName(this::ByRef1{TSystemFile}, name::ByCopy{String})

# Wrapper of void TSystemFile::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TSystemFile}, name::ByCopy{String})::Nothing
Set the name of the [TNamed](@ref).
WARNING: if the object is a member of a [THashTable](@ref) or [THashList](@ref) container the container must be Rehash()'ed after [SetName()](@ref). For example the list of objects in the current directory is a [THashList](@ref).
""" SetName(this::ByRef1{TSystemFile}, name::ByCopy{String})

# Wrapper of void TSystemFile::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TSystemFile}, title::ByCopy{String})::Nothing
Set the title of the [TNamed](@ref).

""" SetTitle(this::ByRef1{TSystemFile}, title::ByCopy{String})

# Wrapper of void TSystemFile::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TSystemFile}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TSystemFile}, ::ByRef1{TBuffer})

# Wrapper of void TSystemFile::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TSystemFile}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TSystemFile}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TSystemDirectory::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TSystemDirectory}, b::ByPtr1{TBrowser})::Nothing
Browse OS system directories.

""" Browse(this::ByRef1{TSystemDirectory}, b::ByPtr1{TBrowser})

# Wrapper of void TSystemDirectory::Copy(const char *)
@trydoc raw"""
    Copy(this::ByRef1{TSystemDirectory}, to::ByCopy{String})::Nothing
copy this file

""" Copy(this::ByRef1{TSystemDirectory}, to::ByCopy{String})

# Wrapper of void TSystemDirectory::Delete()
@trydoc raw"""
    Delete(this::ByRef1{TSystemDirectory})::Nothing
delete this file

""" Delete(this::ByRef1{TSystemDirectory})

# Wrapper of void TSystemDirectory::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TSystemDirectory}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TSystemDirectory}, option::ByCopy{String})

# Wrapper of void TSystemDirectory::Edit()
@trydoc raw"""
    Edit(this::ByRef1{TSystemDirectory})::Nothing
Invoke text editor on this file.

""" Edit(this::ByRef1{TSystemDirectory})

# Wrapper of void TSystemDirectory::Move(const char *)
@trydoc raw"""
    Move(this::ByRef1{TSystemDirectory}, to::ByCopy{String})::Nothing
move this file

""" Move(this::ByRef1{TSystemDirectory}, to::ByCopy{String})

# Wrapper of void TSystemDirectory::SetDirectory(const char *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TSystemDirectory}, name::ByCopy{String})::Nothing
Create a system directory object.

""" SetDirectory(this::ByRef1{TSystemDirectory}, name::ByCopy{String})

# Wrapper of void TSystemDirectory::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TSystemDirectory}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TSystemDirectory}, option::ByCopy{String})

# Wrapper of void TSystemDirectory::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TSystemDirectory}, name::ByCopy{String})::Nothing
Set the name of the [TNamed](@ref).
WARNING: if the object is a member of a [THashTable](@ref) or [THashList](@ref) container the container must be Rehash()'ed after [SetName()](@ref). For example the list of objects in the current directory is a [THashList](@ref).
""" SetName(this::ByRef1{TSystemDirectory}, name::ByCopy{String})

# Wrapper of void TSystemDirectory::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TSystemDirectory}, title::ByCopy{String})::Nothing
Set the title of the [TNamed](@ref).

""" SetTitle(this::ByRef1{TSystemDirectory}, title::ByCopy{String})

# Wrapper of void TSystemDirectory::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TSystemDirectory}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TSystemDirectory}, ::ByRef1{TBuffer})

# Wrapper of void TSystemDirectory::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TSystemDirectory}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TSystemDirectory}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TTask::Abort()
@trydoc raw"""
    Abort(this::ByRef1{TTask})::Nothing
Abort current tree of tasks.
After this call, the tree of tasks is ready to be executed again. The application must take care of cleaning data structures created by previous executions.
""" Abort(this::ByRef1{TTask})

# Wrapper of void TTask::Add(TTask *)
@trydoc raw"""
    Add(this::ByRef1{TTask}, task::ByPtr1{TTask})::Nothing
Add [TTask](@ref) to this.

""" Add(this::ByRef1{TTask}, task::ByPtr1{TTask})

# Wrapper of void TTask::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TTask}, b::ByPtr1{TBrowser})::Nothing
Browse the list of tasks.
It is recommended to add the top level task to the list of [ROOT](@ref) browsables by: 

    gROOT->GetListOfBrowsables()->Add(myTopLevelTask)

(C++ version of the code)
""" Browse(this::ByRef1{TTask}, b::ByPtr1{TBrowser})

# Wrapper of void TTask::CleanTasks()
@trydoc raw"""
    CleanTasks(this::ByRef1{TTask})::Nothing
Reset tasks state: breakpoints and execute flags also invokes the Clear function of each task to clear all data structures created by a previous execution of a task.

""" CleanTasks(this::ByRef1{TTask})

# Wrapper of void TTask::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TTask}, option::ByCopy{String})::Nothing
Recursively call the Clear function of this task and its subtasks.
The Clear function must be implemented for each derived class to clear all data structures created by a previous execution of a task. This function is automatically called by the CleanTasks function.
""" Clear(this::ByRef1{TTask}, option::ByCopy{String})

# Wrapper of void TTask::Continue()
@trydoc raw"""
    Continue(this::ByRef1{TTask})::Nothing
Resume execution at the current break point.

""" Continue(this::ByRef1{TTask})

# Wrapper of void TTask::Exec(Option_t *)
@trydoc raw"""
    Exec(this::ByRef1{TTask}, option::ByCopy{String})::Nothing
Dummy Execute.
This function must be redefined in the derived classes.
""" Exec(this::ByRef1{TTask}, option::ByCopy{String})

# Wrapper of void TTask::ExecuteTask(Option_t *)
@trydoc raw"""
    ExecuteTask(this::ByRef1{TTask}, option::ByCopy{String})::Nothing
Execute main task and its subtasks.
When calling this function, the Exec function of the corresponding class is invoked, then the list of its subtasks is executed calling recursively all the subtasks, etc.

The option parameter may be used to select different execution steps within a task. This parameter is passed also to all the subtasks.
""" ExecuteTask(this::ByRef1{TTask}, option::ByCopy{String})

# Wrapper of void TTask::ExecuteTasks(Option_t *)
@trydoc raw"""
    ExecuteTasks(this::ByRef1{TTask}, option::ByCopy{String})::Nothing
Execute all the subtasks of a task.

""" ExecuteTasks(this::ByRef1{TTask}, option::ByCopy{String})

# Wrapper of TTask & TTask::operator=(const TTask &)
@trydoc raw"""
    assign(this::ByRef1{TTask}, tt::ByConstRef1{TTask})::CxxRef1{TTask}
Assignment operator.

""" assign(this::ByRef1{TTask}, tt::ByConstRef1{TTask})

# Wrapper of void TTask::SetActive(Bool_t)
@trydoc raw"""
    SetActive(this::ByRef1{TTask}, active::Bool)::Nothing


""" SetActive(this::ByRef1{TTask}, active::Bool)

# Wrapper of void TTask::SetBreakin(Int_t)
@trydoc raw"""
    SetBreakin(this::ByRef1{TTask}, breakin::Int32)::Nothing


""" SetBreakin(this::ByRef1{TTask}, breakin::Int32)

# Wrapper of void TTask::SetBreakout(Int_t)
@trydoc raw"""
    SetBreakout(this::ByRef1{TTask}, breakout::Int32)::Nothing


""" SetBreakout(this::ByRef1{TTask}, breakout::Int32)

# Wrapper of void TTask::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TTask}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TTask}, ::ByRef1{TBuffer})

# Wrapper of void TTask::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TTask}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TTask}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TTimeStamp::Add(const TTimeStamp &)
@trydoc raw"""
    Add(this::ByRef1{TTimeStamp}, offset::ByConstRef1{TTimeStamp})::Nothing
Add "offset" as a delta time.

""" Add(this::ByRef1{TTimeStamp}, offset::ByConstRef1{TTimeStamp})

# Wrapper of void TTimeStamp::Set()
@trydoc raw"""
    Set(this::ByRef1{TTimeStamp})::Nothing
Set Date/Time to current time as reported by the system.
No accounting for nanoseconds with std ANSI functions, ns part faked so that subsequent calls simply add 1 to it this ensures that calls within the same second come back distinct (and sortable). Time is since Jan 1, 1970.
""" Set(this::ByRef1{TTimeStamp})

# Wrapper of void TTimeStamp::Set(Int_t, Int_t, Int_t, Bool_t, Int_t)
@trydoc raw"""
    Set(this::ByRef1{TTimeStamp}, date::Int32, time::Int32, nsec::Int32, isUTC::Bool, secOffset::Int32)::Nothing
Set date/time from integers of the form [yy]YYMMDD and HHMMSS, assume UTC (UTC) components:
MM: 01=January .. 12=December
    DD: 01 .. 31
    HH: 00=midnight .. 23
    MM: 00 .. 59
    SS: 00 .. 69

(C++ version of the code)

- Date must be in format 980418 or 19980418 1001127 or 20001127 (i.e. year 100 = 2000),
- time must be in format 224512 (second precision),
- date must be >= 700101.
""" Set(this::ByRef1{TTimeStamp}, date::Int32, time::Int32, nsec::Int32, isUTC::Bool, secOffset::Int32)

# Wrapper of void TTimeStamp::Set(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Bool_t, Int_t)
@trydoc raw"""
    Set(this::ByRef1{TTimeStamp}, year::Int32, month::Int32, day::Int32, hour::Int32, min::Int32, sec::Int32, nsec::Int32, isUTC::Bool, secOffset::Int32)::Nothing
Set Date/Time from components.
Month & day both use normal 1..12 and 1..31 counting, hours, min, sec run from 0 to 23, 59, 59 respectively, secOffset provides method for adjusting for alternative timezones

    "year"  |    0    1 ... 37 | 38...69   |   70 .. 100  101 ..  137
    true    | 2000 2001   2037 | undefined | 1970   2000 2001 .. 2037
    "year"  | 138...1969 | 1970 .. 2037 | ...
    true    | undefined  | 1970 .. 2037 | undefined

(C++ version of the code)
""" Set(this::ByRef1{TTimeStamp}, year::Int32, month::Int32, day::Int32, hour::Int32, min::Int32, sec::Int32, nsec::Int32, isUTC::Bool, secOffset::Int32)

# Wrapper of void TTimeStamp::Set(UInt_t, Bool_t, Int_t, Bool_t)
@trydoc raw"""
    Set(this::ByRef1{TTimeStamp}, tloc::UInt32, isUTC::Bool, secOffset::Int32, dosDate::Bool)::Nothing
The input arg is a time_t value returned by time() or a value returned by Convert().
This value is the number of seconds since the EPOCH (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input is a dosDate value.
""" Set(this::ByRef1{TTimeStamp}, tloc::UInt32, isUTC::Bool, secOffset::Int32, dosDate::Bool)

# Wrapper of void TTimeStamp::SetNanoSec(Int_t)
@trydoc raw"""
    SetNanoSec(this::ByRef1{TTimeStamp}, nsec::Int32)::Nothing


""" SetNanoSec(this::ByRef1{TTimeStamp}, nsec::Int32)

# Wrapper of void TTimeStamp::SetSec(Int_t)
@trydoc raw"""
    SetSec(this::ByRef1{TTimeStamp}, sec::Int32)::Nothing


""" SetSec(this::ByRef1{TTimeStamp}, sec::Int32)

# Wrapper of void TTimeStamp::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TTimeStamp}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TTimeStamp}, ::ByRef1{TBuffer})

# Wrapper of void TTimeStamp::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TTimeStamp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TTimeStamp}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TUri::Normalise()
@trydoc raw"""
    Normalise(this::ByRef1{TUri})::Nothing
Syntax based normalisation according to RFC chapter 6.2.2.

""" Normalise(this::ByRef1{TUri})

# Wrapper of TUri & TUri::operator=(const TUri &)
@trydoc raw"""
    assign(this::ByRef1{TUri}, rhs::ByConstRef1{TUri})::CxxRef1{TUri}
[TUri](@ref) assignment operator.

""" assign(this::ByRef1{TUri}, rhs::ByConstRef1{TUri})

# Wrapper of void TUri::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TUri})::Nothing
Initialize this URI object.
Set all [TString](@ref) members to empty string, set all Bool_t members to kFALSE.
""" Reset(this::ByRef1{TUri})

# Wrapper of Bool_t TUri::SetAuthority(const TString &)
@trydoc raw"""
    SetAuthority(this::ByRef1{TUri}, authority::ByConstRef1{TString})::Bool
Set authority part of URI:
authority   = [ userinfo "@" ] host [ ":" port ]

(C++ version of the code)

Split into components {userinfo@, host, :port}, remember that according to the RFC, it is necessary to distinguish between missing component (no delimiter) and empty component (delimiter present).
""" SetAuthority(this::ByRef1{TUri}, authority::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetFragment(const TString &)
@trydoc raw"""
    SetFragment(this::ByRef1{TUri}, fragment::ByConstRef1{TString})::Bool
Set fragment component of URI:
fragment    = *( pchar / "/" / "?" )

(C++ version of the code)
""" SetFragment(this::ByRef1{TUri}, fragment::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetHierPart(const TString &)
@trydoc raw"""
    SetHierPart(this::ByRef1{TUri}, hier::ByConstRef1{TString})::Bool
returns hier-part component of URI
hier-part   = "//" authority path-abempty
                / path-absolute
                / path-rootless
                / path-empty

(C++ version of the code)
""" SetHierPart(this::ByRef1{TUri}, hier::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetHost(const TString &)
@trydoc raw"""
    SetHost(this::ByRef1{TUri}, host::ByConstRef1{TString})::Bool
Set host component of URI:
RFC 3986:    host = IP-literal / IPv4address / reg-name
    implemented: host =  IPv4address / reg-name

(C++ version of the code)
""" SetHost(this::ByRef1{TUri}, host::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetPath(const TString &)
@trydoc raw"""
    SetPath(this::ByRef1{TUri}, path::ByConstRef1{TString})::Bool
Set path component of URI:
path          = path-abempty    ; begins with "/" or is empty
                  / path-absolute   ; begins with "/" but not "//"
                  / path-noscheme   ; begins with a non-colon segment
                  / path-rootless   ; begins with a segment
                  / path-empty      ; zero characters

(C++ version of the code)
""" SetPath(this::ByRef1{TUri}, path::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetPort(const TString &)
@trydoc raw"""
    SetPort(this::ByRef1{TUri}, port::ByConstRef1{TString})::Bool
Set port component of URI:
port        = *DIGIT

(C++ version of the code)
""" SetPort(this::ByRef1{TUri}, port::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetQuery(const TString &)
@trydoc raw"""
    SetQuery(this::ByRef1{TUri}, path::ByConstRef1{TString})::Bool
Set query component of URI:
query       = *( pchar / "/" / "?" )

(C++ version of the code)
""" SetQuery(this::ByRef1{TUri}, path::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetRelativePart(const TString &)
@trydoc raw"""
    SetRelativePart(this::ByRef1{TUri}, ::ByConstRef1{TString})::Bool
Returns kTRUE is string qualifies as relative-part:
relative-part = "//" authority path-abempty
                  / path-absolute
                  / path-noscheme
                  / path-empty

(C++ version of the code)
""" SetRelativePart(this::ByRef1{TUri}, ::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetScheme(const TString &)
@trydoc raw"""
    SetScheme(this::ByRef1{TUri}, scheme::ByConstRef1{TString})::Bool
Set scheme component of URI:
scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

(C++ version of the code)
""" SetScheme(this::ByRef1{TUri}, scheme::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetUri(const TString &)
@trydoc raw"""
    SetUri(this::ByRef1{TUri}, uri::ByConstRef1{TString})::Bool
Parse URI and set the member variables accordingly, returns kTRUE if URI validates, and kFALSE otherwise:
URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    hier-part   = "//" authority path-abempty
                / path-absolute
                / path-rootless
                / path-empty

(C++ version of the code)
""" SetUri(this::ByRef1{TUri}, uri::ByConstRef1{TString})

# Wrapper of Bool_t TUri::SetUserInfo(const TString &)
@trydoc raw"""
    SetUserInfo(this::ByRef1{TUri}, userinfo::ByConstRef1{TString})::Bool
Set userinfo component of URI:
userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )

(C++ version of the code)
""" SetUserInfo(this::ByRef1{TUri}, userinfo::ByConstRef1{TString})

# Wrapper of void TUri::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TUri}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TUri}, ::ByRef1{TBuffer})

# Wrapper of void TUri::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TUri}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TUri}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TVirtualAuth::ClientVersion()
@trydoc raw"""
    ClientVersion(this::ByRef1{TVirtualAuth})::Int32


""" ClientVersion(this::ByRef1{TVirtualAuth})

# Wrapper of void TVirtualAuth::ErrorMsg(const char *, Int_t)
@trydoc raw"""
    ErrorMsg(this::ByRef1{TVirtualAuth}, where::ByCopy{String}, ecode::Int32)::Nothing


""" ErrorMsg(this::ByRef1{TVirtualAuth}, where::ByCopy{String}, ecode::Int32)

# Wrapper of const char * TVirtualAuth::Name()
@trydoc raw"""
    Name(this::ByRef1{TVirtualAuth})::ByCopy{String}


""" Name(this::ByRef1{TVirtualAuth})

# Wrapper of void TVirtualAuth::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualAuth}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualAuth}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualAuth::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualAuth}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualAuth}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualFFT::Init(Option_t *, Int_t, const Int_t *)
@trydoc raw"""
    Init(this::ByRef1{TVirtualFFT}, flag::ByCopy{String}, sign::Int32, kind::ByConstPtr2{Int32})::Nothing


""" Init(this::ByRef1{TVirtualFFT}, flag::ByCopy{String}, sign::Int32, kind::ByConstPtr2{Int32})

# Wrapper of void TVirtualFFT::SetPoint(const Int_t *, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TVirtualFFT}, ipoint::ByConstPtr2{Int32}, re::Float64, im::Float64)::Nothing


""" SetPoint(this::ByRef1{TVirtualFFT}, ipoint::ByConstPtr2{Int32}, re::Float64, im::Float64)

# Wrapper of void TVirtualFFT::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TVirtualFFT}, ipoint::Int32, re::Float64, im::Float64)::Nothing


""" SetPoint(this::ByRef1{TVirtualFFT}, ipoint::Int32, re::Float64, im::Float64)

# Wrapper of void TVirtualFFT::SetPoints(const Double_t *)
@trydoc raw"""
    SetPoints(this::ByRef1{TVirtualFFT}, data::ByConstPtr2{Float64})::Nothing


""" SetPoints(this::ByRef1{TVirtualFFT}, data::ByConstPtr2{Float64})

# Wrapper of void TVirtualFFT::SetPointsComplex(const Double_t *, const Double_t *)
@trydoc raw"""
    SetPointsComplex(this::ByRef1{TVirtualFFT}, re::ByConstPtr2{Float64}, im::ByConstPtr2{Float64})::Nothing


""" SetPointsComplex(this::ByRef1{TVirtualFFT}, re::ByConstPtr2{Float64}, im::ByConstPtr2{Float64})

# Wrapper of void TVirtualFFT::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualFFT}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TVirtualFFT}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualFFT::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualFFT}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualFFT}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualFFT::Transform()
@trydoc raw"""
    Transform(this::ByRef1{TVirtualFFT})::Nothing


""" Transform(this::ByRef1{TVirtualFFT})

# Wrapper of void TVirtualMapFile::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TVirtualMapFile}, option::ByCopy{String})::Nothing


""" Close(this::ByRef1{TVirtualMapFile}, option::ByCopy{String})

# Wrapper of void TVirtualMapFile::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualMapFile}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TVirtualMapFile}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualMapFile::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualMapFile}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualMapFile}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void THashTable::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{THashTable}, obj::ByPtr1{TObject})::Nothing
Add object to the hash table.
Its position in the table will be determined by the value returned by its [Hash()](@ref) function.
""" Add(this::ByRef1{THashTable}, obj::ByPtr1{TObject})

# Wrapper of void THashTable::AddAll(const TCollection *)
@trydoc raw"""
    AddAll(this::ByRef1{THashTable}, col::ByConstPtr1{TCollection})::Nothing
Add all objects from collection col to this collection.
Implemented for more efficient rehashing.
""" AddAll(this::ByRef1{THashTable}, col::ByConstPtr1{TCollection})

# Wrapper of void THashTable::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{THashTable}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object to the hash table.
Its position in the table will be determined by the value returned by its [Hash()](@ref) function. If and only if 'before' is in the same bucket as obj, obj is added in front of 'before' within the bucket's list.
""" AddBefore(this::ByRef1{THashTable}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void THashTable::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{THashTable}, option::ByCopy{String})::Nothing
Remove all objects from the table.
Does not delete the objects unless the [THashTable](@ref) is the owner (set via [SetOwner()](@ref)).
""" Clear(this::ByRef1{THashTable}, option::ByCopy{String})

# Wrapper of void THashTable::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{THashTable}, option::ByCopy{String})::Nothing
Remove all objects from the table AND delete all heap based objects.

""" Delete(this::ByRef1{THashTable}, option::ByCopy{String})

# Wrapper of void THashTable::Rehash(Int_t, Bool_t)
@trydoc raw"""
    Rehash(this::ByRef1{THashTable}, newCapacity::Int32, checkObjValidity::Bool)::Nothing
Rehash the hashtable.
If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use [AverageCollisions()](@ref) to check if you need to rehash. Set checkObjValidity to kFALSE if you know that all objects in the table are still valid (i.e. have not been deleted from the system in the meanwhile).
""" Rehash(this::ByRef1{THashTable}, newCapacity::Int32, checkObjValidity::Bool)

# Wrapper of TObject * THashTable::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{THashTable}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from the hashtable.

""" Remove(this::ByRef1{THashTable}, obj::ByPtr1{TObject})

# Wrapper of TObject * THashTable::RemoveSlow(TObject *)
@trydoc raw"""
    RemoveSlow(this::ByRef1{THashTable}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from the hashtable without using the hash value.

""" RemoveSlow(this::ByRef1{THashTable}, obj::ByPtr1{TObject})

# Wrapper of void THashTable::SetRehashLevel(Int_t)
@trydoc raw"""
    SetRehashLevel(this::ByRef1{THashTable}, rehash::Int32)::Nothing


""" SetRehashLevel(this::ByRef1{THashTable}, rehash::Int32)

# Wrapper of TObject * THashTableIter::Next()
@trydoc raw"""
    Next(this::ByRef1{THashTableIter})::CxxPtr1{TObject}
Return next object in hashtable. Returns 0 when no more objects in table.

""" Next(this::ByRef1{THashTableIter})

# Wrapper of THashTableIter & THashTableIter::operator=(const THashTableIter &)
@trydoc raw"""
    assign(this::ByRef1{THashTableIter}, rhs::ByConstRef1{THashTableIter})::CxxRef1{THashTableIter}
Overloaded assignment operator.

""" assign(this::ByRef1{THashTableIter}, rhs::ByConstRef1{THashTableIter})

# Wrapper of TIterator & THashTableIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{THashTableIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{THashTableIter}, rhs::ByConstRef1{TIterator})

# Wrapper of void THashTableIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{THashTableIter})::Nothing
Reset the hashtable iterator.
Either to beginning or theend, depending on the initial iteration direction.
""" Reset(this::ByRef1{THashTableIter})

# Wrapper of void TPair::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TPair}, b::ByPtr1{TBrowser})::Nothing
Browse the pair.

""" Browse(this::ByRef1{TPair}, b::ByPtr1{TBrowser})

# Wrapper of void TPair::SetValue(TObject *)
@trydoc raw"""
    SetValue(this::ByRef1{TPair}, val::ByPtr1{TObject})::Nothing


""" SetValue(this::ByRef1{TPair}, val::ByPtr1{TObject})

# Wrapper of TObject * TMapIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TMapIter})::CxxPtr1{TObject}
Returns the next key from a map.
Use [TMap!GetValue()](@ref) to get the value associated with the key. Returns 0 when no more items in map.
""" Next(this::ByRef1{TMapIter})

# Wrapper of TIterator & TMapIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TMapIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TMapIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TMapIter & TMapIter::operator=(const TMapIter &)
@trydoc raw"""
    assign(this::ByRef1{TMapIter}, rhs::ByConstRef1{TMapIter})::CxxRef1{TMapIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TMapIter}, rhs::ByConstRef1{TMapIter})

# Wrapper of void TMapIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TMapIter})::Nothing
Reset the map iterator.

""" Reset(this::ByRef1{TMapIter})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendFileCloseEvent(TFile *)
@trydoc raw"""
    SendFileCloseEvent(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile})::Bool


""" SendFileCloseEvent(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendFileOpenProgress(TFile *, TList *, const char *, Bool_t)
@trydoc raw"""
    SendFileOpenProgress(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile}, ::ByPtr1{TList}, ::ByCopy{String}, ::Bool)::Bool


""" SendFileOpenProgress(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile}, ::ByPtr1{TList}, ::ByCopy{String}, ::Bool)

# Wrapper of Bool_t TVirtualMonitoringWriter::SendFileReadProgress(TFile *)
@trydoc raw"""
    SendFileReadProgress(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile})::Bool


""" SendFileReadProgress(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendFileWriteProgress(TFile *)
@trydoc raw"""
    SendFileWriteProgress(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile})::Bool


""" SendFileWriteProgress(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TFile})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendInfoDescription(const char *)
@trydoc raw"""
    SendInfoDescription(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})::Bool


""" SendInfoDescription(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendInfoStatus(const char *)
@trydoc raw"""
    SendInfoStatus(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})::Bool


""" SendInfoStatus(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendInfoTime()
@trydoc raw"""
    SendInfoTime(this::ByRef1{TVirtualMonitoringWriter})::Bool


""" SendInfoTime(this::ByRef1{TVirtualMonitoringWriter})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendInfoUser(const char *)
@trydoc raw"""
    SendInfoUser(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})::Bool


""" SendInfoUser(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendParameters(TList *, const char *)
@trydoc raw"""
    SendParameters(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TList}, ::ByCopy{String})::Bool


""" SendParameters(this::ByRef1{TVirtualMonitoringWriter}, ::ByPtr1{TList}, ::ByCopy{String})

# Wrapper of Bool_t TVirtualMonitoringWriter::SendProcessingProgress(Double_t, Double_t, Bool_t)
@trydoc raw"""
    SendProcessingProgress(this::ByRef1{TVirtualMonitoringWriter}, ::Float64, ::Float64, ::Bool)::Bool


""" SendProcessingProgress(this::ByRef1{TVirtualMonitoringWriter}, ::Float64, ::Float64, ::Bool)

# Wrapper of Bool_t TVirtualMonitoringWriter::SendProcessingStatus(const char *, Bool_t)
@trydoc raw"""
    SendProcessingStatus(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String}, ::Bool)::Bool


""" SendProcessingStatus(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String}, ::Bool)

# Wrapper of void TVirtualMonitoringWriter::SetLogLevel(const char *)
@trydoc raw"""
    SetLogLevel(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})::Nothing


""" SetLogLevel(this::ByRef1{TVirtualMonitoringWriter}, ::ByCopy{String})

# Wrapper of void TVirtualMonitoringWriter::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualMonitoringWriter}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TVirtualMonitoringWriter}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualMonitoringWriter::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualMonitoringWriter}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualMonitoringWriter}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualMonitoringWriter::Verbose(Bool_t)
@trydoc raw"""
    Verbose(this::ByRef1{TVirtualMonitoringWriter}, ::Bool)::Nothing


""" Verbose(this::ByRef1{TVirtualMonitoringWriter}, ::Bool)

# Wrapper of void TVirtualMonitoringReader::DeleteMap(TMap *)
@trydoc raw"""
    DeleteMap(this::ByRef1{TVirtualMonitoringReader}, ::ByPtr1{TMap})::Nothing


""" DeleteMap(this::ByRef1{TVirtualMonitoringReader}, ::ByPtr1{TMap})

# Wrapper of void TVirtualMonitoringReader::DumpResult()
@trydoc raw"""
    DumpResult(this::ByRef1{TVirtualMonitoringReader})::Nothing


""" DumpResult(this::ByRef1{TVirtualMonitoringReader})

# Wrapper of void TVirtualMonitoringReader::GetLastValues(const char *, const char *, const char *, const char *, Bool_t)
@trydoc raw"""
    GetLastValues(this::ByRef1{TVirtualMonitoringReader}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Bool)::Nothing


""" GetLastValues(this::ByRef1{TVirtualMonitoringReader}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Bool)

# Wrapper of TMap * TVirtualMonitoringReader::GetMap()
@trydoc raw"""
    GetMap(this::ByRef1{TVirtualMonitoringReader})::CxxPtr1{TMap}


""" GetMap(this::ByRef1{TVirtualMonitoringReader})

# Wrapper of void TVirtualMonitoringReader::GetValues(const char *, const char *, const char *, const char *, Long_t, Long_t, Bool_t)
@trydoc raw"""
    GetValues(this::ByRef1{TVirtualMonitoringReader}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int64, ::Int64, ::Bool)::Nothing


""" GetValues(this::ByRef1{TVirtualMonitoringReader}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int64, ::Int64, ::Bool)

# Wrapper of void TVirtualMonitoringReader::ProxyValues(const char *, const char *, const char *, const char *, Long_t, Long_t, Long_t)
@trydoc raw"""
    ProxyValues(this::ByRef1{TVirtualMonitoringReader}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int64, ::Int64, ::Int64)::Nothing


""" ProxyValues(this::ByRef1{TVirtualMonitoringReader}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int64, ::Int64, ::Int64)

# Wrapper of void TVirtualMonitoringReader::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualMonitoringReader}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TVirtualMonitoringReader}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualMonitoringReader::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualMonitoringReader}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualMonitoringReader}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPadEditor::Build()
@trydoc raw"""
    Build(this::ByRef1{TVirtualPadEditor})::Nothing


""" Build(this::ByRef1{TVirtualPadEditor})

# Wrapper of void TVirtualPadEditor::DeleteEditors()
@trydoc raw"""
    DeleteEditors(this::ByRef1{TVirtualPadEditor})::Nothing


""" DeleteEditors(this::ByRef1{TVirtualPadEditor})

# Wrapper of void TVirtualPadEditor::DrawLine(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DrawLine(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::Float64, ::Float64)::Nothing


""" DrawLine(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::Float64, ::Float64)

# Wrapper of void TVirtualPadEditor::DrawLineNDC(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DrawLineNDC(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::Float64, ::Float64)::Nothing


""" DrawLineNDC(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::Float64, ::Float64)

# Wrapper of void TVirtualPadEditor::DrawText(Double_t, Double_t, const char *)
@trydoc raw"""
    DrawText(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::ByCopy{String})::Nothing


""" DrawText(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::ByCopy{String})

# Wrapper of void TVirtualPadEditor::DrawTextNDC(Double_t, Double_t, const char *)
@trydoc raw"""
    DrawTextNDC(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::ByCopy{String})::Nothing


""" DrawTextNDC(this::ByRef1{TVirtualPadEditor}, ::Float64, ::Float64, ::ByCopy{String})

# Wrapper of void TVirtualPadEditor::FillAttributes(Int_t, Int_t)
@trydoc raw"""
    FillAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Int32)::Nothing


""" FillAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Int32)

# Wrapper of void TVirtualPadEditor::Hide()
@trydoc raw"""
    Hide(this::ByRef1{TVirtualPadEditor})::Nothing


""" Hide(this::ByRef1{TVirtualPadEditor})

# Wrapper of void TVirtualPadEditor::LineAttributes(Int_t, Int_t, Int_t)
@trydoc raw"""
    LineAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Int32, ::Int32)::Nothing


""" LineAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Int32, ::Int32)

# Wrapper of void TVirtualPadEditor::MarkerAttributes(Int_t, Int_t, Float_t)
@trydoc raw"""
    MarkerAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Int32, ::Float32)::Nothing


""" MarkerAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Int32, ::Float32)

# Wrapper of void TVirtualPadEditor::SetGlobal(Bool_t)
@trydoc raw"""
    SetGlobal(this::ByRef1{TVirtualPadEditor}, ::Bool)::Nothing


""" SetGlobal(this::ByRef1{TVirtualPadEditor}, ::Bool)

# Wrapper of void TVirtualPadEditor::Show()
@trydoc raw"""
    Show(this::ByRef1{TVirtualPadEditor})::Nothing


""" Show(this::ByRef1{TVirtualPadEditor})

# Wrapper of void TVirtualPadEditor::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualPadEditor}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualPadEditor}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualPadEditor::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualPadEditor}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualPadEditor}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPadEditor::TextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t)
@trydoc raw"""
    TextAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Float32, ::Int32, ::Int32, ::Float32)::Nothing


""" TextAttributes(this::ByRef1{TVirtualPadEditor}, ::Int32, ::Float32, ::Int32, ::Int32, ::Float32)

# Wrapper of Bool_t TAxis::CanBeAlphanumeric()
@trydoc raw"""
    CanBeAlphanumeric(this::ByRef1{TAxis})::Bool


""" CanBeAlphanumeric(this::ByRef1{TAxis})

# Wrapper of void TAxis::CenterLabels(Bool_t)
@trydoc raw"""
    CenterLabels(this::ByRef1{TAxis}, center::Bool)::Nothing
Center axis labels.
If center = kTRUE axis labels will be centered (horizontal axes only) on the bin center. Default is to center on the primary tick marks This option does not make sense if there are more bins than tick marks
""" CenterLabels(this::ByRef1{TAxis}, center::Bool)

# Wrapper of void TAxis::CenterTitle(Bool_t)
@trydoc raw"""
    CenterTitle(this::ByRef1{TAxis}, center::Bool)::Nothing
Center axis title.
If center = kTRUE axis title will be centered default is right adjusted
""" CenterTitle(this::ByRef1{TAxis}, center::Bool)

# Wrapper of void TAxis::ChangeLabel(Int_t, Double_t, Double_t, Int_t, Int_t, Int_t, const TString &)
@trydoc raw"""
    ChangeLabel(this::ByRef1{TAxis}, labNum::Int32, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})::Nothing
Define new text attributes for the label number "labNum".
It allows to do a fine tuning of the labels. All the attributes can be changed, even the label text itself.

## Arguments

- **`labNum`** [in] 
    Number of the label to be changed, negative numbers thestart from the theend 
    
- **`labAngle`** [in] 
    New angle value 
    
- **`labSize`** [in] 
    New size (0 erase the label) 
    
- **`labAlign`** [in] 
    New alignment value 
    
- **`labColor`** [in] 
    New label color 
    
- **`labFont`** [in] 
    New label font 
    
- **`labText`** [in] 
    New label text
    

#### Notes:

- If an attribute should not be changed just give the value "-1".
- If labnum=0 the list of modified labels is reset.
- To erase a label set labSize to 0.
- If labText is not specified or is an empty string, the text label is not changed.
- To retrieve the number of axis labels use [TAxis!GetNlabels](@ref).
""" ChangeLabel(this::ByRef1{TAxis}, labNum::Int32, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})

# Wrapper of void TAxis::ChangeLabelByValue(Double_t, Double_t, Double_t, Int_t, Int_t, Int_t, const TString &)
@trydoc raw"""
    ChangeLabelByValue(this::ByRef1{TAxis}, labValue::Float64, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})::Nothing
Define new text attributes for the label value "labValue".
It allows to do a fine tuning of the labels. All the attributes can be changed, even the label text itself.

## Arguments

- **`labValue`** [in] 
    Axis value to be changed 
    
- **`labAngle`** [in] 
    New angle value 
    
- **`labSize`** [in] 
    New size (0 erase the label) 
    
- **`labAlign`** [in] 
    New alignment value 
    
- **`labColor`** [in] 
    New label color 
    
- **`labFont`** [in] 
    New label font 
    
- **`labText`** [in] 
    New label text
    

#### Notes:

- If an attribute should not be changed just give the value "-1".
- If labnum=0 the list of modified labels is reset.
- To erase a label set labSize to 0.
- If labText is not specified or is an empty string, the text label is not changed.
- To retrieve the number of axis labels use [TAxis!GetNlabels](@ref).
""" ChangeLabelByValue(this::ByRef1{TAxis}, labValue::Float64, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})

# Wrapper of const char * TAxis::ChooseTimeFormat(Double_t)
@trydoc raw"""
    ChooseTimeFormat(this::ByRef1{TAxis}, axislength::Float64)::ByCopy{String}
Choose a reasonable time format from the coordinates in the active pad and the number of divisions in this axis If orientation = "X", the horizontal axis of the pad will be used for ref.
If orientation = "Y", the vertical axis of the pad will be used for ref.
""" ChooseTimeFormat(this::ByRef1{TAxis}, axislength::Float64)

# Wrapper of void TAxis::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of Int_t TAxis::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TAxis}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to an axis.

""" DistancetoPrimitive(this::ByRef1{TAxis}, px::Int32, py::Int32)

# Wrapper of void TAxis::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TAxis}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed and the position where it is released. If the mouse position is outside the current axis range when it is released the axis is unzoomed with the corresponding proportions. Note that the mouse does not need to be in the pad or even canvas when it is released.
""" ExecuteEvent(this::ByRef1{TAxis}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TAxis::FindBin(const char *)
@trydoc raw"""
    FindBin(this::ByRef1{TAxis}, label::ByCopy{String})::Int32
Find bin number with label.
If the List of labels does not exist create it and make the axis alphanumeric If one wants just to add a single label- just call [TAxis!SetBinLabel](@ref) If label is not in the list of labels do the following depending on the bit TAxis!kCanExtend; of the axis.

- if the bit is set add the new label and if the number of labels exceeds the number of bins, double the number of bins via [TH1!LabelsInflate](@ref)
- if the bit is not set and the histogram has labels in each bin set the bit automatically and consider the histogram as alphanumeric if histogram has only some bins with labels then the histogram is not consider alphanumeric and return -1

-1 is returned only when the Axis has no parent histogram
""" FindBin(this::ByRef1{TAxis}, label::ByCopy{String})

# Wrapper of Int_t TAxis::FindBin(Double_t)
@trydoc raw"""
    FindBin(this::ByConstRef1{TAxis}, x::Float64)::Int32


""" FindBin(this::ByConstRef1{TAxis}, x::Float64)

# Wrapper of UInt_t TAxis::GetTimeOffset()
@trydoc raw"""
    GetTimeOffset(this::ByRef1{TAxis})::UInt32
Return the time offset in GMT.

""" GetTimeOffset(this::ByRef1{TAxis})

# Wrapper of void TAxis::ImportAttributes(const TAxis *)
@trydoc raw"""
    ImportAttributes(this::ByRef1{TAxis}, axis::ByConstPtr1{TAxis})::Nothing
Copy axis attributes to this.

""" ImportAttributes(this::ByRef1{TAxis}, axis::ByConstPtr1{TAxis})

# Wrapper of void TAxis::LabelsOption(Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Set option(s) to draw axis with labels option can be:
- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of TAxis & TAxis::operator=(const TAxis &)
@trydoc raw"""
    assign(this::ByRef1{TAxis}, ::ByConstRef1{TAxis})::CxxRef1{TAxis}
Assignment operator.

""" assign(this::ByRef1{TAxis}, ::ByConstRef1{TAxis})

# Wrapper of void TAxis::RotateTitle(Bool_t)
@trydoc raw"""
    RotateTitle(this::ByRef1{TAxis}, rotate::Bool)::Nothing
Rotate title by 180 degrees.
By default the title is drawn right adjusted. If rotate is TRUE, the title is left adjusted at the theend of the axis and rotated by 180 degrees
""" RotateTitle(this::ByRef1{TAxis}, rotate::Bool)

# Wrapper of void TAxis::Set(Int_t, const Double_t *)
@trydoc raw"""
    Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float64})::Nothing
Initialize axis with variable bins.

""" Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float64})

# Wrapper of void TAxis::Set(Int_t, const Float_t *)
@trydoc raw"""
    Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float32})::Nothing
Initialize axis with variable bins.

""" Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float32})

# Wrapper of void TAxis::Set(Int_t, Double_t, Double_t)
@trydoc raw"""
    Set(this::ByRef1{TAxis}, nbins::Int32, xmin::Float64, xmax::Float64)::Nothing
Initialize axis with fix bins.

""" Set(this::ByRef1{TAxis}, nbins::Int32, xmin::Float64, xmax::Float64)

# Wrapper of void TAxis::SetAlphanumeric(Bool_t)
@trydoc raw"""
    SetAlphanumeric(this::ByRef1{TAxis}, alphanumeric::Bool)::Nothing
Set axis alphanumeric.

""" SetAlphanumeric(this::ByRef1{TAxis}, alphanumeric::Bool)

# Wrapper of void TAxis::SetBinLabel(Int_t, const char *)
@trydoc raw"""
    SetBinLabel(this::ByRef1{TAxis}, bin::Int32, label::ByCopy{String})::Nothing
Set label for bin.
If no label list exists, it is created. If all the bins have labels, the axis becomes alphanumeric and extendable. New labels will not be added with the Fill method but will theend-up in the underflow bin. See documentation of [TAxis!FindBin(const char*)](@ref)
""" SetBinLabel(this::ByRef1{TAxis}, bin::Int32, label::ByCopy{String})

# Wrapper of void TAxis::SetCanExtend(Bool_t)
@trydoc raw"""
    SetCanExtend(this::ByRef1{TAxis}, canExtend::Bool)::Nothing


""" SetCanExtend(this::ByRef1{TAxis}, canExtend::Bool)

# Wrapper of void TAxis::SetDecimals(Bool_t)
@trydoc raw"""
    SetDecimals(this::ByRef1{TAxis}, dot::Bool)::Nothing
Sets the decimals flag By default, blank characters are stripped, and then the label is correctly aligned.
If the dot is the last character of the string, it is also stripped, unless this option is specified.
""" SetDecimals(this::ByRef1{TAxis}, dot::Bool)

# Wrapper of void TAxis::SetDefaults()
@trydoc raw"""
    SetDefaults(this::ByRef1{TAxis})::Nothing
Set axis default values (from [TStyle](@ref))

""" SetDefaults(this::ByRef1{TAxis})

# Wrapper of void TAxis::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of void TAxis::SetLimits(Double_t, Double_t)
@trydoc raw"""
    SetLimits(this::ByRef1{TAxis}, xmin::Float64, xmax::Float64)::Nothing


""" SetLimits(this::ByRef1{TAxis}, xmin::Float64, xmax::Float64)

# Wrapper of void TAxis::SetMoreLogLabels(Bool_t)
@trydoc raw"""
    SetMoreLogLabels(this::ByRef1{TAxis}, more::Bool)::Nothing
Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale and there is a small number of decades (<3).
The flag (in fBits) is passed to the drawing function [TGaxis!PaintAxis](@ref)
""" SetMoreLogLabels(this::ByRef1{TAxis}, more::Bool)

# Wrapper of void TAxis::SetNoAlphanumeric(Bool_t)
@trydoc raw"""
    SetNoAlphanumeric(this::ByRef1{TAxis}, noalpha::Bool)::Nothing


""" SetNoAlphanumeric(this::ByRef1{TAxis}, noalpha::Bool)

# Wrapper of void TAxis::SetNoExponent(Bool_t)
@trydoc raw"""
    SetNoExponent(this::ByRef1{TAxis}, noExponent::Bool)::Nothing
Set the NoExponent flag By default, an exponent of the form 10^N is used when the label value are either all very small or very large.
The flag (in fBits) is passed to the drawing function [TGaxis!PaintAxis](@ref)
""" SetNoExponent(this::ByRef1{TAxis}, noExponent::Bool)

# Wrapper of void TAxis::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TAxis}, obj::ByPtr1{TObject})::Nothing


""" SetParent(this::ByRef1{TAxis}, obj::ByPtr1{TObject})

# Wrapper of void TAxis::SetRange(Int_t, Int_t)
@trydoc raw"""
    SetRange(this::ByRef1{TAxis}, first::Int32, last::Int32)::Nothing
Set the viewing range for the axis using bin numbers.
## Arguments

- **`first`** 
    First bin of the range. 
    
- **`last`** 
    Last bin of the range. To set a range using the axis coordinates, use [TAxis!SetRangeUser](@ref).
    

If `first == last == 0` or if `first > last` or if the range specified does not intersect at all with the maximum available range `[0, fNbins + 1]`, then the viewing range is reset by removing the bit [TAxis!kAxisRange](@ref). In this case, the functions [TAxis!GetFirst()](@ref) and [TAxis!GetLast()](@ref) will return 1 and fNbins.

If the range specified partially intersects with `[0, fNbins + 1]`, then the intersection range is accepted. For instance, if `first == -2` and `last == fNbins`, the accepted range will be `[0, fNbins]` (`fFirst = 0` and `fLast = fNbins`).

###Note

For historical reasons, SetRange(0,0) resets the range even though bin 0 is technically reserved for the underflow; in order to set the range of the axis so that it only includes the underflow, use SetRange(-1,0).
""" SetRange(this::ByRef1{TAxis}, first::Int32, last::Int32)

# Wrapper of void TAxis::SetRangeUser(Double_t, Double_t)
@trydoc raw"""
    SetRangeUser(this::ByRef1{TAxis}, ufirst::Float64, ulast::Float64)::Nothing
Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is, the "natural" axis coordinates).
To set a range using the axis bin numbers, use [TAxis!SetRange](@ref).
""" SetRangeUser(this::ByRef1{TAxis}, ufirst::Float64, ulast::Float64)

# Wrapper of void TAxis::SetTicks(Option_t *)
@trydoc raw"""
    SetTicks(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Set ticks orientation.
option = "+" ticks drawn on the "positive side" (default) option = "-" ticks drawn on the "negative side" option = "+-" ticks drawn on both sides option = "" ticks will be drawn as whatever is defined as default. No bit is set internally.
""" SetTicks(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of void TAxis::SetTimeDisplay(Int_t)
@trydoc raw"""
    SetTimeDisplay(this::ByRef1{TAxis}, value::Int32)::Nothing


""" SetTimeDisplay(this::ByRef1{TAxis}, value::Int32)

# Wrapper of void TAxis::SetTimeFormat(const char *)
@trydoc raw"""
    SetTimeFormat(this::ByRef1{TAxis}, format::ByCopy{String})::Nothing
Change the format used for time plotting.
The format string for date and time use the same options as the one used in the standard strftime C function, i.e. : for date : 
```
     %a abbreviated weekday name
     %b abbreviated month name
     %d day of the month (01-31)
     %m month (01-12)
     %y year without century
```  for time : 
```
     %H hour (24-hour clock)
     %I hour (12-hour clock)
     %p local_ equivalent of AM or PM
     %M minute (00-59)
     %S seconds (00-61)
     %% %
```  This function allows also to define the time offset. It is done via F which should be appended at the theend of the format string. The time offset has the following format: 'yyyy-mm-dd hh:mm:ss' Example: 
```
     h = new TH1F("Test","h",3000,0.,200000.);
     h->GetXaxis()->SetTimeDisplay(1);
     h->GetXaxis()->SetTimeFormat("%d\/%m\/%y%F2000-02-28 13:00:01");
```  This defines the time format being "dd/mm/yy" and the time offset as the February 28th 2003 at 13:00:01

If F is not specified, the time offset used will be the one defined by: gStyle->SetTimeOffset. For example like that: 
```
     TDatime da(2003,02,28,12,00,00);
     gStyle->SetTimeOffset(da.Convert()); 
```
""" SetTimeFormat(this::ByRef1{TAxis}, format::ByCopy{String})

# Wrapper of void TAxis::SetTimeOffset(Double_t, Option_t *)
@trydoc raw"""
    SetTimeOffset(this::ByRef1{TAxis}, toffset::Float64, option::ByCopy{String})::Nothing
Change the time offset If option = "gmt", set display mode to GMT.

""" SetTimeOffset(this::ByRef1{TAxis}, toffset::Float64, option::ByCopy{String})

# Wrapper of void TAxis::UnZoom()
@trydoc raw"""
    UnZoom(this::ByRef1{TAxis})::Nothing
Reset first & last bin to the full range.

""" UnZoom(this::ByRef1{TAxis})

# Wrapper of void TAxis::ZoomOut(Double_t, Double_t)
@trydoc raw"""
    ZoomOut(this::ByRef1{TAxis}, factor::Float64, offset::Float64)::Nothing
Zoom out by a factor of 'factor' (default =2) uses previous zoom factor by default Keep center defined by 'offset' fixed ie.
-1 at left of current range, 0 in center, +1 at right
""" ZoomOut(this::ByRef1{TAxis}, factor::Float64, offset::Float64)

# Wrapper of void TVirtualViewer3D::AddCompositeOp(UInt_t)
@trydoc raw"""
    AddCompositeOp(this::ByRef1{TVirtualViewer3D}, operation::UInt32)::Nothing


""" AddCompositeOp(this::ByRef1{TVirtualViewer3D}, operation::UInt32)

# Wrapper of Int_t TVirtualViewer3D::AddObject(const TBuffer3D &, Bool_t *)
@trydoc raw"""
    AddObject(this::ByRef1{TVirtualViewer3D}, buffer::ByConstRef1{TBuffer3D}, addChildren::ByPtr2{Bool})::Int32


""" AddObject(this::ByRef1{TVirtualViewer3D}, buffer::ByConstRef1{TBuffer3D}, addChildren::ByPtr2{Bool})

# Wrapper of Int_t TVirtualViewer3D::AddObject(UInt_t, const TBuffer3D &, Bool_t *)
@trydoc raw"""
    AddObject(this::ByRef1{TVirtualViewer3D}, physicalID::UInt32, buffer::ByConstRef1{TBuffer3D}, addChildren::ByPtr2{Bool})::Int32


""" AddObject(this::ByRef1{TVirtualViewer3D}, physicalID::UInt32, buffer::ByConstRef1{TBuffer3D}, addChildren::ByPtr2{Bool})

# Wrapper of void TVirtualViewer3D::BeginScene()
@trydoc raw"""
    BeginScene(this::ByRef1{TVirtualViewer3D})::Nothing


""" BeginScene(this::ByRef1{TVirtualViewer3D})

# Wrapper of void TVirtualViewer3D::CloseComposite()
@trydoc raw"""
    CloseComposite(this::ByRef1{TVirtualViewer3D})::Nothing


""" CloseComposite(this::ByRef1{TVirtualViewer3D})

# Wrapper of void TVirtualViewer3D::DrawViewer()
@trydoc raw"""
    DrawViewer(this::ByRef1{TVirtualViewer3D})::Nothing


""" DrawViewer(this::ByRef1{TVirtualViewer3D})

# Wrapper of void TVirtualViewer3D::EndScene()
@trydoc raw"""
    EndScene(this::ByRef1{TVirtualViewer3D})::Nothing


""" EndScene(this::ByRef1{TVirtualViewer3D})

# Wrapper of void TVirtualViewer3D::ObjectPaint(TObject *, Option_t *)
@trydoc raw"""
    ObjectPaint(this::ByRef1{TVirtualViewer3D}, ::ByPtr1{TObject}, ::ByCopy{String})::Nothing


""" ObjectPaint(this::ByRef1{TVirtualViewer3D}, ::ByPtr1{TObject}, ::ByCopy{String})

# Wrapper of Bool_t TVirtualViewer3D::OpenComposite(const TBuffer3D &, Bool_t *)
@trydoc raw"""
    OpenComposite(this::ByRef1{TVirtualViewer3D}, buffer::ByConstRef1{TBuffer3D}, addChildren::ByPtr2{Bool})::Bool


""" OpenComposite(this::ByRef1{TVirtualViewer3D}, buffer::ByConstRef1{TBuffer3D}, addChildren::ByPtr2{Bool})

# Wrapper of void TVirtualViewer3D::PadPaint(TVirtualPad *)
@trydoc raw"""
    PadPaint(this::ByRef1{TVirtualViewer3D}, ::ByPtr1{TVirtualPad})::Nothing


""" PadPaint(this::ByRef1{TVirtualViewer3D}, ::ByPtr1{TVirtualPad})

# Wrapper of void TVirtualViewer3D::PrintObjects()
@trydoc raw"""
    PrintObjects(this::ByRef1{TVirtualViewer3D})::Nothing


""" PrintObjects(this::ByRef1{TVirtualViewer3D})

# Wrapper of void TVirtualViewer3D::ResetCameras()
@trydoc raw"""
    ResetCameras(this::ByRef1{TVirtualViewer3D})::Nothing


""" ResetCameras(this::ByRef1{TVirtualViewer3D})

# Wrapper of void TVirtualViewer3D::ResetCamerasAfterNextUpdate()
@trydoc raw"""
    ResetCamerasAfterNextUpdate(this::ByRef1{TVirtualViewer3D})::Nothing


""" ResetCamerasAfterNextUpdate(this::ByRef1{TVirtualViewer3D})

# Wrapper of TObject * TVirtualViewer3D::SelectObject(Int_t, Int_t)
@trydoc raw"""
    SelectObject(this::ByRef1{TVirtualViewer3D}, ::Int32, ::Int32)::CxxPtr1{TObject}


""" SelectObject(this::ByRef1{TVirtualViewer3D}, ::Int32, ::Int32)

# Wrapper of void TVirtualViewer3D::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualViewer3D}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TVirtualViewer3D}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualViewer3D::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualViewer3D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualViewer3D}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPadPainter::ClearDrawable()
@trydoc raw"""
    ClearDrawable(this::ByRef1{TVirtualPadPainter})::Nothing


""" ClearDrawable(this::ByRef1{TVirtualPadPainter})

# Wrapper of void TVirtualPadPainter::CopyDrawable(Int_t, Int_t, Int_t)
@trydoc raw"""
    CopyDrawable(this::ByRef1{TVirtualPadPainter}, device::Int32, px::Int32, py::Int32)::Nothing


""" CopyDrawable(this::ByRef1{TVirtualPadPainter}, device::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TVirtualPadPainter::CreateDrawable(UInt_t, UInt_t)
@trydoc raw"""
    CreateDrawable(this::ByRef1{TVirtualPadPainter}, w::UInt32, h::UInt32)::Int32


""" CreateDrawable(this::ByRef1{TVirtualPadPainter}, w::UInt32, h::UInt32)

# Wrapper of void TVirtualPadPainter::DestroyDrawable(Int_t)
@trydoc raw"""
    DestroyDrawable(this::ByRef1{TVirtualPadPainter}, device::Int32)::Nothing


""" DestroyDrawable(this::ByRef1{TVirtualPadPainter}, device::Int32)

# Wrapper of void TVirtualPadPainter::DrawFillArea(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    DrawFillArea(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})::Nothing


""" DrawFillArea(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})

# Wrapper of void TVirtualPadPainter::DrawFillArea(Int_t, const Float_t *, const Float_t *)
@trydoc raw"""
    DrawFillArea(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32})::Nothing


""" DrawFillArea(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32})

# Wrapper of void TVirtualPadPainter::DrawLine(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DrawLine(this::ByRef1{TVirtualPadPainter}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Nothing


""" DrawLine(this::ByRef1{TVirtualPadPainter}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)

# Wrapper of void TVirtualPadPainter::DrawLineNDC(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DrawLineNDC(this::ByRef1{TVirtualPadPainter}, u1::Float64, v1::Float64, u2::Float64, v2::Float64)::Nothing


""" DrawLineNDC(this::ByRef1{TVirtualPadPainter}, u1::Float64, v1::Float64, u2::Float64, v2::Float64)

# Wrapper of void TVirtualPadPainter::DrawPixels(const unsigned char *, UInt_t, UInt_t, Int_t, Int_t, Bool_t)
@trydoc raw"""
    DrawPixels(this::ByRef1{TVirtualPadPainter}, pixelData::ByConstPtr1{unsigned Int8}, width::UInt32, height::UInt32, dstX::Int32, dstY::Int32, enableAlphaBlending::Bool)::Nothing


""" DrawPixels(this::ByRef1{TVirtualPadPainter}, pixelData::ByConstPtr1{unsigned Int8}, width::UInt32, height::UInt32, dstX::Int32, dstY::Int32, enableAlphaBlending::Bool)

# Wrapper of void TVirtualPadPainter::DrawPolyLine(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    DrawPolyLine(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})::Nothing


""" DrawPolyLine(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})

# Wrapper of void TVirtualPadPainter::DrawPolyLine(Int_t, const Float_t *, const Float_t *)
@trydoc raw"""
    DrawPolyLine(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32})::Nothing


""" DrawPolyLine(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32})

# Wrapper of void TVirtualPadPainter::DrawPolyLineNDC(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    DrawPolyLineNDC(this::ByRef1{TVirtualPadPainter}, n::Int32, u::ByConstPtr2{Float64}, v::ByConstPtr2{Float64})::Nothing


""" DrawPolyLineNDC(this::ByRef1{TVirtualPadPainter}, n::Int32, u::ByConstPtr2{Float64}, v::ByConstPtr2{Float64})

# Wrapper of void TVirtualPadPainter::DrawPolyMarker(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})::Nothing


""" DrawPolyMarker(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})

# Wrapper of void TVirtualPadPainter::DrawPolyMarker(Int_t, const Float_t *, const Float_t *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32})::Nothing


""" DrawPolyMarker(this::ByRef1{TVirtualPadPainter}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32})

# Wrapper of void TVirtualPadPainter::InitPainter()
@trydoc raw"""
    InitPainter(this::ByRef1{TVirtualPadPainter})::Nothing
Empty definition.

""" InitPainter(this::ByRef1{TVirtualPadPainter})

# Wrapper of void TVirtualPadPainter::InvalidateCS()
@trydoc raw"""
    InvalidateCS(this::ByRef1{TVirtualPadPainter})::Nothing
Empty definition.

""" InvalidateCS(this::ByRef1{TVirtualPadPainter})

# Wrapper of void TVirtualPadPainter::LockPainter()
@trydoc raw"""
    LockPainter(this::ByRef1{TVirtualPadPainter})::Nothing
Empty definition.

""" LockPainter(this::ByRef1{TVirtualPadPainter})

# Wrapper of void TVirtualPadPainter::SelectDrawable(Int_t)
@trydoc raw"""
    SelectDrawable(this::ByRef1{TVirtualPadPainter}, device::Int32)::Nothing


""" SelectDrawable(this::ByRef1{TVirtualPadPainter}, device::Int32)

# Wrapper of void TVirtualPadPainter::SetFillColor(Color_t)
@trydoc raw"""
    SetFillColor(this::ByRef1{TVirtualPadPainter}, fcolor::Int16)::Nothing


""" SetFillColor(this::ByRef1{TVirtualPadPainter}, fcolor::Int16)

# Wrapper of void TVirtualPadPainter::SetFillStyle(Style_t)
@trydoc raw"""
    SetFillStyle(this::ByRef1{TVirtualPadPainter}, fstyle::Int16)::Nothing


""" SetFillStyle(this::ByRef1{TVirtualPadPainter}, fstyle::Int16)

# Wrapper of void TVirtualPadPainter::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TVirtualPadPainter}, lcolor::Int16)::Nothing


""" SetLineColor(this::ByRef1{TVirtualPadPainter}, lcolor::Int16)

# Wrapper of void TVirtualPadPainter::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TVirtualPadPainter}, lstyle::Int16)::Nothing


""" SetLineStyle(this::ByRef1{TVirtualPadPainter}, lstyle::Int16)

# Wrapper of void TVirtualPadPainter::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TVirtualPadPainter}, lwidth::Int16)::Nothing


""" SetLineWidth(this::ByRef1{TVirtualPadPainter}, lwidth::Int16)

# Wrapper of void TVirtualPadPainter::SetOpacity(Int_t)
@trydoc raw"""
    SetOpacity(this::ByRef1{TVirtualPadPainter}, percent::Int32)::Nothing


""" SetOpacity(this::ByRef1{TVirtualPadPainter}, percent::Int32)

# Wrapper of void TVirtualPadPainter::SetTextAlign(Short_t)
@trydoc raw"""
    SetTextAlign(this::ByRef1{TVirtualPadPainter}, align::Int16)::Nothing


""" SetTextAlign(this::ByRef1{TVirtualPadPainter}, align::Int16)

# Wrapper of void TVirtualPadPainter::SetTextAngle(Float_t)
@trydoc raw"""
    SetTextAngle(this::ByRef1{TVirtualPadPainter}, tangle::Float32)::Nothing


""" SetTextAngle(this::ByRef1{TVirtualPadPainter}, tangle::Float32)

# Wrapper of void TVirtualPadPainter::SetTextColor(Color_t)
@trydoc raw"""
    SetTextColor(this::ByRef1{TVirtualPadPainter}, tcolor::Int16)::Nothing


""" SetTextColor(this::ByRef1{TVirtualPadPainter}, tcolor::Int16)

# Wrapper of void TVirtualPadPainter::SetTextFont(Font_t)
@trydoc raw"""
    SetTextFont(this::ByRef1{TVirtualPadPainter}, tfont::Int16)::Nothing


""" SetTextFont(this::ByRef1{TVirtualPadPainter}, tfont::Int16)

# Wrapper of void TVirtualPadPainter::SetTextSize(Float_t)
@trydoc raw"""
    SetTextSize(this::ByRef1{TVirtualPadPainter}, tsize::Float32)::Nothing


""" SetTextSize(this::ByRef1{TVirtualPadPainter}, tsize::Float32)

# Wrapper of void TVirtualPadPainter::SetTextSizePixels(Int_t)
@trydoc raw"""
    SetTextSizePixels(this::ByRef1{TVirtualPadPainter}, npixels::Int32)::Nothing


""" SetTextSizePixels(this::ByRef1{TVirtualPadPainter}, npixels::Int32)

# Wrapper of void TVirtualPadPainter::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualPadPainter}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualPadPainter}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualPadPainter::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualPadPainter}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualPadPainter}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPerfStats::FileEvent(const char *, const char *, const char *, const char *, Bool_t)
@trydoc raw"""
    FileEvent(this::ByRef1{TVirtualPerfStats}, slave::ByCopy{String}, slavename::ByCopy{String}, nodename::ByCopy{String}, filename::ByCopy{String}, isStart::Bool)::Nothing


""" FileEvent(this::ByRef1{TVirtualPerfStats}, slave::ByCopy{String}, slavename::ByCopy{String}, nodename::ByCopy{String}, filename::ByCopy{String}, isStart::Bool)

# Wrapper of void TVirtualPerfStats::FileOpenEvent(TFile *, const char *, Double_t)
@trydoc raw"""
    FileOpenEvent(this::ByRef1{TVirtualPerfStats}, file::ByPtr1{TFile}, filename::ByCopy{String}, thestart::Float64)::Nothing


""" FileOpenEvent(this::ByRef1{TVirtualPerfStats}, file::ByPtr1{TFile}, filename::ByCopy{String}, thestart::Float64)

# Wrapper of void TVirtualPerfStats::FileReadEvent(TFile *, Int_t, Double_t)
@trydoc raw"""
    FileReadEvent(this::ByRef1{TVirtualPerfStats}, file::ByPtr1{TFile}, len::Int32, thestart::Float64)::Nothing


""" FileReadEvent(this::ByRef1{TVirtualPerfStats}, file::ByPtr1{TFile}, len::Int32, thestart::Float64)

# Wrapper of void TVirtualPerfStats::PacketEvent(const char *, const char *, const char *, Long64_t, Double_t, Double_t, Double_t, Long64_t)
@trydoc raw"""
    PacketEvent(this::ByRef1{TVirtualPerfStats}, slave::ByCopy{String}, slavename::ByCopy{String}, filename::ByCopy{String}, eventsprocessed::Int64, latency::Float64, proctime::Float64, cputime::Float64, bytesRead::Int64)::Nothing


""" PacketEvent(this::ByRef1{TVirtualPerfStats}, slave::ByCopy{String}, slavename::ByCopy{String}, filename::ByCopy{String}, eventsprocessed::Int64, latency::Float64, proctime::Float64, cputime::Float64, bytesRead::Int64)

# Wrapper of void TVirtualPerfStats::RateEvent(Double_t, Double_t, Long64_t, Long64_t)
@trydoc raw"""
    RateEvent(this::ByRef1{TVirtualPerfStats}, proctime::Float64, deltatime::Float64, eventsprocessed::Int64, bytesRead::Int64)::Nothing


""" RateEvent(this::ByRef1{TVirtualPerfStats}, proctime::Float64, deltatime::Float64, eventsprocessed::Int64, bytesRead::Int64)

# Wrapper of void TVirtualPerfStats::SetBytesRead(Long64_t)
@trydoc raw"""
    SetBytesRead(this::ByRef1{TVirtualPerfStats}, num::Int64)::Nothing


""" SetBytesRead(this::ByRef1{TVirtualPerfStats}, num::Int64)

# Wrapper of void TVirtualPerfStats::SetLoaded(size_t, size_t)
@trydoc raw"""
    SetLoaded(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)::Nothing


""" SetLoaded(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetLoaded(TBranch *, size_t)
@trydoc raw"""
    SetLoaded(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)::Nothing


""" SetLoaded(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetLoadedMiss(size_t, size_t)
@trydoc raw"""
    SetLoadedMiss(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)::Nothing


""" SetLoadedMiss(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetLoadedMiss(TBranch *, size_t)
@trydoc raw"""
    SetLoadedMiss(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)::Nothing


""" SetLoadedMiss(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetMissed(size_t, size_t)
@trydoc raw"""
    SetMissed(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)::Nothing


""" SetMissed(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetMissed(TBranch *, size_t)
@trydoc raw"""
    SetMissed(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)::Nothing


""" SetMissed(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetNumEvents(Long64_t)
@trydoc raw"""
    SetNumEvents(this::ByRef1{TVirtualPerfStats}, num::Int64)::Nothing


""" SetNumEvents(this::ByRef1{TVirtualPerfStats}, num::Int64)

# Wrapper of void TVirtualPerfStats::SetUsed(size_t, size_t)
@trydoc raw"""
    SetUsed(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)::Nothing


""" SetUsed(this::ByRef1{TVirtualPerfStats}, bi::Int64, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::SetUsed(TBranch *, size_t)
@trydoc raw"""
    SetUsed(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)::Nothing


""" SetUsed(this::ByRef1{TVirtualPerfStats}, b::ByPtr1{TBranch}, basketNumber::Int64)

# Wrapper of void TVirtualPerfStats::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualPerfStats}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TVirtualPerfStats}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualPerfStats::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualPerfStats}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualPerfStats}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPerfStats::UnzipEvent(TObject *, Long64_t, Double_t, Int_t, Int_t)
@trydoc raw"""
    UnzipEvent(this::ByRef1{TVirtualPerfStats}, tree::ByPtr1{TObject}, pos::Int64, thestart::Float64, complen::Int32, objlen::Int32)::Nothing


""" UnzipEvent(this::ByRef1{TVirtualPerfStats}, tree::ByPtr1{TObject}, pos::Int64, thestart::Float64, complen::Int32, objlen::Int32)

# Wrapper of void TVirtualPerfStats::UpdateBranchIndices(TObjArray *)
@trydoc raw"""
    UpdateBranchIndices(this::ByRef1{TVirtualPerfStats}, branches::ByPtr1{TObjArray})::Nothing


""" UpdateBranchIndices(this::ByRef1{TVirtualPerfStats}, branches::ByPtr1{TObjArray})

# Wrapper of void TBranch::AddLastBasket(Long64_t)
@trydoc raw"""
    AddLastBasket(this::ByRef1{TBranch}, startEntry::Int64)::Nothing
Add the thestart entry of the write basket (not yet created)

""" AddLastBasket(this::ByRef1{TBranch}, startEntry::Int64)

# Wrapper of Int_t TBranch::BackFill()
@trydoc raw"""
    BackFill(this::ByRef1{TBranch})::Int32
Loop on all leaves of this branch to back fill Basket buffer.
Use this routine instead of [TBranch!Fill](@ref) when filling a branch individually to catch up with the number of entries already in the [TTree](@ref).

First it calls [TBranch!Fill](@ref) and then if the number of entries of the branch reach one of [TTree](@ref) cluster's boundary, the basket is flushed.

The function returns the number of bytes committed to the memory basket. If a write error occurs, the number of bytes returned is -1. If no data are written, because e.g. the branch is disabled, the number of bytes returned is 0.

To insure that the baskets of each cluster are located close by in the file, when back-filling multiple branches make sure to call BackFill for the same entry for all the branches consecutively 

    for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.
      for( auto branch : branchCollection) {
         ... Make change to the data associated with the branch ...
         branch->BackFill();
      }
    }
    // Since we loop over all the branches for each new entry
    // all the baskets for a cluster are consecutive in the file.

(C++ version of the code)

 rather than doing all the entries of one branch at a time. 

    // Do NOT do things in the following order, it will lead to
    // poorly clustered files.
    for(auto branch : branchCollection) {
      for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.
         ... Make change to the data associated with the branch ...
         branch->BackFill();
      }
    }
    // Since we loop over all the entries for one branch
    // all the baskets for that branch are consecutive.

(C++ version of the code)
""" BackFill(this::ByRef1{TBranch})

# Wrapper of void TBranch::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TBranch}, b::ByPtr1{TBrowser})::Nothing
Browser interface.

""" Browse(this::ByRef1{TBranch}, b::ByPtr1{TBrowser})

# Wrapper of void TBranch::DeleteBaskets(Option_t *)
@trydoc raw"""
    DeleteBaskets(this::ByRef1{TBranch}, option::ByCopy{String})::Nothing
Loop on all branch baskets.
If the file where branch buffers reside is writable, free the disk space associated to the baskets of the branch, then call [Reset()](@ref). If the option contains "all", delete also the baskets for the subbranches. The branch is reset.

NOTE that this function must be used with extreme care. Deleting branch baskets fragments the file and may introduce inefficiencies when adding new entries in the Tree or later on when reading the Tree.
""" DeleteBaskets(this::ByRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::DropBaskets(Option_t *)
@trydoc raw"""
    DropBaskets(this::ByRef1{TBranch}, option::ByCopy{String})::Nothing
Loop on all branch baskets.
Drop all baskets from memory except readbasket. If the option contains "all", drop all baskets including read- and write-baskets (unless they are not stored individually on disk). The option "all" also lead to DropBaskets being called on the sub-branches.
""" DropBaskets(this::ByRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::ExpandBasketArrays()
@trydoc raw"""
    ExpandBasketArrays(this::ByRef1{TBranch})::Nothing
Increase BasketEntry buffer of a minimum of 10 locations and a maximum of 50 per cent of current size.

""" ExpandBasketArrays(this::ByRef1{TBranch})

# Wrapper of Int_t TBranch::Fill()
@trydoc raw"""
    Fill(this::ByRef1{TBranch})::Int32


""" Fill(this::ByRef1{TBranch})

# Wrapper of TBranch * TBranch::FindBranch(const char *)
@trydoc raw"""
    FindBranch(this::ByRef1{TBranch}, name::ByCopy{String})::CxxPtr1{TBranch}
Find the immediate sub-branch with passed name.

""" FindBranch(this::ByRef1{TBranch}, name::ByCopy{String})

# Wrapper of TLeaf * TBranch::FindLeaf(const char *)
@trydoc raw"""
    FindLeaf(this::ByRef1{TBranch}, name::ByCopy{String})::CxxPtr1{TLeaf}
Find the leaf corresponding to the name 'searchname'.

""" FindLeaf(this::ByRef1{TBranch}, name::ByCopy{String})

# Wrapper of Int_t TBranch::FlushBaskets()
@trydoc raw"""
    FlushBaskets(this::ByRef1{TBranch})::Int32
Flush to disk all the baskets of this branch and any of subbranches.
Return the number of bytes written or -1 in case of write error.
""" FlushBaskets(this::ByRef1{TBranch})

# Wrapper of Int_t TBranch::FlushOneBasket(UInt_t)
@trydoc raw"""
    FlushOneBasket(this::ByRef1{TBranch}, which::UInt32)::Int32
If we have a write basket in memory and it contains some entries and has not yet been written to disk, we write it and delete it from memory.
Return the number of bytes written;
""" FlushOneBasket(this::ByRef1{TBranch}, which::UInt32)

# Wrapper of TList * TBranch::GetBrowsables()
@trydoc raw"""
    GetBrowsables(this::ByRef1{TBranch})::CxxPtr1{TList}
Returns (and, if 0, creates) browsable objects for this branch See [TVirtualBranchBrowsable!FillListOfBrowsables](@ref).
""" GetBrowsables(this::ByRef1{TBranch})

# Wrapper of Int_t TBranch::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TBranch}, entry::Int64, getall::Int32)::Int32
Read all leaves of entry and return total number of bytes read.
The input argument "entry" is the entry number in the current tree. In case of a [TChain](@ref), the entry number in the current Tree must be found before calling this function. For example:

    TChain* chain = ...;
    Long64_t localEntry = chain->LoadTree(entry);
    branch->GetEntry(localEntry);

(C++ version of the code)

The function returns the number of bytes read from the input buffer. If entry does not exist, the function returns 0. If an I/O error occurs, the function returns -1.

See IMPORTANT REMARKS in [TTree!GetEntry](@ref).
""" GetEntry(this::ByRef1{TBranch}, entry::Int64, getall::Int32)

# Wrapper of Int_t TBranch::GetEntryExport(Long64_t, Int_t, TClonesArray *, Int_t)
@trydoc raw"""
    GetEntryExport(this::ByRef1{TBranch}, entry::Int64, getall::Int32, list::ByPtr1{TClonesArray}, n::Int32)::Int32
Read all leaves of an entry and export buffers to real objects in a [TClonesArray](@ref) list.
Returns total number of bytes read.
""" GetEntryExport(this::ByRef1{TBranch}, entry::Int64, getall::Int32, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of Int_t TBranch::GetEvent(Long64_t)
@trydoc raw"""
    GetEvent(this::ByRef1{TBranch}, entry::Int64)::Int32


""" GetEvent(this::ByRef1{TBranch}, entry::Int64)

# Wrapper of Int_t TBranch::GetExpectedType(TClass *&, EDataType &)
@trydoc raw"""
    GetExpectedType(this::ByRef1{TBranch}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})::Int32
Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure.

""" GetExpectedType(this::ByRef1{TBranch}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})

# Wrapper of TFile * TBranch::GetFile(Int_t)
@trydoc raw"""
    GetFile(this::ByRef1{TBranch}, mode::Int32)::CxxPtr1{TFile}
Return pointer to the file where branch buffers reside, returns 0 in case branch buffers reside in the same file as tree header.
If mode is 1 the branch buffer file is recreated.
""" GetFile(this::ByRef1{TBranch}, mode::Int32)

# Wrapper of TObjArray * TBranch::GetListOfBaskets()
@trydoc raw"""
    GetListOfBaskets(this::ByRef1{TBranch})::CxxPtr1{TObjArray}


""" GetListOfBaskets(this::ByRef1{TBranch})

# Wrapper of TObjArray * TBranch::GetListOfBranches()
@trydoc raw"""
    GetListOfBranches(this::ByRef1{TBranch})::CxxPtr1{TObjArray}


""" GetListOfBranches(this::ByRef1{TBranch})

# Wrapper of TObjArray * TBranch::GetListOfLeaves()
@trydoc raw"""
    GetListOfLeaves(this::ByRef1{TBranch})::CxxPtr1{TObjArray}


""" GetListOfLeaves(this::ByRef1{TBranch})

# Wrapper of Int_t TBranch::GetRow(Int_t)
@trydoc raw"""
    GetRow(this::ByRef1{TBranch}, row::Int32)::Int32
Return all elements of one row unpacked in internal array fValues [Actually just returns 1 (?)].

""" GetRow(this::ByRef1{TBranch}, row::Int32)

# Wrapper of TBuffer * TBranch::GetTransientBuffer(Int_t)
@trydoc raw"""
    GetTransientBuffer(this::ByRef1{TBranch}, size::Int32)::CxxPtr1{TBuffer}
Returns the transient buffer currently used by this [TBranch](@ref) for reading/writing baskets.

""" GetTransientBuffer(this::ByRef1{TBranch}, size::Int32)

# Wrapper of void TBranch::KeepCircular(Long64_t)
@trydoc raw"""
    KeepCircular(this::ByRef1{TBranch}, maxEntries::Int64)::Nothing
keep a maximum of fMaxEntries in memory

""" KeepCircular(this::ByRef1{TBranch}, maxEntries::Int64)

# Wrapper of Int_t TBranch::LoadBaskets()
@trydoc raw"""
    LoadBaskets(this::ByRef1{TBranch})::Int32
Baskets associated to this branch are forced to be in memory.
You can call TTree!SetMaxVirtualSize(maxmemory) to instruct the system that the total size of the imported baskets does not exceed maxmemory bytes.

The function returns the number of baskets that have been put in memory. This method may be called to force all baskets of one or more branches in memory when random access to entries in this branch is required. See also [TTree!LoadBaskets](@ref) to load all baskets of all branches in memory.
""" LoadBaskets(this::ByRef1{TBranch})

# Wrapper of void TBranch::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TBranch}, b::ByRef1{TBuffer})::Nothing
Loop on all leaves of this branch to read Basket buffer.

""" ReadBasket(this::ByRef1{TBranch}, b::ByRef1{TBuffer})

# Wrapper of void TBranch::Refresh(TBranch *)
@trydoc raw"""
    Refresh(this::ByRef1{TBranch}, b::ByPtr1{TBranch})::Nothing
Refresh this branch using new information in b This function is called by [TTree!Refresh](@ref).
""" Refresh(this::ByRef1{TBranch}, b::ByPtr1{TBranch})

# Wrapper of void TBranch::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TBranch}, option::ByCopy{String})::Nothing
Reset a Branch.
- Existing buffers are deleted.
- Entries, max and min are reset.
""" Reset(this::ByRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::ResetAddress()
@trydoc raw"""
    ResetAddress(this::ByRef1{TBranch})::Nothing
Reset the address of the branch.

""" ResetAddress(this::ByRef1{TBranch})

# Wrapper of void TBranch::ResetReadEntry()
@trydoc raw"""
    ResetReadEntry(this::ByRef1{TBranch})::Nothing


""" ResetReadEntry(this::ByRef1{TBranch})

# Wrapper of void TBranch::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TBranch}, add::ByPtr2{Nothing})::Nothing
Set address of this branch.

""" SetAddress(this::ByRef1{TBranch}, add::ByPtr2{Nothing})

# Wrapper of void TBranch::SetAutoDelete(bool)
@trydoc raw"""
    SetAutoDelete(this::ByRef1{TBranch}, autodel::Bool)::Nothing
Set the automatic delete bit.
This bit is used by [TBranchObject!ReadBasket](@ref) to decide if an object referenced by a [TBranchObject](@ref) must be deleted or not before reading a new entry.

If autodel is true, this existing object will be deleted, a new object created by the default constructor, then read from disk by the streamer.

If autodel is false, the existing object is not deleted. Root assumes that the user is taking care of deleting any internal object or array (this can be done in the streamer).
""" SetAutoDelete(this::ByRef1{TBranch}, autodel::Bool)

# Wrapper of void TBranch::SetBasketSize(Int_t)
@trydoc raw"""
    SetBasketSize(this::ByRef1{TBranch}, buffsize::Int32)::Nothing
Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen.

""" SetBasketSize(this::ByRef1{TBranch}, buffsize::Int32)

# Wrapper of void TBranch::SetBufferAddress(TBuffer *)
@trydoc raw"""
    SetBufferAddress(this::ByRef1{TBranch}, entryBuffer::ByPtr1{TBuffer})::Nothing
Set address of this branch directly from a [TBuffer](@ref) to avoid streaming.
Note: We do not take ownership of the buffer.
""" SetBufferAddress(this::ByRef1{TBranch}, entryBuffer::ByPtr1{TBuffer})

# Wrapper of void TBranch::SetCompressionAlgorithm(Int_t)
@trydoc raw"""
    SetCompressionAlgorithm(this::ByRef1{TBranch}, algorithm::Int32)::Nothing
Set compression algorithm.

""" SetCompressionAlgorithm(this::ByRef1{TBranch}, algorithm::Int32)

# Wrapper of void TBranch::SetCompressionLevel(Int_t)
@trydoc raw"""
    SetCompressionLevel(this::ByRef1{TBranch}, level::Int32)::Nothing
Set compression level.

""" SetCompressionLevel(this::ByRef1{TBranch}, level::Int32)

# Wrapper of void TBranch::SetCompressionSettings(Int_t)
@trydoc raw"""
    SetCompressionSettings(this::ByRef1{TBranch}, settings::Int32)::Nothing
Set compression settings.

""" SetCompressionSettings(this::ByRef1{TBranch}, settings::Int32)

# Wrapper of void TBranch::SetEntries(Long64_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TBranch}, entries::Int64)::Nothing
Set the number of entries in this branch.

""" SetEntries(this::ByRef1{TBranch}, entries::Int64)

# Wrapper of void TBranch::SetEntryOffsetLen(Int_t, bool)
@trydoc raw"""
    SetEntryOffsetLen(this::ByRef1{TBranch}, len::Int32, updateSubBranches::Bool)::Nothing
Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches.

""" SetEntryOffsetLen(this::ByRef1{TBranch}, len::Int32, updateSubBranches::Bool)

# Wrapper of void TBranch::SetFile(const char *)
@trydoc raw"""
    SetFile(this::ByRef1{TBranch}, filename::ByCopy{String})::Nothing
Set file where this branch writes/reads its buffers.
By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch files to a different location in the file system and still access the branch files. The [ROOT](@ref) file will be connected only when necessary. If called by [TBranch!Fill](@ref) (via [TBasket!WriteFile](@ref)), the file will be created with the option "recreate". If called by [TBranch!GetEntry](@ref) (via [TBranch!GetBasket](@ref)), the file will be opened in read mode. To open a file in "update" mode or with a certain compression level, use [TBranch!SetFile(TFile *file)](@ref).
""" SetFile(this::ByRef1{TBranch}, filename::ByCopy{String})

# Wrapper of void TBranch::SetFile(TFile *)
@trydoc raw"""
    SetFile(this::ByRef1{TBranch}, file::ByPtr1{TFile})::Nothing
Set file where this branch writes/reads its buffers.
By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. or root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch files to a different location in the file system and still access the branch files. The [ROOT](@ref) file will be connected only when necessary. If called by [TBranch!Fill](@ref) (via [TBasket!WriteFile](@ref)), the file will be created with the option "recreate". If called by [TBranch!GetEntry](@ref) (via [TBranch!GetBasket](@ref)), the file will be opened in read mode. To open a file in "update" mode or with a certain compression level, use [TBranch!SetFile(TFile *file)](@ref).
""" SetFile(this::ByRef1{TBranch}, file::ByPtr1{TFile})

# Wrapper of void TBranch::SetFirstEntry(Long64_t)
@trydoc raw"""
    SetFirstEntry(this::ByRef1{TBranch}, entry::Int64)::Nothing
set the first entry number (case of [TBranchSTL](@ref))

""" SetFirstEntry(this::ByRef1{TBranch}, entry::Int64)

# Wrapper of bool TBranch::SetMakeClass(bool)
@trydoc raw"""
    SetMakeClass(this::ByRef1{TBranch}, decomposeObj::Bool)::Bool
Set the branch in a mode where the object are decomposed (Also known as MakeClass mode).
Return whether the setting was possible (it is not possible for [TBranch](@ref) and [TBranchObject](@ref)).
""" SetMakeClass(this::ByRef1{TBranch}, decomposeObj::Bool)

# Wrapper of void TBranch::SetObject(void *)
@trydoc raw"""
    SetObject(this::ByRef1{TBranch}, objadd::ByPtr2{Nothing})::Nothing
Set object this branch is pointing to.

""" SetObject(this::ByRef1{TBranch}, objadd::ByPtr2{Nothing})

# Wrapper of void TBranch::SetOffset(Int_t)
@trydoc raw"""
    SetOffset(this::ByRef1{TBranch}, offset::Int32)::Nothing


""" SetOffset(this::ByRef1{TBranch}, offset::Int32)

# Wrapper of void TBranch::SetStatus(bool)
@trydoc raw"""
    SetStatus(this::ByRef1{TBranch}, status::Bool)::Nothing
Set branch status to Process or DoNotProcess.

""" SetStatus(this::ByRef1{TBranch}, status::Bool)

# Wrapper of void TBranch::SetTree(TTree *)
@trydoc raw"""
    SetTree(this::ByRef1{TBranch}, tree::ByPtr1{TTree})::Nothing


""" SetTree(this::ByRef1{TBranch}, tree::ByPtr1{TTree})

# Wrapper of void TBranch::SetupAddresses()
@trydoc raw"""
    SetupAddresses(this::ByRef1{TBranch})::Nothing
If the branch address is not set, we set all addresses starting with the top level parent branch.

""" SetupAddresses(this::ByRef1{TBranch})

# Wrapper of void TBranch::UpdateAddress()
@trydoc raw"""
    UpdateAddress(this::ByRef1{TBranch})::Nothing


""" UpdateAddress(this::ByRef1{TBranch})

# Wrapper of void TBranch::UpdateFile()
@trydoc raw"""
    UpdateFile(this::ByRef1{TBranch})::Nothing
Refresh the value of fDirectory (i.e.
where this branch writes/reads its buffers) with the current value of fTree->GetCurrentFile unless this branch has been redirected to a different file. Also update the sub-branches.
""" UpdateFile(this::ByRef1{TBranch})

# Wrapper of void TVirtualPS::CellArrayBegin(Int_t, Int_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CellArrayBegin(this::ByRef1{TVirtualPS}, W::Int32, H::Int32, x1::Float64, x2::Float64, y1::Float64, y2::Float64)::Nothing


""" CellArrayBegin(this::ByRef1{TVirtualPS}, W::Int32, H::Int32, x1::Float64, x2::Float64, y1::Float64, y2::Float64)

# Wrapper of void TVirtualPS::CellArrayEnd()
@trydoc raw"""
    CellArrayEnd(this::ByRef1{TVirtualPS})::Nothing


""" CellArrayEnd(this::ByRef1{TVirtualPS})

# Wrapper of void TVirtualPS::CellArrayFill(Int_t, Int_t, Int_t)
@trydoc raw"""
    CellArrayFill(this::ByRef1{TVirtualPS}, r::Int32, g::Int32, b::Int32)::Nothing


""" CellArrayFill(this::ByRef1{TVirtualPS}, r::Int32, g::Int32, b::Int32)

# Wrapper of void TVirtualPS::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TVirtualPS}, opt::ByCopy{String})::Nothing


""" Close(this::ByRef1{TVirtualPS}, opt::ByCopy{String})

# Wrapper of void TVirtualPS::DrawBox(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DrawBox(this::ByRef1{TVirtualPS}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Nothing


""" DrawBox(this::ByRef1{TVirtualPS}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)

# Wrapper of void TVirtualPS::DrawFrame(Double_t, Double_t, Double_t, Double_t, Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    DrawFrame(this::ByRef1{TVirtualPS}, xl::Float64, yl::Float64, xt::Float64, yt::Float64, mode::Int32, border::Int32, dark::Int32, light::Int32)::Nothing


""" DrawFrame(this::ByRef1{TVirtualPS}, xl::Float64, yl::Float64, xt::Float64, yt::Float64, mode::Int32, border::Int32, dark::Int32, light::Int32)

# Wrapper of void TVirtualPS::DrawPolyMarker(Int_t, Double_t *, Double_t *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TVirtualPS}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64})::Nothing


""" DrawPolyMarker(this::ByRef1{TVirtualPS}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64})

# Wrapper of void TVirtualPS::DrawPolyMarker(Int_t, Float_t *, Float_t *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TVirtualPS}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32})::Nothing


""" DrawPolyMarker(this::ByRef1{TVirtualPS}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32})

# Wrapper of void TVirtualPS::DrawPS(Int_t, Double_t *, Double_t *)
@trydoc raw"""
    DrawPS(this::ByRef1{TVirtualPS}, n::Int32, xw::ByPtr2{Float64}, yw::ByPtr2{Float64})::Nothing


""" DrawPS(this::ByRef1{TVirtualPS}, n::Int32, xw::ByPtr2{Float64}, yw::ByPtr2{Float64})

# Wrapper of void TVirtualPS::DrawPS(Int_t, Float_t *, Float_t *)
@trydoc raw"""
    DrawPS(this::ByRef1{TVirtualPS}, n::Int32, xw::ByPtr2{Float32}, yw::ByPtr2{Float32})::Nothing


""" DrawPS(this::ByRef1{TVirtualPS}, n::Int32, xw::ByPtr2{Float32}, yw::ByPtr2{Float32})

# Wrapper of void TVirtualPS::NewPage()
@trydoc raw"""
    NewPage(this::ByRef1{TVirtualPS})::Nothing


""" NewPage(this::ByRef1{TVirtualPS})

# Wrapper of void TVirtualPS::Open(const char *, Int_t)
@trydoc raw"""
    Open(this::ByRef1{TVirtualPS}, filename::ByCopy{String}, type::Int32)::Nothing


""" Open(this::ByRef1{TVirtualPS}, filename::ByCopy{String}, type::Int32)

# Wrapper of void TVirtualPS::PrintFast(Int_t, const char *)
@trydoc raw"""
    PrintFast(this::ByRef1{TVirtualPS}, nch::Int32, string::ByCopy{String})::Nothing
Fast version of Print.

""" PrintFast(this::ByRef1{TVirtualPS}, nch::Int32, string::ByCopy{String})

# Wrapper of void TVirtualPS::PrintRaw(Int_t, const char *)
@trydoc raw"""
    PrintRaw(this::ByRef1{TVirtualPS}, len::Int32, str::ByCopy{String})::Nothing
Print a raw.

""" PrintRaw(this::ByRef1{TVirtualPS}, len::Int32, str::ByCopy{String})

# Wrapper of void TVirtualPS::PrintStr(const char *)
@trydoc raw"""
    PrintStr(this::ByRef1{TVirtualPS}, string::ByCopy{String})::Nothing
Output the string str in the output buffer.

""" PrintStr(this::ByRef1{TVirtualPS}, string::ByCopy{String})

# Wrapper of void TVirtualPS::SetColor(Float_t, Float_t, Float_t)
@trydoc raw"""
    SetColor(this::ByRef1{TVirtualPS}, r::Float32, g::Float32, b::Float32)::Nothing


""" SetColor(this::ByRef1{TVirtualPS}, r::Float32, g::Float32, b::Float32)

# Wrapper of void TVirtualPS::SetType(Int_t)
@trydoc raw"""
    SetType(this::ByRef1{TVirtualPS}, ::Int32)::Nothing


""" SetType(this::ByRef1{TVirtualPS}, ::Int32)

# Wrapper of void TVirtualPS::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualPS}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualPS}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualPS::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualPS}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualPS}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualPS::Text(Double_t, Double_t, const char *)
@trydoc raw"""
    GetText(this::ByRef1{TVirtualPS}, x::Float64, y::Float64, string::ByCopy{String})::Nothing


""" GetText(this::ByRef1{TVirtualPS}, x::Float64, y::Float64, string::ByCopy{String})

# Wrapper of void TVirtualPS::Text(Double_t, Double_t, const wchar_t *)
@trydoc raw"""
    GetText(this::ByRef1{TVirtualPS}, x::Float64, y::Float64, string::ByConstPtr1{wchar_t})::Nothing


""" GetText(this::ByRef1{TVirtualPS}, x::Float64, y::Float64, string::ByConstPtr1{wchar_t})

# Wrapper of void TVirtualPS::WriteInteger(Int_t, Bool_t)
@trydoc raw"""
    WriteInteger(this::ByRef1{TVirtualPS}, i::Int32, space::Bool)::Nothing
Write one Integer to the file.
n: Integer to be written in the file. space: If TRUE, a space in written before the integer.
""" WriteInteger(this::ByRef1{TVirtualPS}, i::Int32, space::Bool)

# Wrapper of void TVirtualPS::WriteReal(Float_t, Bool_t)
@trydoc raw"""
    WriteReal(this::ByRef1{TVirtualPS}, r::Float32, space::Bool)::Nothing
Write a Real number to the file.

""" WriteReal(this::ByRef1{TVirtualPS}, r::Float32, space::Bool)

# Wrapper of const char * TVirtualTableInterface::GetColumnHeader(UInt_t)
@trydoc raw"""
    GetColumnHeader(this::ByRef1{TVirtualTableInterface}, column::UInt32)::ByCopy{String}


""" GetColumnHeader(this::ByRef1{TVirtualTableInterface}, column::UInt32)

# Wrapper of UInt_t TVirtualTableInterface::GetNColumns()
@trydoc raw"""
    GetNColumns(this::ByRef1{TVirtualTableInterface})::UInt32


""" GetNColumns(this::ByRef1{TVirtualTableInterface})

# Wrapper of UInt_t TVirtualTableInterface::GetNRows()
@trydoc raw"""
    GetNRows(this::ByRef1{TVirtualTableInterface})::UInt32


""" GetNRows(this::ByRef1{TVirtualTableInterface})

# Wrapper of const char * TVirtualTableInterface::GetRowHeader(UInt_t)
@trydoc raw"""
    GetRowHeader(this::ByRef1{TVirtualTableInterface}, row::UInt32)::ByCopy{String}


""" GetRowHeader(this::ByRef1{TVirtualTableInterface}, row::UInt32)

# Wrapper of Double_t TVirtualTableInterface::GetValue(UInt_t, UInt_t)
@trydoc raw"""
    GetValue(this::ByRef1{TVirtualTableInterface}, row::UInt32, column::UInt32)::Float64


""" GetValue(this::ByRef1{TVirtualTableInterface}, row::UInt32, column::UInt32)

# Wrapper of const char * TVirtualTableInterface::GetValueAsString(UInt_t, UInt_t)
@trydoc raw"""
    GetValueAsString(this::ByRef1{TVirtualTableInterface}, row::UInt32, column::UInt32)::ByCopy{String}


""" GetValueAsString(this::ByRef1{TVirtualTableInterface}, row::UInt32, column::UInt32)

# Wrapper of void TVirtualTableInterface::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualTableInterface}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualTableInterface}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualTableInterface::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualTableInterface}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualTableInterface}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TVirtualX::AddPixmap(ULongptr_t, UInt_t, UInt_t)
@trydoc raw"""
    AddPixmap(this::ByRef1{TVirtualX}, pixid::UInt64, w::UInt32, h::UInt32)::Int32
Registers a pixmap created by [TGLManager](@ref) as a [ROOT](@ref) pixmap.
## Arguments

- **`pixid`** [in], **`w`** [in], **`h`** [in] 
    pixmap identifier 
    . 
    the width and height, which define the pixmap size
""" AddPixmap(this::ByRef1{TVirtualX}, pixid::UInt64, w::UInt32, h::UInt32)

# Wrapper of Int_t TVirtualX::AddWindow(ULongptr_t, UInt_t, UInt_t)
@trydoc raw"""
    AddWindow(this::ByRef1{TVirtualX}, qwid::UInt64, w::UInt32, h::UInt32)::Int32
Registers a window created by Qt as a [ROOT](@ref) window.
## Arguments

- **`qwid`** [in], **`w`** [in], **`h`** [in] 
    window identifier 
    . 
    the width and height, which define the window size
""" AddWindow(this::ByRef1{TVirtualX}, qwid::UInt64, w::UInt32, h::UInt32)

# Wrapper of Bool_t TVirtualX::AllocColor(Colormap_t, ColorStruct_t &)
@trydoc raw"""
    AllocColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, color::ByRef1{ColorStruct_t})::Bool
Allocates a read-only colormap entry corresponding to the closest RGB value supported by the hardware.
If no cell could be allocated it returns kFALSE, otherwise kTRUE.

The pixel value is set to default. Let system think we could allocate color.

## Arguments

- **`cmap`** [in] 
    the colormap 
    
- **`color`** [in] 
    specifies and returns the values actually used in the cmap
""" AllocColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, color::ByRef1{ColorStruct_t})

# Wrapper of void TVirtualX::BeginModalSessionFor(Window_t)
@trydoc raw"""
    BeginModalSessionFor(this::ByRef1{TVirtualX}, window::ByCopy{Window_t})::Nothing
Start a modal session for a dialog window.

""" BeginModalSessionFor(this::ByRef1{TVirtualX}, window::ByCopy{Window_t})

# Wrapper of void TVirtualX::Bell(Int_t)
@trydoc raw"""
    Bell(this::ByRef1{TVirtualX}, percent::Int32)::Nothing
Sets the sound bell. Percent is loudness from -100% to 100%.

""" Bell(this::ByRef1{TVirtualX}, percent::Int32)

# Wrapper of void TVirtualX::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t)
@trydoc raw"""
    ChangeActivePointerGrab(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::UInt32, ::ByCopy{Cursor_t})::Nothing
Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X server time.

""" ChangeActivePointerGrab(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::UInt32, ::ByCopy{Cursor_t})

# Wrapper of void TVirtualX::ChangeGC(GContext_t, GCValues_t *)
@trydoc raw"""
    ChangeGC(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, gval::ByPtr1{GCValues_t})::Nothing
Changes the components specified by the mask in gval for the specified GC.
## Arguments

- **`gc`** [in] 
    specifies the GC to be changed 
    
- **`gval`** [in] 
    specifies the mask and the values to be set
    

(see also the [GCValues_t](@ref) structure)
""" ChangeGC(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, gval::ByPtr1{GCValues_t})

# Wrapper of void TVirtualX::ChangeProperties(Window_t, Atom_t, Atom_t, Int_t, UChar_t *, Int_t)
@trydoc raw"""
    ChangeProperties(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, property::ByCopy{Atom_t}, type::ByCopy{Atom_t}, format::Int32, data::ByPtr2{UInt8}, len::Int32)::Nothing
Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window.

""" ChangeProperties(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, property::ByCopy{Atom_t}, type::ByCopy{Atom_t}, format::Int32, data::ByPtr2{UInt8}, len::Int32)

# Wrapper of void TVirtualX::ChangeProperty(Window_t, Atom_t, Atom_t, UChar_t *, Int_t)
@trydoc raw"""
    ChangeProperty(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, property::ByCopy{Atom_t}, type::ByCopy{Atom_t}, data::ByPtr2{UInt8}, len::Int32)::Nothing
Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window.
## Arguments

- **`id`** [in] 
    the window whose property you want to change 
    
- **`property`** [in] 
    specifies the property name 
    
- **`type`** [in] 
    the type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties 
    
- **`data`** [in] 
    the property data 
    
- **`len`** [in] 
    the length of the specified data format
""" ChangeProperty(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, property::ByCopy{Atom_t}, type::ByCopy{Atom_t}, data::ByPtr2{UInt8}, len::Int32)

# Wrapper of void TVirtualX::ChangeWindowAttributes(Window_t, SetWindowAttributes_t *)
@trydoc raw"""
    ChangeWindowAttributes(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, attr::ByPtr1{SetWindowAttributes_t})::Nothing
Changes the attributes of the specified window "id" according the values provided in "attr".
The mask data member of "attr" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored.
""" ChangeWindowAttributes(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, attr::ByPtr1{SetWindowAttributes_t})

# Wrapper of Bool_t TVirtualX::CheckEvent(Window_t, EGEventType, Event_t &)
@trydoc raw"""
    CheckEvent(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, type::ByCopy{EGEventType}, ev::ByRef1{Event_t})::Bool
Check if there is for window "id" an event of type "type".
If there is it fills in the event structure and return true. If no such event return false.
""" CheckEvent(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, type::ByCopy{EGEventType}, ev::ByRef1{Event_t})

# Wrapper of void TVirtualX::ClearArea(Window_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    ClearArea(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)::Nothing
Paints a rectangular area in the specified window "id" according to the specified dimensions with the window's background pixel or pixmap.
## Arguments

- **`id`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in] 
    specifies the window 
    . 
    coordinates, which are relative to the origin 
    . 
    the width and height which define the rectangle dimensions
""" ClearArea(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::ClearWindow()
@trydoc raw"""
    ClearWindow(this::ByRef1{TVirtualX})::Nothing
Clears the entire area of the current window.

""" ClearWindow(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::ClearWindow(Window_t)
@trydoc raw"""
    ClearWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Clears the entire area in the specified window and it is equivalent to ClearArea(id, 0, 0, 0, 0)

""" ClearWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::CloseDisplay()
@trydoc raw"""
    CloseDisplay(this::ByRef1{TVirtualX})::Nothing
Closes connection to display server and destroys all windows.

""" CloseDisplay(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::ClosePixmap()
@trydoc raw"""
    ClosePixmap(this::ByRef1{TVirtualX})::Nothing
Deletes current pixmap.

""" ClosePixmap(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::CloseWindow()
@trydoc raw"""
    CloseWindow(this::ByRef1{TVirtualX})::Nothing
Deletes current window.

""" CloseWindow(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::ConvertPrimarySelection(Window_t, Atom_t, Time_t)
@trydoc raw"""
    ConvertPrimarySelection(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, clipboard::ByCopy{Atom_t}, when::ByCopy{Time_t})::Nothing
Causes a SelectionRequest event to be sent to the current primary selection owner.
This event specifies the selection property (primary selection), the format into which to convert that data before storing it (target = XA_STRING), the property in which the owner will place the information (sel_property), the window that wants the information (id), and the time of the conversion request (when). The selection owner responds by sending a SelectionNotify event, which confirms the selected atom and type.
""" ConvertPrimarySelection(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, clipboard::ByCopy{Atom_t}, when::ByCopy{Time_t})

# Wrapper of void TVirtualX::ConvertSelection(Window_t, Atom_t &, Atom_t &, Atom_t &, Time_t &)
@trydoc raw"""
    ConvertSelection(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByRef1{Atom_t}, ::ByRef1{Atom_t}, ::ByRef1{Atom_t}, ::ByRef1{Time_t})::Nothing
Requests that the specified selection be converted to the specified target type.

""" ConvertSelection(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByRef1{Atom_t}, ::ByRef1{Atom_t}, ::ByRef1{Atom_t}, ::ByRef1{Time_t})

# Wrapper of void TVirtualX::CopyArea(Drawable_t, Drawable_t, GContext_t, Int_t, Int_t, UInt_t, UInt_t, Int_t, Int_t)
@trydoc raw"""
    CopyArea(this::ByRef1{TVirtualX}, src::ByCopy{Drawable_t}, dest::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, src_x::Int32, src_y::Int32, width::UInt32, height::UInt32, dest_x::Int32, dest_y::Int32)::Nothing
Combines the specified rectangle of "src" with the specified rectangle of "dest" according to the "gc".
## Arguments

- **`src`** [in], **`dest`** [in], **`gc`** [in], **`src_x`** [in], **`src_y`** [in], **`width`** [in], **`height`** [in], **`dest_x`** [in], **`dest_y`** [in] 
    source rectangle 
    . 
    destination rectangle 
    . 
    graphics context 
    . 
    specify the x and y coordinates, which are relative to the origin of the source rectangle and specify upper-left corner. 
    . 
    the width and height, which are the dimensions of both the source and destination rectangles 
    . 
    specify the upper-left corner of the destination rectangle
    

GC components in use: function, plane-mask, subwindow-mode, graphics-exposure, clip-x-origin, clip-y-origin, and clip-mask. (see also the [GCValues_t](@ref) structure)
""" CopyArea(this::ByRef1{TVirtualX}, src::ByCopy{Drawable_t}, dest::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, src_x::Int32, src_y::Int32, width::UInt32, height::UInt32, dest_x::Int32, dest_y::Int32)

# Wrapper of void TVirtualX::CopyGC(GContext_t, GContext_t, Mask_t)
@trydoc raw"""
    CopyGC(this::ByRef1{TVirtualX}, org::ByCopy{GContext_t}, dest::ByCopy{GContext_t}, mask::ByCopy{Mask_t})::Nothing
Copies the specified components from the source GC "org" to the destination GC "dest".
The "mask" defines which component to copy and it is a data member of [GCValues_t](@ref).
""" CopyGC(this::ByRef1{TVirtualX}, org::ByCopy{GContext_t}, dest::ByCopy{GContext_t}, mask::ByCopy{Mask_t})

# Wrapper of void TVirtualX::CopyPixmap(Int_t, Int_t, Int_t)
@trydoc raw"""
    CopyPixmap(this::ByRef1{TVirtualX}, wid::Int32, xpos::Int32, ypos::Int32)::Nothing
Copies the pixmap "wid" at the position [xpos,ypos] in the current window.

""" CopyPixmap(this::ByRef1{TVirtualX}, wid::Int32, xpos::Int32, ypos::Int32)

# Wrapper of Pixmap_t TVirtualX::CreateBitmap(Drawable_t, const char *, UInt_t, UInt_t)
@trydoc raw"""
    CreateBitmap(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, bitmap::ByCopy{String}, width::UInt32, height::UInt32)::ByCopy{Pixmap_t}
Creates a bitmap (i.e.
pixmap with depth 1) from the bitmap data.

## Arguments

- **`id`** [in], **`bitmap`** [in], **`width`** [in], **`height`** [in] 
    specifies which screen the pixmap is created on 
    . 
    the data in bitmap format 
    . 
    define the dimensions of the pixmap
""" CreateBitmap(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, bitmap::ByCopy{String}, width::UInt32, height::UInt32)

# Wrapper of Cursor_t TVirtualX::CreateCursor(ECursor)
@trydoc raw"""
    CreateCursor(this::ByRef1{TVirtualX}, cursor::ByCopy{ECursor})::ByCopy{Cursor_t}
Creates the specified cursor.
(just return cursor from cursor pool). The cursor can be: 

    kBottomLeft, kBottomRight, kTopLeft,  kTopRight,
    kBottomSide, kLeftSide,    kTopSide,  kRightSide,
    kMove,       kCross,       kArrowHor, kArrowVer,
    kHand,       kRotate,      kPointer,  kArrowRight,
    kCaret,      kWatch

(C++ version of the code)
""" CreateCursor(this::ByRef1{TVirtualX}, cursor::ByCopy{ECursor})

# Wrapper of GContext_t TVirtualX::CreateGC(Drawable_t, GCValues_t *)
@trydoc raw"""
    CreateGC(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gval::ByPtr1{GCValues_t})::ByCopy{GContext_t}
Creates a graphics context using the provided [GCValues_t](@ref) *gval structure.
The mask data member of gval specifies which components in the GC are to be set using the information in the specified values structure. It returns a graphics context handle GContext_t that can be used with any destination drawable or O if the creation falls.
""" CreateGC(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gval::ByPtr1{GCValues_t})

# Wrapper of Drawable_t TVirtualX::CreateImage(UInt_t, UInt_t)
@trydoc raw"""
    CreateImage(this::ByRef1{TVirtualX}, width::UInt32, height::UInt32)::ByCopy{Drawable_t}
Allocates the memory needed for an drawable.
## Arguments

- **`width`** [in] 
    the width of the image, in pixels 
    
- **`height`** [in] 
    the height of the image, in pixels
""" CreateImage(this::ByRef1{TVirtualX}, width::UInt32, height::UInt32)

# Wrapper of void TVirtualX::CreateOpenGLContext(Int_t)
@trydoc raw"""
    CreateOpenGLContext(this::ByRef1{TVirtualX}, wid::Int32)::Nothing
Creates OpenGL context for window "wid".

""" CreateOpenGLContext(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of Handle_t TVirtualX::CreateOpenGLContext(Window_t, Handle_t)
@trydoc raw"""
    CreateOpenGLContext(this::ByRef1{TVirtualX}, windowID::ByCopy{Window_t}, sharedContext::ByCopy{Handle_t})::ByCopy{Handle_t}
Creates OpenGL context for window "windowID".

""" CreateOpenGLContext(this::ByRef1{TVirtualX}, windowID::ByCopy{Window_t}, sharedContext::ByCopy{Handle_t})

# Wrapper of Bool_t TVirtualX::CreatePictureFromData(Drawable_t, char **, Pixmap_t &, Pixmap_t &, PictureAttributes_t &)
@trydoc raw"""
    CreatePictureFromData(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, data::ByPtr2{Int8}, pict::ByRef1{Pixmap_t}, pict_mask::ByRef1{Pixmap_t}, attr::ByRef1{PictureAttributes_t})::Bool
Creates a picture pict from data in bitmap format.
The picture attributes "attr" are used for input and output. Returns kTRUE in case of success, kFALSE otherwise. If the mask "pict_mask" does not exist it is set to kNone.
""" CreatePictureFromData(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, data::ByPtr2{Int8}, pict::ByRef1{Pixmap_t}, pict_mask::ByRef1{Pixmap_t}, attr::ByRef1{PictureAttributes_t})

# Wrapper of Bool_t TVirtualX::CreatePictureFromFile(Drawable_t, const char *, Pixmap_t &, Pixmap_t &, PictureAttributes_t &)
@trydoc raw"""
    CreatePictureFromFile(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, filename::ByCopy{String}, pict::ByRef1{Pixmap_t}, pict_mask::ByRef1{Pixmap_t}, attr::ByRef1{PictureAttributes_t})::Bool
Creates a picture pict from data in file "filename".
The picture attributes "attr" are used for input and output. Returns kTRUE in case of success, kFALSE otherwise. If the mask "pict_mask" does not exist it is set to kNone.
""" CreatePictureFromFile(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, filename::ByCopy{String}, pict::ByRef1{Pixmap_t}, pict_mask::ByRef1{Pixmap_t}, attr::ByRef1{PictureAttributes_t})

# Wrapper of Pixmap_t TVirtualX::CreatePixmap(Drawable_t, const char *, UInt_t, UInt_t, ULong_t, ULong_t, Int_t)
@trydoc raw"""
    CreatePixmap(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, bitmap::ByCopy{String}, width::UInt32, height::UInt32, forecolor::UInt64, backcolor::UInt64, depth::Int32)::ByCopy{Pixmap_t}
Creates a pixmap from bitmap data of the width, height, and depth you specified and returns a pixmap that identifies it.
The width and height arguments must be nonzero. The depth argument must be one of the depths supported by the screen of the specified drawable.

## Arguments

- **`id`** [in], **`bitmap`** [in], **`width`** [in], **`height`** [in], **`forecolor`** [in], **`backcolor`** [in], **`depth`** [in] 
    specifies which screen the pixmap is created on 
    . 
    the data in bitmap format 
    . 
    define the dimensions of the pixmap 
    . 
    the foreground pixel values to use 
    . 
    the background pixel values to use 
    . 
    the depth of the pixmap
""" CreatePixmap(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, bitmap::ByCopy{String}, width::UInt32, height::UInt32, forecolor::UInt64, backcolor::UInt64, depth::Int32)

# Wrapper of Pixmap_t TVirtualX::CreatePixmap(Drawable_t, UInt_t, UInt_t)
@trydoc raw"""
    CreatePixmap(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, w::UInt32, h::UInt32)::ByCopy{Pixmap_t}
Creates a pixmap of the specified width and height and returns a pixmap ID that identifies it.

""" CreatePixmap(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, w::UInt32, h::UInt32)

# Wrapper of Pixmap_t TVirtualX::CreatePixmapFromData(unsigned char *, UInt_t, UInt_t)
@trydoc raw"""
    CreatePixmapFromData(this::ByRef1{TVirtualX}, bits::ByPtr1{unsigned Int8}, width::UInt32, height::UInt32)::ByCopy{Pixmap_t}
create pixmap from RGB data.
RGB data is in format:

    b1, g1, r1, 0,  b2, g2, r2, 0 ... bn, gn, rn, 0 ..

(C++ version of the code)

Pixels are numbered from left to right and from top to bottom. Note that data must be 32-bit aligned
""" CreatePixmapFromData(this::ByRef1{TVirtualX}, bits::ByPtr1{unsigned Int8}, width::UInt32, height::UInt32)

# Wrapper of Region_t TVirtualX::CreateRegion()
@trydoc raw"""
    CreateRegion(this::ByRef1{TVirtualX})::ByCopy{Region_t}
Creates a new empty region.

""" CreateRegion(this::ByRef1{TVirtualX})

# Wrapper of Window_t TVirtualX::CreateWindow(Window_t, Int_t, Int_t, UInt_t, UInt_t, UInt_t, Int_t, UInt_t, void *, SetWindowAttributes_t *, UInt_t)
@trydoc raw"""
    CreateWindow(this::ByRef1{TVirtualX}, parent::ByCopy{Window_t}, x::Int32, y::Int32, w::UInt32, h::UInt32, border::UInt32, depth::Int32, clss::UInt32, visual::ByPtr2{Nothing}, attr::ByPtr1{SetWindowAttributes_t}, wtype::UInt32)::ByCopy{Window_t}
Creates an unmapped subwindow for a specified parent window and returns the created window.
The created window is placed on top in the stacking order with respect to siblings. The coordinate system has the X axis horizontal and the Y axis vertical with the origin [0,0] at the upper-left corner. Each window and pixmap has its own coordinate system.

## Arguments

- **`parent`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in], **`border`** [in], **`depth`** [in], **`clss`** [in], **`visual`** [in], **`attr`** [in], **`wtype`** [in] 
    the parent window 
    . 
    coordinates, the top-left outside corner of the window's borders; relative to the inside of the parent window's borders 
    . 
    width and height of the created window; do not include the created window's borders 
    . 
    the border pixel value of the window 
    . 
    the window's depth 
    . 
    the created window's class; can be InputOutput, InputOnly, or CopyFromParent 
    . 
    the visual type 
    . 
    the structure from which the values are to be taken. 
    . 
    the window type
""" CreateWindow(this::ByRef1{TVirtualX}, parent::ByCopy{Window_t}, x::Int32, y::Int32, w::UInt32, h::UInt32, border::UInt32, depth::Int32, clss::UInt32, visual::ByPtr2{Nothing}, attr::ByPtr1{SetWindowAttributes_t}, wtype::UInt32)

# Wrapper of void TVirtualX::DeleteFont(FontStruct_t)
@trydoc raw"""
    DeleteFont(this::ByRef1{TVirtualX}, fs::ByCopy{FontStruct_t})::Nothing
Explicitly deletes the font structure "fs" obtained via [LoadQueryFont()](@ref).

""" DeleteFont(this::ByRef1{TVirtualX}, fs::ByCopy{FontStruct_t})

# Wrapper of void TVirtualX::DeleteGC(GContext_t)
@trydoc raw"""
    DeleteGC(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t})::Nothing
Deletes the specified GC "gc".

""" DeleteGC(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t})

# Wrapper of void TVirtualX::DeleteImage(Drawable_t)
@trydoc raw"""
    DeleteImage(this::ByRef1{TVirtualX}, img::ByCopy{Drawable_t})::Nothing
Deallocates the memory associated with the image img.

""" DeleteImage(this::ByRef1{TVirtualX}, img::ByCopy{Drawable_t})

# Wrapper of void TVirtualX::DeleteOpenGLContext(Int_t)
@trydoc raw"""
    DeleteOpenGLContext(this::ByRef1{TVirtualX}, wid::Int32)::Nothing
Deletes OpenGL context for window "wid".

""" DeleteOpenGLContext(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of void TVirtualX::DeletePictureData(void *)
@trydoc raw"""
    DeletePictureData(this::ByRef1{TVirtualX}, data::ByPtr2{Nothing})::Nothing
Delete picture data created by the function ReadPictureDataFromFile.

""" DeletePictureData(this::ByRef1{TVirtualX}, data::ByPtr2{Nothing})

# Wrapper of void TVirtualX::DeletePixmap(Pixmap_t)
@trydoc raw"""
    DeletePixmap(this::ByRef1{TVirtualX}, pmap::ByCopy{Pixmap_t})::Nothing
Explicitly deletes the pixmap resource "pmap".

""" DeletePixmap(this::ByRef1{TVirtualX}, pmap::ByCopy{Pixmap_t})

# Wrapper of void TVirtualX::DeleteProperty(Window_t, Atom_t &)
@trydoc raw"""
    DeleteProperty(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByRef1{Atom_t})::Nothing
Deletes the specified property only if the property was defined on the specified window and causes the X server to generate a PropertyNotify event on the window unless the property does not exist.

""" DeleteProperty(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByRef1{Atom_t})

# Wrapper of void TVirtualX::DestroyRegion(Region_t)
@trydoc raw"""
    DestroyRegion(this::ByRef1{TVirtualX}, reg::ByCopy{Region_t})::Nothing
Destroys the region "reg".

""" DestroyRegion(this::ByRef1{TVirtualX}, reg::ByCopy{Region_t})

# Wrapper of void TVirtualX::DestroySubwindows(Window_t)
@trydoc raw"""
    DestroySubwindows(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
The DestroySubwindows function destroys all inferior windows of the specified window, in bottom-to-top stacking order.

""" DestroySubwindows(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::DestroyWindow(Window_t)
@trydoc raw"""
    DestroyWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Destroys the window "id" as well as all of its subwindows.
The window should never be referenced again. If the window specified by the "id" argument is mapped, it is unmapped automatically.
""" DestroyWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::DispatchClientMessage(UInt_t)
@trydoc raw"""
    DispatchClientMessage(this::ByRef1{TVirtualX}, messageID::UInt32)::Nothing
Force processing of event, sent by SendEvent before.

""" DispatchClientMessage(this::ByRef1{TVirtualX}, messageID::UInt32)

# Wrapper of const char * TVirtualX::DisplayName(const char *)
@trydoc raw"""
    DisplayName(this::ByRef1{TVirtualX}, ::ByCopy{String})::ByCopy{String}
Returns hostname on which the display is opened.

""" DisplayName(this::ByRef1{TVirtualX}, ::ByCopy{String})

# Wrapper of void TVirtualX::DrawCellArray(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Int_t *)
@trydoc raw"""
    DrawCellArray(this::ByRef1{TVirtualX}, x1::Int32, y1::Int32, x2::Int32, y2::Int32, nx::Int32, ny::Int32, ic::ByPtr2{Int32})::Nothing
Draws a cell array.
The drawing is done with the pixel precision if (x2-x1)/nx (or y) is not a exact pixel number the position of the top right corner may be wrong.

## Arguments

- **`x1`** [in], **`y1`** [in], **`x2`** [in], **`y2`** [in], **`nx`** [in], **`ny`** [in], **`ic`** [in] 
    left down corner 
    . 
    right up corner 
    . 
    array size 
    . 
    array
""" DrawCellArray(this::ByRef1{TVirtualX}, x1::Int32, y1::Int32, x2::Int32, y2::Int32, nx::Int32, ny::Int32, ic::ByPtr2{Int32})

# Wrapper of void TVirtualX::DrawFillArea(Int_t, TPoint *)
@trydoc raw"""
    DrawFillArea(this::ByRef1{TVirtualX}, n::Int32, xy::ByPtr1{TPoint})::Nothing
Fills area described by the polygon.
## Arguments

- **`n`** [in] 
    number of points 
    
- **`xy`** [in] 
    list of points. xy(2,n)
""" DrawFillArea(this::ByRef1{TVirtualX}, n::Int32, xy::ByPtr1{TPoint})

# Wrapper of void TVirtualX::DrawLine(Drawable_t, GContext_t, Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    DrawLine(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x1::Int32, y1::Int32, x2::Int32, y2::Int32)::Nothing
Uses the components of the specified GC to draw a line between the specified set of points (x1, y1) and (x2, y2).
GC components in use: function, plane-mask, line-width, line-style, cap-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.

GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the [GCValues_t](@ref) structure)
""" DrawLine(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x1::Int32, y1::Int32, x2::Int32, y2::Int32)

# Wrapper of void TVirtualX::DrawLine(Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    DrawLine(this::ByRef1{TVirtualX}, x1::Int32, y1::Int32, x2::Int32, y2::Int32)::Nothing
Draws a line.
## Arguments

- **`x1`** [in], **`y1`** [in], **`x2`** [in], **`y2`** [in] 
    thebegin of line 
    . 
    theend of line
""" DrawLine(this::ByRef1{TVirtualX}, x1::Int32, y1::Int32, x2::Int32, y2::Int32)

# Wrapper of void TVirtualX::DrawPolyLine(Int_t, TPoint *)
@trydoc raw"""
    DrawPolyLine(this::ByRef1{TVirtualX}, n::Int32, xy::ByPtr1{TPoint})::Nothing
Draws a line through all points in the list.
## Arguments

- **`n`** [in] 
    number of points 
    
- **`xy`** [in] 
    list of points
""" DrawPolyLine(this::ByRef1{TVirtualX}, n::Int32, xy::ByPtr1{TPoint})

# Wrapper of void TVirtualX::DrawPolyMarker(Int_t, TPoint *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TVirtualX}, n::Int32, xy::ByPtr1{TPoint})::Nothing
Draws "n" markers with the current attributes at position [x,y].
## Arguments

- **`n`** [in] 
    number of markers to draw 
    
- **`xy`** [in] 
    an array of x,y marker coordinates
""" DrawPolyMarker(this::ByRef1{TVirtualX}, n::Int32, xy::ByPtr1{TPoint})

# Wrapper of void TVirtualX::DrawRectangle(Drawable_t, GContext_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    DrawRectangle(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)::Nothing
Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h].
GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the [GCValues_t](@ref) structure)
""" DrawRectangle(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::DrawSegments(Drawable_t, GContext_t, Segment_t *, Int_t)
@trydoc raw"""
    DrawSegments(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, seg::ByPtr1{Segment_t}, nseg::Int32)::Nothing
Draws multiple line segments.
Each line is specified by a pair of points.

## Arguments

- **`id`** [in] 
    Drawable identifier 
    
- **`gc`** [in] 
    graphics context 
    
- **`*seg`** [in] 
    specifies an array of segments 
    
- **`nseg`** [in] 
    specifies the number of segments in the array
    

GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.

GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, and dash-list. (see also the [GCValues_t](@ref) structure)
""" DrawSegments(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, seg::ByPtr1{Segment_t}, nseg::Int32)

# Wrapper of void TVirtualX::DrawString(Drawable_t, GContext_t, Int_t, Int_t, const char *, Int_t)
@trydoc raw"""
    DrawString(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, s::ByCopy{String}, len::Int32)::Nothing
Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable.
## Arguments

- **`id`** [in], **`gc`** [in], **`x`** [in], **`y`** [in], **`s`** [in], **`len`** [in] 
    the drawable 
    . 
    the GC 
    . 
    coordinates, which are relative to the origin of the specified drawable and define the origin of the first character 
    . 
    the character string 
    . 
    the number of characters in the string argument
    

GC components in use: function, plane-mask, fill-style, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the [GCValues_t](@ref) structure)
""" DrawString(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, s::ByCopy{String}, len::Int32)

# Wrapper of Bool_t TVirtualX::EmptyRegion(Region_t)
@trydoc raw"""
    EmptyRegion(this::ByRef1{TVirtualX}, reg::ByCopy{Region_t})::Bool
Returns kTRUE if the region reg is empty.

""" EmptyRegion(this::ByRef1{TVirtualX}, reg::ByCopy{Region_t})

# Wrapper of Bool_t TVirtualX::EqualRegion(Region_t, Region_t)
@trydoc raw"""
    EqualRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t})::Bool
Returns kTRUE if the two regions have the same offset, size, and shape.

""" EqualRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t})

# Wrapper of Int_t TVirtualX::EventsPending()
@trydoc raw"""
    EventsPending(this::ByRef1{TVirtualX})::Int32
Returns the number of events that have been received from the X server but have not been removed from the event queue.

""" EventsPending(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::FillPolygon(Window_t, GContext_t, Point_t *, Int_t)
@trydoc raw"""
    FillPolygon(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, gc::ByCopy{GContext_t}, points::ByPtr1{Point_t}, npnt::Int32)::Nothing
Fills the region closed by the specified path.
The path is closed automatically if the last point in the list does not coincide with the first point.

## Arguments

- **`id`** [in] 
    window identifier 
    
- **`gc`** [in] 
    graphics context 
    
- **`*points`** [in] 
    specifies an array of points 
    
- **`npnt`** [in] 
    specifies the number of points in the array
    

GC components in use: function, plane-mask, fill-style, fill-rule, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the [GCValues_t](@ref) structure)
""" FillPolygon(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, gc::ByCopy{GContext_t}, points::ByPtr1{Point_t}, npnt::Int32)

# Wrapper of void TVirtualX::FillRectangle(Drawable_t, GContext_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    FillRectangle(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)::Nothing
Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h].
using the GC you specify.

GC components in use are: function, plane-mask, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the [GCValues_t](@ref) structure)
""" FillRectangle(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of Window_t TVirtualX::FindRWindow(Window_t, Window_t, Window_t, int, int, int)
@trydoc raw"""
    FindRWindow(this::ByRef1{TVirtualX}, win::ByCopy{Window_t}, dragwin::ByCopy{Window_t}, input::ByCopy{Window_t}, x::Int32, y::Int32, maxd::Int32)::ByCopy{Window_t}
Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd.

""" FindRWindow(this::ByRef1{TVirtualX}, win::ByCopy{Window_t}, dragwin::ByCopy{Window_t}, input::ByCopy{Window_t}, x::Int32, y::Int32, maxd::Int32)

# Wrapper of void TVirtualX::FlushOpenGLBuffer(Handle_t)
@trydoc raw"""
    FlushOpenGLBuffer(this::ByRef1{TVirtualX}, ctx::ByCopy{Handle_t})::Nothing
Flushes OpenGL buffer.

""" FlushOpenGLBuffer(this::ByRef1{TVirtualX}, ctx::ByCopy{Handle_t})

# Wrapper of void TVirtualX::FreeColor(Colormap_t, ULong_t)
@trydoc raw"""
    FreeColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, pixel::UInt64)::Nothing
Frees color cell with specified pixel value.

""" FreeColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, pixel::UInt64)

# Wrapper of void TVirtualX::FreeFontNames(char **)
@trydoc raw"""
    FreeFontNames(this::ByRef1{TVirtualX}, fontlist::ByPtr2{Int8})::Nothing
Frees the specified the array of strings "fontlist".

""" FreeFontNames(this::ByRef1{TVirtualX}, fontlist::ByPtr2{Int8})

# Wrapper of void TVirtualX::FreeFontStruct(FontStruct_t)
@trydoc raw"""
    FreeFontStruct(this::ByRef1{TVirtualX}, fs::ByCopy{FontStruct_t})::Nothing
Frees the font structure "fs".
The font itself will be freed when no other resource references it.
""" FreeFontStruct(this::ByRef1{TVirtualX}, fs::ByCopy{FontStruct_t})

# Wrapper of void TVirtualX::GetCharacterUp(Float_t &, Float_t &)
@trydoc raw"""
    GetCharacterUp(this::ByRef1{TVirtualX}, chupx::ByRef2{Float32}, chupy::ByRef2{Float32})::Nothing
Returns character up vector.

""" GetCharacterUp(this::ByRef1{TVirtualX}, chupx::ByRef2{Float32}, chupy::ByRef2{Float32})

# Wrapper of unsigned char * TVirtualX::GetColorBits(Drawable_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    GetColorBits(this::ByRef1{TVirtualX}, wid::ByCopy{Drawable_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)::CxxPtr1{unsigned Int8}
Returns an array of pixels created from a part of drawable (defined by x, y, w, h) in format:
b1, g1, r1, 0,  b2, g2, r2, 0 ... bn, gn, rn, 0 ..

(C++ version of the code)

Pixels are numbered from left to right and from top to bottom. By default all pixels from the whole drawable are returned.

Note that return array is 32-bit aligned
""" GetColorBits(this::ByRef1{TVirtualX}, wid::ByCopy{Drawable_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of Handle_t TVirtualX::GetCurrentOpenGLContext()
@trydoc raw"""
    GetCurrentOpenGLContext(this::ByRef1{TVirtualX})::ByCopy{Handle_t}
Asks OpenGL subsystem about the current OpenGL context.

""" GetCurrentOpenGLContext(this::ByRef1{TVirtualX})

# Wrapper of Int_t TVirtualX::GetDoubleBuffer(Int_t)
@trydoc raw"""
    GetDoubleBuffer(this::ByRef1{TVirtualX}, wid::Int32)::Int32
Queries the double buffer value for the window "wid".

""" GetDoubleBuffer(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of FontH_t TVirtualX::GetFontHandle(FontStruct_t)
@trydoc raw"""
    GetFontHandle(this::ByRef1{TVirtualX}, fs::ByCopy{FontStruct_t})::ByCopy{FontH_t}
Returns the font handle of the specified font structure "fs".

""" GetFontHandle(this::ByRef1{TVirtualX}, fs::ByCopy{FontStruct_t})

# Wrapper of void TVirtualX::GetFontProperties(FontStruct_t, Int_t &, Int_t &)
@trydoc raw"""
    GetFontProperties(this::ByRef1{TVirtualX}, font::ByCopy{FontStruct_t}, max_ascent::ByRef2{Int32}, max_descent::ByRef2{Int32})::Nothing
Returns the font properties.

""" GetFontProperties(this::ByRef1{TVirtualX}, font::ByCopy{FontStruct_t}, max_ascent::ByRef2{Int32}, max_descent::ByRef2{Int32})

# Wrapper of FontStruct_t TVirtualX::GetFontStruct(FontH_t)
@trydoc raw"""
    GetFontStruct(this::ByRef1{TVirtualX}, fh::ByCopy{FontH_t})::ByCopy{FontStruct_t}
Retrieves the associated font structure of the font specified font handle "fh".
Free returned FontStruct_t using [FreeFontStruct()](@ref).
""" GetFontStruct(this::ByRef1{TVirtualX}, fh::ByCopy{FontH_t})

# Wrapper of FontStruct_t TVirtualX::GetGCFont(GContext_t)
@trydoc raw"""
    GetGCFont(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t})::ByCopy{FontStruct_t}
Return the font associated with the graphics context gc.

""" GetGCFont(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t})

# Wrapper of void TVirtualX::GetGCValues(GContext_t, GCValues_t &)
@trydoc raw"""
    GetGCValues(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, gval::ByRef1{GCValues_t})::Nothing
Returns the components specified by the mask in "gval" for the specified GC "gc" (see also the [GCValues_t](@ref) structure)

""" GetGCValues(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, gval::ByRef1{GCValues_t})

# Wrapper of void TVirtualX::GetGeometry(Int_t, Int_t &, Int_t &, UInt_t &, UInt_t &)
@trydoc raw"""
    GetGeometry(this::ByRef1{TVirtualX}, wid::Int32, x::ByRef2{Int32}, y::ByRef2{Int32}, w::ByRef2{UInt32}, h::ByRef2{UInt32})::Nothing
Returns position and size of window "wid".
## Arguments

- **`wid`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in] 
    window identifier if wid < 0 the size of the display is returned 
    . 
    returned window position 
    . 
    returned window size
""" GetGeometry(this::ByRef1{TVirtualX}, wid::Int32, x::ByRef2{Int32}, y::ByRef2{Int32}, w::ByRef2{UInt32}, h::ByRef2{UInt32})

# Wrapper of void TVirtualX::GetImageSize(Drawable_t, UInt_t &, UInt_t &)
@trydoc raw"""
    GetImageSize(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, width::ByRef2{UInt32}, height::ByRef2{UInt32})::Nothing
Returns the width and height of the image id.

""" GetImageSize(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, width::ByRef2{UInt32}, height::ByRef2{UInt32})

# Wrapper of Window_t TVirtualX::GetInputFocus()
@trydoc raw"""
    GetInputFocus(this::ByRef1{TVirtualX})::ByCopy{Window_t}
Returns the window id of the window having the input focus.

""" GetInputFocus(this::ByRef1{TVirtualX})

# Wrapper of Double_t TVirtualX::GetOpenGLScalingFactor()
@trydoc raw"""
    GetOpenGLScalingFactor(this::ByRef1{TVirtualX})::Float64
On a HiDPI resolution it can be > 1., this means glViewport should use scaled width and height.

""" GetOpenGLScalingFactor(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::GetPasteBuffer(Window_t, Atom_t, TString &, Int_t &, Bool_t)
@trydoc raw"""
    GetPasteBuffer(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, atom::ByCopy{Atom_t}, text::ByRef1{TString}, nchar::ByRef2{Int32}, del::Bool)::Nothing
Gets contents of the paste buffer "atom" into the string "text".
(nchar = number of characters) If "del" is true deletes the paste buffer afterwards.
""" GetPasteBuffer(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, atom::ByCopy{Atom_t}, text::ByRef1{TString}, nchar::ByRef2{Int32}, del::Bool)

# Wrapper of ULong_t TVirtualX::GetPixel(Color_t)
@trydoc raw"""
    GetPixel(this::ByRef1{TVirtualX}, cindex::Int16)::UInt64
Returns pixel value associated to specified [ROOT](@ref) color number "cindex".

""" GetPixel(this::ByRef1{TVirtualX}, cindex::Int16)

# Wrapper of void TVirtualX::GetPlanes(Int_t &)
@trydoc raw"""
    GetPlanes(this::ByRef1{TVirtualX}, nplanes::ByRef2{Int32})::Nothing
Returns the maximum number of planes.

""" GetPlanes(this::ByRef1{TVirtualX}, nplanes::ByRef2{Int32})

# Wrapper of Window_t TVirtualX::GetPrimarySelectionOwner()
@trydoc raw"""
    GetPrimarySelectionOwner(this::ByRef1{TVirtualX})::ByCopy{Window_t}
Returns the window id of the current owner of the primary selection.
That is the window in which, for example some text is selected.
""" GetPrimarySelectionOwner(this::ByRef1{TVirtualX})

# Wrapper of Int_t TVirtualX::GetProperty(Window_t, Atom_t, Long_t, Long_t, Bool_t, Atom_t, Atom_t *, Int_t *, ULong_t *, ULong_t *, unsigned char **)
@trydoc raw"""
    GetProperty(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByCopy{Atom_t}, ::Int64, ::Int64, ::Bool, ::ByCopy{Atom_t}, ::ByPtr1{Atom_t}, ::ByPtr2{Int32}, ::ByPtr2{UInt64}, ::ByPtr2{UInt64}, ::ByPtr1{unsigned Int8})::Int32
Returns the actual type of the property; the actual format of the property; the number of 8-bit, 16-bit, or 32-bit items transferred; the number of bytes remaining to be read in the property; and a pointer to the data actually returned.

""" GetProperty(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByCopy{Atom_t}, ::Int64, ::Int64, ::Bool, ::ByCopy{Atom_t}, ::ByPtr1{Atom_t}, ::ByPtr2{Int32}, ::ByPtr2{UInt64}, ::ByPtr2{UInt64}, ::ByPtr1{unsigned Int8})

# Wrapper of void TVirtualX::GetRegionBox(Region_t, Rectangle_t *)
@trydoc raw"""
    GetRegionBox(this::ByRef1{TVirtualX}, reg::ByCopy{Region_t}, rect::ByPtr1{Rectangle_t})::Nothing
Returns smallest enclosing rectangle.

""" GetRegionBox(this::ByRef1{TVirtualX}, reg::ByCopy{Region_t}, rect::ByPtr1{Rectangle_t})

# Wrapper of void TVirtualX::GetRGB(Int_t, Float_t &, Float_t &, Float_t &)
@trydoc raw"""
    GetRGB(this::ByRef1{TVirtualX}, index::Int32, r::ByRef2{Float32}, g::ByRef2{Float32}, b::ByRef2{Float32})::Nothing
Returns RGB values for color "index".

""" GetRGB(this::ByRef1{TVirtualX}, index::Int32, r::ByRef2{Float32}, g::ByRef2{Float32}, b::ByRef2{Float32})

# Wrapper of void TVirtualX::GetTextExtent(UInt_t &, UInt_t &, char *)
@trydoc raw"""
    GetTextExtent(this::ByRef1{TVirtualX}, w::ByRef2{UInt32}, h::ByRef2{UInt32}, mess::ByPtr2{Int8})::Nothing
Returns the size of the specified character string "mess".
## Arguments

- **`w`** [in] 
    the text width 
    
- **`h`** [in] 
    the text height 
    
- **`mess`** [in] 
    the string
""" GetTextExtent(this::ByRef1{TVirtualX}, w::ByRef2{UInt32}, h::ByRef2{UInt32}, mess::ByPtr2{Int8})

# Wrapper of void TVirtualX::GetTextExtent(UInt_t &, UInt_t &, wchar_t *)
@trydoc raw"""
    GetTextExtent(this::ByRef1{TVirtualX}, w::ByRef2{UInt32}, h::ByRef2{UInt32}, mess::ByPtr1{wchar_t})::Nothing
Returns the size of the specified character string "mess".
## Arguments

- **`w`** [in] 
    the text width 
    
- **`h`** [in] 
    the text height 
    
- **`mess`** [in] 
    the string
""" GetTextExtent(this::ByRef1{TVirtualX}, w::ByRef2{UInt32}, h::ByRef2{UInt32}, mess::ByPtr1{wchar_t})

# Wrapper of Float_t TVirtualX::GetTextMagnitude()
@trydoc raw"""
    GetTextMagnitude(this::ByRef1{TVirtualX})::Float32
Returns the current font magnification factor.

""" GetTextMagnitude(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::GetWindowAttributes(Window_t, WindowAttributes_t &)
@trydoc raw"""
    GetWindowAttributes(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, attr::ByRef1{WindowAttributes_t})::Nothing
The [WindowAttributes_t](@ref) structure is set to default.

""" GetWindowAttributes(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, attr::ByRef1{WindowAttributes_t})

# Wrapper of Window_t TVirtualX::GetWindowID(Int_t)
@trydoc raw"""
    GetWindowID(this::ByRef1{TVirtualX}, wid::Int32)::ByCopy{Window_t}
Returns the X11 window identifier.
## Arguments

- **`wid`** [in] 
    workstation identifier (input)
""" GetWindowID(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of void TVirtualX::GetWindowSize(Drawable_t, Int_t &, Int_t &, UInt_t &, UInt_t &)
@trydoc raw"""
    GetWindowSize(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, x::ByRef2{Int32}, overridey::ByRef2{Int32}, w::ByRef2{UInt32}, h::ByRef2{UInt32})::Nothing
Returns the location and the size of window "id".
## Arguments

- **`id`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in] 
    drawable identifier 
    . 
    coordinates of the upper-left outer corner relative to the parent window's origin 
    . 
    the inside size of the window, not including the border
""" GetWindowSize(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, x::ByRef2{Int32}, overridey::ByRef2{Int32}, w::ByRef2{UInt32}, h::ByRef2{UInt32})

# Wrapper of void TVirtualX::GrabButton(Window_t, EMouseButton, UInt_t, UInt_t, Window_t, Cursor_t, Bool_t)
@trydoc raw"""
    GrabButton(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, button::ByCopy{EMouseButton}, modifier::UInt32, evmask::UInt32, confine::ByCopy{Window_t}, cursor::ByCopy{Cursor_t}, grab::Bool)::Nothing
Establishes a passive grab on a certain mouse button.
That is, when a certain mouse button is hit while certain modifier's (Shift, Control, Meta, Alt) are active then the mouse will be grabbed for window id. When grab is false, ungrab the mouse button for this button and modifier.
""" GrabButton(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, button::ByCopy{EMouseButton}, modifier::UInt32, evmask::UInt32, confine::ByCopy{Window_t}, cursor::ByCopy{Cursor_t}, grab::Bool)

# Wrapper of void TVirtualX::GrabKey(Window_t, Int_t, UInt_t, Bool_t)
@trydoc raw"""
    GrabKey(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, keycode::Int32, modifier::UInt32, grab::Bool)::Nothing
Establishes a passive grab on the keyboard.
In the future, the keyboard is actively grabbed, the last-keyboard-grab time is set to the time at which the key was pressed (as transmitted in the KeyPress event), and the KeyPress event is reported if all of the following conditions are true:

- the keyboard is not grabbed and the specified key (which can itself be a modifier key) is logically pressed when the specified modifier keys are logically down, and no other modifier keys are logically down;
- either the grab window "id" is an ancestor of (or is) the focus window, or "id" is a descendant of the focus window and contains the pointer;
- a passive grab on the same key combination does not exist on any ancestor of grab_window

## Arguments

- **`id`** [in] 
    window id 
    
- **`keycode`** [in] 
    specifies the KeyCode or AnyKey 
    
- **`modifier`** [in] 
    specifies the set of keymasks or AnyModifier; the mask is the bitwise inclusive OR of the valid keymask bits 
    
- **`grab`** [in] 
    a switch between grab/ungrab key grab = kTRUE grab the key and modifier grab = kFALSE ungrab the key and modifier
""" GrabKey(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, keycode::Int32, modifier::UInt32, grab::Bool)

# Wrapper of void TVirtualX::GrabPointer(Window_t, UInt_t, Window_t, Cursor_t, Bool_t, Bool_t)
@trydoc raw"""
    GrabPointer(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, evmask::UInt32, confine::ByCopy{Window_t}, cursor::ByCopy{Cursor_t}, grab::Bool, owner_events::Bool)::Nothing
Establishes an active pointer grab.
While an active pointer grab is in effect, further pointer events are only reported to the grabbing client window.
""" GrabPointer(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, evmask::UInt32, confine::ByCopy{Window_t}, cursor::ByCopy{Cursor_t}, grab::Bool, owner_events::Bool)

# Wrapper of void TVirtualX::IconifyWindow(Window_t)
@trydoc raw"""
    IconifyWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Iconifies the window "id".

""" IconifyWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of Bool_t TVirtualX::Init(void *)
@trydoc raw"""
    Init(this::ByRef1{TVirtualX}, display::ByPtr2{Nothing})::Bool
Initializes the X system.
Returns kFALSE in case of failure. It is implementation dependent.
""" Init(this::ByRef1{TVirtualX}, display::ByPtr2{Nothing})

# Wrapper of Int_t TVirtualX::InitWindow(ULongptr_t)
@trydoc raw"""
    InitWindow(this::ByRef1{TVirtualX}, window::UInt64)::Int32
Creates a new window and return window number.
Returns -1 if window initialization fails.
""" InitWindow(this::ByRef1{TVirtualX}, window::UInt64)

# Wrapper of Atom_t TVirtualX::InternAtom(const char *, Bool_t)
@trydoc raw"""
    InternAtom(this::ByRef1{TVirtualX}, atom_name::ByCopy{String}, only_if_exist::Bool)::ByCopy{Atom_t}
Returns the atom identifier associated with the specified "atom_name" string.
If "only_if_exists" is False, the atom is created if it does not exist. If the atom name is not in the Host Portable Character Encoding, the result is implementation dependent. Uppercase and lowercase matter; the strings "thing", "Thing", and "thinG" all designate different atoms.
""" InternAtom(this::ByRef1{TVirtualX}, atom_name::ByCopy{String}, only_if_exist::Bool)

# Wrapper of void TVirtualX::IntersectRegion(Region_t, Region_t, Region_t)
@trydoc raw"""
    IntersectRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})::Nothing
Computes the intersection of two regions.
## Arguments

- **`rega`** [in], **`regb`** [in], **`result`** [in] 
    specify the two regions with which you want to perform the computation 
    . 
    returns the result of the computation
""" IntersectRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})

# Wrapper of Bool_t TVirtualX::IsDNDAware(Window_t, Atom_t *)
@trydoc raw"""
    IsDNDAware(this::ByRef1{TVirtualX}, win::ByCopy{Window_t}, typelist::ByPtr1{Atom_t})::Bool
Checks if the Window is DND aware, and knows any of the DND formats passed in argument.

""" IsDNDAware(this::ByRef1{TVirtualX}, win::ByCopy{Window_t}, typelist::ByPtr1{Atom_t})

# Wrapper of Int_t TVirtualX::KeysymToKeycode(UInt_t)
@trydoc raw"""
    KeysymToKeycode(this::ByRef1{TVirtualX}, keysym::UInt32)::Int32
Converts the "keysym" to the appropriate keycode.
For example, keysym is a letter and keycode is the matching keyboard key (which is dependent on the current keyboard mapping). If the specified "keysym" is not defined for any keycode, returns zero.
""" KeysymToKeycode(this::ByRef1{TVirtualX}, keysym::UInt32)

# Wrapper of char ** TVirtualX::ListFonts(const char *, Int_t, Int_t &)
@trydoc raw"""
    ListFonts(this::ByRef1{TVirtualX}, fontname::ByCopy{String}, max::Int32, count::ByRef2{Int32})::CxxPtr2{Int8}
Returns list of font names matching fontname regexp, like "-*-times-*".
The pattern string can contain any characters, but each asterisk (*) is a wildcard for any number of characters, and each question mark (?) is a wildcard for a single character. If the pattern string is not in the Host Portable Character Encoding, the result is implementation dependent. Use of uppercase or lowercase does not matter. Each returned string is null-terminated.

## Arguments

- **`fontname`** [in] 
    specifies the null-terminated pattern string that can contain wildcard characters 
    
- **`max`** [in] 
    specifies the maximum number of names to be returned 
    
- **`count`** [in] 
    returns the actual number of font names
""" ListFonts(this::ByRef1{TVirtualX}, fontname::ByCopy{String}, max::Int32, count::ByRef2{Int32})

# Wrapper of FontStruct_t TVirtualX::LoadQueryFont(const char *)
@trydoc raw"""
    LoadQueryFont(this::ByRef1{TVirtualX}, font_name::ByCopy{String})::ByCopy{FontStruct_t}
Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure.
If the font does not exist, it returns NULL.
""" LoadQueryFont(this::ByRef1{TVirtualX}, font_name::ByCopy{String})

# Wrapper of void TVirtualX::LookupString(Event_t *, char *, Int_t, UInt_t &)
@trydoc raw"""
    LookupString(this::ByRef1{TVirtualX}, event::ByPtr1{Event_t}, buf::ByPtr2{Int8}, buflen::Int32, keysym::ByRef2{UInt32})::Nothing
Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping).
In "buf" a null terminated ASCII string is returned representing the string that is currently mapped to the key code.

## Arguments

- **`event`** [in] 
    specifies the event structure to be used 
    
- **`buf`** [in] 
    returns the translated characters 
    
- **`buflen`** [in] 
    the length of the buffer 
    
- **`keysym`** [in] 
    returns the "keysym" computed from the event if this argument is not NULL
""" LookupString(this::ByRef1{TVirtualX}, event::ByPtr1{Event_t}, buf::ByPtr2{Int8}, buflen::Int32, keysym::ByRef2{UInt32})

# Wrapper of void TVirtualX::LowerWindow(Window_t)
@trydoc raw"""
    LowerWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Lowers the specified window "id" to the bottom of the stack so that it does not obscure any sibling windows.

""" LowerWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of Bool_t TVirtualX::MakeOpenGLContextCurrent(Handle_t, Window_t)
@trydoc raw"""
    MakeOpenGLContextCurrent(this::ByRef1{TVirtualX}, ctx::ByCopy{Handle_t}, windowID::ByCopy{Window_t})::Bool
Makes context ctx current OpenGL context.

""" MakeOpenGLContextCurrent(this::ByRef1{TVirtualX}, ctx::ByCopy{Handle_t}, windowID::ByCopy{Window_t})

# Wrapper of void TVirtualX::MapGCFont(GContext_t, FontStruct_t)
@trydoc raw"""
    MapGCFont(this::ByRef1{TVirtualX}, ::ByCopy{GContext_t}, ::ByCopy{FontStruct_t})::Nothing
Map the XftFont with the Graphics Context using it.

""" MapGCFont(this::ByRef1{TVirtualX}, ::ByCopy{GContext_t}, ::ByCopy{FontStruct_t})

# Wrapper of void TVirtualX::MapRaised(Window_t)
@trydoc raw"""
    MapRaised(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Maps the window "id" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows.

""" MapRaised(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::MapSubwindows(Window_t)
@trydoc raw"""
    MapSubwindows(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Maps all subwindows for the specified window "id" in top-to-bottom stacking order.

""" MapSubwindows(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::MapWindow(Window_t)
@trydoc raw"""
    MapWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Maps the window "id" and all of its subwindows that have had map requests.
This function has no effect if the window is already mapped.
""" MapWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::MoveResizeWindow(Window_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    MoveResizeWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)::Nothing
Changes the size and location of the specified window "id" without raising it.
## Arguments

- **`id`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in] 
    window identifier 
    . 
    coordinates, which define the new position of the window relative to its parent. 
    . 
    the width and height, which define the interior size of the window
""" MoveResizeWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::MoveWindow(Int_t, Int_t, Int_t)
@trydoc raw"""
    MoveWindow(this::ByRef1{TVirtualX}, wid::Int32, x::Int32, y::Int32)::Nothing
Moves the window "wid" to the specified x and y coordinates.
It does not change the window's size, raise the window, or change the mapping state of the window.

## Arguments

- **`wid`** [in], **`x`** [in], **`y`** [in] 
    window identifier 
    . 
    coordinates, which define the new position of the window relative to its parent.
""" MoveWindow(this::ByRef1{TVirtualX}, wid::Int32, x::Int32, y::Int32)

# Wrapper of Bool_t TVirtualX::NeedRedraw(ULongptr_t, Bool_t)
@trydoc raw"""
    NeedRedraw(this::ByRef1{TVirtualX}, tgwindow::UInt64, force::Bool)::Bool
Notify the low level GUI layer [ROOT](@ref) requires "tgwindow" to be updated.
Returns kTRUE if the notification was desirable and it was sent

At the moment only Qt4 layer needs that

One needs explicitly cast the first parameter to [TGWindow](@ref) to make it working in the implementation.

One needs to process the notification to confine all paint operations within "expose" / "paint" like low level event or equivalent
""" NeedRedraw(this::ByRef1{TVirtualX}, tgwindow::UInt64, force::Bool)

# Wrapper of void TVirtualX::NextEvent(Event_t &)
@trydoc raw"""
    NextEvent(this::ByRef1{TVirtualX}, event::ByRef1{Event_t})::Nothing
The "event" is set to default event.
This method however, should never be called.
""" NextEvent(this::ByRef1{TVirtualX}, event::ByRef1{Event_t})

# Wrapper of Int_t TVirtualX::OpenDisplay(const char *)
@trydoc raw"""
    OpenDisplay(this::ByRef1{TVirtualX}, dpyName::ByCopy{String})::Int32
Opens connection to display server (if such a thing exist on the current platform).
The encoding and interpretation of the display name.

On X11 this method returns on success the X display socket descriptor >0, 0 in case of batch mode, and <0 in case of failure (cannot connect to display dpyName).
""" OpenDisplay(this::ByRef1{TVirtualX}, dpyName::ByCopy{String})

# Wrapper of Int_t TVirtualX::OpenPixmap(UInt_t, UInt_t)
@trydoc raw"""
    OpenPixmap(this::ByRef1{TVirtualX}, w::UInt32, h::UInt32)::Int32
Creates a pixmap of the width "w" and height "h" you specified.

""" OpenPixmap(this::ByRef1{TVirtualX}, w::UInt32, h::UInt32)

# Wrapper of Bool_t TVirtualX::ParseColor(Colormap_t, const char *, ColorStruct_t &)
@trydoc raw"""
    ParseColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, cname::ByCopy{String}, color::ByRef1{ColorStruct_t})::Bool
Looks up the string name of a color "cname" with respect to the screen associated with the specified colormap.
It returns the exact color value. If the color name is not in the Host Portable Character Encoding, the result is implementation dependent.

## Arguments

- **`cmap`** [in] 
    the colormap 
    
- **`cname`** [in] 
    the color name string; use of uppercase or lowercase does not matter 
    
- **`color`** [in] 
    returns the exact color value for later use
    

The [ColorStruct_t](@ref) structure is set to default. Let system think we could parse color.
""" ParseColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, cname::ByCopy{String}, color::ByRef1{ColorStruct_t})

# Wrapper of Bool_t TVirtualX::PointInRegion(Int_t, Int_t, Region_t)
@trydoc raw"""
    PointInRegion(this::ByRef1{TVirtualX}, x::Int32, y::Int32, reg::ByCopy{Region_t})::Bool
Returns kTRUE if the point [x, y] is contained in the region reg.

""" PointInRegion(this::ByRef1{TVirtualX}, x::Int32, y::Int32, reg::ByCopy{Region_t})

# Wrapper of Region_t TVirtualX::PolygonRegion(Point_t *, Int_t, Bool_t)
@trydoc raw"""
    PolygonRegion(this::ByRef1{TVirtualX}, points::ByPtr1{Point_t}, np::Int32, winding::Bool)::ByCopy{Region_t}
Returns a region for the polygon defined by the points array.
## Arguments

- **`points`** [in] 
    specifies an array of points 
    
- **`np`** [in] 
    specifies the number of points in the polygon 
    
- **`winding`** [in] 
    specifies the winding-rule is set (kTRUE) or not(kFALSE)
""" PolygonRegion(this::ByRef1{TVirtualX}, points::ByPtr1{Point_t}, np::Int32, winding::Bool)

# Wrapper of void TVirtualX::PutImage(Drawable_t, GContext_t, Drawable_t, Int_t, Int_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    PutImage(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, img::ByCopy{Drawable_t}, dx::Int32, dy::Int32, x::Int32, y::Int32, w::UInt32, h::UInt32)::Nothing
Combines an image with a rectangle of the specified drawable.
The section of the image defined by the x, y, width, and height arguments is drawn on the specified part of the drawable.

## Arguments

- **`id`** [in], **`gc`** [in], **`img`** [in], **`dx`** [in], **`dy`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in] 
    the drawable 
    . 
    the GC 
    . 
    the image you want combined with the rectangle 
    . 
    the offset in X from the left edge of the image 
    . 
    the offset in Y from the top edge of the image 
    . 
    coordinates, which are relative to the origin of the drawable and are the coordinates of the subimage 
    . 
    the width and height of the subimage, which define the rectangle dimensions
    

GC components in use: function, plane-mask, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC mode-dependent components: foreground and background. (see also the [GCValues_t](@ref) structure)
""" PutImage(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, gc::ByCopy{GContext_t}, img::ByCopy{Drawable_t}, dx::Int32, dy::Int32, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::PutPixel(Drawable_t, Int_t, Int_t, ULong_t)
@trydoc raw"""
    PutPixel(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, x::Int32, y::Int32, pixel::UInt64)::Nothing
Overwrites the pixel in the image with the specified pixel value.
The image must contain the x and y coordinates.

## Arguments

- **`id`** [in], **`x`** [in], **`y`** [in], **`pixel`** [in] 
    specifies the image 
    . 
    coordinates 
    . 
    the new pixel value
""" PutPixel(this::ByRef1{TVirtualX}, id::ByCopy{Drawable_t}, x::Int32, y::Int32, pixel::UInt64)

# Wrapper of void TVirtualX::QueryColor(Colormap_t, ColorStruct_t &)
@trydoc raw"""
    QueryColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, color::ByRef1{ColorStruct_t})::Nothing
Returns the current RGB value for the pixel in the "color" structure.
The color components are set to default.

## Arguments

- **`cmap`** [in] 
    the colormap 
    
- **`color`** [in] 
    specifies and returns the RGB values for the pixel specified in the structure
""" QueryColor(this::ByRef1{TVirtualX}, cmap::ByCopy{Colormap_t}, color::ByRef1{ColorStruct_t})

# Wrapper of void TVirtualX::QueryPointer(Int_t &, Int_t &)
@trydoc raw"""
    QueryPointer(this::ByRef1{TVirtualX}, ix::ByRef2{Int32}, iy::ByRef2{Int32})::Nothing
Returns the pointer position.

""" QueryPointer(this::ByRef1{TVirtualX}, ix::ByRef2{Int32}, iy::ByRef2{Int32})

# Wrapper of void TVirtualX::QueryPointer(Window_t, Window_t &, Window_t &, Int_t &, Int_t &, Int_t &, Int_t &, UInt_t &)
@trydoc raw"""
    QueryPointer(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, rootw::ByRef1{Window_t}, childw::ByRef1{Window_t}, root_x::ByRef2{Int32}, root_y::ByRef2{Int32}, win_x::ByRef2{Int32}, win_y::ByRef2{Int32}, mask::ByRef2{UInt32})::Nothing
Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin.
## Arguments

- **`id`** [in], **`rootw`** [in], **`childw`** [in], **`root_x`** [in], **`root_y`** [in], **`win_x`** [in], **`win_y`** [in], **`mask`** [in] 
    specifies the window 
    . 
    the root window that the pointer is in 
    . 
    the child window that the pointer is located in, if any 
    . 
    the pointer coordinates relative to the root window's origin 
    . 
    the pointer coordinates relative to the specified window "id" 
    . 
    the current state of the modifier keys and pointer buttons
""" QueryPointer(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, rootw::ByRef1{Window_t}, childw::ByRef1{Window_t}, root_x::ByRef2{Int32}, root_y::ByRef2{Int32}, win_x::ByRef2{Int32}, win_y::ByRef2{Int32}, mask::ByRef2{UInt32})

# Wrapper of void TVirtualX::RaiseWindow(Window_t)
@trydoc raw"""
    RaiseWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Raises the specified window to the top of the stack so that no sibling window obscures it.

""" RaiseWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of Pixmap_t TVirtualX::ReadGIF(Int_t, Int_t, const char *, Window_t)
@trydoc raw"""
    ReadGIF(this::ByRef1{TVirtualX}, x0::Int32, y0::Int32, file::ByCopy{String}, id::ByCopy{Window_t})::ByCopy{Pixmap_t}
If id is NULL - loads the specified gif file at position [x0,y0] in the current window.
Otherwise creates pixmap from gif file
""" ReadGIF(this::ByRef1{TVirtualX}, x0::Int32, y0::Int32, file::ByCopy{String}, id::ByCopy{Window_t})

# Wrapper of Bool_t TVirtualX::ReadPictureDataFromFile(const char *, char ***)
@trydoc raw"""
    ReadPictureDataFromFile(this::ByRef1{TVirtualX}, filename::ByCopy{String}, ret_data::ByPtr2{Int8})::Bool
Reads picture data from file "filename" and store it in "ret_data".
Returns kTRUE in case of success, kFALSE otherwise.
""" ReadPictureDataFromFile(this::ByRef1{TVirtualX}, filename::ByCopy{String}, ret_data::ByPtr2{Int8})

# Wrapper of void TVirtualX::RemoveWindow(ULongptr_t)
@trydoc raw"""
    RemoveWindow(this::ByRef1{TVirtualX}, qwid::UInt64)::Nothing
Removes the created by Qt window "qwid".

""" RemoveWindow(this::ByRef1{TVirtualX}, qwid::UInt64)

# Wrapper of void TVirtualX::ReparentWindow(Window_t, Window_t, Int_t, Int_t)
@trydoc raw"""
    ReparentWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, pid::ByCopy{Window_t}, x::Int32, y::Int32)::Nothing
If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent.
The window is placed in the stacking order on top with respect to sibling windows.
""" ReparentWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, pid::ByCopy{Window_t}, x::Int32, y::Int32)

# Wrapper of Int_t TVirtualX::RequestLocator(Int_t, Int_t, Int_t &, Int_t &)
@trydoc raw"""
    RequestLocator(this::ByRef1{TVirtualX}, mode::Int32, ctyp::Int32, x::ByRef2{Int32}, y::ByRef2{Int32})::Int32
Requests Locator position.
## Arguments

- **`x`** [in], **`y`** [in], **`ctyp`** [in], **`mode`** [in] 
    cursor position at moment of button press (output) 
    . 
    cursor type (input)
    
    - ctyp = 1 tracking cross
    - ctyp = 2 cross-hair
    - ctyp = 3 rubber circle
    - ctyp = 4 rubber band
    - ctyp = 5 rubber rectangle
    
    . 
    input mode
    
    - mode = 0 request
    - mode = 1 sample
    
    

###Return


in request mode:
1 = left is pressed
2 = middle is pressed
3 = right is pressed


in sample mode:
11 = left is released
12 = middle is released
13 = right is released
-1 = nothing is pressed or released
-2 = leave the window
else = keycode (keyboard is pressed)
""" RequestLocator(this::ByRef1{TVirtualX}, mode::Int32, ctyp::Int32, x::ByRef2{Int32}, y::ByRef2{Int32})

# Wrapper of Int_t TVirtualX::RequestString(Int_t, Int_t, char *)
@trydoc raw"""
    RequestString(this::ByRef1{TVirtualX}, x::Int32, y::Int32, text::ByPtr2{Int8})::Int32
Requests string: text is displayed and can be edited with Emacs-like keybinding.
Returns termination code (0 for ESC, 1 for RETURN)

## Arguments

- **`x`** [in], **`y`** [in], **`text`** [in] 
    position where text is displayed 
    . 
    displayed text (as input), edited text (as output)
""" RequestString(this::ByRef1{TVirtualX}, x::Int32, y::Int32, text::ByPtr2{Int8})

# Wrapper of void TVirtualX::RescaleWindow(Int_t, UInt_t, UInt_t)
@trydoc raw"""
    RescaleWindow(this::ByRef1{TVirtualX}, wid::Int32, w::UInt32, h::UInt32)::Nothing
Rescales the window "wid".
## Arguments

- **`wid`** [in] 
    window identifier 
    
- **`w`** [in] 
    the width 
    
- **`h`** [in] 
    the height
""" RescaleWindow(this::ByRef1{TVirtualX}, wid::Int32, w::UInt32, h::UInt32)

# Wrapper of Int_t TVirtualX::ResizePixmap(Int_t, UInt_t, UInt_t)
@trydoc raw"""
    ResizePixmap(this::ByRef1{TVirtualX}, wid::Int32, w::UInt32, h::UInt32)::Int32
Resizes the specified pixmap "wid".
## Arguments

- **`wid`** [in], **`w`** [in], **`h`** [in] 
    window identifier 
    . 
    the width and height which define the pixmap dimensions
""" ResizePixmap(this::ByRef1{TVirtualX}, wid::Int32, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::ResizeWindow(Int_t)
@trydoc raw"""
    ResizeWindow(this::ByRef1{TVirtualX}, wid::Int32)::Nothing
Resizes the window "wid" if necessary.

""" ResizeWindow(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of void TVirtualX::ResizeWindow(Window_t, UInt_t, UInt_t)
@trydoc raw"""
    ResizeWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, w::UInt32, h::UInt32)::Nothing
Changes the width and height of the specified window "id", not including its borders.
This function does not change the window's upper-left coordinate.

## Arguments

- **`id`** [in], **`w`** [in], **`h`** [in] 
    window identifier 
    . 
    the width and height, which are the interior dimensions of the window after the call completes.
""" ResizeWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::SelectInput(Window_t, UInt_t)
@trydoc raw"""
    SelectInput(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, evmask::UInt32)::Nothing
Defines which input events the window is interested in.
By default events are propagated up the window stack. This mask can also be set at window creation time via the [SetWindowAttributes_t!fEventMask](@ref) attribute.
""" SelectInput(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, evmask::UInt32)

# Wrapper of void TVirtualX::SelectPixmap(Int_t)
@trydoc raw"""
    SelectPixmap(this::ByRef1{TVirtualX}, qpixid::Int32)::Nothing
Selects the pixmap "qpixid".

""" SelectPixmap(this::ByRef1{TVirtualX}, qpixid::Int32)

# Wrapper of void TVirtualX::SelectWindow(Int_t)
@trydoc raw"""
    SelectWindow(this::ByRef1{TVirtualX}, wid::Int32)::Nothing
Selects the window "wid" to which subsequent output is directed.

""" SelectWindow(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of void TVirtualX::SendEvent(Window_t, Event_t *)
@trydoc raw"""
    SendEvent(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, ev::ByPtr1{Event_t})::Nothing
Specifies the event "ev" is to be sent to the window "id".
This function requires you to pass an event mask.
""" SendEvent(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, ev::ByPtr1{Event_t})

# Wrapper of void TVirtualX::SetCharacterUp(Float_t, Float_t)
@trydoc raw"""
    SetCharacterUp(this::ByRef1{TVirtualX}, chupx::Float32, chupy::Float32)::Nothing
Sets character up vector.

""" SetCharacterUp(this::ByRef1{TVirtualX}, chupx::Float32, chupy::Float32)

# Wrapper of void TVirtualX::SetClassHints(Window_t, char *, char *)
@trydoc raw"""
    SetClassHints(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, className::ByPtr2{Int8}, resourceName::ByPtr2{Int8})::Nothing
Sets the windows class and resource name.

""" SetClassHints(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, className::ByPtr2{Int8}, resourceName::ByPtr2{Int8})

# Wrapper of void TVirtualX::SetClipOFF(Int_t)
@trydoc raw"""
    SetClipOFF(this::ByRef1{TVirtualX}, wid::Int32)::Nothing
Turns off the clipping for the window "wid".

""" SetClipOFF(this::ByRef1{TVirtualX}, wid::Int32)

# Wrapper of void TVirtualX::SetClipRectangles(GContext_t, Int_t, Int_t, Rectangle_t *, Int_t)
@trydoc raw"""
    SetClipRectangles(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, recs::ByPtr1{Rectangle_t}, n::Int32)::Nothing
Sets clipping rectangles in graphics context.
[x,y] specify the origin of the rectangles. "recs" specifies an array of rectangles that define the clipping mask and "n" is the number of rectangles. (see also the [GCValues_t](@ref) structure)
""" SetClipRectangles(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, x::Int32, y::Int32, recs::ByPtr1{Rectangle_t}, n::Int32)

# Wrapper of void TVirtualX::SetClipRegion(Int_t, Int_t, Int_t, UInt_t, UInt_t)
@trydoc raw"""
    SetClipRegion(this::ByRef1{TVirtualX}, wid::Int32, x::Int32, y::Int32, w::UInt32, h::UInt32)::Nothing
Sets clipping region for the window "wid".
## Arguments

- **`wid`** [in], **`x`** [in], **`y`** [in], **`w`** [in], **`h`** [in] 
    window identifier 
    . 
    origin of clipping rectangle 
    . 
    the clipping rectangle dimensions
""" SetClipRegion(this::ByRef1{TVirtualX}, wid::Int32, x::Int32, y::Int32, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::SetCursor(Int_t, ECursor)
@trydoc raw"""
    SetCursor(this::ByRef1{TVirtualX}, win::Int32, cursor::ByCopy{ECursor})::Nothing
The cursor "cursor" will be used when the pointer is in the window "wid".

""" SetCursor(this::ByRef1{TVirtualX}, win::Int32, cursor::ByCopy{ECursor})

# Wrapper of void TVirtualX::SetDashes(GContext_t, Int_t, const char *, Int_t)
@trydoc raw"""
    SetDashes(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, offset::Int32, dash_list::ByCopy{String}, n::Int32)::Nothing
Sets the dash-offset and dash-list attributes for dashed line styles in the specified GC.
There must be at least one element in the specified dash_list. The initial and alternating elements (second, fourth, and so on) of the dash_list are the even dashes, and the others are the odd dashes. Each element in the "dash_list" array specifies the length (in pixels) of a segment of the pattern.

## Arguments

- **`gc`** [in] 
    specifies the GC (see [GCValues_t](@ref) structure) 
    
- **`offset`** [in] 
    the phase of the pattern for the dashed line-style you want to set for the specified GC. 
    
- **`dash_list`** [in] 
    the dash-list for the dashed line-style you want to set for the specified GC 
    
- **`n`** [in] 
    the number of elements in dash_list (see also the [GCValues_t](@ref) structure)
""" SetDashes(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, offset::Int32, dash_list::ByCopy{String}, n::Int32)

# Wrapper of void TVirtualX::SetDNDAware(Window_t, Atom_t *)
@trydoc raw"""
    SetDNDAware(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByPtr1{Atom_t})::Nothing
Add XdndAware property and the list of drag and drop types to the Window win.

""" SetDNDAware(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByPtr1{Atom_t})

# Wrapper of void TVirtualX::SetDoubleBuffer(Int_t, Int_t)
@trydoc raw"""
    SetDoubleBuffer(this::ByRef1{TVirtualX}, wid::Int32, mode::Int32)::Nothing
Sets the double buffer on/off on the window "wid".
## Arguments

- **`wid`** [in] 
    window identifier.
    
    - 999 means all opened windows. 
    
    
- **`mode`** [in] 
    the on/off switch
    
    - mode = 1 double buffer is on
    - mode = 0 double buffer is off
""" SetDoubleBuffer(this::ByRef1{TVirtualX}, wid::Int32, mode::Int32)

# Wrapper of void TVirtualX::SetDoubleBufferOFF()
@trydoc raw"""
    SetDoubleBufferOFF(this::ByRef1{TVirtualX})::Nothing
Turns double buffer mode off.

""" SetDoubleBufferOFF(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::SetDoubleBufferON()
@trydoc raw"""
    SetDoubleBufferON(this::ByRef1{TVirtualX})::Nothing
Turns double buffer mode on.

""" SetDoubleBufferON(this::ByRef1{TVirtualX})

# Wrapper of void TVirtualX::SetFillColor(Color_t)
@trydoc raw"""
    SetFillColor(this::ByRef1{TVirtualX}, cindex::Int16)::Nothing
Sets color index "cindex" for fill areas.

""" SetFillColor(this::ByRef1{TVirtualX}, cindex::Int16)

# Wrapper of void TVirtualX::SetFillStyle(Style_t)
@trydoc raw"""
    SetFillStyle(this::ByRef1{TVirtualX}, style::Int16)::Nothing
Sets fill area style.
## Arguments

- **`style`** [in] 
    compound fill area interior style
    
    - style = 1000 * interiorstyle + styleindex
""" SetFillStyle(this::ByRef1{TVirtualX}, style::Int16)

# Wrapper of void TVirtualX::SetForeground(GContext_t, ULong_t)
@trydoc raw"""
    SetForeground(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, foreground::UInt64)::Nothing
Sets the foreground color for the specified GC (shortcut for ChangeGC with only foreground mask set).
## Arguments

- **`gc`** [in] 
    specifies the GC 
    
- **`foreground`** [in] 
    the foreground you want to set
    

(see also the [GCValues_t](@ref) structure)
""" SetForeground(this::ByRef1{TVirtualX}, gc::ByCopy{GContext_t}, foreground::UInt64)

# Wrapper of void TVirtualX::SetIconName(Window_t, char *)
@trydoc raw"""
    SetIconName(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, name::ByPtr2{Int8})::Nothing
Sets the window icon name.

""" SetIconName(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, name::ByPtr2{Int8})

# Wrapper of void TVirtualX::SetIconPixmap(Window_t, Pixmap_t)
@trydoc raw"""
    SetIconPixmap(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, pix::ByCopy{Pixmap_t})::Nothing
Sets the icon name pixmap.

""" SetIconPixmap(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, pix::ByCopy{Pixmap_t})

# Wrapper of void TVirtualX::SetInputFocus(Window_t)
@trydoc raw"""
    SetInputFocus(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Changes the input focus to specified window "id".

""" SetInputFocus(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::SetKeyAutoRepeat(Bool_t)
@trydoc raw"""
    SetKeyAutoRepeat(this::ByRef1{TVirtualX}, on::Bool)::Nothing
Turns key auto repeat on (kTRUE) or off (kFALSE).

""" SetKeyAutoRepeat(this::ByRef1{TVirtualX}, on::Bool)

# Wrapper of void TVirtualX::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TVirtualX}, cindex::Int16)::Nothing
Sets color index "cindex" for drawing lines.

""" SetLineColor(this::ByRef1{TVirtualX}, cindex::Int16)

# Wrapper of void TVirtualX::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TVirtualX}, linestyle::Int16)::Nothing
Sets the line style.
## Arguments

- **`linestyle`** [in] 
    line style.
    
    - linestyle <= 1 solid
    - linestyle = 2 dashed
    - linestyle = 3 dotted
    - linestyle = 4 dashed-dotted
""" SetLineStyle(this::ByRef1{TVirtualX}, linestyle::Int16)

# Wrapper of void TVirtualX::SetLineType(Int_t, Int_t *)
@trydoc raw"""
    SetLineType(this::ByRef1{TVirtualX}, n::Int32, dash::ByPtr2{Int32})::Nothing
Sets the line type.
## Arguments

- **`n`** [in] 
    length of the dash list
    
    - n <= 0 use solid lines
    - n > 0 use dashed lines described by dash(n) e.g. n = 4,dash = (6,3,1,3) gives a dashed-dotted line with dash length 6 and a gap of 7 between dashes 
    
    
- **`dash`** [in] 
    dash segment lengths
""" SetLineType(this::ByRef1{TVirtualX}, n::Int32, dash::ByPtr2{Int32})

# Wrapper of void TVirtualX::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TVirtualX}, width::Int16)::Nothing
Sets the line width.
## Arguments

- **`width`** [in] 
    the line width in pixels
""" SetLineWidth(this::ByRef1{TVirtualX}, width::Int16)

# Wrapper of void TVirtualX::SetMarkerColor(Color_t)
@trydoc raw"""
    SetMarkerColor(this::ByRef1{TVirtualX}, cindex::Int16)::Nothing
Sets color index "cindex" for markers.

""" SetMarkerColor(this::ByRef1{TVirtualX}, cindex::Int16)

# Wrapper of void TVirtualX::SetMarkerSize(Float_t)
@trydoc raw"""
    SetMarkerSize(this::ByRef1{TVirtualX}, markersize::Float32)::Nothing
Sets marker size index.
## Arguments

- **`markersize`** [in] 
    the marker scale factor
""" SetMarkerSize(this::ByRef1{TVirtualX}, markersize::Float32)

# Wrapper of void TVirtualX::SetMarkerStyle(Style_t)
@trydoc raw"""
    SetMarkerStyle(this::ByRef1{TVirtualX}, markerstyle::Int16)::Nothing
Sets marker style.

""" SetMarkerStyle(this::ByRef1{TVirtualX}, markerstyle::Int16)

# Wrapper of void TVirtualX::SetMWMHints(Window_t, UInt_t, UInt_t, UInt_t)
@trydoc raw"""
    SetMWMHints(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, value::UInt32, funcs::UInt32, input::UInt32)::Nothing
Sets decoration style.

""" SetMWMHints(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, value::UInt32, funcs::UInt32, input::UInt32)

# Wrapper of void TVirtualX::SetOpacity(Int_t)
@trydoc raw"""
    SetOpacity(this::ByRef1{TVirtualX}, percent::Int32)::Nothing
Sets opacity of the current window.
This image manipulation routine works by adding to a percent amount of neutral to each pixels RGB. Since it requires quite some additional color map entries is it only supported on displays with more than > 8 color planes (> 256 colors).
""" SetOpacity(this::ByRef1{TVirtualX}, percent::Int32)

# Wrapper of void TVirtualX::SetPrimarySelectionOwner(Window_t)
@trydoc raw"""
    SetPrimarySelectionOwner(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Makes the window "id" the current owner of the primary selection.
That is the window in which, for example some text is selected.
""" SetPrimarySelectionOwner(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::SetRGB(Int_t, Float_t, Float_t, Float_t)
@trydoc raw"""
    SetRGB(this::ByRef1{TVirtualX}, cindex::Int32, r::Float32, g::Float32, b::Float32)::Nothing
Sets color intensities the specified color index "cindex".
## Arguments

- **`cindex`** [in], **`r`** [in], **`g`** [in], **`b`** [in] 
    color index 
    . 
    the red, green, blue intensities between 0.0 and 1.0
""" SetRGB(this::ByRef1{TVirtualX}, cindex::Int32, r::Float32, g::Float32, b::Float32)

# Wrapper of Bool_t TVirtualX::SetSelectionOwner(Window_t, Atom_t &)
@trydoc raw"""
    SetSelectionOwner(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByRef1{Atom_t})::Bool
Changes the owner and last-change time for the specified selection.

""" SetSelectionOwner(this::ByRef1{TVirtualX}, ::ByCopy{Window_t}, ::ByRef1{Atom_t})

# Wrapper of void TVirtualX::SetTextAlign(Short_t)
@trydoc raw"""
    SetTextAlign(this::ByRef1{TVirtualX}, talign::Int16)::Nothing
Sets the text alignment.
## Arguments

- **`talign`** [in] 
    text alignment.
    
    - talign = txalh horizontal text alignment
    - talign = txalv vertical text alignment
""" SetTextAlign(this::ByRef1{TVirtualX}, talign::Int16)

# Wrapper of void TVirtualX::SetTextColor(Color_t)
@trydoc raw"""
    SetTextColor(this::ByRef1{TVirtualX}, cindex::Int16)::Nothing
Sets the color index "cindex" for text.

""" SetTextColor(this::ByRef1{TVirtualX}, cindex::Int16)

# Wrapper of void TVirtualX::SetTextFont(Font_t)
@trydoc raw"""
    SetTextFont(this::ByRef1{TVirtualX}, fontnumber::Int16)::Nothing
Sets the current text font number.

""" SetTextFont(this::ByRef1{TVirtualX}, fontnumber::Int16)

# Wrapper of void TVirtualX::SetTextMagnitude(Float_t)
@trydoc raw"""
    SetTextMagnitude(this::ByRef1{TVirtualX}, mgn::Float32)::Nothing
Sets the current text magnification factor to "mgn".

""" SetTextMagnitude(this::ByRef1{TVirtualX}, mgn::Float32)

# Wrapper of void TVirtualX::SetTextSize(Float_t)
@trydoc raw"""
    SetTextSize(this::ByRef1{TVirtualX}, textsize::Float32)::Nothing
Sets the current text size to "textsize".

""" SetTextSize(this::ByRef1{TVirtualX}, textsize::Float32)

# Wrapper of void TVirtualX::SetTypeList(Window_t, Atom_t, Atom_t *)
@trydoc raw"""
    SetTypeList(this::ByRef1{TVirtualX}, win::ByCopy{Window_t}, prop::ByCopy{Atom_t}, typelist::ByPtr1{Atom_t})::Nothing
Add the list of drag and drop types to the Window win.

""" SetTypeList(this::ByRef1{TVirtualX}, win::ByCopy{Window_t}, prop::ByCopy{Atom_t}, typelist::ByPtr1{Atom_t})

# Wrapper of void TVirtualX::SetWindowBackground(Window_t, ULong_t)
@trydoc raw"""
    SetWindowBackground(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, color::UInt64)::Nothing
Sets the background of the window "id" to the specified color value "color".
Changing the background does not cause the window contents to be changed.
""" SetWindowBackground(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, color::UInt64)

# Wrapper of void TVirtualX::SetWindowBackgroundPixmap(Window_t, Pixmap_t)
@trydoc raw"""
    SetWindowBackgroundPixmap(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, pxm::ByCopy{Pixmap_t})::Nothing
Sets the background pixmap of the window "id" to the specified pixmap "pxm".

""" SetWindowBackgroundPixmap(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, pxm::ByCopy{Pixmap_t})

# Wrapper of void TVirtualX::SetWindowName(Window_t, char *)
@trydoc raw"""
    SetWindowName(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, name::ByPtr2{Int8})::Nothing
Sets the window name.

""" SetWindowName(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, name::ByPtr2{Int8})

# Wrapper of void TVirtualX::SetWMPosition(Window_t, Int_t, Int_t)
@trydoc raw"""
    SetWMPosition(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32)::Nothing
Tells the window manager the desired position [x,y] of window "id".

""" SetWMPosition(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32)

# Wrapper of void TVirtualX::SetWMSize(Window_t, UInt_t, UInt_t)
@trydoc raw"""
    SetWMSize(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, w::UInt32, h::UInt32)::Nothing
Tells window manager the desired size of window "id".
## Arguments

- **`id`** [in] 
    window identifier 
    
- **`w`** [in] 
    the width 
    
- **`h`** [in] 
    the height
""" SetWMSize(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, w::UInt32, h::UInt32)

# Wrapper of void TVirtualX::SetWMSizeHints(Window_t, UInt_t, UInt_t, UInt_t, UInt_t, UInt_t, UInt_t)
@trydoc raw"""
    SetWMSizeHints(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, wmin::UInt32, hmin::UInt32, wmax::UInt32, hmax::UInt32, winc::UInt32, hinc::UInt32)::Nothing
Gives the window manager minimum and maximum size hints of the window "id".
Also specify via "winc" and "hinc" the resize increments.

## Arguments

- **`id`** [in], **`wmin`** [in], **`hmin`** [in], **`wmax`** [in], **`hmax`** [in], **`winc`** [in], **`hinc`** [in] 
    window identifier 
    . 
    specify the minimum window size 
    . 
    specify the maximum window size 
    . 
    define an arithmetic progression of sizes into which the window to be resized (minimum to maximum)
""" SetWMSizeHints(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, wmin::UInt32, hmin::UInt32, wmax::UInt32, hmax::UInt32, winc::UInt32, hinc::UInt32)

# Wrapper of void TVirtualX::SetWMState(Window_t, EInitialState)
@trydoc raw"""
    SetWMState(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, state::ByCopy{EInitialState})::Nothing
Sets the initial state of the window "id": either kNormalState or kIconicState.

""" SetWMState(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, state::ByCopy{EInitialState})

# Wrapper of void TVirtualX::SetWMTransientHint(Window_t, Window_t)
@trydoc raw"""
    SetWMTransientHint(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, main_id::ByCopy{Window_t})::Nothing
Tells window manager that the window "id" is a transient window of the window "main_id".
A window manager may decide not to decorate a transient window or may treat it differently in other ways.
""" SetWMTransientHint(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, main_id::ByCopy{Window_t})

# Wrapper of void TVirtualX::ShapeCombineMask(Window_t, Int_t, Int_t, Pixmap_t)
@trydoc raw"""
    ShapeCombineMask(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32, mask::ByCopy{Pixmap_t})::Nothing
The Non-rectangular Window Shape Extension adds non-rectangular windows to the System.
This allows for making shaped (partially transparent) windows
""" ShapeCombineMask(this::ByRef1{TVirtualX}, id::ByCopy{Window_t}, x::Int32, y::Int32, mask::ByCopy{Pixmap_t})

# Wrapper of void TVirtualX::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TVirtualX}, ::ByRef1{TBuffer})::Nothing


""" Streamer(this::ByRef1{TVirtualX}, ::ByRef1{TBuffer})

# Wrapper of void TVirtualX::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TVirtualX}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TVirtualX}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TVirtualX::SubtractRegion(Region_t, Region_t, Region_t)
@trydoc raw"""
    SubtractRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})::Nothing
Subtracts regb from rega and stores the results in result.

""" SubtractRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})

# Wrapper of void TVirtualX::Sync(Int_t)
@trydoc raw"""
    Sync(this::ByRef1{TVirtualX}, mode::Int32)::Nothing
Set synchronisation on or off.
## Arguments

- **`mode`** [in] 
    synchronisation on/off
    
    - mode=1 on
    - mode<>0 off
""" Sync(this::ByRef1{TVirtualX}, mode::Int32)

# Wrapper of Int_t TVirtualX::TextWidth(FontStruct_t, const char *, Int_t)
@trydoc raw"""
    TextWidth(this::ByRef1{TVirtualX}, font::ByCopy{FontStruct_t}, s::ByCopy{String}, len::Int32)::Int32
Return length of the string "s" in pixels. Size depends on font.

""" TextWidth(this::ByRef1{TVirtualX}, font::ByCopy{FontStruct_t}, s::ByCopy{String}, len::Int32)

# Wrapper of void TVirtualX::TranslateCoordinates(Window_t, Window_t, Int_t, Int_t, Int_t &, Int_t &, Window_t &)
@trydoc raw"""
    TranslateCoordinates(this::ByRef1{TVirtualX}, src::ByCopy{Window_t}, dest::ByCopy{Window_t}, src_x::Int32, src_y::Int32, dest_x::ByRef2{Int32}, dest_y::ByRef2{Int32}, child::ByRef1{Window_t})::Nothing
Translates coordinates in one window to the coordinate space of another window.
It takes the "src_x" and "src_y" coordinates relative to the source window's origin and returns these coordinates to "dest_x" and "dest_y" relative to the destination window's origin.

## Arguments

- **`src`** [in], **`dest`** [in], **`src_x`** [in], **`src_y`** [in], **`dest_x`** [in], **`dest_y`** [in], **`child`** [in] 
    the source window 
    . 
    the destination window 
    . 
    coordinates within the source window 
    . 
    coordinates within the destination window 
    . 
    returns the child of "dest" if the coordinates are contained in a mapped child of the destination window; otherwise, child is set to 0
""" TranslateCoordinates(this::ByRef1{TVirtualX}, src::ByCopy{Window_t}, dest::ByCopy{Window_t}, src_x::Int32, src_y::Int32, dest_x::ByRef2{Int32}, dest_y::ByRef2{Int32}, child::ByRef1{Window_t})

# Wrapper of void TVirtualX::UnionRectWithRegion(Rectangle_t *, Region_t, Region_t)
@trydoc raw"""
    UnionRectWithRegion(this::ByRef1{TVirtualX}, rect::ByPtr1{Rectangle_t}, src::ByCopy{Region_t}, dest::ByCopy{Region_t})::Nothing
Updates the destination region from a union of the specified rectangle and the specified source region.
## Arguments

- **`rect`** [in] 
    specifies the rectangle 
    
- **`src`** [in] 
    specifies the source region to be used 
    
- **`dest`** [in] 
    returns the destination region
""" UnionRectWithRegion(this::ByRef1{TVirtualX}, rect::ByPtr1{Rectangle_t}, src::ByCopy{Region_t}, dest::ByCopy{Region_t})

# Wrapper of void TVirtualX::UnionRegion(Region_t, Region_t, Region_t)
@trydoc raw"""
    UnionRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})::Nothing
Computes the union of two regions.
## Arguments

- **`rega`** [in], **`regb`** [in], **`result`** [in] 
    specify the two regions with which you want to perform the computation 
    . 
    returns the result of the computation
""" UnionRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})

# Wrapper of void TVirtualX::UnmapWindow(Window_t)
@trydoc raw"""
    UnmapWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Unmaps the specified window "id".
If the specified window is already unmapped, this function has no effect. Any child window will no longer be visible (but they are still mapped) until another map call is made on the parent.
""" UnmapWindow(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::Update(Int_t)
@trydoc raw"""
    Update(this::ByRef1{TVirtualX}, mode::Int32)::Nothing
Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer.
Flush flushes output buffer. Sync flushes buffer and waits till all requests have been processed by X server.
""" Update(this::ByRef1{TVirtualX}, mode::Int32)

# Wrapper of void TVirtualX::UpdateWindow(Int_t)
@trydoc raw"""
    UpdateWindow(this::ByRef1{TVirtualX}, mode::Int32)::Nothing
Updates or synchronises client and server once (not permanent).
according to "mode".

## Arguments

- **`mode`** [in] 
    update mode.
    
    - mode = 1 update
    - mode = 0 sync
""" UpdateWindow(this::ByRef1{TVirtualX}, mode::Int32)

# Wrapper of void TVirtualX::Warp(Int_t, Int_t, Window_t)
@trydoc raw"""
    Warp(this::ByRef1{TVirtualX}, ix::Int32, iy::Int32, id::ByCopy{Window_t})::Nothing
Sets the pointer position.
## Arguments

- **`ix`** [in] 
    new X coordinate of pointer 
    
- **`iy`** [in] 
    new Y coordinate of pointer 
    
- **`id`** [in] 
    window identifier
    

Coordinates are relative to the origin of the window id or to the origin of the current window if id == 0.
""" Warp(this::ByRef1{TVirtualX}, ix::Int32, iy::Int32, id::ByCopy{Window_t})

# Wrapper of void TVirtualX::WMDeleteNotify(Window_t)
@trydoc raw"""
    WMDeleteNotify(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})::Nothing
Tells WM to send message when window is closed via WM.

""" WMDeleteNotify(this::ByRef1{TVirtualX}, id::ByCopy{Window_t})

# Wrapper of Int_t TVirtualX::WriteGIF(char *)
@trydoc raw"""
    WriteGIF(this::ByRef1{TVirtualX}, name::ByPtr2{Int8})::Int32
Writes the current window into GIF file.
Returns 1 in case of success, 0 otherwise.
""" WriteGIF(this::ByRef1{TVirtualX}, name::ByPtr2{Int8})

# Wrapper of void TVirtualX::WritePixmap(Int_t, UInt_t, UInt_t, char *)
@trydoc raw"""
    WritePixmap(this::ByRef1{TVirtualX}, wid::Int32, w::UInt32, h::UInt32, pxname::ByPtr2{Int8})::Nothing
Writes the pixmap "wid" in the bitmap file "pxname".
## Arguments

- **`wid`** [in], **`w`** [in], **`h`** [in], **`pxname`** [in] 
    the pixmap address 
    . 
    the width and height of the pixmap. 
    . 
    the file name
""" WritePixmap(this::ByRef1{TVirtualX}, wid::Int32, w::UInt32, h::UInt32, pxname::ByPtr2{Int8})

# Wrapper of void TVirtualX::XorRegion(Region_t, Region_t, Region_t)
@trydoc raw"""
    XorRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})::Nothing
Calculates the difference between the union and intersection of two regions.
## Arguments

- **`rega`** [in], **`regb`** [in], **`result`** [in] 
    specify the two regions with which you want to perform the computation 
    . 
    returns the result of the computation
""" XorRegion(this::ByRef1{TVirtualX}, rega::ByCopy{Region_t}, regb::ByCopy{Region_t}, result::ByCopy{Region_t})

# Wrapper of int TClassTable::Classes()
@trydoc raw"""
    Classes(this::ByRef1{TClassTable})::Int32


""" Classes(this::ByRef1{TClassTable})

# Wrapper of void TArrayL::AddAt(Long_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayL}, c::Int64, i::Int32)::Nothing
Add long c at position i. Check for out of bounds.

""" AddAt(this::ByRef1{TArrayL}, c::Int64, i::Int32)

# Wrapper of void TArrayL::Adopt(Int_t, Long_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayL}, n::Int32, array::ByPtr2{Int64})::Nothing
Adopt array arr into [TArrayL](@ref), i.e.
don't copy arr but use it directly in [TArrayL](@ref). User may not delete arr, [TArrayL](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayL}, n::Int32, array::ByPtr2{Int64})

# Wrapper of Long_t * TArrayL::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayL})::CxxPtr2{Int64}


""" GetArray(this::ByRef1{TArrayL})

# Wrapper of TArrayL & TArrayL::operator=(const TArrayL &)
@trydoc raw"""
    assign(this::ByRef1{TArrayL}, rhs::ByConstRef1{TArrayL})::CxxRef1{TArrayL}
[TArrayL](@ref) assignment operator.

""" assign(this::ByRef1{TArrayL}, rhs::ByConstRef1{TArrayL})

# Wrapper of Long_t & TArrayL::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayL}, i::Int32)::CxxRef2{Int64}


""" Base.getindex(this::ByRef1{TArrayL}, i::Int32)

# Wrapper of void TArrayL::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TArrayL})::Nothing


""" Reset(this::ByRef1{TArrayL})

# Wrapper of void TArrayL::Reset(Long_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayL}, val::Int64)::Nothing


""" Reset(this::ByRef1{TArrayL}, val::Int64)

# Wrapper of void TArrayL::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayL}, n::Int32)::Nothing
Set size of this array to n longs.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayL}, n::Int32)

# Wrapper of void TArrayL::Set(Int_t, const Long_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayL}, n::Int32, array::ByConstPtr2{Int64})::Nothing
Set size of this array to n longs and set the contents.
This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayL}, n::Int32, array::ByConstPtr2{Int64})

# Wrapper of void TArrayL::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayL}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayL}, v::Float64, i::Int32)

# Wrapper of void TBtree::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TBtree}, obj::ByPtr1{TObject})::Nothing
Add object to B-tree.

""" Add(this::ByRef1{TBtree}, obj::ByPtr1{TObject})

# Wrapper of void TBtree::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TBtree}, ::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing


""" AddAfter(this::ByRef1{TBtree}, ::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TBtree::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TBtree}, obj::ByPtr1{TObject}, ::Int32)::Nothing


""" AddAt(this::ByRef1{TBtree}, obj::ByPtr1{TObject}, ::Int32)

# Wrapper of void TBtree::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TBtree}, ::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing


""" AddBefore(this::ByRef1{TBtree}, ::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TBtree::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TBtree}, obj::ByPtr1{TObject})::Nothing


""" AddFirst(this::ByRef1{TBtree}, obj::ByPtr1{TObject})

# Wrapper of void TBtree::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TBtree}, obj::ByPtr1{TObject})::Nothing


""" AddLast(this::ByRef1{TBtree}, obj::ByPtr1{TObject})

# Wrapper of void TBtree::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TBtree}, option::ByCopy{String})::Nothing
Remove all objects from B-tree.
Does NOT delete objects unless the [TBtree](@ref) is the owner (set via [SetOwner()](@ref)).
""" Clear(this::ByRef1{TBtree}, option::ByCopy{String})

# Wrapper of void TBtree::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TBtree}, option::ByCopy{String})::Nothing
Remove all objects from B-tree AND delete all heap based objects.

""" Delete(this::ByRef1{TBtree}, option::ByCopy{String})

# Wrapper of Int_t TBtree::Order()
@trydoc raw"""
    Order(this::ByRef1{TBtree})::Int32


""" Order(this::ByRef1{TBtree})

# Wrapper of TObject * TBtree::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TBtree}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove an object from the tree.

""" Remove(this::ByRef1{TBtree}, obj::ByPtr1{TObject})

# Wrapper of void TBtNode::Add(const TObject *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBtNode}, obj::ByConstPtr1{TObject}, index::Int32)::Nothing


""" Add(this::ByRef1{TBtNode}, obj::ByConstPtr1{TObject}, index::Int32)

# Wrapper of TBtLeafNode * TBtNode::FirstLeafNode()
@trydoc raw"""
    FirstLeafNode(this::ByRef1{TBtNode})::CxxPtr1{TBtLeafNode}


""" FirstLeafNode(this::ByRef1{TBtNode})

# Wrapper of TObject * TBtNode::Found(const TObject *, TBtNode **, Int_t *)
@trydoc raw"""
    Found(this::ByRef1{TBtNode}, obj::ByConstPtr1{TObject}, which::ByPtr1{TBtNode}, where::ByPtr2{Int32})::CxxPtr1{TObject}


""" Found(this::ByRef1{TBtNode}, obj::ByConstPtr1{TObject}, which::ByPtr1{TBtNode}, where::ByPtr2{Int32})

# Wrapper of TBtLeafNode * TBtNode::LastLeafNode()
@trydoc raw"""
    LastLeafNode(this::ByRef1{TBtNode})::CxxPtr1{TBtLeafNode}


""" LastLeafNode(this::ByRef1{TBtNode})

# Wrapper of void TBtNode::Remove(Int_t)
@trydoc raw"""
    Remove(this::ByRef1{TBtNode}, index::Int32)::Nothing


""" Remove(this::ByRef1{TBtNode}, index::Int32)

# Wrapper of void TBtNode::Split()
@trydoc raw"""
    Split(this::ByRef1{TBtNode})::Nothing


""" Split(this::ByRef1{TBtNode})

# Wrapper of void TBtInnerNode::Add(const TObject *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBtInnerNode}, obj::ByConstPtr1{TObject}, idx::Int32)::Nothing
This is called only from [TBtree!Add()](@ref).
""" Add(this::ByRef1{TBtInnerNode}, obj::ByConstPtr1{TObject}, idx::Int32)

# Wrapper of void TBtInnerNode::Add(Int_t, TObject *, TBtNode *)
@trydoc raw"""
    Add(this::ByRef1{TBtInnerNode}, at::Int32, obj::ByPtr1{TObject}, n::ByPtr1{TBtNode})::Nothing
Add one element.

""" Add(this::ByRef1{TBtInnerNode}, at::Int32, obj::ByPtr1{TObject}, n::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::Add(TBtItem &, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBtInnerNode}, i::ByRef1{TBtItem}, idx::Int32)::Nothing
Add one element.

""" Add(this::ByRef1{TBtInnerNode}, i::ByRef1{TBtItem}, idx::Int32)

# Wrapper of void TBtInnerNode::AddElt(Int_t, TObject *, TBtNode *)
@trydoc raw"""
    AddElt(this::ByRef1{TBtInnerNode}, at::Int32, obj::ByPtr1{TObject}, n::ByPtr1{TBtNode})::Nothing
Add one element.

""" AddElt(this::ByRef1{TBtInnerNode}, at::Int32, obj::ByPtr1{TObject}, n::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::AddElt(TBtItem &, Int_t)
@trydoc raw"""
    AddElt(this::ByRef1{TBtInnerNode}, itm::ByRef1{TBtItem}, at::Int32)::Nothing
Add one element.

""" AddElt(this::ByRef1{TBtInnerNode}, itm::ByRef1{TBtItem}, at::Int32)

# Wrapper of void TBtInnerNode::Append(TBtItem &)
@trydoc raw"""
    Append(this::ByRef1{TBtInnerNode}, itm::ByRef1{TBtItem})::Nothing
Append itm to this tree.

""" Append(this::ByRef1{TBtInnerNode}, itm::ByRef1{TBtItem})

# Wrapper of void TBtInnerNode::Append(TObject *, TBtNode *)
@trydoc raw"""
    Append(this::ByRef1{TBtInnerNode}, obj::ByPtr1{TObject}, n::ByPtr1{TBtNode})::Nothing
Never called from anywhere where it might fill up THIS.

""" Append(this::ByRef1{TBtInnerNode}, obj::ByPtr1{TObject}, n::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::AppendFrom(TBtInnerNode *, Int_t, Int_t)
@trydoc raw"""
    AppendFrom(this::ByRef1{TBtInnerNode}, src::ByPtr1{TBtInnerNode}, thestart::Int32, stop::Int32)::Nothing
This should never create a full node that is, it is not used anywhere where THIS could possibly be near full.

""" AppendFrom(this::ByRef1{TBtInnerNode}, src::ByPtr1{TBtInnerNode}, thestart::Int32, stop::Int32)

# Wrapper of void TBtInnerNode::BalanceWith(TBtInnerNode *, int)
@trydoc raw"""
    BalanceWith(this::ByRef1{TBtInnerNode}, n::ByPtr1{TBtInnerNode}, idx::Int32)::Nothing
PINDX is the index of the parent item whose key will change when keys are shifted from one InnerNode to the other.

""" BalanceWith(this::ByRef1{TBtInnerNode}, n::ByPtr1{TBtInnerNode}, idx::Int32)

# Wrapper of void TBtInnerNode::BalanceWithLeft(TBtInnerNode *, Int_t)
@trydoc raw"""
    BalanceWithLeft(this::ByRef1{TBtInnerNode}, l::ByPtr1{TBtInnerNode}, idx::Int32)::Nothing
THIS has more than LEFTSIB.
Move some item from THIS to LEFTSIB. PIDX is the index of the parent item that will change when keys are moved.
""" BalanceWithLeft(this::ByRef1{TBtInnerNode}, l::ByPtr1{TBtInnerNode}, idx::Int32)

# Wrapper of void TBtInnerNode::BalanceWithRight(TBtInnerNode *, Int_t)
@trydoc raw"""
    BalanceWithRight(this::ByRef1{TBtInnerNode}, r::ByPtr1{TBtInnerNode}, idx::Int32)::Nothing
THIS has more than RIGHTSIB.
Move some items from THIS to RIGHTSIB. PIDX is the index of the parent item that will change when keys are moved.
""" BalanceWithRight(this::ByRef1{TBtInnerNode}, r::ByPtr1{TBtInnerNode}, idx::Int32)

# Wrapper of Int_t TBtInnerNode::DecNofKeys(Int_t, Int_t)
@trydoc raw"""
    DecNofKeys(this::ByRef1{TBtInnerNode}, i::Int32, n::Int32)::Int32


""" DecNofKeys(this::ByRef1{TBtInnerNode}, i::Int32, n::Int32)

# Wrapper of void TBtInnerNode::DecrNofKeys(TBtNode *)
@trydoc raw"""
    DecrNofKeys(this::ByRef1{TBtInnerNode}, np::ByPtr1{TBtNode})::Nothing
THAT is a child of THIS that has just shrunk by 1.

""" DecrNofKeys(this::ByRef1{TBtInnerNode}, np::ByPtr1{TBtNode})

# Wrapper of TBtLeafNode * TBtInnerNode::FirstLeafNode()
@trydoc raw"""
    FirstLeafNode(this::ByRef1{TBtInnerNode})::CxxPtr1{TBtLeafNode}
Return the first leaf node.

""" FirstLeafNode(this::ByRef1{TBtInnerNode})

# Wrapper of TObject * TBtInnerNode::Found(const TObject *, TBtNode **, Int_t *)
@trydoc raw"""
    Found(this::ByRef1{TBtInnerNode}, obj::ByConstPtr1{TObject}, which::ByPtr1{TBtNode}, where::ByPtr2{Int32})::CxxPtr1{TObject}
Recursively look for WHAT starting in the current node.

""" Found(this::ByRef1{TBtInnerNode}, obj::ByConstPtr1{TObject}, which::ByPtr1{TBtNode}, where::ByPtr2{Int32})

# Wrapper of Int_t TBtInnerNode::IncNofKeys(Int_t, Int_t)
@trydoc raw"""
    IncNofKeys(this::ByRef1{TBtInnerNode}, i::Int32, n::Int32)::Int32


""" IncNofKeys(this::ByRef1{TBtInnerNode}, i::Int32, n::Int32)

# Wrapper of void TBtInnerNode::IncrNofKeys(TBtNode *)
@trydoc raw"""
    IncrNofKeys(this::ByRef1{TBtInnerNode}, np::ByPtr1{TBtNode})::Nothing
THAT is a child of THIS that has just grown by 1.

""" IncrNofKeys(this::ByRef1{TBtInnerNode}, np::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::InformParent()
@trydoc raw"""
    InformParent(this::ByRef1{TBtInnerNode})::Nothing
Tell the parent that we are full.

""" InformParent(this::ByRef1{TBtInnerNode})

# Wrapper of void TBtInnerNode::IsFull(TBtNode *)
@trydoc raw"""
    IsFull(this::ByRef1{TBtInnerNode}, n::ByPtr1{TBtNode})::Nothing
The child node THAT is full.
We will either redistribute elements or create a new node and then redistribute. In an attempt to minimize the number of splits, we adopt the following strategy:

- redistribute if possible
- if not possible, then split with a sibling
""" IsFull(this::ByRef1{TBtInnerNode}, n::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::IsLow(TBtNode *)
@trydoc raw"""
    IsLow(this::ByRef1{TBtInnerNode}, n::ByPtr1{TBtNode})::Nothing
The child node THAT is <= half full.
We will either redistribute elements between children, or THAT will be merged with another child. In an attempt to minimize the number of mergers, we adopt the following strategy:

- redistribute if possible
- if not possible, then merge with a sibling
""" IsLow(this::ByRef1{TBtInnerNode}, n::ByPtr1{TBtNode})

# Wrapper of TBtLeafNode * TBtInnerNode::LastLeafNode()
@trydoc raw"""
    LastLeafNode(this::ByRef1{TBtInnerNode})::CxxPtr1{TBtLeafNode}
Return the last leaf node.

""" LastLeafNode(this::ByRef1{TBtInnerNode})

# Wrapper of void TBtInnerNode::MergeWithRight(TBtInnerNode *, Int_t)
@trydoc raw"""
    MergeWithRight(this::ByRef1{TBtInnerNode}, r::ByPtr1{TBtInnerNode}, idx::Int32)::Nothing
Merge the 2 part of the tree.

""" MergeWithRight(this::ByRef1{TBtInnerNode}, r::ByPtr1{TBtInnerNode}, idx::Int32)

# Wrapper of void TBtInnerNode::PushLeft(Int_t, TBtInnerNode *, Int_t)
@trydoc raw"""
    PushLeft(this::ByRef1{TBtInnerNode}, cnt::Int32, leftsib::ByPtr1{TBtInnerNode}, parentIdx::Int32)::Nothing
noFromThis==1 => moves the parent item into the leftsib, and the first item in this's array into the parent item.

""" PushLeft(this::ByRef1{TBtInnerNode}, cnt::Int32, leftsib::ByPtr1{TBtInnerNode}, parentIdx::Int32)

# Wrapper of void TBtInnerNode::PushRight(Int_t, TBtInnerNode *, Int_t)
@trydoc raw"""
    PushRight(this::ByRef1{TBtInnerNode}, cnt::Int32, rightsib::ByPtr1{TBtInnerNode}, parentIdx::Int32)::Nothing
The operation is three steps:
- Step I. Make room for the incoming keys in RIGHTSIB.
- Step II. Move the items from THIS into RIGHTSIB.
- Step III. Update the length of THIS.
""" PushRight(this::ByRef1{TBtInnerNode}, cnt::Int32, rightsib::ByPtr1{TBtInnerNode}, parentIdx::Int32)

# Wrapper of void TBtInnerNode::Remove(Int_t)
@trydoc raw"""
    Remove(this::ByRef1{TBtInnerNode}, idx::Int32)::Nothing
Remove an element.

""" Remove(this::ByRef1{TBtInnerNode}, idx::Int32)

# Wrapper of void TBtInnerNode::RemoveItem(Int_t)
@trydoc raw"""
    RemoveItem(this::ByRef1{TBtInnerNode}, idx::Int32)::Nothing
Remove an item.

""" RemoveItem(this::ByRef1{TBtInnerNode}, idx::Int32)

# Wrapper of void TBtInnerNode::SetItem(Int_t, TBtItem &)
@trydoc raw"""
    SetItem(this::ByRef1{TBtInnerNode}, i::Int32, itm::ByRef1{TBtItem})::Nothing


""" SetItem(this::ByRef1{TBtInnerNode}, i::Int32, itm::ByRef1{TBtItem})

# Wrapper of void TBtInnerNode::SetItem(Int_t, TObject *, TBtNode *)
@trydoc raw"""
    SetItem(this::ByRef1{TBtInnerNode}, i::Int32, obj::ByPtr1{TObject}, node::ByPtr1{TBtNode})::Nothing


""" SetItem(this::ByRef1{TBtInnerNode}, i::Int32, obj::ByPtr1{TObject}, node::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::SetKey(Int_t, TObject *)
@trydoc raw"""
    SetKey(this::ByRef1{TBtInnerNode}, i::Int32, obj::ByPtr1{TObject})::Nothing


""" SetKey(this::ByRef1{TBtInnerNode}, i::Int32, obj::ByPtr1{TObject})

# Wrapper of void TBtInnerNode::SetNofKeys(Int_t, Int_t)
@trydoc raw"""
    SetNofKeys(this::ByRef1{TBtInnerNode}, i::Int32, r::Int32)::Nothing


""" SetNofKeys(this::ByRef1{TBtInnerNode}, i::Int32, r::Int32)

# Wrapper of void TBtInnerNode::SetTree(Int_t, TBtNode *)
@trydoc raw"""
    SetTree(this::ByRef1{TBtInnerNode}, i::Int32, node::ByPtr1{TBtNode})::Nothing


""" SetTree(this::ByRef1{TBtInnerNode}, i::Int32, node::ByPtr1{TBtNode})

# Wrapper of void TBtInnerNode::ShiftLeft(Int_t)
@trydoc raw"""
    ShiftLeft(this::ByRef1{TBtInnerNode}, cnt::Int32)::Nothing
Shift to the left.

""" ShiftLeft(this::ByRef1{TBtInnerNode}, cnt::Int32)

# Wrapper of void TBtInnerNode::Split()
@trydoc raw"""
    Split(this::ByRef1{TBtInnerNode})::Nothing
This function is called only when THIS is the only descendent of the root node, and THIS needs to be split.
Assumes that idx of THIS in fParent is 0.
""" Split(this::ByRef1{TBtInnerNode})

# Wrapper of void TBtInnerNode::SplitWith(TBtInnerNode *, Int_t)
@trydoc raw"""
    SplitWith(this::ByRef1{TBtInnerNode}, r::ByPtr1{TBtInnerNode}, idx::Int32)::Nothing
THIS and SIB are too full; create a NEWNODE, and balance the number of keys between the three of them.
picture: (also see Knuth Vol 3 pg 478) 

                  keyidx keyidx+1
               +--+--+--+--+--+--...
               |  |  |  |  |  |
    fParent--->|  |     |     |
               |  |     |     |
               +*-+*-+*-+--+--+--...
                |  |  |
           +----+  |  +-----+
           |       +-----+  |
           V             |  V
           +----------+  |  +----------+
           |          |  |  |          |
     this->|          |  |  |          |<--sib
           +----------+  |  +----------+
                         V
                       data

(C++ version of the code)

 keyidx is the index of where the sibling is, and where the newly created node will be recorded (sibling will be moved to keyidx+1)
""" SplitWith(this::ByRef1{TBtInnerNode}, r::ByPtr1{TBtInnerNode}, idx::Int32)

# Wrapper of void TBtLeafNode::Add(const TObject *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBtLeafNode}, obj::ByConstPtr1{TObject}, idx::Int32)::Nothing
Add the object OBJ to the leaf node, inserting it at location INDEX in the fItem array.

""" Add(this::ByRef1{TBtLeafNode}, obj::ByConstPtr1{TObject}, idx::Int32)

# Wrapper of void TBtLeafNode::Append(TObject *)
@trydoc raw"""
    Append(this::ByRef1{TBtLeafNode}, obj::ByPtr1{TObject})::Nothing
Never called from anywhere where it might fill up THIS does NOT handle nofKeys.

""" Append(this::ByRef1{TBtLeafNode}, obj::ByPtr1{TObject})

# Wrapper of void TBtLeafNode::AppendFrom(TBtLeafNode *, Int_t, Int_t)
@trydoc raw"""
    AppendFrom(this::ByRef1{TBtLeafNode}, src::ByPtr1{TBtLeafNode}, thestart::Int32, stop::Int32)::Nothing
A convenience function, does not worry about the element in the parent, simply moves elements from SRC[thestart] to SRC[stop] into the current array.
This should never create a full node. That is, it is not used anywhere where THIS could possibly be near full. Does NOT handle nofKeys.
""" AppendFrom(this::ByRef1{TBtLeafNode}, src::ByPtr1{TBtLeafNode}, thestart::Int32, stop::Int32)

# Wrapper of void TBtLeafNode::BalanceWith(TBtLeafNode *, Int_t)
@trydoc raw"""
    BalanceWith(this::ByRef1{TBtLeafNode}, n::ByPtr1{TBtLeafNode}, idx::Int32)::Nothing
PITEM is the parent item whose key will change when keys are shifted from one LeafNode to the other.

""" BalanceWith(this::ByRef1{TBtLeafNode}, n::ByPtr1{TBtLeafNode}, idx::Int32)

# Wrapper of void TBtLeafNode::BalanceWithLeft(TBtLeafNode *, Int_t)
@trydoc raw"""
    BalanceWithLeft(this::ByRef1{TBtLeafNode}, l::ByPtr1{TBtLeafNode}, idx::Int32)::Nothing
THIS has more than LEFTSIB; move some items from THIS to LEFTSIB.

""" BalanceWithLeft(this::ByRef1{TBtLeafNode}, l::ByPtr1{TBtLeafNode}, idx::Int32)

# Wrapper of void TBtLeafNode::BalanceWithRight(TBtLeafNode *, Int_t)
@trydoc raw"""
    BalanceWithRight(this::ByRef1{TBtLeafNode}, r::ByPtr1{TBtLeafNode}, idx::Int32)::Nothing
THIS has more than RIGHTSIB; move some items from THIS to RIGHTSIB.

""" BalanceWithRight(this::ByRef1{TBtLeafNode}, r::ByPtr1{TBtLeafNode}, idx::Int32)

# Wrapper of TBtLeafNode * TBtLeafNode::FirstLeafNode()
@trydoc raw"""
    FirstLeafNode(this::ByRef1{TBtLeafNode})::CxxPtr1{TBtLeafNode}
Return the first node.

""" FirstLeafNode(this::ByRef1{TBtLeafNode})

# Wrapper of TObject * TBtLeafNode::Found(const TObject *, TBtNode **, Int_t *)
@trydoc raw"""
    Found(this::ByRef1{TBtLeafNode}, obj::ByConstPtr1{TObject}, which::ByPtr1{TBtNode}, where::ByPtr2{Int32})::CxxPtr1{TObject}
WHAT was not in any inner node; it is either here, or it's not in the tree.

""" Found(this::ByRef1{TBtLeafNode}, obj::ByConstPtr1{TObject}, which::ByPtr1{TBtNode}, where::ByPtr2{Int32})

# Wrapper of TObject * TBtLeafNode::GetKey(Int_t)
@trydoc raw"""
    GetKey(this::ByRef1{TBtLeafNode}, idx::Int32)::CxxPtr1{TObject}


""" GetKey(this::ByRef1{TBtLeafNode}, idx::Int32)

# Wrapper of TBtLeafNode * TBtLeafNode::LastLeafNode()
@trydoc raw"""
    LastLeafNode(this::ByRef1{TBtLeafNode})::CxxPtr1{TBtLeafNode}
return the last node.

""" LastLeafNode(this::ByRef1{TBtLeafNode})

# Wrapper of void TBtLeafNode::MergeWithRight(TBtLeafNode *, Int_t)
@trydoc raw"""
    MergeWithRight(this::ByRef1{TBtLeafNode}, r::ByPtr1{TBtLeafNode}, idx::Int32)::Nothing
Merge.

""" MergeWithRight(this::ByRef1{TBtLeafNode}, r::ByPtr1{TBtLeafNode}, idx::Int32)

# Wrapper of void TBtLeafNode::PushLeft(Int_t, TBtLeafNode *, Int_t)
@trydoc raw"""
    PushLeft(this::ByRef1{TBtLeafNode}, cnt::Int32, l::ByPtr1{TBtLeafNode}, parentIndex::Int32)::Nothing
noFromThis==1 => moves the parent item into the leftsib, and the first item in this's array into the parent item.

""" PushLeft(this::ByRef1{TBtLeafNode}, cnt::Int32, l::ByPtr1{TBtLeafNode}, parentIndex::Int32)

# Wrapper of void TBtLeafNode::PushRight(Int_t, TBtLeafNode *, Int_t)
@trydoc raw"""
    PushRight(this::ByRef1{TBtLeafNode}, cnt::Int32, r::ByPtr1{TBtLeafNode}, parentIndex::Int32)::Nothing
noFromThis==1 => moves the parent item into the rightsib, and the last item in this's array into the parent item.

""" PushRight(this::ByRef1{TBtLeafNode}, cnt::Int32, r::ByPtr1{TBtLeafNode}, parentIndex::Int32)

# Wrapper of void TBtLeafNode::Remove(Int_t)
@trydoc raw"""
    Remove(this::ByRef1{TBtLeafNode}, idx::Int32)::Nothing
Remove an element.

""" Remove(this::ByRef1{TBtLeafNode}, idx::Int32)

# Wrapper of void TBtLeafNode::RemoveItem(Int_t)
@trydoc raw"""
    RemoveItem(this::ByRef1{TBtLeafNode}, idx::Int32)::Nothing


""" RemoveItem(this::ByRef1{TBtLeafNode}, idx::Int32)

# Wrapper of void TBtLeafNode::SetKey(Int_t, TObject *)
@trydoc raw"""
    SetKey(this::ByRef1{TBtLeafNode}, idx::Int32, obj::ByPtr1{TObject})::Nothing


""" SetKey(this::ByRef1{TBtLeafNode}, idx::Int32, obj::ByPtr1{TObject})

# Wrapper of void TBtLeafNode::ShiftLeft(Int_t)
@trydoc raw"""
    ShiftLeft(this::ByRef1{TBtLeafNode}, cnt::Int32)::Nothing
Shift.

""" ShiftLeft(this::ByRef1{TBtLeafNode}, cnt::Int32)

# Wrapper of void TBtLeafNode::Split()
@trydoc raw"""
    Split(this::ByRef1{TBtLeafNode})::Nothing
This function is called only when THIS is the only descendent of the root node, and THIS needs to be split.
Assumes that idx of THIS in Parent is 0.
""" Split(this::ByRef1{TBtLeafNode})

# Wrapper of void TBtLeafNode::SplitWith(TBtLeafNode *, Int_t)
@trydoc raw"""
    SplitWith(this::ByRef1{TBtLeafNode}, r::ByPtr1{TBtLeafNode}, idx::Int32)::Nothing
Split.

""" SplitWith(this::ByRef1{TBtLeafNode}, r::ByPtr1{TBtLeafNode}, idx::Int32)

# Wrapper of TObject * TBtreeIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TBtreeIter})::CxxPtr1{TObject}
Get next object from B-tree. Returns 0 when no more objects in tree.

""" Next(this::ByRef1{TBtreeIter})

# Wrapper of TBtreeIter & TBtreeIter::operator=(const TBtreeIter &)
@trydoc raw"""
    assign(this::ByRef1{TBtreeIter}, rhs::ByConstRef1{TBtreeIter})::CxxRef1{TBtreeIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TBtreeIter}, rhs::ByConstRef1{TBtreeIter})

# Wrapper of TIterator & TBtreeIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TBtreeIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TBtreeIter}, rhs::ByConstRef1{TIterator})

# Wrapper of void TBtreeIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TBtreeIter})::Nothing
Reset the B-tree iterator.

""" Reset(this::ByRef1{TBtreeIter})

# Wrapper of void TArrayD::AddAt(Double_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayD}, c::Float64, i::Int32)::Nothing
Set the double c value at position i in the array.
Check for out of bounds. Warning: the name of the method is misleading, it actually overwrites the position i.
""" AddAt(this::ByRef1{TArrayD}, c::Float64, i::Int32)

# Wrapper of void TArrayD::Adopt(Int_t, Double_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayD}, n::Int32, array::ByPtr2{Float64})::Nothing
Adopt array arr into [TArrayD](@ref), i.e.
don't copy arr but use it directly in [TArrayD](@ref). User may not delete arr, [TArrayD](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayD}, n::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t * TArrayD::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayD})::CxxPtr2{Float64}


""" GetArray(this::ByRef1{TArrayD})

# Wrapper of TArrayD & TArrayD::operator=(const TArrayD &)
@trydoc raw"""
    assign(this::ByRef1{TArrayD}, rhs::ByConstRef1{TArrayD})::CxxRef1{TArrayD}
[TArrayD](@ref) assignment operator.

""" assign(this::ByRef1{TArrayD}, rhs::ByConstRef1{TArrayD})

# Wrapper of Double_t & TArrayD::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayD}, i::Int32)::CxxRef2{Float64}


""" Base.getindex(this::ByRef1{TArrayD}, i::Int32)

# Wrapper of void TArrayD::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TArrayD})::Nothing


""" Reset(this::ByRef1{TArrayD})

# Wrapper of void TArrayD::Reset(Double_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayD}, val::Float64)::Nothing


""" Reset(this::ByRef1{TArrayD}, val::Float64)

# Wrapper of void TArrayD::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayD}, n::Int32)::Nothing
Set size of this array to n doubles.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayD}, n::Int32)

# Wrapper of void TArrayD::Set(Int_t, const Double_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayD}, n::Int32, array::ByConstPtr2{Float64})::Nothing
Set size of this array to n doubles and set the contents This function should not be called if the array was declared via Adopt.

""" Set(this::ByRef1{TArrayD}, n::Int32, array::ByConstPtr2{Float64})

# Wrapper of void TArrayD::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayD}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayD}, v::Float64, i::Int32)

# Wrapper of void TArrayF::AddAt(Float_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayF}, c::Float32, i::Int32)::Nothing
Add float c at position i. Check for out of bounds.

""" AddAt(this::ByRef1{TArrayF}, c::Float32, i::Int32)

# Wrapper of void TArrayF::Adopt(Int_t, Float_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayF}, n::Int32, array::ByPtr2{Float32})::Nothing
Adopt array arr into [TArrayF](@ref), i.e.
don't copy arr but use it directly in [TArrayF](@ref). User may not delete arr, [TArrayF](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayF}, n::Int32, array::ByPtr2{Float32})

# Wrapper of Float_t * TArrayF::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayF})::CxxPtr2{Float32}


""" GetArray(this::ByRef1{TArrayF})

# Wrapper of TArrayF & TArrayF::operator=(const TArrayF &)
@trydoc raw"""
    assign(this::ByRef1{TArrayF}, rhs::ByConstRef1{TArrayF})::CxxRef1{TArrayF}
[TArrayF](@ref) assignment operator.

""" assign(this::ByRef1{TArrayF}, rhs::ByConstRef1{TArrayF})

# Wrapper of Float_t & TArrayF::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayF}, i::Int32)::CxxRef2{Float32}


""" Base.getindex(this::ByRef1{TArrayF}, i::Int32)

# Wrapper of void TArrayF::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TArrayF})::Nothing


""" Reset(this::ByRef1{TArrayF})

# Wrapper of void TArrayF::Reset(Float_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayF}, val::Float32)::Nothing


""" Reset(this::ByRef1{TArrayF}, val::Float32)

# Wrapper of void TArrayF::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayF}, n::Int32)::Nothing
Set size of this array to n floats.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayF}, n::Int32)

# Wrapper of void TArrayF::Set(Int_t, const Float_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayF}, n::Int32, array::ByConstPtr2{Float32})::Nothing
Set size of this array to n floats and set the contents.
This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayF}, n::Int32, array::ByConstPtr2{Float32})

# Wrapper of void TArrayF::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayF}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayF}, v::Float64, i::Int32)

# Wrapper of void TRefArray::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})

# Wrapper of void TRefArray::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TRefArray}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object in the slot after object after.
If after=0 add object in the last empty slot. Note that this will overwrite any object that might have already been in this slot. For insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddAfter(this::ByRef1{TRefArray}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TRefArray::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TRefArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position ids.
Give an error when idx is out of bounds (i.e. the array is not expanded).
""" AddAt(this::ByRef1{TRefArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TRefArray::AddAtAndExpand(TObject *, Int_t)
@trydoc raw"""
    AddAtAndExpand(this::ByRef1{TRefArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position idx.
If idx is larger than the current size of the array, expand the array (double its size).
""" AddAtAndExpand(this::ByRef1{TRefArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of Int_t TRefArray::AddAtFree(TObject *)
@trydoc raw"""
    AddAtFree(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})::Int32
Return the position of the new object.
Find the first empty cell or AddLast if there is no empty cell
""" AddAtFree(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})

# Wrapper of void TRefArray::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TRefArray}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object in the slot before object before.
If before=0 add object in the first slot. Note that this will overwrite any object that might have already been in this slot. For insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddBefore(this::ByRef1{TRefArray}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TRefArray::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})::Nothing
Add object in the first slot of the array.
This will overwrite the first element that might have been there. To have insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddFirst(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})

# Wrapper of void TRefArray::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})::Nothing
Add object in the next empty slot in the array.
Expand the array if necessary.
""" AddLast(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})

# Wrapper of Int_t TRefArray::BinarySearch(TObject *, Int_t)
@trydoc raw"""
    BinarySearch(this::ByRef1{TRefArray}, obj::ByPtr1{TObject}, upto::Int32)::Int32
Find object using a binary search.
Array must first have been sorted. Search can be limited by setting upto to desired index.
""" BinarySearch(this::ByRef1{TRefArray}, obj::ByPtr1{TObject}, upto::Int32)

# Wrapper of void TRefArray::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TRefArray}, option::ByCopy{String})::Nothing
Remove all objects from the array.

""" Clear(this::ByRef1{TRefArray}, option::ByCopy{String})

# Wrapper of void TRefArray::Compress()
@trydoc raw"""
    Compress(this::ByRef1{TRefArray})::Nothing
Remove empty slots from array.

""" Compress(this::ByRef1{TRefArray})

# Wrapper of void TRefArray::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TRefArray}, option::ByCopy{String})::Nothing
Remove all objects from the array and free the internal memory.

""" Delete(this::ByRef1{TRefArray}, option::ByCopy{String})

# Wrapper of void TRefArray::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TRefArray}, newSize::Int32)::Nothing
Expand or shrink the array to newSize elements.

""" Expand(this::ByRef1{TRefArray}, newSize::Int32)

# Wrapper of TRefArray & TRefArray::operator=(const TRefArray &)
@trydoc raw"""
    assign(this::ByRef1{TRefArray}, a::ByConstRef1{TRefArray})::CxxRef1{TRefArray}
Assignment operator.

""" assign(this::ByRef1{TRefArray}, a::ByConstRef1{TRefArray})

# Wrapper of TObject * TRefArray::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from array.

""" Remove(this::ByRef1{TRefArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TRefArray::RemoveAt(Int_t)
@trydoc raw"""
    RemoveAt(this::ByRef1{TRefArray}, idx::Int32)::CxxPtr1{TObject}
Remove object at index idx.

""" RemoveAt(this::ByRef1{TRefArray}, idx::Int32)

# Wrapper of void TRefArray::SetLast(Int_t)
@trydoc raw"""
    SetLast(this::ByRef1{TRefArray}, last::Int32)::Nothing
Set index of last object in array, effectively truncating the array.
Use carefully since whenever last position has to be recalculated, e.g. after a [Remove()](@ref) or [Sort()](@ref) it will be reset to the last non-empty slot. If last is -2 this will force the recalculation of the last used slot.
""" SetLast(this::ByRef1{TRefArray}, last::Int32)

# Wrapper of void TRefArray::Sort(Int_t)
@trydoc raw"""
    Sort(this::ByRef1{TRefArray}, upto::Int32)::Nothing
If objects in array are sortable (i.e.
[IsSortable()](@ref) returns true for all objects) then sort array.
""" Sort(this::ByRef1{TRefArray}, upto::Int32)

# Wrapper of TObject * TRefArrayIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TRefArrayIter})::CxxPtr1{TObject}
Return next object in array. Returns 0 when no more objects in array.

""" Next(this::ByRef1{TRefArrayIter})

# Wrapper of TIterator & TRefArrayIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TRefArrayIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TRefArrayIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TRefArrayIter & TRefArrayIter::operator=(const TRefArrayIter &)
@trydoc raw"""
    assign(this::ByRef1{TRefArrayIter}, rhs::ByConstRef1{TRefArrayIter})::CxxRef1{TRefArrayIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TRefArrayIter}, rhs::ByConstRef1{TRefArrayIter})

# Wrapper of void TRefArrayIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TRefArrayIter})::Nothing
Reset array iterator.

""" Reset(this::ByRef1{TRefArrayIter})

# Wrapper of void TArrayC::AddAt(Char_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayC}, c::Int8, i::Int32)::Nothing
Add char c at position i. Check for out of bounds.

""" AddAt(this::ByRef1{TArrayC}, c::Int8, i::Int32)

# Wrapper of void TArrayC::Adopt(Int_t, Char_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayC}, n::Int32, array::ByPtr2{Int8})::Nothing
Adopt array arr into [TArrayC](@ref), i.e.
don't copy arr but use it directly in [TArrayC](@ref). User may not delete arr, [TArrayC](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayC}, n::Int32, array::ByPtr2{Int8})

# Wrapper of Char_t * TArrayC::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayC})::CxxPtr2{Int8}


""" GetArray(this::ByRef1{TArrayC})

# Wrapper of TArrayC & TArrayC::operator=(const TArrayC &)
@trydoc raw"""
    assign(this::ByRef1{TArrayC}, rhs::ByConstRef1{TArrayC})::CxxRef1{TArrayC}
[TArrayC](@ref) assignment operator.

""" assign(this::ByRef1{TArrayC}, rhs::ByConstRef1{TArrayC})

# Wrapper of Char_t & TArrayC::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayC}, i::Int32)::CxxRef2{Int8}


""" Base.getindex(this::ByRef1{TArrayC}, i::Int32)

# Wrapper of void TArrayC::Reset(Char_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayC}, val::Int8)::Nothing


""" Reset(this::ByRef1{TArrayC}, val::Int8)

# Wrapper of void TArrayC::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayC}, n::Int32)::Nothing
Set size of this array to n chars.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayC}, n::Int32)

# Wrapper of void TArrayC::Set(Int_t, const Char_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayC}, n::Int32, array::ByCopy{String})::Nothing
Set size of this array to n chars and set the contents.
This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayC}, n::Int32, array::ByCopy{String})

# Wrapper of void TArrayC::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayC}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayC}, v::Float64, i::Int32)

# Wrapper of void TExMap::Add(Long64_t, Long64_t)
@trydoc raw"""
    Add(this::ByRef1{TExMap}, key::Int64, value::Int64)::Nothing


""" Add(this::ByRef1{TExMap}, key::Int64, value::Int64)

# Wrapper of void TExMap::Add(ULong64_t, Long64_t, Long64_t)
@trydoc raw"""
    Add(this::ByRef1{TExMap}, hash::UInt64, key::Int64, value::Int64)::Nothing
Add an (key,value) pair to the table. The key should be unique.

""" Add(this::ByRef1{TExMap}, hash::UInt64, key::Int64, value::Int64)

# Wrapper of void TExMap::AddAt(UInt_t, ULong64_t, Long64_t, Long64_t)
@trydoc raw"""
    AddAt(this::ByRef1{TExMap}, slot::UInt32, hash::UInt64, key::Int64, value::Int64)::Nothing
Add an (key,value) pair to the table.
The key should be unique. If the 'slot' is open, use it to store the value, otherwise revert to Add(hash,key,value) This is usually used in conjunction with GetValue with 3 parameters: 

    if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {
       ...
    } else {
       fMap->AddAt(slot,hash,key,value);
    }

(C++ version of the code)
""" AddAt(this::ByRef1{TExMap}, slot::UInt32, hash::UInt64, key::Int64, value::Int64)

# Wrapper of void TExMap::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TExMap}, opt::ByCopy{String})::Nothing
Delete all entries stored in the [TExMap](@ref).

""" Delete(this::ByRef1{TExMap}, opt::ByCopy{String})

# Wrapper of void TExMap::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TExMap}, newsize::Int32)::Nothing
Expand the [TExMap](@ref).

""" Expand(this::ByRef1{TExMap}, newsize::Int32)

# Wrapper of Long64_t TExMap::GetValue(Long64_t)
@trydoc raw"""
    GetValue(this::ByRef1{TExMap}, key::Int64)::Int64


""" GetValue(this::ByRef1{TExMap}, key::Int64)

# Wrapper of Long64_t TExMap::GetValue(ULong64_t, Long64_t)
@trydoc raw"""
    GetValue(this::ByRef1{TExMap}, hash::UInt64, key::Int64)::Int64
Return the value belonging to specified key and hash value.
If key not found return 0.
""" GetValue(this::ByRef1{TExMap}, hash::UInt64, key::Int64)

# Wrapper of Long64_t TExMap::GetValue(ULong64_t, Long64_t, UInt_t &)
@trydoc raw"""
    GetValue(this::ByRef1{TExMap}, hash::UInt64, key::Int64, slot::ByRef2{UInt32})::Int64
Return the value belonging to specified key and hash value.
If key not found return 0. In 'slot', return the index of the slot used or the first empty slot. (to be used with AddAt).
""" GetValue(this::ByRef1{TExMap}, hash::UInt64, key::Int64, slot::ByRef2{UInt32})

# Wrapper of Long64_t & TExMap::operator()(Long64_t)
@trydoc raw"""
    paren(this::ByRef1{TExMap}, key::Int64)::CxxRef2{Int64}


""" paren(this::ByRef1{TExMap}, key::Int64)

# Wrapper of Long64_t & TExMap::operator()(ULong64_t, Long64_t)
@trydoc raw"""
    paren(this::ByRef1{TExMap}, hash::UInt64, key::Int64)::CxxRef2{Int64}
Return a reference to the value belonging to the key with the specified hash value.
If the key does not exist it will be added. NOTE: the reference will be invalidated an [Expand()](@ref) triggered by an [Add()](@ref) or another operator() call.
""" paren(this::ByRef1{TExMap}, hash::UInt64, key::Int64)

# Wrapper of TExMap & TExMap::operator=(const TExMap &)
@trydoc raw"""
    assign(this::ByRef1{TExMap}, ::ByConstRef1{TExMap})::CxxRef1{TExMap}
Assignment operator.

""" assign(this::ByRef1{TExMap}, ::ByConstRef1{TExMap})

# Wrapper of void TExMap::Remove(Long64_t)
@trydoc raw"""
    Remove(this::ByRef1{TExMap}, key::Int64)::Nothing


""" Remove(this::ByRef1{TExMap}, key::Int64)

# Wrapper of void TExMap::Remove(ULong64_t, Long64_t)
@trydoc raw"""
    Remove(this::ByRef1{TExMap}, hash::UInt64, key::Int64)::Nothing
Remove entry with specified key from the [TExMap](@ref).

""" Remove(this::ByRef1{TExMap}, hash::UInt64, key::Int64)

# Wrapper of Bool_t TExMapIter::Next(Long64_t &, Long64_t &)
@trydoc raw"""
    Next(this::ByRef1{TExMapIter}, key::ByRef2{Int64}, value::ByRef2{Int64})::Bool
Get next entry from [TExMap](@ref). Returns kFALSE at theend of map.

""" Next(this::ByRef1{TExMapIter}, key::ByRef2{Int64}, value::ByRef2{Int64})

# Wrapper of Bool_t TExMapIter::Next(ULong64_t &, Long64_t &, Long64_t &)
@trydoc raw"""
    Next(this::ByRef1{TExMapIter}, hash::ByRef2{UInt64}, key::ByRef2{Int64}, value::ByRef2{Int64})::Bool
Get next entry from [TExMap](@ref). Returns kFALSE at theend of map.

""" Next(this::ByRef1{TExMapIter}, hash::ByRef2{UInt64}, key::ByRef2{Int64}, value::ByRef2{Int64})

# Wrapper of TExMapIter & TExMapIter::operator=(const TExMapIter &)
@trydoc raw"""
    assign(this::ByRef1{TExMapIter}, ::ByConstRef1{TExMapIter})::CxxRef1{TExMapIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TExMapIter}, ::ByConstRef1{TExMapIter})

# Wrapper of void TExMapIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TExMapIter})::Nothing


""" Reset(this::ByRef1{TExMapIter})

# Wrapper of void TArrayS::AddAt(Short_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayS}, c::Int16, i::Int32)::Nothing
Add short c at position i. Check for out of bounds.

""" AddAt(this::ByRef1{TArrayS}, c::Int16, i::Int32)

# Wrapper of void TArrayS::Adopt(Int_t, Short_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayS}, n::Int32, array::ByPtr2{Int16})::Nothing
Adopt array arr into [TArrayS](@ref), i.e.
don't copy arr but use it directly in [TArrayS](@ref). User may not delete arr, [TArrayS](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayS}, n::Int32, array::ByPtr2{Int16})

# Wrapper of Short_t * TArrayS::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayS})::CxxPtr2{Int16}


""" GetArray(this::ByRef1{TArrayS})

# Wrapper of TArrayS & TArrayS::operator=(const TArrayS &)
@trydoc raw"""
    assign(this::ByRef1{TArrayS}, rhs::ByConstRef1{TArrayS})::CxxRef1{TArrayS}
[TArrayS](@ref) assignment operator.

""" assign(this::ByRef1{TArrayS}, rhs::ByConstRef1{TArrayS})

# Wrapper of Short_t & TArrayS::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayS}, i::Int32)::CxxRef2{Int16}


""" Base.getindex(this::ByRef1{TArrayS}, i::Int32)

# Wrapper of void TArrayS::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TArrayS})::Nothing


""" Reset(this::ByRef1{TArrayS})

# Wrapper of void TArrayS::Reset(Short_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayS}, val::Int16)::Nothing


""" Reset(this::ByRef1{TArrayS}, val::Int16)

# Wrapper of void TArrayS::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayS}, n::Int32)::Nothing
Set size of this array to n shorts.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayS}, n::Int32)

# Wrapper of void TArrayS::Set(Int_t, const Short_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayS}, n::Int32, array::ByConstPtr2{Int16})::Nothing
Set size of this array to n shorts and set the contents.
This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayS}, n::Int32, array::ByConstPtr2{Int16})

# Wrapper of void TArrayS::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayS}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayS}, v::Float64, i::Int32)

# Wrapper of void * TVirtualCollectionProxy::Allocate(UInt_t, Bool_t)
@trydoc raw"""
    Allocate(this::ByRef1{TVirtualCollectionProxy}, n::UInt32, forceDelete::Bool)::CxxPtr2{Nothing}
Allocates space for storing at least `n` elements.
This function returns a pointer to the actual object on which insertions should take place. For associative collections, this function returns a pointer to a temporary buffer known as the staging area. If the insertion happened in a staging area (i.e. the returned pointer != proxied object), `Commit()` should be called on the value returned by this function.
""" Allocate(this::ByRef1{TVirtualCollectionProxy}, n::UInt32, forceDelete::Bool)

# Wrapper of void * TVirtualCollectionProxy::At(UInt_t)
@trydoc raw"""
    At(this::ByRef1{TVirtualCollectionProxy}, idx::UInt32)::CxxPtr2{Nothing}
Return the address of the value at index `idx`

""" At(this::ByRef1{TVirtualCollectionProxy}, idx::UInt32)

# Wrapper of void TVirtualCollectionProxy::Clear(const char *)
@trydoc raw"""
    Clear(this::ByRef1{TVirtualCollectionProxy}, opt::ByCopy{String})::Nothing
Clear the container.

""" Clear(this::ByRef1{TVirtualCollectionProxy}, opt::ByCopy{String})

# Wrapper of void TVirtualCollectionProxy::Commit(void *)
@trydoc raw"""
    Commit(this::ByRef1{TVirtualCollectionProxy}, ::ByPtr2{Nothing})::Nothing
Commits pending elements in a staging area (see [Allocate()](@ref) for more information).

""" Commit(this::ByRef1{TVirtualCollectionProxy}, ::ByPtr2{Nothing})

# Wrapper of void TVirtualCollectionProxy::Insert(const void *, void *, size_t)
@trydoc raw"""
    Insert(this::ByRef1{TVirtualCollectionProxy}, data::ByConstPtr2{Nothing}, container::ByPtr2{Nothing}, size::Int64)::Nothing
Insert elements into the proxied container.
`data` is a C-style array of the value type of the given `size`. For associative containers, e.g. `std!map`, the data type should be `std!pair<Key_t, Value_t>`.
""" Insert(this::ByRef1{TVirtualCollectionProxy}, data::ByConstPtr2{Nothing}, container::ByPtr2{Nothing}, size::Int64)

# Wrapper of void TVirtualCollectionProxy::PopProxy()
@trydoc raw"""
    PopProxy(this::ByRef1{TVirtualCollectionProxy})::Nothing
Reset the address of the container being proxied to the previous container.

""" PopProxy(this::ByRef1{TVirtualCollectionProxy})

# Wrapper of void TVirtualCollectionProxy::PushProxy(void *)
@trydoc raw"""
    PushProxy(this::ByRef1{TVirtualCollectionProxy}, objectstart::ByPtr2{Nothing})::Nothing
Set the address of the container being proxied and keep track of the previous one.

""" PushProxy(this::ByRef1{TVirtualCollectionProxy}, objectstart::ByPtr2{Nothing})

# Wrapper of Bool_t TVirtualCollectionProxy::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TVirtualCollectionProxy})::Bool
Reset the information gathered from StreamerInfos and value's [TClass](@ref).

""" Reset(this::ByRef1{TVirtualCollectionProxy})

# Wrapper of void TOrdCollection::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TOrdCollection}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object after object after in the collection.

""" AddAfter(this::ByRef1{TOrdCollection}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TOrdCollection::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Insert object at position idx in the collection.

""" AddAt(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TOrdCollection::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TOrdCollection}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object before object before in the collection.

""" AddBefore(this::ByRef1{TOrdCollection}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TOrdCollection::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})::Nothing
Insert object at beginning of collection.

""" AddFirst(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})

# Wrapper of void TOrdCollection::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})::Nothing
Add object at the theend of the collection.

""" AddLast(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})

# Wrapper of Int_t TOrdCollection::BinarySearch(TObject *)
@trydoc raw"""
    BinarySearch(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})::Int32
Find object using a binary search.
Collection must first have been sorted.
""" BinarySearch(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})

# Wrapper of void TOrdCollection::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TOrdCollection}, option::ByCopy{String})::Nothing
Remove all objects from the collection.
Does not delete the objects unless the [TOrdCollection](@ref) is the owner (set via [SetOwner()](@ref)).
""" Clear(this::ByRef1{TOrdCollection}, option::ByCopy{String})

# Wrapper of void TOrdCollection::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TOrdCollection}, option::ByCopy{String})::Nothing
Remove all objects from the collection AND delete all heap based objects.

""" Delete(this::ByRef1{TOrdCollection}, option::ByCopy{String})

# Wrapper of void TOrdCollection::PutAt(TObject *, Int_t)
@trydoc raw"""
    PutAt(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Put object at index idx. Overwrites what was at idx before.

""" PutAt(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of TObject * TOrdCollection::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from collection.

""" Remove(this::ByRef1{TOrdCollection}, obj::ByPtr1{TObject})

# Wrapper of TObject * TOrdCollection::RemoveAt(Int_t)
@trydoc raw"""
    RemoveAt(this::ByRef1{TOrdCollection}, idx::Int32)::CxxPtr1{TObject}
Remove object at index idx.

""" RemoveAt(this::ByRef1{TOrdCollection}, idx::Int32)

# Wrapper of void TOrdCollection::Sort()
@trydoc raw"""
    Sort(this::ByRef1{TOrdCollection})::Nothing
If objects in collection are sortable (i.e.
[IsSortable()](@ref) returns true for all objects) then sort collection.
""" Sort(this::ByRef1{TOrdCollection})

# Wrapper of TObject * TOrdCollectionIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TOrdCollectionIter})::CxxPtr1{TObject}
Return next object in collection.
Returns 0 when no more objects in collection.
""" Next(this::ByRef1{TOrdCollectionIter})

# Wrapper of TIterator & TOrdCollectionIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TOrdCollectionIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TOrdCollectionIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TOrdCollectionIter & TOrdCollectionIter::operator=(const TOrdCollectionIter &)
@trydoc raw"""
    assign(this::ByRef1{TOrdCollectionIter}, rhs::ByConstRef1{TOrdCollectionIter})::CxxRef1{TOrdCollectionIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TOrdCollectionIter}, rhs::ByConstRef1{TOrdCollectionIter})

# Wrapper of void TOrdCollectionIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TOrdCollectionIter})::Nothing
Reset collection iterator.

""" Reset(this::ByRef1{TOrdCollectionIter})

# Wrapper of void TArrayL64::AddAt(Long64_t, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TArrayL64}, c::Int64, i::Int32)::Nothing
Add long64 c at position i. Check for out of bounds.

""" AddAt(this::ByRef1{TArrayL64}, c::Int64, i::Int32)

# Wrapper of void TArrayL64::Adopt(Int_t, Long64_t *)
@trydoc raw"""
    Adopt(this::ByRef1{TArrayL64}, n::Int32, array::ByPtr2{Int64})::Nothing
Adopt array arr into [TArrayL64](@ref), i.e.
don't copy arr but use it directly in [TArrayL64](@ref). User may not delete arr, [TArrayL64](@ref) dtor will do it.
""" Adopt(this::ByRef1{TArrayL64}, n::Int32, array::ByPtr2{Int64})

# Wrapper of Long64_t * TArrayL64::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{TArrayL64})::CxxPtr2{Int64}


""" GetArray(this::ByRef1{TArrayL64})

# Wrapper of TArrayL64 & TArrayL64::operator=(const TArrayL64 &)
@trydoc raw"""
    assign(this::ByRef1{TArrayL64}, rhs::ByConstRef1{TArrayL64})::CxxRef1{TArrayL64}
[TArrayL64](@ref) assignment operator.

""" assign(this::ByRef1{TArrayL64}, rhs::ByConstRef1{TArrayL64})

# Wrapper of Long64_t & TArrayL64::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TArrayL64}, i::Int32)::CxxRef2{Int64}


""" Base.getindex(this::ByRef1{TArrayL64}, i::Int32)

# Wrapper of void TArrayL64::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TArrayL64})::Nothing


""" Reset(this::ByRef1{TArrayL64})

# Wrapper of void TArrayL64::Reset(Long64_t)
@trydoc raw"""
    Reset(this::ByRef1{TArrayL64}, val::Int64)::Nothing


""" Reset(this::ByRef1{TArrayL64}, val::Int64)

# Wrapper of void TArrayL64::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TArrayL64}, n::Int32)::Nothing
Set size of this array to n long64s.
A new array is created, the old contents copied to the new array, then the old array is deleted. This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayL64}, n::Int32)

# Wrapper of void TArrayL64::Set(Int_t, const Long64_t *)
@trydoc raw"""
    Set(this::ByRef1{TArrayL64}, n::Int32, array::ByConstPtr2{Int64})::Nothing
Set size of this array to n long64s and set the contents.
This function should not be called if the array was declared via Adopt.
""" Set(this::ByRef1{TArrayL64}, n::Int32, array::ByConstPtr2{Int64})

# Wrapper of void TArrayL64::SetAt(Double_t, Int_t)
@trydoc raw"""
    SetAt(this::ByRef1{TArrayL64}, v::Float64, i::Int32)::Nothing


""" SetAt(this::ByRef1{TArrayL64}, v::Float64, i::Int32)

# Wrapper of void TSortedList::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TSortedList}, obj::ByPtr1{TObject})::Nothing
Add object in sorted list.
Uses object [Compare()](@ref) member to find right position.
""" Add(this::ByRef1{TSortedList}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::Add(TObject *, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object in sorted list.
Uses object [Compare()](@ref) member to find right position and also store option. See [TList!Add](@ref) for explanation of usage of option.
""" Add(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TSortedList::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TSortedList}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object after object after in the list.

""" AddAfter(this::ByRef1{TSortedList}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::AddAfter(TObjLink *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TSortedList}, after::ByPtr1{TObjLink}, obj::ByPtr1{TObject})::Nothing
Insert object after the specified ObjLink object.
If after = 0 then add to the tail of the list. An ObjLink can be obtained by looping over a list using the above describe iterator method 3.
""" AddAfter(this::ByRef1{TSortedList}, after::ByPtr1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Insert object at position idx in the list.

""" AddAt(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TSortedList::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TSortedList}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Insert object before object before in the list.

""" AddBefore(this::ByRef1{TSortedList}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::AddBefore(TObjLink *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TSortedList}, before::ByPtr1{TObjLink}, obj::ByPtr1{TObject})::Nothing
Insert object before the specified ObjLink object.
If before = 0 then add to the head of the list. An ObjLink can be obtained by looping over a list using the above describe iterator method 3.
""" AddBefore(this::ByRef1{TSortedList}, before::ByPtr1{TObjLink}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TSortedList}, obj::ByPtr1{TObject})::Nothing
Add object at the beginning of the list.

""" AddFirst(this::ByRef1{TSortedList}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::AddFirst(TObject *, Option_t *)
@trydoc raw"""
    AddFirst(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object at the beginning of the list and also store option.
Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the [Draw()](@ref) method. It allows the same object to be drawn in different ways.
""" AddFirst(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TSortedList::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TSortedList}, obj::ByPtr1{TObject})::Nothing
Add object at the theend of the list.

""" AddLast(this::ByRef1{TSortedList}, obj::ByPtr1{TObject})

# Wrapper of void TSortedList::AddLast(TObject *, Option_t *)
@trydoc raw"""
    AddLast(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, opt::ByCopy{String})::Nothing
Add object at the theend of the list and also store option.
Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the [Draw()](@ref) method. It allows the same object to be drawn in different ways.
""" AddLast(this::ByRef1{TSortedList}, obj::ByPtr1{TObject}, opt::ByCopy{String})

# Wrapper of void TSortedList::Sort(Bool_t)
@trydoc raw"""
    Sort(this::ByRef1{TSortedList}, order::Bool)::Nothing
Sort linked list.
Real sorting is done in private function [DoSort()](@ref). The list can only be sorted when is contains objects of a sortable class.
""" Sort(this::ByRef1{TSortedList}, order::Bool)

# Wrapper of void TObjectTable::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})::Nothing
Add an object to the object table.

""" Add(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})

# Wrapper of void * TObjectTable::CheckPtrAndWarn(const char *, void *)
@trydoc raw"""
    CheckPtrAndWarn(this::ByRef1{TObjectTable}, msg::ByCopy{String}, vp::ByPtr2{Nothing})::CxxPtr2{Nothing}
Issue a warning in case an object still appears in the table while it should not.

""" CheckPtrAndWarn(this::ByRef1{TObjectTable}, msg::ByCopy{String}, vp::ByPtr2{Nothing})

# Wrapper of void TObjectTable::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TObjectTable}, opt::ByCopy{String})::Nothing
Delete all objects stored in the [TObjectTable](@ref).

""" Delete(this::ByRef1{TObjectTable}, opt::ByCopy{String})

# Wrapper of Bool_t TObjectTable::PtrIsValid(TObject *)
@trydoc raw"""
    PtrIsValid(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})::Bool


""" PtrIsValid(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})

# Wrapper of void TObjectTable::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})::Nothing
Remove an object from the object table.

""" Remove(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})

# Wrapper of void TObjectTable::RemoveQuietly(TObject *)
@trydoc raw"""
    RemoveQuietly(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})::Nothing
Remove an object from the object table.
If op is 0 or not in the table don't complain. Currently only used by the [TClonesArray](@ref) dtor. Should not be used anywhere else, except in places where "special" allocation and de-allocation tricks are performed.
""" RemoveQuietly(this::ByRef1{TObjectTable}, obj::ByPtr1{TObject})

# Wrapper of void TObjectTable::Statistics()
@trydoc raw"""
    Statistics(this::ByRef1{TObjectTable})::Nothing


""" Statistics(this::ByRef1{TObjectTable})

# Wrapper of void TObjectTable::Terminate()
@trydoc raw"""
    Terminate(this::ByRef1{TObjectTable})::Nothing
Deletes the object table (this static class function calls the dtor).

""" Terminate(this::ByRef1{TObjectTable})

# Wrapper of void TTree::AddAllocationCount(UInt_t)
@trydoc raw"""
    AddAllocationCount(this::ByRef1{TTree}, count::UInt32)::Nothing


""" AddAllocationCount(this::ByRef1{TTree}, count::UInt32)

# Wrapper of Int_t TTree::AddBranchToCache(const char *, bool)
@trydoc raw"""
    AddBranchToCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)::Int32
Add branch with name bname to the Tree cache.
If bname="*" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.

Returns:

- 0 branch added or already included
- -1 on error
""" AddBranchToCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)

# Wrapper of Int_t TTree::AddBranchToCache(TBranch *, bool)
@trydoc raw"""
    AddBranchToCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)::Int32
Add branch b to the Tree cache.
if subbranches is true all the branches of the subbranches are also put to the cache.

Returns:

- 0 branch added or already included
- -1 on error
""" AddBranchToCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)

# Wrapper of void TTree::AddClone(TTree *)
@trydoc raw"""
    AddClone(this::ByRef1{TTree}, ::ByPtr1{TTree})::Nothing
Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted.

""" AddClone(this::ByRef1{TTree}, ::ByPtr1{TTree})

# Wrapper of void TTree::AddTotBytes(Int_t)
@trydoc raw"""
    AddTotBytes(this::ByRef1{TTree}, tot::Int32)::Nothing


""" AddTotBytes(this::ByRef1{TTree}, tot::Int32)

# Wrapper of void TTree::AddZipBytes(Int_t)
@trydoc raw"""
    AddZipBytes(this::ByRef1{TTree}, zip::Int32)::Nothing


""" AddZipBytes(this::ByRef1{TTree}, zip::Int32)

# Wrapper of Long64_t TTree::AutoSave(Option_t *)
@trydoc raw"""
    AutoSave(this::ByRef1{TTree}, option::ByCopy{String})::Int64
AutoSave tree header every fAutoSave bytes.
When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by [TTree!Fill](@ref) when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by [TTree!Fill](@ref) every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.

Note that calling [TTree!AutoSave](@ref) too frequently (or similarly calling [TTree!SetAutoSave](@ref) with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.

In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.

if option contains "SaveSelf", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.

if option contains "FlushBaskets", [TTree!FlushBaskets](@ref) is called and all the current basket are closed-out and written to disk individually.

By default the previous header is deleted after having written the new header. if option contains "Overwrite", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.

The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file.

## How to write a Tree in one process and view it from another process

The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2

script treew.C: 

    void treew() {
       TFile f("test.root","recreate");
       TNtuple *ntuple = new TNtuple("ntuple","Demo","px:py:pz:random:i");
       Float_t px, py, pz;
       for ( Int_t i=0; i<10000000; i++) {
          gRandom->Rannor(px,py);
          pz = px*px + py*py;
          Float_t random = gRandom->Rndm(1);
          ntuple->Fill(px,py,pz,random,i);
          if (i%1000 == 1) ntuple->AutoSave("SaveSelf");
       }
    }

(C++ version of the code)

 script treer.C: 

    void treer() {
       TFile f("test.root");
       TTree *ntuple = (TTree*)f.Get("ntuple");
       TCanvas c1;
       Int_t first = 0;
       while(1) {
          if (first == 0) ntuple->Draw("px>>hpx", "","",10000000,first);
          else            ntuple->Draw("px>>+hpx","","",10000000,first);
          first = (Int_t)ntuple->GetEntries();
          c1.Update();
          gSystem->Sleep(1000); //sleep 1 second
          ntuple->Refresh();
       }
    }

(C++ version of the code)
""" AutoSave(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of Int_t TTree::Branch(const char *, Int_t, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, folder::ByCopy{String}, bufsize::Int32, splitlevel::Int32)::Int32
Create one branch for each element in the folder.
Returns the total number of branches created.
""" Branch(this::ByRef1{TTree}, folder::ByCopy{String}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::Branch(const char *, char *, const char *, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Int8}, leaflist::ByCopy{String}, bufsize::Int32)::CxxPtr1{TBranch}


""" Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Int8}, leaflist::ByCopy{String}, bufsize::Int32)

# Wrapper of TBranch * TTree::Branch(const char *, const char *, void *, Int_t, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)::CxxPtr1{TBranch}
Create a new branch with the object of class classname at address addobj.
WARNING:

Starting with Root version 3.01, the Branch function uses the new style branches ([TBranchElement](@ref)). To get the old behaviour, you can:

- call BranchOld or
- call TTree!SetBranchStyle(0)

Note that with the new style, classname does not need to derive from [TObject](@ref). It must derived from [TObject](@ref) if the branch style has been set to 0 (old)

Note: See the comments in [TBranchElement!SetAddress()](@ref) for a more detailed discussion of the meaning of the addobj parameter in the case of new-style branches.

Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer

Note: if the split level is set to the default (99), [TTree!Branch](@ref) will not issue a warning if the class can not be split.
""" Branch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::Branch(const char *, void *, const char *, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Nothing}, leaflist::ByCopy{String}, bufsize::Int32)::CxxPtr1{TBranch}
Create a new [TTree](@ref) Branch.
This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.

By default the branch buffers are stored in the same file as the Tree. use [TBranch!SetFile](@ref) to specify a different file

- address is the address of the first item of a structure.
- leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:

    - `C` : a character string terminated by the 0 character
    - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.
    - `b` : an 8 bit unsigned integer (`UChar_t`)
    - `S` : a 16 bit signed integer (`Short_t`)
    - `s` : a 16 bit unsigned integer (`UShort_t`)
    - `I` : a 32 bit signed integer (`Int_t`)
    - `i` : a 32 bit unsigned integer (`UInt_t`)
    - `F` : a 32 bit floating point (`Float_t`)
    - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`)
    - `D` : a 64 bit floating point (`Double_t`)
    - `d` : a 24 bit truncated floating point (`Double32_t`)
    - `L` : a 64 bit signed integer (`Long64_t`)
    - `l` : a 64 bit unsigned integer (`ULong64_t`)
    - `G` : a long signed integer, stored as 64 bit (`Long_t`)
    - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`)
    - `O` : [the letter `o`, not a zero] a boolean (`bool`)

    Arrays of values are supported with the following syntax:

    - If leaf name has the form var[nelem], where nelem is alphanumeric, then if nelem is a leaf name, it is used as the variable size of the array, otherwise return 0. The leaf referred to by nelem **MUST** be an int (/I),
    - If leaf name has the form var[nelem], where nelem is a non-negative integer, then it is used as the fixed size of the array.
    - If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]) where nelem and nelem2 are non-negative integer) then it is used as a 2 dimensional array of fixed size.
    - In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. See `TStreamerElement!GetRange()` for further information.

    Any of other form is not supported.

Note that the [TTree](@ref) will assume that all the item are contiguous in memory. On some platform, this is not always true of the member of a struct or a class, due to padding and alignment. Sorting your data member in order of decreasing sizeof usually leads to their being contiguous in memory.

- bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.
""" Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Nothing}, leaflist::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TTree::Branch(TCollection *, Int_t, Int_t, const char *)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, list::ByPtr1{TCollection}, bufsize::Int32, splitlevel::Int32, name::ByCopy{String})::Int32
Create one branch for each element in the collection.
Each entry in the collection becomes a top level branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The splitlevel is decreased by 1 every time a new collection is found. For example if list is a TObjArray*

- if splitlevel = 1, one top level branch is created for each element of the [TObjArray](@ref).
- if splitlevel = 2, one top level branch is created for each array element. if, in turn, one of the array elements is a [TCollection](@ref), one top level branch will be created for each element of this collection.

In case a collection element is a [TClonesArray](@ref), the special Tree constructor for [TClonesArray](@ref) is called. The collection itself cannot be a [TClonesArray](@ref).

The function returns the total number of branches created.

If name is given, all branch names will be prefixed with name_.

IMPORTANT NOTE1: This function should not be called with splitlevel < 1.

IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name for a [TList](@ref) is "TList".

And in general, in case two or more master branches contain subbranches with identical names, one must add a "." (dot) character at the theend of the master branch name. This will force the name of the subbranches to be of the form `master.subbranch` instead of simply `subbranch`. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches [B1](@ref) and B2 corresponding to objects of the same class MyClass, one can do: 

    tree.Branch("B1.","MyClass",&b1,8000,1);
    tree.Branch("B2.","MyClass",&b2,8000,1);

(C++ version of the code)

 if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

Example: 

    {
          TTree T("T","test list");
          TList *list = new TList();
          TObjArray *a1 = new TObjArray();
          a1->SetName("a1");
          list->Add(a1);
          TH1F *ha1a = new TH1F("ha1a","ha1",100,0,1);
          TH1F *ha1b = new TH1F("ha1b","ha1",100,0,1);
          a1->Add(ha1a);
          a1->Add(ha1b);
          TObjArray *b1 = new TObjArray();
          b1->SetName("b1");
          list->Add(b1);
          TH1F *hb1a = new TH1F("hb1a","hb1",100,0,1);
          TH1F *hb1b = new TH1F("hb1b","hb1",100,0,1);
          b1->Add(hb1a);
          b1->Add(hb1b);
          TObjArray *a2 = new TObjArray();
          a2->SetName("a2");
          list->Add(a2);
          TH1S *ha2a = new TH1S("ha2a","ha2",100,0,1);
          TH1S *ha2b = new TH1S("ha2b","ha2",100,0,1);
          a2->Add(ha2a);
          a2->Add(ha2b);
          T.Branch(list,16000,2);
          T.Print();
    }

(C++ version of the code)
""" Branch(this::ByRef1{TTree}, list::ByPtr1{TCollection}, bufsize::Int32, splitlevel::Int32, name::ByCopy{String})

# Wrapper of Int_t TTree::Branch(TList *, Int_t, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, list::ByPtr1{TList}, bufsize::Int32, splitlevel::Int32)::Int32
Deprecated function. Use next function instead.

""" Branch(this::ByRef1{TTree}, list::ByPtr1{TList}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::BranchOld(const char *, const char *, void *, Int_t, Int_t)
@trydoc raw"""
    BranchOld(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)::CxxPtr1{TBranch}
Create a new [TTree](@ref) BranchObject.
Build a [TBranchObject](@ref) for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from [TObject](@ref). The class dictionary must be available (ClassDef in class header).

This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.

By default the branch buffers are stored in the same file as the Tree. use [TBranch!SetFile](@ref) to specify a different file

IMPORTANT NOTE about branch names:

And in general, in case two or more master branches contain subbranches with identical names, one must add a "." (dot) character at the theend of the master branch name. This will force the name of the subbranches to be of the form `master.subbranch` instead of simply `subbranch`. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches [B1](@ref) and B2 corresponding to objects of the same class MyClass, one can do: 

    tree.Branch("B1.","MyClass",&b1,8000,1);
    tree.Branch("B2.","MyClass",&b2,8000,1);

(C++ version of the code)

 if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.
""" BranchOld(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::BranchRef()
@trydoc raw"""
    BranchRef(this::ByRef1{TTree})::CxxPtr1{TBranch}
Build the optional branch supporting the [TRefTable](@ref).
This branch will keep all the information to find the branches containing referenced objects.

At each Tree!Fill, the branch numbers containing the referenced objects are saved to the [TBranchRef](@ref) basket. When the Tree header is saved (via [TTree!Write](@ref)), the branch is saved keeping the information with the pointers to the branches having referenced objects.
""" BranchRef(this::ByRef1{TTree})

# Wrapper of TBranch * TTree::Bronch(const char *, const char *, void *, Int_t, Int_t)
@trydoc raw"""
    Bronch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)::CxxPtr1{TBranch}
Create a new [TTree](@ref) BranchElement.
## WARNING about this new function

This function is designed to replace the internal implementation of the old [TTree!Branch](@ref) (whose implementation has been moved to BranchOld).

NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.

This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from [TObject](@ref). The function is based on the new [TStreamerInfo](@ref).

Build a [TBranchElement](@ref) for an object of class classname.

addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).

Note: See the comments in [TBranchElement!SetAddress()](@ref) for a more detailed discussion of the meaning of the addr parameter.

This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.

By default the branch buffers are stored in the same file as the Tree. use [TBranch!SetFile](@ref) to specify a different file

IMPORTANT NOTE about branch names:

And in general, in case two or more master branches contain subbranches with identical names, one must add a "." (dot) character at the theend of the master branch name. This will force the name of the subbranches to be of the form `master.subbranch` instead of simply `subbranch`. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches [B1](@ref) and B2 corresponding to objects of the same class MyClass, one can do: 

    tree.Branch("B1.","MyClass",&b1,8000,1);
    tree.Branch("B2.","MyClass",&b2,8000,1);

(C++ version of the code)

 if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.

Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer

Note: if the split level is set to the default (99), [TTree!Branch](@ref) will not issue a warning if the class can not be split.
""" Bronch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)

# Wrapper of void TTree::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TTree}, ::ByPtr1{TBrowser})::Nothing
Browse content of the [TTree](@ref).

""" Browse(this::ByRef1{TTree}, ::ByPtr1{TBrowser})

# Wrapper of Int_t TTree::BuildIndex(const char *, const char *)
@trydoc raw"""
    BuildIndex(this::ByRef1{TTree}, majorname::ByCopy{String}, minorname::ByCopy{String})::Int32
Build a Tree Index (default is [TTreeIndex](@ref)).
See a description of the parameters and functionality in [TTreeIndex!TTreeIndex()](@ref).

The return value is the number of entries in the Index (< 0 indicates failure).

A [TTreeIndex](@ref) object pointed by fTreeIndex is created. This object will be automatically deleted by the [TTree](@ref) destructor. If an index is already existing, this is replaced by the new one without being deleted. This behaviour prevents the deletion of a previously external index assigned to the [TTree](@ref) via the [TTree!SetTreeIndex()](@ref) method. 

###See

also comments in TTree!SetTreeIndex().
""" BuildIndex(this::ByRef1{TTree}, majorname::ByCopy{String}, minorname::ByCopy{String})

# Wrapper of TStreamerInfo * TTree::BuildStreamerInfo(TClass *, void *, bool)
@trydoc raw"""
    BuildStreamerInfo(this::ByRef1{TTree}, cl::ByPtr1{TClass}, pointer::ByPtr2{Nothing}, canOptimize::Bool)::CxxPtr1{TStreamerInfo}
Build StreamerInfo for class cl.
pointer is an optional argument that may contain a pointer to an object of cl.
""" BuildStreamerInfo(this::ByRef1{TTree}, cl::ByPtr1{TClass}, pointer::ByPtr2{Nothing}, canOptimize::Bool)

# Wrapper of TFile * TTree::ChangeFile(TFile *)
@trydoc raw"""
    ChangeFile(this::ByRef1{TTree}, file::ByPtr1{TFile})::CxxPtr1{TFile}
Called by [TTree!Fill()](@ref) when file has reached its maximum fgMaxTreeSize.
Create a new file. If the original file is named "myfile.root", subsequent files are named "myfile_1.root", "myfile_2.root", etc.

Returns a pointer to the new file.

Currently, the automatic change of file is restricted to the case where the tree is in the top level directory. The file should not contain sub-directories.

Before switching to a new file, the tree header is written to the current file, then the current file is closed.

To process the multiple files created by ChangeFile, one must use a [TChain](@ref).

The new file name has a suffix "_N" where N is equal to fFileNumber+1. By default a Root session starts with fFileNumber=0. One can set fFileNumber to a different value via [TTree!SetFileNumber](@ref). In case a file named "_N" already exists, the function will try a file named "__N", then "___N", etc.

fgMaxTreeSize can be set via the static function [TTree!SetMaxTreeSize](@ref). The default value of fgMaxTreeSize is 100 Gigabytes.

If the current file contains other objects like [TH1](@ref) and [TTree](@ref), these objects are automatically moved to the new file.

###Warning

Be careful when writing the final Tree header to the file! Don't do: TFile*file=newTFile("myfile.root","recreate");
TTree*T=newTTree("T","title");
T->Fill();//Loop
file->Write();
file->Close();
 

###Warning

but do the following: TFile*file=newTFile("myfile.root","recreate");
TTree*T=newTTree("T","title");
T->Fill();//Loop
file=T->GetCurrentFile();//Togetthepointertothecurrentfile
file->Write();
file->Close();


###Note

This method is never called if the input file is a TMemFile or derivate.
""" ChangeFile(this::ByRef1{TTree}, file::ByPtr1{TFile})

# Wrapper of TTree * TTree::CloneTree(Long64_t, Option_t *)
@trydoc raw"""
    CloneTree(this::ByRef1{TTree}, nentries::Int64, option::ByCopy{String})::CxxPtr1{TTree}
Create a clone of this tree and copy nentries.
By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.

NOTE: Only active branches are copied. See [TTree!SetBranchStatus](@ref) for more information and usage regarding the (de)activation of branches. More examples are provided in the tutorials listed below.

NOTE: If the [TTree](@ref) is a [TChain](@ref), the structure of the first [TTree](@ref) is used for the copy.

IMPORTANT: The cloned tree stays connected with this tree until this tree is deleted. In particular, any changes in branch addresses in this tree are forwarded to the clone trees, unless a branch in a clone tree has had its address changed, in which case that change stays in effect. When this tree is deleted, all the addresses of the cloned tree are reset to their default values.

If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).

When 'fast' is specified, 'option' can also contain a sorting order for the baskets in the output file.

There are currently 3 supported sorting order:

- SortBasketsByOffset (the default)
- SortBasketsByBranch
- SortBasketsByEntry

When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the baskets are sorted by their offset in the original file; Usually this also means that the baskets are sorted by the index/number of the *last* entry they contain)

When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).

When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.

For examples of CloneTree, see tutorials:

- copytree.C: A macro to copy a subset of a [TTree](@ref) to a new [TTree](@ref). The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1
- copytree2.C: A macro to copy a subset of a [TTree](@ref) to a new [TTree](@ref). One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1
""" CloneTree(this::ByRef1{TTree}, nentries::Int64, option::ByCopy{String})

# Wrapper of void TTree::CopyAddresses(TTree *, bool)
@trydoc raw"""
    CopyAddresses(this::ByRef1{TTree}, ::ByPtr1{TTree}, undo::Bool)::Nothing
Set branch addresses of passed tree equal to ours.
If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original.
""" CopyAddresses(this::ByRef1{TTree}, ::ByPtr1{TTree}, undo::Bool)

# Wrapper of Long64_t TTree::CopyEntries(TTree *, Long64_t, Option_t *, bool)
@trydoc raw"""
    CopyEntries(this::ByRef1{TTree}, tree::ByPtr1{TTree}, nentries::Int64, option::ByCopy{String}, needCopyAddresses::Bool)::Int64
Copy nentries from given tree to this tree.
This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).

By default copy all entries.

Returns number of bytes copied to this tree.

If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).

When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.

There are currently 3 supported sorting order:

- SortBasketsByOffset (the default)
- SortBasketsByBranch
- SortBasketsByEntry

See [TTree!CloneTree](@ref) for a detailed explanation of the semantics of these 3 options.

If the tree or any of the underlying tree of the chain has an index, that index and any index in the subsequent underlying [TTree](@ref) objects will be merged.

There are currently three 'options' to control this merging:

- NoIndex : all the [TTreeIndex](@ref) object are dropped.
- DropIndexOnError : if any of the underlying [TTree](@ref) object do no have a [TTreeIndex](@ref), they are all dropped.
- AsIsIndexOnError [default]: In case of missing [TTreeIndex](@ref), the resulting [TTree](@ref) index has gaps.
- BuildIndexOnError : If any of the underlying [TTree](@ref) objects do not have a [TTreeIndex](@ref), all [TTreeIndex](@ref) are 'ignored' and the missing piece are rebuilt.
""" CopyEntries(this::ByRef1{TTree}, tree::ByPtr1{TTree}, nentries::Int64, option::ByCopy{String}, needCopyAddresses::Bool)

# Wrapper of TTree * TTree::CopyTree(const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    CopyTree(this::ByRef1{TTree}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::CxxPtr1{TTree}
Copy a tree with selection.
### Important:

The returned copied tree stays connected with the original tree until the original tree is deleted. In particular, any changes to the branch addresses in the original tree are also made to the copied tree. Any changes made to the branch addresses of the copied tree are overridden anytime the original tree changes its branch addresses. When the original tree is deleted, all the branch addresses of the copied tree are set to zero.

For examples of CopyTree, see the tutorials:

- copytree.C: Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in $ROOTSYS/test/Event in this way: 

        ./Event 1000 1 1 1

(C++ version of the code)

- copytree2.C Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in $ROOTSYS/test/Event in this way: 

        ./Event 1000 1 1 1

(C++ version of the code)

- copytree3.C Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree. NOTE that only the active branches are copied.
""" CopyTree(this::ByRef1{TTree}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of void TTree::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TTree}, option::ByCopy{String})::Nothing
Delete this tree from memory or/and disk.
- if option == "all" delete Tree object from memory AND from disk all baskets on disk are deleted. All keys with same name are deleted.
- if option =="" only Tree object in memory is deleted.
""" Delete(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TTree}, ::ByPtr1{TDirectory})::Nothing
Called by [TKey](@ref) and [TObject!Clone](@ref) to automatically add us to a directory when we are read from a file.

""" DirectoryAutoAdd(this::ByRef1{TTree}, ::ByPtr1{TDirectory})

# Wrapper of Long64_t TTree::Draw(const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Draw(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Draw expression varexp for entries and objects that pass a (optional) selection.
###Return

-1 in case of error or number of selected events in case of success.

## Arguments

- **`varexp`** [in] 
    A string that takes one of these general forms:
    
    - "e1" produces a 1-d histogram ([TH1F](@ref)) of expression "e1"
    - "e1:e2" produces an unbinned 2-d scatter-plot ([TGraph](@ref)) of "e1" on the y-axis versus "e2" on the x-axis
    - "e1:e2:e3" produces an unbinned 3-d scatter-plot ([TPolyMarker3D](@ref)) of "e1" vs "e2" vs "e3" on the z-, y-, x-axis, respectively
    - "e1:e2:e3:e4" produces an unbinned 3-d scatter-plot ([TPolyMarker3D](@ref)) of "e1" vs "e2" vs "e3" and "e4" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section "Saving the result of Draw to an histogram")
    
        - "e1:e2:e3:e4:e5" with option "GL5D" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.
        - Any number of variables no fewer than two can be used with the options "CANDLE" and "PARA"
        - An arbitrary number of variables can be used with the option "GOFF"
    
        Examples:
    
        - "x": the simplest case, it draws a 1-Dim histogram of column x
        - "sqrt(x)", "x*y/z": draw histogram with the values of the specified numerical expression across [TTree](@ref) events
        - "y:sqrt(x)": 2-Dim histogram of y versus sqrt(x)
        - "px:py:pz:2.5*E": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See [TStyle!SetPalette](@ref) for setting a new color palette.
    
        The expressions can use all the operations and built-in functions supported by [TFormula](@ref) (see TFormula!Analyze()), including free functions taking numerical arguments (e.g. TMath!Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: 
    
            TMath!BreitWigner(fPx,3,2)
            event.GetHistogram()->GetXaxis()->GetXmax()
    
        (C++ version of the code)
    
         
    
    
    
- **`selection`** [in] 
    A string containing a selection expression. In a selection all usual C++ mathematical and logical operators are allowed. The value corresponding to the selection expression is used as a weight to fill the histogram (a weight of 0 is equivalent to not filling the histogram).<br/>
     <br/>
     Examples:
    
    - "x<y && sqrt(z)>3.2": returns a weight = 0 or 1
    - "(x+y)*(sqrt(z)>3.2)": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise<br/>
     <br/>
     If the selection expression returns an array, it is iterated over in sync with the array returned by the varexp argument (as described below in "Drawing expressions using arrays and array
      elements"). For example, if, for a given event, varexp evaluates to `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection: 
    
            // Muon_pt is an array: fill a histogram with the array elements > 100 in each event
            tree->Draw('Muon_pt', 'Muon_pt > 100')
    
    (C++ version of the code)
    
     
    
    
    
- **`option`** [in] 
    The drawing option.
    
    - When an histogram is produced it can be any histogram drawing option listed in [THistPainter](@ref).
    - when no option is specified:
    
        - the default histogram drawing option is used if the expression is of the form "e1".
        - if the expression is of the form "e1:e2"or "e1:e2:e3" a cloud of unbinned 2D or 3D points is drawn respectively.
        - if the expression has four fields "e1:e2:e3:e4" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette.
    - If option COL is specified when varexp has three fields: 
    
            tree.Draw("e1:e2:e3","","col");
    
    (C++ version of the code)
    
     a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.
    - if expression has more than four fields the option "PARA"or "CANDLE" can be used.
    - If option contains the string "goff", no graphics is generated. 
    
    
    
- **`nentries`** [in] 
    The number of entries to process (default is all) 
    
- **`firstentry`** [in] 
    The first entry to process (default is 0)
    

### Drawing expressions using arrays and array elements

Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array, or a [TClonesArray](@ref). In a [TTree!Draw](@ref) expression you can now access fMatrix using the following syntaxes:

| **String passed** | **What is used for each entry of the tree**                   |
|:------------------|:--------------------------------------------------------------|
| `fMatrix`         | the 9 elements of fMatrix                                     |
| `fMatrix[][]`     | the 9 elements of fMatrix                                     |
| `fMatrix[2][2]`   | only the elements fMatrix[2][2]                               |
| `fMatrix[1]`      | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |
| `fMatrix[1][]`    | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |
| `fMatrix[][0]`    | the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] |

"fEvent.fMatrix...." same as "fMatrix..." (unless there is more than one leaf named fMatrix!).

In summary, if a specific index is not specified for a dimension, [TTree!Draw](@ref) will loop through all the indices along this dimension. Leaving off the last (right most) dimension of specifying then with the two characters '[]' is equivalent. For variable size arrays (and [TClonesArray](@ref)) the range of the first dimension is recalculated for each entry of the tree. You can also specify the index as an expression of any other variables from the tree.

[TTree!Draw](@ref) also now properly handling operations involving 2 or more arrays.

Let assume a second matrix fResults[5][2], here are a sample of some of the possible combinations, the number of elements they produce and the loop used:

| **expression**                   | **element(s)** | **Loop**                                                                                                                       |
|:---------------------------------|:---------------|:-------------------------------------------------------------------------------------------------------------------------------|
| `fMatrix[2][1] - fResults[5][2]` | one            | no loop                                                                                                                        |
| `fMatrix[2][] - fResults[5][2]`  | three          | on 2nd dim fMatrix                                                                                                             |
| `fMatrix[2][] - fResults[5][]`   | two            | on both 2nd dimensions                                                                                                         |
| `fMatrix[][2] - fResults[][1]`   | three          | on both 1st dimensions                                                                                                         |
| `fMatrix[][2] - fResults[][]`    | six            | on both 1st and 2nd dimensions of fResults                                                                                     |
| `fMatrix[][2] - fResults[3][]`   | two            | on 1st dim of fMatrix and 2nd of fResults (at the same time)                                                                   |
| `fMatrix[][] - fResults[][]`     | six            | on 1st dim then on 2nd dim                                                                                                     |
| `fMatrix[][fResult[][]]`         | 30             | on 1st dim of fMatrix then on both dimensions of fResults. The value if fResults[j][k] is used as the second index of fMatrix. |

In summary, [TTree!Draw](@ref) loops through all unspecified dimensions. To figure out the range of each loop, we match each unspecified dimension from left to right (ignoring ALL dimensions for which an index has been specified), in the equivalent loop matched dimensions use the same index and are restricted to the smallest range (of only the matched dimensions). When involving variable arrays, the range can of course be different for each entry of the tree.

So the loop equivalent to "fMatrix[][2] - fResults[3][]" is: 

    for (Int_t i0; i < min(3,2); i++) {
       use the value of (fMatrix[i0][2] - fMatrix[3][i0])
    }

(C++ version of the code)

 So the loop equivalent to "fMatrix[][2] - fResults[][]" is: 

    for (Int_t i0; i < min(3,5); i++) {
       for (Int_t i1; i1 < 2; i1++) {
          use the value of (fMatrix[i0][2] - fMatrix[i0][i1])
       }
    }

(C++ version of the code)

 So the loop equivalent to "fMatrix[][] - fResults[][]" is: 

    for (Int_t i0; i < min(3,5); i++) {
       for (Int_t i1; i1 < min(3,2); i1++) {
          use the value of (fMatrix[i0][i1] - fMatrix[i0][i1])
       }
    }

(C++ version of the code)

 So the loop equivalent to "fMatrix[][fResults[][]]" is: 

    for (Int_t i0; i0 < 3; i0++) {
       for (Int_t j2; j2 < 5; j2++) {
          for (Int_t j3; j3 < 2; j3++) {
             i1 = fResults[j2][j3];
             use the value of fMatrix[i0][i1]
       }
    }

(C++ version of the code)

 

### Retrieving the result of Draw

By default a temporary histogram called `htemp` is created. It will be:

- A TH1F* in case of a mono-dimensional distribution: `Draw("e1")`,
- A TH2F* in case of a bi-dimensional distribution: `Draw("e1:e2")`,
- A TH3F* in case of a three-dimensional distribution: `Draw("e1:e2:e3")`.

In the one dimensional case the `htemp` is filled and drawn whatever the drawing option is.

In the two and three dimensional cases, with the default drawing option (`""`), a cloud of points is drawn and the histogram `htemp` is not filled. For all the other drawing options `htemp` will be filled.

In all cases `htemp` can be retrieved by calling:

    auto htemp = (TH1F*)gPad->GetPrimitive("htemp"); // 1D
    auto htemp = (TH2F*)gPad->GetPrimitive("htemp"); // 2D
    auto htemp = (TH3F*)gPad->GetPrimitive("htemp"); // 3D

(C++ version of the code)

In the two dimensional case (`Draw("e1;e2")`), with the default drawing option, the data is filled into a [TGraph](@ref) named `Graph`. This [TGraph](@ref) can be retrieved by calling

    auto graph = (TGraph*)gPad->GetPrimitive("Graph");

(C++ version of the code)

For the three and four dimensional cases, with the default drawing option, an unnamed [TPolyMarker3D](@ref) is produced, and therefore cannot be retrieved.

In all cases `htemp` can be used to access the axes. For instance in the 2D case:

    auto htemp = (TH2F*)gPad->GetPrimitive("htemp");
    auto xaxis = htemp->GetXaxis();

(C++ version of the code)

When the option `"A"` is used (with [TGraph](@ref) painting option) to draw a 2D distribution: 

    tree.Draw("e1:e2","","A*");

(C++ version of the code)

 a scatter plot is produced (with stars in that case) but the axis creation is delegated to [TGraph](@ref) and `htemp` is not created.

### Saving the result of Draw to a histogram

If `varexp` contains `>>hnew` (following the variable(s) name(s)), the new histogram called `hnew` is created and it is kept in the current directory (and also the current pad). This works for all dimensions.

Example: 

    tree.Draw("sqrt(x)>>hsqrt","y>0")

(C++ version of the code)

 will draw `sqrt(x)` and save the histogram as "hsqrt" in the current directory. To retrieve it do: 

    TH1F *hsqrt = (TH1F*)gDirectory->Get("hsqrt");

(C++ version of the code)

 The binning information is taken from the environment variables 

    Hist.Binning.?D.?

(C++ version of the code)

 In addition, the name of the histogram can be followed by up to 9 numbers between '(' and ')', where the numbers describe the following:

- 1 - bins in x-direction
- 2 - lower limit in x-direction
- 3 - upper limit in x-direction
- 4-6 same for y-direction
- 7-9 same for z-direction

When a new binning is used the new value will become the default. Values can be skipped.

Example: 

    tree.Draw("sqrt(x)>>hsqrt(500,10,20)")
         // plot sqrt(x) between 10 and 20 using 500 bins
    tree.Draw("sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)")
         // plot sqrt(x) against sin(y)
         // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60
         //  50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5

(C++ version of the code)

 By default, the specified histogram is reset. To continue to append data to an existing histogram, use "+" in front of the histogram name.

A '+' in front of the histogram name is ignored, when the name is followed by binning information as described in the previous paragraph. 

    tree.Draw("sqrt(x)>>+hsqrt","y>0")

(C++ version of the code)

 will not reset `hsqrt`, but will continue filling. This works for 1-D, 2-D and 3-D histograms.

### Accessing collection objects

[TTree!Draw](@ref) default's handling of collections is to assume that any request on a collection pertain to it content. For example, if fTracks is a collection of Track objects, the following: 

    tree->Draw("event.fTracks.fPx");

(C++ version of the code)

 will plot the value of fPx for each Track objects inside the collection. Also 

    tree->Draw("event.fTracks.size()");

(C++ version of the code)

 would plot the result of the member function Track!size() for each Track object inside the collection. To access information about the collection itself, [TTree!Draw](@ref) support the '@' notation. If a variable which points to a collection is prefixed or postfixed with '@', the next part of the expression will pertain to the collection object. For example: 

    tree->Draw("event.@fTracks.size()");

(C++ version of the code)

 will plot the size of the collection referred to by `fTracks` (i.e the number of Track objects).

### Drawing 'objects'

When a class has a member function named AsDouble or AsString, requesting to directly draw the object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std!string or a TString.s For example, the following 

    tree->Draw("event.myTTimeStamp");

(C++ version of the code)

 will draw the same histogram as 

    tree->Draw("event.myTTimeStamp.AsDouble()");

(C++ version of the code)

 In addition, when the object is a type [TString](@ref) or std!string, [TTree!Draw](@ref) will call respectively `TString!Data` and `std!string!c_str()`

If the object is a [TBits](@ref), the histogram will contain the index of the bit that are turned on.

### Retrieving  information about the tree itself.

You can refer to the tree (or chain) containing the data by using the string 'This'. You can then could any [TTree](@ref) methods. For example: 

    tree->Draw("This->GetReadEntry()");

(C++ version of the code)

 will display the local_ entry numbers be read. 

    tree->Draw("This->GetUserInfo()->At(0)->GetName()");

(C++ version of the code)

 will display the name of the first 'user info' object.

### Special functions and variables

`Entry$`: A [TTree!Draw](@ref) formula can use the special variable `Entry$` to access the entry number being read. For example to draw every other entry use: 

    tree.Draw("myvar","Entry$%2==0");

(C++ version of the code)

- `Entry$` : return the current entry number (`== TTree!GetReadEntry()`)
- `LocalEntry$` : return the current entry number in the current tree of a chain (`== GetTree()->GetReadEntry()`)
- `Entries$` : return the total number of entries (== [TTree!GetEntries()](@ref))
- `LocalEntries$` : return the total number of entries in the current tree of a chain (== [GetTree()](@ref)->[TTree!GetEntries()](@ref))
- `Length$` : return the total number of element of this formula for this entry (`==TTreeFormula!GetNdata()`)
- `Iteration$` : return the current iteration over this formula for this entry (i.e. varies from 0 to `Length$`).
- `Length$(formula )` : return the total number of element of the formula given as a parameter.
- `Sum$(formula )` : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with: `Sum$(formula )/Length$(formula )`
- `Min$(formula )` : return the minimum (within one [TTree](@ref) entry) of the value of the elements of the formula given as a parameter.
- `Max$(formula )` : return the maximum (within one [TTree](@ref) entry) of the value of the elements of the formula given as a parameter.
- `MinIf$(formula,condition)`
- `MaxIf$(formula,condition)` : return the minimum (maximum) (within one [TTree](@ref) entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: 

        tree->Draw("MinIf$(formula,condition)","condition");

(C++ version of the code)

 which will avoid calculation `MinIf$` for the entries that have no match for the condition.
- `Alt$(primary,alternate)` : return the value of "primary" if it is available for the current iteration otherwise return the value of "alternate". For example, with arr1[3] and arr2[2] 

        tree->Draw("arr1+Alt$(arr2,0)");

(C++ version of the code)

 will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 

        tree->Draw("Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)");

(C++ version of the code)

 will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison 

        tree->Draw("arr3[0]+arr3[1]+arr3[2]");

(C++ version of the code)

 will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using `Alt$` with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by [TTree!Draw](@ref), [TTree!Scan](@ref) can be used: 

        tree->Scan("arr1:Alt$(arr2,0)");

(C++ version of the code)

 will print on one line the value of arr1 and (arr2,0) that will be matched by 

        tree->Draw("arr1-Alt$(arr2,0)");

(C++ version of the code)

 The ternary operator is not directly supported in [TTree!Draw](@ref) however, to plot the equivalent of `var2<20 ? -99 : var1`, you can use: 

        tree->Draw("(var2<20)*99+(var2>=20)*var1","");

(C++ version of the code)


### Drawing a user function accessing the TTree data directly

If the formula contains a file name, [TTree!MakeProxy](@ref) will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.

For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: 

    double hsimple() {
       return px;
    }

(C++ version of the code)

 MakeProxy can then be used indirectly via the [TTree!Draw](@ref) interface as follow: 

    new TFile("hsimple.root")
    ntuple->Draw("hsimple.cxx");

(C++ version of the code)

 A more complete example is available in the tutorials directory: `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C` which reimplement the selector found in `h1analysis.C`

The main features of this facility are:

- on-demand loading of branches
- ability to use the 'branchname' as if it was a data member
- protection against array out-of-bound
- ability to use the branch data as object (when the user code is available)

See [TTree!MakeProxy](@ref) for more details.

### Making a Profile histogram

In case of a 2-Dim expression, one can generate a [TProfile](@ref) histogram instead of a [TH2F](@ref) histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See [TProfile2D!SetErrorOption](@ref) for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing [TProfile](@ref) histogram.

### Making a 2D Profile histogram

In case of a 3-Dim expression, one can generate a [TProfile2D](@ref) histogram instead of a [TH3F](@ref) histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See [TProfile2D!SetErrorOption](@ref) for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing [TProfile2D](@ref) histogram.

### Making a 5D plot using GL

If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.

### Making a parallel coordinates plot

In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error.

### Making a candle sticks chart

In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error.

### Normalizing the output histogram to 1

When option contains "norm" the output histogram is normalized to 1.

### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray

[TTree!Draw](@ref) can be used to fill a [TEventList](@ref) object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a [TEventList](@ref) object named "elist" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option "entrylist" is used, a [TEntryList](@ref) object is created If the selection contains arrays, vectors or any container class and option "entrylistarray" is used, a [TEntryListArray](@ref) object is created containing also the subentries satisfying the selection, i.e. the indices of the branches which hold containers classes. Example: 

    tree.Draw(">>yplus","y>0")

(C++ version of the code)

 will create a [TEventList](@ref) object named "yplus" in the current directory. In an interactive session, one can type (after [TTree!Draw](@ref)) 

    yplus.Print("all")

(C++ version of the code)

 to print the list of entry numbers in the list. 

    tree.Draw(">>yplus", "y>0", "entrylist")

(C++ version of the code)

 will create a [TEntryList](@ref) object names "yplus" in the current directory 

    tree.Draw(">>yplus", "y>0", "entrylistarray")

(C++ version of the code)

 will create a [TEntryListArray](@ref) object names "yplus" in the current directory

By default, the specified entry list is reset. To continue to append data to an existing list, use "+" in front of the list name; 

    tree.Draw(">>+yplus","y>0")

(C++ version of the code)

 will not reset yplus, but will enter the selected entries at the theend of the existing list.

### Using a TEventList, TEntryList or TEntryListArray as Input

Once a [TEventList](@ref) or a [TEntryList](@ref) object has been generated, it can be used as input for [TTree!Draw](@ref). Use [TTree!SetEventList](@ref) or [TTree!SetEntryList](@ref) to set the current event list

Example 1: 

    TEventList *elist = (TEventList*)gDirectory->Get("yplus");
    tree->SetEventList(elist);
    tree->Draw("py");

(C++ version of the code)

 Example 2: 

    TEntryList *elist = (TEntryList*)gDirectory->Get("yplus");
    tree->SetEntryList(elist);
    tree->Draw("py");

(C++ version of the code)

 If a [TEventList](@ref) object is used as input, a new [TEntryList](@ref) object is created inside the SetEventList function. In case of a [TChain](@ref), all tree headers are loaded for this transformation. This new object is owned by the chain and is deleted with it, unless the user extracts it by calling [GetEntryList()](@ref) function. See also comments to [SetEventList()](@ref) function of [TTree](@ref) and [TChain](@ref).

If arrays are used in the selection criteria and [TEntryListArray](@ref) is not used, all the entries that have at least one element of the array that satisfy the selection are entered in the list.

Example: 

    tree.Draw(">>pyplus","fTracks.fPy>0");
    tree->SetEventList(pyplus);
    tree->Draw("fTracks.fPy");

(C++ version of the code)

 will draw the fPy of ALL tracks in event with at least one track with a positive fPy.

To select only the elements that did match the original selection use [TEventList!SetReapplyCut](@ref) or [TEntryList!SetReapplyCut](@ref).

Example: 

    tree.Draw(">>pyplus","fTracks.fPy>0");
    pyplus->SetReapplyCut(true);
    tree->SetEventList(pyplus);
    tree->Draw("fTracks.fPy");

(C++ version of the code)

 will draw the fPy of only the tracks that have a positive fPy.

To draw only the elements that match a selection in case of arrays, you can also use [TEntryListArray](@ref) (faster in case of a more general selection).

Example: 

    tree.Draw(">>pyplus","fTracks.fPy>0", "entrylistarray");
    tree->SetEntryList(pyplus);
    tree->Draw("fTracks.fPy");

(C++ version of the code)

 will draw the fPy of only the tracks that have a positive fPy, but without redoing the selection.

Note: Use tree->SetEventList(0) if you do not want use the list as input.

### How to obtain more info from TTree::Draw

Once [TTree!Draw](@ref) has been called, it is possible to access useful information still stored in the [TTree](@ref) object via the following functions:

- [GetSelectedRows()](@ref) // return the number of values accepted by the selection expression. In case where no selection was specified, returns the number of values processed.
- [GetV1()](@ref) // returns a pointer to the double array of V1
- [GetV2()](@ref) // returns a pointer to the double array of V2
- [GetV3()](@ref) // returns a pointer to the double array of V3
- [GetV4()](@ref) // returns a pointer to the double array of V4
- [GetW()](@ref) // returns a pointer to the double array of Weights where weight equal the result of the selection expression.

where V1,V2,V3 correspond to the expressions in 

    TTree!Draw("V1:V2:V3:V4",selection);

(C++ version of the code)

 If the expression has more than 4 component use GetVal(index)

Example: 

    Root > ntuple->Draw("py:px","pz>4");
    Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),
                                  ntuple->GetV2(), ntuple->GetV1());
    Root > gr->Draw("ap"); //draw graph in current pad

(C++ version of the code)

A more complete complete tutorial (treegetval.C) shows how to use the [GetVal()](@ref) method.

creates a [TGraph](@ref) object with a number of points corresponding to the number of entries selected by the expression "pz>4", the x points of the graph being the px values of the Tree and the y points the py values.

Important note: By default [TTree!Draw](@ref) creates the arrays obtained with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding to the parameter fEstimate. The content will be the last `GetSelectedRows() % GetEstimate()` values calculated. By default fEstimate=1000000 and can be modified via [TTree!SetEstimate](@ref). To keep in memory all the results (in case where there is only one result per entry), use 

    tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);

(C++ version of the code)

 You must call SetEstimate if the expected number of selected rows you need to look at is greater than 1000000.

You can use the option "goff" to turn off the graphics output of [TTree!Draw](@ref) in the above example.

### Automatic interface to TTree::Draw via the TTreeViewer

A complete graphical interface to this function is implemented in the class [TTreeViewer](@ref). To thestart the [TTreeViewer](@ref), three possibilities:

- select [TTree](@ref) context menu item "StartViewer"
- type the command "TTreeViewer TV(treeName)"
- execute statement "tree->StartViewer();"
""" Draw(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of void TTree::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TTree}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::DropBaskets()
@trydoc raw"""
    DropBaskets(this::ByRef1{TTree})::Nothing
Remove some baskets from memory.

""" DropBaskets(this::ByRef1{TTree})

# Wrapper of Int_t TTree::DropBranchFromCache(const char *, bool)
@trydoc raw"""
    DropBranchFromCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)::Int32
Remove the branch with name 'bname' from the Tree cache.
If bname="*" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.

Returns:

- 0 branch dropped or not in cache
- -1 on error
""" DropBranchFromCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)

# Wrapper of Int_t TTree::DropBranchFromCache(TBranch *, bool)
@trydoc raw"""
    DropBranchFromCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)::Int32
Remove the branch b from the Tree cache.
if subbranches is true all the branches of the subbranches are also removed from the cache.

Returns:

- 0 branch dropped or not in cache
- -1 on error
""" DropBranchFromCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)

# Wrapper of void TTree::DropBuffers(Int_t)
@trydoc raw"""
    DropBuffers(this::ByRef1{TTree}, nbytes::Int32)::Nothing
Drop branch buffers to accommodate nbytes below MaxVirtualsize.

""" DropBuffers(this::ByRef1{TTree}, nbytes::Int32)

# Wrapper of bool TTree::EnableCache()
@trydoc raw"""
    EnableCache(this::ByRef1{TTree})::Bool
Enable the [TTreeCache](@ref) unless explicitly disabled for this [TTree](@ref) by a prior call to `SetCacheSize(0)`.
If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config `TTreeCache.Size` has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster)

Return true if there is a cache attached to the `TTree` (either pre-exisiting or created as part of this call)
""" EnableCache(this::ByRef1{TTree})

# Wrapper of Int_t TTree::Fill()
@trydoc raw"""
    Fill(this::ByRef1{TTree})::Int32
Fill all branches.
This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.

This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.

The function returns the number of bytes committed to the individual branches.

If a write error occurs, the number of bytes returned is -1.

If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.

**The baskets are flushed and the Tree header saved at regular intervals**

At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.

###Note

Calling TTree!FlushBaskets too often increases the IO time.

###Note

Calling TTree!AutoSave too often increases the IO time and also the file size.

###Note

This method calls TTree!ChangeFile when the tree reaches a size greater than TTree!fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate.
""" Fill(this::ByRef1{TTree})

# Wrapper of TBranch * TTree::FindBranch(const char *)
@trydoc raw"""
    FindBranch(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TBranch}
Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches.
In case of ambiguity, returns the first match.
""" FindBranch(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of TLeaf * TTree::FindLeaf(const char *)
@trydoc raw"""
    FindLeaf(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TLeaf}
Find leaf..

""" FindLeaf(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of Int_t TTree::Fit(const char *, const char *, const char *, Option_t *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Fit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int32
Fit a projected item(s) from a tree.
funcname is a [TF1](@ref) function.

See [TTree!Draw()](@ref) for explanations of the other parameters.

By default the temporary histogram created is called htemp. If varexp contains >>hnew , the new histogram created is called hnew and it is kept in the current directory.

The function returns the number of selected entries.

Example: 

    tree.Fit(pol4,"sqrt(x)>>hsqrt","y>0")

(C++ version of the code)

 will fit sqrt(x) and save the histogram as "hsqrt" in the current directory.

See also [TTree!UnbinnedFit](@ref)

## Return status

The function returns the status of the histogram fit (see [TH1!Fit](@ref)) If no entries were selected, the function returns -1; (i.e. fitResult is null if the fit is OK)
""" Fit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of TBranch * TTree::GetBranch(const char *)
@trydoc raw"""
    GetBranch(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TBranch}
Return pointer to the branch with the given name in this tree or its friends.
The search is done breadth first.
""" GetBranch(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of Long64_t TTree::GetEntries(const char *)
@trydoc raw"""
    GetEntries(this::ByRef1{TTree}, selection::ByCopy{String})::Int64
Return the number of entries matching the selection.
Return -1 in case of errors.

If the selection uses any arrays or containers, we return the number of entries where at least one element match the selection. GetEntries is implemented using the selector class [TSelectorEntries](@ref), which can be used directly (see code in [TTreePlayer!GetEntries](@ref)) for additional option. If SetEventList was used on the [TTree](@ref) or [TChain](@ref), only that subset of entries will be considered.
""" GetEntries(this::ByRef1{TTree}, selection::ByCopy{String})

# Wrapper of Int_t TTree::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TTree}, entry::Int64, getall::Int32)::Int32
Read all branches of entry and return total number of bytes read.
- `getall = 0` : get only active branches
- `getall = 1` : get all branches

The function returns the number of bytes read from the input buffer. If entry does not exist the function returns 0. If an I/O error occurs, the function returns -1.

If the Tree has friends, also read the friends entry.

To activate/deactivate one or more branches, use TBranch!SetBranchStatus For example, if you have a Tree with several hundred branches, and you are interested only by branches named "a" and "b", do 

    mytree.SetBranchStatus("*",0); //disable all branches
    mytree.SetBranchStatus("a",1);
    mytree.SetBranchStatus("b",1);

(C++ version of the code)

 when calling mytree.GetEntry(i); only branches "a" and "b" will be read.

**WARNING!!** If your Tree has been created in split mode with a parent branch "parent.", 

    mytree.SetBranchStatus("parent",1);

(C++ version of the code)

 will not activate the sub-branches of "parent". You should do: 

    mytree.SetBranchStatus("parent*",1);

(C++ version of the code)

 Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.

An alternative is to call directly 

    brancha.GetEntry(i)
    branchb.GetEntry(i);

(C++ version of the code)

 

## IMPORTANT NOTE

By default, GetEntry reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(true) (default is false).

Example:

Consider the example in $ROOTSYS/test/Event.h The top level branch in the tree T is declared with: 

    Event *event = 0;  //event must be null or point to a valid object
                       //it must be initialized
    T.SetBranchAddress("event",&event);

(C++ version of the code)

 When reading the Tree, one can choose one of these 3 options:

## OPTION 1

    for (Long64_t i=0;i<nentries;i++) {
       T.GetEntry(i);
       // the object event has been filled at this point
    }

(C++ version of the code)

 The default (recommended). At the first entry an object of the class Event will be created and pointed by event. At the following entries, event will be overwritten by the new data. All internal members that are TObject* are automatically deleted. It is important that these members be in a valid state when GetEntry is called. Pointers must be correctly initialized. However these internal members will not be deleted if the characters "->" are specified as the first characters in the comment field of the data member declaration.

If "->" is specified, the pointer member is read via pointer->Streamer(buf). In this case, it is assumed that the pointer is never null (case of pointer [TClonesArray](@ref) *fTracks in the Event example). If "->" is not specified, the pointer member is read via buf >> pointer. In this case the pointer may be null. Note that the option with "->" is faster to read or write and it also consumes less space in the file.

## OPTION 2

The option AutoDelete is set 

    TBranch *branch = T.GetBranch("event");
    branch->SetAddress(&event);
    branch->SetAutoDelete(true);
    for (Long64_t i=0;i<nentries;i++) {
       T.GetEntry(i);
       // the object event has been filled at this point
    }

(C++ version of the code)

 In this case, at each iteration, the object event is deleted by GetEntry and a new instance of Event is created and filled.

## OPTION 3

    Same as option 1, but you delete yourself the event.
        for (Long64_t i=0;i<nentries;i++) {
           delete event;
           event = 0;  // EXTREMELY IMPORTANT
           T.GetEntry(i);
           // the object event has been filled at this point
        }

(C++ version of the code)

 It is strongly recommended to use the default option 1. It has the additional advantage that functions like [TTree!Draw](@ref) (internally calling [TTree!GetEntry](@ref)) will be functional even when the classes in the file are not available.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the object ownership policy of the underlying (user) data.
""" GetEntry(this::ByRef1{TTree}, entry::Int64, getall::Int32)

# Wrapper of TEntryList * TTree::GetEntryList()
@trydoc raw"""
    GetEntryList(this::ByRef1{TTree})::CxxPtr1{TEntryList}
Returns the entry list assigned to this tree.

""" GetEntryList(this::ByRef1{TTree})

# Wrapper of Int_t TTree::GetEntryWithIndex(Int_t, Int_t)
@trydoc raw"""
    GetEntryWithIndex(this::ByRef1{TTree}, major::Int32, minor::Int32)::Int32
Read entry corresponding to major and minor number.
The function returns the total number of bytes read. If the Tree has friend trees, the corresponding entry with the index values (major,minor) is read. Note that the master Tree and its friend may have different entry serial numbers corresponding to (major,minor).
""" GetEntryWithIndex(this::ByRef1{TTree}, major::Int32, minor::Int32)

# Wrapper of Int_t TTree::GetEvent(Long64_t, Int_t)
@trydoc raw"""
    GetEvent(this::ByRef1{TTree}, entry::Int64, getall::Int32)::Int32


""" GetEvent(this::ByRef1{TTree}, entry::Int64, getall::Int32)

# Wrapper of TH1 * TTree::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByRef1{TTree})::CxxPtr1{TH1}


""" GetHistogram(this::ByRef1{TTree})

# Wrapper of bool TTree::GetImplicitMT()
@trydoc raw"""
    GetImplicitMT(this::ByRef1{TTree})::Bool


""" GetImplicitMT(this::ByRef1{TTree})

# Wrapper of Int_t * TTree::GetIndex()
@trydoc raw"""
    GetIndex(this::ByRef1{TTree})::CxxPtr2{Int32}


""" GetIndex(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetIndexValues()
@trydoc raw"""
    GetIndexValues(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetIndexValues(this::ByRef1{TTree})

# Wrapper of TIterator * TTree::GetIteratorOnAllLeaves(bool)
@trydoc raw"""
    GetIteratorOnAllLeaves(this::ByRef1{TTree}, dir::Bool)::CxxPtr1{TIterator}
Creates a new iterator that will go through all the leaves on the tree itself and its friend.

""" GetIteratorOnAllLeaves(this::ByRef1{TTree}, dir::Bool)

# Wrapper of TLeaf * TTree::GetLeaf(const char *, const char *)
@trydoc raw"""
    GetLeaf(this::ByRef1{TTree}, branchname::ByCopy{String}, leafname::ByCopy{String})::CxxPtr1{TLeaf}
Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees.
The leaf name can contain the name of a friend tree with the syntax: friend_dir_and_tree.full_leaf_name the friend_dir_and_tree can be of the form: 
```
TDirectoryName/TreeName 
```
""" GetLeaf(this::ByRef1{TTree}, branchname::ByCopy{String}, leafname::ByCopy{String})

# Wrapper of TLeaf * TTree::GetLeaf(const char *)
@trydoc raw"""
    GetLeaf(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TLeaf}
Return pointer to first leaf named "name" in any branch of this tree or its friend trees.
## Arguments

- **`name`** [in] 
    may be in the form 'branch/leaf'
""" GetLeaf(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of TObjArray * TTree::GetListOfBranches()
@trydoc raw"""
    GetListOfBranches(this::ByRef1{TTree})::CxxPtr1{TObjArray}


""" GetListOfBranches(this::ByRef1{TTree})

# Wrapper of TList * TTree::GetListOfClones()
@trydoc raw"""
    GetListOfClones(this::ByRef1{TTree})::CxxPtr1{TList}


""" GetListOfClones(this::ByRef1{TTree})

# Wrapper of TObjArray * TTree::GetListOfLeaves()
@trydoc raw"""
    GetListOfLeaves(this::ByRef1{TTree})::CxxPtr1{TObjArray}


""" GetListOfLeaves(this::ByRef1{TTree})

# Wrapper of Double_t TTree::GetMaximum(const char *)
@trydoc raw"""
    GetMaximum(this::ByRef1{TTree}, columname::ByCopy{String})::Float64
Return maximum of column with name columname.
if the Tree has an associated [TEventList](@ref) or [TEntryList](@ref), the maximum is computed for the entries in this list.
""" GetMaximum(this::ByRef1{TTree}, columname::ByCopy{String})

# Wrapper of Double_t TTree::GetMinimum(const char *)
@trydoc raw"""
    GetMinimum(this::ByRef1{TTree}, columname::ByCopy{String})::Float64
Return minimum of column with name columname.
if the Tree has an associated [TEventList](@ref) or [TEntryList](@ref), the minimum is computed for the entries in this list.
""" GetMinimum(this::ByRef1{TTree}, columname::ByCopy{String})

# Wrapper of Int_t TTree::GetNbranches()
@trydoc raw"""
    GetNbranches(this::ByRef1{TTree})::Int32


""" GetNbranches(this::ByRef1{TTree})

# Wrapper of TVirtualTreePlayer * TTree::GetPlayer()
@trydoc raw"""
    GetPlayer(this::ByRef1{TTree})::CxxPtr1{TVirtualTreePlayer}
Load the [TTreePlayer](@ref) (if not already done).

""" GetPlayer(this::ByRef1{TTree})

# Wrapper of Long64_t TTree::GetSelectedRows()
@trydoc raw"""
    GetSelectedRows(this::ByRef1{TTree})::Int64


""" GetSelectedRows(this::ByRef1{TTree})

# Wrapper of TBuffer * TTree::GetTransientBuffer(Int_t)
@trydoc raw"""
    GetTransientBuffer(this::ByRef1{TTree}, size::Int32)::CxxPtr1{TBuffer}
Returns the transient buffer currently used by this [TTree](@ref) for reading/writing baskets.

""" GetTransientBuffer(this::ByRef1{TTree}, size::Int32)

# Wrapper of TList * TTree::GetUserInfo()
@trydoc raw"""
    GetUserInfo(this::ByRef1{TTree})::CxxPtr1{TList}
Return a pointer to the list containing user objects associated to this tree.
The list is automatically created if it does not exist.

WARNING: By default the [TTree](@ref) destructor will delete all objects added to this list. If you do not want these objects to be deleted, call: 
```
mytree->GetUserInfo()->Clear();
```  before deleting the tree.
""" GetUserInfo(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV1()
@trydoc raw"""
    GetV1(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV1(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV2()
@trydoc raw"""
    GetV2(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV2(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV3()
@trydoc raw"""
    GetV3(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV3(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV4()
@trydoc raw"""
    GetV4(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV4(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetVal(Int_t)
@trydoc raw"""
    GetVal(this::ByRef1{TTree}, i::Int32)::CxxPtr2{Float64}


""" GetVal(this::ByRef1{TTree}, i::Int32)

# Wrapper of Double_t * TTree::GetW()
@trydoc raw"""
    GetW(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetW(this::ByRef1{TTree})

# Wrapper of void TTree::IncrementTotalBuffers(Int_t)
@trydoc raw"""
    IncrementTotalBuffers(this::ByRef1{TTree}, nbytes::Int32)::Nothing


""" IncrementTotalBuffers(this::ByRef1{TTree}, nbytes::Int32)

# Wrapper of bool TTree::InPlaceClone(TDirectory *, const char *)
@trydoc raw"""
    InPlaceClone(this::ByRef1{TTree}, newdirectory::ByPtr1{TDirectory}, options::ByCopy{String})::Bool
Copy the content to a new new file, update this [TTree](@ref) with the new location information and attach this [TTree](@ref) to the new directory.
options: Indicates a basket sorting method, see TTreeCloner!TTreeCloner for details

If new and old directory are in the same file, the data is untouched, this "just" does a call to SetDirectory. Equivalent to an "in place" cloning of the [TTree](@ref).
""" InPlaceClone(this::ByRef1{TTree}, newdirectory::ByPtr1{TDirectory}, options::ByCopy{String})

# Wrapper of Int_t TTree::LoadBaskets(Long64_t)
@trydoc raw"""
    LoadBaskets(this::ByRef1{TTree}, maxmemory::Int64)::Int32
Read in memory all baskets from all branches up to the limit of maxmemory bytes.
If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly [TBranch!LoadBaskets](@ref).
""" LoadBaskets(this::ByRef1{TTree}, maxmemory::Int64)

# Wrapper of Long64_t TTree::LoadTree(Long64_t)
@trydoc raw"""
    LoadTree(this::ByRef1{TTree}, entry::Int64)::Int64
Set current entry.
Returns -2 if entry does not exist (just as [TChain!LoadTree()](@ref)). Returns -6 if an error occurs in the notification callback (just as [TChain!LoadTree()](@ref)).

Calls fNotify->[Notify()](@ref) (if fNotify is not null) when starting the processing of a new tree.

###Note

This function is overloaded in TChain.
""" LoadTree(this::ByRef1{TTree}, entry::Int64)

# Wrapper of Long64_t TTree::LoadTreeFriend(Long64_t, TTree *)
@trydoc raw"""
    LoadTreeFriend(this::ByRef1{TTree}, entry::Int64, T::ByPtr1{TTree})::Int64
Load entry on behalf of our master tree, we may use an index.
Called by [LoadTree()](@ref) when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.

If we have no index, our entry number and the masterTree entry number are the same.

If we *do* have an index, we must find the (major, minor) value pair in masterTree to locate our corresponding entry.
""" LoadTreeFriend(this::ByRef1{TTree}, entry::Int64, T::ByPtr1{TTree})

# Wrapper of Int_t TTree::MakeClass(const char *, Option_t *)
@trydoc raw"""
    MakeClass(this::ByRef1{TTree}, classname::ByCopy{String}, option::ByCopy{String})::Int32
Generate a skeleton analysis class for this tree.
The following files are produced: classname.h and classname.C. If classname is 0, classname will be called "nameoftree".

The generated code in classname.h includes the following:

- Identification of the original tree and the input file name.
- Definition of an analysis class (data members and member functions).
- The following member functions:

    - constructor (by default opening the tree file),
    - GetEntry(Long64_t entry),
    - Init(TTree* tree) to initialize a new [TTree](@ref),
    - Show(Long64_t entry) to read and dump entry.

The generated code in classname.C includes only the main analysis function Loop.

To use this function:

- Open your tree file (eg: [TFile](@ref) f("myfile.root");)
- T->MakeClass("MyClass");

where T is the name of the [TTree](@ref) in file myfile.root, and MyClass.h, MyClass.C the name of the files created by this function. In a [ROOT](@ref) session, you can do: 

    root > .L MyClass.C
    root > MyClass* t = new MyClass;
    root > t->GetEntry(12); // Fill data members of t with entry number 12.
    root > t->Show();       // Show values of entry 12.
    root > t->Show(16);     // Read and show values of entry 16.
    root > t->Loop();       // Loop on all entries.

(C++ version of the code)

 NOTE: Do not use the code generated for a single [TTree](@ref) which is part of a [TChain](@ref) to process that entire [TChain](@ref). The maximum dimensions calculated for arrays on the basis of a single [TTree](@ref) from the [TChain](@ref) might be (will be!) too small when processing all of the TTrees in the [TChain](@ref). You must use myChain.MakeClass() to generate the code, not myTree.MakeClass(...).
""" MakeClass(this::ByRef1{TTree}, classname::ByCopy{String}, option::ByCopy{String})

# Wrapper of Int_t TTree::MakeCode(const char *)
@trydoc raw"""
    MakeCode(this::ByRef1{TTree}, filename::ByCopy{String})::Int32
Generate a skeleton function for this tree.
The function code is written on filename. If filename is 0, filename will be called nameoftree.C

The generated code includes the following:

- Identification of the original Tree and Input file name,
- Opening the Tree file,
- Declaration of Tree variables,
- Setting of branches addresses,
- A skeleton for the entry loop.

To use this function:

- Open your Tree file (eg: [TFile](@ref) f("myfile.root");)
- T->MakeCode("MyAnalysis.C");

where T is the name of the [TTree](@ref) in file myfile.root and MyAnalysis.C the name of the file created by this function.

NOTE: Since the implementation of this function, a new and better function [TTree!MakeClass()](@ref) has been developed.
""" MakeCode(this::ByRef1{TTree}, filename::ByCopy{String})

# Wrapper of Int_t TTree::MakeProxy(const char *, const char *, const char *, const char *, Int_t)
@trydoc raw"""
    MakeProxy(this::ByRef1{TTree}, classname::ByCopy{String}, macrofilename::ByCopy{String}, cutfilename::ByCopy{String}, option::ByCopy{String}, maxUnrolling::Int32)::Int32
Generate a skeleton analysis class for this Tree using TBranchProxy.
TBranchProxy is the base of a class hierarchy implementing an indirect access to the content of the branches of a [TTree](@ref).

"proxyClassname" is expected to be of the form: 

    [path/]fileprefix

(C++ version of the code)

 The skeleton will then be generated in the file: 

    fileprefix.h

(C++ version of the code)

 located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'

"macrofilename" and optionally "cutfilename" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: 

    [if (cutfilename())] htemp->Fill(macrofilename());

(C++ version of the code)

 "option" can be used select some of the optional features during the code generation. The possible options are:

- nohist : indicates that the generated ProcessFill should not fill the histogram.

'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of [TTreeFormula](@ref)).

The main features of this skeleton are:

- on-demand loading of branches
- ability to use the 'branchname' as if it was a data member
- protection against array out-of-bounds errors
- ability to use the branch data as an object (when the user code is available)

For example with Event.root, if 

    Double_t somePx = fTracks.fPx[2];

(C++ version of the code)

 is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.

Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: 

    x_t macrofilename(); // i.e function with the same name as the file

(C++ version of the code)

 and 

    y_t cutfilename();   // i.e function with the same name as the file

(C++ version of the code)

 x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: 
```
if (cutfilename()) htemp->Fill(macrofilename());
```  These two functions are run in a context such that the branch names are available as local_ variables of the correct (read-only) type.

Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: 

    Int_t n = fEventNumber; // Read fEventNumber
    if (n<10 || n>10) { ... }

(C++ version of the code)

 is more efficient than 

    if (fEventNumber<10 || fEventNumber>10)

(C++ version of the code)

 Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).

Concretely, with the script named h1analysisProxy.C,

- The method calls the method (if it exist)
- Begin -> void h1analysisProxy_Begin(TTree*);
- SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);
- Notify -> bool h1analysisProxy_Notify();
- Process -> bool h1analysisProxy_Process(Long64_t);
- SlaveTerminate -> void h1analysisProxy_SlaveTerminate();
- Terminate -> void h1analysisProxy_Terminate();

If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.

The default histogram is accessible via the variable named 'htemp'.

If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed `include` statements and give the ability to access the object stored in the branches.

To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: 

    double hsimple() {
       return px;
    }

(C++ version of the code)

 MakeProxy can then be used indirectly via the [TTree!Draw](@ref) interface as follow: 

    new TFile("hsimple.root")
    ntuple->Draw("hsimple.cxx");

(C++ version of the code)

 A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C
""" MakeProxy(this::ByRef1{TTree}, classname::ByCopy{String}, macrofilename::ByCopy{String}, cutfilename::ByCopy{String}, option::ByCopy{String}, maxUnrolling::Int32)

# Wrapper of Int_t TTree::MakeSelector(const char *, Option_t *)
@trydoc raw"""
    MakeSelector(this::ByRef1{TTree}, selector::ByCopy{String}, option::ByCopy{String})::Int32
Generate skeleton selector class for this tree.
The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called "nameoftree". The option can be used to specify the branches that will have a data member.

- If option is "=legacy", a pre-ROOT6 selector will be generated (data members and branch pointers instead of TTreeReaders).
- If option is empty, readers will be generated for each leaf.
- If option is "@", readers will be generated for the topmost branches.
- Individual branches can also be picked by their name:

    - "X" generates readers for leaves of X.
    - "@X" generates a reader for X as a whole.
    - "@X;Y" generates a reader for X as a whole and also readers for the leaves of Y.
- For further examples see the figure below.

![https://root.cern/doc/v636/ttree_makeselector_option_examples.png](https://root.cern/doc/v636/ttree_makeselector_option_examples.png)

The generated code in selector.h includes the following:

- Identification of the original Tree and Input file name
- Definition of selector class (data and functions)
- The following class functions:

    - constructor and destructor
    - void Begin(TTree *tree)
    - void SlaveBegin(TTree *tree)
    - void Init(TTree *tree)
    - bool [Notify()](@ref)
    - bool Process(Long64_t entry)
    - void Terminate()
    - void SlaveTerminate()

The class selector derives from [TSelector](@ref). The generated code in selector.C includes empty functions defined above.

To use this function:

- connect your Tree file (eg: `TFile f("myfile.root");`)
- `T->MakeSelector("myselect");`

where T is the name of the Tree in file myfile.root and myselect.h, myselect.C the name of the files created by this function. In a [ROOT](@ref) session, you can do: 

    root > T->Process("myselect.C")

(C++ version of the code)
""" MakeSelector(this::ByRef1{TTree}, selector::ByCopy{String}, option::ByCopy{String})

# Wrapper of bool TTree::MemoryFull(Int_t)
@trydoc raw"""
    MemoryFull(this::ByRef1{TTree}, nbytes::Int32)::Bool
Check if adding nbytes to memory we are still below MaxVirtualsize.

""" MemoryFull(this::ByRef1{TTree}, nbytes::Int32)

# Wrapper of Long64_t TTree::Merge(TCollection *, Option_t *)
@trydoc raw"""
    Merge(this::ByRef1{TTree}, list::ByPtr1{TCollection}, option::ByCopy{String})::Int64
Merge the trees in the [TList](@ref) into this tree.
Returns the total number of entries in the merged tree.
""" Merge(this::ByRef1{TTree}, list::ByPtr1{TCollection}, option::ByCopy{String})

# Wrapper of bool TTree::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TTree})::Bool
Function called when loading a new class library.

""" Notify(this::ByRef1{TTree})

# Wrapper of void TTree::OptimizeBaskets(ULong64_t, Float_t, Option_t *)
@trydoc raw"""
    OptimizeBaskets(this::ByRef1{TTree}, maxMemory::UInt64, minComp::Float32, option::ByCopy{String})::Nothing
This function may be called after having filled some entries in a Tree.
Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.

The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.

if option ="d" an analysis report is printed.
""" OptimizeBaskets(this::ByRef1{TTree}, maxMemory::UInt64, minComp::Float32, option::ByCopy{String})

# Wrapper of TPrincipal * TTree::Principal(const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Principal(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::CxxPtr1{TPrincipal}
Interface to the Principal Components Analysis class.
Create an instance of [TPrincipal](@ref)

Fill it with the selected variables

- if option "n" is specified, the [TPrincipal](@ref) object is filled with normalized variables.
- If option "p" is specified, compute the principal components
- If option "p" and "d" print results of analysis
- If option "p" and "h" generate standard histograms
- If option "p" and "c" generate code of conversion functions
- return a pointer to the [TPrincipal](@ref) object. It is the user responsibility
- to delete this object.
- The option default value is "np"

see [TTree!Draw](@ref) for explanation of the other parameters.

The created object is named "principal" and a reference to it is added to the list of specials Root objects. you can retrieve a pointer to the created object via: 

    TPrincipal *principal =
    (TPrincipal*)gROOT->GetListOfSpecials()->FindObject("principal");

(C++ version of the code)
""" Principal(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Long64_t TTree::Process(const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Process(this::ByRef1{TTree}, filename::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Process this tree executing the [TSelector](@ref) code in the specified filename.
The return value is -1 in case of error and [TSelector!GetStatus()](@ref) in in case of success.

The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from [TSelector](@ref), where [TSelector](@ref) has the following member functions:

- `Begin()`: called every time a loop on the tree starts, a convenient place to create your histograms.
- `SlaveBegin()`: called after [Begin()](@ref), when on PROOF called only on the slave servers.
- `Process()`: called for each event, in this function you decide what to read and fill your histograms.
- `SlaveTerminate`: called at the theend of the loop on the tree, when on PROOF called only on the slave servers.
- `Terminate()`: called at the theend of the loop on the tree, a convenient place to draw/fit your histograms.

If filename is of the form file.C, the file will be interpreted.

If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.

If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.

## NOTE1

It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg 

    MySelector *selector = (MySelector*)TSelector!GetSelector(filename);
    selector->CallSomeFunction(..);
    mytree.Process(selector,..);

(C++ version of the code)

 

## NOTE2

One should not call this function twice with the same selector file in the same script. If this is required, proceed as indicated in NOTE1, by getting a pointer to the corresponding [TSelector](@ref),eg

### Workaround 1

    void stubs1() {
       TSelector *selector = TSelector!GetSelector("h1test.C");
       TFile *f1 = new TFile("stubs_nood_le1.root");
       TTree *h1 = (TTree*)f1->Get("h1");
       h1->Process(selector);
       TFile *f2 = new TFile("stubs_nood_le1_coarse.root");
       TTree *h2 = (TTree*)f2->Get("h1");
       h2->Process(selector);
    }

(C++ version of the code)

 or use ACLIC to compile the selector

### Workaround 2

    void stubs2() {
       TFile *f1 = new TFile("stubs_nood_le1.root");
       TTree *h1 = (TTree*)f1->Get("h1");
       h1->Process("h1test.C+");
       TFile *f2 = new TFile("stubs_nood_le1_coarse.root");
       TTree *h2 = (TTree*)f2->Get("h1");
       h2->Process("h1test.C+");
    }

(C++ version of the code)
""" Process(this::ByRef1{TTree}, filename::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Long64_t TTree::Project(const char *, const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Project(this::ByRef1{TTree}, hname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Make a projection of a tree using selections.
Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc., projection of the tree will be filled in histogram hname. Note that the dimension of hname must match with the dimension of varexp.
""" Project(this::ByRef1{TTree}, hname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Long64_t TTree::ReadFile(const char *, const char *, char)
@trydoc raw"""
    ReadFile(this::ByRef1{TTree}, filename::ByCopy{String}, branchDescriptor::ByCopy{String}, delimiter::Int8)::Int64
Create or simply read branches from filename.
if branchDescriptor = "" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like 

    A/D:Table[2]/F:Ntracks/I:astring/C

(C++ version of the code)

 otherwise branchDescriptor must be specified with the above syntax.

- If the type of the first variable is not specified, it is assumed to be "/F"
- If the type of any other variable is not specified, the type of the previous variable is assumed. eg

    - `x:y:z` (all variables are assumed of type "F")
    - `x/D:y:z` (all variables are of type "D")
    - `x:y/D:z` (x is type "F", y and z of type "D")

delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == "", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type "F". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.

Lines in the input file starting with "#" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.

A [TBranch](@ref) object is created for each variable in the expression. The total number of rows read from the file is returned.

## FILLING a TTree WITH MULTIPLE INPUT TEXT FILES

To fill a [TTree](@ref) with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls 

    T.ReadFile("file1.dat","branch descriptor");
    T.ReadFile("file2.dat");

(C++ version of the code)
""" ReadFile(this::ByRef1{TTree}, filename::ByCopy{String}, branchDescriptor::ByCopy{String}, delimiter::Int8)

# Wrapper of void TTree::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TTree}, obj::ByPtr1{TObject})::Nothing
Make sure that obj (which is being deleted or will soon be) is no longer referenced by this [TTree](@ref).

""" RecursiveRemove(this::ByRef1{TTree}, obj::ByPtr1{TObject})

# Wrapper of void TTree::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TTree})::Nothing
Refresh contents of this tree and its branches from the current status on disk.
One can call this function in case the tree file is being updated by another process.
""" Refresh(this::ByRef1{TTree})

# Wrapper of void TTree::RemoveFriend(TTree *)
@trydoc raw"""
    RemoveFriend(this::ByRef1{TTree}, ::ByPtr1{TTree})::Nothing
Remove a friend from the list of friends.

""" RemoveFriend(this::ByRef1{TTree}, ::ByPtr1{TTree})

# Wrapper of void TTree::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TTree}, option::ByCopy{String})::Nothing
Reset baskets, buffers and entries count in all branches and leaves.

""" Reset(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::ResetBranchAddress(TBranch *)
@trydoc raw"""
    ResetBranchAddress(this::ByRef1{TTree}, ::ByPtr1{TBranch})::Nothing
Tell all of our branches to set their addresses to zero.
Note: If any of our branches own any objects, they are deleted.
""" ResetBranchAddress(this::ByRef1{TTree}, ::ByPtr1{TBranch})

# Wrapper of void TTree::ResetBranchAddresses()
@trydoc raw"""
    ResetBranchAddresses(this::ByRef1{TTree})::Nothing
Tell all of our branches to drop their current objects and allocate new ones.

""" ResetBranchAddresses(this::ByRef1{TTree})

# Wrapper of Long64_t TTree::Scan(const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Scan(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Loop over tree entries and print entries passing selection.
- If varexp is 0 (or "") then print only first 8 columns.
- If varexp = "*" print all columns.

Otherwise a columns selection can be made using "var1:var2:var3". 

###See

TTreePlayer!Scan for more information
""" Scan(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of bool TTree::SetAlias(const char *, const char *)
@trydoc raw"""
    SetAlias(this::ByRef1{TTree}, aliasName::ByCopy{String}, aliasFormula::ByCopy{String})::Bool
Set a tree variable alias.
Set an alias for an expression/formula based on the tree 'variables'.

The content of 'aliasName' can be used in [TTreeFormula](@ref) (i.e. [TTree!Draw](@ref), [TTree!Scan](@ref), [TTreeViewer](@ref)) and will be evaluated as the content of 'aliasFormula'.

If the content of 'aliasFormula' only contains symbol names, periods and array index specification (for example event.fTracks[3]), then the content of 'aliasName' can be used as the thestart of symbol.

If the alias 'aliasName' already existed, it is replaced by the new value.

When being used, the alias can be preceded by an eventual 'Friend Alias' (see [TTree!GetFriendAlias](@ref))

Return true if it was added properly.

For example: 

    tree->SetAlias("x1","(tdc1[1]-tdc1[0])/49");
    tree->SetAlias("y1","(tdc1[3]-tdc1[2])/47");
    tree->SetAlias("x2","(tdc2[1]-tdc2[0])/49");
    tree->SetAlias("y2","(tdc2[3]-tdc2[2])/47");
    tree->Draw("y2-y1:x2-x1");
    tree->SetAlias("theGoodTrack","event.fTracks[3]");
    tree->Draw("theGoodTrack.fPx"); // same as "event.fTracks[3].fPx"

(C++ version of the code)
""" SetAlias(this::ByRef1{TTree}, aliasName::ByCopy{String}, aliasFormula::ByCopy{String})

# Wrapper of void TTree::SetAutoFlush(Long64_t)
@trydoc raw"""
    SetAutoFlush(this::ByRef1{TTree}, autof::Int64)::Nothing
This function may be called at the thestart of a program to change the default value for fAutoFlush.
### CASE 1 : autof > 0

autof is the number of consecutive entries after which [TTree!Fill](@ref) will flush all branch buffers to disk.

### CASE 2 : autof < 0

When filling the Tree the branch buffers will be flushed to disk when more than autof bytes have been written to the file. At the first FlushBaskets [TTree!Fill](@ref) will replace fAutoFlush by the current value of fEntries.

Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.

The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file.

### CASE 3 : autof = 0

The AutoFlush mechanism is disabled.

Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.

A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the [TTreeCache](@ref) will read.
""" SetAutoFlush(this::ByRef1{TTree}, autof::Int64)

# Wrapper of void TTree::SetAutoSave(Long64_t)
@trydoc raw"""
    SetAutoSave(this::ByRef1{TTree}, autos::Int64)::Nothing
In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point.
This function may be called before filling a [TTree](@ref) to specify when the branch buffers and [TTree](@ref) header are flushed to disk as part of [TTree!Fill()](@ref). The default is -300000000, ie the [TTree](@ref) will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be written to the file. CASE 3: If fAutoSave is 0, [AutoSave()](@ref) will never be called automatically as part of [TTree!Fill()](@ref).
""" SetAutoSave(this::ByRef1{TTree}, autos::Int64)

# Wrapper of void TTree::SetBasketSize(const char *, Int_t)
@trydoc raw"""
    SetBasketSize(this::ByRef1{TTree}, bname::ByCopy{String}, buffsize::Int32)::Nothing
Set a branch's basket size.
bname is the name of a branch.

- if bname="*", apply to all branches.
- if bname="xxx*", apply to all branches with name starting with xxx

see [TRegexp](@ref) for wildcarding options buffsize = branc basket size
""" SetBasketSize(this::ByRef1{TTree}, bname::ByCopy{String}, buffsize::Int32)

# Wrapper of Int_t TTree::SetBranchAddress(const char *, void *, TBranch **, TClass *, EDataType, bool)
@trydoc raw"""
    SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)::Int32
Verify the validity of the type of addr before calling SetBranchAddress.
See [TTree!CheckBranchAddressType](@ref) for the semantic of the return value.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the meaning of the addr parameter and the object ownership policy.
""" SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)

# Wrapper of Int_t TTree::SetBranchAddress(const char *, void *, TBranch **)
@trydoc raw"""
    SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch})::Int32
Change branch address, dealing with clone trees properly.
See [TTree!CheckBranchAddressType](@ref) for the semantic of the return value.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the meaning of the addr parameter and the object ownership policy.
""" SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch})

# Wrapper of Int_t TTree::SetBranchAddress(const char *, void *, TClass *, EDataType, bool)
@trydoc raw"""
    SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)::Int32
Verify the validity of the type of addr before calling SetBranchAddress.
See [TTree!CheckBranchAddressType](@ref) for the semantic of the return value.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the meaning of the addr parameter and the object ownership policy.
""" SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)

# Wrapper of void TTree::SetBranchStatus(const char *, bool, UInt_t *)
@trydoc raw"""
    SetBranchStatus(this::ByRef1{TTree}, bname::ByCopy{String}, status::Bool, found::ByPtr2{UInt32})::Nothing
Set branch status to Process or DoNotProcess.
When reading a Tree, by default, all branches are read. One can speed up considerably the analysis phase by activating only the branches that hold variables involved in a query.

bname is the name of a branch.

- if bname="*", apply to all branches.
- if bname="xxx*", apply to all branches with name starting with xxx

see [TRegexp](@ref) for wildcarding options

- status = 1 branch will be processed
- = 0 branch will not be processed

Example:

Assume a tree T with sub-branches a,b,c,d,e,f,g,etc.. when doing T.GetEntry(i) all branches are read for entry i. to read only the branches c and e, one can do 

    T.SetBranchStatus("*",0); //disable all branches
    T.SetBranchStatus("c",1);
    T.setBranchStatus("e",1);
    T.GetEntry(i);

(C++ version of the code)

 bname is interpreted as a wild-carded [TRegexp](@ref) (see TRegexp!MakeWildcard). Thus, "a*b" or "a.*b" matches branches starting with "a" and ending with "b", but not any other branch with an "a" followed at some point by a "b". For this second behavior, use "*a*b*". Note that TRegExp does not support '|', and so you cannot select, e.g. track and shower branches with "track|shower".

**WARNING! WARNING! WARNING!**

SetBranchStatus is matching the branch based on match of the branch 'name' and not on the branch hierarchy! In order to be able to selectively enable a top level object that is 'split' you need to make sure the name of the top level branch is prefixed to the sub-branches' name (by adding a dot ('.') at the theend of the Branch creation and use the corresponding bname.

I.e If your Tree has been created in split mode with a parent branch "parent." (note the trailing dot). 

    T.SetBranchStatus("parent",1);

(C++ version of the code)

 will not activate the sub-branches of "parent". You should do: 

    T.SetBranchStatus("parent*",1);

(C++ version of the code)

 Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.

An alternative to this function is to read directly and only the interesting branches. Example: 

    TBranch *brc = T.GetBranch("c");
    TBranch *bre = T.GetBranch("e");
    brc->GetEntry(i);
    bre->GetEntry(i);

(C++ version of the code)

 If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed.
""" SetBranchStatus(this::ByRef1{TTree}, bname::ByCopy{String}, status::Bool, found::ByPtr2{UInt32})

# Wrapper of Int_t TTree::SetCacheEntryRange(Long64_t, Long64_t)
@trydoc raw"""
    SetCacheEntryRange(this::ByRef1{TTree}, first::Int64, last::Int64)::Int32
interface to [TTreeCache](@ref) to set the cache entry range
Returns:

- 0 entry range set
- -1 on error
""" SetCacheEntryRange(this::ByRef1{TTree}, first::Int64, last::Int64)

# Wrapper of void TTree::SetCacheLearnEntries(Int_t)
@trydoc raw"""
    SetCacheLearnEntries(this::ByRef1{TTree}, n::Int32)::Nothing
Interface to [TTreeCache](@ref) to set the number of entries for the learning phase.

""" SetCacheLearnEntries(this::ByRef1{TTree}, n::Int32)

# Wrapper of Int_t TTree::SetCacheSize(Long64_t)
@trydoc raw"""
    SetCacheSize(this::ByRef1{TTree}, cachesize::Int64)::Int32
Set maximum size of the file cache .
- if cachesize = 0 the existing cache (if any) is deleted.
- if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes).

Returns:

- 0 size set, cache was created if possible
- -1 on error
""" SetCacheSize(this::ByRef1{TTree}, cachesize::Int64)

# Wrapper of void TTree::SetChainOffset(Long64_t)
@trydoc raw"""
    SetChainOffset(this::ByRef1{TTree}, offset::Int64)::Nothing


""" SetChainOffset(this::ByRef1{TTree}, offset::Int64)

# Wrapper of void TTree::SetCircular(Long64_t)
@trydoc raw"""
    SetCircular(this::ByRef1{TTree}, maxEntries::Int64)::Nothing
Enable/Disable circularity for this tree.
if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.

#### NOTE 1:

Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. #### NOTE 2:

Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. #### NOTE 3:

SetCircular with maxEntries <= 0 is automatically called by [TChain!Merge](@ref) #### NOTE 4:

A circular Tree can still be saved in a file. When read back, it is still a circular Tree and can be filled again.
""" SetCircular(this::ByRef1{TTree}, maxEntries::Int64)

# Wrapper of void TTree::SetClusterPrefetch(bool)
@trydoc raw"""
    SetClusterPrefetch(this::ByRef1{TTree}, enabled::Bool)::Nothing


""" SetClusterPrefetch(this::ByRef1{TTree}, enabled::Bool)

# Wrapper of void TTree::SetDebug(Int_t, Long64_t, Long64_t)
@trydoc raw"""
    SetDebug(this::ByRef1{TTree}, level::Int32, min::Int64, max::Int64)::Nothing
Set the debug level and the debug range.
For entries in the debug range, the functions [TBranchElement!Fill](@ref) and [TBranchElement!GetEntry](@ref) will print the number of bytes filled or read for each branch.
""" SetDebug(this::ByRef1{TTree}, level::Int32, min::Int64, max::Int64)

# Wrapper of void TTree::SetDefaultEntryOffsetLen(Int_t, bool)
@trydoc raw"""
    SetDefaultEntryOffsetLen(this::ByRef1{TTree}, newdefault::Int32, updateExisting::Bool)::Nothing
Update the default value for the branch's fEntryOffsetLen.
If updateExisting is true, also update all the existing branches. If newdefault is less than 10, the new default value will be 10.
""" SetDefaultEntryOffsetLen(this::ByRef1{TTree}, newdefault::Int32, updateExisting::Bool)

# Wrapper of void TTree::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TTree}, dir::ByPtr1{TDirectory})::Nothing
Change the tree's directory.
Remove reference to this tree from current directory and add reference to new directory dir. The dir parameter can be 0 in which case the tree does not belong to any directory.
""" SetDirectory(this::ByRef1{TTree}, dir::ByPtr1{TDirectory})

# Wrapper of Long64_t TTree::SetEntries(Long64_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TTree}, n::Int64)::Int64
Change number of entries in the tree.
If n >= 0, set number of entries in the tree = n.

If n < 0, set number of entries in the tree to match the number of entries in each branch. (default for n is -1)

This function should be called only when one fills each branch independently via [TBranch!Fill](@ref) without calling [TTree!Fill](@ref). Calling [TTree!SetEntries()](@ref) make sense only if the number of entries in each branch is identical, a warning is issued otherwise. The function returns the number of entries.
""" SetEntries(this::ByRef1{TTree}, n::Int64)

# Wrapper of void TTree::SetEntryList(TEntryList *, Option_t *)
@trydoc raw"""
    SetEntryList(this::ByRef1{TTree}, list::ByPtr1{TEntryList}, opt::ByCopy{String})::Nothing
Set an EntryList.

""" SetEntryList(this::ByRef1{TTree}, list::ByPtr1{TEntryList}, opt::ByCopy{String})

# Wrapper of void TTree::SetEstimate(Long64_t)
@trydoc raw"""
    SetEstimate(this::ByRef1{TTree}, nentries::Int64)::Nothing
Set number of entries to estimate variable limits.
If n is -1, the estimate is set to be the current maximum for the tree (i.e. [GetEntries()](@ref) + 1) If n is less than -1, the behavior is undefined.
""" SetEstimate(this::ByRef1{TTree}, nentries::Int64)

# Wrapper of void TTree::SetFileNumber(Int_t)
@trydoc raw"""
    SetFileNumber(this::ByRef1{TTree}, number::Int32)::Nothing
Set fFileNumber to number.
fFileNumber is used by [TTree!Fill](@ref) to set the file name for a new file to be created when the current file exceeds fgTreeMaxSize. (see [TTree!ChangeFile](@ref)) if fFileNumber=10, the new file name will have a suffix "_11", ie, fFileNumber is incremented before setting the file name
""" SetFileNumber(this::ByRef1{TTree}, number::Int32)

# Wrapper of void TTree::SetImplicitMT(bool)
@trydoc raw"""
    SetImplicitMT(this::ByRef1{TTree}, enabled::Bool)::Nothing


""" SetImplicitMT(this::ByRef1{TTree}, enabled::Bool)

# Wrapper of void TTree::SetMakeClass(Int_t)
@trydoc raw"""
    SetMakeClass(this::ByRef1{TTree}, make::Int32)::Nothing
Set all the branches in this [TTree](@ref) to be in decomposed object mode (also known as MakeClass mode).
For MakeClass mode 0, the [TTree](@ref) expects the address where the data is stored to be set by either the user or the [TTree](@ref) to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof).
""" SetMakeClass(this::ByRef1{TTree}, make::Int32)

# Wrapper of void TTree::SetMaxEntryLoop(Long64_t)
@trydoc raw"""
    SetMaxEntryLoop(this::ByRef1{TTree}, maxev::Int64)::Nothing


""" SetMaxEntryLoop(this::ByRef1{TTree}, maxev::Int64)

# Wrapper of void TTree::SetMaxVirtualSize(Long64_t)
@trydoc raw"""
    SetMaxVirtualSize(this::ByRef1{TTree}, size::Int64)::Nothing


""" SetMaxVirtualSize(this::ByRef1{TTree}, size::Int64)

# Wrapper of void TTree::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TTree}, name::ByCopy{String})::Nothing
Change the name of this tree.

""" SetName(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of void TTree::SetNotify(TObject *)
@trydoc raw"""
    SetNotify(this::ByRef1{TTree}, obj::ByPtr1{TObject})::Nothing
Sets the address of the object to be notified when the tree is loaded.
The method [TObject!Notify](@ref) is called for the given object when the tree is loaded. Specifically this occurs in the [TTree!LoadTree](@ref) method. To remove the notification call this method with nullptr: 

    tree->SetNotify(nullptr); 

(C++ version of the code)

If this is a [TChain](@ref), `obj` is most often going to be a [TNotifyLink](@ref).

## Arguments

- **`obj`** [in] 
    Pointer to a [TObject](@ref) to be notified.
""" SetNotify(this::ByRef1{TTree}, obj::ByPtr1{TObject})

# Wrapper of void TTree::SetObject(const char *, const char *)
@trydoc raw"""
    SetObject(this::ByRef1{TTree}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Change the name and title of this tree.

""" SetObject(this::ByRef1{TTree}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TTree::SetParallelUnzip(bool, Float_t)
@trydoc raw"""
    SetParallelUnzip(this::ByRef1{TTree}, opt::Bool, RelSize::Float32)::Nothing
Enable or disable parallel unzipping of Tree buffers.

""" SetParallelUnzip(this::ByRef1{TTree}, opt::Bool, RelSize::Float32)

# Wrapper of void TTree::SetPerfStats(TVirtualPerfStats *)
@trydoc raw"""
    SetPerfStats(this::ByRef1{TTree}, perf::ByPtr1{TVirtualPerfStats})::Nothing
Set perf stats.

""" SetPerfStats(this::ByRef1{TTree}, perf::ByPtr1{TVirtualPerfStats})

# Wrapper of void TTree::SetScanField(Int_t)
@trydoc raw"""
    SetScanField(this::ByRef1{TTree}, n::Int32)::Nothing


""" SetScanField(this::ByRef1{TTree}, n::Int32)

# Wrapper of void TTree::SetTargetMemoryRatio(Float_t)
@trydoc raw"""
    SetTargetMemoryRatio(this::ByRef1{TTree}, ratio::Float32)::Nothing


""" SetTargetMemoryRatio(this::ByRef1{TTree}, ratio::Float32)

# Wrapper of void TTree::SetTimerInterval(Int_t)
@trydoc raw"""
    SetTimerInterval(this::ByRef1{TTree}, msec::Int32)::Nothing


""" SetTimerInterval(this::ByRef1{TTree}, msec::Int32)

# Wrapper of void TTree::SetUpdate(Int_t)
@trydoc raw"""
    SetUpdate(this::ByRef1{TTree}, freq::Int32)::Nothing


""" SetUpdate(this::ByRef1{TTree}, freq::Int32)

# Wrapper of void TTree::SetWeight(Double_t, Option_t *)
@trydoc raw"""
    SetWeight(this::ByRef1{TTree}, w::Float64, option::ByCopy{String})::Nothing
Set tree weight.
The weight is used by [TTree!Draw](@ref) to automatically weight each selected entry in the resulting histogram.

For example the equivalent of: 

    T.Draw("x", "w")

(C++ version of the code)

 is: 

    T.SetWeight(w);
    T.Draw("x");

(C++ version of the code)

 This function is redefined by [TChain!SetWeight](@ref). In case of a [TChain](@ref), an option "global_" may be specified to set the same weight for all trees in the [TChain](@ref) instead of the default behaviour using the weights of each tree in the chain (see [TChain!SetWeight](@ref)).
""" SetWeight(this::ByRef1{TTree}, w::Float64, option::ByCopy{String})

# Wrapper of void TTree::Show(Long64_t, Int_t)
@trydoc raw"""
    Show(this::ByRef1{TTree}, entry::Int64, lenmax::Int32)::Nothing
Print values of all active leaves for entry.
- if entry==-1, print current entry (default)
- if a leaf is an array, a maximum of lenmax elements is printed.
""" Show(this::ByRef1{TTree}, entry::Int64, lenmax::Int32)

# Wrapper of void TTree::StartViewer()
@trydoc raw"""
    StartViewer(this::ByRef1{TTree})::Nothing
Start the [TTreeViewer](@ref) on this tree.
- ww is the width of the canvas in pixels
- wh is the height of the canvas in pixels
""" StartViewer(this::ByRef1{TTree})

# Wrapper of Int_t TTree::StopCacheLearningPhase()
@trydoc raw"""
    StopCacheLearningPhase(this::ByRef1{TTree})::Int32
Stop the cache learning phase.
Returns:

- 0 learning phase stopped or not active
- -1 on error
""" StopCacheLearningPhase(this::ByRef1{TTree})

# Wrapper of Int_t TTree::UnbinnedFit(const char *, const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    UnbinnedFit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int32
Unbinned fit of one or more variable(s) from a tree.
funcname is a [TF1](@ref) function.

###See

TTree!Draw for explanations of the other parameters.

Fit the variable varexp using the function funcname using the selection cuts given by selection.

The list of fit options is given in parameter option.

- option = "Q" Quiet mode (minimum printing)
- option = "V" Verbose mode (default is between Q and V)
- option = "E" Perform better Errors estimation using Minos technique
- option = "M" More. Improve fit results

You can specify boundary limits for some or all parameters via 

    func->SetParLimits(p_number, parmin, parmax);

(C++ version of the code)

 if parmin>=parmax, the parameter is fixed

Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do: 

    func->SetParameters(0,3.1,1.e-6,0.1,-8,100);
    func->SetParLimits(4,-10,-4);
    func->SetParLimits(5, 1,1);

(C++ version of the code)

 With this setup:

- Parameters 0->3 can vary freely
- Parameter 4 has boundaries [-10,-4] with initial value -8
- Parameter 5 is fixed to 100.

For the fit to be meaningful, the function must be self-normalized.

i.e. It must have the same integral regardless of the parameter settings. Otherwise the fit will effectively just maximize the area.

It is mandatory to have a normalization variable which is fixed for the fit. e.g. 

    TF1* f1 = new TF1("f1", "gaus(0)/sqrt(2*3.14159)/[2]", 0, 5);
    f1->SetParameters(1, 3.1, 0.01);
    f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1
    data->UnbinnedFit("f1", "jpsimass", "jpsipt>3.0");

(C++ version of the code)

 1, 2 and 3 Dimensional fits are supported. See also [TTree!Fit](@ref)

Return status:

- The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult
- The fitResult is 0 is the fit is OK.
- The fitResult is negative in case of an error not connected with the fit.
- The number of entries used in the fit can be obtained via mytree.GetSelectedRows();
- If the number of selected entries is null the function returns -1
""" UnbinnedFit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of void TTree::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TTree})::Nothing
Replace current attributes by current style.

""" UseCurrentStyle(this::ByRef1{TTree})

# Wrapper of Int_t TTree::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TTree}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write this object to the current directory.
For more see [TObject!Write](@ref) If option & kFlushBasket, call FlushBasket before writing the tree.
""" Write(this::ByRef1{TTree}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of void TLeaf::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TLeaf}, b::ByPtr1{TBrowser})::Nothing
Browse the content of this leaf.

""" Browse(this::ByRef1{TLeaf}, b::ByPtr1{TBrowser})

# Wrapper of bool TLeaf::CanGenerateOffsetArray()
@trydoc raw"""
    CanGenerateOffsetArray(this::ByRef1{TLeaf})::Bool


""" CanGenerateOffsetArray(this::ByRef1{TLeaf})

# Wrapper of void TLeaf::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)::Nothing


""" Export(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)

# Wrapper of void TLeaf::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeaf}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeaf}, b::ByRef1{TBuffer})

# Wrapper of Int_t * TLeaf::GenerateOffsetArray(Int_t, Int_t)
@trydoc raw"""
    GenerateOffsetArray(this::ByRef1{TLeaf}, base::Int32, events::Int32)::CxxPtr2{Int32}


""" GenerateOffsetArray(this::ByRef1{TLeaf}, base::Int32, events::Int32)

# Wrapper of void TLeaf::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)::Nothing


""" Import(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)

# Wrapper of bool TLeaf::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeaf}, ::ByPtr1{TLeaf})::Bool


""" IncludeRange(this::ByRef1{TLeaf}, ::ByPtr1{TLeaf})

# Wrapper of void TLeaf::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeaf}, ::ByRef1{TBuffer})::Nothing


""" ReadBasket(this::ByRef1{TLeaf}, ::ByRef1{TBuffer})

# Wrapper of void TLeaf::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::ByPtr1{TClonesArray}, ::Int32)::Nothing


""" ReadBasketExport(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::ByPtr1{TClonesArray}, ::Int32)

# Wrapper of bool TLeaf::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketFast(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of bool TLeaf::ReadBasketSerialized(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketSerialized(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketSerialized(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of Int_t TLeaf::ResetAddress(void *, bool)
@trydoc raw"""
    ResetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing}, calledFromDestructor::Bool)::Int32
Helper routine for TLeafX!SetAddress.
The return value is non-zero if we owned the old value buffer and must delete it now. The size of the value buffer is recalculated and stored, and a decision is made whether or not we own the new value buffer.
""" ResetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing}, calledFromDestructor::Bool)

# Wrapper of void TLeaf::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing})::Nothing


""" SetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing})

# Wrapper of void TLeaf::SetBranch(TBranch *)
@trydoc raw"""
    SetBranch(this::ByRef1{TLeaf}, branch::ByPtr1{TBranch})::Nothing


""" SetBranch(this::ByRef1{TLeaf}, branch::ByPtr1{TBranch})

# Wrapper of void TLeaf::SetLeafCount(TLeaf *)
@trydoc raw"""
    SetLeafCount(this::ByRef1{TLeaf}, leaf::ByPtr1{TLeaf})::Nothing
Set the leaf count of this leaf.

""" SetLeafCount(this::ByRef1{TLeaf}, leaf::ByPtr1{TLeaf})

# Wrapper of void TLeaf::SetLen(Int_t)
@trydoc raw"""
    SetLen(this::ByRef1{TLeaf}, len::Int32)::Nothing


""" SetLen(this::ByRef1{TLeaf}, len::Int32)

# Wrapper of void TLeaf::SetOffset(Int_t)
@trydoc raw"""
    SetOffset(this::ByRef1{TLeaf}, offset::Int32)::Nothing


""" SetOffset(this::ByRef1{TLeaf}, offset::Int32)

# Wrapper of void TLeaf::SetRange(bool)
@trydoc raw"""
    SetRange(this::ByRef1{TLeaf}, range::Bool)::Nothing


""" SetRange(this::ByRef1{TLeaf}, range::Bool)

# Wrapper of void TLeaf::SetUnsigned()
@trydoc raw"""
    SetUnsigned(this::ByRef1{TLeaf})::Nothing


""" SetUnsigned(this::ByRef1{TLeaf})

# Wrapper of void TEntryList::Add(const TEntryList *)
@trydoc raw"""
    Add(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})::Nothing
Add 2 entry lists.
## Arguments

- **`elist`** [in] 
    The list that should be added to the current one.
    

###Note

If you are creating a TEntryList for a TChain and you would like to have a one to one mapping between the sub lists of the TEntryList and the sub trees in the TChain, please do not call this function but use TEntryList!AddSubList instead and pair it with a call to TChain!SetEntryList with option "sync". See the AddSubList function documentation for an example usage. This helps for example in a testing or benchmark scenario where a TChain holds multiple times the same tree in the same file. In that case, this function would not be be able to distinguish different sub entry lists that refer to the same treename and filename. Instead it would create a union of all the sub entry lists into one list.
""" Add(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})

# Wrapper of void TEntryList::AddSubList(TEntryList *)
@trydoc raw"""
    AddSubList(this::ByRef1{TEntryList}, elist::ByPtr1{TEntryList})::Nothing
Add a sub entry list to the current list.
## Arguments

- **`elist`** [in] 
    an entry list that should be added as a sub list of this list.
    

This function is specifically targeted at situations where there is a global_ [TEntryList](@ref) that should hold one or more sub [TEntryList](@ref) objects. For example, if one wants to create a one to one mapping between the sub entry lists and the trees in the files that make a [TChain](@ref). Note that in such cases this configuration of the entry list should be used in pair with the option `"sync"` of the function [TChain!SetEntryList](@ref)

    // Create a TChain with two files. Each contains a tree with 20 entries
    TChain chain{"entries"};
    chain.Add("file_20entries_1.root");
    chain.Add("file_20entries_2.root");
    // Create a global_, empty TEntryList.
    TEntryList elists;
    // Create two entry lists. Each one will be referring to a different tree in the chain
    TEntryList elist1{"","","entries","file_20entries_1.root"};
    TEntryList elist2{"","","entries","file_20entries_2.root"};
    // Select the first ten entries from the first tree and all entries from the second
    for(auto entry = 0; entry < 10; entry++){
        elist1.Enter(entry);
    }
    for(auto entry = 0; entry < 20; entry++){
        elist2.Enter(entry);
    }
    // Add sub entry lists to the global_ list
    elists.AddSubList(&elist1);
    elists.AddSubList(&elist2);
    // Set the entry list in the chain. Note the usage of option "sync"
    chain.SetEntryList(&elists, "sync");

(C++ version of the code)
""" AddSubList(this::ByRef1{TEntryList}, elist::ByPtr1{TEntryList})

# Wrapper of Int_t TEntryList::Contains(Long64_t, TTree *)
@trydoc raw"""
    Contains(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})::Int32

- When tree = 0, returns from the current list
- When tree != 0, finds the list, corresponding to this tree
- When tree is a chain, the entry is assumed to be global_ index and the local_ entry is recomputed from the treeoffset information of the chain
""" Contains(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})

# Wrapper of void TEntryList::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TEntryList}, ::ByPtr1{TDirectory})::Nothing
Called by [TKey](@ref) and others to automatically add us to a directory when we are read from a file.

""" DirectoryAutoAdd(this::ByRef1{TEntryList}, ::ByPtr1{TDirectory})

# Wrapper of bool TEntryList::Enter(Long64_t, TTree *)
@trydoc raw"""
    Enter(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})::Bool
Add entry #entry to the list.
- When tree = 0, adds to the current list
- When tree != 0, finds the list, corresponding to this tree
- When tree is a chain, the entry is assumed to be global_ index and the local_ entry is recomputed from the treeoffset information of the chain
""" Enter(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})

# Wrapper of bool TEntryList::Enter(Long64_t, const char *, const char *)
@trydoc raw"""
    Enter(this::ByRef1{TEntryList}, localentry::Int64, treename::ByCopy{String}, filename::ByCopy{String})::Bool


""" Enter(this::ByRef1{TEntryList}, localentry::Int64, treename::ByCopy{String}, filename::ByCopy{String})

# Wrapper of void TEntryList::EnterRange(Long64_t, Long64_t, TTree *, UInt_t)
@trydoc raw"""
    EnterRange(this::ByRef1{TEntryList}, thestart::Int64, theend::Int64, tree::ByPtr1{TTree}, step::UInt32)::Nothing
Enter all entries in a range in the [TEntryList](@ref).
## Arguments

- **`thestart`** [in] 
    starting entry to enter. 
    
- **`theend`** [in] 
    ending entry to enter. 
    
- **`tree`** [in] 
    passed as is to [TEntryList!Enter](@ref). 
    
- **`step`** [in] 
    step increase of the loop entering the entries.
    

This is a helper function that enters all entries between `thestart` (inclusive) and `theend` (exclusive) to the [TEntryList](@ref) in a loop. It is useful also in PyROOT to avoid having to do the same in a Python loop.
""" EnterRange(this::ByRef1{TEntryList}, thestart::Int64, theend::Int64, tree::ByPtr1{TTree}, step::UInt32)

# Wrapper of Long64_t TEntryList::GetEntry(Long64_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TEntryList}, index::Int64)::Int64
Return the number of the entry #index of this [TEntryList](@ref) in the [TTree](@ref) or [TChain](@ref) See also [Next()](@ref).

""" GetEntry(this::ByRef1{TEntryList}, index::Int64)

# Wrapper of Long64_t TEntryList::GetEntryAndTree(Long64_t, Int_t &)
@trydoc raw"""
    GetEntryAndTree(this::ByRef1{TEntryList}, index::Int64, treenum::ByRef2{Int32})::Int64
Return the index of "index"-th non-zero entry in the [TTree](@ref) or [TChain](@ref) and the # of the corresponding tree in the chain.

""" GetEntryAndTree(this::ByRef1{TEntryList}, index::Int64, treenum::ByRef2{Int32})

# Wrapper of TEntryList * TEntryList::GetEntryList(const char *, const char *, Option_t *)
@trydoc raw"""
    GetEntryList(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String}, opt::ByCopy{String})::CxxPtr1{TEntryList}
Return the entry list, corresponding to treename and filename By default, the filename is first tried as is, and then, if the corresponding list is not found, the filename is expanded to the absolute path, and compared again.
To avoid it, use option "ne"
""" GetEntryList(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String}, opt::ByCopy{String})

# Wrapper of Int_t TEntryList::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TEntryList}, list::ByPtr1{TCollection})::Int32
Merge this list with the lists from the collection.

""" Merge(this::ByRef1{TEntryList}, list::ByPtr1{TCollection})

# Wrapper of Long64_t TEntryList::Next()
@trydoc raw"""
    Next(this::ByRef1{TEntryList})::Int64
Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than [GetEntry()](@ref)

""" Next(this::ByRef1{TEntryList})

# Wrapper of void TEntryList::OptimizeStorage()
@trydoc raw"""
    OptimizeStorage(this::ByRef1{TEntryList})::Nothing
Checks if the array representation is more economical and if so, switches to it.

""" OptimizeStorage(this::ByRef1{TEntryList})

# Wrapper of Int_t TEntryList::RelocatePaths(const char *, const char *)
@trydoc raw"""
    RelocatePaths(this::ByRef1{TEntryList}, newloc::ByCopy{String}, oldloc::ByCopy{String})::Int32
Relocate the file paths.
If `oldroot` is defined, replace `oldroot` with `newroot` in all file names, i.e. `oldroot/re/st/of/the/path` will become `newroot`/re/st/of/the/path`. If`oldroot`is null, the new path will be just`newroot/path`. Relocation is mandatory to use the entry-list with the same dataset at a different location (i.e. on a different cluster, machine or disks).
""" RelocatePaths(this::ByRef1{TEntryList}, newloc::ByCopy{String}, oldloc::ByCopy{String})

# Wrapper of bool TEntryList::Remove(Long64_t, TTree *)
@trydoc raw"""
    Remove(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})::Bool
Remove entry #entry from the list.
- When tree = 0, removes from the current list
- When tree != 0, finds the list, corresponding to this tree
- When tree is a chain, the entry is assumed to be global_ index and the local_ entry is recomputed from the treeoffset information of the chain
""" Remove(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})

# Wrapper of void TEntryList::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TEntryList})::Nothing
Reset this list.

""" Reset(this::ByRef1{TEntryList})

# Wrapper of Int_t TEntryList::ScanPaths(TList *, bool)
@trydoc raw"""
    ScanPaths(this::ByRef1{TEntryList}, roots::ByPtr1{TList}, notify::Bool)::Int32
Scan the paths to find the common roots.
If 'roots' is defined, add the found roots to the list as TObjStrings. Return the number of roots found.
""" ScanPaths(this::ByRef1{TEntryList}, roots::ByPtr1{TList}, notify::Bool)

# Wrapper of void TEntryList::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TEntryList}, dir::ByPtr1{TDirectory})::Nothing
Add reference to directory dir. dir can be 0.

""" SetDirectory(this::ByRef1{TEntryList}, dir::ByPtr1{TDirectory})

# Wrapper of void TEntryList::SetEntriesToProcess(Long64_t)
@trydoc raw"""
    SetEntriesToProcess(this::ByRef1{TEntryList}, nen::Int64)::Nothing


""" SetEntriesToProcess(this::ByRef1{TEntryList}, nen::Int64)

# Wrapper of void TEntryList::SetFileName(const char *)
@trydoc raw"""
    SetFileName(this::ByRef1{TEntryList}, filename::ByCopy{String})::Nothing


""" SetFileName(this::ByRef1{TEntryList}, filename::ByCopy{String})

# Wrapper of void TEntryList::SetReapplyCut(bool)
@trydoc raw"""
    SetReapplyCut(this::ByRef1{TEntryList}, apply::Bool)::Nothing


""" SetReapplyCut(this::ByRef1{TEntryList}, apply::Bool)

# Wrapper of void TEntryList::SetShift(bool)
@trydoc raw"""
    SetShift(this::ByRef1{TEntryList}, shift::Bool)::Nothing


""" SetShift(this::ByRef1{TEntryList}, shift::Bool)

# Wrapper of void TEntryList::SetTree(const char *, const char *)
@trydoc raw"""
    SetTree(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String})::Nothing
If a list for a tree with such name and filename exists, sets it as the current sublist If not, creates this list and sets it as the current sublist.
! the filename is taken as provided, no extensions to full path or url !
""" SetTree(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String})

# Wrapper of void TEntryList::SetTree(const TTree *)
@trydoc raw"""
    SetTree(this::ByRef1{TEntryList}, tree::ByConstPtr1{TTree})::Nothing
If a list for a tree with such name and filename exists, sets it as the current sublist If not, creates this list and sets it as the current sublist The name of the file, where the tree is, is taken as `tree->GetTree()->GetCurrentFile()->GetName()`, and then expanded either to the absolute path, or to full url.
If, for some reason, you want to provide the filename in a different format, use [SetTree(const char *treename, const char *filename)](@ref), where the filename is taken "as is".
""" SetTree(this::ByRef1{TEntryList}, tree::ByConstPtr1{TTree})

# Wrapper of void TEntryList::SetTreeName(const char *)
@trydoc raw"""
    SetTreeName(this::ByRef1{TEntryList}, treename::ByCopy{String})::Nothing


""" SetTreeName(this::ByRef1{TEntryList}, treename::ByCopy{String})

# Wrapper of void TEntryList::SetTreeNumber(Int_t)
@trydoc raw"""
    SetTreeNumber(this::ByRef1{TEntryList}, index::Int32)::Nothing


""" SetTreeNumber(this::ByRef1{TEntryList}, index::Int32)

# Wrapper of void TEntryList::Subtract(const TEntryList *)
@trydoc raw"""
    Subtract(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})::Nothing
Remove all the entries of this entry list, that are contained in elist.

""" Subtract(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})

# Wrapper of Bool_t TH1::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH1}, h::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this histogram by the addition of h1 and h2.
`this = c1*h1 + c2*h2` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated

Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.

Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number independently of the labels. For adding histogram ith labels one should use [TH1!Merge](@ref)

SPECIAL CASE (Average/Efficiency histograms) For histograms representing averages or efficiencies, one should compute the average of the two histograms and not the sum. One can mark a histogram to be an average histogram by setting its bit kIsAverage with myhist.SetBit(TH1!kIsAverage); Note that the two histograms must have their kIsAverage bit set

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Add](@ref)

IMPORTANT NOTE2: You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c1 is negative, whether [TAxis!kAxisRange](@ref) is true, and whether [TH1!ResetStats](@ref) has been called on either this or h1. See [TH1!GetStats](@ref).

ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0 do a scaling this = c1 * h1 / (bin Volume)

The function returns kFALSE if the Add operation failed
""" Add(this::ByRef1{TH1}, h::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TH1::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: `this = this + c1*h1` If errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.
Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.

Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number independently of the labels. For adding histogram with labels one should use [TH1!Merge](@ref)

SPECIAL CASE (Average/Efficiency histograms) For histograms representing averages or efficiencies, one should compute the average of the two histograms and not the sum. One can mark a histogram to be an average histogram by setting its bit kIsAverage with myhist.SetBit(TH1!kIsAverage); Note that the two histograms must have their kIsAverage bit set

IMPORTANT NOTE1: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Add](@ref)

IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor is used , ie this = this + c1*factor*h1 Use the other [TH1!Add](@ref) function if you do not want this feature

IMPORTANT NOTE3: You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c1 is negative, whether [TAxis!kAxisRange](@ref) is true, and whether [TH1!ResetStats](@ref) has been called on either this or h1. See [TH1!GetStats](@ref).

The function return kFALSE if the Add operation failed
""" Add(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TH1::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TH1}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: `this = this + c1*f1` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.
By default, the function is computed at the centre of the bin. if option "I" is specified (1-d histogram only), the integral of the function in each bin is used instead of the value of the function at the centre of the bin.

Only bins inside the function range are recomputed.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Add](@ref)

The function return kFALSE if the Add operation failed
""" Add(this::ByRef1{TH1}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of void TH1::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1}, bin::Int32)

# Wrapper of void TH1::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1}, bin::Int32, w::Float64)

# Wrapper of void TH1::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TH1}, b::ByPtr1{TBrowser})::Nothing
Browse the Histogram object.

""" Browse(this::ByRef1{TH1}, b::ByPtr1{TBrowser})

# Wrapper of Int_t TH1::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TH1}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is reset and filled from the buffer. When the histogram is filled from the buffer the value fBuffer[0] is set to a negative number (= - number of entries) When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0 While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if the histogram was filled before. This is needed when drawing the histogram
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when filling the histogram and the entries is larger than the buffer size
""" BufferEmpty(this::ByRef1{TH1}, action::Int32)

# Wrapper of void TH1::ClearUnderflowAndOverflow()
@trydoc raw"""
    ClearUnderflowAndOverflow(this::ByRef1{TH1})::Nothing
Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins.

""" ClearUnderflowAndOverflow(this::ByRef1{TH1})

# Wrapper of Double_t TH1::ComputeIntegral(Bool_t)
@trydoc raw"""
    ComputeIntegral(this::ByRef1{TH1}, onlyPositive::Bool)::Float64
Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions.
This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. If the routine is called with the onlyPositive flag set an error will be produced in case of negative bin content and a NaN value returned 

###Return

1 if success, 0 if integral is zero, NAN if onlyPositive-test fails
""" ComputeIntegral(this::ByRef1{TH1}, onlyPositive::Bool)

# Wrapper of void TH1::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TH1}, ::ByPtr1{TDirectory})::Nothing
Perform the automatic addition of the histogram to the given directory.
Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a [TKey](@ref) or being Cloned)
""" DirectoryAutoAdd(this::ByRef1{TH1}, ::ByPtr1{TDirectory})

# Wrapper of Int_t TH1::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TH1}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a line.
Compute the closest distance of approach from point px,py to elements of a histogram. The distance is computed in pixels units.

#### Algorithm:

Currently, this simple model computes the distance from the mouse to the histogram contour only.
""" DistancetoPrimitive(this::ByRef1{TH1}, px::Int32, py::Int32)

# Wrapper of Bool_t TH1::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})::Bool
Divide this histogram by h1.
`this = this/h1` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated. Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. See the other [TH1!Divide](@ref) that gives the possibility to optionally compute binomial errors.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Scale](@ref)

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TH1::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this histogram by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

If errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. However, if option ="B" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Divide](@ref)

Please note also that in the binomial case errors are calculated using standard binomial statistics, which means when b1 = b2, the error is zero. If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must use the function [TGraphAsymmErrors!BayesDivide](@ref), which will return an asymmetric and non-zero lower error for the case b1=b2.

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TH1::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.
Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Divide](@ref)

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TH1::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Draw this histogram with options.
Histograms are drawn via the [THistPainter](@ref) class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use `h->DrawCopy();` This makes a clone of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone. By default, [TH1!Draw](@ref) clears the current pad.

One can use [TH1!SetMaximum](@ref) and [TH1!SetMinimum](@ref) to force a particular value for the maximum or the minimum scale on the plot.

[TH1!UseCurrentStyle](@ref) can be used to change all histogram graphics attributes to correspond to the current selected style. This function must be called for each histogram. In case one reads and draws many histograms from a file, one can force the histograms to inherit automatically the current graphics style by calling before gROOT->ForceStyle();

See the [THistPainter](@ref) class for a description of all the drawing options.
""" Draw(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TH1})::Nothing
Display a panel with all histogram drawing options.
See class TDrawPanelHist for example
""" DrawPanel(this::ByRef1{TH1})

# Wrapper of void TH1::Eval(TF1 *, Option_t *)
@trydoc raw"""
    Eval(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String})::Nothing
Evaluate function f1 at the center of bins of this histogram.
- If option "R" is specified, the function is evaluated only for the bins included in the function range.
- If option "A" is specified, the value of the function is added to the existing bin contents
- If option "S" is specified, the value of the function is used to generate a value, distributed according to the Poisson distribution, with f1 as the mean.
""" Eval(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String})

# Wrapper of void TH1::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TH1}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a histogram is clicked with the locator

If Left button clicked on the bin top value, then the content of this bin is modified according to the new position of the mouse when it is released.
""" ExecuteEvent(this::ByRef1{TH1}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TH1::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Histogram is resized along axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The algorithm works for 1-d, 2-D and 3-D histograms. The axis must be extendable before invoking this function. Ex:

    h->GetXaxis()->SetCanExtend(kTRUE);

(C++ version of the code)
""" ExtendAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of TH1 * TH1::FFT(TH1 *, Option_t *)
@trydoc raw"""
    FFT(this::ByRef1{TH1}, h_output::ByPtr1{TH1}, option::ByCopy{String})::CxxPtr1{TH1}
This function allows to do discrete Fourier transforms of [TH1](@ref) and [TH2](@ref).
Available transform types and flags are described below.

To extract more information about the transform, use the function [TVirtualFFT!GetCurrentTransform()](@ref) to get a pointer to the current transform object.

## Arguments

- **`h_output`** [out] 
    histogram for the output. If a null pointer is passed, a new histogram is created and returned, otherwise, the provided histogram is used and should be big enough 
    
- **`option`** [in] 
    option parameters consists of 3 parts:
    
    - option on what to return
    
        - "RE" - returns a histogram of the real part of the output
        - "IM" - returns a histogram of the imaginary part of the output
        - "MAG"- returns a histogram of the magnitude of the output
        - "PH" - returns a histogram of the phase of the output
    - option of transform type
    
        - "R2C" - real to complex transforms - default
        - "R2HC" - real to halfcomplex (special format of storing output data, results the same as for R2C)
        - "DHT" - discrete Hartley transform real to real transforms (sine and cosine):
        - "R2R_0", "R2R_1", "R2R_2", "R2R_3" - discrete cosine transforms of types I-IV
        - "R2R_4", "R2R_5", "R2R_6", "R2R_7" - discrete sine transforms of types I-IV To specify the type of each dimension of a 2-dimensional real to real transform, use options of form "R2R_XX", for example, "R2R_02" for a transform, which is of type "R2R_0" in 1st dimension and "R2R_2" in the 2nd.
    - option of transform flag
    
        - "ES" (from "estimate") - no time in preparing the transform, but probably sub-optimal performance
        - "M" (from "measure") - some time spend in finding the optimal way to do the transform
        - "P" (from "patient") - more time spend in finding the optimal way to do the transform
        - "EX" (from "exhaustive") - the most optimal way is found This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type. Default is "ES".
    
    
    

Examples of valid options: "Mag R2C M" "Re R2R_11" "Im R2C ES" "PH R2HC EX"
""" FFT(this::ByRef1{TH1}, h_output::ByPtr1{TH1}, option::ByCopy{String})

# Wrapper of Int_t TH1::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1}, name::ByCopy{String}, w::Float64)::Int32
Increment bin with namex with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w.
""" Fill(this::ByRef1{TH1}, name::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH1::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1}, x::Float64)::Int32
Increment bin with abscissa X by 1.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the storage of the sum of squares of weights has been triggered, via the function Sumw2, then the sum of the squares of weights is incremented by 1 in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by 1
""" Fill(this::ByRef1{TH1}, x::Float64)

# Wrapper of Int_t TH1::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1}, x::Float64, w::Float64)::Int32
Increment bin with abscissa X with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w
""" Fill(this::ByRef1{TH1}, x::Float64, w::Float64)

# Wrapper of void TH1::FillN(Int_t, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH1}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill this histogram with an array x and weights w.
## Arguments

- **`ntimes`** [in] 
    number of entries in arrays x and w (array size must be ntimes*stride) 
    
- **`x`** [in] 
    array of values to be histogrammed 
    
- **`w`** [in] 
    array of weighs 
    
- **`stride`** [in] 
    step size through arrays x and w
    

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x. if w is NULL each entry is assumed a weight=1
""" FillN(this::ByRef1{TH1}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of void TH1::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH1}, ::Int32, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::Int32)::Nothing


""" FillN(this::ByRef1{TH1}, ::Int32, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::Int32)

# Wrapper of void TH1::FillRandom(const char *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH1}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in function fname.
## Arguments

- **`fname`** 
    : Function name used for filling the histogram 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used to sample
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents for the bin range of this histogram. It is normalized to 1.

Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

One can also call [TF1!GetRandom](@ref) to get a random variate from a function.
""" FillRandom(this::ByRef1{TH1}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH1::FillRandom(TH1 *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH1}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in histogram h.
## Arguments

- **`h`** 
    : Histogram pointer used for sampling random number 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used for sampling
    

The distribution contained in the histogram h ([TH1](@ref)) is integrated over the channel contents for the bin range of this histogram. It is normalized to 1.

Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

SPECIAL CASE when the target histogram has the same binning as the source. in this case we simply use a poisson distribution where the mean value per bin = bincontent/integral.
""" FillRandom(this::ByRef1{TH1}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of Int_t TH1::FindBin(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindBin(this::ByRef1{TH1}, x::Float64, y::Float64, z::Float64)::Int32
Return Global bin number corresponding to x,y,z.
2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions. This function tries to extend the axis if the given point belongs to an under-/overflow bin AND if [CanExtendAllAxes()](@ref) is true.

See also [TH1!GetBin](@ref), [TAxis!FindBin](@ref) and [TAxis!FindFixBin](@ref)
""" FindBin(this::ByRef1{TH1}, x::Float64, y::Float64, z::Float64)

# Wrapper of TFitResultPtr TH1::Fit(const char *, Option_t *, Option_t *, Double_t, Double_t)
@trydoc raw"""
    Fit(this::ByRef1{TH1}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit histogram with function fname.
fname is the name of a function available in the global_ [ROOT](@ref) list of functions `gROOT->GetListOfFunctions` The list include any [TF1](@ref) object created by the user plus some pre-defined functions which are automatically created by [ROOT](@ref) the first time a pre-defined function is requested from `gROOT` (i.e. when calling `gROOT->GetFunction(const char *name)`). These pre-defined functions are:

- `gaus, gausn` where gausn is the normalized Gaussian
- `landau, landaun`
- `expo`
- `pol1,...9, chebyshev1,...9`.

For printing the list of all available functions do: 
```
  TF1!InitStandardFunctions();   // not needed if `gROOT->GetFunction` is called before
  gROOT->GetListOfFunctions()->ls()
```  `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`, representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`

This function finds a pointer to the [TF1](@ref) object with name `fname` and calls [TH1!Fit(TF1 *, Option_t *, Option_t *,
 Double_t, Double_t)](@ref). See there for the fitting options and the details about fitting histograms
""" Fit(this::ByRef1{TH1}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of TFitResultPtr TH1::Fit(TF1 *, Option_t *, Option_t *, Double_t, Double_t)
@trydoc raw"""
    Fit(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit histogram with the function pointer f1.
## Arguments

- **`f1`** [in] 
    pointer to the function object 
    
- **`option`** [in] 
    string defining the fit options (see table below). 
    
- **`goption`** [in] 
    specify a list of graphics options. See [TH1!Draw](@ref) for a complete list of these options. 
    
- **`xxmin`** [in] 
    lower fitting range 
    
- **`xxmax`** [in] 
    upper fitting range 
    

###Return

A smart pointer to the TFitResult class

### Histogram Fitting Options

Here is the full list of fit options that can be given in the parameter `option`. Several options can be used together by concatanating the strings without the need of any delimiters.

| **option**    | **description**                                                                                                                                                                                                                                 |
|:--------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "L"           | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.                                                                                                                                   |
| "WL"          | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.                                                      |
| "P"           | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.                                                        |
| "MULTI"       | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.                                                                                                |
| "W"           | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.                                                                                                                                                         |
| "WW"          | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.                                                                                                                                                  |
| "I"           | Uses the integral of function in the bin instead of the default bin center value.                                                                                                                                                               |
| "F"           | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.                                                                                                                               |
| "U"           | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter!SetFCN`                                                                                                                          |
| "E"           | Performs a better parameter errors estimation using the Minos technique for all fit parameters.                                                                                                                                                 |
| "M"           | Uses the IMPROVE algorithm (available only in [TMinuit](@ref)). This algorithm attempts improve the found local_ minimum by searching for a better one.                                                                                         |
| "S"           | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT!Math!FitResult`.                                                               |
| "Q"           | Quiet mode (minimum printing)                                                                                                                                                                                                                   |
| "V"           | Verbose mode (default is between Q and V)                                                                                                                                                                                                       |
| "+"           | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.                                                                                                      |
| "N"           | Does not store the graphics function, does not draw the histogram with the function after fitting.                                                                                                                                              |
| "0"           | Does not draw the histogram and the fitted function after fitting, but in contrast to option "N", it stores the fitted function in the histogram list of functions.                                                                             |
| "R"           | Fit using a fitting range specified in the function range with `TF1!SetRange`.                                                                                                                                                                  |
| "B"           | Use this option when you want to fix or set limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used. |
| "C"           | In case of linear fitting, do no calculate the chisquare (saves CPU time).                                                                                                                                                                      |
| "G"           | Uses the gradient implemented in `TF1!GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided [TF1](@ref) function.                                                                |
| "WIDTH"       | Scales the histogran bin content by the bin width (useful for variable bins histograms)                                                                                                                                                         |
| "SERIAL"      | Runs in serial mode. By defult if [ROOT](@ref) is built with MT support and MT is enables, the fit is perfomed in multi-thread - "E" Perform better Errors estimation using Minos technique                                                     |
| "MULTITHREAD" | Forces usage of multi-thread execution whenever possible                                                                                                                                                                                        |

The default fitting of an histogram (when no option is given) is perfomed as following:

- a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);
- the full range of the histogram is used;
- the default Minimizer with its default configuration is used (see below Minimizer [Configuration](@ref)) except for linear function;
- for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.
- only the status of the fit is returned;
- the fit is performed in Multithread whenever is enabled in [ROOT](@ref);
- only the last fitted function is saved in the histogram;
- the histogram is drawn after fitting overalyed with the resulting fitting function

### Minimizer Configuration

The Fit is perfomed using the default Minimizer, defined in the `ROOT!Math!MinimizerOptions` class. It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1!Fit`):

- `ROOT!Math!MinimizerOptions!SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm. For example `ROOT!Math!MinimizerOptions!SetDefaultMinimizer("GSLMultiMin","BFGS");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization The current defaults are ("Minuit","Migrad"). See the documentation of the `ROOT!Math!MinimizerOptions` for the available minimizers in [ROOT](@ref) and their corresponding algorithms.
- `ROOT!Math!MinimizerOptions!SetDefaultTolerance` for setting a different tolerance value for the minimization.
- `ROOT!Math!MinimizerOptions!SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.
- `ROOT!Math!MinimizerOptions!SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing

Other options are possible depending on the Minimizer used, see the corresponding documentation. The default minimizer can be also set in the resource file in etc/system.rootrc. For example

    Root.Fitter:      Minuit2

(C++ version of the code)

### Chi-square Fits

By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1!GetBinError`

``Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }``

where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment of empty bins. When using option "I" the residual is computed not using the function value at the bin center, `f(x(i)|p)`, but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume. When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used. In this case empty bins are considered in the fit. Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics, because they could return a biased result.

### Likelihood Fits

When using option "L" a likelihood fit is used instead of the default chi-square fit. The likelihood is built assuming a Poisson probability density function for each bin. The negative log-likelihood to be minimized is

``NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }``

 where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`. The exact likelihood used is the Poisson likelihood described in this paper: S. Baker and R. D. Cousins, Clarification of the use of chi-square and likelihood functions in fits to histograms, Nucl. Instrum. Meth. 221 (1984) 437.

``NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }``

 By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.

This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ). The likelihood method has the advantage of treating correctly bins with low statistics. In case of high statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit give the same result.

The likelihood method, although a bit slower, it is therefore the recommended method, when the histogram represent counts (Poisson statistics), where the chi-square methods may give incorrect results, especially in case of low statistics. In case of a weighted histogram, it is possible to perform also a likelihood fit by using the option "WL". Note a weighted histogram is a histogram which has been filled with weights and it has the information on the sum of the weight square for each bin ( [TH1!Sumw2()](@ref) has been called). The bin error for a weighted histogram is the square root of the sum of the weight square.

### Fit Result

The function returns a [TFitResultPtr](@ref) which can hold a pointer to a [TFitResult](@ref) object. By default the [TFitResultPtr](@ref) contains only the status of the fit which is return by an automatic conversion of the [TFitResultPtr](@ref) to an integer. One can write in this case directly:

    Int_t fitStatus =  h->Fit(myFunc);

(C++ version of the code)

If the option "S" is instead used, [TFitResultPtr](@ref) behaves as a smart pointer to the [TFitResult](@ref) object. This is useful for retrieving the full result information from the fit, such as the covariance matrix, as shown in this example code:

    TFitResultPtr r = h->Fit(myFunc,"S");
    TMatrixDSym cov = r->GetCovarianceMatrix();  //  to access the covariance matrix
    Double_t chi2   = r->Chi2(); // to retrieve the fit chi2
    Double_t par0   = r->Parameter(0); // retrieve the value for the parameter 0
    Double_t err0   = r->ParError(0); // retrieve the error for the parameter 0
    r->Print("V");     // print full information of fit including covariance matrix
    r->Write();        // store the result in a file

(C++ version of the code)

The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also directly from the fitted function that is passed to this call. Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit parameters with calls such as:

    Double_t chi2 = myfunc->GetChisquare();
    Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter
    Double_t err0 = myfunc->GetParError(0);  //error on first parameter

(C++ version of the code)

##### Associated functions

One or more object ( can be added to the list of functions (fFunctions) associated to each histogram. When [TH1!Fit](@ref) is invoked, the fitted function is added to the histogram list of functions (fFunctions). If the histogram is made persistent, the list of associated functions is also persistent. Given a histogram h, one can retrieve an associated function with:

    TF1 *myfunc = h->GetFunction("myfunc");

(C++ version of the code)

 or by quering directly the list obtained by calling `TH1!GetListOfFunctions`.

### Fit status

The status of the fit is obtained converting the [TFitResultPtr](@ref) to an integer independently if the fit option "S" is used or not:

    TFitResultPtr r = h->Fit(myFunc,opt);
    Int_t fitStatus = r;

(C++ version of the code)

- `status = 0` : the fit has been performed successfully (i.e no error occurred).
- `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.
- `status > 0` : return status from Minimizer, depends on used Minimizer. For example for [TMinuit](@ref) and Minuit2 we have:

    - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`. [TMinuit](@ref) returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of [TMinuit!mnexcm](@ref)). For example, for an error only in Minos but not in Migrad a fitStatus of 40 will be returned. Minuit2 returns 0 in case of success and different values in migrad,minos or hesse depending on the error. See in this case the documentation of Minuit2Minimizer!Minimize for the migrad return status, Minuit2Minimizer!GetMinosError for the minos return status and Minuit2Minimizer!Hesse for the hesse return status. If other minimizers are used see their specific documentation for the status code returned. For example in the case of Fumili, see [TFumili!Minimize](@ref).

### Fitting in a range

In order to fit in a sub-range of the histogram you have two options:

- pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;
- define a specific range in the fitted function and use the fitting option "R". For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian only in the interval 1 to 3, you can do:

    TF1 *f1 = new TF1("f1", "gaus", 1, 3);
    histo->Fit("f1", "R");

(C++ version of the code)

The fitting range is also limited by the histogram range defined using [TAxis!SetRange](@ref) or [TAxis!SetRangeUser](@ref). Therefore the fitting range is the smallest range between the histogram one and the one defined by one of the two previous options described above.

### Setting initial conditions

Parameters must be initialized before invoking the Fit function. The setting of the parameter initial values is automatic for the predefined functions such as poln, expo, gaus, landau. One can however disable this automatic computation by using the option "B". Note that if a predefined function is defined with an argument, eg, gaus(0), expo(1), you must specify the initial values for the parameters. You can specify boundary limits for some or all parameters via

    f1->SetParLimits(p_number, parmin, parmax);

(C++ version of the code)

if `parmin >= parmax`, the parameter is fixed Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do:

    func->SetParameters(0, 3.1, 1.e-6, -8, 0, 100);
    func->SetParLimits(3, -10, -4);
    func->FixParameter(4, 0);
    func->SetParLimits(5, 1, 1);

(C++ version of the code)

With this setup, parameters 0->2 can vary freely Parameter 3 has boundaries [-10,-4] with initial value -8 Parameter 4 is fixed to 0 Parameter 5 is fixed to 100. When the lower limit and upper limit are equal, the parameter is fixed. However to fix a parameter to 0, one must call the FixParameter function.

### Fit Statistics Box

The statistics box can display the result of the fit. You can change the statistics box to display the fit parameters with the TStyle!SetOptFit(mode) method. This mode has four digits. mode = pcev (default = 0111) 
```
v = 1;  print name/values of parameters
e = 1;  print errors (if e=1, v must be 1)
c = 1;  print Chisquare/Number of degrees of freedom
p = 1;  print Probability
```  For example: gStyle->SetOptFit(1011); prints the fit probability, parameter names/values, and errors. You can change the position of the statistics box with these lines (where g is a pointer to the [TGraph](@ref)): 
```
TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject("stats");
st->SetX1NDC(newx1); //new x thestart position
st->SetX2NDC(newx2); //new x theend position
```  

### Additional Notes on Fitting

#### Fitting a histogram of dimension N with a function of dimension N-1

It is possible to fit a [TH2](@ref) with a [TF1](@ref) or a [TH3](@ref) with a [TF2](@ref). In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content. For correct error scaling, the obtained parameter error are corrected as in the case when the option "W" is used.

#### User defined objective functions

By default when fitting a chi square function is used for fitting. When option "L" is used a Poisson likelihood function is used. Using option "MULTI" a multinomial likelihood fit is used. Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they are implemented using the routines FitUtil!EvaluateChi2 or FitUtil!EvaluatePoissonLogL in the file [math/mathcore/src/FitUtil.cxx](@ref). It is possible to specify a user defined fitting function, using option "U" and calling the following functions:

    TVirtualFitter!Fitter(myhist)->SetFCN(MyFittingFunction);

(C++ version of the code)

where MyFittingFunction is of type:

    extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);

(C++ version of the code)

#### Note on treatment of empty bins

Empty bins, which have the content equal to zero AND error equal to zero, are excluded by default from the chi-square fit, but they are considered in the likelihood fit. since they affect the likelihood if the function value in these bins is not negligible. Note that if the histogram is having bins with zero content and non zero-errors they are considered as any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit. In general, one should not fit a histogram with non-empty bins and zero errors.

If the bin errors are not known, one should use the fit option "W", which gives a weight=1 for each bin (it is an unweighted least-square fit). When using option "WW" the empty bins will be also considered in the chi-square fit with an error of 1. Note that in this fitting case (option "W" or "WW") the resulting fitted parameter errors are corrected by the obtained chi2 value using this scaling expression: `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a [TGraph](@ref) with no point errors.

#### Excluding points

You can use [TF1!RejectPoint](@ref) inside your fitting function to exclude some points within a certain range from the fit. See the tutorial `fit/fitExclude.C`.

#### Warning when using the option "0"

When selecting the option "0", the fitted function is added to the list of functions of the histogram, but it is not drawn when the histogram is drawn. You can undo this behaviour resetting its corresponding bit in the [TF1](@ref) object as following:

    h.Fit("myFunction", "0"); // fit, store function but do not draw
    h.Draw(); // function is not drawn
    h.GetFunction("myFunction")->ResetBit(TF1!kNotDraw);
""" Fit(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of void TH1::FitPanel()
@trydoc raw"""
    FitPanel(this::ByRef1{TH1})::Nothing
Display a panel with all histogram fit options.
See class TFitPanel for example
""" FitPanel(this::ByRef1{TH1})

# Wrapper of TH1 * TH1::GetAsymmetry(TH1 *, Double_t, Double_t)
@trydoc raw"""
    GetAsymmetry(this::ByRef1{TH1}, h2::ByPtr1{TH1}, c2::Float64, dc2::Float64)::CxxPtr1{TH1}
Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:
Asymmetry = (h1 - h2)/(h1 + h2)  where h1 = this

(C++ version of the code)

works for 1D, 2D, etc. histograms c2 is an optional argument that gives a relative weight between the two histograms, and dc2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from 2 different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).

example: assuming 'h1' and 'h2' are already filled

    h3 = h1->GetAsymmetry(h2)

(C++ version of the code)

then 'h3' is created and filled with the asymmetry between 'h1' and 'h2'; h1 and h2 are left intact.

Note that it is the user's responsibility to manage the created histogram. The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`

code proposed by Jason Seely ([seely@mit.edu](mailto:seely@mit.edu)) and adapted by R.Brun

clone the histograms so top and bottom will have the correct dimensions: Sumw2 just makes sure the errors will be computed properly when we form sums and ratios below.
""" GetAsymmetry(this::ByRef1{TH1}, h2::ByPtr1{TH1}, c2::Float64, dc2::Float64)

# Wrapper of Int_t TH1::GetContour(Double_t *)
@trydoc raw"""
    GetContour(this::ByRef1{TH1}, levels::ByPtr2{Float64})::Int32
Return contour values into array levels if pointer levels is non zero.
The function returns the number of contour levels. see GetContourLevel to return one contour only
""" GetContour(this::ByRef1{TH1}, levels::ByPtr2{Float64})

# Wrapper of Double_t * TH1::GetIntegral()
@trydoc raw"""
    GetIntegral(this::ByRef1{TH1})::CxxPtr2{Float64}
Return a pointer to the array of bins integral.
if the pointer fIntegral is null, [TH1!ComputeIntegral](@ref) is called The array dimension is the number of bins in the histograms including underflow and overflow (fNCells) the last value integral[fNCells] is set to the number of entries of the histogram
""" GetIntegral(this::ByRef1{TH1})

# Wrapper of TVirtualHistPainter * TH1::GetPainter(Option_t *)
@trydoc raw"""
    GetPainter(this::ByRef1{TH1}, option::ByCopy{String})::CxxPtr1{TVirtualHistPainter}
Return pointer to painter.
If painter does not exist, it is created
""" GetPainter(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of Int_t TH1::GetQuantiles(Int_t, Double_t *, const Double_t *)
@trydoc raw"""
    GetQuantiles(this::ByRef1{TH1}, nprobSum::Int32, q::ByPtr2{Float64}, probSum::ByConstPtr2{Float64})::Int32
Compute Quantiles for this histogram Quantile x_q of a probability distribution Function F is defined as.
F(x_q) = q with 0 <= q <= 1.

(C++ version of the code)

For instance the median x_0.5 of a distribution is defined as that value of the random variable for which the distribution function equals 0.5:

    F(x_0.5) = Probability(x < x_0.5) = 0.5

(C++ version of the code)

code from Eddy Offermann, Renaissance

## Arguments

- **`nprobSum`** [in] 
    maximum size of array q and size of array probSum (if given) 
    
- **`probSum`** [in] 
    array of positions where quantiles will be computed.
    
    - if probSum is null, probSum will be computed internally and will have a size = number of bins + 1 in h. it will correspond to the quantiles calculated at the lowest edge of the histogram (quantile=0) and all the upper edges of the bins.
    - if probSum is not null, it is assumed to contain at least nprobSum values. 
    
    
- **`q`** [out] 
    array q filled with nq quantiles 
    

###Return

value nq (<=nprobSum) with the number of quantiles computed

Note that the Integral of the histogram is automatically recomputed if the number of entries is different of the number of entries when the integral was computed last time. In case you do not use the Fill functions to fill your histogram, but SetBinContent, you must call [TH1!ComputeIntegral](@ref) before calling this function.

Getting quantiles q from two histograms and storing results in a [TGraph](@ref), a so-called QQ-plot

    TGraph *gr = new TGraph(nprob);
    h1->GetQuantiles(nprob,gr->GetX());
    h2->GetQuantiles(nprob,gr->GetY());
    gr->Draw("alp");

(C++ version of the code)

Example:

    void quantiles() {
       // demo for quantiles
       const Int_t nq = 20;
       TH1F *h = new TH1F("h","demo quantiles",100,-3,3);
       h->FillRandom("gaus",5000);
       Double_t xq[nq];  // position where to compute the quantiles in [0,1]
       Double_t yq[nq];  // array to contain the quantiles
       for (Int_t i=0;i<nq;i++) xq[i] = Float_t(i+1)/nq;
       h->GetQuantiles(nq,yq,xq);
       //show the original histogram in the top pad
       TCanvas *c1 = new TCanvas("c1","demo quantiles",10,10,700,900);
       c1->Divide(1,2);
       c1->cd(1);
       h->Draw();
       // show the quantiles in the bottom pad
       c1->cd(2);
       gPad->SetGrid();
       TGraph *gr = new TGraph(nq,xq,yq);
       gr->SetMarkerStyle(21);
       gr->Draw("alp");
    }

(C++ version of the code)
""" GetQuantiles(this::ByRef1{TH1}, nprobSum::Int32, q::ByPtr2{Float64}, probSum::ByConstPtr2{Float64})

# Wrapper of TArrayD * TH1::GetSumw2()
@trydoc raw"""
    GetSumw2(this::ByRef1{TH1})::CxxPtr1{TArrayD}


""" GetSumw2(this::ByRef1{TH1})

# Wrapper of TAxis * TH1::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByRef1{TH1})::CxxPtr1{TAxis}


""" GetXaxis(this::ByRef1{TH1})

# Wrapper of TAxis * TH1::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByRef1{TH1})::CxxPtr1{TAxis}


""" GetYaxis(this::ByRef1{TH1})

# Wrapper of TAxis * TH1::GetZaxis()
@trydoc raw"""
    GetZaxis(this::ByRef1{TH1})::CxxPtr1{TAxis}


""" GetZaxis(this::ByRef1{TH1})

# Wrapper of void TH1::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TH1}, axis::ByCopy{String})::Nothing
Reduce the number of bins for the axis passed in the option to the number of bins having a label.
The method will remove only the extra bins existing after the last "labeled" bin. Note that if there are "un-labeled" bins present between "labeled" bins they will not be removed
""" LabelsDeflate(this::ByRef1{TH1}, axis::ByCopy{String})

# Wrapper of void TH1::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TH1}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram. This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TH1}, axis::ByCopy{String})

# Wrapper of void TH1::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TH1}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Sort bins with labels or set option(s) to draw axis with labels.
## Arguments

- **`option`** [in] 
    - "a" sort by alphabetic order
    - ">" sort by decreasing values
    - "<" sort by increasing values
    - "h" draw labels horizontal
    - "v" draw labels vertical
    - "u" draw labels up (theend of label right adjusted)
    - "d" draw labels down (thestart of label left adjusted)
    
    

In case not all bins have labels sorting will work only in the case the first `n` consecutive bins have all labels and sorting will be performed on those label bins.

## Arguments

- **`ax`** [in] 
    axis
""" LabelsOption(this::ByRef1{TH1}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TH1::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection})::Int64


""" Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection})

# Wrapper of Long64_t TH1::Merge(TCollection *, Option_t *)
@trydoc raw"""
    Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection}, option::ByCopy{String})::Int64
Add all histograms in the collection to this histogram.
This function computes the min/max for the x axis, compute a new number of bins, if necessary, add bin contents, errors and statistics. If all histograms have bin labels, bins with identical labels will be merged, no matter what their order is. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

Possible option: -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check (enabled by default) slows down the merging

IMPORTANT remark. The axis x may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width. Example:

    void atest() {
      TH1F *h1 = new TH1F("h1","h1",110,-110,0);
      TH1F *h2 = new TH1F("h2","h2",220,0,110);
      TH1F *h3 = new TH1F("h3","h3",330,-55,55);
      TRandom r;
      for (Int_t i=0;i<10000;i++) {
         h1->Fill(r.Gaus(-55,10));
         h2->Fill(r.Gaus(55,10));
         h3->Fill(r.Gaus(0,10));
      }
      TList *list = new TList;
      list->Add(h1);
      list->Add(h2);
      list->Add(h3);
      TH1F *h = (TH1F*)h1->Clone("h");
      h->Reset();
      h->Merge(list);
      h->Draw();
    }

(C++ version of the code)
""" Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection}, option::ByCopy{String})

# Wrapper of Bool_t TH1::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})::Bool
Multiply this histogram by h1.
`this = this*h1`

If errors of this are available ([TH1!Sumw2](@ref)), errors are recalculated. Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Multiply](@ref)

The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TH1::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this histogram by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`

If errors of this are available ([TH1!Sumw2](@ref)), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Multiply](@ref)

The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TH1::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation:
`this = this*c1*f1`

If errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.

Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Multiply](@ref)

The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TH1::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Control routine to paint any kind of histograms.
This function is automatically called by [TCanvas!Update](@ref). (see [TH1!Draw](@ref) for the list of options)
""" Paint(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TH1}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TH1}, stats::ByPtr2{Float64})

# Wrapper of TH1 * TH1::Rebin(Int_t, const char *, const Double_t *)
@trydoc raw"""
    Rebin(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})::CxxPtr1{TH1}
Rebin this histogram.
#### case 1 xbins=0

If newname is blank (default), the current histogram is modified and a pointer to it is returned.

If newname is not blank, the current histogram is not modified, and a new histogram is returned which is a Clone of the current histogram with its name set to newname.

The parameter ngroup indicates how many bins of this have to be merged into one bin of the result.

If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

examples: if h1 is an existing [TH1F](@ref) histogram with 100 bins

    h1->Rebin();  //merges two bins in one in h1: previous contents of h1 are lost
    h1->Rebin(5); //merges five bins in one in h1
    TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,"hnew")); // creates a new histogram hnew
                                                           // merging 5 bins of h1 in one bin

(C++ version of the code)

NOTE: If ngroup is not an exact divider of the number of bins, the top limit of the rebinned histogram is reduced to the upper edge of the last bin that can make a complete group. The remaining bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.

#### case 2 xbins!=0

A new histogram is created (you should specify newname). The parameter ngroup is the number of variable size bins in the created histogram. The array xbins must contain ngroup+1 elements that represent the low-edges of the bins. If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

NOTE: The bin edges specified in xbins should correspond to bin edges in the original histogram. If a bin edge in the new histogram is in the middle of a bin in the original histogram, all entries in the split bin in the original histogram will be transfered to the lower of the two possible bins in the new histogram. This is probably not what you want. A warning message is emitted in this case

examples: if h1 is an existing [TH1F](@ref) histogram with 100 bins

    Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin
    h1->Rebin(24,"hnew",xbins);  //creates a new variable bin size histogram hnew

(C++ version of the code)
""" Rebin(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})

# Wrapper of void TH1::RebinAxis(Double_t, TAxis *)
@trydoc raw"""
    RebinAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})::Nothing


""" RebinAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of TH1 * TH1::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH1}


""" RebinX(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TH1::Rebuild(Option_t *)
@trydoc raw"""
    Rebuild(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Using the current bin info, recompute the arrays for contents and errors.

""" Rebuild(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TH1}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from the list of functions.

""" RecursiveRemove(this::ByRef1{TH1}, obj::ByPtr1{TObject})

# Wrapper of void TH1::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.
## Arguments

- **`option`** [in] 
    - if "ICE" is specified, resets only Integral, Contents and Errors.
    - if "ICES" is specified, resets only Integral, Contents, Errors and Statistics This option is used
    - if "M" is specified, resets also Minimum and Maximum
""" Reset(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::ResetStats()
@trydoc raw"""
    ResetStats(this::ByRef1{TH1})::Nothing
Reset the statistics including the number of entries and replace with values calculated from bin content.
The number of entries is set to the total bin content or (in case of weighted histogram) to number of effective entries

Note that, by default, before calling this function, statistics are those computed at fill time, which are unbinned. See [TH1!GetStats](@ref).
""" ResetStats(this::ByRef1{TH1})

# Wrapper of void TH1::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TH1}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this histogram by a constant c1.
`this = c1*this`

Note that both contents and errors (if any) are scaled. This function uses the services of [TH1!Add](@ref)

IMPORTANT NOTE: [Sumw2()](@ref) is called automatically when scaling. If you are not interested in the histogram statistics you can call Sumw2(kFALSE) or use the option "nosw2"

One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1!Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram.

If option contains "width" the bin contents and errors are divided by the bin width.
""" Scale(this::ByRef1{TH1}, c1::Float64, option::ByCopy{String})

# Wrapper of void TH1::SetAxisColor(Color_t, Option_t *)
@trydoc raw"""
    SetAxisColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})::Nothing
Set color to draw the axis line and tick marks.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetAxisColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetAxisRange(Double_t, Double_t, Option_t *)
@trydoc raw"""
    SetAxisRange(this::ByRef1{TH1}, xmin::Float64, xmax::Float64, axis::ByCopy{String})::Nothing
Set the "axis" range.

""" SetAxisRange(this::ByRef1{TH1}, xmin::Float64, xmax::Float64, axis::ByCopy{String})

# Wrapper of void TH1::SetBarOffset(Float_t)
@trydoc raw"""
    SetBarOffset(this::ByRef1{TH1}, offset::Float32)::Nothing
Set the bar offset as fraction of the bin width for drawing mode "B".
This shifts bars to the right on the x axis, and helps to draw bars next to each other. 

###See

THistPainter, SetBarWidth()
""" SetBarOffset(this::ByRef1{TH1}, offset::Float32)

# Wrapper of void TH1::SetBarWidth(Float_t)
@trydoc raw"""
    SetBarWidth(this::ByRef1{TH1}, width::Float32)::Nothing
Set the width of bars as fraction of the bin width for drawing mode "B".
This allows for making bars narrower than the bin width. With [SetBarOffset()](@ref), this helps to draw multiple bars next to each other. 

###See

THistPainter, SetBarOffset()
""" SetBarWidth(this::ByRef1{TH1}, width::Float32)

# Wrapper of void TH1::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH1}, bin::Int32, content::Float64)::Nothing
Set bin content see convention for numbering bins in [TH1!GetBin](@ref) In case the bin number is greater than the number of bins and the timedisplay option is set or [CanExtendAllAxes()](@ref), the number of bins is automatically doubled to accommodate the new bin.

""" SetBinContent(this::ByRef1{TH1}, bin::Int32, content::Float64)

# Wrapper of void TH1::SetBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, content::Float64)

# Wrapper of void TH1::SetBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, ::Int32, content::Float64)

# Wrapper of void TH1::SetBinError(Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH1}, bin::Int32, error::Float64)::Nothing
Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empty bin the bin error is set by default to the square root of their content.
Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent) he needs then to provide also the corresponding bin error (using SetBinError) since the bin error will not be recalculated after setting the content and a default error = 0 will be used for those bins.

See convention for numbering bins in [TH1!GetBin](@ref)
""" SetBinError(this::ByRef1{TH1}, bin::Int32, error::Float64)

# Wrapper of void TH1::SetBinError(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, error::Float64)::Nothing
See convention for numbering bins in [TH1!GetBin](@ref).
""" SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, error::Float64)

# Wrapper of void TH1::SetBinError(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, binz::Int32, error::Float64)::Nothing
See convention for numbering bins in [TH1!GetBin](@ref).
""" SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, binz::Int32, error::Float64)

# Wrapper of void TH1::SetBins(Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64})::Nothing
Redefine x axis parameters with variable bin sizes.
The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref) xBins is supposed to be of length nx+1
""" SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64})

# Wrapper of void TH1::SetBins(Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})::Nothing
Redefine x and y axis parameters with variable bin sizes.
The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref) xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1
""" SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})

# Wrapper of void TH1::SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})::Nothing
Redefine x, y and z axis parameters with variable bin sizes.
The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref) xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1
""" SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})

# Wrapper of void TH1::SetBins(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64)::Nothing
Redefine x axis parameters.
The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref)
""" SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64)

# Wrapper of void TH1::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)::Nothing
Redefine x and y axis parameters.
The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref)
""" SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)

# Wrapper of void TH1::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)::Nothing
Redefine x, y and z axis parameters.
The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref)
""" SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)

# Wrapper of void TH1::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1}, ::Int32)::Nothing


""" SetBinsLength(this::ByRef1{TH1}, ::Int32)

# Wrapper of void TH1::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TH1}, buffersize::Int32, option::ByCopy{String})::Nothing
Set the maximum number of entries to be kept in the buffer.

""" SetBuffer(this::ByRef1{TH1}, buffersize::Int32, option::ByCopy{String})

# Wrapper of UInt_t TH1::SetCanExtend(UInt_t)
@trydoc raw"""
    SetCanExtend(this::ByRef1{TH1}, extendBitMask::UInt32)::UInt32
Make the histogram axes extendable / not extendable according to the bit mask returns the previous bit mask specifying which axes are extendable.

""" SetCanExtend(this::ByRef1{TH1}, extendBitMask::UInt32)

# Wrapper of void TH1::SetCellContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetCellContent(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)::Nothing


""" SetCellContent(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)

# Wrapper of void TH1::SetCellError(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetCellError(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)::Nothing


""" SetCellError(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)

# Wrapper of void TH1::SetContent(const Double_t *)
@trydoc raw"""
    SetContent(this::ByRef1{TH1}, content::ByConstPtr2{Float64})::Nothing
Replace bin contents by the contents of array content.

""" SetContent(this::ByRef1{TH1}, content::ByConstPtr2{Float64})

# Wrapper of void TH1::SetContour(Int_t, const Double_t *)
@trydoc raw"""
    SetContour(this::ByRef1{TH1}, nlevels::Int32, levels::ByConstPtr2{Float64})::Nothing
Set the number and values of contour levels.
By default the number of contour levels is set to 20. The contours values in the array "levels" should be specified in increasing order.

if argument levels = 0 or missing, equidistant contours are computed
""" SetContour(this::ByRef1{TH1}, nlevels::Int32, levels::ByConstPtr2{Float64})

# Wrapper of void TH1::SetContourLevel(Int_t, Double_t)
@trydoc raw"""
    SetContourLevel(this::ByRef1{TH1}, level::Int32, value::Float64)::Nothing
Set value for one contour level.

""" SetContourLevel(this::ByRef1{TH1}, level::Int32, value::Float64)

# Wrapper of void TH1::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TH1}, dir::ByPtr1{TDirectory})::Nothing
By default, when a histogram is created, it is added to the list of histogram objects in the current directory in memory.
Remove reference to this histogram from current directory and add reference to new directory dir. dir can be 0 in which case the histogram does not belong to any directory.

Note that the directory is not a real property of the histogram and it will not be copied when the histogram is copied or cloned. If the user wants to have the copied (cloned) histogram in the same directory, he needs to set again the directory using SetDirectory to the copied histograms
""" SetDirectory(this::ByRef1{TH1}, dir::ByPtr1{TDirectory})

# Wrapper of void TH1::SetEntries(Double_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TH1}, n::Float64)::Nothing


""" SetEntries(this::ByRef1{TH1}, n::Float64)

# Wrapper of void TH1::SetError(const Double_t *)
@trydoc raw"""
    SetError(this::ByRef1{TH1}, error::ByConstPtr2{Float64})::Nothing
Replace bin errors by values in array error.

""" SetError(this::ByRef1{TH1}, error::ByConstPtr2{Float64})

# Wrapper of void TH1::SetHighlight(Bool_t)
@trydoc raw"""
    SetHighlight(this::ByRef1{TH1}, set::Bool)::Nothing
Set highlight (enable/disable) mode for the histogram by default highlight mode is disable.

""" SetHighlight(this::ByRef1{TH1}, set::Bool)

# Wrapper of void TH1::SetLabelColor(Color_t, Option_t *)
@trydoc raw"""
    SetLabelColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})::Nothing
Set axis labels color.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetLabelFont(Style_t, Option_t *)
@trydoc raw"""
    SetLabelFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})::Nothing
Set font number used to draw axis labels.
font : Text font code = 10*fontnumber + precision Font numbers must be between 1 and 14 precision = 1 fast hardware fonts (steps in the size) precision = 2 scalable and rotatable hardware fonts

The default font number is 62. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetLabelOffset(Float_t, Option_t *)
@trydoc raw"""
    SetLabelOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})::Nothing
Set offset between axis and axis' labels.
The offset is expressed as a percent of the pad height. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetLabelSize(Float_t, Option_t *)
@trydoc raw"""
    SetLabelSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})::Nothing
Set size of axis' labels.
The size is expressed as a percent of the pad height. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TH1}, maximum::Float64)::Nothing


""" SetMaximum(this::ByRef1{TH1}, maximum::Float64)

# Wrapper of void TH1::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TH1}, minimum::Float64)::Nothing


""" SetMinimum(this::ByRef1{TH1}, minimum::Float64)

# Wrapper of void TH1::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TH1}, name::ByCopy{String})::Nothing
Change the name of this histogram.

""" SetName(this::ByRef1{TH1}, name::ByCopy{String})

# Wrapper of void TH1::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TH1}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Change the name and title of this histogram.

""" SetNameTitle(this::ByRef1{TH1}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TH1::SetNdivisions(Int_t, Option_t *)
@trydoc raw"""
    SetNdivisions(this::ByRef1{TH1}, n::Int32, axis::ByCopy{String})::Nothing
Set the number of divisions to draw an axis.
ndiv : Number of divisions. 
```
 n = N1 + 100*N2 + 10000*N3
 N1=number of primary divisions.
 N2=number of secondary divisions.
 N3=number of 3rd divisions.
     e.g.:
     nndi=0 --> no tick marks.
     nndi=2 --> 2 divisions, one tick mark in the middle
                of the axis.
```  axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetNdivisions(this::ByRef1{TH1}, n::Int32, axis::ByCopy{String})

# Wrapper of void TH1::SetNormFactor(Double_t)
@trydoc raw"""
    SetNormFactor(this::ByRef1{TH1}, factor::Float64)::Nothing


""" SetNormFactor(this::ByRef1{TH1}, factor::Float64)

# Wrapper of void TH1::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TH1}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::SetStats(Bool_t)
@trydoc raw"""
    SetStats(this::ByRef1{TH1}, stats::Bool)::Nothing
Set statistics option on/off.
By default, the statistics box is drawn. The paint options can be selected via gStyle->SetOptStat. This function sets/resets the kNoStats bit in the histogram object. It has priority over the Style option.
""" SetStats(this::ByRef1{TH1}, stats::Bool)

# Wrapper of void TH1::SetTickLength(Float_t, Option_t *)
@trydoc raw"""
    SetTickLength(this::ByRef1{TH1}, length::Float32, axis::ByCopy{String})::Nothing
Set the axis' tick marks length.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetTickLength(this::ByRef1{TH1}, length::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing
Change/set the title.
If title is in the form `stringt;stringx;stringy;stringz` the histogram title is set to `stringt`, the x axis title to `stringx`, the y axis title to `stringy`, and the z axis title to `stringz`.

To insert the character `;` in one of the titles, one should use `#;` or `#semicolon`.
""" SetTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of void TH1::SetTitleFont(Style_t, Option_t *)
@trydoc raw"""
    SetTitleFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})::Nothing
Set the axis' title font.
- if axis =="x" set the X axis title font
- if axis =="y" set the Y axis title font
- if axis =="z" set the Z axis title font any other value of axis will set the pad title font

if axis="xyz" set all 3 axes
""" SetTitleFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetTitleOffset(Float_t, Option_t *)
@trydoc raw"""
    SetTitleOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})::Nothing
Specify a parameter offset to control the distance between the axis and the axis' title.
- offset = 1 means : use the default distance
- offset = 1.2 means: the distance will be 1.2*(default distance)
- offset = 0.8 means: the distance will be 0.8*(default distance)

axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetTitleOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetTitleSize(Float_t, Option_t *)
@trydoc raw"""
    SetTitleSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})::Nothing
Set the axis' title size.
- if axis = "x" set the X axis title size
- if axis = "y" set the Y axis title size
- if axis = "z" set the Z axis title size

if axis ="xyz" set all 3 axes
""" SetTitleSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetXTitle(const char *)
@trydoc raw"""
    SetXTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing


""" SetXTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of void TH1::SetYTitle(const char *)
@trydoc raw"""
    SetYTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing


""" SetYTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of void TH1::SetZTitle(const char *)
@trydoc raw"""
    SetZTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing


""" SetZTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of TH1 * TH1::ShowBackground(Int_t, Option_t *)
@trydoc raw"""
    ShowBackground(this::ByRef1{TH1}, niter::Int32, option::ByCopy{String})::CxxPtr1{TH1}
This function calculates the background spectrum in this histogram.
The background is returned as a histogram.

## Arguments

- **`niter`** [in] 
    number of iterations (default value = 2) Increasing niter make the result smoother and lower. 
    
- **`option`** [in] 
    may contain one of the following options
    
    - to set the direction parameter "BackDecreasingWindow". By default the direction is BackIncreasingWindow
    - filterOrder-order of clipping filter (default "BackOrder2") possible values= "BackOrder4" "BackOrder6" "BackOrder8"
    - "nosmoothing" - if selected, the background is not smoothed By default the background is smoothed.
    - smoothWindow - width of smoothing window, (default is "BackSmoothing3") possible values= "BackSmoothing5" "BackSmoothing7" "BackSmoothing9" "BackSmoothing11" "BackSmoothing13" "BackSmoothing15"
    - "nocompton" - if selected the estimation of Compton edge will be not be included (by default the compton estimation is set)
    - "same" if this option is specified, the resulting background histogram is superimposed on the picture in the current pad. This option is given by default.
    
    

NOTE that the background is only evaluated in the current range of this histogram. i.e., if this has a bin range (set via h->[GetXaxis()](@ref)->SetRange(binmin, binmax), the returned histogram will be created with the same number of bins as this input histogram, but only bins from binmin to binmax will be filled with the estimated background.
""" ShowBackground(this::ByRef1{TH1}, niter::Int32, option::ByCopy{String})

# Wrapper of Int_t TH1::ShowPeaks(Double_t, Option_t *, Double_t)
@trydoc raw"""
    ShowPeaks(this::ByRef1{TH1}, sigma::Float64, option::ByCopy{String}, threshold::Float64)::Int32
Interface to [TSpectrum!Search](@ref).
The function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. For more details see [TSpectrum!Search](@ref). Note the difference in the default value for option compared to [TSpectrum!Search](@ref) option="" by default (instead of "goff").
""" ShowPeaks(this::ByRef1{TH1}, sigma::Float64, option::ByCopy{String}, threshold::Float64)

# Wrapper of void TH1::Smooth(Int_t, Option_t *)
@trydoc raw"""
    Smooth(this::ByRef1{TH1}, ntimes::Int32, option::ByCopy{String})::Nothing
Smooth bin contents of this histogram.
if option contains "R" smoothing is applied only to the bins defined in the X axis range (default is to smooth all bins) Bin contents are replaced by their smooth values. Errors (if any) are not modified. the smoothing procedure is repeated ntimes (default=1)
""" Smooth(this::ByRef1{TH1}, ntimes::Int32, option::ByCopy{String})

# Wrapper of void TH1::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TH1}, flag::Bool)::Nothing
Create structure to store sum of squares of weights.
if histogram is already filled, the sum of squares of weights is filled with the existing bin contents

The error per bin will be computed as sqrt(sum of squares of weight) for each bin.

This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag = false the structure containing the sum of the square of weights is rest and it will be empty, but it is not deleted (i.e. [GetSumw2()](@ref)->fN = 0)
""" Sumw2(this::ByRef1{TH1}, flag::Bool)

# Wrapper of void TH1::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TH1})::Nothing
Copy current attributes from/to current style.

""" UseCurrentStyle(this::ByRef1{TH1})

# Wrapper of void TH1F::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1F}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1F}, bin::Int32)

# Wrapper of void TH1F::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1F}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
###Warning

The value of w is cast to Float_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1F}, bin::Int32, w::Float64)

# Wrapper of TH1F & TH1F::operator=(const TH1F &)
@trydoc raw"""
    assign(this::ByRef1{TH1F}, h1::ByConstRef1{TH1F})::CxxRef1{TH1F}
Operator =.

""" assign(this::ByRef1{TH1F}, h1::ByConstRef1{TH1F})

# Wrapper of void TH1F::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1F}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1F}, option::ByCopy{String})

# Wrapper of void TH1F::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1F}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1F}, n::Int32)

# Wrapper of void TPrincipal::AddRow(const Double_t *)
@trydoc raw"""
    AddRow(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64})::Nothing
Add a data point and update the covariance matrix.
The input array must be `fNumberOfVariables` long.

The Covariance matrix and mean values of the input data is calculated on the fly by the following equations:

``\left<x_i\right>^{(0)}  = x_{i0}``

``\left<x_i\right>^{(n)} = \left<x_i\right>^{(n-1)}
+ \frac1n \left(x_{in} - \left<x_i\right>^{(n-1)}\right)``

``C_{ij}^{(0)} = 0``

``C_{ij}^{(n)} = C_{ij}^{(n-1)}
+ \frac1{n-1}\left[\left(x_{in} - \left<x_i\right>^{(n)}\right)
  \left(x_{jn} - \left<x_j\right>^{(n)}\right)\right]
- \frac1n C_{ij}^{(n-1)}``

since this is a really fast method, with no rounding errors (please refer to CERN 72-21 pp. 54-106).

The data is stored internally in a `TVectorD`, in the following way:

``\mathbf{x} = \left[\left(x_{0_0},\ldots,x_{{P-1}_0}\right),\ldots,
    \left(x_{0_i},\ldots,x_{{P-1}_i}\right), \ldots\right]``

With $P$ as defined in the class description.
""" AddRow(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64})

# Wrapper of void TPrincipal::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TPrincipal}, b::ByPtr1{TBrowser})::Nothing
Browse the [TPrincipal](@ref) object in the [TBrowser](@ref).

""" Browse(this::ByRef1{TPrincipal}, b::ByPtr1{TBrowser})

# Wrapper of void TPrincipal::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TPrincipal}, option::ByCopy{String})::Nothing
Clear the data in Object.
Notice, that's not possible to change the dimension of the original data.
""" Clear(this::ByRef1{TPrincipal}, option::ByCopy{String})

# Wrapper of const Double_t * TPrincipal::GetRow(Long64_t)
@trydoc raw"""
    GetRow(this::ByRef1{TPrincipal}, row::Int64)::ConstCxxPtr2{Float64}
Return a row of the user supplied data.
If row is out of bounds, 0 is returned. It's up to the user to delete the returned array. Row 0 is the first row;
""" GetRow(this::ByRef1{TPrincipal}, row::Int64)

# Wrapper of void TPrincipal::MakeCode(const char *, Option_t *)
@trydoc raw"""
    MakeCode(this::ByRef1{TPrincipal}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Generates the file `<filename>`, with `.C` appended if it does argument doesn't theend in .cxx or .C.
The file contains the implementation of two functions 

    void X2P(Double_t *x, Double *p)
    void P2X(Double_t *p, Double *x, Int_t nTest)

(C++ version of the code)

 which does the same as `TPrincipal!X2P` and `TPrincipal!P2X` respectively. Please refer to these methods.

Further, the static variables: 

    Int_t    gNVariables
    Double_t gEigenValues[]
    Double_t gEigenVectors[]
    Double_t gMeanValues[]
    Double_t gSigmaValues[]

(C++ version of the code)

 are initialized. The only [ROOT](@ref) header file needed is Rtypes.h

See [TPrincipal!MakeRealCode](@ref) for a list of options
""" MakeCode(this::ByRef1{TPrincipal}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TPrincipal::MakeHistograms(const char *, Option_t *)
@trydoc raw"""
    MakeHistograms(this::ByRef1{TPrincipal}, name::ByCopy{String}, option::ByCopy{String})::Nothing
Make histograms of the result of the analysis.
The option string say which histograms to create

- X Histogram original data
- P Histogram principal components corresponding to original data
- D Histogram the difference between the original data and the projection of principal unto a lower dimensional subspace (2D histograms)
- E Histogram the eigenvalues
- S Histogram the square of the residues (see `TPrincipal!SumOfSquareResiduals`) The histograms will be named `<name>_<type><number>`, where `<name>` is the first argument, `<type>` is one of X,P,D,E,S, and `<number>` is the variable.
""" MakeHistograms(this::ByRef1{TPrincipal}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TPrincipal::MakeMethods(const char *, Option_t *)
@trydoc raw"""
    MakeMethods(this::ByRef1{TPrincipal}, classname::ByCopy{String}, option::ByCopy{String})::Nothing
Generate the file `<classname>PCA.cxx` which contains the implementation of two methods:
void <classname>!X2P(Double_t *x, Double *p)
    void <classname>!P2X(Double_t *p, Double *x, Int_t nTest)

(C++ version of the code)

 which does the same as [TPrincipal!X2P](@ref) and [TPrincipal!P2X](@ref) respectively. Please refer to these methods.

Further, the public static members: 

    Int_t    <classname>!fgNVariables
    Double_t <classname>!fgEigenValues[]
    Double_t <classname>!fgEigenVectors[]
    Double_t <classname>!fgMeanValues[]
    Double_t <classname>!fgSigmaValues[]

(C++ version of the code)

 are initialized, and assumed to exist. The class declaration is assumed to be in `<classname>.h` and assumed to be provided by the user.

See [TPrincipal!MakeRealCode](@ref) for a list of options

The minimal class definition is: 

    class <classname> {
    public:
      static Int_t    fgNVariables;
      static Double_t fgEigenVectors[];
      static Double_t fgEigenValues[];
      static Double_t fgMeanValues[];
      static Double_t fgSigmaValues[];
      void X2P(Double_t *x, Double_t *p);
      void P2X(Double_t *p, Double_t *x, Int_t nTest);
    };

(C++ version of the code)

 Whether the methods `<classname>!X2P` and `<classname>!P2X` should be static or not, is up to the user.
""" MakeMethods(this::ByRef1{TPrincipal}, classname::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TPrincipal::MakePrincipals()
@trydoc raw"""
    MakePrincipals(this::ByRef1{TPrincipal})::Nothing
Perform the principal components analysis.
This is done in several stages in the [TMatrix!EigenVectors](@ref) method:

- Transform the covariance matrix into a tridiagonal matrix.
- Find the eigenvalues and vectors of the tridiagonal matrix.
""" MakePrincipals(this::ByRef1{TPrincipal})

# Wrapper of void TPrincipal::P2X(const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    P2X(this::ByRef1{TPrincipal}, p::ByConstPtr2{Float64}, x::ByPtr2{Float64}, nTest::Int32)::Nothing
Calculate x as a function of nTest of the most significant principal components p, and return it in x.
It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for x).
""" P2X(this::ByRef1{TPrincipal}, p::ByConstPtr2{Float64}, x::ByPtr2{Float64}, nTest::Int32)

# Wrapper of void TPrincipal::SumOfSquareResiduals(const Double_t *, Double_t *)
@trydoc raw"""
    SumOfSquareResiduals(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, s::ByPtr2{Float64})::Nothing
Calculates the sum of the square residuals, that is.
``E_N = \sum_{i=0}^{P-1} \left(x_i - x^\prime_i\right)^2``

where $x^\prime_i = \sum_{j=i}^N p_i e_{n_j}$ is the $i^{\mbox{th}}$ component of the principal vector, corresponding to $x_i$, the original data; I.e., the square distance to the space spanned by $N$ eigenvectors.
""" SumOfSquareResiduals(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, s::ByPtr2{Float64})

# Wrapper of void TPrincipal::Test(Option_t *)
@trydoc raw"""
    Test(this::ByRef1{TPrincipal}, option::ByCopy{String})::Nothing
Test the PCA, bye calculating the sum square of residuals (see method SumOfSquareResiduals), and display the histogram.

""" Test(this::ByRef1{TPrincipal}, option::ByCopy{String})

# Wrapper of void TPrincipal::X2P(const Double_t *, Double_t *)
@trydoc raw"""
    X2P(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, p::ByPtr2{Float64})::Nothing
Calculate the principal components from the original data vector x, and return it in p.
It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for p).
""" X2P(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, p::ByPtr2{Float64})

# Wrapper of TObject * TTreeFriendLeafIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TTreeFriendLeafIter})::CxxPtr1{TObject}
Go the next friend element.

""" Next(this::ByRef1{TTreeFriendLeafIter})

# Wrapper of TIterator & TTreeFriendLeafIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator. Does NOT copy the 'cursor' location!

""" assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TTreeFriendLeafIter & TTreeFriendLeafIter::operator=(const TTreeFriendLeafIter &)
@trydoc raw"""
    assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TTreeFriendLeafIter})::CxxRef1{TTreeFriendLeafIter}
Overridden assignment operator. Does NOT copy the 'cursor' location!

""" assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TTreeFriendLeafIter})

# Wrapper of void TTreeFriendLeafIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TTreeFriendLeafIter})::Nothing


""" Reset(this::ByRef1{TTreeFriendLeafIter})

# Wrapper of void TLeafB::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafB}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to a ClonesArray.

""" Export(this::ByRef1{TLeafB}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafB::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafB}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements into Basket output buffer.

""" FillBasket(this::ByRef1{TLeafB}, b::ByRef1{TBuffer})

# Wrapper of void TLeafB::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafB}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafB}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafB::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafB}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafB}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafB::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafB}, ::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafB}, ::ByRef1{TBuffer})

# Wrapper of void TLeafB::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafB}, ::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafB}, ::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafB::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafB}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketFast(this::ByRef1{TLeafB}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafB::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafB}, addr::ByPtr2{Nothing})::Nothing
Set value buffer address.

""" SetAddress(this::ByRef1{TLeafB}, addr::ByPtr2{Nothing})

# Wrapper of void TLeafB::SetMaximum(Char_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafB}, max::Int8)::Nothing


""" SetMaximum(this::ByRef1{TLeafB}, max::Int8)

# Wrapper of void TLeafB::SetMinimum(Char_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafB}, min::Int8)::Nothing


""" SetMinimum(this::ByRef1{TLeafB}, min::Int8)

# Wrapper of void TLeafC::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafC}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafC}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafC::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafC}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafC}, b::ByRef1{TBuffer})

# Wrapper of void TLeafC::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafC}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafC}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafC::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafC}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafC}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafC::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafC}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafC}, b::ByRef1{TBuffer})

# Wrapper of void TLeafC::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafC}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafC}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafC::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafC}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafC}, add::ByPtr2{Nothing})

# Wrapper of void TLeafC::SetMaximum(Int_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafC}, max::Int32)::Nothing


""" SetMaximum(this::ByRef1{TLeafC}, max::Int32)

# Wrapper of void TLeafC::SetMinimum(Int_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafC}, min::Int32)::Nothing


""" SetMinimum(this::ByRef1{TLeafC}, min::Int32)

# Wrapper of void TLeafD::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafD}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafD}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafD::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafD}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafD}, b::ByRef1{TBuffer})

# Wrapper of void TLeafD::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafD}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafD}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafD::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafD}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafD}, b::ByRef1{TBuffer})

# Wrapper of void TLeafD::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafD}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafD}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafD::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafD}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketFast(this::ByRef1{TLeafD}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafD::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafD}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafD}, add::ByPtr2{Nothing})

# Wrapper of void TLeafD32::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafD32}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafD32}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafD32::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafD32}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafD32}, b::ByRef1{TBuffer})

# Wrapper of void TLeafD32::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafD32}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafD32}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafD32::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafD32}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafD32}, b::ByRef1{TBuffer})

# Wrapper of void TLeafD32::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafD32}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafD32}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafD32::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafD32}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafD32}, add::ByPtr2{Nothing})

# Wrapper of void TBranchElement::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TBranchElement}, b::ByPtr1{TBrowser})::Nothing
Browse the branch content.

""" Browse(this::ByRef1{TBranchElement}, b::ByPtr1{TBrowser})

# Wrapper of TBranch * TBranchElement::FindBranch(const char *)
@trydoc raw"""
    FindBranch(this::ByRef1{TBranchElement}, name::ByCopy{String})::CxxPtr1{TBranch}
Find the immediate sub-branch with passed name.

""" FindBranch(this::ByRef1{TBranchElement}, name::ByCopy{String})

# Wrapper of TLeaf * TBranchElement::FindLeaf(const char *)
@trydoc raw"""
    FindLeaf(this::ByRef1{TBranchElement}, name::ByCopy{String})::CxxPtr1{TLeaf}
Find the leaf corresponding to the name 'searchname'.

""" FindLeaf(this::ByRef1{TBranchElement}, name::ByCopy{String})

# Wrapper of UInt_t TBranchElement::GetCheckSum()
@trydoc raw"""
    GetCheckSum(this::ByRef1{TBranchElement})::UInt32


""" GetCheckSum(this::ByRef1{TBranchElement})

# Wrapper of Int_t TBranchElement::GetClassVersion()
@trydoc raw"""
    GetClassVersion(this::ByRef1{TBranchElement})::Int32


""" GetClassVersion(this::ByRef1{TBranchElement})

# Wrapper of TVirtualCollectionProxy * TBranchElement::GetCollectionProxy()
@trydoc raw"""
    GetCollectionProxy(this::ByRef1{TBranchElement})::CxxPtr1{TVirtualCollectionProxy}
Return the collection proxy describing the branch content, if any.

""" GetCollectionProxy(this::ByRef1{TBranchElement})

# Wrapper of TClass * TBranchElement::GetCurrentClass()
@trydoc raw"""
    GetCurrentClass(this::ByRef1{TBranchElement})::CxxPtr1{TClass}
Return a pointer to the current type of the data member corresponding to branch element.

""" GetCurrentClass(this::ByRef1{TBranchElement})

# Wrapper of Int_t TBranchElement::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TBranchElement}, entry::Int64, getall::Int32)::Int32
Read all branches of a BranchElement and return total number of bytes.
- If entry = 0, then use current entry number + 1.
- If entry < 0, then reset entry number to 0.

Returns the number of bytes read from the input buffer.

- If entry does not exist, then returns 0.
- If an I/O error occurs, then returns -1.

See IMPORTANT REMARKS in [TTree!GetEntry](@ref).
""" GetEntry(this::ByRef1{TBranchElement}, entry::Int64, getall::Int32)

# Wrapper of Int_t TBranchElement::GetExpectedType(TClass *&, EDataType &)
@trydoc raw"""
    GetExpectedType(this::ByRef1{TBranchElement}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})::Int32
Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure.

""" GetExpectedType(this::ByRef1{TBranchElement}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})

# Wrapper of TClass * TBranchElement::GetTargetClass()
@trydoc raw"""
    GetTargetClass(this::ByRef1{TBranchElement})::CxxPtr1{TClass}


""" GetTargetClass(this::ByRef1{TBranchElement})

# Wrapper of bool TBranchElement::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TBranchElement})::Bool
This method must be overridden to handle object notification (the base implementation is no-op).
Different objects in [ROOT](@ref) use the `Notify` method for different purposes, in coordination with other objects that call this method at the appropriate time.

For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a callback mechanism to inform interested parties when it switches to a new sub-tree.
""" Notify(this::ByRef1{TBranchElement})

# Wrapper of void TBranchElement::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TBranchElement}, option::ByCopy{String})::Nothing
Reset a Branch.
Existing i/o buffers are deleted. Entries, max and min are reset.
""" Reset(this::ByRef1{TBranchElement}, option::ByCopy{String})

# Wrapper of void TBranchElement::ResetAddress()
@trydoc raw"""
    ResetAddress(this::ByRef1{TBranchElement})::Nothing
Set branch address to zero and free all allocated memory.

""" ResetAddress(this::ByRef1{TBranchElement})

# Wrapper of void TBranchElement::ResetDeleteObject()
@trydoc raw"""
    ResetDeleteObject(this::ByRef1{TBranchElement})::Nothing
Release ownership of any allocated objects.
Note: This interface was added so that clone trees could be told they do not own the allocated objects.
""" ResetDeleteObject(this::ByRef1{TBranchElement})

# Wrapper of void TBranchElement::ResetInitInfo(bool)
@trydoc raw"""
    ResetInitInfo(this::ByRef1{TBranchElement}, recurse::Bool)::Nothing
Reset offset and StreamerInfo information from this branch.
## Arguments

- **`recurse`** [in] 
    When true call ResetInitInfo on all subbranches.
""" ResetInitInfo(this::ByRef1{TBranchElement}, recurse::Bool)

# Wrapper of void TBranchElement::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TBranchElement}, addobj::ByPtr2{Nothing})::Nothing
Point this branch at an object.
For a sub-branch, addr is a pointer to the branch object.

For a top-level branch the meaning of addr is as follows:

If addr is zero, then we allocate a branch object internally and the branch is the owner of the allocated object, not the caller. However the caller may obtain a pointer to the branch object with [GetObject()](@ref). The pointer is reset to zero (nullptr) when the relevant branch object is destroyed.

Example: 

    branch->SetAddress(0);
    Event* event = branch->GetObject();
    ... Do some work.

(C++ version of the code)

 If addr is not zero, but the pointer addr points at is zero, then we allocate a branch object and set the passed pointer to point at the allocated object. The caller owns the allocated object and is responsible for deleting it when it is no longer needed.

Example: 

    Event* event = 0;
    branch->SetAddress(&event);
    ... Do some work.
    delete event;
    event = 0;

(C++ version of the code)

 If addr is not zero and the pointer addr points at is also not zero, then the caller has allocated a branch object and is asking us to use it. The caller owns it and must delete it when it is no longer needed.

Example: 

    Event* event = new Event();
    branch->SetAddress(&event);
    ... Do some work.
    delete event;
    event = 0;

(C++ version of the code)

 These rules affect users of [TTree!Branch()](@ref), [TTree!SetBranchAddress()](@ref), and [TChain!SetBranchAddress()](@ref) as well because those routines call this one.

An example of a tree with branches with objects allocated and owned by us: 

    TFile* f1 = new TFile("myfile_original.root");
    TTree* t1 = (TTree*) f->Get("MyTree");
    TFile* f2 = new TFile("myfile_copy.root", "recreate");
    TTree* t2 = t1->Clone(0);
    for (Int_t i = 0; i < 10; ++i) {
       t1->GetEntry(i);
       t2->Fill();
    }
    t2->Write()
    delete f2;
    f2 = 0;
    delete f1;
    f1 = 0;

(C++ version of the code)

 An example of a branch with an object allocated by us, but owned by the caller: 

    TFile* f = new TFile("myfile.root", "recreate");
    TTree* t = new TTree("t", "A test tree.")
    Event* event = 0;
    TBranchElement* br = t->Branch("event.", &event);
    for (Int_t i = 0; i < 10; ++i) {
       ... Fill event with meaningful data in some way.
       t->Fill();
    }
    t->Write();
    delete event;
    event = 0;
    delete f;
    f = 0;

(C++ version of the code)

 Notice that the only difference between this example and the following example is that the event pointer is zero when the branch is created.

An example of a branch with an object allocated and owned by the caller: 

    TFile* f = new TFile("myfile.root", "recreate");
    TTree* t = new TTree("t", "A test tree.")
    Event* event = new Event();
    TBranchElement* br = t->Branch("event.", &event);
    for (Int_t i = 0; i < 10; ++i) {
       ... Fill event with meaningful data in some way.
       t->Fill();
    }
    t->Write();
    delete event;
    event = 0;
    delete f;
    f = 0;

(C++ version of the code)

 If AutoDelete is on (see [TBranch!SetAutoDelete](@ref)), the top level objet will be deleted and recreate each time an entry is read, whether or not the [TTree](@ref) owns the object.
""" SetAddress(this::ByRef1{TBranchElement}, addobj::ByPtr2{Nothing})

# Wrapper of void TBranchElement::SetBasketSize(Int_t)
@trydoc raw"""
    SetBasketSize(this::ByRef1{TBranchElement}, buffsize::Int32)::Nothing
Reset the basket size for all sub-branches of this branch element.

""" SetBasketSize(this::ByRef1{TBranchElement}, buffsize::Int32)

# Wrapper of void TBranchElement::SetBranchFolder()
@trydoc raw"""
    SetBranchFolder(this::ByRef1{TBranchElement})::Nothing


""" SetBranchFolder(this::ByRef1{TBranchElement})

# Wrapper of void TBranchElement::SetClassName(const char *)
@trydoc raw"""
    SetClassName(this::ByRef1{TBranchElement}, name::ByCopy{String})::Nothing


""" SetClassName(this::ByRef1{TBranchElement}, name::ByCopy{String})

# Wrapper of bool TBranchElement::SetMakeClass(bool)
@trydoc raw"""
    SetMakeClass(this::ByRef1{TBranchElement}, decomposeObj::Bool)::Bool
Set the branch in a mode where the object are decomposed (Also known as MakeClass mode).
Return whether the setting was possible (it is not possible for [TBranch](@ref) and [TBranchObject](@ref)).
""" SetMakeClass(this::ByRef1{TBranchElement}, decomposeObj::Bool)

# Wrapper of void TBranchElement::SetMissing()
@trydoc raw"""
    SetMissing(this::ByRef1{TBranchElement})::Nothing
Set offset of the object (to which the data member represented by this branch belongs) inside its containing object (if any) to mark it as missing.

""" SetMissing(this::ByRef1{TBranchElement})

# Wrapper of void TBranchElement::SetObject(void *)
@trydoc raw"""
    SetObject(this::ByRef1{TBranchElement}, objadd::ByPtr2{Nothing})::Nothing
Set object this branch is pointing to.

""" SetObject(this::ByRef1{TBranchElement}, objadd::ByPtr2{Nothing})

# Wrapper of void TBranchElement::SetOffset(Int_t)
@trydoc raw"""
    SetOffset(this::ByRef1{TBranchElement}, offset::Int32)::Nothing
Set offset of the object (to which the data member represented by this branch belongs) inside its containing object (if any).

""" SetOffset(this::ByRef1{TBranchElement}, offset::Int32)

# Wrapper of void TBranchElement::SetParentClass(TClass *)
@trydoc raw"""
    SetParentClass(this::ByRef1{TBranchElement}, clparent::ByPtr1{TClass})::Nothing


""" SetParentClass(this::ByRef1{TBranchElement}, clparent::ByPtr1{TClass})

# Wrapper of void TBranchElement::SetParentName(const char *)
@trydoc raw"""
    SetParentName(this::ByRef1{TBranchElement}, name::ByCopy{String})::Nothing


""" SetParentName(this::ByRef1{TBranchElement}, name::ByCopy{String})

# Wrapper of void TBranchElement::SetTargetClass(const char *)
@trydoc raw"""
    SetTargetClass(this::ByRef1{TBranchElement}, name::ByCopy{String})::Nothing
Set the name of the class of the in-memory object into which the data will loaded.

""" SetTargetClass(this::ByRef1{TBranchElement}, name::ByCopy{String})

# Wrapper of void TBranchElement::SetType(Int_t)
@trydoc raw"""
    SetType(this::ByRef1{TBranchElement}, btype::Int32)::Nothing


""" SetType(this::ByRef1{TBranchElement}, btype::Int32)

# Wrapper of void TBranchElement::SetupAddresses()
@trydoc raw"""
    SetupAddresses(this::ByRef1{TBranchElement})::Nothing
If the branch address is not set, we set all addresses starting with the top level parent branch.
This is required to be done in order for GetOffset to be correct and for GetEntry to run.
""" SetupAddresses(this::ByRef1{TBranchElement})

# Wrapper of void TBranchElement::Unroll(const char *, TClass *, TStreamerInfo *, char *, Int_t, Int_t)
@trydoc raw"""
    Unroll(this::ByRef1{TBranchElement}, name::ByCopy{String}, cl::ByPtr1{TClass}, sinfo::ByPtr1{TStreamerInfo}, objptr::ByPtr2{Int8}, bufsize::Int32, splitlevel::Int32)::Nothing
Split class cl into sub-branches of this branch.
This version of Unroll was formerly embedded in [TTree!BronchExec](@ref) It is moved here so we can make sure to call SetReadActionSequence.
""" Unroll(this::ByRef1{TBranchElement}, name::ByCopy{String}, cl::ByPtr1{TClass}, sinfo::ByPtr1{TStreamerInfo}, objptr::ByPtr2{Int8}, bufsize::Int32, splitlevel::Int32)

# Wrapper of void TBranchElement::UpdateFile()
@trydoc raw"""
    UpdateFile(this::ByRef1{TBranchElement})::Nothing
Refresh the value of fDirectory (i.e.
where this branch writes/reads its buffers) with the current value of fTree->GetCurrentFile unless this branch has been redirected to a different file. Also update the sub-branches.
""" UpdateFile(this::ByRef1{TBranchElement})

# Wrapper of bool TLeafElement::CanGenerateOffsetArray()
@trydoc raw"""
    CanGenerateOffsetArray(this::ByRef1{TLeafElement})::Bool


""" CanGenerateOffsetArray(this::ByRef1{TLeafElement})

# Wrapper of Int_t * TLeafElement::GenerateOffsetArrayBase(Int_t, Int_t)
@trydoc raw"""
    GenerateOffsetArrayBase(this::ByRef1{TLeafElement}, ::Int32, ::Int32)::CxxPtr2{Int32}


""" GenerateOffsetArrayBase(this::ByRef1{TLeafElement}, ::Int32, ::Int32)

# Wrapper of TMethodCall * TLeafElement::GetMethodCall(const char *)
@trydoc raw"""
    GetMethodCall(this::ByRef1{TLeafElement}, name::ByCopy{String})::CxxPtr1{TMethodCall}
Returns pointer to method corresponding to name name is a string with the general form "method(list of params)" If list of params is omitted, () is assumed;.

""" GetMethodCall(this::ByRef1{TLeafElement}, name::ByCopy{String})

# Wrapper of bool TLeafElement::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafElement}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafElement}, ::ByPtr1{TLeaf})

# Wrapper of bool TLeafElement::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafElement}, ::ByRef1{TBuffer}, ::Int64)::Bool
Deserialize N events from an input buffer.

""" ReadBasketFast(this::ByRef1{TLeafElement}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafElement::SetLeafCount(TLeaf *)
@trydoc raw"""
    SetLeafCount(this::ByRef1{TLeafElement}, leaf::ByPtr1{TLeaf})::Nothing
Set the leaf count of this leaf.

""" SetLeafCount(this::ByRef1{TLeafElement}, leaf::ByPtr1{TLeaf})

# Wrapper of void TLeafF::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafF}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafF}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafF::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafF}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafF}, b::ByRef1{TBuffer})

# Wrapper of void TLeafF::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafF}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafF}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafF::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafF}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafF}, b::ByRef1{TBuffer})

# Wrapper of void TLeafF::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafF}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafF}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafF::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafF}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketFast(this::ByRef1{TLeafF}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafF::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafF}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafF}, add::ByPtr2{Nothing})

# Wrapper of void TLeafF16::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafF16}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafF16}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafF16::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafF16}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafF16}, b::ByRef1{TBuffer})

# Wrapper of void TLeafF16::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafF16}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafF16}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafF16::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafF16}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafF16}, b::ByRef1{TBuffer})

# Wrapper of void TLeafF16::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafF16}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafF16}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafF16::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafF16}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafF16}, add::ByPtr2{Nothing})

# Wrapper of void TLeafG::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafG}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafG}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafG::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafG}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafG}, b::ByRef1{TBuffer})

# Wrapper of void TLeafG::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafG}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafG}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafG::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafG}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafG}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafG::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafG}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafG}, b::ByRef1{TBuffer})

# Wrapper of void TLeafG::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafG}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafG}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafG::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafG}, ::ByRef1{TBuffer}, ::Int64)::Bool
Deserialize input by performing byteswap as needed.

""" ReadBasketFast(this::ByRef1{TLeafG}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafG::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafG}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafG}, add::ByPtr2{Nothing})

# Wrapper of void TLeafG::SetMaximum(Long_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafG}, max::Int64)::Nothing


""" SetMaximum(this::ByRef1{TLeafG}, max::Int64)

# Wrapper of void TLeafG::SetMinimum(Long_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafG}, min::Int64)::Nothing


""" SetMinimum(this::ByRef1{TLeafG}, min::Int64)

# Wrapper of void TLeafI::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafI}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafI}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafI::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafI}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafI}, b::ByRef1{TBuffer})

# Wrapper of void TLeafI::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafI}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafI}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafI::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafI}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafI}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafI::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafI}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafI}, b::ByRef1{TBuffer})

# Wrapper of void TLeafI::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafI}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafI}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafI::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafI}, ::ByRef1{TBuffer}, ::Int64)::Bool
Deserialize input by performing byteswap as needed.

""" ReadBasketFast(this::ByRef1{TLeafI}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafI::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafI}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafI}, add::ByPtr2{Nothing})

# Wrapper of void TLeafI::SetMaximum(Int_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafI}, max::Int32)::Nothing


""" SetMaximum(this::ByRef1{TLeafI}, max::Int32)

# Wrapper of void TLeafI::SetMinimum(Int_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafI}, min::Int32)::Nothing


""" SetMinimum(this::ByRef1{TLeafI}, min::Int32)

# Wrapper of void TLeafL::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafL}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafL}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafL::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafL}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafL}, b::ByRef1{TBuffer})

# Wrapper of void TLeafL::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafL}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafL}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafL::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafL}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafL}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafL::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafL}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafL}, b::ByRef1{TBuffer})

# Wrapper of void TLeafL::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafL}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafL}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafL::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafL}, ::ByRef1{TBuffer}, ::Int64)::Bool
Deserialize input by performing byteswap as needed.

""" ReadBasketFast(this::ByRef1{TLeafL}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafL::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafL}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafL}, add::ByPtr2{Nothing})

# Wrapper of void TLeafL::SetMaximum(Long64_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafL}, max::Int64)::Nothing


""" SetMaximum(this::ByRef1{TLeafL}, max::Int64)

# Wrapper of void TLeafL::SetMinimum(Long64_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafL}, min::Int64)::Nothing


""" SetMinimum(this::ByRef1{TLeafL}, min::Int64)

# Wrapper of void TLeafO::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafO}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafO}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafO::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafO}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafO}, b::ByRef1{TBuffer})

# Wrapper of void TLeafO::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafO}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafO}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafO::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafO}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafO}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafO::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafO}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafO}, b::ByRef1{TBuffer})

# Wrapper of void TLeafO::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafO}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafO}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafO::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafO}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketFast(this::ByRef1{TLeafO}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafO::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafO}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafO}, add::ByPtr2{Nothing})

# Wrapper of void TLeafO::SetMaximum(bool)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafO}, max::Bool)::Nothing


""" SetMaximum(this::ByRef1{TLeafO}, max::Bool)

# Wrapper of void TLeafO::SetMinimum(bool)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafO}, min::Bool)::Nothing


""" SetMinimum(this::ByRef1{TLeafO}, min::Bool)

# Wrapper of bool TLeafObject::CanGenerateOffsetArray()
@trydoc raw"""
    CanGenerateOffsetArray(this::ByRef1{TLeafObject})::Bool


""" CanGenerateOffsetArray(this::ByRef1{TLeafObject})

# Wrapper of void TLeafObject::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafObject}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafObject}, b::ByRef1{TBuffer})

# Wrapper of Int_t * TLeafObject::GenerateOffsetArrayBase(Int_t, Int_t)
@trydoc raw"""
    GenerateOffsetArrayBase(this::ByRef1{TLeafObject}, ::Int32, ::Int32)::CxxPtr2{Int32}


""" GenerateOffsetArrayBase(this::ByRef1{TLeafObject}, ::Int32, ::Int32)

# Wrapper of TMethodCall * TLeafObject::GetMethodCall(const char *)
@trydoc raw"""
    GetMethodCall(this::ByRef1{TLeafObject}, name::ByCopy{String})::CxxPtr1{TMethodCall}
Returns pointer to method corresponding to name.
name is a string with the general form "method(list of params)" If list of params is omitted, () is assumed;
""" GetMethodCall(this::ByRef1{TLeafObject}, name::ByCopy{String})

# Wrapper of bool TLeafObject::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TLeafObject})::Bool
This method must be overridden to handle object notification.

""" Notify(this::ByRef1{TLeafObject})

# Wrapper of void TLeafObject::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafObject}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafObject}, b::ByRef1{TBuffer})

# Wrapper of void TLeafObject::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafObject}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafObject}, add::ByPtr2{Nothing})

# Wrapper of void TLeafObject::SetVirtual(bool)
@trydoc raw"""
    SetVirtual(this::ByRef1{TLeafObject}, virt::Bool)::Nothing


""" SetVirtual(this::ByRef1{TLeafObject}, virt::Bool)

# Wrapper of void TLeafS::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeafS}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Export element from local_ leaf buffer to ClonesArray.

""" Export(this::ByRef1{TLeafS}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of void TLeafS::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeafS}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeafS}, b::ByRef1{TBuffer})

# Wrapper of void TLeafS::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeafS}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Import element from ClonesArray into local_ leaf buffer.

""" Import(this::ByRef1{TLeafS}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafS::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeafS}, ::ByPtr1{TLeaf})::Bool
Copy/set fMinimum and fMaximum to include/be wide than those of the parameter.

""" IncludeRange(this::ByRef1{TLeafS}, ::ByPtr1{TLeaf})

# Wrapper of void TLeafS::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeafS}, b::ByRef1{TBuffer})::Nothing
Read leaf elements from Basket input buffer.

""" ReadBasket(this::ByRef1{TLeafS}, b::ByRef1{TBuffer})

# Wrapper of void TLeafS::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeafS}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)::Nothing
Read leaf elements from Basket input buffer and export buffer to [TClonesArray](@ref) objects.

""" ReadBasketExport(this::ByRef1{TLeafS}, b::ByRef1{TBuffer}, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of bool TLeafS::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeafS}, ::ByRef1{TBuffer}, ::Int64)::Bool
Deserialize input by performing byteswap as needed.

""" ReadBasketFast(this::ByRef1{TLeafS}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of void TLeafS::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeafS}, add::ByPtr2{Nothing})::Nothing
Set leaf buffer data address.

""" SetAddress(this::ByRef1{TLeafS}, add::ByPtr2{Nothing})

# Wrapper of void TLeafS::SetMaximum(Short_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TLeafS}, max::Int16)::Nothing


""" SetMaximum(this::ByRef1{TLeafS}, max::Int16)

# Wrapper of void TLeafS::SetMinimum(Short_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TLeafS}, min::Int16)::Nothing


""" SetMinimum(this::ByRef1{TLeafS}, min::Int16)

# Wrapper of void TBranchObject::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TBranchObject}, b::ByPtr1{TBrowser})::Nothing
Browse the branch content.

""" Browse(this::ByRef1{TBranchObject}, b::ByPtr1{TBrowser})

# Wrapper of Int_t TBranchObject::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TBranchObject}, entry::Int64, getall::Int32)::Int32
Read all branches of a BranchObject and return total number of bytes.
- If entry = 0 take current entry number + 1
- If entry < 0 reset entry number to 0

The function returns the number of bytes read from the input buffer.

- If entry does not exist the function returns 0.
- If an I/O error occurs, the function returns -1.
""" GetEntry(this::ByRef1{TBranchObject}, entry::Int64, getall::Int32)

# Wrapper of Int_t TBranchObject::GetExpectedType(TClass *&, EDataType &)
@trydoc raw"""
    GetExpectedType(this::ByRef1{TBranchObject}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})::Int32
Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure.

""" GetExpectedType(this::ByRef1{TBranchObject}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})

# Wrapper of const char * TBranchObject::GetObjClassName()
@trydoc raw"""
    GetObjClassName(this::ByRef1{TBranchObject})::ByCopy{String}


""" GetObjClassName(this::ByRef1{TBranchObject})

# Wrapper of void TBranchObject::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TBranchObject}, option::ByCopy{String})::Nothing
Reset a branch.
- Existing buffers are deleted.
- Entries, max and min are reset.
""" Reset(this::ByRef1{TBranchObject}, option::ByCopy{String})

# Wrapper of void TBranchObject::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TBranchObject}, addobj::ByPtr2{Nothing})::Nothing
Set address of this branch.

""" SetAddress(this::ByRef1{TBranchObject}, addobj::ByPtr2{Nothing})

# Wrapper of void TBranchObject::SetAutoDelete(bool)
@trydoc raw"""
    SetAutoDelete(this::ByRef1{TBranchObject}, autodel::Bool)::Nothing
Set the AutoDelete bit.
This function can be used to instruct Root in [TBranchObject!ReadBasket](@ref) to not delete the object referenced by a branchobject before reading a new entry. By default, the object is deleted.

- If autodel is true, this existing object will be deleted, a new object created by the default constructor, then object->Streamer called.
- If autodel is false, the existing object is not deleted. Root assumes that the user is taking care of deleting any internal object or array This can be done in Streamer itself.
- If this branch has sub-branches, the function sets autodel for these branches as well. We STRONGLY suggest to activate this option by default when you create the top level branch. This will make the read phase more efficient because it minimizes the numbers of new/delete operations. Once this option has been set and the Tree is written to a file, it is not necessary to specify the option again when reading, unless you want to set the opposite mode.
""" SetAutoDelete(this::ByRef1{TBranchObject}, autodel::Bool)

# Wrapper of void TBranchObject::SetBasketSize(Int_t)
@trydoc raw"""
    SetBasketSize(this::ByRef1{TBranchObject}, buffsize::Int32)::Nothing
Reset basket size for all subbranches of this branch.

""" SetBasketSize(this::ByRef1{TBranchObject}, buffsize::Int32)

# Wrapper of void TBranchObject::SetupAddresses()
@trydoc raw"""
    SetupAddresses(this::ByRef1{TBranchObject})::Nothing
 If the branch address is not set, we set all addresses starting with the top level parent branch.
This is required to be done in order for GetOffset to be correct and for GetEntry to run.
""" SetupAddresses(this::ByRef1{TBranchObject})

# Wrapper of void TBranchObject::UpdateAddress()
@trydoc raw"""
    UpdateAddress(this::ByRef1{TBranchObject})::Nothing
Update branch addresses if a new object was created.

""" UpdateAddress(this::ByRef1{TBranchObject})

# Wrapper of void TBranchSTL::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TBranchSTL}, b::ByPtr1{TBrowser})::Nothing
Browse an STL branch.

""" Browse(this::ByRef1{TBranchSTL}, b::ByPtr1{TBrowser})

# Wrapper of Int_t TBranchSTL::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TBranchSTL}, entry::Int64, getall::Int32)::Int32
Get entry.

""" GetEntry(this::ByRef1{TBranchSTL}, entry::Int64, getall::Int32)

# Wrapper of Int_t TBranchSTL::GetExpectedType(TClass *&, EDataType &)
@trydoc raw"""
    GetExpectedType(this::ByRef1{TBranchSTL}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})::Int32
Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure.

""" GetExpectedType(this::ByRef1{TBranchSTL}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})

# Wrapper of void TBranchSTL::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TBranchSTL}, addr::ByPtr2{Nothing})::Nothing
Set Address.

""" SetAddress(this::ByRef1{TBranchSTL}, addr::ByPtr2{Nothing})

# Wrapper of Long64_t TTreeReader::GetEntries(bool)
@trydoc raw"""
    GetEntries(this::ByRef1{TTreeReader}, force::Bool)::Int64
Returns the number of entries of the [TEntryList](@ref) if one is provided, else of the [TTree](@ref) / [TChain](@ref), independent of a range set by [SetEntriesRange()](@ref).
## Arguments

- **`force`** 
    If `IsChain()` and `force`, determines whether all TFiles of this [TChain](@ref) should be opened to determine the exact number of entries of the [TChain](@ref). If `!IsChain()`, `force` is ignored.
""" GetEntries(this::ByRef1{TTreeReader}, force::Bool)

# Wrapper of bool TTreeReader::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TTreeReader})::Bool
Notify director and values of a change in tree.
Called from [TChain](@ref) and [TTree](@ref)'s LoadTree. [TTreeReader](@ref) registers its fNotify data member with the TChain/TTree which in turn leads to this method being called upon the execution of LoadTree.
""" Notify(this::ByRef1{TTreeReader})

# Wrapper of void TTreeReader::SetTree(const char *, TDirectory *, TEntryList *)
@trydoc raw"""
    SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, dir::ByPtr1{TDirectory}, entryList::ByPtr1{TEntryList})::Nothing
Set (or update) the which tree to read from, passing the name of a tree in a directory.
## Arguments

- **`keyname`** 
    - name of the tree in `dir` 
    
- **`dir`** 
    - the `TDirectory` to load `keyname` from (or gDirectory if `nullptr`) 
    
- **`entryList`** 
    - the `TEntryList` to attach to the `TTreeReader`.
""" SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, dir::ByPtr1{TDirectory}, entryList::ByPtr1{TEntryList})

# Wrapper of void TTreeReader::SetTree(const char *, TEntryList *)
@trydoc raw"""
    SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, entryList::ByPtr1{TEntryList})::Nothing


""" SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, entryList::ByPtr1{TEntryList})

# Wrapper of void TTreeReader::SetTree(TTree *, TEntryList *)
@trydoc raw"""
    SetTree(this::ByRef1{TTreeReader}, tree::ByPtr1{TTree}, entryList::ByPtr1{TEntryList})::Nothing
Set (or update) the which tree to read from.
`tree` can be a [TTree](@ref) or a [TChain](@ref).
""" SetTree(this::ByRef1{TTreeReader}, tree::ByPtr1{TTree}, entryList::ByPtr1{TEntryList})

# Wrapper of T * TTreeReaderValue::Get()
@trydoc raw"""
    Get(this::ByRef1{TTreeReaderValue})::CxxPtr1{T}
Return a pointer to the value of the current entry.
Return a nullptr and print an error if no entry has been loaded yet. The returned address is guaranteed to stay constant while a given [TTree](@ref) is being read from a given file, unless the branch addresses are manipulated directly (e.g. through [TTree!SetBranchAddress()](@ref)). The address might also change when the underlying TTree/TFile is switched, e.g. when a [TChain](@ref) switches files.
""" Get(this::ByRef1{TTreeReaderValue})

# Wrapper of T & TTreeReaderValue::operator*()
@trydoc raw"""
    Base.getindex(this::ByRef1{TTreeReaderValue})::CxxRef1{T}
Return a reference to the value of the current entry.
Equivalent to dereferencing the pointer returned by [Get()](@ref). Behavior is undefined if no entry has been loaded yet. Most likely a crash will occur.
""" Base.getindex(this::ByRef1{TTreeReaderValue})

# Wrapper of T * TTreeReaderValue::operator->()
@trydoc raw"""
    arrow(this::ByRef1{TTreeReaderValue})::CxxPtr1{T}
Return a pointer to the value of the current entry.
Equivalent to [Get()](@ref).
""" arrow(this::ByRef1{TTreeReaderValue})

# Wrapper of Int_t TRandom::Binomial(Int_t, Double_t)
@trydoc raw"""
    Binomial(this::ByRef1{TRandom}, ntot::Int32, prob::Float64)::Int32
Generates a random integer N according to the binomial law.
Coded from Los Alamos report LA-5061-MS.

N is binomially distributed between 0 and ntot inclusive with mean prob*ntot and prob is between 0 and 1.

Note: This function should not be used when ntot is large (say >100). The normal approximation is then recommended instead (with mean =*ntot+0.5 and standard deviation sqrt(ntot*prob*(1-prob)).
""" Binomial(this::ByRef1{TRandom}, ntot::Int32, prob::Float64)

# Wrapper of Double_t TRandom::BreitWigner(Double_t, Double_t)
@trydoc raw"""
    BreitWigner(this::ByRef1{TRandom}, mean::Float64, gamma::Float64)::Float64
Return a number distributed following a BreitWigner function with mean and gamma.

""" BreitWigner(this::ByRef1{TRandom}, mean::Float64, gamma::Float64)

# Wrapper of void TRandom::Circle(Double_t &, Double_t &, Double_t)
@trydoc raw"""
    Circle(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, r::Float64)::Nothing
Generates random vectors, uniformly distributed over a circle of given radius.
Input : r = circle radius Output: x,y a random 2-d vector of length r
""" Circle(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, r::Float64)

# Wrapper of Double_t TRandom::Exp(Double_t)
@trydoc raw"""
    Exp(this::ByRef1{TRandom}, tau::Float64)::Float64
Returns an exponential deviate.
```
     exp( -t/tau ) 
```
""" Exp(this::ByRef1{TRandom}, tau::Float64)

# Wrapper of Double_t TRandom::Gaus(Double_t, Double_t)
@trydoc raw"""
    Gaus(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)::Float64
Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigma.
Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger This is one of the fastest existing method for generating normal random variables. It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous version of [TRandom!Gaus](@ref). The speed is comparable to the Ziggurat method (from Marsaglia) implemented for example in GSL and available in the MathMore library.

REFERENCE: - W. Hoermann and G. Derflinger (1990): The ACR Method for generating normal random variables, OR Spektrum 12 (1990), 181-185.

Implementation taken from UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien
""" Gaus(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)

# Wrapper of UInt_t TRandom::Integer(UInt_t)
@trydoc raw"""
    GetInteger(this::ByRef1{TRandom}, imax::UInt32)::UInt32
Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].
Note that the interval contains the values of 0 and imax-1 but not imax.
""" GetInteger(this::ByRef1{TRandom}, imax::UInt32)

# Wrapper of Double_t TRandom::Landau(Double_t, Double_t)
@trydoc raw"""
    Landau(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)::Float64
Generate a random number following a Landau distribution with location parameter mu and scale parameter sigma: Landau( (x-mu)/sigma ) Note that mu is not the mpv(most probable value) of the Landa distribution and sigma is not the standard deviation of the distribution which is not defined.
For mu =0 and sigma=1, the mpv = -0.22278

The Landau random number generation is implemented using the function landau_quantile(x,sigma), which provides the inverse of the landau cumulative distribution. landau_quantile has been converted from CERNLIB ranlan(G110).
""" Landau(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)

# Wrapper of ULong64_t TRandom::Poisson(Double_t)
@trydoc raw"""
    Poisson(this::ByRef1{TRandom}, mean::Float64)::UInt64
Generates a random integer N according to a Poisson law.
Prob(N) = exp(-mean)*mean^N/Factorial(N)

Use a different procedure according to the mean value. The algorithm is the same used by CLHEP. For lower value (mean < 25) use the rejection method based on the exponential. For higher values use a rejection method comparing with a Lorentzian distribution, as suggested by several authors. This routine returns now an unsigned 64 bit integer For large values, larger than 1.84e+19, we print an error message advising to use the Trandom!PoissonD for such large values, and return the max value UINT64_MAX
""" Poisson(this::ByRef1{TRandom}, mean::Float64)

# Wrapper of Double_t TRandom::PoissonD(Double_t)
@trydoc raw"""
    PoissonD(this::ByRef1{TRandom}, mean::Float64)::Float64
Generates a random number according to a Poisson law.
Prob(N) = exp(-mean)*mean^N/Factorial(N)

This function is a variant of [TRandom!Poisson](@ref) returning a double instead of an integer.
""" PoissonD(this::ByRef1{TRandom}, mean::Float64)

# Wrapper of void TRandom::Rannor(Double_t &, Double_t &)
@trydoc raw"""
    Rannor(this::ByRef1{TRandom}, a::ByRef2{Float64}, b::ByRef2{Float64})::Nothing
Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.

""" Rannor(this::ByRef1{TRandom}, a::ByRef2{Float64}, b::ByRef2{Float64})

# Wrapper of void TRandom::Rannor(Float_t &, Float_t &)
@trydoc raw"""
    Rannor(this::ByRef1{TRandom}, a::ByRef2{Float32}, b::ByRef2{Float32})::Nothing
Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.

""" Rannor(this::ByRef1{TRandom}, a::ByRef2{Float32}, b::ByRef2{Float32})

# Wrapper of void TRandom::ReadRandom(const char *)
@trydoc raw"""
    ReadRandom(this::ByRef1{TRandom}, filename::ByCopy{String})::Nothing
Reads saved random generator status from filename.

""" ReadRandom(this::ByRef1{TRandom}, filename::ByCopy{String})

# Wrapper of Double_t TRandom::Rndm()
@trydoc raw"""
    Rndm(this::ByRef1{TRandom})::Float64
Machine independent random number generator.
Based on the BSD Unix (Rand) Linear congruential generator. Produces uniformly-distributed floating points between 0 and 1. Identical sequence on all machines of >= 32 bits. Periodicity = 2**31, generates a number in (0,1). Note that this is a generator which is known to have defects (the lower random bits are correlated) and therefore should NOT be used in any statistical study).
""" Rndm(this::ByRef1{TRandom})

# Wrapper of Double_t TRandom::Rndm(Int_t)
@trydoc raw"""
    Rndm(this::ByRef1{TRandom}, ::Int32)::Float64


""" Rndm(this::ByRef1{TRandom}, ::Int32)

# Wrapper of void TRandom::RndmArray(Int_t, Double_t *)
@trydoc raw"""
    RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float64})::Nothing
Return an array of n random numbers uniformly distributed in ]0,1].

""" RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float64})

# Wrapper of void TRandom::RndmArray(Int_t, Float_t *)
@trydoc raw"""
    RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float32})::Nothing
Return an array of n random numbers uniformly distributed in ]0,1].

""" RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float32})

# Wrapper of void TRandom::SetSeed(ULong_t)
@trydoc raw"""
    SetSeed(this::ByRef1{TRandom}, seed::UInt64)::Nothing
Set the random generator seed.
Note that default value is zero, which is different than the default value used when constructing the class. If the seed is zero the seed is set to a random value which in case of [TRandom](@ref) depends on the lowest 4 bytes of [TUUID](@ref) The UUID will be identical if SetSeed(0) is called with time smaller than 100 ns Instead if a different generator implementation is used ([TRandom1](@ref), 2 or 3) the seed is generated using a 128 bit UUID. This results in different seeds and then random sequence for every SetSeed(0) call.
""" SetSeed(this::ByRef1{TRandom}, seed::UInt64)

# Wrapper of void TRandom::Sphere(Double_t &, Double_t &, Double_t &, Double_t)
@trydoc raw"""
    Sphere(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, r::Float64)::Nothing
Generates random vectors, uniformly distributed over the surface of a sphere of given radius.
Input : r = sphere radius Output: x,y,z a random 3-d vector of length r Method: (based on algorithm suggested by Knuth and attributed to Robert E Knop) which uses less random numbers than the CERNLIB RN23DIM algorithm
""" Sphere(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, r::Float64)

# Wrapper of Double_t TRandom::Uniform(Double_t, Double_t)
@trydoc raw"""
    Uniform(this::ByRef1{TRandom}, x1::Float64, x2::Float64)::Float64
Returns a uniform deviate on the interval (x1, x2).

""" Uniform(this::ByRef1{TRandom}, x1::Float64, x2::Float64)

# Wrapper of Double_t TRandom::Uniform(Double_t)
@trydoc raw"""
    Uniform(this::ByRef1{TRandom}, x1::Float64)::Float64
Returns a uniform deviate on the interval (0, x1).

""" Uniform(this::ByRef1{TRandom}, x1::Float64)

# Wrapper of void TDirectoryFile::Add(TObject *, Bool_t)
@trydoc raw"""
    Add(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)::Nothing


""" Add(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of void TDirectoryFile::Append(TObject *, Bool_t)
@trydoc raw"""
    Append(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)::Nothing
Append object to this directory.
If replace is true: remove any existing objects with the same same (if the name is not ""
""" Append(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of Int_t TDirectoryFile::AppendKey(TKey *)
@trydoc raw"""
    AppendKey(this::ByRef1{TDirectoryFile}, key::ByPtr1{TKey})::Int32
Insert key in the linked list of keys of this directory.

""" AppendKey(this::ByRef1{TDirectoryFile}, key::ByPtr1{TKey})

# Wrapper of void TDirectoryFile::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TDirectoryFile}, b::ByPtr1{TBrowser})::Nothing
Browse the content of the directory.

""" Browse(this::ByRef1{TDirectoryFile}, b::ByPtr1{TBrowser})

# Wrapper of void TDirectoryFile::Build(TFile *, TDirectory *)
@trydoc raw"""
    Build(this::ByRef1{TDirectoryFile}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})::Nothing


""" Build(this::ByRef1{TDirectoryFile}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})

# Wrapper of Bool_t TDirectoryFile::cd()
@trydoc raw"""
    cd(this::ByRef1{TDirectoryFile})::Bool
Change current directory to "this" directory.
Returns kTRUE in case of success.
""" cd(this::ByRef1{TDirectoryFile})

# Wrapper of Bool_t TDirectoryFile::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TDirectoryFile}, path::ByCopy{String})::Bool
Change current directory the directory described by the path if given one.
change the current directory to "path". The absolute path syntax is: 
```
file.root:/dir1/dir2
```  where file.root is the file and /dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to "this" directory. E.g: ../aa. Returns kTRUE in case of success.
""" cd(this::ByRef1{TDirectoryFile}, path::ByCopy{String})

# Wrapper of TObject * TDirectoryFile::CloneObject(const TObject *, Bool_t)
@trydoc raw"""
    CloneObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, autoadd::Bool)::CxxPtr1{TObject}
Make a clone of an object using the Streamer facility.
If the object derives from [TNamed](@ref), this function is called by [TNamed!Clone](@ref). [TNamed!Clone](@ref) uses the optional argument newname to set a new name to the newly created object.

If autoadd is true and if the object class has a DirectoryAutoAdd function, it will be called at the theend of the function with the parameter gDirectory. This usually means that the object will be appended to the current [ROOT](@ref) directory.
""" CloneObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, autoadd::Bool)

# Wrapper of void TDirectoryFile::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TDirectoryFile}, option::ByCopy{String})::Nothing
Delete all objects from memory and directory structure itself.

""" Close(this::ByRef1{TDirectoryFile}, option::ByCopy{String})

# Wrapper of void TDirectoryFile::Delete(const char *)
@trydoc raw"""
    Delete(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})::Nothing
Delete Objects or/and keys in a directory.
Properties of the namecycle string:

- namecycle has the format name;cycle
- namecycle = "" is same as namecycle ="T*"
- name = * means all
- cycle = * means all cycles (memory and keys)
- cycle = "" or cycle = 9999 ==> apply to a memory object When name=* use T* to delete subdirectories also

To delete one directory, you must specify the directory cycle, eg. file.Delete("dir1;1");

Examples: 
| **[Pattern](@ref)** | **Description**                                                |
|:--------------------|:---------------------------------------------------------------|
| foo                 | delete object named foo in memory                              |
| foo*                | delete all objects with a name starting with foo               |
| foo;1               | delete cycle 1 of foo on file                                  |
| foo;*               | delete all cycles of foo on file and also from memory          |
| *;2                 | delete all objects on file having the cycle 2                  |
| *;*                 | delete all objects from memory and file                        |
| T*;*                | delete all objects from memory and file and all subdirectories |

## WARNING

If the key to be deleted contains special characters ("+","^","?", etc that have a special meaning for the regular expression parser (see [TRegexp](@ref)) then you must specify 2 backslash characters to escape the regular expression. For example, if the key to be deleted is namecycle = "C++", you must call 
```
mydir.Delete("C\\+\\+"));
```
""" Delete(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})

# Wrapper of void TDirectoryFile::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TDirectoryFile}, buffer::ByPtr2{Int8})::Nothing
Encode directory header into output buffer.

""" FillBuffer(this::ByRef1{TDirectoryFile}, buffer::ByPtr2{Int8})

# Wrapper of TObject * TDirectoryFile::Get(const char *)
@trydoc raw"""
    Get(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})::CxxPtr1{TObject}
Return pointer to object identified by namecycle.
Properties:

- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

Examples: 
| **Pattern** | **Explanation**                                                                             |
|:------------|:--------------------------------------------------------------------------------------------|
| foo         | get object named foo in memory if object is not in memory, try with highest cycle from file |
| foo;1       | get cycle 1 of foo on file                                                                  |

The retrieved object should in principle derive from [TObject](@ref). If not, the function [TDirectoryFile!Get<T>](@ref) should be called. However, this function will still work for a non-TObject, provided that the calling application cast the return type to the correct type (which is the actual type of the object).

### The Get<T> Method

The method Get<T> offers better protection and avoids the need for any cast: 

    auto objPtr = directory->Get<MyClass>("some object");
    if (objPtr) { ... the object exist and inherits from MyClass ... }

(C++ version of the code)

### Very important note about inheritance

In case the class of this object derives from [TObject](@ref) but not as a first inheritance, one must use dynamic_cast<>().

#### Example 1 - Normal case:

```
class MyClass : public TObject, public AnotherClass
```  then on return, one can adopt a C style cast: 
```
auto objPtr = (MyClass*)directory->Get("some object of MyClass");
```  #### Example 2 - Special case:

```
class MyClass : public AnotherClass, public TObject
```  then on return, one must do: 
```
auto objPtr = dynamic_cast<MyClass*>(directory->Get("some object of MyClass"));
```  Of course, dynamic_cast<> can also be used in the example 1.
""" Get(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})

# Wrapper of TDirectory * TDirectoryFile::GetDirectory(const char *, Bool_t, const char *)
@trydoc raw"""
    GetDirectory(this::ByRef1{TDirectoryFile}, apath::ByCopy{String}, printError::Bool, funcname::ByCopy{String})::CxxPtr1{TDirectory}
Find a directory named "apath".
It apath is null or empty, returns "this" directory. Otherwise use the name "apath" to find a directory. The absolute path syntax is: 
```
file.root:/dir1/dir2
```  where file.root is the file and /dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to "this" directory. E.g: ../aa. Returns 0 in case path does not exist. If printError is true, use Error with 'funcname' to issue an error message.
""" GetDirectory(this::ByRef1{TDirectoryFile}, apath::ByCopy{String}, printError::Bool, funcname::ByCopy{String})

# Wrapper of void * TDirectoryFile::GetObjectChecked(const char *, const char *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, classname::ByCopy{String})::CxxPtr2{Nothing}
See documentation of TDirectoryFile!GetObjectCheck(const char *namecycle, const TClass *cl)

""" GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, classname::ByCopy{String})

# Wrapper of void * TDirectoryFile::GetObjectChecked(const char *, const TClass *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a "expectedClass" If expectedClass is null, no check is performed.
- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

### Very important note

The calling application must cast the returned pointer to the type described by the 2 arguments (i.e. cl):

auto objPtr = (MyClass*)directory->GetObjectChecked("some object of MyClass","MyClass"));

Note: We recommend using the method [TDirectoryFile!Get<T>](@ref): 

    auto objPtr = directory->Get<MyClass>("some object inheriting from MyClass");
    if (objPtr) { ... we found what we are looking for ... }

(C++ version of the code)
""" GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})

# Wrapper of void * TDirectoryFile::GetObjectUnchecked(const char *)
@trydoc raw"""
    GetObjectUnchecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle.
The returned object may or may not derive from [TObject](@ref).

- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

## Very important note

The calling application must cast the returned object to the final type, e.g.

auto objPtr = (MyClass*)directory->GetObject("some object of MyClass");
""" GetObjectUnchecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})

# Wrapper of TDirectory * TDirectoryFile::mkdir(const char *, const char *, Bool_t)
@trydoc raw"""
    mkdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)::CxxPtr1{TDirectory}
Create a sub-directory "a" or a hierarchy of sub-directories "a/b/c/...".
Returns 0 in case of error or if a sub-directory (hierarchy) with the requested name already exists. returnExistingDirectory returns a pointer to an already existing sub-directory instead of 0. Returns a pointer to the created sub-directory or to the top sub-directory of the hierarchy (in the above example, the returned [TDirectory](@ref) * always points to "a").
""" mkdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)

# Wrapper of TFile * TDirectoryFile::OpenFile(const char *, Option_t *, const char *, Int_t, Int_t)
@trydoc raw"""
    OpenFile(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)::CxxPtr1{TFile}
Interface to [TFile!Open](@ref).
""" OpenFile(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)

# Wrapper of void TDirectoryFile::Purge(Short_t)
@trydoc raw"""
    Purge(this::ByRef1{TDirectoryFile}, nkeep::Int16)::Nothing
Purge lowest key cycles in a directory.
By default, only the highest cycle of a key is kept. Keys for which the "KEEP" flag has been set are not removed. See [TKey!Keep()](@ref). NOTE: This does not reduce the size of a [TFile](@ref) the space is simply freed up to be overwritten.
""" Purge(this::ByRef1{TDirectoryFile}, nkeep::Int16)

# Wrapper of void TDirectoryFile::ReadAll(Option_t *)
@trydoc raw"""
    ReadAll(this::ByRef1{TDirectoryFile}, option::ByCopy{String})::Nothing
Read objects from a [ROOT](@ref) file directory into memory.
If an object is already in memory, the memory copy is deleted and the object is again read from the file. If opt=="dirs", only subdirectories will be read If opt=="dirs*" complete directory tree will be read
""" ReadAll(this::ByRef1{TDirectoryFile}, option::ByCopy{String})

# Wrapper of Int_t TDirectoryFile::ReadKeys(Bool_t)
@trydoc raw"""
    ReadKeys(this::ByRef1{TDirectoryFile}, forceRead::Bool)::Int32
Read the linked list of keys.
Every directory has a linked list (fKeys). This linked list has been written on the file via WriteKeys as a single data record.

It is interesting to call this function in the following situation. Assume another process1 is connecting this directory in Update mode

- Process1 is adding/updating objects in this directory
- You want to see the latest status from process1. Example Process1: 

        obj1.Write();
        obj2.Write();
        gDirectory->SaveSelf();

(C++ version of the code)


Example Process2: 

    gDirectory->ReadKeys();
    obj1->Draw();

(C++ version of the code)

 This is an efficient way (without opening/closing files) to view the latest updates of a file being modified by another process as it is typically the case in a data acquisition system.
""" ReadKeys(this::ByRef1{TDirectoryFile}, forceRead::Bool)

# Wrapper of Int_t TDirectoryFile::ReadTObject(TObject *, const char *)
@trydoc raw"""
    ReadTObject(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, keyname::ByCopy{String})::Int32
Read object with keyname from the current directory.
Read contents of object with specified name from the current directory. First the key with keyname is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See [TObject!Write()](@ref).
""" ReadTObject(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, keyname::ByCopy{String})

# Wrapper of void TDirectoryFile::rmdir(const char *)
@trydoc raw"""
    rmdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String})::Nothing
Removes subdirectory from the directory.
When directory is deleted, all keys in all subdirectories will be read first and deleted from file (if exists) Equivalent call is Delete("name;*");
""" rmdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String})

# Wrapper of void TDirectoryFile::Save()
@trydoc raw"""
    Save(this::ByRef1{TDirectoryFile})::Nothing
Save recursively all directory keys and headers.

""" Save(this::ByRef1{TDirectoryFile})

# Wrapper of void TDirectoryFile::SaveSelf(Bool_t)
@trydoc raw"""
    SaveSelf(this::ByRef1{TDirectoryFile}, force::Bool)::Nothing
Save Directory keys and header.
If the directory has been modified (fModified set), write the keys and the directory header. This function assumes the cd is correctly set.

It is recommended to use this function in the following situation: Assume a process1 using a directory in Update mode

- New objects or modified objects have been written to the directory.
- You do not want to close the file.
- You want your changes be visible from another process2 already connected to this directory in read mode.
- Call this function.
- In process2, use [TDirectoryFile!ReadKeys](@ref) to refresh the directory.
""" SaveSelf(this::ByRef1{TDirectoryFile}, force::Bool)

# Wrapper of void TDirectoryFile::SetBufferSize(Int_t)
@trydoc raw"""
    SetBufferSize(this::ByRef1{TDirectoryFile}, bufsize::Int32)::Nothing
Set the default buffer size when creating new TKeys.
See also [TDirectoryFile!GetBufferSize](@ref)
""" SetBufferSize(this::ByRef1{TDirectoryFile}, bufsize::Int32)

# Wrapper of void TDirectoryFile::SetModified()
@trydoc raw"""
    SetModified(this::ByRef1{TDirectoryFile})::Nothing


""" SetModified(this::ByRef1{TDirectoryFile})

# Wrapper of void TDirectoryFile::SetSeekDir(Long64_t)
@trydoc raw"""
    SetSeekDir(this::ByRef1{TDirectoryFile}, v::Int64)::Nothing


""" SetSeekDir(this::ByRef1{TDirectoryFile}, v::Int64)

# Wrapper of void TDirectoryFile::SetTRefAction(TObject *, TObject *)
@trydoc raw"""
    SetTRefAction(this::ByRef1{TDirectoryFile}, ref::ByPtr1{TObject}, parent::ByPtr1{TObject})::Nothing
Find the action to be executed in the dictionary of the parent class and store the corresponding exec number into fBits.
This function searches a data member in the class of parent with an offset corresponding to this. If a comment "TEXEC:" is found in the comment field of the data member, the function stores the exec identifier of the exec statement following this keyword.
""" SetTRefAction(this::ByRef1{TDirectoryFile}, ref::ByPtr1{TObject}, parent::ByPtr1{TObject})

# Wrapper of void TDirectoryFile::SetWritable(Bool_t)
@trydoc raw"""
    SetWritable(this::ByRef1{TDirectoryFile}, writable::Bool)::Nothing
Set the new value of fWritable recursively.

""" SetWritable(this::ByRef1{TDirectoryFile}, writable::Bool)

# Wrapper of Int_t TDirectoryFile::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, opt::Int32, bufsize::Int32)::Int32
Write all objects in memory to disk.
Loop on all objects in memory (including subdirectories). A new key is created in the keys linked list for each object. For allowed options see [TObject!Write()](@ref). The directory header info is rewritten on the directory header record.
""" Write(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, opt::Int32, bufsize::Int32)

# Wrapper of void TDirectoryFile::WriteDirHeader()
@trydoc raw"""
    WriteDirHeader(this::ByRef1{TDirectoryFile})::Nothing
Overwrite the Directory header record.

""" WriteDirHeader(this::ByRef1{TDirectoryFile})

# Wrapper of void TDirectoryFile::WriteKeys()
@trydoc raw"""
    WriteKeys(this::ByRef1{TDirectoryFile})::Nothing
Write Keys linked list on the file.
The linked list of keys (fKeys) is written as a single data record
""" WriteKeys(this::ByRef1{TDirectoryFile})

# Wrapper of Int_t TDirectoryFile::WriteObjectAny(const void *, const char *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, classname::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)::Int32
Write object from pointer of class classname in this directory.
obj may not derive from [TObject](@ref). See [TDirectoryFile!WriteTObject](@ref) for comments

## Very important note

The value passed as 'obj' needs to be from a pointer to the type described by classname. For example: 

    TopClass *top;
    BottomClass *bottom;
    top = bottom;

(C++ version of the code)

 you can do: 

    directory->WriteObjectAny(top,"top","name of object");
    directory->WriteObjectAny(bottom,"bottom","name of object");

(C++ version of the code)

 **BUT YOU CAN NOT DO** the following since it will fail with multiple inheritance: 

    directory->WriteObjectAny(top,"bottom","name of object");

(C++ version of the code)

 We **STRONGLY** recommend to use 

    TopClass *top = ....;
    directory->WriteObject(top,"name of object")

(C++ version of the code)

 See also remarks in [TDirectoryFile!WriteTObject](@ref)
""" WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, classname::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TDirectoryFile::WriteObjectAny(const void *, const TClass *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)::Int32
Write object of class with dictionary cl in this directory.
obj may not derive from [TObject](@ref) To get the TClass* cl pointer, one can use 
```
TClass *cl = TClass!GetClass("classname");
```  An alternative is to call the function WriteObjectAny above. see [TDirectoryFile!WriteTObject](@ref) for comments
""" WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TDirectoryFile::WriteTObject(const TObject *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteTObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)::Int32
Write object obj to this directory.
The data structure corresponding to this object is serialized. The corresponding buffer is written to this directory with an associated key with name "name".

Writing an object to a file involves the following steps:

- Creation of a support [TKey](@ref) object in the directory. The [TKey](@ref) object creates a [TBuffer](@ref) object.
- The [TBuffer](@ref) object is filled via the class!Streamer function.
- If the file is compressed (default) a second buffer is created to hold the compressed buffer.
- Reservation of the corresponding space in the file by looking in the [TFree](@ref) list of free blocks of the file.
- The buffer is written to the file.

By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far. Use [TDirectoryFile!SetBufferSize](@ref) to force a given buffer size.

If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by obj->[GetName()](@ref).

The option can be a combination of:

- "SingleKey"
- "Overwrite"
- "WriteDelete" Using the "Overwrite" option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the "WriteDelete" option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. The "SingleKey" option is only used by [TCollection!Write()](@ref) to write a container with a single key instead of each object in the container with its own key. An object is read from this directory via [TDirectoryFile!Get](@ref). The function returns the total number of bytes written to the directory. It returns 0 if the object cannot be written.

WARNING: avoid special characters like '^','$','.' in the name as they are used by the regular expression parser (see [TRegexp](@ref)).
""" WriteTObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)

# Wrapper of Bool_t TFileOpenHandle::Matches(const char *)
@trydoc raw"""
    Matches(this::ByRef1{TFileOpenHandle}, name::ByCopy{String})::Bool
Return kTRUE if this async request matches the open request specified by 'url'.

""" Matches(this::ByRef1{TFileOpenHandle}, name::ByCopy{String})

# Wrapper of bool TFitResult::Contour(unsigned int, unsigned int, TGraph *, double)
@trydoc raw"""
    Contour(this::ByRef1{TFitResult}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)::Bool
Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or is invalid it will return false on exit a [TGraph](@ref) is filled with the contour points the number of contour points is determined by the size of the [TGraph](@ref).
if the size is zero a default number of points = 20 is used pass optionally the confidence level, default is 0.683 it is assumed that ErrorDef() defines the right error definition (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level
""" Contour(this::ByRef1{TFitResult}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)

# Wrapper of bool TFitResult::Scan(unsigned int, TGraph *, double, double)
@trydoc raw"""
    Scan(this::ByRef1{TFitResult}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)::Bool
Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return filled with the scan resul If the graph size is zero, a default size n = 40 will be used.

""" Scan(this::ByRef1{TFitResult}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr &)
@trydoc raw"""
    assign(this::ByRef1{TFitResultPtr}, rhs::ByConstRef1{TFitResultPtr})::CxxRef1{TFitResultPtr}
Assignment operator.
if needed copy the [TFitResult](@ref) object and delete previous one if existing
""" assign(this::ByRef1{TFitResultPtr}, rhs::ByConstRef1{TFitResultPtr})

# Wrapper of void TF1::AddParameter(const TString &, Double_t)
@trydoc raw"""
    AddParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)::Nothing


""" AddParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of Bool_t TF1::AddToGlobalList(Bool_t)
@trydoc raw"""
    AddToGlobalList(this::ByRef1{TF1}, on::Bool)::Bool
Add to global_ list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the function was already in the list false if not)

""" AddToGlobalList(this::ByRef1{TF1}, on::Bool)

# Wrapper of void TF1::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TF1}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TF1}, b::ByPtr1{TBrowser})

# Wrapper of Double_t TF1::CentralMoment(Double_t, Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    CentralMoment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return nth central moment of function between a and b (i.e the n-th moment around the mean value)
See [TF1!Integral()](@ref) for parameter definitions

###Author

Gene Van Buren gene@bnl.gov
""" CentralMoment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of TH1 * TF1::CreateHistogram()
@trydoc raw"""
    CreateHistogram(this::ByRef1{TF1})::CxxPtr1{TH1}


""" CreateHistogram(this::ByRef1{TF1})

# Wrapper of Int_t TF1::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TF1}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a function.
Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.

Note that px is called with a negative value when the [TF1](@ref) is in [TGraph](@ref) or [TH1](@ref) list of functions. In this case there is no point looking at the histogram axis.
""" DistancetoPrimitive(this::ByRef1{TF1}, px::Int32, py::Int32)

# Wrapper of void TF1::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TF1}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.
Possible option values are:

| **option** | **description**                                  |
|:-----------|:-------------------------------------------------|
| "SAME"     | superimpose on top of existing picture           |
| "L"        | connect all computed points with a straight line |
| "C"        | connect all computed points with a smooth curve  |
| "FC"       | draw a fill area below a smooth curve            |

Note that the default value is "L". Therefore to draw on top of an existing picture, specify option "LSAME"

NB. You must use DrawCopy if you want to draw several times the same function in the current canvas.
""" Draw(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of TObject * TF1::DrawDerivative(Option_t *)
@trydoc raw"""
    DrawDerivative(this::ByRef1{TF1}, option::ByCopy{String})::CxxPtr1{TObject}
Draw derivative of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawDerivative(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawDerivative(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of void TF1::DrawF1(Double_t, Double_t, Option_t *)
@trydoc raw"""
    DrawF1(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, option::ByCopy{String})::Nothing
Draw function between xmin and xmax.

""" DrawF1(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, option::ByCopy{String})

# Wrapper of TObject * TF1::DrawIntegral(Option_t *)
@trydoc raw"""
    DrawIntegral(this::ByRef1{TF1}, option::ByCopy{String})::CxxPtr1{TObject}
Draw integral of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawIntegral(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawIntegral(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of Double_t TF1::EvalPar(const Double_t *, const Double_t *)
@trydoc raw"""
    EvalPar(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Float64
Evaluate function with given coordinates and parameters.
Compute the value of this function at point defined by array x and current values of parameters in array params. If argument params is omitted or equal 0, the internal values of parameters (array fParams) will be used instead. For a 1-D function only x[0] must be given. In case of a multi-dimensional function, the arrays x must be filled with the corresponding number of dimensions.

WARNING. In case of an interpreted function (fType=2), it is the user's responsibility to initialize the parameters via InitArgs before calling this function. InitArgs should be called at least once to specify the addresses of the arguments x and params. InitArgs should be called every time these addresses change.
""" EvalPar(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of void TF1::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TF1}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a F1 is clicked with the locator
""" ExecuteEvent(this::ByRef1{TF1}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TF1::FixParameter(Int_t, Double_t)
@trydoc raw"""
    FixParameter(this::ByRef1{TF1}, ipar::Int32, value::Float64)::Nothing
Fix the value of a parameter for a fit operation The specified value will be used in the fit and the parameter will be constant (nor varying) during fitting Note that when using pre-defined functions (e.g gaus), one needs to use the fit option 'B' to have the fix of the paramter effective.
See [TH1!Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t)](@ref) for the fitting documentation and the fitting options.
""" FixParameter(this::ByRef1{TF1}, ipar::Int32, value::Float64)

# Wrapper of TFormula * TF1::GetFormula()
@trydoc raw"""
    GetFormula(this::ByRef1{TF1})::CxxPtr1{TFormula}


""" GetFormula(this::ByRef1{TF1})

# Wrapper of void TF1::GetParameters(Double_t *)
@trydoc raw"""
    GetParameters(this::ByRef1{TF1}, params::ByPtr2{Float64})::Nothing


""" GetParameters(this::ByRef1{TF1}, params::ByPtr2{Float64})

# Wrapper of Int_t TF1::GetQuantiles(Int_t, Double_t *, const Double_t *)
@trydoc raw"""
    GetQuantiles(this::ByRef1{TF1}, nprobSum::Int32, q::ByPtr2{Float64}, probSum::ByConstPtr2{Float64})::Int32
Compute Quantiles for density distribution of this function.
Quantile x_q of a probability distribution Function F is defined as 

``F(x_{q}) = \int_{xmin}^{x_{q}} f dx = q with 0 <= q <= 1.``

 For instance the median $ x_{\frac{1}{2}} $ of a distribution is defined as that value of the random variable for which the distribution function equals 0.5: 

``F(x_{\frac{1}{2}}) = \prod(x < x_{\frac{1}{2}}) = \frac{1}{2}``

## Arguments

- **`nprobSum`** [in] 
    maximum size of array q and size of array probSum 
    
- **`q`** [out] 
    array filled with nq quantiles 
    
- **`probSum`** [in] 
    array of positions where quantiles will be computed. It is assumed to contain at least nprobSum values. 
    

###Return

value nq (<=nprobSum) with the number of quantiles computed

Getting quantiles from two histograms and storing results in a [TGraph](@ref), a so-called QQ-plot 
```
TGraph *gr = new TGraph(nprob);
f1->GetQuantiles(nprob,gr->GetX());
f2->GetQuantiles(nprob,gr->GetY());
gr->Draw("alp");
```  

###Author

Eddy Offermann
""" GetQuantiles(this::ByRef1{TF1}, nprobSum::Int32, q::ByPtr2{Float64}, probSum::ByConstPtr2{Float64})

# Wrapper of Double_t TF1::GetRandom(Double_t, Double_t, TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape in [xmin,xmax].
The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents. It is normalized to 1. For each bin the integral is approximated by a parabola. The parabola coefficients are stored as non persistent data members Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Evaluate the parabolic curve in the selected bin to find the corresponding X value.

The parabolic approximation is very good as soon as the number of bins is greater than 50.

## Arguments

- **`xmin`** 
    minimum value for generated random numbers 
    
- **`xmax`** 
    maximum value for generated random numbers 
    
- **`rng`** 
    (optional) random number generator pointer 
    
- **`option`** 
    (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table
    

IMPORTANT NOTE

The integral of the function is computed at fNpx points. If the function has sharp peaks, you should increase the number of points (SetNpx) such that the peak is correctly tabulated at several points.
""" GetRandom(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of Double_t TF1::GetRandom(TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF1}, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape.
## Arguments

- **`rng`** 
    Random number generator. By default (or when passing a nullptr) the global_ gRandom is used 
    
- **`option`** 
    Option string which controls the binning used to compute the integral. Default mode is automatic depending of xmax, xmin and Npx (function points). Possible values are:
    
    - "LOG" to force usage of log scale for tabulating the integral
    - "LIN" to force usage of linear scale when tabulating the integral
    
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents. It is normalized to 1. For each bin the integral is approximated by a parabola. The parabola coefficients are stored as non persistent data members Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Evaluate the parabolic curve in the selected bin to find the corresponding X value.

The user can provide as optional parameter a Random number generator. By default gRandom is used

If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x A log scale for the intergral is also always used if a user specifies the "LOG" option Instead if a user requestes a "LIN" option the integral binning is never done in log scale whatever the fXmax/fXmin ratio is

Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.
""" GetRandom(this::ByRef1{TF1}, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of Double_t TF1::GetSave(const Double_t *)
@trydoc raw"""
    GetSave(this::ByRef1{TF1}, x::ByConstPtr2{Float64})::Float64
Get value corresponding to X in array of fSave values.

""" GetSave(this::ByRef1{TF1}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF1::GetVariable(const TString &)
@trydoc raw"""
    GetVariable(this::ByRef1{TF1}, name::ByConstRef1{TString})::Float64


""" GetVariable(this::ByRef1{TF1}, name::ByConstRef1{TString})

# Wrapper of void TF1::GradientPar(const Double_t *, Double_t *, Double_t)
@trydoc raw"""
    GradientPar(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, grad::ByPtr2{Float64}, eps::Float64)::Nothing
Compute the gradient wrt parameters If the [TF1](@ref) object is based on a formula expression ([TFormula](@ref)) and [TFormula!GenerateGradientPar()](@ref) has been successfully called automatic differentiation using CLAD is used instead of the default numerical differentiation.
## Arguments

- **`x`** 
    point, were the gradient is computed 
    
- **`grad`** 
    used to return the computed gradient, assumed to be of at least fNpar size 
    
- **`eps`** 
    if the errors of parameters have been computed, the step used in numerical differentiation is eps*parameter_error.
    

if the errors have not been computed, step=eps is used default value of eps = 0.01 Method is the same as in [Derivative()](@ref) function

If a parameter is fixed, the gradient on this parameter = 0
""" GradientPar(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, grad::ByPtr2{Float64}, eps::Float64)

# Wrapper of Double_t TF1::GradientPar(Int_t, const Double_t *, Double_t)
@trydoc raw"""
    GradientPar(this::ByRef1{TF1}, ipar::Int32, x::ByConstPtr2{Float64}, eps::Float64)::Float64
Compute the gradient (derivative) wrt a parameter ipar.
## Arguments

- **`ipar`** 
    index of parameter for which the derivative is computed 
    
- **`x`** 
    point, where the derivative is computed 
    
- **`eps`** 
    - if the errors of parameters have been computed, the step used in numerical differentiation is eps*parameter_error.
    

if the errors have not been computed, step=eps is used default value of eps = 0.01 Method is the same as in [Derivative()](@ref) function

If a parameter is fixed, the gradient on this parameter = 0
""" GradientPar(this::ByRef1{TF1}, ipar::Int32, x::ByConstPtr2{Float64}, eps::Float64)

# Wrapper of void TF1::InitArgs(const Double_t *, const Double_t *)
@trydoc raw"""
    InitArgs(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Nothing
Initialize parameters addresses.

""" InitArgs(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of Double_t TF1::Integral(Double_t, Double_t, Double_t)
@trydoc raw"""
    Integral(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64)::Float64
IntegralOneDim or analytical integral.

""" Integral(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64)

# Wrapper of Double_t TF1::IntegralError(Double_t, Double_t, const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    IntegralError(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return Error on Integral of a parametric function between a and b due to the parameter uncertainties and their covariance matrix from the fit.
In addition to the integral limits, this method takes as input a pointer to the fitted parameter values and a pointer the covariance matrix from the fit. These pointers should be retrieved from the previously performed fit using the [TFitResult](@ref) class. Note that to get the [TFitResult](@ref), te fit should be done using the fit option `S`. Example: 

    TFitResultPtr r = histo->Fit(func, "S");
    func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );

(C++ version of the code)

IMPORTANT NOTE1:

A null pointer to the parameter values vector and to the covariance matrix can be passed. In this case, when the parameter values pointer is null, the parameter values stored in this [TF1](@ref) function object are used in the integral error computation. When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved from a global_ fitter instance when it exists. Note that the global_ fitter instance esists only when [ROOT](@ref) is not running with multi-threading enabled ([ROOT!IsImplicitMTEnabled()](@ref) == True). When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is returned.

IMPORTANT NOTE2:

When no covariance matrix is passed and in the meantime a fit is done using another function, the routine will signal an error and it will return zero only when the number of fit parameter is different than the values stored in [TF1](@ref) ([TF1!GetNpar()](@ref) ). In the case that npar is the same, an incorrect result is returned.

IMPORTANT NOTE3:

The user must pass a pointer to the elements of the full covariance matrix dimensioned with the right size (npar*npar), where npar is the total number of parameters ([TF1!GetNpar()](@ref)), including also the fixed parameters. The covariance matrix must be retrieved from the [TFitResult](@ref) class as shown above and not from [TVirtualFitter!GetCovarianceMatrix()](@ref) function.
""" IntegralError(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::IntegralError(Int_t, const Double_t *, const Double_t *, const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    IntegralError(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return Error on Integral of a parametric function with dimension larger than one between a[] and b[] due to the parameters uncertainties.
For a [TF1](@ref) with dimension larger than 1 (for example a [TF2](@ref) or [TF3](@ref)) [TF1!IntegralMultiple](@ref) is used for the integral calculation

In addition to the integral limits, this method takes as input a pointer to the fitted parameter values and a pointer the covariance matrix from the fit. These pointers should be retrieved from the previously performed fit using the [TFitResult](@ref) class. Note that to get the [TFitResult](@ref), te fit should be done using the fit option `S`. Example: 

    TFitResultPtr r = histo2d->Fit(func2, "S");
    func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );

(C++ version of the code)

IMPORTANT NOTE1:

A null pointer to the parameter values vector and to the covariance matrix can be passed. In this case, when the parameter values pointer is null, the parameter values stored in this [TF1](@ref) function object are used in the integral error computation. When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved from a global_ fitter instance when it exists. Note that the global_ fitter instance esists only when [ROOT](@ref) is not running with multi-threading enabled ([ROOT!IsImplicitMTEnabled()](@ref) == True). When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is returned.

IMPORTANT NOTE2:

When no covariance matrix is passed and in the meantime a fit is done using another function, the routine will signal an error and it will return zero only when the number of fit parameter is different than the values stored in [TF1](@ref) ([TF1!GetNpar()](@ref) ). In the case that npar is the same, an incorrect result is returned.

IMPORTANT NOTE3:

The user must pass a pointer to the elements of the full covariance matrix dimensioned with the right size (npar*npar), where npar is the total number of parameters ([TF1!GetNpar()](@ref)), including also the fixed parameters. The covariance matrix must be retrieved from the [TFitResult](@ref) class as shown above and not from [TVirtualFitter!GetCovarianceMatrix()](@ref)
""" IntegralError(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::IntegralFast(Int_t, Double_t *, Double_t *, Double_t, Double_t, Double_t *, Double_t)
@trydoc raw"""
    IntegralFast(this::ByRef1{TF1}, num::Int32, x::ByPtr2{Float64}, w::ByPtr2{Float64}, a::Float64, b::Float64, params::ByPtr2{Float64}, epsilon::Float64)::Float64
Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints.

""" IntegralFast(this::ByRef1{TF1}, num::Int32, x::ByPtr2{Float64}, w::ByPtr2{Float64}, a::Float64, b::Float64, params::ByPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::IntegralMultiple(Int_t, const Double_t *, const Double_t *, Double_t, Double_t &)
@trydoc raw"""
    IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, epsrel::Float64, relerr::ByRef2{Float64})::Float64
See more general prototype below.
This interface kept for back compatibility It is recommended to use the other interface where one can specify also epsabs and the maximum number of points
""" IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, epsrel::Float64, relerr::ByRef2{Float64})

# Wrapper of Double_t TF1::IntegralMultiple(Int_t, const Double_t *, const Double_t *, Int_t, Double_t, Double_t, Double_t &, Int_t &, Int_t &)
@trydoc raw"""
    IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, maxpts::Int32, epsrel::Float64, epsabs::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})::Float64
This function computes, to an attempted specified accuracy, the value of the integral.
## Arguments

- **`n`** [in], **`a`** [in], **`b`** [in], **`maxpts`** [in], **`epsrel`** [in], **`epsabs`** [in], **`relerr`** [out], **`nfnevl`** [out], **`ifail`** [out] 
    Number of dimensions [2,15] 
    . 
    One-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. 
    . 
    Maximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts 
    . 
    Specified relative accuracy. 
    . 
    Specified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy
    . 
    Contains, on exit, an estimation of the relative accuracy of the result. 
    . 
    number of function evaluations performed. 
    . 
    0 Normal exit. At least minpts and at most maxpts calls to the function were performed.
    
    1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.
    
    3 n<2 or n>15 
    
    

Method:

The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class [ROOT!Math!AdaptiveIntegratorMultiDim](@ref) (see the reference documentation of the class)

Other methods can be used by setting [ROOT!Math!IntegratorMultiDimOptions!SetDefaultIntegrator()](@ref) to different integrators. Other possible integrators are MC integrators based on the [ROOT!Math!GSLMCIntegrator](@ref) class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts
""" IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, maxpts::Int32, epsrel::Float64, epsabs::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})

# Wrapper of Double_t TF1::IntegralMultiple(Int_t, const Double_t *, const Double_t *, Int_t, Int_t, Double_t, Double_t &, Int_t &, Int_t &)
@trydoc raw"""
    IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, ::Int32, maxpts::Int32, epsrel::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})::Float64


""" IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, ::Int32, maxpts::Int32, epsrel::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})

# Wrapper of Double_t TF1::IntegralOneDim(Double_t, Double_t, Double_t, Double_t, Double_t &)
@trydoc raw"""
    IntegralOneDim(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64, epsabs::Float64, err::ByRef2{Float64})::Float64
Return Integral of function between a and b using the given parameter values and relative and absolute tolerance.
The default integrator defined in [ROOT!Math!IntegratorOneDimOptions!DefaultIntegrator()](@ref) is used If [ROOT](@ref) contains the MathMore library the default integrator is set to be the adaptive [ROOT!Math!GSLIntegrator](@ref) (based on QUADPACK) or otherwise the [ROOT!Math!GaussIntegrator](@ref) is used See the reference documentation of these classes for more information about the integration algorithms To change integration algorithm just do : ROOT!Math!IntegratorOneDimOptions!SetDefaultIntegrator(IntegratorName); Valid integrator names are:

- Gauss : for [ROOT!Math!GaussIntegrator](@ref)
- GaussLegendre : for [ROOT!Math!GaussLegendreIntegrator](@ref)
- Adaptive : for [ROOT!Math!GSLIntegrator](@ref) adaptive method (QAG)
- AdaptiveSingular : for [ROOT!Math!GSLIntegrator](@ref) adaptive singular method (QAGS)
- NonAdaptive : for [ROOT!Math!GSLIntegrator](@ref) non adaptive (QNG)

In order to use the GSL integrators one needs to have the MathMore library installed

Note 1:

Values of the function [f(x)](@ref) at the interval theend-points A and B are not required. The subprogram may therefore be used when these values are undefined.

Note 2:

Instead of [TF1!Integral](@ref), you may want to use the combination of [TF1!CalcGaussLegendreSamplingPoints](@ref) and [TF1!IntegralFast](@ref). See an example with the following script:

    void gint() {
       TF1 *g = new TF1("g","gaus",-5,5);
       g->SetParameters(1,0,1);
       //default gaus integration method uses 6 points
       //not suitable to integrate on a large domain
       double r1 = g->Integral(0,5);
       double r2 = g->Integral(0,1000);
       //try with user directives computing more points
       Int_t np = 1000;
       double *x=new double[np];
       double *w=new double[np];
       g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);
       double r3 = g->IntegralFast(np,x,w,0,5);
       double r4 = g->IntegralFast(np,x,w,0,1000);
       double r5 = g->IntegralFast(np,x,w,0,10000);
       double r6 = g->IntegralFast(np,x,w,0,100000);
       printf("g->Integral(0,5)               = %g\n",r1);
       printf("g->Integral(0,1000)            = %g\n",r2);
       printf("g->IntegralFast(n,x,w,0,5)     = %g\n",r3);
       printf("g->IntegralFast(n,x,w,0,1000)  = %g\n",r4);
       printf("g->IntegralFast(n,x,w,0,10000) = %g\n",r5);
       printf("g->IntegralFast(n,x,w,0,100000)= %g\n",r6);
       delete [] x;
       delete [] w;
    }

(C++ version of the code)

This example produces the following results:

    g->Integral(0,5)               = 1.25331
    g->Integral(0,1000)            = 1.25319
    g->IntegralFast(n,x,w,0,5)     = 1.25331
    g->IntegralFast(n,x,w,0,1000)  = 1.25331
    g->IntegralFast(n,x,w,0,10000) = 1.25331
    g->IntegralFast(n,x,w,0,100000)= 1.253

(C++ version of the code)
""" IntegralOneDim(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64, epsabs::Float64, err::ByRef2{Float64})

# Wrapper of bool TF1::IsVectorized()
@trydoc raw"""
    IsVectorized(this::ByRef1{TF1})::Bool


""" IsVectorized(this::ByRef1{TF1})

# Wrapper of Double_t TF1::Mean(Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    Mean(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64


""" Mean(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::Moment(Double_t, Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    Moment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return nth moment of function between a and b.
See [TF1!Integral()](@ref) for parameter definitions
""" Moment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of TF1 & TF1::operator=(const TF1 &)
@trydoc raw"""
    assign(this::ByRef1{TF1}, rhs::ByConstRef1{TF1})::CxxRef1{TF1}
Operator =.

""" assign(this::ByRef1{TF1}, rhs::ByConstRef1{TF1})

# Wrapper of void TF1::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TF1}, option::ByCopy{String})::Nothing
Paint this function with its current attributes.
The function is going to be converted in an histogram and the corresponding histogram is painted. The painted histogram can be retrieved calling afterwards the method [TF1!GetHistogram()](@ref)
""" Paint(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of void TF1::ReleaseParameter(Int_t)
@trydoc raw"""
    ReleaseParameter(this::ByRef1{TF1}, ipar::Int32)::Nothing
Release parameter number ipar during a fit operation.
After releasing it, the parameter can vary freely in the fit. The parameter limits are reset to 0,0.
""" ReleaseParameter(this::ByRef1{TF1}, ipar::Int32)

# Wrapper of void TF1::Save(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Save(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Nothing
Save values of function in array fSave.

""" Save(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TF1::SetChisquare(Double_t)
@trydoc raw"""
    SetChisquare(this::ByRef1{TF1}, chi2::Float64)::Nothing


""" SetChisquare(this::ByRef1{TF1}, chi2::Float64)

# Wrapper of void TF1::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TF1}, maximum::Float64)::Nothing
Set the maximum value along Y for this function In case the function is already drawn, set also the maximum in the helper histogram.

""" SetMaximum(this::ByRef1{TF1}, maximum::Float64)

# Wrapper of void TF1::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TF1}, minimum::Float64)::Nothing
Set the minimum value along Y for this function In case the function is already drawn, set also the minimum in the helper histogram.

""" SetMinimum(this::ByRef1{TF1}, minimum::Float64)

# Wrapper of void TF1::SetNDF(Int_t)
@trydoc raw"""
    SetNDF(this::ByRef1{TF1}, ndf::Int32)::Nothing
Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of free parameters.

""" SetNDF(this::ByRef1{TF1}, ndf::Int32)

# Wrapper of void TF1::SetNormalized(Bool_t)
@trydoc raw"""
    SetNormalized(this::ByRef1{TF1}, flag::Bool)::Nothing


""" SetNormalized(this::ByRef1{TF1}, flag::Bool)

# Wrapper of void TF1::SetNpx(Int_t)
@trydoc raw"""
    SetNpx(this::ByRef1{TF1}, npx::Int32)::Nothing
Set the number of points used to draw the function.
The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions You can increase this value to get a better resolution when drawing pictures with sharp peaks or to get a better result when using [TF1!GetRandom](@ref) the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions
""" SetNpx(this::ByRef1{TF1}, npx::Int32)

# Wrapper of void TF1::SetNumberFitPoints(Int_t)
@trydoc raw"""
    SetNumberFitPoints(this::ByRef1{TF1}, npfits::Int32)::Nothing


""" SetNumberFitPoints(this::ByRef1{TF1}, npfits::Int32)

# Wrapper of void TF1::SetParameter(const TString &, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TF1::SetParameter(Int_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1}, param::Int32, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1}, param::Int32, value::Float64)

# Wrapper of void TF1::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1}, params::ByConstPtr2{Float64})::Nothing


""" SetParameters(this::ByRef1{TF1}, params::ByConstPtr2{Float64})

# Wrapper of void TF1::SetParameters(double, double, double, double, double, double, double, double, double, double, double)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)::Nothing
Set parameter values.
NaN values will be skipped, meaning that the corresponding parameters will not be changed.
""" SetParameters(this::ByRef1{TF1}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)

# Wrapper of void TF1::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TF1}, p::ByPtr1{TObject})::Nothing


""" SetParent(this::ByRef1{TF1}, p::ByPtr1{TObject})

# Wrapper of void TF1::SetParError(Int_t, Double_t)
@trydoc raw"""
    SetParError(this::ByRef1{TF1}, ipar::Int32, error::Float64)::Nothing
Set error for parameter number ipar.

""" SetParError(this::ByRef1{TF1}, ipar::Int32, error::Float64)

# Wrapper of void TF1::SetParErrors(const Double_t *)
@trydoc raw"""
    SetParErrors(this::ByRef1{TF1}, errors::ByConstPtr2{Float64})::Nothing
Set errors for all active parameters when calling this function, the array errors must have at least fNpar values.

""" SetParErrors(this::ByRef1{TF1}, errors::ByConstPtr2{Float64})

# Wrapper of void TF1::SetParLimits(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetParLimits(this::ByRef1{TF1}, ipar::Int32, parmin::Float64, parmax::Float64)::Nothing
Set lower and upper limits for parameter ipar.
The specified limits will be used in a fit operation. Note that when this function is a pre-defined function (e.g. gaus) one needs to use the fit option "B" to have the limits used in the fit. See [TH1!Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t)](@ref) for the fitting documentation and the [fitting options](@ref)

To fix a parameter, use [TF1!FixParameter](@ref)
""" SetParLimits(this::ByRef1{TF1}, ipar::Int32, parmin::Float64, parmax::Float64)

# Wrapper of void TF1::SetParName(Int_t, const char *)
@trydoc raw"""
    SetParName(this::ByRef1{TF1}, ipar::Int32, name::ByCopy{String})::Nothing
Set name of parameter number ipar.

""" SetParName(this::ByRef1{TF1}, ipar::Int32, name::ByCopy{String})

# Wrapper of void TF1::SetParNames(const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *)
@trydoc raw"""
    SetParNames(this::ByRef1{TF1}, name0::ByCopy{String}, name1::ByCopy{String}, name2::ByCopy{String}, name3::ByCopy{String}, name4::ByCopy{String}, name5::ByCopy{String}, name6::ByCopy{String}, name7::ByCopy{String}, name8::ByCopy{String}, name9::ByCopy{String}, name10::ByCopy{String})::Nothing
Set up to 10 parameter names.
Empty strings will be skipped, meaning that the corresponding name will not be changed.
""" SetParNames(this::ByRef1{TF1}, name0::ByCopy{String}, name1::ByCopy{String}, name2::ByCopy{String}, name3::ByCopy{String}, name4::ByCopy{String}, name5::ByCopy{String}, name6::ByCopy{String}, name7::ByCopy{String}, name8::ByCopy{String}, name9::ByCopy{String}, name10::ByCopy{String})

# Wrapper of void TF1::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1}, xmin::Float64, xmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.
The function range is also used in an histogram fit operation when the option "R" is specified.
""" SetRange(this::ByRef1{TF1}, xmin::Float64, xmax::Float64)

# Wrapper of void TF1::SetRange(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing


""" SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TF1::SetRange(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)::Nothing


""" SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)

# Wrapper of void TF1::SetSavedPoint(Int_t, Double_t)
@trydoc raw"""
    SetSavedPoint(this::ByRef1{TF1}, point::Int32, value::Float64)::Nothing
Restore value of function saved at point.

""" SetSavedPoint(this::ByRef1{TF1}, point::Int32, value::Float64)

# Wrapper of void TF1::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TF1}, title::ByCopy{String})::Nothing
Set function title if title has the form "fffffff;xxxx;yyyy", it is assumed that the function title is "fffffff" and "xxxx" and "yyyy" are the titles for the X and Y axis respectively.

""" SetTitle(this::ByRef1{TF1}, title::ByCopy{String})

# Wrapper of void TF1::SetVectorized(Bool_t)
@trydoc raw"""
    SetVectorized(this::ByRef1{TF1}, vectorized::Bool)::Nothing


""" SetVectorized(this::ByRef1{TF1}, vectorized::Bool)

# Wrapper of void TF1::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1})::Nothing
Called by functions such as SetRange, SetNpx, SetParameters to force the deletion of the associated histogram or Integral.

""" Update(this::ByRef1{TF1})

# Wrapper of Double_t TF1::Variance(Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    Variance(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64


""" Variance(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of void TGraph::AddPoint(Double_t, Double_t)
@trydoc raw"""
    AddPoint(this::ByRef1{TGraph}, x::Float64, y::Float64)::Nothing
Append a new point to the graph.

""" AddPoint(this::ByRef1{TGraph}, x::Float64, y::Float64)

# Wrapper of void TGraph::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraph}, f::ByPtr1{TF1})::Nothing
Apply function f to all the data points f may be a 1-D function [TF1](@ref) or 2-d function [TF2](@ref) The Y values of the graph are replaced by the new values computed using the function.

""" Apply(this::ByRef1{TGraph}, f::ByPtr1{TF1})

# Wrapper of void TGraph::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGraph}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TGraph}, b::ByPtr1{TBrowser})

# Wrapper of Int_t TGraph::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGraph}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a graph.
Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TGraph}, px::Int32, py::Int32)

# Wrapper of void TGraph::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGraph}, chopt::ByCopy{String})::Nothing
Draw this graph with its current attributes.
The options to draw a graph are described in [TGraphPainter](@ref) class.
""" Draw(this::ByRef1{TGraph}, chopt::ByCopy{String})

# Wrapper of void TGraph::DrawGraph(Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, option::ByCopy{String})::Nothing
Draw this graph with new attributes.

""" DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TGraph::DrawGraph(Int_t, const Float_t *, const Float_t *, Option_t *)
@trydoc raw"""
    DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32}, option::ByCopy{String})::Nothing
Draw this graph with new attributes.

""" DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32}, option::ByCopy{String})

# Wrapper of void TGraph::DrawGraph(Int_t, const Int_t *, const Int_t *, Option_t *)
@trydoc raw"""
    DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Int32}, y::ByConstPtr2{Int32}, option::ByCopy{String})::Nothing
Draw this graph with new attributes.

""" DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Int32}, y::ByConstPtr2{Int32}, option::ByCopy{String})

# Wrapper of void TGraph::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TGraph})::Nothing
Display a panel with all graph drawing options.

""" DrawPanel(this::ByRef1{TGraph})

# Wrapper of void TGraph::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGraph}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a graph is clicked with the locator

If Left button clicked on one of the line theend points, this point follows the cursor until button is released.

if Middle button clicked, the line is moved parallel to itself until the button is released.
""" ExecuteEvent(this::ByRef1{TGraph}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TGraph::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TGraph}, newsize::Int32)::Nothing
If array sizes <= newsize, expand storage to 2*newsize.

""" Expand(this::ByRef1{TGraph}, newsize::Int32)

# Wrapper of void TGraph::Expand(Int_t, Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TGraph}, newsize::Int32, step::Int32)::Nothing
If graph capacity is less than newsize points then make array sizes equal to least multiple of step to contain newsize points.

""" Expand(this::ByRef1{TGraph}, newsize::Int32, step::Int32)

# Wrapper of TFitResultPtr TGraph::Fit(const char *, Option_t *, Option_t *, Axis_t, Axis_t)
@trydoc raw"""
    Fit(this::ByRef1{TGraph}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit this graph with function with name `fname`.
This is a different interface to [TGraph](@ref) fitting using [TGraph!Fit(TF1 *f1,Option_t *, Option_t *, Axis_t, Axis_t)](@ref) See there for the details about fitting a [TGraph](@ref).

The parameter `fname` is the name of an already predefined function created by [TF1](@ref) or [TF2](@ref) Predefined functions such as gaus, expo and poln are automatically created by [ROOT](@ref).

The parameter `fname` can also be a formula, accepted by the linear fitter (linear parts divided by "++" sign), for example "x++sin(x)" for fitting "[0]*x+[1]*sin(x)"
""" Fit(this::ByRef1{TGraph}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of TFitResultPtr TGraph::Fit(TF1 *, Option_t *, Option_t *, Axis_t, Axis_t)
@trydoc raw"""
    Fit(this::ByRef1{TGraph}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit this graph with function f1.
## Arguments

- **`f1`** [in] 
    pointer to the function object 
    
- **`option`** [in] 
    string defining the fit options (see table below). 
    
- **`goption`** [in] 
    specify a list of graphics options. See [TGraph!Draw](@ref) and [TGraphPainter](@ref) for a complete list of these possible options. 
    
- **`rxmin`** [in] 
    lower fitting range 
    
- **`rxmax`** [in] 
    upper fitting range
    

### Graph Fitting Options

The list of fit options is given in parameter option.

| **option** | **description**                                                                                                                                                                                                                           |
|:-----------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "S"        | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT!Math!FitResult`.                                                         |
| "W"        | Ignore all point errors when fitting a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref)                                                                                                                                                  |
| "F"        | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.                                                                                                                         |
| "U"        | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter!SetFCN`                                                                                                                    |
| "E"        | Performs a better parameter errors estimation using the Minos technique for all fit parameters.                                                                                                                                           |
| "M"        | Uses the IMPROVE algorithm (available only in [TMinuit](@ref)). This algorithm attempts improve the found local_ minimum by searching for a better one.                                                                                   |
| "Q"        | Quiet mode (minimum printing)                                                                                                                                                                                                             |
| "V"        | Verbose mode (default is between Q and V)                                                                                                                                                                                                 |
| "+"        | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.                                                                                                |
| "N"        | Does not store the graphics function, does not draw the histogram with the function after fitting.                                                                                                                                        |
| "0"        | Does not draw the histogram and the fitted function after fitting, but in contrast to option "N", it stores the fitted function in the histogram list of functions.                                                                       |
| "R"        | Fit using a fitting range specified in the function range with `TF1!SetRange`.                                                                                                                                                            |
| "B"        | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.                 |
| "C"        | In case of linear fitting, do no calculate the chisquare (saves CPU time).                                                                                                                                                                |
| "G"        | Uses the gradient implemented in `TF1!GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided [TF1](@ref) function.                                                          |
| "EX0"      | When fitting a [TGraphErrors](@ref) or TGraphAsymErrors do not consider errors in the X coordinates                                                                                                                                       |
| "ROB"      | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points "ROB=0.x" - compute the LTS regression coefficients, using 0.x as a fraction of good points |

This function is used for fitting also the derived [TGraph](@ref) classes such as [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref). See the note below on how the errors are used when fitting a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref).

The fitting of the [TGraph](@ref), i.e simple data points without any error associated, is performed using the un-weighted least-square (chi-square) method.

### TGraphErrors fit:

In case of a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref) object, when `x` errors are present, the error along x, is projected along the y-direction by calculating the function at the points `x-ex_low` and `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x. The chi-square is then computed as the sum of the quantity below at each data point:

``\frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}``

where `x` and `y` are the point coordinates, and 'f'(x)`is the derivative of the function`[f(x)](@ref)`.

In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).

The approach used to approximate the uncertainty in y because of the errors in x is to make it equal the error in x times the slope of the line. This approach is called "effective variance method" and the implementation is provided in the function FitUtil!EvaluateChi2Effective

### Linear fitting:

When the fitting function is linear (contains the `++` sign) or the fitting function is a polynomial, a linear fitter is initialised. To create a linear function, use the following syntax: linear parts separated by `++` sign. Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a [TF1](@ref) object as 
```
TF1 *f1 = new TF1("f1", "x++sin(x)", xmin, xmax);
```  For such a [TF1](@ref) you don't have to set the initial conditions and the linear fitter is used. Going via the linear fitter for functions, linear in parameters, gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`. See the tutorial `fitLinearRobust.C`.

### Notes on TGraph/TGraphErrors Fitting:

1. By using the "effective variance" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.
2. The effective variance technique assumes that there is no correlation between the x and y coordinate.
3. The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option "EX0"
4. The linear fitter doesn't take into account the errors in x. When fitting a [TGraphErrors](@ref) with a linear functions the errors in x will not be considered. If errors in x are important, use option "F" for linear function fitting.
5. When fitting a [TGraph](@ref) (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: `parameter_error *= sqrt(chisquare/(ndf-1))`

### General Fitting documentation

See in [TH1!Fit](@ref) for the documentation of

- [Fit Result](@ref)
- [Fit Status](@ref)
- [Fit Statistics Box](@ref)
- [Fitting in a Range](@ref)
- [Setting Initial Conditions](@ref)
""" Fit(this::ByRef1{TGraph}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::FitPanel()
@trydoc raw"""
    FitPanel(this::ByRef1{TGraph})::Nothing
Display a GUI panel with all graph fit options.
See class [TFitEditor](@ref) for example
""" FitPanel(this::ByRef1{TGraph})

# Wrapper of void TGraph::InitExpo(Double_t, Double_t)
@trydoc raw"""
    InitExpo(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)::Nothing
Compute Initial values of parameters for an exponential.

""" InitExpo(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::InitGaus(Double_t, Double_t)
@trydoc raw"""
    InitGaus(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)::Nothing
Compute Initial values of parameters for a gaussian.

""" InitGaus(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::InitPolynom(Double_t, Double_t)
@trydoc raw"""
    InitPolynom(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)::Nothing
Compute Initial values of parameters for a polynom.

""" InitPolynom(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of Int_t TGraph::InsertPoint()
@trydoc raw"""
    InsertPoint(this::ByRef1{TGraph})::Int32
Insert a new point at the mouse position.

""" InsertPoint(this::ByRef1{TGraph})

# Wrapper of void TGraph::InsertPointBefore(Int_t, Double_t, Double_t)
@trydoc raw"""
    InsertPointBefore(this::ByRef1{TGraph}, ipoint::Int32, x::Float64, y::Float64)::Nothing
Insert a new point with coordinates (x,y) before the point number `ipoint`.

""" InsertPointBefore(this::ByRef1{TGraph}, ipoint::Int32, x::Float64, y::Float64)

# Wrapper of void TGraph::LeastSquareFit(Int_t, Double_t *, Double_t, Double_t)
@trydoc raw"""
    LeastSquareFit(this::ByRef1{TGraph}, m::Int32, a::ByPtr2{Float64}, xmin::Float64, xmax::Float64)::Nothing
Least squares polynomial fitting without weights.
## Arguments

- **`m`** [in] 
    number of parameters 
    
- **`a`** [in] 
    array of parameters 
    
- **`xmin`** [in] 
    1st point number to fit (default =0) 
    
- **`xmax`** [in] 
    last point number to fit (default=fNpoints-1)
    

based on CERNLIB routine LSQ: Translated to C++ by Rene Brun
""" LeastSquareFit(this::ByRef1{TGraph}, m::Int32, a::ByPtr2{Float64}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::LeastSquareLinearFit(Int_t, Double_t &, Double_t &, Int_t &, Double_t, Double_t)
@trydoc raw"""
    LeastSquareLinearFit(this::ByRef1{TGraph}, n::Int32, a0::ByRef2{Float64}, a1::ByRef2{Float64}, ifail::ByRef2{Int32}, xmin::Float64, xmax::Float64)::Nothing
Least square linear fit without weights.
Fit a straight line (a0 + a1*x) to the data in this graph.

## Arguments

- **`ndata`** [in], **`a0`** [in], **`a1`** [in], **`ifail`** [in], **`xmin`** [in], **`xmax`** [in] 
    if ndata<0, fits the logarithm of the graph (used in [InitExpo()](@ref) to set the initial parameter values for a fit with exponential function. 
    . 
    constant 
    . 
    slope 
    . 
    return parameter indicating the status of the fit (ifail=0, fit is OK) 
    . 
    fitting range
    

extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun
""" LeastSquareLinearFit(this::ByRef1{TGraph}, n::Int32, a0::ByRef2{Float64}, a1::ByRef2{Float64}, ifail::ByRef2{Int32}, xmin::Float64, xmax::Float64)

# Wrapper of Int_t TGraph::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TGraph}, list::ByPtr1{TCollection})::Int32
Adds all graphs from the collection to this graph.
Returns the total number of points in the result or -1 in case of an error.
""" Merge(this::ByRef1{TGraph}, list::ByPtr1{TCollection})

# Wrapper of void TGraph::MovePoints(Double_t, Double_t, Bool_t, Bool_t)
@trydoc raw"""
    MovePoints(this::ByRef1{TGraph}, dx::Float64, dy::Float64, logx::Bool, logy::Bool)::Nothing
Move all graph points on specified values dx,dy If log argument specified, calculation done in logarithmic scale like: new_value = exp( log(old_value) + delta );.

""" MovePoints(this::ByRef1{TGraph}, dx::Float64, dy::Float64, logx::Bool, logy::Bool)

# Wrapper of TGraph & TGraph::operator=(const TGraph &)
@trydoc raw"""
    assign(this::ByRef1{TGraph}, ::ByConstRef1{TGraph})::CxxRef1{TGraph}
Equal operator for this graph.

""" assign(this::ByRef1{TGraph}, ::ByConstRef1{TGraph})

# Wrapper of void TGraph::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGraph}, chopt::ByCopy{String})::Nothing
Draw this graph with its current attributes.

""" Paint(this::ByRef1{TGraph}, chopt::ByCopy{String})

# Wrapper of void TGraph::PaintGraph(Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGraph(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing
Draw the (x,y) as a graph.

""" PaintGraph(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TGraph::PaintGrapHist(Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGrapHist(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing
Draw the (x,y) as a histogram.

""" PaintGrapHist(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TGraph::PaintStats(TF1 *)
@trydoc raw"""
    PaintStats(this::ByRef1{TGraph}, fit::ByPtr1{TF1})::Nothing
Draw the stats.

""" PaintStats(this::ByRef1{TGraph}, fit::ByPtr1{TF1})

# Wrapper of void TGraph::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TGraph}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from the list of functions.

""" RecursiveRemove(this::ByRef1{TGraph}, obj::ByPtr1{TObject})

# Wrapper of Int_t TGraph::RemovePoint()
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph})::Int32
Delete point close to the mouse position Returns index of removed point (or -1 if nothing was changed)

""" RemovePoint(this::ByRef1{TGraph})

# Wrapper of Int_t TGraph::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph}, ipoint::Int32)::Int32
Delete point number ipoint Returns index of removed point (or -1 if nothing was changed)

""" RemovePoint(this::ByRef1{TGraph}, ipoint::Int32)

# Wrapper of void TGraph::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values of a [TGraph](@ref) by a constant c1.
If option contains "x" the x values are scaled If option contains "y" the y values are scaled If option contains "xy" both x and y values are scaled
""" Scale(this::ByRef1{TGraph}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph}, n::Int32)::Nothing
Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints are preset to 0.

""" Set(this::ByRef1{TGraph}, n::Int32)

# Wrapper of void TGraph::SetEditable(Bool_t)
@trydoc raw"""
    SetEditable(this::ByRef1{TGraph}, editable::Bool)::Nothing
if editable=kFALSE, the graph cannot be modified with the mouse by default a [TGraph](@ref) is editable

""" SetEditable(this::ByRef1{TGraph}, editable::Bool)

# Wrapper of void TGraph::SetHighlight(Bool_t)
@trydoc raw"""
    SetHighlight(this::ByRef1{TGraph}, set::Bool)::Nothing
Set highlight (enable/disable) mode for the graph by default highlight mode is disable.

""" SetHighlight(this::ByRef1{TGraph}, set::Bool)

# Wrapper of void TGraph::SetHistogram(TH1F *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TGraph}, h::ByPtr1{TH1F})::Nothing


""" SetHistogram(this::ByRef1{TGraph}, h::ByPtr1{TH1F})

# Wrapper of void TGraph::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TGraph}, maximum::Float64)::Nothing
Set the maximum of the graph.

""" SetMaximum(this::ByRef1{TGraph}, maximum::Float64)

# Wrapper of void TGraph::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TGraph}, minimum::Float64)::Nothing
Set the minimum of the graph.

""" SetMinimum(this::ByRef1{TGraph}, minimum::Float64)

# Wrapper of void TGraph::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TGraph}, name::ByCopy{String})::Nothing
Set graph name.

""" SetName(this::ByRef1{TGraph}, name::ByCopy{String})

# Wrapper of void TGraph::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TGraph}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Set graph name and title.

""" SetNameTitle(this::ByRef1{TGraph}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TGraph::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TGraph}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TGraph}, option::ByCopy{String})

# Wrapper of void TGraph::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph}, i::Int32, x::Float64, y::Float64)::Nothing
Set x and y values for point number i.

""" SetPoint(this::ByRef1{TGraph}, i::Int32, x::Float64, y::Float64)

# Wrapper of void TGraph::SetPointX(Int_t, Double_t)
@trydoc raw"""
    SetPointX(this::ByRef1{TGraph}, i::Int32, x::Float64)::Nothing
Set x value for point i.

""" SetPointX(this::ByRef1{TGraph}, i::Int32, x::Float64)

# Wrapper of void TGraph::SetPointY(Int_t, Double_t)
@trydoc raw"""
    SetPointY(this::ByRef1{TGraph}, i::Int32, y::Float64)::Nothing
Set y value for point i.

""" SetPointY(this::ByRef1{TGraph}, i::Int32, y::Float64)

# Wrapper of void TGraph::SetStats(Bool_t)
@trydoc raw"""
    SetStats(this::ByRef1{TGraph}, stats::Bool)::Nothing
Set statistics option on/off.
By default, the statistics box is drawn. The paint options can be selected via gStyle->SetOptStat. This function sets/resets the kNoStats bit in the graph object. It has priority over the Style option.
""" SetStats(this::ByRef1{TGraph}, stats::Bool)

# Wrapper of void TGraph::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TGraph}, title::ByCopy{String})::Nothing
Change (i.e.
set) the title

if title is in the form `stringt;stringx;stringy;stringz` the graph title is set to `stringt`, the x axis title to `stringx`, the y axis title to `stringy`, and the z axis title to `stringz`.

To insert the character `;` in one of the titles, one should use `#;` or `#semicolon`.
""" SetTitle(this::ByRef1{TGraph}, title::ByCopy{String})

# Wrapper of void TGraph::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TGraph})::Nothing
Set current style settings in this graph This function is called when either [TCanvas!UseCurrentStyle](@ref) or [TROOT!ForceStyle](@ref) have been invoked.

""" UseCurrentStyle(this::ByRef1{TGraph})

# Wrapper of void TGraph::Zero(Int_t &, Double_t, Double_t, Double_t, Double_t &, Double_t &, Int_t)
@trydoc raw"""
    Zero(this::ByRef1{TGraph}, k::ByRef2{Int32}, AZ::Float64, BZ::Float64, E2::Float64, X::ByRef2{Float64}, Y::ByRef2{Float64}, maxiterations::Int32)::Nothing
Find zero of a continuous function.
This function finds a real zero of the continuous real function Y(X) in a given interval (A,B). See accompanying notes for details of the argument list and calling sequence
""" Zero(this::ByRef1{TGraph}, k::ByRef2{Int32}, AZ::Float64, BZ::Float64, E2::Float64, X::ByRef2{Float64}, Y::ByRef2{Float64}, maxiterations::Int32)

# Wrapper of void TGraph2D::AddPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    AddPoint(this::ByRef1{TGraph2D}, x::Float64, y::Float64, z::Float64)::Nothing
Append a new point to the graph.

""" AddPoint(this::ByRef1{TGraph2D}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2D::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGraph2D}, ::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TGraph2D}, ::ByPtr1{TBrowser})

# Wrapper of void TGraph2D::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGraph2D}, option::ByCopy{String})::Nothing
Free all memory allocated by this object.

""" Clear(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of void TGraph2D::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TGraph2D}, ::ByPtr1{TDirectory})::Nothing
Perform the automatic addition of the graph to the given directory.
Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a [TKey](@ref) or being Cloned)
""" DirectoryAutoAdd(this::ByRef1{TGraph2D}, ::ByPtr1{TDirectory})

# Wrapper of Int_t TGraph2D::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGraph2D}, px::Int32, py::Int32)::Int32
Computes distance from point px,py to a graph.

""" DistancetoPrimitive(this::ByRef1{TGraph2D}, px::Int32, py::Int32)

# Wrapper of void TGraph2D::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGraph2D}, option::ByCopy{String})::Nothing
Specific drawing options can be used to paint a [TGraph2D](@ref):
- "TRI" : The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color.
- "TRIW" : The Delaunay triangles are drawn as wire frame
- "TRI1" : The Delaunay triangles are painted with color levels. The edges of each triangles are painted with the current line color.
- "TRI2" : the Delaunay triangles are painted with color levels.
- "P" : Draw a marker at each vertex
- "P0" : Draw a circle at each vertex. Each circle background is white.
- "PCOL" : Draw a marker at each vertex. The color of each marker is defined according to its Z position.
- "CONT" : Draw contours
- "LINE" : Draw a 3D polyline

A [TGraph2D](@ref) can be also drawn with ANY options valid to draw a 2D histogram.

When a [TGraph2D](@ref) is drawn with one of the 2D histogram drawing option, a intermediate 2D histogram is filled using the Delaunay triangles technique to interpolate the data set.
""" Draw(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of void TGraph2D::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGraph2D}, event::Int32, px::Int32, py::Int32)::Nothing
Executes action corresponding to one event.

""" ExecuteEvent(this::ByRef1{TGraph2D}, event::Int32, px::Int32, py::Int32)

# Wrapper of TFitResultPtr TGraph2D::Fit(const char *, Option_t *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TGraph2D}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String})::ByCopy{TFitResultPtr}
Fits this graph with function with name fname Predefined functions such as gaus, expo and poln are automatically created by [ROOT](@ref).
fname can also be a formula, accepted by the linear fitter (linear parts divided by "++" sign), for example "x++sin(y)" for fitting "[0]*x+[1]*sin(y)"
""" Fit(this::ByRef1{TGraph2D}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String})

# Wrapper of TFitResultPtr TGraph2D::Fit(TF2 *, Option_t *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TGraph2D}, f2::ByPtr1{TF2}, option::ByCopy{String}, goption::ByCopy{String})::ByCopy{TFitResultPtr}
Fits this 2D graph with function f2.
f2 is an already predefined function created by [TF2](@ref).

See [TGraph!Fit](@ref) for the available fitting options and fitting notes
""" Fit(this::ByRef1{TGraph2D}, f2::ByPtr1{TF2}, option::ByCopy{String}, goption::ByCopy{String})

# Wrapper of void TGraph2D::FitPanel()
@trydoc raw"""
    FitPanel(this::ByRef1{TGraph2D})::Nothing
Display a GUI panel with all graph fit options.
See class [TFitEditor](@ref) for example
""" FitPanel(this::ByRef1{TGraph2D})

# Wrapper of TList * TGraph2D::GetContourList(Double_t)
@trydoc raw"""
    GetContourList(this::ByRef1{TGraph2D}, contour::Float64)::CxxPtr1{TList}
Returns the X and Y graphs building a contour.
A contour level may consist in several parts not connected to each other. This function returns them in a graphs' list.
""" GetContourList(this::ByRef1{TGraph2D}, contour::Float64)

# Wrapper of TH2D * TGraph2D::GetHistogram(Option_t *)
@trydoc raw"""
    GetHistogram(this::ByRef1{TGraph2D}, option::ByCopy{String})::CxxPtr1{TH2D}
By default returns a pointer to the Delaunay histogram.
If fHistogram doesn't exist, books the 2D histogram fHistogram with a margin around the hull. Calls [TGraphDelaunay!Interpolate](@ref) at each bin centre to build up an interpolated 2D histogram.

If the "empty" option is selected, returns an empty histogram booked with the limits of fX, fY and fZ. This option is used when the data set is drawn with markers only. In that particular case there is no need to find the Delaunay triangles.

By default use the new interpolation routine based on Triangles If the option "old" the old interpolation is used
""" GetHistogram(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of Double_t TGraph2D::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByRef1{TGraph2D}, x::Float64, y::Float64)::Float64
Finds the z value at the position (x,y) thanks to the Delaunay interpolation.

""" Interpolate(this::ByRef1{TGraph2D}, x::Float64, y::Float64)

# Wrapper of TGraph2D & TGraph2D::operator=(const TGraph2D &)
@trydoc raw"""
    assign(this::ByRef1{TGraph2D}, ::ByConstRef1{TGraph2D})::CxxRef1{TGraph2D}
Graph2D operator "=".

""" assign(this::ByRef1{TGraph2D}, ::ByConstRef1{TGraph2D})

# Wrapper of void TGraph2D::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGraph2D}, option::ByCopy{String})::Nothing
Paints this 2D graph with its current attributes.

""" Paint(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of Int_t TGraph2D::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph2D}, ipoint::Int32)::Int32
Deletes point number ipoint.

""" RemovePoint(this::ByRef1{TGraph2D}, ipoint::Int32)

# Wrapper of void TGraph2D::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph2D}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values of a [TGraph2D](@ref) by a constant c1.
If option contains "x" the x values are scaled If option contains "y" the y values are scaled If option contains "z" the z values are scaled If option contains "xyz" all three x, y and z values are scaled
""" Scale(this::ByRef1{TGraph2D}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph2D::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph2D}, n::Int32)::Nothing
Set number of points in the 2D graph.
Existing coordinates are preserved. New coordinates above fNpoints are preset to 0.
""" Set(this::ByRef1{TGraph2D}, n::Int32)

# Wrapper of void TGraph2D::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TGraph2D}, dir::ByPtr1{TDirectory})::Nothing
By default when an 2D graph is created, it is added to the list of 2D graph objects in the current directory in memory.
This method removes reference to this 2D graph from current directory and add reference to new directory dir. dir can be 0 in which case the 2D graph does not belong to any directory.
""" SetDirectory(this::ByRef1{TGraph2D}, dir::ByPtr1{TDirectory})

# Wrapper of void TGraph2D::SetHistogram(TH2 *, Option_t *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TGraph2D}, h::ByPtr1{TH2}, option::ByCopy{String})::Nothing
Sets the histogram to be filled.
If the 2D graph needs to be save in a [TFile](@ref) the following set should be followed to read it back:

1. Create [TGraph2D](@ref)
2. Call g->SetHistogram(h), and do whatever you need to do
3. Save g and h to the [TFile](@ref), exit
4. Open the [TFile](@ref), retrieve g and h
5. Call h->SetDirectory(0)
6. Call g->SetHistogram(h) again
7. Carry on as normal

By default use the new interpolation routine based on Triangles If the option "old" the old interpolation is used
""" SetHistogram(this::ByRef1{TGraph2D}, h::ByPtr1{TH2}, option::ByCopy{String})

# Wrapper of void TGraph2D::SetMargin(Double_t)
@trydoc raw"""
    SetMargin(this::ByRef1{TGraph2D}, m::Float64)::Nothing
Sets the extra space (in %) around interpolated area for the 2D histogram.

""" SetMargin(this::ByRef1{TGraph2D}, m::Float64)

# Wrapper of void TGraph2D::SetMarginBinsContent(Double_t)
@trydoc raw"""
    SetMarginBinsContent(this::ByRef1{TGraph2D}, z::Float64)::Nothing
Sets the histogram bin height for points lying outside the [TGraphDelaunay](@ref) convex hull ie: the bins in the margin.

""" SetMarginBinsContent(this::ByRef1{TGraph2D}, z::Float64)

# Wrapper of void TGraph2D::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TGraph2D}, maximum::Float64)::Nothing
Set maximum.

""" SetMaximum(this::ByRef1{TGraph2D}, maximum::Float64)

# Wrapper of void TGraph2D::SetMaxIter(Int_t)
@trydoc raw"""
    SetMaxIter(this::ByRef1{TGraph2D}, n::Int32)::Nothing


""" SetMaxIter(this::ByRef1{TGraph2D}, n::Int32)

# Wrapper of void TGraph2D::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TGraph2D}, minimum::Float64)::Nothing
Set minimum.

""" SetMinimum(this::ByRef1{TGraph2D}, minimum::Float64)

# Wrapper of void TGraph2D::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TGraph2D}, name::ByCopy{String})::Nothing
Changes the name of this 2D graph.

""" SetName(this::ByRef1{TGraph2D}, name::ByCopy{String})

# Wrapper of void TGraph2D::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TGraph2D}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Change the name and title of this 2D graph.

""" SetNameTitle(this::ByRef1{TGraph2D}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TGraph2D::SetNpx(Int_t)
@trydoc raw"""
    SetNpx(this::ByRef1{TGraph2D}, npx::Int32)::Nothing
Sets the number of bins along X used to draw the function.

""" SetNpx(this::ByRef1{TGraph2D}, npx::Int32)

# Wrapper of void TGraph2D::SetNpy(Int_t)
@trydoc raw"""
    SetNpy(this::ByRef1{TGraph2D}, npx::Int32)::Nothing
Sets the number of bins along Y used to draw the function.

""" SetNpy(this::ByRef1{TGraph2D}, npx::Int32)

# Wrapper of void TGraph2D::SetPoint(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph2D}, point::Int32, x::Float64, y::Float64, z::Float64)::Nothing
Sets point number n.
If n is greater than the current size, the arrays are automatically extended.
""" SetPoint(this::ByRef1{TGraph2D}, point::Int32, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2D::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TGraph2D}, title::ByCopy{String})::Nothing
Sets the 2D graph title.
This method allows to change the global_ title and the axis' titles of a 2D graph. If `g` is the 2D graph one can do:

    g->SetTitle("Graph title; X axis title; Y axis title; Z axis title");

(C++ version of the code)
""" SetTitle(this::ByRef1{TGraph2D}, title::ByCopy{String})

# Wrapper of void TGraphErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})::Nothing
Apply function to all the data points $ y = f(x,y) $.
The error is calculated as $ ey=(f(x,y+ey)-f(x,y-ey))/2 $. This is the same as $ error(fy) = df/dy * ey $ for small errors.

For generic functions the symmetric errors might become non-symmetric and are averaged here. Use [TGraphAsymmErrors](@ref) if desired.

Error on $ x $ doesn't change.

function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphErrors::ApplyX(TF1 *)
@trydoc raw"""
    ApplyX(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})::Nothing
Apply function to all the data points $ x = f(x,y) $.
The error is calculated as $ ex=(f(x+ex,y)-f(x-ex,y))/2 $. This is the same as $ error(fx) = df/dx * ex $ for small errors.

For generic functions the symmetric errors might become non-symmetric and are averaged here. Use [TGraphAsymmErrors](@ref) if desired.

Error on $ y $ doesn't change.
""" ApplyX(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})

# Wrapper of Int_t TGraphErrors::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TGraphErrors}, list::ByPtr1{TCollection})::Int32
Adds all graphs with errors from the collection to this graph.
Returns the total number of points in the result or -1 in case of an error.
""" Merge(this::ByRef1{TGraphErrors}, list::ByPtr1{TCollection})

# Wrapper of TGraphErrors & TGraphErrors::operator=(const TGraphErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraphErrors}, gr::ByConstRef1{TGraphErrors})::CxxRef1{TGraphErrors}
[TGraphErrors](@ref) assignment operator.

""" assign(this::ByRef1{TGraphErrors}, gr::ByConstRef1{TGraphErrors})

# Wrapper of void TGraphErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "xy" both x and y values and errors are scaled
""" Scale(this::ByRef1{TGraphErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphErrors::SetPointError(Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphErrors}, ex::Float64, ey::Float64)::Nothing
Set `ex` and `ey` values for point pointed by the mouse.

""" SetPointError(this::ByRef1{TGraphErrors}, ex::Float64, ey::Float64)

# Wrapper of void TGraphErrors::SetPointError(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphErrors}, i::Int32, ex::Float64, ey::Float64)::Nothing
Set `ex` and `ey` values for point number i.

""" SetPointError(this::ByRef1{TGraphErrors}, i::Int32, ex::Float64, ey::Float64)

# Wrapper of void TAxisModLab::SetAlign(Int_t)
@trydoc raw"""
    SetAlign(this::ByRef1{TAxisModLab}, a::Int32)::Nothing
Set modified label alignment.

""" SetAlign(this::ByRef1{TAxisModLab}, a::Int32)

# Wrapper of void TAxisModLab::SetAngle(Double_t)
@trydoc raw"""
    SetAngle(this::ByRef1{TAxisModLab}, a::Float64)::Nothing
Set modified label angle.

""" SetAngle(this::ByRef1{TAxisModLab}, a::Float64)

# Wrapper of void TAxisModLab::SetColor(Int_t)
@trydoc raw"""
    SetColor(this::ByRef1{TAxisModLab}, c::Int32)::Nothing
Set modified label color.

""" SetColor(this::ByRef1{TAxisModLab}, c::Int32)

# Wrapper of void TAxisModLab::SetFont(Int_t)
@trydoc raw"""
    SetFont(this::ByRef1{TAxisModLab}, f::Int32)::Nothing
Set modified label font.

""" SetFont(this::ByRef1{TAxisModLab}, f::Int32)

# Wrapper of void TAxisModLab::SetLabNum(Int_t)
@trydoc raw"""
    SetLabNum(this::ByRef1{TAxisModLab}, n::Int32)::Nothing
Set modified label number.

""" SetLabNum(this::ByRef1{TAxisModLab}, n::Int32)

# Wrapper of void TAxisModLab::SetLabValue(Double_t)
@trydoc raw"""
    SetLabValue(this::ByRef1{TAxisModLab}, v::Float64)::Nothing
Set modified label value.

""" SetLabValue(this::ByRef1{TAxisModLab}, v::Float64)

# Wrapper of void TAxisModLab::SetSize(Double_t)
@trydoc raw"""
    SetSize(this::ByRef1{TAxisModLab}, s::Float64)::Nothing
Set modified label size.

""" SetSize(this::ByRef1{TAxisModLab}, s::Float64)

# Wrapper of void TAxisModLab::SetText(TString)
@trydoc raw"""
    SetText(this::ByRef1{TAxisModLab}, t::ByCopy{TString})::Nothing
Set modified label text.

""" SetText(this::ByRef1{TAxisModLab}, t::ByCopy{TString})

# Wrapper of void TVirtualFitter::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TVirtualFitter}, option::ByCopy{String})::Nothing
Set name and title to empty strings ("").

""" Clear(this::ByRef1{TVirtualFitter}, option::ByCopy{String})

# Wrapper of Int_t TVirtualFitter::ExecuteCommand(const char *, Double_t *, Int_t)
@trydoc raw"""
    ExecuteCommand(this::ByRef1{TVirtualFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)::Int32


""" ExecuteCommand(this::ByRef1{TVirtualFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)

# Wrapper of void TVirtualFitter::FixParameter(Int_t)
@trydoc raw"""
    FixParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)::Nothing


""" FixParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of void TVirtualFitter::GetConfidenceIntervals(Int_t, Int_t, const Double_t *, Double_t *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)::Nothing
return confidence intervals in array x of dimension ndim implemented in [TFitter](@ref) and [TLinearFitter](@ref)

""" GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)

# Wrapper of void TVirtualFitter::GetConfidenceIntervals(TObject *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject}, cl::Float64)::Nothing
return confidence intervals in [TObject](@ref) obj implemented in [TFitter](@ref) and [TLinearFitter](@ref)

""" GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject}, cl::Float64)

# Wrapper of Double_t TVirtualFitter::GetSumLog(Int_t)
@trydoc raw"""
    GetSumLog(this::ByRef1{TVirtualFitter}, i::Int32)::Float64


""" GetSumLog(this::ByRef1{TVirtualFitter}, i::Int32)

# Wrapper of void TVirtualFitter::ReleaseParameter(Int_t)
@trydoc raw"""
    ReleaseParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)::Nothing


""" ReleaseParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of Double_t * TVirtualFitter::SetCache(Int_t, Int_t)
@trydoc raw"""
    SetCache(this::ByRef1{TVirtualFitter}, npoints::Int32, psize::Int32)::CxxPtr2{Float64}
Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point.
if (npoints*psize > fCacheSize) the existing cache is deleted and a new array is created. The function returns a pointer to the cache
""" SetCache(this::ByRef1{TVirtualFitter}, npoints::Int32, psize::Int32)

# Wrapper of void TVirtualFitter::SetFitMethod(const char *)
@trydoc raw"""
    SetFitMethod(this::ByRef1{TVirtualFitter}, name::ByCopy{String})::Nothing


""" SetFitMethod(this::ByRef1{TVirtualFitter}, name::ByCopy{String})

# Wrapper of void TVirtualFitter::SetFitOption(Foption_t)
@trydoc raw"""
    SetFitOption(this::ByRef1{TVirtualFitter}, option::ByCopy{Foption_t})::Nothing


""" SetFitOption(this::ByRef1{TVirtualFitter}, option::ByCopy{Foption_t})

# Wrapper of void TVirtualFitter::SetObjectFit(TObject *)
@trydoc raw"""
    SetObjectFit(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject})::Nothing


""" SetObjectFit(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject})

# Wrapper of Int_t TVirtualFitter::SetParameter(Int_t, const char *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TVirtualFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)::Int32


""" SetParameter(this::ByRef1{TVirtualFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)

# Wrapper of void TVirtualFitter::SetUserFunc(TObject *)
@trydoc raw"""
    SetUserFunc(this::ByRef1{TVirtualFitter}, userfunc::ByPtr1{TObject})::Nothing


""" SetUserFunc(this::ByRef1{TVirtualFitter}, userfunc::ByPtr1{TObject})

# Wrapper of void TVirtualFitter::SetXfirst(Int_t)
@trydoc raw"""
    SetXfirst(this::ByRef1{TVirtualFitter}, first::Int32)::Nothing


""" SetXfirst(this::ByRef1{TVirtualFitter}, first::Int32)

# Wrapper of void TVirtualFitter::SetXlast(Int_t)
@trydoc raw"""
    SetXlast(this::ByRef1{TVirtualFitter}, last::Int32)::Nothing


""" SetXlast(this::ByRef1{TVirtualFitter}, last::Int32)

# Wrapper of void TVirtualFitter::SetYfirst(Int_t)
@trydoc raw"""
    SetYfirst(this::ByRef1{TVirtualFitter}, first::Int32)::Nothing


""" SetYfirst(this::ByRef1{TVirtualFitter}, first::Int32)

# Wrapper of void TVirtualFitter::SetYlast(Int_t)
@trydoc raw"""
    SetYlast(this::ByRef1{TVirtualFitter}, last::Int32)::Nothing


""" SetYlast(this::ByRef1{TVirtualFitter}, last::Int32)

# Wrapper of void TVirtualFitter::SetZfirst(Int_t)
@trydoc raw"""
    SetZfirst(this::ByRef1{TVirtualFitter}, first::Int32)::Nothing


""" SetZfirst(this::ByRef1{TVirtualFitter}, first::Int32)

# Wrapper of void TVirtualFitter::SetZlast(Int_t)
@trydoc raw"""
    SetZlast(this::ByRef1{TVirtualFitter}, last::Int32)::Nothing


""" SetZlast(this::ByRef1{TVirtualFitter}, last::Int32)

# Wrapper of void TBackCompFitter::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TBackCompFitter}, option::ByCopy{String})::Nothing
Clear resources for consecutive fits.

""" Clear(this::ByRef1{TBackCompFitter}, option::ByCopy{String})

# Wrapper of bool TBackCompFitter::Contour(unsigned int, unsigned int, TGraph *, double)
@trydoc raw"""
    Contour(this::ByRef1{TBackCompFitter}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)::Bool
Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or is invalid it will return false on exit a [TGraph](@ref) is filled with the contour points the number of contour points is determined by the size of the [TGraph](@ref).
if the size is zero a default number of points = 20 is used pass optionally the confidence level, default is 0.683 it is assumed that ErrorDef() defines the right error definition (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level
""" Contour(this::ByRef1{TBackCompFitter}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)

# Wrapper of Int_t TBackCompFitter::ExecuteCommand(const char *, Double_t *, Int_t)
@trydoc raw"""
    ExecuteCommand(this::ByRef1{TBackCompFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)::Int32
Execute the command (Fortran Minuit compatible interface)

""" ExecuteCommand(this::ByRef1{TBackCompFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)

# Wrapper of void TBackCompFitter::FixParameter(Int_t)
@trydoc raw"""
    FixParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)::Nothing
Fix the parameter.

""" FixParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of void TBackCompFitter::GetConfidenceIntervals(Int_t, Int_t, const Double_t *, Double_t *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)::Nothing
Computes point-by-point confidence intervals for the fitted function.
## Arguments

- **`n`** 
    number of points 
    
- **`ndim`** 
    dimensions of points 
    
- **`x`** 
    points, at which to compute the intervals, for ndim > 1 should be in order: (x0,y0, x1, y1, ... xn, yn) 
    
- **`ci`** 
    computed intervals are returned in this array 
    
- **`cl`** 
    confidence level, default=0.95
    

NOTE, that the intervals are approximate for nonlinear(in parameters) models
""" GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)

# Wrapper of void TBackCompFitter::GetConfidenceIntervals(TObject *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, obj::ByPtr1{TObject}, cl::Float64)::Nothing
Computes confidence intervals at level cl.
Default is 0.95 The [TObject](@ref) parameter can be a [TGraphErrors](@ref), a [TGraph2DErrors](@ref) or a [TH1](@ref),2,3. For Graphs, confidence intervals are computed for each point, the value of the graph at that point is set to the function value at that point, and the graph y-errors (or z-errors) are set to the value of the confidence interval at that point. For Histograms, confidence intervals are computed for each bin center The bin content of this bin is then set to the function value at the bin center, and the bin error is set to the confidence interval value. NOTE: confidence intervals are approximate for nonlinear models!

Allowed combinations:

| **Fitted object**                 | **Passed object**                   |
|:----------------------------------|:------------------------------------|
| [TGraph](@ref)                    | [TGraphErrors](@ref), [TH1](@ref)   |
| [TGraphErrors](@ref), AsymmErrors | [TGraphErrors](@ref), [TH1](@ref)   |
| [TH1](@ref)                       | [TGraphErrors](@ref), [TH1](@ref)   |
| [TGraph2D](@ref)                  | [TGraph2DErrors](@ref), [TH2](@ref) |
| [TGraph2DErrors](@ref)            | [TGraph2DErrors](@ref), [TH2](@ref) |
| [TH2](@ref)                       | [TGraph2DErrors](@ref), [TH2](@ref) |
| [TH3](@ref)                       | [TH3](@ref)                         |
""" GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, obj::ByPtr1{TObject}, cl::Float64)

# Wrapper of Double_t TBackCompFitter::GetSumLog(Int_t)
@trydoc raw"""
    GetSumLog(this::ByRef1{TBackCompFitter}, i::Int32)::Float64
Sum of log (un-needed)

""" GetSumLog(this::ByRef1{TBackCompFitter}, i::Int32)

# Wrapper of void TBackCompFitter::ReCreateMinimizer()
@trydoc raw"""
    ReCreateMinimizer(this::ByRef1{TBackCompFitter})::Nothing
Recreate a minimizer instance using the function and data set objective function in minimizers function to re-create FCN from stored data object and fit options.

""" ReCreateMinimizer(this::ByRef1{TBackCompFitter})

# Wrapper of void TBackCompFitter::ReleaseParameter(Int_t)
@trydoc raw"""
    ReleaseParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)::Nothing
Release a fit parameter.

""" ReleaseParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of bool TBackCompFitter::Scan(unsigned int, TGraph *, double, double)
@trydoc raw"""
    Scan(this::ByRef1{TBackCompFitter}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)::Bool
Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return filled with the scan resul If the graph size is zero, a default size n = 40 will be used.

""" Scan(this::ByRef1{TBackCompFitter}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of void TBackCompFitter::SetFitMethod(const char *)
@trydoc raw"""
    SetFitMethod(this::ByRef1{TBackCompFitter}, name::ByCopy{String})::Nothing
Set fit method (chi2 or likelihood).
According to the method the appropriate FCN function will be created
""" SetFitMethod(this::ByRef1{TBackCompFitter}, name::ByCopy{String})

# Wrapper of void TBackCompFitter::SetMethodCall(TMethodCall *)
@trydoc raw"""
    SetMethodCall(this::ByRef1{TBackCompFitter}, m::ByPtr1{TMethodCall})::Nothing
For using interpreted function passed by the user.

""" SetMethodCall(this::ByRef1{TBackCompFitter}, m::ByPtr1{TMethodCall})

# Wrapper of Int_t TBackCompFitter::SetParameter(Int_t, const char *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TBackCompFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)::Int32
Set (add) a new fit parameter passing initial value, step size (verr) and parameter limits if vlow > vhigh the parameter is unbounded if the stepsize (verr) == 0 the parameter is treated as fixed.

""" SetParameter(this::ByRef1{TBackCompFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)

# Wrapper of Double_t TBinomialEfficiencyFitter::EvaluateFCN(const Double_t *)
@trydoc raw"""
    EvaluateFCN(this::ByRef1{TBinomialEfficiencyFitter}, par::ByConstPtr2{Float64})::Float64


""" EvaluateFCN(this::ByRef1{TBinomialEfficiencyFitter}, par::ByConstPtr2{Float64})

# Wrapper of TFitResultPtr TBinomialEfficiencyFitter::Fit(TF1 *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TBinomialEfficiencyFitter}, f1::ByPtr1{TF1}, option::ByCopy{String})::ByCopy{TFitResultPtr}
Carry out the fit of the given function to the given histograms.
If option "I" is used, the fit function will be averaged over the bin (the default is to evaluate it simply at the bin center).

If option "R" is used, the fit range will be taken from the fit function (the default is to use the entire histogram).

If option "S" a [TFitResult](@ref) object is returned and it can be used to obtain additional fit information, like covariance or correlation matrix.

Note that all parameter values, limits, and step sizes are copied from the input fit function f1 (so they should be set before calling this method. This is particularly relevant for the step sizes, taken to be the "error" set on input, as a null step size usually fixes the corresponding parameter. That is protected against, but in such cases an arbitrary starting step size will be used, and the reliability of the fit should be questioned). If parameters are to be fixed, this should be done by specifying non-null parameter limits, with lower limits larger than upper limits.

On output, f1 contains the fitted parameters and errors, as well as the number of degrees of freedom, and the goodness-of-fit estimator as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437.
""" Fit(this::ByRef1{TBinomialEfficiencyFitter}, f1::ByPtr1{TF1}, option::ByCopy{String})

# Wrapper of void TBinomialEfficiencyFitter::Set(const TH1 *, const TH1 *)
@trydoc raw"""
    Set(this::ByRef1{TBinomialEfficiencyFitter}, numerator::ByConstPtr1{TH1}, denominator::ByConstPtr1{TH1})::Nothing
Initialize with a new set of inputs.

""" Set(this::ByRef1{TBinomialEfficiencyFitter}, numerator::ByConstPtr1{TH1}, denominator::ByConstPtr1{TH1})

# Wrapper of void TBinomialEfficiencyFitter::SetPrecision(Double_t)
@trydoc raw"""
    SetPrecision(this::ByRef1{TBinomialEfficiencyFitter}, epsilon::Float64)::Nothing
Set the required integration precision, see [TF1!Integral()](@ref)
""" SetPrecision(this::ByRef1{TBinomialEfficiencyFitter}, epsilon::Float64)

# Wrapper of void TConfidenceLevel::Draw(const Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TConfidenceLevel}, option::ByCopy{String})::Nothing
Display sort of a "canonical" -2lnQ plot.
This results in a plot with 2 elements:

- The histogram of -2lnQ for background hypothesis (full)
- The histogram of -2lnQ for signal and background hypothesis (dashed)

The 2 histograms are respectively named b_hist and sb_hist.
""" Draw(this::ByRef1{TConfidenceLevel}, option::ByCopy{String})

# Wrapper of void TConfidenceLevel::SetBtot(Double_t)
@trydoc raw"""
    SetBtot(this::ByRef1{TConfidenceLevel}, in::Float64)::Nothing


""" SetBtot(this::ByRef1{TConfidenceLevel}, in::Float64)

# Wrapper of void TConfidenceLevel::SetDtot(Int_t)
@trydoc raw"""
    SetDtot(this::ByRef1{TConfidenceLevel}, in::Int32)::Nothing


""" SetDtot(this::ByRef1{TConfidenceLevel}, in::Int32)

# Wrapper of void TConfidenceLevel::SetLRB(Double_t *)
@trydoc raw"""
    SetLRB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing


""" SetLRB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TConfidenceLevel::SetLRS(Double_t *)
@trydoc raw"""
    SetLRS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing


""" SetLRS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TConfidenceLevel::SetStot(Double_t)
@trydoc raw"""
    SetStot(this::ByRef1{TConfidenceLevel}, in::Float64)::Nothing


""" SetStot(this::ByRef1{TConfidenceLevel}, in::Float64)

# Wrapper of void TConfidenceLevel::SetTSB(Double_t *)
@trydoc raw"""
    SetTSB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing
Set the TSB.

""" SetTSB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TConfidenceLevel::SetTSD(Double_t)
@trydoc raw"""
    SetTSD(this::ByRef1{TConfidenceLevel}, in::Float64)::Nothing


""" SetTSD(this::ByRef1{TConfidenceLevel}, in::Float64)

# Wrapper of void TConfidenceLevel::SetTSS(Double_t *)
@trydoc raw"""
    SetTSS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing
Set the TSS.

""" SetTSS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TEfficiency::Add(const TEfficiency &)
@trydoc raw"""
    Add(this::ByRef1{TEfficiency}, rEff::ByConstRef1{TEfficiency})::Nothing


""" Add(this::ByRef1{TEfficiency}, rEff::ByConstRef1{TEfficiency})

# Wrapper of void TEfficiency::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TEfficiency}, b::ByPtr1{TBrowser})::Nothing
Browse object. May be overridden for another default action.

""" Browse(this::ByRef1{TEfficiency}, b::ByPtr1{TBrowser})

# Wrapper of Int_t TEfficiency::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TEfficiency}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a graph.
Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units.

Forward the call to the painted graph
""" DistancetoPrimitive(this::ByRef1{TEfficiency}, px::Int32, py::Int32)

# Wrapper of void TEfficiency::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TEfficiency}, opt::ByCopy{String})::Nothing
Draws the current [TEfficiency](@ref) object.
## Arguments

- **`opt`** [in] 
    - 1-dimensional case: same options as [TGraphAsymmErrors!Draw()](@ref) but as default "AP" is used
    - 2-dimensional case: by default use an histogram and in this case same options as [TH2!Draw()](@ref) if using instad option "GRAPH" a [TGraph2DAsymmErrors](@ref) is used and the same options as for [TGraph2D](@ref) applies
    - 3-dimensional case: not yet supported
    
    

Specific [TEfficiency](@ref) drawing options:

- E0 - plot bins where the total number of passed events is zero (the error interval will be [0,1] )
""" Draw(this::ByRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of void TEfficiency::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TEfficiency}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when the drawn class is clicked with the locator If Left button clicked on one of the line theend points, this point follows the cursor until button is released.

if Middle button clicked, the line is moved parallel to itself until the button is released. Forward the call to the underlying graph
""" ExecuteEvent(this::ByRef1{TEfficiency}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TEfficiency::Fill(Bool_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TEfficiency}, bPassed::Bool, x::Float64, y::Float64, z::Float64)::Nothing
This function is used for filling the two histograms.
## Arguments

- **`bPassed`** [in] 
    flag whether the current event passed the selection
    
    - true: both histograms are filled
    - false: only the total histogram is filled 
    
    
- **`x`** [in] 
    x-value 
    
- **`y`** [in] 
    y-value (use default=0 for 1-D efficiencies) 
    
- **`z`** [in] 
    z-value (use default=0 for 2-D or 1-D efficiencies)
""" Fill(this::ByRef1{TEfficiency}, bPassed::Bool, x::Float64, y::Float64, z::Float64)

# Wrapper of void TEfficiency::FillWeighted(Bool_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    FillWeighted(this::ByRef1{TEfficiency}, bPassed::Bool, weight::Float64, x::Float64, y::Float64, z::Float64)::Nothing
This function is used for filling the two histograms with a weight.
## Arguments

- **`bPassed`** [in] 
    flag whether the current event passed the selection
    
    - true: both histograms are filled
    - false: only the total histogram is filled 
    
    
- **`weight`** [in] 
    weight for the event 
    
- **`x`** [in] 
    x-value 
    
- **`y`** [in] 
    y-value (use default=0 for 1-D efficiencies) 
    
- **`z`** [in] 
    z-value (use default=0 for 2-D or 1-D efficiencies)
    

Note: - this function will call SetUseWeightedEvents if it was not called by the user before
""" FillWeighted(this::ByRef1{TEfficiency}, bPassed::Bool, weight::Float64, x::Float64, y::Float64, z::Float64)

# Wrapper of TFitResultPtr TEfficiency::Fit(TF1 *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TEfficiency}, f1::ByPtr1{TF1}, opt::ByCopy{String})::ByCopy{TFitResultPtr}
Fits the efficiency using the [TBinomialEfficiencyFitter](@ref) class.
The resulting fit function is added to the list of associated functions.

Options:

- "+": previous fitted functions in the list are kept, by default all functions in the list are deleted
- "N": do not store fitted function
- for more fitting options see [TBinomialEfficiencyFitter!Fit](@ref)
""" Fit(this::ByRef1{TEfficiency}, f1::ByPtr1{TF1}, opt::ByCopy{String})

# Wrapper of TList * TEfficiency::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByRef1{TEfficiency})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByRef1{TEfficiency})

# Wrapper of Long64_t TEfficiency::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TEfficiency}, list::ByPtr1{TCollection})::Int64
Merges the [TEfficiency](@ref) objects in the given list to the given [TEfficiency](@ref) object using the operator+=(TEfficiency&)
The merged result is stored in the current object. The statistic options and the confidence level are taken from the current object.

This function should be used when all [TEfficiency](@ref) objects correspond to the same process.

The new weight is set according to: $  \frac{1}{w_{new}} = \sum_{i} \frac{1}{w_{i}} $
""" Merge(this::ByRef1{TEfficiency}, list::ByPtr1{TCollection})

# Wrapper of TEfficiency & TEfficiency::operator+=(const TEfficiency &)
@trydoc raw"""
    add!(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})::CxxRef1{TEfficiency}
Adds the histograms of another [TEfficiency](@ref) object to current histograms.
The statistic options and the confidence level remain unchanged.

fTotalHistogram += rhs.fTotalHistogram; fPassedHistogram += rhs.fPassedHistogram;

calculates a new weight: current weight of this [TEfficiency](@ref) object = $ w_{1} $ weight of rhs = $ w_{2} $ $ w_{new} = \frac{w_{1} \times w_{2}}{w_{1} + w_{2}} $
""" add!(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})

# Wrapper of TEfficiency & TEfficiency::operator=(const TEfficiency &)
@trydoc raw"""
    assign(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})::CxxRef1{TEfficiency}
Assignment operator.
The histograms, statistic option, confidence level, weight and paint styles of rhs are copied to the this [TEfficiency](@ref) object.

Note: - The list of associated functions is not copied. After this operation the list of associated functions is empty.
""" assign(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})

# Wrapper of void TEfficiency::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TEfficiency}, opt::ByCopy{String})::Nothing
Paints this [TEfficiency](@ref) object.
For details on the possible option see [Draw(Option_t*)](@ref)

Note for 1D classes In 1D the [TEfficiency](@ref) uses a [TGraphAsymmErrors](@ref) for drawing The [TGraph](@ref) is created only the first time Paint is used. The user can manipulate the [TGraph](@ref) via the method [TEfficiency!GetPaintedGraph()](@ref) The [TGraph](@ref) creates behing an histogram for the axis. The histogram is created also only the first time. If the axis needs to be updated because in the meantime the class changed use this trick which will trigger a re-calculation of the axis of the graph [TEfficiency!GetPaintedGraph()](@ref)->Set(0)

Note that in order to access the painted graph via [GetPaintedGraph()](@ref) you need either to call Paint or better gPad->Update();
""" Paint(this::ByRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of void TEfficiency::SetBetaAlpha(Double_t)
@trydoc raw"""
    SetBetaAlpha(this::ByRef1{TEfficiency}, alpha::Float64)::Nothing
Sets the shape parameter .
The prior probability of the efficiency is given by the beta distribution: 

``f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}``

Note: - both shape parameters have to be positive (i.e. > 0)
""" SetBetaAlpha(this::ByRef1{TEfficiency}, alpha::Float64)

# Wrapper of void TEfficiency::SetBetaBeta(Double_t)
@trydoc raw"""
    SetBetaBeta(this::ByRef1{TEfficiency}, beta::Float64)::Nothing
Sets the shape parameter .
The prior probability of the efficiency is given by the beta distribution: 

``f(\varepsilon;\alpha,\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}``

Note: - both shape parameters have to be positive (i.e. > 0)
""" SetBetaBeta(this::ByRef1{TEfficiency}, beta::Float64)

# Wrapper of void TEfficiency::SetBetaBinParameters(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBetaBinParameters(this::ByRef1{TEfficiency}, bin::Int32, alpha::Float64, beta::Float64)::Nothing
Sets different shape parameter  and  for the prior distribution for each bin.
By default the global_ parameter are used if they are not set for the specific bin The prior probability of the efficiency is given by the beta distribution: 

``f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}``

Note:

- both shape parameters have to be positive (i.e. > 0)
- bin gives the global_ bin number (cf. GetGlobalBin)
""" SetBetaBinParameters(this::ByRef1{TEfficiency}, bin::Int32, alpha::Float64, beta::Float64)

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64})::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64})

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64)::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64)

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)

# Wrapper of void TEfficiency::SetCentralInterval(Bool_t)
@trydoc raw"""
    SetCentralInterval(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetCentralInterval(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetConfidenceLevel(Double_t)
@trydoc raw"""
    SetConfidenceLevel(this::ByRef1{TEfficiency}, level::Float64)::Nothing
Sets the confidence level (0 < level < 1) The default value is 1-sigma :~ 0.683.

""" SetConfidenceLevel(this::ByRef1{TEfficiency}, level::Float64)

# Wrapper of void TEfficiency::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TEfficiency}, dir::ByPtr1{TDirectory})::Nothing
Sets the directory holding this [TEfficiency](@ref) object.
A reference to this [TEfficiency](@ref) object is removed from the current directory (if it exists) and a new reference to this [TEfficiency](@ref) object is added to the given directory.

Notes: - If the given directory is 0, the [TEfficiency](@ref) object does not belong to any directory and will not be written to file during the next [TFile!Write()](@ref) command.
""" SetDirectory(this::ByRef1{TEfficiency}, dir::ByPtr1{TDirectory})

# Wrapper of void TEfficiency::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TEfficiency}, name::ByCopy{String})::Nothing
Sets the name.
Note: The names of the internal histograms are set to "name + _total" and "name + _passed" respectively.
""" SetName(this::ByRef1{TEfficiency}, name::ByCopy{String})

# Wrapper of Bool_t TEfficiency::SetPassedEvents(Int_t, Int_t)
@trydoc raw"""
    SetPassedEvents(this::ByRef1{TEfficiency}, bin::Int32, events::Int32)::Bool
Sets the number of passed events in the given global_ bin.
returns "true" if the number of passed events has been updated otherwise "false" ist returned

Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin)
""" SetPassedEvents(this::ByRef1{TEfficiency}, bin::Int32, events::Int32)

# Wrapper of Bool_t TEfficiency::SetPassedHistogram(const TH1 &, Option_t *)
@trydoc raw"""
    SetPassedHistogram(this::ByRef1{TEfficiency}, rPassed::ByConstRef1{TH1}, opt::ByCopy{String})::Bool
Sets the histogram containing the passed events.
The given histogram is cloned and stored internally as histogram containing the passed events. The given histogram has to be consistent with the current fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fPassedHistogram has been replaced (true) or not (false).

Note: The list of associated functions fFunctions is cleared.

Option:

- "f": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fTotalHistogram is replaced by a consistent one (with respect to rPassed) as well.
""" SetPassedHistogram(this::ByRef1{TEfficiency}, rPassed::ByConstRef1{TH1}, opt::ByCopy{String})

# Wrapper of void TEfficiency::SetPosteriorAverage(Bool_t)
@trydoc raw"""
    SetPosteriorAverage(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetPosteriorAverage(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetPosteriorMode(Bool_t)
@trydoc raw"""
    SetPosteriorMode(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetPosteriorMode(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetShortestInterval(Bool_t)
@trydoc raw"""
    SetShortestInterval(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetShortestInterval(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TEfficiency}, title::ByCopy{String})::Nothing
Sets the title.
Notes:

- The titles of the internal histograms are set to "title + (total)" or "title + (passed)" respectively.
- It is possible to label the axis of the histograms as usual (see [TH1!SetTitle](@ref)).

Example: Setting the title to "My Efficiency" and label the axis pEff->SetTitle("My Efficiency;x label;eff");
""" SetTitle(this::ByRef1{TEfficiency}, title::ByCopy{String})

# Wrapper of Bool_t TEfficiency::SetTotalEvents(Int_t, Double_t)
@trydoc raw"""
    SetTotalEvents(this::ByRef1{TEfficiency}, bin::Int32, events::Float64)::Bool
Sets the number of total events in the given global_ bin.
returns "true" if the number of total events has been updated otherwise "false" ist returned

Note: - requires: fPassedHistogram->GetBinContent(bin) <= events
""" SetTotalEvents(this::ByRef1{TEfficiency}, bin::Int32, events::Float64)

# Wrapper of Bool_t TEfficiency::SetTotalHistogram(const TH1 &, Option_t *)
@trydoc raw"""
    SetTotalHistogram(this::ByRef1{TEfficiency}, rTotal::ByConstRef1{TH1}, opt::ByCopy{String})::Bool
Sets the histogram containing all events.
The given histogram is cloned and stored internally as histogram containing all events. The given histogram has to be consistent with the current fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fTotalHistogram has been replaced (true) or not (false).

Note: The list of associated functions fFunctions is cleared.

Option:

- "f": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fPassedHistogram is replaced by a consistent one (with respect to rTotal) as well.
""" SetTotalHistogram(this::ByRef1{TEfficiency}, rTotal::ByConstRef1{TH1}, opt::ByCopy{String})

# Wrapper of void TEfficiency::SetUseWeightedEvents(Bool_t)
@trydoc raw"""
    SetUseWeightedEvents(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetUseWeightedEvents(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetWeight(Double_t)
@trydoc raw"""
    SetWeight(this::ByRef1{TEfficiency}, weight::Float64)::Nothing
Sets the global_ weight for this [TEfficiency](@ref) object.
Note: - weight has to be positive ( > 0)
""" SetWeight(this::ByRef1{TEfficiency}, weight::Float64)

# Wrapper of void TGraphAsymmErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphAsymmErrors}, f::ByPtr1{TF1})::Nothing
Apply a function to all data points $ y = f(x,y) $.
Errors are calculated as $ eyh = f(x,y+eyh)-f(x,y) $ and $ eyl = f(x,y)-f(x,y-eyl) $

Special treatment has to be applied for the functions where the role of "up" and "down" is reversed.

Function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphAsymmErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphAsymmErrors::BayesDivide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    BayesDivide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
This function is only kept for backward compatibility.
You should rather use the Divide method. It calls `Divide(pass,total,"cl=0.683 b(1,1) mode")` which is equivalent to the former BayesDivide method.
""" BayesDivide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of void TGraphAsymmErrors::Divide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
Fill this [TGraphAsymmErrors](@ref) by dividing two 1-dimensional histograms pass/total.
This method serves two purposes:

### 1) calculating efficiencies:

The assumption is that the entries in "pass" are a subset of those in "total". That is, we create an "efficiency" graph, where each entry is between 0 and 1, inclusive.

If the histograms are not filled with unit weights, the number of effective entries is used to normalise the bin contents which might lead to wrong results. 

``\text{effective entries} = \frac{(\sum w_{i})^{2}}{\sum w_{i}^{2}}``

 The points are assigned a x value at the center of each histogram bin. The y values are $\text{eff} = \frac{\text{pass}}{\text{total}}$ for all options except for the bayesian methods where the result depends on the chosen option.

If the denominator becomes 0 or pass > total, the corresponding bin is skipped.

### 2) calculating ratios of two Poisson means (option 'pois'):

The two histograms are interpreted as independent Poisson processes and the ratio 

``\tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}``

 with $\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}$. The histogram 'pass' is interpreted as $n_{1}$ and the total histogram is used for $n_{2}$.

The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties of efficiency by a parameter transformation: 

``\Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}``

The x errors span each histogram bin (lowedge ... lowedge+width) The y errors depend on the chosen statistic methode which can be determined by the options given below. For a detailed description of the used statistic calculations please have a look at the corresponding functions!

Options:

- v : verbose mode: prints information about the number of used bins and calculated efficiencies with their errors
- cl=x : determine the used confidence level (0<x<1) (default is 0.683)
- cp : Clopper-Pearson interval (see [TEfficiency!ClopperPearson](@ref))
- w : Wilson interval (see [TEfficiency!Wilson](@ref))
- n : normal approximation propagation (see [TEfficiency!Normal](@ref))
- ac : Agresti-Coull interval (see [TEfficiency!AgrestiCoull](@ref))
- fc : Feldman-Cousins interval (see [TEfficiency!FeldmanCousinsInterval](@ref))
- midp : Lancaster mid-P interval (see [TEfficiency!MidPInterval](@ref))
- [b(a,b)](@ref): bayesian interval using a prior probability ~Beta(a,b); a,b > 0 (see [TEfficiency!Bayesian](@ref))
- mode : use mode of posterior for Bayesian interval (default is mean)
- shortest: use shortest interval (done by default if mode is set)
- central: use central interval (done by default if mode is NOT set)
- pois: interpret histograms as poisson ratio instead of efficiency
- e0 : plot efficiency and interval for bins where total=0 (default is to skip them)

Note: Unfortunately there is no straightforward approach for determining a confidence interval for a given confidence level. The actual coverage probability of the confidence interval oscillates significantly according to the total number of events and the true efficiency. In order to decrease the impact of this oscillation on the actual coverage probability a couple of approximations and methodes has been developed. For a detailed discussion, please have a look at this statistical paper: [http://www-stat.wharton.upenn.edu/~tcai/paper/Binomial-StatSci.pdf](http://www-stat.wharton.upenn.edu/~tcai/paper/Binomial-StatSci.pdf)
""" Divide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of Int_t TGraphAsymmErrors::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TGraphAsymmErrors}, list::ByPtr1{TCollection})::Int32
Adds all graphs with asymmetric errors from the collection to this graph.
Returns the total number of points in the result or -1 in case of an error.
""" Merge(this::ByRef1{TGraphAsymmErrors}, list::ByPtr1{TCollection})

# Wrapper of TGraphAsymmErrors & TGraphAsymmErrors::operator=(const TGraphAsymmErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraphAsymmErrors}, gr::ByConstRef1{TGraphAsymmErrors})::CxxRef1{TGraphAsymmErrors}
[TGraphAsymmErrors](@ref) assignment operator.

""" assign(this::ByRef1{TGraphAsymmErrors}, gr::ByConstRef1{TGraphAsymmErrors})

# Wrapper of void TGraphAsymmErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphAsymmErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphAsymmErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "xy" both x and y values and errors are scaled
""" Scale(this::ByRef1{TGraphAsymmErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphAsymmErrors::SetPointError(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphAsymmErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)::Nothing
Set ex and ey values for point pointed by the mouse.

""" SetPointError(this::ByRef1{TGraphAsymmErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointError(Int_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)::Nothing
Set ex and ey values for point number i.

""" SetPointError(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEXhigh(Int_t, Double_t)
@trydoc raw"""
    SetPointEXhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, exh::Float64)::Nothing
Set EXhigh for point `i`.

""" SetPointEXhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, exh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEXlow(Int_t, Double_t)
@trydoc raw"""
    SetPointEXlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64)::Nothing
Set EXlow for point `i`.

""" SetPointEXlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEYhigh(Int_t, Double_t)
@trydoc raw"""
    SetPointEYhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyh::Float64)::Nothing
Set EYhigh for point `i`.

""" SetPointEYhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEYlow(Int_t, Double_t)
@trydoc raw"""
    SetPointEYlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyl::Float64)::Nothing
Set EYlow for point `i`.

""" SetPointEYlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyl::Float64)

# Wrapper of TGraph2DAsymmErrors & TGraph2DAsymmErrors::operator=(const TGraph2DAsymmErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraph2DAsymmErrors}, ::ByConstRef1{TGraph2DAsymmErrors})::CxxRef1{TGraph2DAsymmErrors}
Assignment operator Copy everything except list of functions.

""" assign(this::ByRef1{TGraph2DAsymmErrors}, ::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Int_t TGraph2DAsymmErrors::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph2DAsymmErrors}, ipoint::Int32)::Int32
Deletes point number ipoint.

""" RemovePoint(this::ByRef1{TGraph2DAsymmErrors}, ipoint::Int32)

# Wrapper of void TGraph2DAsymmErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph2DAsymmErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraph2DAsymmErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "z" the z values and errors are scaled If option contains "xyz" all three x, y and z values and errors are scaled
""" Scale(this::ByRef1{TGraph2DAsymmErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph2DAsymmErrors::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph2DAsymmErrors}, n::Int32)::Nothing
Set number of points in the 2D graph.
Existing coordinates are preserved. New coordinates above fNpoints are preset to 0.
""" Set(this::ByRef1{TGraph2DAsymmErrors}, n::Int32)

# Wrapper of void TGraph2DAsymmErrors::SetPoint(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, x::Float64, y::Float64, z::Float64)::Nothing
Set x, y and z values for point number i.

""" SetPoint(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2DAsymmErrors::SetPointError(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, ezl::Float64, ezh::Float64)::Nothing
Set ex, ey and ez values for point number i.

""" SetPointError(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, ezl::Float64, ezh::Float64)

# Wrapper of void TH2::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, bin::Int32)

# Wrapper of void TH2::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, bin::Int32, w::Float64)

# Wrapper of void TH2::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of void TH2::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of Int_t TH2::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TH2}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TH2}, action::Int32)

# Wrapper of Int_t TH2::Fill(const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,namey

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH2::Fill(const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, namex::ByCopy{String}, y::Float64, w::Float64)::Int32
Increment cell defined by namex,y by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,y

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, namex::ByCopy{String}, y::Float64, w::Float64)

# Wrapper of Int_t TH2::Fill(Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, x::Float64, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to x,y.

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, x::Float64, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH2::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, x::Float64, y::Float64)::Int32
Increment cell defined by x,y by 1.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the storage of the sum of squares of weights has been triggered, via the function Sumw2, then the sum of the squares of weights is incremented by 1 in the cell corresponding to x,y.

The function returns the corresponding global_ bin number which has its content incremented by 1
""" Fill(this::ByRef1{TH2}, x::Float64, y::Float64)

# Wrapper of Int_t TH2::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, x::Float64, y::Float64, w::Float64)::Int32
Increment cell defined by x,y by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to x,y

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, x::Float64, y::Float64, w::Float64)

# Wrapper of void TH2::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill a 2-D histogram with an array of values and weights.
- ntimes: number of entries in arrays x and w (array size must be ntimes*stride)
- x: array of x values to be histogrammed
- y: array of y values to be histogrammed
- w: array of weights
- stride: step size through arrays x, y and w

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w[i]^2 in the bin corresponding to x[i],y[i].
    - If w is NULL each entry is assumed a weight=1

NB: function only valid for a TH2x object
""" FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of void TH2::FillN(Int_t, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill this histogram with an array x and weights w.
## Arguments

- **`ntimes`** [in] 
    number of entries in arrays x and w (array size must be ntimes*stride) 
    
- **`x`** [in] 
    array of values to be histogrammed 
    
- **`w`** [in] 
    array of weighs 
    
- **`stride`** [in] 
    step size through arrays x and w
    

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x. if w is NULL each entry is assumed a weight=1
""" FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of void TH2::FillRandom(const char *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH2}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in function fname.
## Arguments

- **`fname`** 
    : Function name used for filling the histogram 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used to sample
    

The distribution contained in the function fname ([TF2](@ref)) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

One can also call [TF2!GetRandom2](@ref) to get a random variate from a function.
""" FillRandom(this::ByRef1{TH2}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH2::FillRandom(TH1 *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH2}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in histogram h.
## Arguments

- **`h`** 
    : Histogram pointer used for sampling random number 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used for sampling
    

The distribution contained in the histogram h ([TH2](@ref)) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated
""" FillRandom(this::ByRef1{TH2}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH2::FitSlicesX(TF1 *, Int_t, Int_t, Int_t, Option_t *, TObjArray *)
@trydoc raw"""
    FitSlicesX(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstybin::Int32, lastybin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})::Nothing
Project slices along X in case of a 2-D histogram, then fit each slice with function f1 and make a histogram for each fit parameter Only bins along Y between firstybin and lastybin are considered.
By default (firstybin == 0, lastybin == -1), all bins in y including over- and underflows are taken into account. If f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along X via f1->SetRange(xmin,xmax) The argument option (default="QNR") can be used to change the fit options.

- "Q" means Quiet mode
- "N" means do not show the result of the fit
- "R" means fit the function in the specified function range
- "G2" merge 2 consecutive bins along X
- "G3" merge 3 consecutive bins along X
- "G4" merge 4 consecutive bins along X
- "G5" merge 5 consecutive bins along X
- "S" sliding merge: merge n consecutive bins along X accordingly to what Gn is given. It makes sense when used together with a Gn option

The generated histograms are returned by adding them to arr, if arr is not NULL. arr's SetOwner() is called, to signal that it is the user's responsibility to delete the histograms, possibly by deleting the array. 

    TObjArray aSlices;
    h2->FitSlicesX(func, 0, -1, 0, "QNR", &aSlices);

(C++ version of the code)

 will already delete the histograms once aSlice goes out of scope. aSlices will contain the histogram for the i-th parameter of the fit function at aSlices[i]; aSlices[n] (n being the number of parameters) contains the chi2 distribution of the fits.

If arr is NULL, the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.

Example: Assume a 2-d histogram h2 

    Root > h2->FitSlicesX(); produces 4 TH1D histograms
           with h2_0 containing parameter 0(Constant) for a Gaus fit
                     of each bin in Y projected along X
           with h2_1 containing parameter 1(Mean) for a gaus fit
           with h2_2 containing parameter 2(StdDev)  for a gaus fit
           with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit
    Root > h2->FitSlicesX(0,15,22,10);
           same as above, but only for bins 15 to 22 along Y
           and only for bins in Y for which the corresponding projection
           along X has more than cut bins filled.

(C++ version of the code)

 NOTE: To access the generated histograms in the current directory, do eg: 

    TH1D *h2_1 = (TH1D*)gDirectory->Get("h2_1");

(C++ version of the code)
""" FitSlicesX(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstybin::Int32, lastybin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})

# Wrapper of void TH2::FitSlicesY(TF1 *, Int_t, Int_t, Int_t, Option_t *, TObjArray *)
@trydoc raw"""
    FitSlicesY(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstxbin::Int32, lastxbin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})::Nothing
Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a histogram for each fit parameter Only bins along X between firstxbin and lastxbin are considered.
By default (firstxbin == 0, lastxbin == -1), all bins in x including over- and underflows are taken into account. If f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along Y via f1->SetRange(ymin,ymax) The argument option (default="QNR") can be used to change the fit options.

- "Q" means Quiet mode
- "N" means do not show the result of the fit
- "R" means fit the function in the specified function range
- "G2" merge 2 consecutive bins along Y
- "G3" merge 3 consecutive bins along Y
- "G4" merge 4 consecutive bins along Y
- "G5" merge 5 consecutive bins along Y
- "S" sliding merge: merge n consecutive bins along Y accordingly to what Gn is given. It makes sense when used together with a Gn option

The generated histograms are returned by adding them to arr, if arr is not NULL. arr's SetOwner() is called, to signal that it is the user's responsibility to delete the histograms, possibly by deleting the array. 

    TObjArray aSlices;
    h2->FitSlicesY(func, 0, -1, 0, "QNR", &aSlices);

(C++ version of the code)

 will already delete the histograms once aSlice goes out of scope. aSlices will contain the histogram for the i-th parameter of the fit function at aSlices[i]; aSlices[n] (n being the number of parameters) contains the chi2 distribution of the fits.

If arr is NULL, the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.

Example: Assume a 2-d histogram h2 

    Root > h2->FitSlicesY(); produces 4 TH1D histograms
           with h2_0 containing parameter 0(Constant) for a Gaus fit
                     of each bin in X projected along Y
           with h2_1 containing parameter 1(Mean) for a gaus fit
           with h2_2 containing parameter 2(StdDev)  for a gaus fit
           with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit
    Root > h2->FitSlicesY(0,15,22,10);
           same as above, but only for bins 15 to 22 along X
           and only for bins in X for which the corresponding projection
           along Y has more than cut bins filled.

(C++ version of the code)

NOTE: To access the generated histograms in the current directory, do eg: 

    TH1D *h2_1 = (TH1D*)gDirectory->Get("h2_1");

(C++ version of the code)

A complete example of this function is given in tutorial:fitslicesy.C.
""" FitSlicesY(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstxbin::Int32, lastxbin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})

# Wrapper of Double_t TH2::GetBinErrorLow(Int_t, Int_t)
@trydoc raw"""
    GetBinErrorLow(this::ByRef1{TH2}, binx::Int32, biny::Int32)::Float64


""" GetBinErrorLow(this::ByRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of Double_t TH2::GetBinErrorUp(Int_t, Int_t)
@trydoc raw"""
    GetBinErrorUp(this::ByRef1{TH2}, binx::Int32, biny::Int32)::Float64


""" GetBinErrorUp(this::ByRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of void TH2::GetRandom2(Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom2(this::ByRef1{TH2}, x::ByRef2{Float64}, y::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D histogram.
Return a NaN if the histogram has a bin with negative content

## Arguments

- **`x`** [out] 
    reference to random generated x value 
    
- **`y`** [out] 
    reference to random generated y value 
    
- **`rng`** [in] 
    (optional) Random number generator pointer used (default is gRandom)
""" GetRandom2(this::ByRef1{TH2}, x::ByRef2{Float64}, y::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of void TH2::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TH2}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TH2}, stats::ByPtr2{Float64})

# Wrapper of TH2 * TH2::Rebin(Int_t, const char *, const Double_t *)
@trydoc raw"""
    Rebin(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})::CxxPtr1{TH2}
Override [TH1!Rebin](@ref) as [TH2!RebinX](@ref) Rebinning in variable binning as for [TH1](@ref) is not allowed If a non-null pointer is given an error is flagged see RebinX and Rebin2D.

""" Rebin(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})

# Wrapper of TH2 * TH2::Rebin2D(Int_t, Int_t, const char *)
@trydoc raw"""
    Rebin2D(this::ByRef1{TH2}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})::CxxPtr1{TH2}
Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.
if newname is not blank a new temporary histogram hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to me merged into one bin of hnew If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

examples: if hpxpy is an existing [TH2](@ref) histogram with 40 x 40 bins 

    hpxpy->Rebin2D();  // merges two bins along the xaxis and yaxis in one in hpxpy
                       // Carefull: previous contents of hpxpy are lost
    hpxpy->RebinX(5);  //merges five bins along the xaxis in one in hpxpy
    TH2 *hnew = hpxpy->RebinY(5,"hnew"); // creates a new histogram hnew
                                         // merging 5 bins of h1 along the yaxis in one bin

(C++ version of the code)

NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned histogram is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.
""" Rebin2D(this::ByRef1{TH2}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})

# Wrapper of TH2 * TH2::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH2}
Rebin only the X axis see Rebin2D.

""" RebinX(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TH2 * TH2::RebinY(Int_t, const char *)
@trydoc raw"""
    RebinY(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH2}
Rebin only the Y axis see Rebin2D.

""" RebinY(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TH2::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2}, option::ByCopy{String})

# Wrapper of void TH2::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2}, bin::Int32, content::Float64)::Nothing
Set bin content.

""" SetBinContent(this::ByRef1{TH2}, bin::Int32, content::Float64)

# Wrapper of void TH2::SetBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, content::Float64)

# Wrapper of void TH2::SetBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, ::Int32, content::Float64)

# Wrapper of void TH2::SetShowProjectionX(Int_t)
@trydoc raw"""
    SetShowProjectionX(this::ByRef1{TH2}, nbins::Int32)::Nothing
When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the projection along X corresponding to the mouse position along Y.
To stop the generation of the projections, delete the canvas containing the projection. ## Arguments

- **`nbins`** 
    number of bins in Y to sum across for the projection
""" SetShowProjectionX(this::ByRef1{TH2}, nbins::Int32)

# Wrapper of void TH2::SetShowProjectionXY(Int_t, Int_t)
@trydoc raw"""
    SetShowProjectionXY(this::ByRef1{TH2}, nbinsY::Int32, nbinsX::Int32)::Nothing
When the mouse is moved in a pad containing a 2-d view of this histogram two canvases show the projection along X and Y corresponding to the mouse position along Y and X, respectively.
To stop the generation of the projections, delete the canvas containing the projection. ## Arguments

- **`nbinsY`** 
    number of bins in Y to sum across for the x projection 
    
- **`nbinsX`** 
    number of bins in X to sum across for the y projection
""" SetShowProjectionXY(this::ByRef1{TH2}, nbinsY::Int32, nbinsX::Int32)

# Wrapper of void TH2::SetShowProjectionY(Int_t)
@trydoc raw"""
    SetShowProjectionY(this::ByRef1{TH2}, nbins::Int32)::Nothing
When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the projection along Y corresponding to the mouse position along X.
To stop the generation of the projections, delete the canvas containing the projection. ## Arguments

- **`nbins`** 
    number of bins in X to sum across for the projection
""" SetShowProjectionY(this::ByRef1{TH2}, nbins::Int32)

# Wrapper of TH1 * TH2::ShowBackground(Int_t, Option_t *)
@trydoc raw"""
    ShowBackground(this::ByRef1{TH2}, niter::Int32, option::ByCopy{String})::CxxPtr1{TH1}
This function calculates the background spectrum in this histogram.
The background is returned as a histogram. to be implemented (may be)
""" ShowBackground(this::ByRef1{TH2}, niter::Int32, option::ByCopy{String})

# Wrapper of Int_t TH2::ShowPeaks(Double_t, Option_t *, Double_t)
@trydoc raw"""
    ShowPeaks(this::ByRef1{TH2}, sigma::Float64, option::ByCopy{String}, threshold::Float64)::Int32
Interface to [TSpectrum2!Search](@ref) the function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this.
for more details see [TSpectrum!Search](@ref). note the difference in the default value for option compared to [TSpectrum2!Search](@ref) option="" by default (instead of "goff")
""" ShowPeaks(this::ByRef1{TH2}, sigma::Float64, option::ByCopy{String}, threshold::Float64)

# Wrapper of void TH2::Smooth(Int_t, Option_t *)
@trydoc raw"""
    Smooth(this::ByRef1{TH2}, ntimes::Int32, option::ByCopy{String})::Nothing
Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community.
Bin contents in the active range are replaced by their smooth values. The algorithm retains the input dimension by using Kernel Crop at the input boundaries. Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the normalization accordingly. If Errors are defined via Sumw2, they are also scaled and computed. However, note the resulting errors will be correlated between different-bins, so the errors should not be used blindly to perform any calculation involving several bins, like fitting the histogram. One would need to compute also the bin by bin correlation matrix.

3 kernels are proposed k5a, k5b and k3a. k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j) k5b is a bit more stronger in smoothing k3a acts only on 3x3 cells (i-1,i,i+1, and same for j). By default the kernel "k5a" is used. You can select the kernels "k5b" or "k3a" via the option argument. If [TAxis!SetRange](@ref) has been called on the x or/and y axis, only the bins in the specified range are smoothed. In the current implementation if the first argument is not used (default value=1).

implementation by David McKee ([dmckee@bama.ua.edu](mailto:dmckee@bama.ua.edu)). Extended by Rene Brun
""" Smooth(this::ByRef1{TH2}, ntimes::Int32, option::ByCopy{String})

# Wrapper of void TFormula::AddParameter(const TString &, Double_t)
@trydoc raw"""
    AddParameter(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)::Nothing


""" AddParameter(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TFormula::AddVariable(const TString &, Double_t)
@trydoc raw"""
    AddVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)::Nothing
Adds variable to known variables, and reprocess formula.

""" AddVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TFormula::AddVariables(const TString *, const Int_t)
@trydoc raw"""
    AddVariables(this::ByRef1{TFormula}, vars::ByConstPtr1{TString}, size::ByCopy{Int32})::Nothing
Adds multiple variables.
First argument is an array of pairs<TString,Double>, where first argument is name of variable, second argument represents value. size - number of variables passed in first argument
""" AddVariables(this::ByRef1{TFormula}, vars::ByConstPtr1{TString}, size::ByCopy{Int32})

# Wrapper of void TFormula::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TFormula}, option::ByCopy{String})::Nothing
Clear the formula setting expression to empty and reset the variables and parameters containers.

""" Clear(this::ByRef1{TFormula}, option::ByCopy{String})

# Wrapper of Int_t TFormula::Compile(const char *)
@trydoc raw"""
    Compile(this::ByRef1{TFormula}, expression::ByCopy{String})::Int32
Compile the given expression with Cling backward compatibility method to be used in combination with the empty constructor if no expression is given , the current stored formula (retrieved with [GetExpFormula()](@ref)) or the title is used.
return 0 if the formula compilation is successful
""" Compile(this::ByRef1{TFormula}, expression::ByCopy{String})

# Wrapper of bool TFormula::GenerateGradientPar()
@trydoc raw"""
    GenerateGradientPar(this::ByRef1{TFormula})::Bool
Generate gradient computation routine with respect to the parameters.
returns true on success.

###Return

true if a gradient was generated and GradientPar can be called.
""" GenerateGradientPar(this::ByRef1{TFormula})

# Wrapper of bool TFormula::GenerateHessianPar()
@trydoc raw"""
    GenerateHessianPar(this::ByRef1{TFormula})::Bool
Generate hessian computation routine with respect to the parameters.
returns true on success.

###Return

true if a hessian was generated and HessianPar can be called.
""" GenerateHessianPar(this::ByRef1{TFormula})

# Wrapper of void TFormula::GradientPar(const Double_t *, Double_t *)
@trydoc raw"""
    GradientPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})::Nothing
Compute the gradient with respect to the parameter passing a buffer with a size at least equal to the number of parameters.
Note that the result buffer needs to be initialized to zero before passed to this function.
""" GradientPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})

# Wrapper of void TFormula::HessianPar(const Double_t *, Double_t *)
@trydoc raw"""
    HessianPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})::Nothing


""" HessianPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})

# Wrapper of TFormula & TFormula::operator=(const TFormula &)
@trydoc raw"""
    assign(this::ByRef1{TFormula}, rhs::ByConstRef1{TFormula})::CxxRef1{TFormula}
= operator.

""" assign(this::ByRef1{TFormula}, rhs::ByConstRef1{TFormula})

# Wrapper of void TFormula::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TFormula}, name::ByCopy{String})::Nothing
Set the name of the formula.
We need to allow the list of function to properly handle the hashes.
""" SetName(this::ByRef1{TFormula}, name::ByCopy{String})

# Wrapper of void TFormula::SetParameter(const char *, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TFormula}, name::ByCopy{String}, value::Float64)::Nothing
Sets parameter value.

""" SetParameter(this::ByRef1{TFormula}, name::ByCopy{String}, value::Float64)

# Wrapper of void TFormula::SetParameter(Int_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TFormula}, param::Int32, value::Float64)::Nothing
Set a parameter given a parameter index.
The parameter index is by default the alphabetic order given to the parameters, apart if the users has defined explicitly the parameter names.
""" SetParameter(this::ByRef1{TFormula}, param::Int32, value::Float64)

# Wrapper of void TFormula::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TFormula}, params::ByConstPtr2{Float64})::Nothing
Set a vector of parameters value.
Order in the vector is by default the alphabetic order given to the parameters apart if the users has defined explicitly the parameter names
""" SetParameters(this::ByRef1{TFormula}, params::ByConstPtr2{Float64})

# Wrapper of void TFormula::SetParName(Int_t, const char *)
@trydoc raw"""
    SetParName(this::ByRef1{TFormula}, ipar::Int32, name::ByCopy{String})::Nothing


""" SetParName(this::ByRef1{TFormula}, ipar::Int32, name::ByCopy{String})

# Wrapper of void TFormula::SetVariable(const TString &, Double_t)
@trydoc raw"""
    SetVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)::Nothing
Sets variable value.

""" SetVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TFormula::SetVectorized(Bool_t)
@trydoc raw"""
    SetVectorized(this::ByRef1{TFormula}, vectorized::Bool)::Nothing


""" SetVectorized(this::ByRef1{TFormula}, vectorized::Bool)

# Wrapper of double TF1AbsComposition::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByRef1{TF1AbsComposition}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64


""" paren(this::ByRef1{TF1AbsComposition}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of void TF1AbsComposition::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1AbsComposition}, params::ByConstPtr2{Float64})::Nothing


""" SetParameters(this::ByRef1{TF1AbsComposition}, params::ByConstPtr2{Float64})

# Wrapper of void TF1AbsComposition::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1AbsComposition}, a::Float64, b::Float64)::Nothing


""" SetRange(this::ByRef1{TF1AbsComposition}, a::Float64, b::Float64)

# Wrapper of void TF1AbsComposition::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1AbsComposition})::Nothing


""" Update(this::ByRef1{TF1AbsComposition})

# Wrapper of TF1Parameters & TF1Parameters::operator=(const TF1Parameters &)
@trydoc raw"""
    assign(this::ByRef1{TF1Parameters}, rhs::ByConstRef1{TF1Parameters})::CxxRef1{TF1Parameters}


""" assign(this::ByRef1{TF1Parameters}, rhs::ByConstRef1{TF1Parameters})

# Wrapper of void TF1Parameters::SetParameter(const char *, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1Parameters}, name::ByCopy{String}, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1Parameters}, name::ByCopy{String}, value::Float64)

# Wrapper of void TF1Parameters::SetParameter(Int_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1Parameters}, iparam::Int32, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1Parameters}, iparam::Int32, value::Float64)

# Wrapper of void TF1Parameters::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1Parameters}, params::ByConstPtr2{Float64})::Nothing


""" SetParameters(this::ByRef1{TF1Parameters}, params::ByConstPtr2{Float64})

# Wrapper of void TF1Parameters::SetParName(Int_t, const char *)
@trydoc raw"""
    SetParName(this::ByRef1{TF1Parameters}, iparam::Int32, name::ByCopy{String})::Nothing


""" SetParName(this::ByRef1{TF1Parameters}, iparam::Int32, name::ByCopy{String})

# Wrapper of Double_t TF2::CentralMoment2(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CentralMoment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny central moment of a 2d function in range [ax,bx],[ay,by].
###Author

Gene Van Buren gene@bnl.gov
""" CentralMoment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Covariance2XY(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance2XY(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Covariance2XY(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of TH1 * TF2::CreateHistogram()
@trydoc raw"""
    CreateHistogram(this::ByRef1{TF2})::CxxPtr1{TH1}
Create a histogram from function.
always created it, even if it is already existing
""" CreateHistogram(this::ByRef1{TF2})

# Wrapper of Int_t TF2::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TF2}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a function.
## Arguments

- **`px`** [in] 
    x position 
    
- **`py`** [in] 
    y position
    

Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TF2}, px::Int32, py::Int32)

# Wrapper of void TF2::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TF2}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.
NB. You must use DrawCopy if you want to draw several times the same function in the current canvas.
""" Draw(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of TObject * TF2::DrawDerivative(Option_t *)
@trydoc raw"""
    DrawDerivative(this::ByRef1{TF2}, option::ByCopy{String})::CxxPtr1{TObject}
Draw derivative of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawDerivative(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawDerivative(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of TObject * TF2::DrawIntegral(Option_t *)
@trydoc raw"""
    DrawIntegral(this::ByRef1{TF2}, option::ByCopy{String})::CxxPtr1{TObject}
Draw integral of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawIntegral(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawIntegral(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of void TF2::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TF2}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a F2 is clicked with the locator
""" ExecuteEvent(this::ByRef1{TF2}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TF2::GetContour(Double_t *)
@trydoc raw"""
    GetContour(this::ByRef1{TF2}, levels::ByPtr2{Float64})::Int32
Return contour values into array levels.
The number of contour levels can be returned by getContourLevel
""" GetContour(this::ByRef1{TF2}, levels::ByPtr2{Float64})

# Wrapper of Double_t TF2::GetRandom(Double_t, Double_t, TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape.

""" GetRandom(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of Double_t TF2::GetRandom(TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF2}, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape.

""" GetRandom(this::ByRef1{TF2}, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of void TF2::GetRandom2(Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom2(this::ByRef1{TF2}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 2 random numbers following this function shape.
The distribution contained in this [TF2](@ref) function is integrated over the cell contents. It is normalized to 1. Getting the two random numbers implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which cell in the normalized integral r1 corresponds to
- make a linear interpolation in the returned cell

IMPORTANT NOTE

The integral of the function is computed at fNpx * fNpy points. If the function has sharp peaks, you should increase the number of points (SetNpx, SetNpy) such that the peak is correctly tabulated at several points.
""" GetRandom2(this::ByRef1{TF2}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of Double_t TF2::GetSave(const Double_t *)
@trydoc raw"""
    GetSave(this::ByRef1{TF2}, x::ByConstPtr2{Float64})::Float64
Get value corresponding to X in array of fSave values.

""" GetSave(this::ByRef1{TF2}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF2::Integral(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Integral(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsrel::Float64)::Float64
Return Integral of a 2d function in range [ax,bx],[ay,by] with desired relative accuracy (defined by eps)

""" Integral(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsrel::Float64)

# Wrapper of Double_t TF2::Mean2X(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Mean2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Mean2Y(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Mean2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Moment2(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Moment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny moment of a 2d function in range [ax,bx],[ay,by].
###Author

Gene Van Buren gene@bnl.gov
""" Moment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of TF2 & TF2::operator=(const TF2 &)
@trydoc raw"""
    assign(this::ByRef1{TF2}, rhs::ByConstRef1{TF2})::CxxRef1{TF2}
Operator =.

""" assign(this::ByRef1{TF2}, rhs::ByConstRef1{TF2})

# Wrapper of void TF2::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TF2}, option::ByCopy{String})::Nothing
Paint this 2-D function with its current attributes.

""" Paint(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of void TF2::Save(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Save(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Nothing
Save values of function in array fSave.

""" Save(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TF2::SetContour(Int_t, const Double_t *)
@trydoc raw"""
    SetContour(this::ByRef1{TF2}, nlevels::Int32, levels::ByConstPtr2{Float64})::Nothing
Set the number and values of contour levels.
By default the number of contour levels is set to 20.

if argument levels = 0 or missing, equidistant contours are computed
""" SetContour(this::ByRef1{TF2}, nlevels::Int32, levels::ByConstPtr2{Float64})

# Wrapper of void TF2::SetContourLevel(Int_t, Double_t)
@trydoc raw"""
    SetContourLevel(this::ByRef1{TF2}, level::Int32, value::Float64)::Nothing
Set value for one contour level.

""" SetContourLevel(this::ByRef1{TF2}, level::Int32, value::Float64)

# Wrapper of void TF2::SetNpy(Int_t)
@trydoc raw"""
    SetNpy(this::ByRef1{TF2}, npy::Int32)::Nothing
Set the number of points used to draw the function.
The default number of points along x is 30 for 2-d/3-d functions. You can increase this value to get a better resolution when drawing pictures with sharp peaks or to get a better result when using [TF2!GetRandom2](@ref) the minimum number of points is 4, the maximum is 10000 for 2-d/3-d functions
""" SetNpy(this::ByRef1{TF2}, npy::Int32)

# Wrapper of void TF2::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF2}, xmin::Float64, xmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.
The function range is also used in an histogram fit operation when the option "R" is specified.
""" SetRange(this::ByRef1{TF2}, xmin::Float64, xmax::Float64)

# Wrapper of void TF2::SetRange(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function-.

""" SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TF2::SetRange(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)::Nothing


""" SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)

# Wrapper of Double_t TF2::Variance2X(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Variance2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Variance2Y(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Variance2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF12::EvalPar(const Double_t *, const Double_t *)
@trydoc raw"""
    EvalPar(this::ByRef1{TF12}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Float64
Evaluate this function at point x[0].
x[0] is the value along X if fCase =0, the value along Y if fCase=1 if params is non null, the array will be used instead of the internal [TF2](@ref) parameters
""" EvalPar(this::ByRef1{TF12}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of void TF12::SetXY(Double_t)
@trydoc raw"""
    SetXY(this::ByRef1{TF12}, xy::Float64)::Nothing
Set the value of the constant for the [TF2](@ref).
constant in X when projecting along Y constant in Y when projecting along X The function title is set to include the value of the constant The current pad is updated
""" SetXY(this::ByRef1{TF12}, xy::Float64)

# Wrapper of Int_t TSpline::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TSpline}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a spline.

""" DistancetoPrimitive(this::ByRef1{TSpline}, px::Int32, py::Int32)

# Wrapper of void TSpline::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TSpline}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.
Possible option values are:

- "SAME" superimpose on top of existing picture
- "L" connect all computed points with a straight line
- "C" connect all computed points with a smooth curve.
- "P" add a polymarker at each knot

Note that the default value is "L". Therefore to draw on top of an existing picture, specify option "LSAME"
""" Draw(this::ByRef1{TSpline}, option::ByCopy{String})

# Wrapper of void TSpline::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TSpline}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.

""" ExecuteEvent(this::ByRef1{TSpline}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TSpline::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TSpline}, option::ByCopy{String})::Nothing
Paint this function with its current attributes.

""" Paint(this::ByRef1{TSpline}, option::ByCopy{String})

# Wrapper of void TSpline::SetNpx(Int_t)
@trydoc raw"""
    SetNpx(this::ByRef1{TSpline}, n::Int32)::Nothing


""" SetNpx(this::ByRef1{TSpline}, n::Int32)

# Wrapper of Double_t TF1Convolution::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByRef1{TF1Convolution}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64
Used in [TF1](@ref) when doing the fit, will be evaluated at each point.

""" paren(this::ByRef1{TF1Convolution}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of TF1Convolution & TF1Convolution::operator=(const TF1Convolution &)
@trydoc raw"""
    assign(this::ByRef1{TF1Convolution}, rhs::ByConstRef1{TF1Convolution})::CxxRef1{TF1Convolution}
Operator =.

""" assign(this::ByRef1{TF1Convolution}, rhs::ByConstRef1{TF1Convolution})

# Wrapper of void TF1Convolution::SetExtraRange(Double_t)
@trydoc raw"""
    SetExtraRange(this::ByRef1{TF1Convolution}, percentage::Float64)::Nothing
Set the fraction of extra range used when doing an FFT convolution.
The extra range is often needed to avoid mirroring effect of the resulting convolution function at the borders. By default an extra range of 0.1 is used.
""" SetExtraRange(this::ByRef1{TF1Convolution}, percentage::Float64)

# Wrapper of void TF1Convolution::SetNofPointsFFT(Int_t)
@trydoc raw"""
    SetNofPointsFFT(this::ByRef1{TF1Convolution}, n::Int32)::Nothing
Set the number of points used for the FFT convolution.

""" SetNofPointsFFT(this::ByRef1{TF1Convolution}, n::Int32)

# Wrapper of void TF1Convolution::SetNumConv(Bool_t)
@trydoc raw"""
    SetNumConv(this::ByRef1{TF1Convolution}, flag::Bool)::Nothing


""" SetNumConv(this::ByRef1{TF1Convolution}, flag::Bool)

# Wrapper of void TF1Convolution::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1Convolution}, params::ByConstPtr2{Float64})::Nothing
Set the vector of parameters p for the convolution function [g(x,p)](@ref) = f1 * f2.

""" SetParameters(this::ByRef1{TF1Convolution}, params::ByConstPtr2{Float64})

# Wrapper of void TF1Convolution::SetParameters(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1Convolution}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64)::Nothing
Set the parameter values for the convolution function.

""" SetParameters(this::ByRef1{TF1Convolution}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64)

# Wrapper of void TF1Convolution::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1Convolution}, a::Float64, b::Float64)::Nothing
Set the actual range used for the convolution.
In case a or b are -inf or +inf and FFT convolution is used, then the range of the first function will be used and extended by the default extra range fraction.
""" SetRange(this::ByRef1{TF1Convolution}, a::Float64, b::Float64)

# Wrapper of void TF1Convolution::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1Convolution})::Nothing
Update the two component functions of the convolution.

""" Update(this::ByRef1{TF1Convolution})

# Wrapper of double TF1NormSum::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByRef1{TF1NormSum}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64
Overload the parenthesis to add the functions.

""" paren(this::ByRef1{TF1NormSum}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of TF1NormSum & TF1NormSum::operator=(const TF1NormSum &)
@trydoc raw"""
    assign(this::ByRef1{TF1NormSum}, rhs::ByConstRef1{TF1NormSum})::CxxRef1{TF1NormSum}
Operator =.

""" assign(this::ByRef1{TF1NormSum}, rhs::ByConstRef1{TF1NormSum})

# Wrapper of void TF1NormSum::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1NormSum}, params::ByConstPtr2{Float64})::Nothing
Initialize array of all parameters.
double *params must contains first an array of the coefficients, then an array of the parameters.
""" SetParameters(this::ByRef1{TF1NormSum}, params::ByConstPtr2{Float64})

# Wrapper of void TF1NormSum::SetParameters(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1NormSum}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)::Nothing
Initialize array of all parameters.
Overload the [TF1!SetParameters()](@ref) method. A maximum of 10 parameters must be used, with first the coefficients, then the parameters
""" SetParameters(this::ByRef1{TF1NormSum}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)

# Wrapper of void TF1NormSum::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1NormSum}, a::Float64, b::Float64)::Nothing


""" SetRange(this::ByRef1{TF1NormSum}, a::Float64, b::Float64)

# Wrapper of void TF1NormSum::SetScale(Double_t)
@trydoc raw"""
    SetScale(this::ByRef1{TF1NormSum}, scale::Float64)::Nothing


""" SetScale(this::ByRef1{TF1NormSum}, scale::Float64)

# Wrapper of void TF1NormSum::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1NormSum})::Nothing
Update the component functions of the normalized sum.

""" Update(this::ByRef1{TF1NormSum})

# Wrapper of Double_t TF3::CentralMoment3(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CentralMoment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny * z^nz central moment of a 3d function in range [ax,bx],[ay,by],[az,bz].
###Author

Gene Van Buren gene@bnl.gov
""" CentralMoment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Covariance3XY(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance3XY(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Covariance3XY(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Covariance3XZ(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance3XZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Covariance3XZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Covariance3YZ(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance3YZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Covariance3YZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of TH1 * TF3::CreateHistogram()
@trydoc raw"""
    CreateHistogram(this::ByRef1{TF3})::CxxPtr1{TH1}
Create a histogram for axis range.

""" CreateHistogram(this::ByRef1{TF3})

# Wrapper of Int_t TF3::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TF3}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a function.
Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TF3}, px::Int32, py::Int32)

# Wrapper of void TF3::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TF3}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.

""" Draw(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of TObject * TF3::DrawDerivative(Option_t *)
@trydoc raw"""
    DrawDerivative(this::ByRef1{TF3}, option::ByCopy{String})::CxxPtr1{TObject}
Draw derivative of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawDerivative(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawDerivative(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of TObject * TF3::DrawIntegral(Option_t *)
@trydoc raw"""
    DrawIntegral(this::ByRef1{TF3}, option::ByCopy{String})::CxxPtr1{TObject}
Draw integral of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawIntegral(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawIntegral(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of void TF3::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TF3}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a F3 is clicked with the locator
""" ExecuteEvent(this::ByRef1{TF3}, event::Int32, px::Int32, py::Int32)

# Wrapper of Double_t TF3::GetMaximumXYZ(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetMaximumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})::Float64
Compute the X, Y and Z values corresponding to the maximum value of the function on its range.
Return the function value at the maximum. See [TF3!GetMinimumXYZ](@ref)
""" GetMaximumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})

# Wrapper of Double_t TF3::GetMinimumXYZ(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetMinimumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})::Float64
Compute the X, Y and Z values corresponding to the minimum value of the function on its range.
Returns the function value at the minimum. To find the minimum on a subrange, use the [SetRange()](@ref) function first.

Method: First, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx,fNpy and fNpz sub-ranges. If the function is "good" (or "bad"), these values can be changed by [SetNpx()](@ref), [SetNpy()](@ref) and [SetNpz()](@ref) functions. Then, Minuit minimization is used with starting values found by the grid search

Note that this method will always do first a grid search in contrast to GetMinimum
""" GetMinimumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})

# Wrapper of void TF3::GetRandom3(Double_t &, Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom3(this::ByRef1{TF3}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, zrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 3 random numbers following this function shape.
The distribution contained in this [TF3](@ref) function is integrated over the cell contents. It is normalized to 1. Getting the three random numbers implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which cell in the normalized integral r1 corresponds to
- make a linear interpolation in the returned cell

IMPORTANT NOTE

The integral of the function is computed at fNpx * fNpy * fNpz points. If the function has sharp peaks, you should increase the number of points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated at several points.
""" GetRandom3(this::ByRef1{TF3}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, zrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of Double_t TF3::GetSave(const Double_t *)
@trydoc raw"""
    GetSave(this::ByRef1{TF3}, x::ByConstPtr2{Float64})::Float64
Get value corresponding to X in array of fSave values.

""" GetSave(this::ByRef1{TF3}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF3::Integral(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Integral(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsrel::Float64)::Float64
Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz] with a desired relative accuracy.

""" Integral(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsrel::Float64)

# Wrapper of Double_t TF3::Mean3X(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Mean3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Mean3Y(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Mean3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Mean3Z(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Mean3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Moment3(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Moment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny * z^nz moment of a 3d function in range [ax,bx],[ay,by],[az,bz].
###Author

Gene Van Buren gene@bnl.gov
""" Moment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of TF3 & TF3::operator=(const TF3 &)
@trydoc raw"""
    assign(this::ByRef1{TF3}, rhs::ByConstRef1{TF3})::CxxRef1{TF3}
Operator =.

""" assign(this::ByRef1{TF3}, rhs::ByConstRef1{TF3})

# Wrapper of void TF3::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TF3}, option::ByCopy{String})::Nothing
Paint this 3-D function with its current attributes.

""" Paint(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of void TF3::Save(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Save(this::ByRef1{TF3}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Nothing
Save values of function in array fSave.

""" Save(this::ByRef1{TF3}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TF3::SetClippingBoxOff()
@trydoc raw"""
    SetClippingBoxOff(this::ByRef1{TF3})::Nothing
Set the function clipping box (for drawing) "off".

""" SetClippingBoxOff(this::ByRef1{TF3})

# Wrapper of void TF3::SetClippingBoxOn(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetClippingBoxOn(this::ByRef1{TF3}, xclip::Float64, yclip::Float64, zclip::Float64)::Nothing
Set the function clipping box (for drawing) "on" and define the clipping box.
xclip, yclip and zclip is a point within the function range. All the function values having x<=xclip and y<=yclip and z>=zclip are clipped.
""" SetClippingBoxOn(this::ByRef1{TF3}, xclip::Float64, yclip::Float64, zclip::Float64)

# Wrapper of void TF3::SetNpz(Int_t)
@trydoc raw"""
    SetNpz(this::ByRef1{TF3}, npz::Int32)::Nothing
Set the number of points used to draw the function.
The default number of points along x is 30 for 2-d/3-d functions. You can increase this value to get a better resolution when drawing pictures with sharp peaks or to get a better result when using [TF3!GetRandom2](@ref) the minimum number of points is 4, the maximum is 10000 for 2-d/3-d functions
""" SetNpz(this::ByRef1{TF3}, npz::Int32)

# Wrapper of void TF3::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF3}, xmin::Float64, xmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.
The function range is also used in an histogram fit operation when the option "R" is specified.
""" SetRange(this::ByRef1{TF3}, xmin::Float64, xmax::Float64)

# Wrapper of void TF3::SetRange(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function-.

""" SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TF3::SetRange(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.

""" SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)

# Wrapper of Double_t TF3::Variance3X(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Variance3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Variance3Y(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Variance3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Variance3Z(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Variance3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of void TFractionFitter::Constrain(Int_t, Double_t, Double_t)
@trydoc raw"""
    Constrain(this::ByRef1{TFractionFitter}, parm::Int32, low::Float64, high::Float64)::Nothing
Constrain the values of parameter number `<parm>` (the parameter numbering follows that of the input template vector).
Use [UnConstrain()](@ref) to remove this constraint.
""" Constrain(this::ByRef1{TFractionFitter}, parm::Int32, low::Float64, high::Float64)

# Wrapper of void TFractionFitter::ErrorAnalysis(Double_t)
@trydoc raw"""
    ErrorAnalysis(this::ByRef1{TFractionFitter}, UP::Float64)::Nothing
Set UP to the given value (see class [TMinuit](@ref)), and perform a MINOS minimisation.

""" ErrorAnalysis(this::ByRef1{TFractionFitter}, UP::Float64)

# Wrapper of Double_t TFractionFitter::EvaluateFCN(const Double_t *)
@trydoc raw"""
    EvaluateFCN(this::ByRef1{TFractionFitter}, par::ByConstPtr2{Float64})::Float64


""" EvaluateFCN(this::ByRef1{TFractionFitter}, par::ByConstPtr2{Float64})

# Wrapper of void TFractionFitter::ExcludeBin(Int_t)
@trydoc raw"""
    ExcludeBin(this::ByRef1{TFractionFitter}, bin::Int32)::Nothing
Exclude the given bin from the fit.
The bin numbering to be used is that of [TH1!GetBin()](@ref).
""" ExcludeBin(this::ByRef1{TFractionFitter}, bin::Int32)

# Wrapper of TFitResultPtr TFractionFitter::Fit()
@trydoc raw"""
    Fit(this::ByRef1{TFractionFitter})::ByCopy{TFitResultPtr}
Perform the fit with the default UP value.
The value returned is the minimisation status.
""" Fit(this::ByRef1{TFractionFitter})

# Wrapper of TH1 * TFractionFitter::GetPlot()
@trydoc raw"""
    GetPlot(this::ByRef1{TFractionFitter})::CxxPtr1{TH1}
Return the "template prediction" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account).
Note that the name of this histogram will simply be the same as that of the "data" histogram, prefixed with the string "Fraction fit to hist: ". Note also that the histogram is managed by the [TFractionFitter](@ref) class, so the returned pointer will be invalid if the class is deleted
""" GetPlot(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::IncludeBin(Int_t)
@trydoc raw"""
    IncludeBin(this::ByRef1{TFractionFitter}, bin::Int32)::Nothing
Include the given bin in the fit, if it was excluded before using [ExcludeBin()](@ref).
The bin numbering to be used is that of [TH1!GetBin()](@ref).
""" IncludeBin(this::ByRef1{TFractionFitter}, bin::Int32)

# Wrapper of void TFractionFitter::ReleaseRangeX()
@trydoc raw"""
    ReleaseRangeX(this::ByRef1{TFractionFitter})::Nothing
Release restrictions on the X range of the histogram to be used in the fit.

""" ReleaseRangeX(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::ReleaseRangeY()
@trydoc raw"""
    ReleaseRangeY(this::ByRef1{TFractionFitter})::Nothing
Release restrictions on the Y range of the histogram to be used in the fit.

""" ReleaseRangeY(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::ReleaseRangeZ()
@trydoc raw"""
    ReleaseRangeZ(this::ByRef1{TFractionFitter})::Nothing
Release restrictions on the Z range of the histogram to be used in the fit.

""" ReleaseRangeZ(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::SetData(TH1 *)
@trydoc raw"""
    SetData(this::ByRef1{TFractionFitter}, data::ByPtr1{TH1})::Nothing
Change the histogram to be fitted to.
Notes:

- Parameter constraints and settings are retained from a possible previous fit.
- Modifying the dimension or number of bins results in an error (in this case rather instantiate a new [TFractionFitter](@ref) object)
""" SetData(this::ByRef1{TFractionFitter}, data::ByPtr1{TH1})

# Wrapper of void TFractionFitter::SetMC(Int_t, TH1 *)
@trydoc raw"""
    SetMC(this::ByRef1{TFractionFitter}, parm::Int32, MC::ByPtr1{TH1})::Nothing
Change the histogram for template number `<parm>`.
Notes:

- Parameter constraints and settings are retained from a possible previous fit.
- Modifying the dimension or number of bins results in an error (in this case rather instantiate a new [TFractionFitter](@ref) object)
""" SetMC(this::ByRef1{TFractionFitter}, parm::Int32, MC::ByPtr1{TH1})

# Wrapper of void TFractionFitter::SetRangeX(Int_t, Int_t)
@trydoc raw"""
    SetRangeX(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)::Nothing
Set the X range of the histogram to be used in the fit.
Use [ReleaseRangeX()](@ref) to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). ## Arguments

- **`low`** [in] 
    lower X bin number 
    
- **`high`** [in] 
    upper X bin number
""" SetRangeX(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)

# Wrapper of void TFractionFitter::SetRangeY(Int_t, Int_t)
@trydoc raw"""
    SetRangeY(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)::Nothing
Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).
Use [ReleaseRangeY()](@ref) to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). ## Arguments

- **`low`** [in] 
    lower X bin number 
    
- **`high`** [in] 
    upper X bin number
""" SetRangeY(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)

# Wrapper of void TFractionFitter::SetRangeZ(Int_t, Int_t)
@trydoc raw"""
    SetRangeZ(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)::Nothing
Set the Z range of the histogram to be used in the fit (3D histograms only).
Use [ReleaseRangeY()](@ref) to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). ## Arguments

- **`low`** [in] 
    lower X bin number 
    
- **`high`** [in] 
    upper X bin number
""" SetRangeZ(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)

# Wrapper of void TFractionFitter::SetWeight(Int_t, TH1 *)
@trydoc raw"""
    SetWeight(this::ByRef1{TFractionFitter}, parm::Int32, weight::ByPtr1{TH1})::Nothing
Set bin by bin weights for template number `<parm>` (the parameter numbering follows that of the input template vector).
Weights can be "unset" by passing a null pointer. Consistency of the weights histogram with the data histogram is checked at this point, and an error in case of problems.
""" SetWeight(this::ByRef1{TFractionFitter}, parm::Int32, weight::ByPtr1{TH1})

# Wrapper of void TFractionFitter::UnConstrain(Int_t)
@trydoc raw"""
    UnConstrain(this::ByRef1{TFractionFitter}, parm::Int32)::Nothing
Remove the constraints on the possible values of parameter `<parm>`.

""" UnConstrain(this::ByRef1{TFractionFitter}, parm::Int32)

# Wrapper of void TH2D::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, bin::Int32)

# Wrapper of void TH2D::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w Passing an out-of-range bin leads to undefined behavior.

""" AddBinContent(this::ByRef1{TH2D}, bin::Int32, w::Float64)

# Wrapper of void TH2D::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32)

# Wrapper of void TH2D::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of TH2D & TH2D::operator=(const TH2D &)
@trydoc raw"""
    assign(this::ByRef1{TH2D}, h1::ByConstRef1{TH2D})::CxxRef1{TH2D}
Operator =.

""" assign(this::ByRef1{TH2D}, h1::ByConstRef1{TH2D})

# Wrapper of void TH2D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2D}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2D}, option::ByCopy{String})

# Wrapper of void TH2D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2D}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2D}, n::Int32)

# Wrapper of TGraph2DErrors & TGraph2DErrors::operator=(const TGraph2DErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraph2DErrors}, ::ByConstRef1{TGraph2DErrors})::CxxRef1{TGraph2DErrors}
Assignment operator Copy everything except list of functions.

""" assign(this::ByRef1{TGraph2DErrors}, ::ByConstRef1{TGraph2DErrors})

# Wrapper of Int_t TGraph2DErrors::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph2DErrors}, ipoint::Int32)::Int32
Deletes point number ipoint.

""" RemovePoint(this::ByRef1{TGraph2DErrors}, ipoint::Int32)

# Wrapper of void TGraph2DErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph2DErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraph2DErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "z" the z values and errors are scaled If option contains "xyz" all three x, y and z values and errors are scaled
""" Scale(this::ByRef1{TGraph2DErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph2DErrors::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph2DErrors}, n::Int32)::Nothing
Set number of points in the 2D graph.
Existing coordinates are preserved. New coordinates above fNpoints are preset to 0.
""" Set(this::ByRef1{TGraph2DErrors}, n::Int32)

# Wrapper of void TGraph2DErrors::SetPoint(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph2DErrors}, i::Int32, x::Float64, y::Float64, z::Float64)::Nothing
Set x, y and z values for point number i.

""" SetPoint(this::ByRef1{TGraph2DErrors}, i::Int32, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2DErrors::SetPointError(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraph2DErrors}, i::Int32, ex::Float64, ey::Float64, ez::Float64)::Nothing
Set ex, ey and ez values for point number i.

""" SetPointError(this::ByRef1{TGraph2DErrors}, i::Int32, ex::Float64, ey::Float64, ez::Float64)

# Wrapper of void TGraphBentErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphBentErrors}, f::ByPtr1{TF1})::Nothing
Apply a function to all data points $ y = f(x,y) $.
Errors are calculated as $ eyh = f(x,y+eyh)-f(x,y) $ and $ eyl = f(x,y)-f(x,y-eyl) $.

Special treatment has to be applied for the functions where the role of "up" and "down" is reversed.

Function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphBentErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphBentErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphBentErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphBentErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "xy" both x and y values and errors are scaled
""" Scale(this::ByRef1{TGraphBentErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphBentErrors::SetPointError(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphBentErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)::Nothing
Set ex and ey values for point pointed by the mouse.

""" SetPointError(this::ByRef1{TGraphBentErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)

# Wrapper of void TGraphBentErrors::SetPointError(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphBentErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)::Nothing
Set ex and ey values for point number `i`.

""" SetPointError(this::ByRef1{TGraphBentErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)

# Wrapper of Double_t TGraphDelaunay::ComputeZ(Double_t, Double_t)
@trydoc raw"""
    ComputeZ(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)::Float64
Return the z value corresponding to the (x,y) point in fGraph2D.

""" ComputeZ(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)

# Wrapper of void TGraphDelaunay::FindAllTriangles()
@trydoc raw"""
    FindAllTriangles(this::ByRef1{TGraphDelaunay})::Nothing
Attempt to find all the Delaunay triangles of the point set.
It is not guaranteed that it will fully succeed, and no check is made that it has fully succeeded (such a check would be possible by referencing the points that make up the convex hull). The method is to check if each triangle shares all three of its sides with other triangles. If not, a point is generated just outside the triangle on the side(s) not shared, and a new triangle is found for that point. If this method is not working properly (many triangles are not being found) it's probably because the new points are too far beyond or too close to the non-shared sides. Fiddling with the size of the 'alittlebit' parameter may help.
""" FindAllTriangles(this::ByRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)::Float64
Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by linearly interpolating the z-values that make up that triangle.

""" Interpolate(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)

# Wrapper of void TGraphDelaunay::SetMarginBinsContent(Double_t)
@trydoc raw"""
    SetMarginBinsContent(this::ByRef1{TGraphDelaunay}, z::Float64)::Nothing
Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin.

""" SetMarginBinsContent(this::ByRef1{TGraphDelaunay}, z::Float64)

# Wrapper of void TGraphDelaunay::SetMaxIter(Int_t)
@trydoc raw"""
    SetMaxIter(this::ByRef1{TGraphDelaunay}, n::Int32)::Nothing
Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoning the search.

""" SetMaxIter(this::ByRef1{TGraphDelaunay}, n::Int32)

# Wrapper of Double_t TGraphDelaunay2D::ComputeZ(Double_t, Double_t)
@trydoc raw"""
    ComputeZ(this::ByRef1{TGraphDelaunay2D}, x::Float64, y::Float64)::Float64


""" ComputeZ(this::ByRef1{TGraphDelaunay2D}, x::Float64, y::Float64)

# Wrapper of void TGraphDelaunay2D::FindAllTriangles()
@trydoc raw"""
    FindAllTriangles(this::ByRef1{TGraphDelaunay2D})::Nothing


""" FindAllTriangles(this::ByRef1{TGraphDelaunay2D})

# Wrapper of void TGraphDelaunay2D::SetMarginBinsContent(Double_t)
@trydoc raw"""
    SetMarginBinsContent(this::ByRef1{TGraphDelaunay2D}, z::Float64)::Nothing


""" SetMarginBinsContent(this::ByRef1{TGraphDelaunay2D}, z::Float64)

# Wrapper of void TGraphMultiErrors::AddYError(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    AddYError(this::ByRef1{TGraphMultiErrors}, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Add a new y error to the graph and fill it with the values from `eyL` and `eyH`

""" AddYError(this::ByRef1{TGraphMultiErrors}, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphMultiErrors}, f::ByPtr1{TF1})::Nothing
Apply a function to all data points $ y = f(x,y) $.
Errors are calculated as $ eyh = f(x,y+eyh)-f(x,y) $ and $ eyl = f(x,y)-f(x,y-eyl) $

Only the first error dimension is affected.

Special treatment has to be applied for the functions where the role of "up" and "down" is reversed.

Function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphMultiErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphMultiErrors::BayesDivide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    BayesDivide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
This function is only kept for backward compatibility.
You should rather use the Divide method. It calls `Divide(pass,total,"cl=0.683 b(1,1) mode")` which is equivalent to the former BayesDivide method.
""" BayesDivide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of void TGraphMultiErrors::DeleteYError(Int_t)
@trydoc raw"""
    DeleteYError(this::ByRef1{TGraphMultiErrors}, e::Int32)::Nothing
Deletes the y error with the index `e`.
Note that you must keep at least 1 error
""" DeleteYError(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of void TGraphMultiErrors::Divide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
This function was adapted from the [TGraphAsymmErrors](@ref) class.
See [TGraphAsymmErrors!Divide](@ref) for the documentation

Only the first error dimension is affected.
""" Divide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of TAttFill * TGraphMultiErrors::GetAttFill(Int_t)
@trydoc raw"""
    GetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr1{TAttFill}
Get AttFill pointer for specified error dimension.

""" GetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of TAttLine * TGraphMultiErrors::GetAttLine(Int_t)
@trydoc raw"""
    GetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr1{TAttLine}
Get AttLine pointer for specified error dimension.

""" GetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Double_t * TGraphMultiErrors::GetEYhigh(Int_t)
@trydoc raw"""
    GetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr2{Float64}
Get all high errors `e` on y coordinates as an array.

""" GetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Double_t * TGraphMultiErrors::GetEYlow(Int_t)
@trydoc raw"""
    GetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr2{Float64}
Get all low errors `e` on y coordinates as an array.

""" GetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of TGraphMultiErrors & TGraphMultiErrors::operator=(const TGraphMultiErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraphMultiErrors}, tgme::ByConstRef1{TGraphMultiErrors})::CxxRef1{TGraphMultiErrors}
[TGraphMultiErrors](@ref) assignment operator.

""" assign(this::ByRef1{TGraphMultiErrors}, tgme::ByConstRef1{TGraphMultiErrors})

# Wrapper of void TGraphMultiErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphMultiErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphMultiErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and (multiple) errors are scaled If option contains "xy" both x and y values and (multiple) errors are scaled
""" Scale(this::ByRef1{TGraphMultiErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphMultiErrors::SetAttFill(Int_t, TAttFill *)
@trydoc raw"""
    SetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32, taf::ByPtr1{TAttFill})::Nothing
Set [TAttFill](@ref) parameters of error e by copying from another [TAttFill](@ref) (-1 = Global and x errors).

""" SetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32, taf::ByPtr1{TAttFill})

# Wrapper of void TGraphMultiErrors::SetAttLine(Int_t, TAttLine *)
@trydoc raw"""
    SetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32, tal::ByPtr1{TAttLine})::Nothing
Set [TAttLine](@ref) parameters of error e by copying from another [TAttLine](@ref) (-1 = Global and x errors).

""" SetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32, tal::ByPtr1{TAttLine})

# Wrapper of void TGraphMultiErrors::SetEY(Int_t, Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    SetEY(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Set error e ey values.

""" SetEY(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetEYhigh(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyH::ByConstPtr2{Float64})::Nothing
Set error e eyH values.

""" SetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetEYlow(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64})::Nothing
Set error e eyL values.

""" SetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetFillColor(Int_t, Color_t)
@trydoc raw"""
    SetFillColor(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16)::Nothing
Set Fill Color of error e (-1 = Global and x errors).

""" SetFillColor(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16)

# Wrapper of void TGraphMultiErrors::SetFillColorAlpha(Int_t, Color_t, Float_t)
@trydoc raw"""
    SetFillColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16, falpha::Float32)::Nothing
Set Fill Color and Alpha of error e (-1 = Global and x errors).

""" SetFillColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16, falpha::Float32)

# Wrapper of void TGraphMultiErrors::SetFillStyle(Int_t, Style_t)
@trydoc raw"""
    SetFillStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, fstyle::Int16)::Nothing
Set Fill Style of error e (-1 = Global and x errors).

""" SetFillStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, fstyle::Int16)

# Wrapper of void TGraphMultiErrors::SetLineColor(Int_t, Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16)::Nothing
Set Line Color of error e (-1 = Global and x errors).

""" SetLineColor(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16)

# Wrapper of void TGraphMultiErrors::SetLineColorAlpha(Int_t, Color_t, Float_t)
@trydoc raw"""
    SetLineColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16, lalpha::Float32)::Nothing
Set Line Color and Alpha of error e (-1 = Global and x errors).

""" SetLineColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16, lalpha::Float32)

# Wrapper of void TGraphMultiErrors::SetLineStyle(Int_t, Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, lstyle::Int16)::Nothing
Set Line Style of error e (-1 = Global and x errors).

""" SetLineStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, lstyle::Int16)

# Wrapper of void TGraphMultiErrors::SetLineWidth(Int_t, Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TGraphMultiErrors}, e::Int32, lwidth::Int16)::Nothing
Set Line Width of error e (-1 = Global and x errors).

""" SetLineWidth(this::ByRef1{TGraphMultiErrors}, e::Int32, lwidth::Int16)

# Wrapper of void TGraphMultiErrors::SetPointError(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphMultiErrors}, exL::Float64, exH::Float64, eyL1::Float64, eyH1::Float64, eyL2::Float64, eyH2::Float64, eyL3::Float64, eyH3::Float64)::Nothing
Set ex and ey values for point pointed by the mouse.
Up to 3 y error dimensions possible.
""" SetPointError(this::ByRef1{TGraphMultiErrors}, exL::Float64, exH::Float64, eyL1::Float64, eyH1::Float64, eyL2::Float64, eyH2::Float64, eyL3::Float64, eyH3::Float64)

# Wrapper of void TGraphMultiErrors::SetPointError(Int_t, Int_t, Double_t, Double_t, const Double_t *, const Double_t *)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, exL::Float64, exH::Float64, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Set ex and ey values for point `i`.

""" SetPointError(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, exL::Float64, exH::Float64, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetPointEX(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPointEX(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64, exH::Float64)::Nothing
Set ex values for point `i`.

""" SetPointEX(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64, exH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEXhigh(Int_t, Double_t)
@trydoc raw"""
    SetPointEXhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, exH::Float64)::Nothing
Set exH value for point `i`.

""" SetPointEXhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, exH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEXlow(Int_t, Double_t)
@trydoc raw"""
    SetPointEXlow(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64)::Nothing
Set exL value for point `i`.

""" SetPointEXlow(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEY(Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64, eyH::Float64)::Nothing
Set error e ey values for point `i`.

""" SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64, eyH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEY(Int_t, Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Set ey values for point `i`.

""" SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetPointEYhigh(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyH::Float64)::Nothing
Set error e eyH value for point `i`.

""" SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEYhigh(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyH::ByConstPtr2{Float64})::Nothing
Set eyH values for point `i`.

""" SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetPointEYlow(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64)::Nothing
Set error e eyL value for point `i`.

""" SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEYlow(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64})::Nothing
Set eyL values for point `i`.

""" SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetSumErrorsMode(Int_t)
@trydoc raw"""
    SetSumErrorsMode(this::ByRef1{TGraphMultiErrors}, m::Int32)::Nothing
Set the sum errors mode and recalculate summed errors.

""" SetSumErrorsMode(this::ByRef1{TGraphMultiErrors}, m::Int32)

# Wrapper of TGraph * TGraphSmooth::Approx(TGraph *, Option_t *, Int_t, Double_t *, Double_t, Double_t, Int_t, Double_t, Option_t *)
@trydoc raw"""
    Approx(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, nout::Int32, xout::ByPtr2{Float64}, yleft::Float64, yright::Float64, rule::Int32, f::Float64, ties::ByCopy{String})::CxxPtr1{TGraph}
Approximate data points.
## Arguments

- **`grin`** [in] 
    graph giving the coordinates of the points to be interpolated. Alternatively a single plotting structure can be specified: 
    
- **`option`** [in] 
    specifies the interpolation method to be used. Choices are "linear" (iKind = 1) or "constant" (iKind = 2). 
    
- **`nout`** [in] 
    If xout is not specified, interpolation takes place at n equally spaced points spanning the interval [min(x), max(x)], where nout = max(nout, number of input data). 
    
- **`xout`** [in] 
    an optional set of values specifying where interpolation is to take place. 
    
- **`yleft`** [in] 
    the value to be returned when input x values less than min(x). The default is defined by the value of rule given below. 
    
- **`yright`** [in] 
    the value to be returned when input x values greater than max(x). The default is defined by the value of rule given below. 
    
- **`rule`** [in] 
    an integer describing how interpolation is to take place outside the interval [min(x), max(x)]. If rule is 0 then the given yleft and yright values are returned, if it is 1 then 0 is returned for such points and if it is 2, the value at the closest data extreme is used. 
    
- **`f`** [in] 
    For method="constant" a number between 0 and 1 inclusive, indicating a compromise between left- and right-continuous step functions. If y0 and y1 are the values to the left and right of the point then the value is y0*f+y1*(1-f) so that f=0 is right-continuous and f=1 is left-continuous 
    
- **`ties`** [in] 
    Handling of tied x values. An integer describing a function with a single vector argument returning a single number result:
    
    - ties = "ordered" (iTies = 0): input x are "ordered"
    - ties = "mean" (iTies = 1): function "mean"
    - ties = "min" (iTies = 2): function "min"
    - ties = "max" (iTies = 3): function "max"
    
    

Details:

At least two complete (x, y) pairs are required. If there are duplicated (tied) x values and ties is a function it is applied to the y values for each distinct x value. Useful functions in this context include mean, min, and max. If ties="ordered" the x values are assumed to be already ordered. The first y value will be used for interpolation to the left and the last one for interpolation to the right.

Value:

approx returns a graph with components x and y, containing n coordinates which interpolate the given data points according to the method (and rule) desired.
""" Approx(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, nout::Int32, xout::ByPtr2{Float64}, yleft::Float64, yright::Float64, rule::Int32, f::Float64, ties::ByCopy{String})

# Wrapper of void TGraphSmooth::Approxin(TGraph *, Int_t, Double_t &, Double_t &, Int_t, Int_t)
@trydoc raw"""
    Approxin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, iKind::Int32, Ylow::ByRef2{Float64}, Yhigh::ByRef2{Float64}, rule::Int32, iTies::Int32)::Nothing
Sort data points and eliminate double x values.

""" Approxin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, iKind::Int32, Ylow::ByRef2{Float64}, Yhigh::ByRef2{Float64}, rule::Int32, iTies::Int32)

# Wrapper of void TGraphSmooth::Lowess(Double_t *, Double_t *, Int_t, Double_t *, Double_t, Int_t, Double_t)
@trydoc raw"""
    Lowess(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, ys::ByPtr2{Float64}, span::Float64, iter::Int32, delta::Float64)::Nothing
Lowess regression smoother.
Based on R function clowess: Translated to C++ by C. Stratowa (R source file: lowess.c by R Development Core Team (C) 1999-2001)
""" Lowess(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, ys::ByPtr2{Float64}, span::Float64, iter::Int32, delta::Float64)

# Wrapper of void TGraphSmooth::Smoothin(TGraph *)
@trydoc raw"""
    Smoothin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph})::Nothing
Sort input data points.

""" Smoothin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph})

# Wrapper of TGraph * TGraphSmooth::SmoothKern(TGraph *, Option_t *, Double_t, Int_t, Double_t *)
@trydoc raw"""
    SmoothKern(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bandwidth::Float64, nout::Int32, xout::ByPtr2{Float64})::CxxPtr1{TGraph}
Smooth data with Kernel smoother.
Smooth grin with the Nadaraya-Watson kernel regression estimate.

## Arguments

- **`grin`** [in] 
    input graph 
    
- **`option`** [in] 
    the kernel to be used: "box", "normal" 
    
- **`bandwidth`** [in] 
    the bandwidth. The kernels are scaled so that their quartiles (viewed as probability densities) are at +/- 0.25*bandwidth. 
    
- **`nout`** [in] 
    If xout is not specified, interpolation takes place at equally spaced points spanning the interval [min(x), max(x)], where nout = max(nout, number of input data). 
    
- **`xout`** [in] 
    an optional set of values at which to evaluate the fit
""" SmoothKern(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bandwidth::Float64, nout::Int32, xout::ByPtr2{Float64})

# Wrapper of TGraph * TGraphSmooth::SmoothLowess(TGraph *, Option_t *, Double_t, Int_t, Double_t)
@trydoc raw"""
    SmoothLowess(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, span::Float64, iter::Int32, delta::Float64)::CxxPtr1{TGraph}
Smooth data with Lowess smoother.
This function performs the computations for the LOWESS smoother (see the reference below). Lowess returns the output points x and y which give the coordinates of the smooth.

## Arguments

- **`grin`** [in] 
    Input graph 
    
- **`option`** [in] 
    specific options 
    
- **`span`** [in] 
    the smoother span. This gives the proportion of points in the plot which influence the smooth at each value. Larger values give more smoothness. 
    
- **`iter`** [in] 
    the number of robustifying iterations which should be performed. Using smaller values of iter will make lowess run faster. 
    
- **`delta`** [in] 
    values of x which lie within delta of each other replaced by a single value in the output from lowess. For delta = 0, delta will be calculated.
    

References:

- Cleveland, W. S. (1979) Robust locally weighted regression and smoothing scatterplots. J. Amer. Statist. Assoc. 74, 829-836.
- Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots by robust locally weighted regression. The American Statistician, 35, 54.
""" SmoothLowess(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, span::Float64, iter::Int32, delta::Float64)

# Wrapper of TGraph * TGraphSmooth::SmoothSuper(TGraph *, Option_t *, Double_t, Double_t, Bool_t, Double_t *)
@trydoc raw"""
    SmoothSuper(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bass::Float64, span::Float64, isPeriodic::Bool, w::ByPtr2{Float64})::CxxPtr1{TGraph}
Smooth data with Super smoother.
Smooth the (x, y) values by Friedman's `'super smoother''.

## Arguments

- **`grin`** [in] 
    graph for smoothing 
    
- **`option`** [in] 
    specific options 
    
- **`span`** [in] 
    the fraction of the observations in the span of the running lines smoother, or 0 to choose this by leave-one-out cross-validation. 
    
- **`bass`** [in] 
    controls the smoothness of the fitted curve. Values of up to 10 indicate increasing smoothness. 
    
- **`isPeriodic`** [in] 
    if TRUE, the x values are assumed to be in [0, 1] and of period 1. 
    
- **`w`** [in] 
    case weights
    

Details:

supsmu is a running lines smoother which chooses between three spans for the lines. The running lines smoothers are symmetric, with k/2 data points each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and 0.05 * n, where n is the number of data points. If span is specified, a single smoother with span span * n is used.

The best of the three smoothers is chosen by cross-validation for each prediction. The best spans are then smoothed by a running lines smoother and the final prediction chosen by linear interpolation.

The FORTRAN code says: ``For small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. Reasonable span values are 0.2 to 0.4.''

References:

- Friedman, J. H. (1984) SMART User's Guide. Laboratory for Computational Statistics, Stanford University Technical Report No. 1.
- Friedman, J. H. (1984) A variable span scatterplot smoother. Laboratory for Computational Statistics, Stanford University Technical Report No. 5.
""" SmoothSuper(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bass::Float64, span::Float64, isPeriodic::Bool, w::ByPtr2{Float64})

# Wrapper of Int_t TGraphTime::Add(const TObject *, Int_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TGraphTime}, obj::ByConstPtr1{TObject}, slot::Int32, option::ByCopy{String})::Int32
Add one object to a time slot.
[TGraphTime](@ref) becomes the owner of this object. object will be drawn with option
""" Add(this::ByRef1{TGraphTime}, obj::ByConstPtr1{TObject}, slot::Int32, option::ByCopy{String})

# Wrapper of void TGraphTime::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGraphTime}, chopt::ByCopy{String})::Nothing
Draw this [TGraphTime](@ref).
for each time step the list of objects added to this step are drawn.
""" Draw(this::ByRef1{TGraphTime}, chopt::ByCopy{String})

# Wrapper of void TGraphTime::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGraphTime}, chopt::ByCopy{String})::Nothing
Paint all objects added to each time step.

""" Paint(this::ByRef1{TGraphTime}, chopt::ByCopy{String})

# Wrapper of void TGraphTime::SetSleepTime(Int_t)
@trydoc raw"""
    SetSleepTime(this::ByRef1{TGraphTime}, stime::Int32)::Nothing


""" SetSleepTime(this::ByRef1{TGraphTime}, stime::Int32)

# Wrapper of Int_t TVirtualHistPainter::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TVirtualHistPainter}, px::Int32, py::Int32)::Int32
Computes distance from point (px,py) to the object.
This member function must be implemented for each graphics primitive. This default function returns a big number (999999).
""" DistancetoPrimitive(this::ByRef1{TVirtualHistPainter}, px::Int32, py::Int32)

# Wrapper of void TVirtualHistPainter::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TVirtualHistPainter})::Nothing


""" DrawPanel(this::ByRef1{TVirtualHistPainter})

# Wrapper of void TVirtualHistPainter::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TVirtualHistPainter}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to an event at (px,py).
This method must be overridden if an object can react to graphics events.
""" ExecuteEvent(this::ByRef1{TVirtualHistPainter}, event::Int32, px::Int32, py::Int32)

# Wrapper of Bool_t TVirtualHistPainter::IsInside(Double_t, Double_t)
@trydoc raw"""
    IsInside(this::ByRef1{TVirtualHistPainter}, x::Float64, y::Float64)::Bool


""" IsInside(this::ByRef1{TVirtualHistPainter}, x::Float64, y::Float64)

# Wrapper of Bool_t TVirtualHistPainter::IsInside(Int_t, Int_t)
@trydoc raw"""
    IsInside(this::ByRef1{TVirtualHistPainter}, x::Int32, y::Int32)::Bool


""" IsInside(this::ByRef1{TVirtualHistPainter}, x::Int32, y::Int32)

# Wrapper of Int_t TVirtualHistPainter::MakeCuts(char *)
@trydoc raw"""
    MakeCuts(this::ByRef1{TVirtualHistPainter}, cutsopt::ByPtr2{Int8})::Int32


""" MakeCuts(this::ByRef1{TVirtualHistPainter}, cutsopt::ByPtr2{Int8})

# Wrapper of void TVirtualHistPainter::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String})

# Wrapper of void TVirtualHistPainter::PaintStat(Int_t, TF1 *)
@trydoc raw"""
    PaintStat(this::ByRef1{TVirtualHistPainter}, dostat::Int32, fit::ByPtr1{TF1})::Nothing


""" PaintStat(this::ByRef1{TVirtualHistPainter}, dostat::Int32, fit::ByPtr1{TF1})

# Wrapper of void TVirtualHistPainter::ProcessMessage(const char *, const TObject *)
@trydoc raw"""
    ProcessMessage(this::ByRef1{TVirtualHistPainter}, mess::ByCopy{String}, obj::ByConstPtr1{TObject})::Nothing


""" ProcessMessage(this::ByRef1{TVirtualHistPainter}, mess::ByCopy{String}, obj::ByConstPtr1{TObject})

# Wrapper of void TVirtualHistPainter::SetHighlight()
@trydoc raw"""
    SetHighlight(this::ByRef1{TVirtualHistPainter})::Nothing


""" SetHighlight(this::ByRef1{TVirtualHistPainter})

# Wrapper of void TVirtualHistPainter::SetHistogram(TH1 *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TVirtualHistPainter}, h::ByPtr1{TH1})::Nothing


""" SetHistogram(this::ByRef1{TVirtualHistPainter}, h::ByPtr1{TH1})

# Wrapper of void TVirtualHistPainter::SetShowProjection(const char *, Int_t)
@trydoc raw"""
    SetShowProjection(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbins::Int32)::Nothing


""" SetShowProjection(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbins::Int32)

# Wrapper of void TVirtualHistPainter::SetShowProjectionXY(const char *, Int_t, Int_t)
@trydoc raw"""
    SetShowProjectionXY(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbinsY::Int32, nbinsX::Int32)::Nothing


""" SetShowProjectionXY(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbinsY::Int32, nbinsX::Int32)

# Wrapper of void TVirtualHistPainter::SetStack(TList *)
@trydoc raw"""
    SetStack(this::ByRef1{TVirtualHistPainter}, stack::ByPtr1{TList})::Nothing


""" SetStack(this::ByRef1{TVirtualHistPainter}, stack::ByPtr1{TList})

# Wrapper of void TH1C::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1C}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1C}, bin::Int32)

# Wrapper of void TH1C::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1C}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1C}, bin::Int32, w::Float64)

# Wrapper of TH1C & TH1C::operator=(const TH1C &)
@trydoc raw"""
    assign(this::ByRef1{TH1C}, h1::ByConstRef1{TH1C})::CxxRef1{TH1C}
Operator =.

""" assign(this::ByRef1{TH1C}, h1::ByConstRef1{TH1C})

# Wrapper of void TH1C::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1C}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1C}, option::ByCopy{String})

# Wrapper of void TH1C::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1C}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1C}, n::Int32)

# Wrapper of void TH1S::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1S}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1S}, bin::Int32)

# Wrapper of void TH1S::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1S}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1S}, bin::Int32, w::Float64)

# Wrapper of TH1S & TH1S::operator=(const TH1S &)
@trydoc raw"""
    assign(this::ByRef1{TH1S}, h1::ByConstRef1{TH1S})::CxxRef1{TH1S}
Operator =.

""" assign(this::ByRef1{TH1S}, h1::ByConstRef1{TH1S})

# Wrapper of void TH1S::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1S}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1S}, option::ByCopy{String})

# Wrapper of void TH1S::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1S}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1S}, n::Int32)

# Wrapper of void TH1I::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1I}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1I}, bin::Int32)

# Wrapper of void TH1I::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1I}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1I}, bin::Int32, w::Float64)

# Wrapper of TH1I & TH1I::operator=(const TH1I &)
@trydoc raw"""
    assign(this::ByRef1{TH1I}, h1::ByConstRef1{TH1I})::CxxRef1{TH1I}
Operator =.

""" assign(this::ByRef1{TH1I}, h1::ByConstRef1{TH1I})

# Wrapper of void TH1I::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1I}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1I}, option::ByCopy{String})

# Wrapper of void TH1I::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1I}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1I}, n::Int32)

# Wrapper of void TH1L::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1L}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1L}, bin::Int32)

# Wrapper of void TH1L::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1L}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1L}, bin::Int32, w::Float64)

# Wrapper of TH1L & TH1L::operator=(const TH1L &)
@trydoc raw"""
    assign(this::ByRef1{TH1L}, h1::ByConstRef1{TH1L})::CxxRef1{TH1L}
Operator =.

""" assign(this::ByRef1{TH1L}, h1::ByConstRef1{TH1L})

# Wrapper of void TH1L::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1L}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1L}, option::ByCopy{String})

# Wrapper of void TH1L::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1L}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1L}, n::Int32)

# Wrapper of void TH1D::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1D}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1D}, bin::Int32)

# Wrapper of void TH1D::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1D}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w Passing an out-of-range bin leads to undefined behavior.

""" AddBinContent(this::ByRef1{TH1D}, bin::Int32, w::Float64)

# Wrapper of TH1D & TH1D::operator=(const TH1D &)
@trydoc raw"""
    assign(this::ByRef1{TH1D}, h1::ByConstRef1{TH1D})::CxxRef1{TH1D}
Operator =.

""" assign(this::ByRef1{TH1D}, h1::ByConstRef1{TH1D})

# Wrapper of void TH1D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1D}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1D}, option::ByCopy{String})

# Wrapper of void TH1D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1D}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1D}, n::Int32)

# Wrapper of Int_t TH1K::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1K}, name::ByCopy{String}, w::Float64)::Int32
Increment bin with namex with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w.
""" Fill(this::ByRef1{TH1K}, name::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH1K::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1K}, x::Float64)::Int32
Increment bin with abscissa X by 1.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is greater than the upper edge of last bin, the Overflow bin is incremented

If the storage of the sum of squares of weights has been triggered, via the function Sumw2, then the sum of the squares of weights is incremented by 1 in the bin corresponding to x.
""" Fill(this::ByRef1{TH1K}, x::Float64)

# Wrapper of Int_t TH1K::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1K}, x::Float64, w::Float64)::Int32
Increment bin with abscissa X with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w
""" Fill(this::ByRef1{TH1K}, x::Float64, w::Float64)

# Wrapper of void TH1K::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1K}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1K}, option::ByCopy{String})

# Wrapper of void TH1K::SetKOrd(Int_t)
@trydoc raw"""
    SetKOrd(this::ByRef1{TH1K}, k::Int32)::Nothing


""" SetKOrd(this::ByRef1{TH1K}, k::Int32)

# Wrapper of Bool_t TProfile::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this profile by the addition of h1 and h2.
`this = c1*h1 + c2*h2`

c1 and c2 are considered as weights applied to the two summed profiles. The operation acts therefore like merging the two profiles with a weight c1 and c2
""" Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TProfile::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: this = this + c1*h1.

""" Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TProfile::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: this = this + c1*f1.

""" Add(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TProfile::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TProfile}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TProfile}, action::Int32)

# Wrapper of void TProfile::BuildOptions(Double_t, Double_t, Option_t *)
@trydoc raw"""
    BuildOptions(this::ByRef1{TProfile}, ymin::Float64, ymax::Float64, option::ByCopy{String})::Nothing
Set Profile histogram structure and options.
## Arguments

- **`ymin`** [in] 
    minimum value allowed for y 
    
- **`ymax`** [in] 
    maximum value allowed for y if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf) 
    
- **`option`** [in] 
    this is the option for the computation of the y error of the profile ( [TProfile!GetBinError](@ref) ) possible values for the options are:
    
    - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N) where S(Y) is the standard deviation (RMS) of the Y data in the bin and N is the number of bin entries (from TProfile!GetBinEntries(ibin) ) (i.e the errors are the standard error on the bin content of the profile)
    - 's' Errors are the standard deviation of Y, S(Y)
    - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default) The only difference is only when the standard deviation in Y is zero. In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is 1./SQRT(12*N). This approximation assumes that the Y values are integer (e.g. ADC counts) and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12)
    - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j W is obtained as from TProfile!GetBinEntries(ibin) This errors corresponds to the standard deviation of weighted mean where each measurement Y is uncorrelated and has an error sigma, which is expressed in the weight used to fill the Profile: w = 1/sigma^2 The resulting error in [TProfile](@ref) is then 1./SQRT( Sum(1./sigma^2) )
    
    

In the case of Profile filled weights and with [TProfile!Sumw2()](@ref) called, STD(Y) is the standard deviation of the weighted sample Y and N is in this case the number of effective entries (TProfile!GetBinEffectiveEntries(ibin) )

If a bin has N data points all with the same value Y (especially possible when dealing with integers), the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. To avoid this problem one can use an approximation for the standard deviation S(Y), by using the average of all the S(Y) of the other Profile bins. To use this approximation one must call before [TProfile!Approximate](@ref) This approximation applies only for the default and the 's' options
""" BuildOptions(this::ByRef1{TProfile}, ymin::Float64, ymax::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})::Bool
Divide this profile by h1.
`this = this/h1`

This function accepts to divide a [TProfile](@ref) by a histogram

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)`.
This function is not implemented for the [TProfile](@ref)
""" Divide(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TProfile::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TProfile}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Profile histogram is resized along x axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The axis must be extendable before invoking this function.

Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`
""" ExtendAxis(this::ByRef1{TProfile}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of Int_t TProfile::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64)::Int32
Fill a Profile histogram (no weights).

""" Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64)

# Wrapper of Int_t TProfile::Fill(const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64, w::Float64)::Int32
Fill a Profile histogram with weights.

""" Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64, w::Float64)

# Wrapper of Int_t TProfile::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, x::Float64, y::Float64)::Int32
Fill a Profile histogram (no weights).

""" Fill(this::ByRef1{TProfile}, x::Float64, y::Float64)

# Wrapper of Int_t TProfile::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, x::Float64, y::Float64, w::Float64)::Int32
Fill a Profile histogram with weights.

""" Fill(this::ByRef1{TProfile}, x::Float64, y::Float64, w::Float64)

# Wrapper of void TProfile::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TProfile}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill a Profile histogram with weights.

""" FillN(this::ByRef1{TProfile}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of TArrayD * TProfile::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByRef1{TProfile})::CxxPtr1{TArrayD}


""" GetBinSumw2(this::ByRef1{TProfile})

# Wrapper of void TProfile::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TProfile}, axis::ByCopy{String})::Nothing
Reduce the number of bins for this axis to the number of bins having a label.

""" LabelsDeflate(this::ByRef1{TProfile}, axis::ByCopy{String})

# Wrapper of void TProfile::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TProfile}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TProfile}, axis::ByCopy{String})

# Wrapper of void TProfile::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TProfile}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Set option(s) to draw axis with labels.
option might have the following values:

- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TProfile}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TProfile::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile}, list::ByPtr1{TCollection})::Int64
Merge all histograms in the collection in this histogram.
This function computes the min/max for the x axis, compute a new number of bins, if necessary, add bin contents, errors and statistics. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

IMPORTANT remark. The axis x may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width.
""" Merge(this::ByRef1{TProfile}, list::ByPtr1{TCollection})

# Wrapper of Bool_t TProfile::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})::Bool
Multiply this profile by h1.
`this = this*h1`
""" Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`
""" Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: this = this*c1*f1.
The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of TProfile & TProfile::operator=(const TProfile &)
@trydoc raw"""
    assign(this::ByRef1{TProfile}, profile::ByConstRef1{TProfile})::CxxRef1{TProfile}


""" assign(this::ByRef1{TProfile}, profile::ByConstRef1{TProfile})

# Wrapper of void TProfile::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TProfile}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TProfile}, stats::ByPtr2{Float64})

# Wrapper of TH1 * TProfile::Rebin(Int_t, const char *, const Double_t *)
@trydoc raw"""
    Rebin(this::ByRef1{TProfile}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})::CxxPtr1{TH1}
Rebin this profile grouping ngroup bins together.
## case 1  xbins=0

if newname is not blank a new temporary profile hnew is created. else the current profile is modified (default) The parameter ngroup indicates how many bins of this have to me merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.

examples: if hp is an existing [TProfile](@ref) histogram with 100 bins

    hp->Rebin();  //merges two bins in one in hp: previous contents of hp are lost
    hp->Rebin(5); //merges five bins in one in hp
    TProfile *hnew = hp->Rebin(5,"hnew"); // creates a new profile hnew
                                      //merging 5 bins of hp in one bin

(C++ version of the code)

NOTE: If ngroup is not an exact divider of the number of bins, the top limit of the rebinned profile is changed to the upper edge of the bin=newbins*ngroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.

## case 2  xbins!=0

a new profile is created (you should specify newname). The parameter ngroup is the number of variable size bins in the created profile The array xbins must contain ngroup+1 elements that represent the low-edge of the bins. The data of the old bins are added to the new bin which contains the bin center of the old bins. It is possible that information from the old binning are attached to the under-/overflow bins of the new binning.

examples: if hp is an existing [TProfile](@ref) with 100 bins

    Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin
    hp->Rebin(24,"hpnew",xbins);  //creates a new variable bin size profile hpnew

(C++ version of the code)
""" Rebin(this::ByRef1{TProfile}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})

# Wrapper of void TProfile::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile}, option::ByCopy{String})::Nothing
Reset contents of a Profile histogram.

""" Reset(this::ByRef1{TProfile}, option::ByCopy{String})

# Wrapper of void TProfile::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TProfile}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this profile by a constant c1.
`this = c1*this`

This function uses the services of [TProfile!Add](@ref)
""" Scale(this::ByRef1{TProfile}, c1::Float64, option::ByCopy{String})

# Wrapper of void TProfile::SetBinEntries(Int_t, Double_t)
@trydoc raw"""
    SetBinEntries(this::ByRef1{TProfile}, bin::Int32, w::Float64)::Nothing
Set the number of entries in bin.

""" SetBinEntries(this::ByRef1{TProfile}, bin::Int32, w::Float64)

# Wrapper of void TProfile::SetBins(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile}, nbins::Int32, xmin::Float64, xmax::Float64)::Nothing
Redefine x axis parameters.

""" SetBins(this::ByRef1{TProfile}, nbins::Int32, xmin::Float64, xmax::Float64)

# Wrapper of void TProfile::SetBins(Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile}, nx::Int32, xbins::ByConstPtr2{Float64})::Nothing
Redefine x axis parameters.

""" SetBins(this::ByRef1{TProfile}, nx::Int32, xbins::ByConstPtr2{Float64})

# Wrapper of void TProfile::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TProfile}, n::Int32)::Nothing
Set total number of bins including under/overflow.
Reallocate bin contents array
""" SetBinsLength(this::ByRef1{TProfile}, n::Int32)

# Wrapper of void TProfile::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TProfile}, buffersize::Int32, option::ByCopy{String})::Nothing
Set the buffer size in units of 8 bytes (double).

""" SetBuffer(this::ByRef1{TProfile}, buffersize::Int32, option::ByCopy{String})

# Wrapper of void TProfile::SetErrorOption(Option_t *)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile}, option::ByCopy{String})::Nothing
Set option to compute profile errors.
The computation of the bin errors is based on the parameter option:

-' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y), i.e. the standard error of the bin contents. Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Y is 0 and the number of bin entries is > 0 -'s' The bin errors are the standard deviations of the Y bin values Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Y is 0 and the number of bin entries is > 0 -'i' Errors are as in default case (standard errors of the bin contents) The only difference is for the case when the spread in Y is zero. In this case for N > 0 the error is 1./SQRT(12.*N) -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0. W is the sum in the bin of the weights of the profile. This option is for combining measurements y +/- dy, and the profile is filled with values y and weights w = 1/dy**2

See [TProfile!BuildOptions](@ref) for a detailed explanation of all options
""" SetErrorOption(this::ByRef1{TProfile}, option::ByCopy{String})

# Wrapper of void TProfile::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TProfile}, flag::Bool)::Nothing
Create/delete structure to store sum of squares of weights per bin.
This is needed to compute the correct statistical quantities of a profile filled with weights

This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag is false the structure is deleted
""" Sumw2(this::ByRef1{TProfile}, flag::Bool)

# Wrapper of void TH2C::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, bin::Int32)

# Wrapper of void TH2C::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, bin::Int32, w::Float64)

# Wrapper of void TH2C::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32)

# Wrapper of void TH2C::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of TH2C & TH2C::operator=(const TH2C &)
@trydoc raw"""
    assign(this::ByRef1{TH2C}, h1::ByConstRef1{TH2C})::CxxRef1{TH2C}
Operator =.

""" assign(this::ByRef1{TH2C}, h1::ByConstRef1{TH2C})

# Wrapper of void TH2C::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2C}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2C}, option::ByCopy{String})

# Wrapper of void TH2C::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2C}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2C}, n::Int32)

# Wrapper of void TH2S::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, bin::Int32)

# Wrapper of void TH2S::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, bin::Int32, w::Float64)

# Wrapper of void TH2S::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32)

# Wrapper of void TH2S::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of TH2S & TH2S::operator=(const TH2S &)
@trydoc raw"""
    assign(this::ByRef1{TH2S}, h1::ByConstRef1{TH2S})::CxxRef1{TH2S}
Operator =.

""" assign(this::ByRef1{TH2S}, h1::ByConstRef1{TH2S})

# Wrapper of void TH2S::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2S}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2S}, option::ByCopy{String})

# Wrapper of void TH2S::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2S}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2S}, n::Int32)

# Wrapper of void TH2I::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, bin::Int32)

# Wrapper of void TH2I::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, bin::Int32, w::Float64)

# Wrapper of void TH2I::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32)

# Wrapper of void TH2I::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of TH2I & TH2I::operator=(const TH2I &)
@trydoc raw"""
    assign(this::ByRef1{TH2I}, h1::ByConstRef1{TH2I})::CxxRef1{TH2I}
Operator =.

""" assign(this::ByRef1{TH2I}, h1::ByConstRef1{TH2I})

# Wrapper of void TH2I::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2I}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2I}, option::ByCopy{String})

# Wrapper of void TH2I::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2I}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2I}, n::Int32)

# Wrapper of void TH2L::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, bin::Int32)

# Wrapper of void TH2L::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, bin::Int32, w::Float64)

# Wrapper of void TH2L::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32)

# Wrapper of void TH2L::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of TH2L & TH2L::operator=(const TH2L &)
@trydoc raw"""
    assign(this::ByRef1{TH2L}, h1::ByConstRef1{TH2L})::CxxRef1{TH2L}
Operator =.

""" assign(this::ByRef1{TH2L}, h1::ByConstRef1{TH2L})

# Wrapper of void TH2L::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2L}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2L}, option::ByCopy{String})

# Wrapper of void TH2L::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2L}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2L}, n::Int32)

# Wrapper of void TH2F::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, bin::Int32)

# Wrapper of void TH2F::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
###Warning

The value of w is cast to Float_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, bin::Int32, w::Float64)

# Wrapper of void TH2F::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32)

# Wrapper of void TH2F::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of TH2F & TH2F::operator=(const TH2F &)
@trydoc raw"""
    assign(this::ByRef1{TH2F}, h1::ByConstRef1{TH2F})::CxxRef1{TH2F}
Operator =.

""" assign(this::ByRef1{TH2F}, h1::ByConstRef1{TH2F})

# Wrapper of void TH2F::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2F}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2F}, option::ByCopy{String})

# Wrapper of void TH2F::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2F}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2F}, n::Int32)

# Wrapper of Bool_t TH2Poly::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TH2Poly::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: this = this + c1*h1.

""" Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TH2Poly::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TH2Poly}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Add(this::ByRef1{TH2Poly}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TH2Poly::AddBin(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    AddBin(this::ByRef1{TH2Poly}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Int32
Add a new bin to the histogram.
The bin shape is a rectangle. It returns the bin number of the bin in the histogram.
""" AddBin(this::ByRef1{TH2Poly}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)

# Wrapper of Int_t TH2Poly::AddBin(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    AddBin(this::ByRef1{TH2Poly}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})::Int32
Adds a new bin to the histogram.
The number of vertices and their (x,y) coordinates are required as input. It returns the bin number in the histogram.
""" AddBin(this::ByRef1{TH2Poly}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})

# Wrapper of Int_t TH2Poly::AddBin(TObject *)
@trydoc raw"""
    AddBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})::Int32
Adds a new bin to the histogram.
It can be any object having the method [IsInside()](@ref). It returns the bin number in the histogram. It returns 0 if it failed to add. To allow the histogram limits to expand when a bin outside the limits is added, call [SetFloat()](@ref) before adding the bin.
""" AddBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})

# Wrapper of void TH2Poly::ChangePartition(Int_t, Int_t)
@trydoc raw"""
    ChangePartition(this::ByRef1{TH2Poly}, n::Int32, m::Int32)::Nothing
Changes the number of partition cells in the histogram.
Deletes the old partition and constructs a new one.
""" ChangePartition(this::ByRef1{TH2Poly}, n::Int32, m::Int32)

# Wrapper of void TH2Poly::ClearBinContents()
@trydoc raw"""
    ClearBinContents(this::ByRef1{TH2Poly})::Nothing
Clears the contents of all bins in the histogram.

""" ClearBinContents(this::ByRef1{TH2Poly})

# Wrapper of Double_t TH2Poly::ComputeIntegral(Bool_t)
@trydoc raw"""
    ComputeIntegral(this::ByRef1{TH2Poly}, ::Bool)::Float64
NOT IMPLEMENTED for [TH2Poly](@ref).

""" ComputeIntegral(this::ByRef1{TH2Poly}, ::Bool)

# Wrapper of TH2PolyBin * TH2Poly::CreateBin(TObject *)
@trydoc raw"""
    CreateBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})::CxxPtr1{TH2PolyBin}
Create appropriate histogram bin.
e.g. [TH2Poly](@ref) creates [TH2PolyBin](@ref), [TProfile2Poly](@ref) creates [TProfile2PolyBin](@ref) This is done so that [TH2Poly!AddBin](@ref) does not have to be duplicated, but only create needs to be reimplemented for additional histogram types
""" CreateBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})

# Wrapper of Bool_t TH2Poly::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Divide(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)

# Wrapper of TH1 * TH2Poly::FFT(TH1 *, Option_t *)
@trydoc raw"""
    FFT(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::ByCopy{String})::CxxPtr1{TH1}
NOT IMPLEMENTED for [TH2Poly](@ref).

""" FFT(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::ByCopy{String})

# Wrapper of Int_t TH2Poly::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2Poly}, name::ByCopy{String}, w::Float64)::Int32
Increment the bin named "name" by w.

""" Fill(this::ByRef1{TH2Poly}, name::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH2Poly::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64)::Int32
Increment the bin containing (x,y) by 1.
Uses the partitioning algorithm.
""" Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64)

# Wrapper of Int_t TH2Poly::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64, w::Float64)::Int32
Increment the bin containing (x,y) by w.
Uses the partitioning algorithm.
""" Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64, w::Float64)

# Wrapper of void TH2Poly::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH2Poly}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fills a 2-D histogram with an array of values and weights.
## Arguments

- **`ntimes`** [in] 
    number of entries in arrays x and w (array size must be ntimes*stride) 
    
- **`x`** [in] 
    array of x values to be histogrammed 
    
- **`y`** [in] 
    array of y values to be histogrammed 
    
- **`w`** [in] 
    array of weights 
    
- **`stride`** [in] 
    step size through arrays x, y and w
""" FillN(this::ByRef1{TH2Poly}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of Int_t TH2Poly::FindBin(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindBin(this::ByRef1{TH2Poly}, x::Float64, y::Float64, z::Float64)::Int32
Returns the bin number of the bin at the given coordinate.
-1 to -9 are the overflow and underflow bins. overflow bin -5 is the unbinned areas in the histogram (also called "the sea"). The third parameter can be left blank. The overflow/underflow bins are: 

    -1 | -2 | -3
    -------------
    -4 | -5 | -6
    -------------
    -7 | -8 | -9

(C++ version of the code)

 where -5 means is the "sea" bin (i.e. unbinned areas)
""" FindBin(this::ByRef1{TH2Poly}, x::Float64, y::Float64, z::Float64)

# Wrapper of TH1 * TH2Poly::GetAsymmetry(TH1 *, Double_t, Double_t)
@trydoc raw"""
    GetAsymmetry(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::Float64, ::Float64)::CxxPtr1{TH1}
NOT IMPLEMENTED for [TH2Poly](@ref).

""" GetAsymmetry(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::Float64, ::Float64)

# Wrapper of TList * TH2Poly::GetBins()
@trydoc raw"""
    GetBins(this::ByRef1{TH2Poly})::CxxPtr1{TList}
Returns the [TList](@ref) of all bins in the histogram.

""" GetBins(this::ByRef1{TH2Poly})

# Wrapper of Bool_t TH2Poly::GetFloat()
@trydoc raw"""
    GetFloat(this::ByRef1{TH2Poly})::Bool


""" GetFloat(this::ByRef1{TH2Poly})

# Wrapper of void TH2Poly::Honeycomb(Double_t, Double_t, Double_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Honeycomb(this::ByRef1{TH2Poly}, xstart::Float64, ystart::Float64, a::Float64, k::Int32, s::Int32, option::ByCopy{String})::Nothing
Bins the histogram using a honeycomb structure If the option "v" is specified, the hexagons are drawn "vertically" (default).
If the option "h" is selected they are drawn "horizontally".
""" Honeycomb(this::ByRef1{TH2Poly}, xstart::Float64, ystart::Float64, a::Float64, k::Int32, s::Int32, option::ByCopy{String})

# Wrapper of Double_t TH2Poly::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByRef1{TH2Poly}, ::Float64, ::Float64)::Float64
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Interpolate(this::ByRef1{TH2Poly}, ::Float64, ::Float64)

# Wrapper of Bool_t TH2Poly::IsInsideBin(Int_t, Double_t, Double_t)
@trydoc raw"""
    IsInsideBin(this::ByRef1{TH2Poly}, binnr::Int32, x::Float64, y::Float64)::Bool
Return "true" if the point (x,y) is inside the bin of binnr.

""" IsInsideBin(this::ByRef1{TH2Poly}, binnr::Int32, x::Float64, y::Float64)

# Wrapper of Long64_t TH2Poly::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TH2Poly}, ::ByPtr1{TCollection})::Int64
Merge TH2Polys Given the special nature of the [TH2Poly](@ref), the merge is implemented in terms of subsequent [TH2Poly!Add](@ref) calls.

""" Merge(this::ByRef1{TH2Poly}, ::ByPtr1{TCollection})

# Wrapper of Bool_t TH2Poly::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Multiply(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)

# Wrapper of TH2Poly & TH2Poly::operator=(const TH2Poly &)
@trydoc raw"""
    assign(this::ByRef1{TH2Poly}, rhs::ByConstRef1{TH2Poly})::CxxRef1{TH2Poly}
Assignment operator.

""" assign(this::ByRef1{TH2Poly}, rhs::ByConstRef1{TH2Poly})

# Wrapper of void TH2Poly::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2Poly}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2Poly}, option::ByCopy{String})

# Wrapper of void TH2Poly::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TH2Poly}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this histogram by a constant c1.

""" Scale(this::ByRef1{TH2Poly}, c1::Float64, option::ByCopy{String})

# Wrapper of void TH2Poly::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2Poly}, bin::Int32, content::Float64)::Nothing
Sets the contents of the input bin to the input content Negative values between -1 and -9 are for the overflows and the sea.

""" SetBinContent(this::ByRef1{TH2Poly}, bin::Int32, content::Float64)

# Wrapper of void TH2Poly::SetBinContentChanged(Bool_t)
@trydoc raw"""
    SetBinContentChanged(this::ByRef1{TH2Poly}, flag::Bool)::Nothing


""" SetBinContentChanged(this::ByRef1{TH2Poly}, flag::Bool)

# Wrapper of void TH2Poly::SetBinError(Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH2Poly}, bin::Int32, error::Float64)::Nothing
Set the bin Error.
Re-implementation for [TH2Poly](@ref) given the different bin indexing in the stored squared error array. See also notes in [TH1!SetBinError](@ref)

Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins
""" SetBinError(this::ByRef1{TH2Poly}, bin::Int32, error::Float64)

# Wrapper of void TH2Poly::SetFloat(Bool_t)
@trydoc raw"""
    SetFloat(this::ByRef1{TH2Poly}, flag::Bool)::Nothing
When set to kTRUE, allows the histogram to expand if a bin outside the limits is added.

""" SetFloat(this::ByRef1{TH2Poly}, flag::Bool)

# Wrapper of void TH2Poly::SetNewBinAdded(Bool_t)
@trydoc raw"""
    SetNewBinAdded(this::ByRef1{TH2Poly}, flag::Bool)::Nothing


""" SetNewBinAdded(this::ByRef1{TH2Poly}, flag::Bool)

# Wrapper of void TH2PolyBin::ClearContent()
@trydoc raw"""
    ClearContent(this::ByRef1{TH2PolyBin})::Nothing


""" ClearContent(this::ByRef1{TH2PolyBin})

# Wrapper of void TH2PolyBin::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2PolyBin}, w::Float64)::Nothing


""" Fill(this::ByRef1{TH2PolyBin}, w::Float64)

# Wrapper of Double_t TH2PolyBin::GetArea()
@trydoc raw"""
    GetArea(this::ByRef1{TH2PolyBin})::Float64
Returns the area of the bin.

""" GetArea(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetXMax()
@trydoc raw"""
    GetXMax(this::ByRef1{TH2PolyBin})::Float64
Returns the maximum value for the x coordinates of the bin.

""" GetXMax(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetXMin()
@trydoc raw"""
    GetXMin(this::ByRef1{TH2PolyBin})::Float64
Returns the minimum value for the x coordinates of the bin.

""" GetXMin(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetYMax()
@trydoc raw"""
    GetYMax(this::ByRef1{TH2PolyBin})::Float64
Returns the maximum value for the y coordinates of the bin.

""" GetYMax(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetYMin()
@trydoc raw"""
    GetYMin(this::ByRef1{TH2PolyBin})::Float64
Returns the minimum value for the y coordinates of the bin.

""" GetYMin(this::ByRef1{TH2PolyBin})

# Wrapper of void TH2PolyBin::SetChanged(Bool_t)
@trydoc raw"""
    SetChanged(this::ByRef1{TH2PolyBin}, flag::Bool)::Nothing


""" SetChanged(this::ByRef1{TH2PolyBin}, flag::Bool)

# Wrapper of void TH2PolyBin::SetContent(Double_t)
@trydoc raw"""
    SetContent(this::ByRef1{TH2PolyBin}, content::Float64)::Nothing


""" SetContent(this::ByRef1{TH2PolyBin}, content::Float64)

# Wrapper of void TH3::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, bin::Int32)

# Wrapper of void TH3::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, bin::Int32, w::Float64)

# Wrapper of void TH3::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of Int_t TH3::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TH3}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref)) action = 0 histogram is filled from the buffer action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TH3}, action::Int32)

# Wrapper of Int_t TH3::Fill(const char *, const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,namey,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(const char *, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Increment cell defined by namex,namey,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TH3::Fill(const char *, Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,y,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(const char *, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)::Int32
Increment cell defined by namex , y ,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,namey,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Increment cell defined by x,namey,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, y::Float64, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,y,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, y::Float64, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64)::Int32
Increment cell defined by x,y,z by 1 .
The function returns the corresponding global_ bin number which has its content incremented by 1
""" Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64, w::Float64)::Int32
Increment cell defined by x,y,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the cell corresponding to x,y,z.

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64, w::Float64)

# Wrapper of void TH3::FillRandom(const char *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH3}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in function fname.
## Arguments

- **`fname`** 
    : Function name used for filling the historam 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used to sample
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

N.B. By dfault this methods approximates the integral of the function in each bin with the function value at the center of the bin, mutiplied by the bin width

One can also call [TF1!GetRandom](@ref) to get a random variate from a function.
""" FillRandom(this::ByRef1{TH3}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH3::FillRandom(TH1 *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH3}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in histogram h.
## Arguments

- **`h`** 
    : Histogram pointer used for smpling random number 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used for sampling
    

The distribution contained in the histogram h ([TH3](@ref)) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated
""" FillRandom(this::ByRef1{TH3}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH3::FitSlicesZ(TF1 *, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    FitSlicesZ(this::ByRef1{TH3}, f1::ByPtr1{TF1}, binminx::Int32, binmaxx::Int32, binminy::Int32, binmaxy::Int32, cut::Int32, option::ByCopy{String})::Nothing
Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-d histogram for each fit parameter Only cells in the bin range [binminx,binmaxx] and [binminy,binmaxy] are considered.
if f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along Z via f1->SetRange(zmin,zmax) The argument option (default="QNR") can be used to change the fit options. "Q" means Quiet mode "N" means do not show the result of the fit "R" means fit the function in the specified function range

Note that the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.

Example: Assume a 3-d histogram h3 Root > h3->[FitSlicesZ()](@ref); produces 4 [TH2D](@ref) histograms with h3_0 containing parameter 0(Constant) for a Gaus fit of each cell in X,Y projected along Z with h3_1 containing parameter 1(Mean) for a gaus fit with h3_2 containing parameter 2(StdDev) for a gaus fit with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit

Root > h3->Fit(0,15,22,0,0,10); same as above, but only for bins 15 to 22 along X and only for cells in X,Y for which the corresponding projection along Z has more than cut bins filled.

NOTE: To access the generated histograms in the current directory, do eg: [TH2D](@ref) <i>h3_1 = ([TH2D](@ref)</i>)gDirectory->Get("h3_1");
""" FitSlicesZ(this::ByRef1{TH3}, f1::ByPtr1{TF1}, binminx::Int32, binmaxx::Int32, binminy::Int32, binmaxy::Int32, cut::Int32, option::ByCopy{String})

# Wrapper of Double_t TH3::GetBinErrorLow(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinErrorLow(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinErrorLow(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH3::GetBinErrorUp(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinErrorUp(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinErrorUp(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3::GetRandom3(Double_t &, Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom3(this::ByRef1{TH3}, x::ByRef2{Float64}, y::ByRef2{Float64}, ::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-dim histogram.
## Arguments

- **`x`** [out] 
    reference to random generated x value 
    
- **`y`** [out] 
    reference to random generated y value 
    
- **`z`** [out] 
    reference to random generated z value 
    
- **`rng`** [in] 
    (optional) Random number generator pointer used (default is gRandom)
""" GetRandom3(this::ByRef1{TH3}, x::ByRef2{Float64}, y::ByRef2{Float64}, ::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of void TH3::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TH3}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TH3}, stats::ByPtr2{Float64})

# Wrapper of TH3 * TH3::Rebin3D(Int_t, Int_t, Int_t, const char *)
@trydoc raw"""
    Rebin3D(this::ByRef1{TH3}, nxgroup::Int32, nygroup::Int32, nzgroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.
if newname is not blank a new temporary histogram hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to me merged into one bin of hnew If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

examples: if hpxpy is an existing [TH3](@ref) histogram with 40 x 40 x 40 bins hpxpypz->[Rebin3D()](@ref); // merges two bins along the xaxis and yaxis in one in hpxpypz // Carefull: previous contents of hpxpy are lost hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz [TH3](@ref) *hnew = hpxpypz->RebinY(5,"hnew"); // creates a new histogram hnew // merging 5 bins of h1 along the yaxis in one bin

NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned histogram is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.
""" Rebin3D(this::ByRef1{TH3}, nxgroup::Int32, nygroup::Int32, nzgroup::Int32, newname::ByCopy{String})

# Wrapper of TH3 * TH3::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin only the X axis see Rebin3D.

""" RebinX(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TH3 * TH3::RebinY(Int_t, const char *)
@trydoc raw"""
    RebinY(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin only the Y axis see Rebin3D.

""" RebinY(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TH3 * TH3::RebinZ(Int_t, const char *)
@trydoc raw"""
    RebinZ(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin only the Z axis see Rebin3D.

""" RebinZ(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TH3::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3}, option::ByCopy{String})

# Wrapper of void TH3::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH3}, bin::Int32, content::Float64)::Nothing
Set bin content.

""" SetBinContent(this::ByRef1{TH3}, bin::Int32, content::Float64)

# Wrapper of void TH3::SetBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH3}, bin::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH3}, bin::Int32, ::Int32, content::Float64)

# Wrapper of void TH3::SetBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, content::Float64)

# Wrapper of void TH3::SetShowProjection(const char *, Int_t)
@trydoc raw"""
    SetShowProjection(this::ByRef1{TH3}, option::ByCopy{String}, nbins::Int32)::Nothing
When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a projection type given as option.
To stop the generation of the projections, delete the canvas containing the projection. option may contain a combination of the characters x,y,z,e option = "x" return the x projection into a [TH1D](@ref) histogram option = "y" return the y projection into a [TH1D](@ref) histogram option = "z" return the z projection into a [TH1D](@ref) histogram option = "xy" return the x versus y projection into a [TH2D](@ref) histogram option = "yx" return the y versus x projection into a [TH2D](@ref) histogram option = "xz" return the x versus z projection into a [TH2D](@ref) histogram option = "zx" return the z versus x projection into a [TH2D](@ref) histogram option = "yz" return the y versus z projection into a [TH2D](@ref) histogram option = "zy" return the z versus y projection into a [TH2D](@ref) histogram option can also include the drawing option for the projection, eg to draw the xy projection using the draw option "box" do myhist.SetShowProjection("xy box"); This function is typically called from the context menu. NB: the notation "a vs b" means "a" vertical and "b" horizontal
""" SetShowProjection(this::ByRef1{TH3}, option::ByCopy{String}, nbins::Int32)

# Wrapper of Bool_t TProfile2D::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this profile2D by the addition of h1 and h2.
`this = c1*h1 + c2*h2`
""" Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TProfile2D::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: `this = this + c1*h1` .

""" Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TProfile2D::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: `this = this + c1*f1` .

""" Add(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TProfile2D::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TProfile2D}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TProfile2D}, action::Int32)

# Wrapper of void TProfile2D::BuildOptions(Double_t, Double_t, Option_t *)
@trydoc raw"""
    BuildOptions(this::ByRef1{TProfile2D}, zmin::Float64, zmax::Float64, option::ByCopy{String})::Nothing
Set Profile2D histogram structure and options.
- zmin: minimum value allowed for z
- zmax: maximum value allowed for z if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf)
- option: this is the option for the computation of the t error of the profile ( [TProfile2D!GetBinError](@ref) ) possible values for the options are documented in [TProfile2D!SetErrorOption](@ref)

    See [TProfile!BuildOptions](@ref) for a detailed description
""" BuildOptions(this::ByRef1{TProfile2D}, zmin::Float64, zmax::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile2D::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})::Bool
Divide this profile2D by h1.
`this = this/h1`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile2D::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile2D::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)` .
This function is not implemented
""" Divide(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TProfile2D::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TProfile2D}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Profile histogram is resized along axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The axis must be extendable before invoking this function.

Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`
""" ExtendAxis(this::ByRef1{TProfile2D}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of Int_t TProfile2D::Fill(const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,namey

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(const char *, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, w::Float64)::Int32
Increment cell defined by namex,y by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,y

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(const char *, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to x,y.

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram with weights.

""" Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64, w::Float64)

# Wrapper of Double_t TProfile2D::GetBinEffectiveEntries(Int_t)
@trydoc raw"""
    GetBinEffectiveEntries(this::ByRef1{TProfile2D}, bin::Int32)::Float64
Return bin effective entries for a weighted filled Profile histogram.
In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. [TProfile!Sumw2()](@ref) must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored.
""" GetBinEffectiveEntries(this::ByRef1{TProfile2D}, bin::Int32)

# Wrapper of TArrayD * TProfile2D::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByRef1{TProfile2D})::CxxPtr1{TArrayD}


""" GetBinSumw2(this::ByRef1{TProfile2D})

# Wrapper of Double_t TProfile2D::GetNumberOfBins()
@trydoc raw"""
    GetNumberOfBins(this::ByRef1{TProfile2D})::Float64


""" GetNumberOfBins(this::ByRef1{TProfile2D})

# Wrapper of void TProfile2D::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})::Nothing
Reduce the number of bins for this axis to the number of bins having a label.

""" LabelsDeflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})

# Wrapper of void TProfile2D::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})

# Wrapper of void TProfile2D::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TProfile2D}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Set option(s) to draw axis with labels.
option might have the following values:

- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TProfile2D}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TProfile2D::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile2D}, list::ByPtr1{TCollection})::Int64
Merge all histograms in the collection in this histogram.
This function computes the min/max for the axes, compute a new number of bins, if necessary, add bin contents, errors and statistics. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

IMPORTANT remark. The 2 axis x and y may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width.
""" Merge(this::ByRef1{TProfile2D}, list::ByPtr1{TCollection})

# Wrapper of Bool_t TProfile2D::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})::Bool
Multiply this profile2D by h1.
`this = this*h1`
""" Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`
""" Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile2D::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: this = this*c1*f1.

""" Multiply(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of TProfile2D & TProfile2D::operator=(const TProfile2D &)
@trydoc raw"""
    assign(this::ByRef1{TProfile2D}, profile::ByConstRef1{TProfile2D})::CxxRef1{TProfile2D}


""" assign(this::ByRef1{TProfile2D}, profile::ByConstRef1{TProfile2D})

# Wrapper of void TProfile2D::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TProfile2D}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TProfile2D}, stats::ByPtr2{Float64})

# Wrapper of TProfile2D * TProfile2D::Rebin2D(Int_t, Int_t, const char *)
@trydoc raw"""
    Rebin2D(this::ByRef1{TProfile2D}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})::CxxPtr1{TProfile2D}
Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.
if newname is not blank a new profile hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to be merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.

examples: if hpxpy is an existing [TProfile2D](@ref) profile with 40 x 40 bins 

    hpxpy->Rebin2D();  // merges two bins along the xaxis and yaxis in one
                       // Carefull: previous contents of hpxpy are lost
    hpxpy->Rebin2D(3,5);  // merges 3 bins along the xaxis and 5 bins along the yaxis in one
                          // Carefull: previous contents of hpxpy are lost
    hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy
    TProfile2D *hnew = hpxpy->RebinY(5,"hnew"); // creates a new profile hnew
                                                // merging 5 bins of hpxpy along the yaxis in one bin

(C++ version of the code)

NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned profile is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the remaining bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.
""" Rebin2D(this::ByRef1{TProfile2D}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})

# Wrapper of TProfile2D * TProfile2D::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TProfile2D}
Rebin only the X axis.
see Rebin2D
""" RebinX(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TProfile2D * TProfile2D::RebinY(Int_t, const char *)
@trydoc raw"""
    RebinY(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TProfile2D}
Rebin only the Y axis.
see Rebin2D
""" RebinY(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TProfile2D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile2D}, option::ByCopy{String})::Nothing
Reset contents of a Profile2D histogram.

""" Reset(this::ByRef1{TProfile2D}, option::ByCopy{String})

# Wrapper of void TProfile2D::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TProfile2D}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this profile2D by a constant c1.
`this = c1*this

This function uses the services of [TProfile2D!Add](@ref)
""" Scale(this::ByRef1{TProfile2D}, c1::Float64, option::ByCopy{String})

# Wrapper of void TProfile2D::SetBinEntries(Int_t, Double_t)
@trydoc raw"""
    SetBinEntries(this::ByRef1{TProfile2D}, bin::Int32, w::Float64)::Nothing
Set the number of entries in bin.

""" SetBinEntries(this::ByRef1{TProfile2D}, bin::Int32, w::Float64)

# Wrapper of void TProfile2D::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile2D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64)::Nothing
Redefine x and y axis parameters.

""" SetBins(this::ByRef1{TProfile2D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64)

# Wrapper of void TProfile2D::SetBins(Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile2D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})::Nothing
Redefine x and y axis parameters for variable bin sizes.

""" SetBins(this::ByRef1{TProfile2D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})

# Wrapper of void TProfile2D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TProfile2D}, n::Int32)::Nothing
Set total number of bins including under/overflow.
Reallocate bin contents array
""" SetBinsLength(this::ByRef1{TProfile2D}, n::Int32)

# Wrapper of void TProfile2D::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TProfile2D}, buffersize::Int32, option::ByCopy{String})::Nothing
Set the buffer size in units of 8 bytes (double).

""" SetBuffer(this::ByRef1{TProfile2D}, buffersize::Int32, option::ByCopy{String})

# Wrapper of void TProfile2D::SetErrorOption(Option_t *)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile2D}, option::ByCopy{String})::Nothing
Set option to compute profile2D errors.
The computation of the bin errors is based on the parameter option:

- ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z), i.e. the standard error of the bin contents. Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Z is 0 and the number of bin entries is > 0
- 's' The bin errors are the standard deviations of the Z bin values Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Z is 0 and the number of bin entries is > 0
- 'i' Errors are as in default case (standard errors of the bin contents) The only difference is for the case when the spread in Z is zero. In this case for N > 0 the error is 1./SQRT(12.*N)
- 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0. W is the sum in the bin of the weights of the profile. This option is for combining measurements z +/- dz, and the profile is filled with values y and weights z = 1/dz**2

See [TProfile!BuildOptions](@ref) for a detailed explanation of all options
""" SetErrorOption(this::ByRef1{TProfile2D}, option::ByCopy{String})

# Wrapper of void TProfile2D::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TProfile2D}, flag::Bool)::Nothing
Create/Delete structure to store sum of squares of weights per bin.
This is needed to compute the correct statistical quantities of a profile filled with weights

This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag is false the structure is deleted
""" Sumw2(this::ByRef1{TProfile2D}, flag::Bool)

# Wrapper of void TH3C::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, bin::Int32)

# Wrapper of void TH3C::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, bin::Int32, w::Float64)

# Wrapper of void TH3C::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3C::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of TH3C & TH3C::operator=(const TH3C &)
@trydoc raw"""
    assign(this::ByRef1{TH3C}, h1::ByConstRef1{TH3C})::CxxRef1{TH3C}
Operator =.

""" assign(this::ByRef1{TH3C}, h1::ByConstRef1{TH3C})

# Wrapper of void TH3C::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3C}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3C}, option::ByCopy{String})

# Wrapper of void TH3C::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3C}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3C}, n::Int32)

# Wrapper of void TH3S::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, bin::Int32)

# Wrapper of void TH3S::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, bin::Int32, w::Float64)

# Wrapper of void TH3S::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3S::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of TH3S & TH3S::operator=(const TH3S &)
@trydoc raw"""
    assign(this::ByRef1{TH3S}, h1::ByConstRef1{TH3S})::CxxRef1{TH3S}
Operator =.

""" assign(this::ByRef1{TH3S}, h1::ByConstRef1{TH3S})

# Wrapper of void TH3S::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3S}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3S}, option::ByCopy{String})

# Wrapper of void TH3S::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3S}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3S}, n::Int32)

# Wrapper of void TH3I::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, bin::Int32)

# Wrapper of void TH3I::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, bin::Int32, w::Float64)

# Wrapper of void TH3I::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3I::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of TH3I & TH3I::operator=(const TH3I &)
@trydoc raw"""
    assign(this::ByRef1{TH3I}, h1::ByConstRef1{TH3I})::CxxRef1{TH3I}
Operator =.

""" assign(this::ByRef1{TH3I}, h1::ByConstRef1{TH3I})

# Wrapper of void TH3I::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3I}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3I}, option::ByCopy{String})

# Wrapper of void TH3I::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3I}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3I}, n::Int32)

# Wrapper of void TH3L::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, bin::Int32)

# Wrapper of void TH3L::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, bin::Int32, w::Float64)

# Wrapper of void TH3L::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3L::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of TH3L & TH3L::operator=(const TH3L &)
@trydoc raw"""
    assign(this::ByRef1{TH3L}, h1::ByConstRef1{TH3L})::CxxRef1{TH3L}
Operator =.

""" assign(this::ByRef1{TH3L}, h1::ByConstRef1{TH3L})

# Wrapper of void TH3L::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3L}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3L}, option::ByCopy{String})

# Wrapper of void TH3L::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3L}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3L}, n::Int32)

# Wrapper of void TH3F::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, bin::Int32)

# Wrapper of void TH3F::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
###Warning

The value of w is cast to Float_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, bin::Int32, w::Float64)

# Wrapper of void TH3F::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3F::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of TH3F & TH3F::operator=(const TH3F &)
@trydoc raw"""
    assign(this::ByRef1{TH3F}, h1::ByConstRef1{TH3F})::CxxRef1{TH3F}
Operator =.

""" assign(this::ByRef1{TH3F}, h1::ByConstRef1{TH3F})

# Wrapper of void TH3F::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3F}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3F}, option::ByCopy{String})

# Wrapper of void TH3F::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3F}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3F}, n::Int32)

# Wrapper of void TH3D::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, bin::Int32)

# Wrapper of void TH3D::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w Passing an out-of-range bin leads to undefined behavior.

""" AddBinContent(this::ByRef1{TH3D}, bin::Int32, w::Float64)

# Wrapper of void TH3D::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3D::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of TH3D & TH3D::operator=(const TH3D &)
@trydoc raw"""
    assign(this::ByRef1{TH3D}, h1::ByConstRef1{TH3D})::CxxRef1{TH3D}
Operator =.

""" assign(this::ByRef1{TH3D}, h1::ByConstRef1{TH3D})

# Wrapper of void TH3D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3D}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3D}, option::ByCopy{String})

# Wrapper of void TH3D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3D}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3D}, n::Int32)

# Wrapper of int & TBinIterator::operator*()
@trydoc raw"""
    Base.getindex(this::ByRef1{TBinIterator})::CxxRef2{Int32}


""" Base.getindex(this::ByRef1{TBinIterator})

# Wrapper of TBinIterator & TBinIterator::operator++()
@trydoc raw"""
    inc!(this::ByRef1{TBinIterator})::CxxRef1{TBinIterator}


""" inc!(this::ByRef1{TBinIterator})

# Wrapper of TBinIterator TBinIterator::operator++(int)
@trydoc raw"""
    inc!(this::ByRef1{TBinIterator}, ::Int32)::ByCopy{TBinIterator}


""" inc!(this::ByRef1{TBinIterator}, ::Int32)

# Wrapper of Int_t THLimitsFinder::FindGoodLimits(TH1 *, Double_t, Double_t)
@trydoc raw"""
    FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64)::Int32
Compute the best axis limits for the X axis.
If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters.

Example: With the input parameters xmin=-1.467 and xmax=2.344, the function will compute better limits -1.8 and 2.7 and store them in the axis.
""" FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64)

# Wrapper of Int_t THLimitsFinder::FindGoodLimits(TH1 *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64)::Int32
Compute the best axis limits for the X and Y axis.
If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters
""" FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64)

# Wrapper of Int_t THLimitsFinder::FindGoodLimits(TH1 *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Int32
Compute the best axis limits for the X, Y and Z axis.
If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters
""" FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TNDArray::AddAt(ULong64_t, Double_t)
@trydoc raw"""
    AddAt(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)::Nothing


""" AddAt(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)

# Wrapper of void TNDArray::Init(Int_t, const Int_t *, bool)
@trydoc raw"""
    Init(this::ByRef1{TNDArray}, ndim::Int32, nbins::ByConstPtr2{Int32}, addOverflow::Bool)::Nothing


""" Init(this::ByRef1{TNDArray}, ndim::Int32, nbins::ByConstPtr2{Int32}, addOverflow::Bool)

# Wrapper of void TNDArray::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TNDArray}, option::ByCopy{String})::Nothing


""" Reset(this::ByRef1{TNDArray}, option::ByCopy{String})

# Wrapper of void TNDArray::SetAsDouble(ULong64_t, Double_t)
@trydoc raw"""
    SetAsDouble(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)::Nothing


""" SetAsDouble(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)

# Wrapper of void THn::AddBinContent(const Int_t *, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!SetBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" AddBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THn::AddBinContent(Long64_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)

# Wrapper of void THn::AddBinError2(Long64_t, Double_t)
@trydoc raw"""
    AddBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)::Nothing


""" AddBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)

# Wrapper of void THn::FillBin(Long64_t, Double_t)
@trydoc raw"""
    FillBin(this::ByRef1{THn}, bin::Int64, w::Float64)::Nothing
Increment the bin content of "bin" by "w", return the bin index.

""" FillBin(this::ByRef1{THn}, bin::Int64, w::Float64)

# Wrapper of TNDArray & THn::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{THn})::CxxRef1{TNDArray}


""" GetArray(this::ByRef1{THn})

# Wrapper of Long64_t THn::GetBin(const Double_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THn}, x::ByConstPtr2{Float64}, ::Bool)::Int64


""" GetBin(this::ByRef1{THn}, x::ByConstPtr2{Float64}, ::Bool)

# Wrapper of Long64_t THn::GetBin(const Int_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, ::Bool)::Int64


""" GetBin(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, ::Bool)

# Wrapper of void THn::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{THn}, option::ByCopy{String})::Nothing
Reset the contents of a [THn](@ref).

""" Reset(this::ByRef1{THn}, option::ByCopy{String})

# Wrapper of void THn::SetBinContent(const Int_t *, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!SetBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" SetBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THn::SetBinContent(Long64_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)::Nothing


""" SetBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)

# Wrapper of void THn::SetBinError2(Long64_t, Double_t)
@trydoc raw"""
    SetBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)::Nothing


""" SetBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)

# Wrapper of void THn::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THn})::Nothing
Enable calculation of errors.

""" Sumw2(this::ByRef1{THn})

# Wrapper of void THnBase::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{THnBase}, hist::ByConstPtr1{TH1}, c::Float64)::Nothing
Fill the [THnBase](@ref) with the bins of hist that have content or error != 0.

""" Add(this::ByRef1{THnBase}, hist::ByConstPtr1{TH1}, c::Float64)

# Wrapper of void THnBase::Add(const THnBase *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)::Nothing
Add contents of h scaled by c to this histogram: this = this + c * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.

""" Add(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)

# Wrapper of void THnBase::AddBinContent(const Int_t *, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnBase}, x::ByConstPtr2{Int32}, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THnBase}, x::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnBase::AddBinContent(Long64_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)

# Wrapper of void THnBase::AddBinError2(Long64_t, Double_t)
@trydoc raw"""
    AddBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)::Nothing


""" AddBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)

# Wrapper of void THnBase::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{THnBase}, b::ByPtr1{TBrowser})::Nothing
Browse a [THnSparse](@ref): create an entry (ROOT!THnSparseBrowsable) for each dimension.

""" Browse(this::ByRef1{THnBase}, b::ByPtr1{TBrowser})

# Wrapper of void THnBase::CalculateErrors(Bool_t)
@trydoc raw"""
    CalculateErrors(this::ByRef1{THnBase}, calc::Bool)::Nothing
Calculate errors (or not if "calc" == kFALSE)

""" CalculateErrors(this::ByRef1{THnBase}, calc::Bool)

# Wrapper of Double_t THnBase::ComputeIntegral()
@trydoc raw"""
    ComputeIntegral(this::ByRef1{THnBase})::Float64
Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions.
This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. 

###Return

1 if success, 0 if integral is zero
""" ComputeIntegral(this::ByRef1{THnBase})

# Wrapper of void THnBase::Divide(const THnBase *)
@trydoc raw"""
    Divide(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})::Nothing
Divide this histogram by h this = this/(h) Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.
The resulting errors are calculated assuming uncorrelated content.
""" Divide(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})

# Wrapper of void THnBase::Divide(const THnBase *, const THnBase *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{THnBase}, h1::ByConstPtr1{THnBase}, h2::ByConstPtr1{THnBase}, c1::Float64, c2::Float64, option::ByCopy{String})::Nothing
Replace contents of this histogram by multiplication of h1 by h2 this = (c1*h1)/(c2*h2) Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.
The resulting errors are calculated assuming uncorrelated content. However, if option ="B" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.
""" Divide(this::ByRef1{THnBase}, h1::ByConstPtr1{THnBase}, h2::ByConstPtr1{THnBase}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Long64_t THnBase::Fill(const Double_t *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, w::Float64)::Int64


""" Fill(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, w::Float64)

# Wrapper of void THnBase::FillBin(Long64_t, Double_t)
@trydoc raw"""
    FillBin(this::ByRef1{THnBase}, bin::Int64, w::Float64)::Nothing


""" FillBin(this::ByRef1{THnBase}, bin::Int64, w::Float64)

# Wrapper of TFitResultPtr THnBase::Fit(TF1 *, Option_t *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{THnBase}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String})::ByCopy{TFitResultPtr}
Fit a [THnSparse](@ref) with function f.
since the data is sparse by default a likelihood fit is performed merging all the regions with empty bins for better performance efficiency

Since the [THnSparse](@ref) is not drawn no graphics options are passed Here is the list of possible options 
```
          = "I"  Use integral of function in bin instead of value at bin center
          = "X"  Use chi2 method (default is log-likelihood method)
          = "U"  Use a User specified fitting algorithm (via SetFCN)
          = "Q"  Quiet mode (minimum printing)
          = "V"  Verbose mode (default is between Q and V)
          = "E"  Perform better Errors estimation using Minos technique
          = "B"  Use this option when you want to fix one or more parameters
                 and the fitting function is like "gaus", "expo", "poln", "landau".
          = "M"  More. Improve fit results
          = "R"  Use the Range specified in the function range 
```
""" Fit(this::ByRef1{THnBase}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String})

# Wrapper of Long64_t THnBase::GetBin(const Double_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, ::Bool)::Int64


""" GetBin(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, ::Bool)

# Wrapper of Long64_t THnBase::GetBin(const Int_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, ::Bool)::Int64


""" GetBin(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, ::Bool)

# Wrapper of TObjArray * THnBase::GetListOfAxes()
@trydoc raw"""
    GetListOfAxes(this::ByRef1{THnBase})::CxxPtr1{TObjArray}


""" GetListOfAxes(this::ByRef1{THnBase})

# Wrapper of TList * THnBase::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByRef1{THnBase})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByRef1{THnBase})

# Wrapper of void THnBase::GetRandom(Double_t *, Bool_t)
@trydoc raw"""
    GetRandom(this::ByRef1{THnBase}, rand::ByPtr2{Float64}, subBinRandom::Bool)::Nothing
Generate an n-dimensional random tuple based on the histogrammed distribution.
If subBinRandom, the returned tuple will be additionally randomly distributed within the randomized bin, using a flat distribution.
""" GetRandom(this::ByRef1{THnBase}, rand::ByPtr2{Float64}, subBinRandom::Bool)

# Wrapper of Long64_t THnBase::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{THnBase}, list::ByPtr1{TCollection})::Int64
Merge this with a list of [THnBase](@ref)'s.
All [THnBase](@ref)'s provided in the list must have the same bin layout!
""" Merge(this::ByRef1{THnBase}, list::ByPtr1{TCollection})

# Wrapper of void THnBase::Multiply(const THnBase *)
@trydoc raw"""
    Multiply(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})::Nothing
Multiply this histogram by histogram h this = this * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.

""" Multiply(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})

# Wrapper of void THnBase::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{THnBase}, f::ByPtr1{TF1}, c::Float64)::Nothing
Performs the operation: this = this*c*f1 if errors are defined, errors are also recalculated.
Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after calling [Multiply()](@ref)
""" Multiply(this::ByRef1{THnBase}, f::ByPtr1{TF1}, c::Float64)

# Wrapper of void THnBase::RebinnedAdd(const THnBase *, Double_t)
@trydoc raw"""
    RebinnedAdd(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)::Nothing
Add contents of h scaled by c to this histogram: this = this + c * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.
In contrast to [Add()](@ref), [RebinnedAdd()](@ref) does not require consistent binning of this and h; instead, each bin's center is used to determine the target bin.
""" RebinnedAdd(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)

# Wrapper of void THnBase::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{THnBase}, option::ByCopy{String})::Nothing


""" Reset(this::ByRef1{THnBase}, option::ByCopy{String})

# Wrapper of void THnBase::Scale(Double_t)
@trydoc raw"""
    Scale(this::ByRef1{THnBase}, c::Float64)::Nothing
Scale contents and errors of this histogram by c: this = this * c It does not modify the histogram's number of entries.

""" Scale(this::ByRef1{THnBase}, c::Float64)

# Wrapper of void THnBase::SetBinContent(const Int_t *, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing


""" SetBinContent(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnBase::SetBinContent(Long64_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)::Nothing


""" SetBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)

# Wrapper of void THnBase::SetBinEdges(Int_t, const Double_t *)
@trydoc raw"""
    SetBinEdges(this::ByRef1{THnBase}, idim::Int32, bins::ByConstPtr2{Float64})::Nothing
Set the axis # of bins and bin limits on dimension idim.

""" SetBinEdges(this::ByRef1{THnBase}, idim::Int32, bins::ByConstPtr2{Float64})

# Wrapper of void THnBase::SetBinError(const Int_t *, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, e::Float64)::Nothing


""" SetBinError(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, e::Float64)

# Wrapper of void THnBase::SetBinError(Long64_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{THnBase}, bin::Int64, e::Float64)::Nothing


""" SetBinError(this::ByRef1{THnBase}, bin::Int64, e::Float64)

# Wrapper of void THnBase::SetBinError2(Long64_t, Double_t)
@trydoc raw"""
    SetBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)::Nothing


""" SetBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)

# Wrapper of void THnBase::SetEntries(Double_t)
@trydoc raw"""
    SetEntries(this::ByRef1{THnBase}, entries::Float64)::Nothing


""" SetEntries(this::ByRef1{THnBase}, entries::Float64)

# Wrapper of void THnBase::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{THnBase}, title::ByCopy{String})::Nothing
Change (i.e.
set) the title.

If title is in the form "stringt;string0;string1;string2 ..." the histogram title is set to stringt, the title of axis0 to string0, of axis1 to string1, of axis2 to string2, etc, just like it is done for TH1/TH2/TH3. To insert the character ";" in one of the titles, one should use "#;" or "#semicolon".
""" SetTitle(this::ByRef1{THnBase}, title::ByCopy{String})

# Wrapper of void THnBase::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THnBase})::Nothing


""" Sumw2(this::ByRef1{THnBase})

# Wrapper of void THnChain::AddFile(const char *)
@trydoc raw"""
    AddFile(this::ByRef1{THnChain}, fileName::ByCopy{String})::Nothing
Add a new file to this chain.
## Arguments

- **`fileName`** 
    path of the file to add
""" AddFile(this::ByRef1{THnChain}, fileName::ByCopy{String})

# Wrapper of Long64_t THnIter::Next(Int_t *)
@trydoc raw"""
    Next(this::ByRef1{THnIter}, coord::ByPtr2{Int32})::Int64
Return the next bin's index.
If provided, set coord to that bin's coordinates (bin indexes). I.e. coord must point to Int_t[hist->GetNdimensions()] Returns -1 when all bins have been visited.
""" Next(this::ByRef1{THnIter}, coord::ByPtr2{Int32})

# Wrapper of void THnSparse::AddBinContent(const Int_t *, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!AddBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" AddBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnSparse::AddBinContent(Long64_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)::Nothing
Add "v" to the content of bin with index "bin".

""" AddBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)

# Wrapper of void THnSparse::AddBinError2(Long64_t, Double_t)
@trydoc raw"""
    AddBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)::Nothing
Add "e" to error of bin with index "bin", enable errors if needed.

""" AddBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)

# Wrapper of Long64_t THnSparse::GetBin(const Double_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnSparse}, x::ByConstPtr2{Float64}, allocate::Bool)::Int64
Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and "allocate" is true.

""" GetBin(this::ByRef1{THnSparse}, x::ByConstPtr2{Float64}, allocate::Bool)

# Wrapper of Long64_t THnSparse::GetBin(const Int_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, allocate::Bool)::Int64
Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and "allocate" is true.

""" GetBin(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, allocate::Bool)

# Wrapper of void THnSparse::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{THnSparse}, option::ByCopy{String})::Nothing
Clear the histogram.

""" Reset(this::ByRef1{THnSparse}, option::ByCopy{String})

# Wrapper of void THnSparse::SetBinContent(const Int_t *, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!SetBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" SetBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnSparse::SetBinContent(Long64_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)::Nothing
Set content of bin with index "bin" to "v".

""" SetBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)

# Wrapper of void THnSparse::SetBinError2(Long64_t, Double_t)
@trydoc raw"""
    SetBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)::Nothing
Set error of bin with index "bin" to "e", enable errors if needed.

""" SetBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)

# Wrapper of void THnSparse::SetFilledBins(Long64_t)
@trydoc raw"""
    SetFilledBins(this::ByRef1{THnSparse}, nbins::Int64)::Nothing


""" SetFilledBins(this::ByRef1{THnSparse}, nbins::Int64)

# Wrapper of void THnSparse::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THnSparse})::Nothing
Enable calculation of errors.

""" Sumw2(this::ByRef1{THnSparse})

# Wrapper of void THStack::Add(TH1 *, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{THStack}, h::ByPtr1{TH1}, option::ByCopy{String})::Nothing
Add a new histogram to the list.
Only 1-d and 2-d histograms currently supported. A drawing option may be specified
""" Add(this::ByRef1{THStack}, h::ByPtr1{TH1}, option::ByCopy{String})

# Wrapper of void THStack::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{THStack}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{THStack}, b::ByPtr1{TBrowser})

# Wrapper of void THStack::BuildPrimitives(Option_t *)
@trydoc raw"""
    BuildPrimitives(this::ByRef1{THStack}, chopt::ByCopy{String})::Nothing


""" BuildPrimitives(this::ByRef1{THStack}, chopt::ByCopy{String})

# Wrapper of Int_t THStack::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{THStack}, px::Int32, py::Int32)::Int32
Compute distance from point px, py to each graph.

""" DistancetoPrimitive(this::ByRef1{THStack}, px::Int32, py::Int32)

# Wrapper of void THStack::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{THStack}, chopt::ByCopy{String})::Nothing
Draw this stack with its current attributes.
Options to draw histograms are described in [THistPainter!Paint](@ref) By default (if the option "nostack" is not specified), histograms will be painted stacked on top of each other.
""" Draw(this::ByRef1{THStack}, chopt::ByCopy{String})

# Wrapper of Double_t THStack::GetMaximum(Option_t *, Double_t)
@trydoc raw"""
    GetMaximum(this::ByRef1{THStack}, option::ByCopy{String}, maxval::Float64)::Float64
Returns the maximum of all added histograms smaller than maxval.
Returns the maximum of all histograms, smaller than maxval, if option "nostack".
""" GetMaximum(this::ByRef1{THStack}, option::ByCopy{String}, maxval::Float64)

# Wrapper of Double_t THStack::GetMinimum(Option_t *, Double_t)
@trydoc raw"""
    GetMinimum(this::ByRef1{THStack}, option::ByCopy{String}, minval::Float64)::Float64
Returns the minimum of all added histograms larger than minval.
Returns the minimum of all histograms, larger than minval, if option "nostack".
""" GetMinimum(this::ByRef1{THStack}, option::ByCopy{String}, minval::Float64)

# Wrapper of TObjArray * THStack::GetStack()
@trydoc raw"""
    GetStack(this::ByRef1{THStack})::CxxPtr1{TObjArray}
Return pointer to Stack. Build it if not yet done.

""" GetStack(this::ByRef1{THStack})

# Wrapper of void THStack::Modified()
@trydoc raw"""
    Modified(this::ByRef1{THStack})::Nothing
Note: this method invalidates the sum of histograms.

""" Modified(this::ByRef1{THStack})

# Wrapper of void THStack::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{THStack}, chopt::ByCopy{String})::Nothing
[Paint the list of histograms.](@ref)

""" Paint(this::ByRef1{THStack}, chopt::ByCopy{String})

# Wrapper of void THStack::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{THStack}, obj::ByPtr1{TObject})::Nothing
Recursively remove the object `obj` from the list of histograms.

""" RecursiveRemove(this::ByRef1{THStack}, obj::ByPtr1{TObject})

# Wrapper of void THStack::SetHistogram(TH1 *)
@trydoc raw"""
    SetHistogram(this::ByRef1{THStack}, h::ByPtr1{TH1})::Nothing


""" SetHistogram(this::ByRef1{THStack}, h::ByPtr1{TH1})

# Wrapper of void THStack::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{THStack}, maximum::Float64)::Nothing
Set maximum.

""" SetMaximum(this::ByRef1{THStack}, maximum::Float64)

# Wrapper of void THStack::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{THStack}, minimum::Float64)::Nothing
Set minimum.

""" SetMinimum(this::ByRef1{THStack}, minimum::Float64)

# Wrapper of void TKDE::Draw(const Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TKDE}, option::ByCopy{String})::Nothing
Draws either the KDE functions or its errors.

""" Draw(this::ByRef1{TKDE}, option::ByCopy{String})

# Wrapper of void TKDE::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TKDE}, data::Float64)::Nothing


""" Fill(this::ByRef1{TKDE}, data::Float64)

# Wrapper of void TKDE::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TKDE}, data::Float64, weight::Float64)::Nothing


""" Fill(this::ByRef1{TKDE}, data::Float64, weight::Float64)

# Wrapper of TF1 * TKDE::GetApproximateBias(UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetApproximateBias(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetApproximateBias(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of TF1 * TKDE::GetFunction(UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetFunction(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetFunction(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of TGraphErrors * TKDE::GetGraphWithErrors(UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetGraphWithErrors(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TGraphErrors}
return a [TGraphErrors](@ref) with the KDE values and errors The return object is managed by the user

""" GetGraphWithErrors(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of TF1 * TKDE::GetLowerFunction(Double_t, UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetLowerFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetLowerFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of TF1 * TKDE::GetUpperFunction(Double_t, UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetUpperFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetUpperFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of void TKDE::SetNBins(UInt_t)
@trydoc raw"""
    SetNBins(this::ByRef1{TKDE}, nbins::UInt32)::Nothing


""" SetNBins(this::ByRef1{TKDE}, nbins::UInt32)

# Wrapper of void TKDE::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TKDE}, xMin::Float64, xMax::Float64)::Nothing
By default computed from the data.

""" SetRange(this::ByRef1{TKDE}, xMin::Float64, xMax::Float64)

# Wrapper of void TKDE::SetTuneFactor(Double_t)
@trydoc raw"""
    SetTuneFactor(this::ByRef1{TKDE}, rho::Float64)::Nothing


""" SetTuneFactor(this::ByRef1{TKDE}, rho::Float64)

# Wrapper of void TKDE::SetUseBinsNEvents(UInt_t)
@trydoc raw"""
    SetUseBinsNEvents(this::ByRef1{TKDE}, nEvents::UInt32)::Nothing


""" SetUseBinsNEvents(this::ByRef1{TKDE}, nEvents::UInt32)

# Wrapper of void TLimitDataSource::AddChannel(TH1 *, TH1 *, TH1 *)
@trydoc raw"""
    AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1})::Nothing
Adds a channel with signal, background and data given as input.

""" AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1})

# Wrapper of void TLimitDataSource::AddChannel(TH1 *, TH1 *, TH1 *, TVectorD *, TVectorD *, TObjArray *)
@trydoc raw"""
    AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TVectorD}, ::ByPtr1{TVectorD}, ::ByPtr1{TObjArray})::Nothing
Adds a channel with signal, background and data given as input.
In addition, error sources are defined. [TH1](@ref) are here used for convenience: each bin has to be seen as an error source (relative). names is an array of strings containing the names of the sources. Sources with the same name are correlated.
""" AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TVectorD}, ::ByPtr1{TVectorD}, ::ByPtr1{TObjArray})

# Wrapper of TObjArray * TLimitDataSource::GetBackground()
@trydoc raw"""
    GetBackground(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetBackground(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetCandidates()
@trydoc raw"""
    GetCandidates(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetCandidates(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetErrorNames()
@trydoc raw"""
    GetErrorNames(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetErrorNames(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetErrorOnBackground()
@trydoc raw"""
    GetErrorOnBackground(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetErrorOnBackground(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetErrorOnSignal()
@trydoc raw"""
    GetErrorOnSignal(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetErrorOnSignal(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetSignal()
@trydoc raw"""
    GetSignal(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetSignal(this::ByRef1{TLimitDataSource})

# Wrapper of void TLimitDataSource::SetOwner(bool)
@trydoc raw"""
    SetOwner(this::ByRef1{TLimitDataSource}, swtch::Bool)::Nothing
Gives to the [TLimitDataSource](@ref) the ownership of the various objects given as input.
Objects are then deleted by the [TLimitDataSource](@ref) destructor.
""" SetOwner(this::ByRef1{TLimitDataSource}, swtch::Bool)

# Wrapper of void TMultiDimFit::AddRow(const Double_t *, Double_t, Double_t)
@trydoc raw"""
    AddRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)::Nothing
Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization.
The mean of the variables and quantity is calculated on the fly, as outlined in [TPrincipal!AddRow](@ref). This sample should be representative of the problem at hand. Please note, that if no error is given Poisson statistics is assumed and the square error is set to the value of dependent quantity. See also the [class description](#TMultiDimFit:description)
""" AddRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)

# Wrapper of void TMultiDimFit::AddTestRow(const Double_t *, Double_t, Double_t)
@trydoc raw"""
    AddTestRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)::Nothing
Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization.
This sample needn't be representative of the problem at hand. Please note, that if no error is given Poisson statistics is assumed and the square error is set to the value of dependent quantity. See also the [class description](#TMultiDimFit:description)
""" AddTestRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)

# Wrapper of void TMultiDimFit::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TMultiDimFit}, b::ByPtr1{TBrowser})::Nothing
Browse the [TMultiDimFit](@ref) object in the [TBrowser](@ref).

""" Browse(this::ByRef1{TMultiDimFit}, b::ByPtr1{TBrowser})

# Wrapper of void TMultiDimFit::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Clear internal structures and variables.

""" Clear(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::FindParameterization(Option_t *)
@trydoc raw"""
    FindParameterization(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Find the parameterization.
Options: None so far

For detailed description of what this entails, please refer to the [class description](#TMultiDimFit:description)
""" FindParameterization(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::Fit(Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Try to fit the found parameterisation to the test sample.
Options M use Minuit to improve coefficients

Also, refer to [class description](#TMultiDimFit:description)
""" Fit(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of Double_t TMultiDimFit::MakeChi2(const Double_t *)
@trydoc raw"""
    MakeChi2(this::ByRef1{TMultiDimFit}, coeff::ByConstPtr2{Float64})::Float64
Calculate Chi square over either the test sample.
The optional argument coeff is a vector of coefficients to use in the evaluation of the parameterisation. If coeff == 0, then the found coefficients is used. Used my MINUIT for fit (see TMultDimFit!Fit)
""" MakeChi2(this::ByRef1{TMultiDimFit}, coeff::ByConstPtr2{Float64})

# Wrapper of void TMultiDimFit::MakeCode(const char *, Option_t *)
@trydoc raw"""
    MakeCode(this::ByRef1{TMultiDimFit}, functionName::ByCopy{String}, option::ByCopy{String})::Nothing
Generate the file `<filename>` with .C appended if argument doesn't theend in .cxx or .C.
The contains the implementation of the function:

`Double_t <funcname>(Double_t *x)`

which does the same as [TMultiDimFit!Eval](@ref). Please refer to this method.

Further, the static variables: 
```
Int_t    gNVariables
Int_t    gNCoefficients
Double_t gDMean
Double_t gXMean[]
Double_t gXMin[]
Double_t gXMax[]
Double_t gCoefficient[]
Int_t    gPower[]
```  are initialized. The only [ROOT](@ref) header file needed is Rtypes.h

See [TMultiDimFit!MakeRealCode](@ref) for a list of options
""" MakeCode(this::ByRef1{TMultiDimFit}, functionName::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::MakeHistograms(Option_t *)
@trydoc raw"""
    MakeHistograms(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Make histograms of the result of the analysis.
This message should be sent after having read all data points, but before finding the parameterization

Options: A All the below X Original independent variables D Original dependent variables N Normalised independent variables S Shifted dependent variables R1 Residuals versus normalised independent variables R2 Residuals versus dependent variable R3 Residuals computed on training sample R4 Residuals computed on test sample

For a description of these quantities, refer to [class description](#TMultiDimFit:description)
""" MakeHistograms(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::MakeMethod(const Char_t *, Option_t *)
@trydoc raw"""
    MakeMethod(this::ByRef1{TMultiDimFit}, className::ByCopy{String}, option::ByCopy{String})::Nothing
Generate the file `<classname>MDF.cxx` which contains the implementation of the method:
`Double_t <classname>!MDF(Double_t *x)`

which does the same as [TMultiDimFit!Eval](@ref). Please refer to this method.

Further, the public static members: 

    Int_t    <classname>!fgNVariables
    Int_t    <classname>!fgNCoefficients
    Double_t <classname>!fgDMean
    Double_t <classname>!fgXMean[]       //[fgNVariables]
    Double_t <classname>!fgXMin[]        //[fgNVariables]
    Double_t <classname>!fgXMax[]        //[fgNVariables]
    Double_t <classname>!fgCoefficient[] //[fgNCoeffficents]
    Int_t    <classname>!fgPower[]       //[fgNCoeffficents*fgNVariables]

(C++ version of the code)

are initialized, and assumed to exist. The class declaration is assumed to be in `<classname>.h` and assumed to be provided by the user.

###See

TMultiDimFit!MakeRealCode for a list of options

The minimal class definition is: 

    class <classname> {
    public:
      Int_t    <classname>!fgNVariables;     // Number of variables
      Int_t    <classname>!fgNCoefficients;  // Number of terms
      Double_t <classname>!fgDMean;          // Mean from training sample
      Double_t <classname>!fgXMean[];        // Mean from training sample
      Double_t <classname>!fgXMin[];         // Min from training sample
      Double_t <classname>!fgXMax[];         // Max from training sample
      Double_t <classname>!fgCoefficient[];  // Coefficients
      Int_t    <classname>!fgPower[];        // Function powers
      Double_t Eval(Double_t *x);
    };

(C++ version of the code)

Whether the method `<classname>!Eval` should be static or not, is up to the user.
""" MakeMethod(this::ByRef1{TMultiDimFit}, className::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::SetBinVarX(Int_t)
@trydoc raw"""
    SetBinVarX(this::ByRef1{TMultiDimFit}, nbbinvarx::Int32)::Nothing


""" SetBinVarX(this::ByRef1{TMultiDimFit}, nbbinvarx::Int32)

# Wrapper of void TMultiDimFit::SetBinVarY(Int_t)
@trydoc raw"""
    SetBinVarY(this::ByRef1{TMultiDimFit}, nbbinvary::Int32)::Nothing


""" SetBinVarY(this::ByRef1{TMultiDimFit}, nbbinvary::Int32)

# Wrapper of void TMultiDimFit::SetMaxAngle(Double_t)
@trydoc raw"""
    SetMaxAngle(this::ByRef1{TMultiDimFit}, angle::Float64)::Nothing
Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit.
By default it is 0, which automatically chooses another selection criteria. See also [class description](#TMultiDimFit:description)
""" SetMaxAngle(this::ByRef1{TMultiDimFit}, angle::Float64)

# Wrapper of void TMultiDimFit::SetMaxFunctions(Int_t)
@trydoc raw"""
    SetMaxFunctions(this::ByRef1{TMultiDimFit}, n::Int32)::Nothing


""" SetMaxFunctions(this::ByRef1{TMultiDimFit}, n::Int32)

# Wrapper of void TMultiDimFit::SetMaxPowers(const Int_t *)
@trydoc raw"""
    SetMaxPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32})::Nothing
Set the maximum power to be considered in the fit for each variable.
See also [class description](#TMultiDimFit:description)
""" SetMaxPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32})

# Wrapper of void TMultiDimFit::SetMaxStudy(Int_t)
@trydoc raw"""
    SetMaxStudy(this::ByRef1{TMultiDimFit}, n::Int32)::Nothing


""" SetMaxStudy(this::ByRef1{TMultiDimFit}, n::Int32)

# Wrapper of void TMultiDimFit::SetMaxTerms(Int_t)
@trydoc raw"""
    SetMaxTerms(this::ByRef1{TMultiDimFit}, terms::Int32)::Nothing


""" SetMaxTerms(this::ByRef1{TMultiDimFit}, terms::Int32)

# Wrapper of void TMultiDimFit::SetMinAngle(Double_t)
@trydoc raw"""
    SetMinAngle(this::ByRef1{TMultiDimFit}, angle::Float64)::Nothing
Set the min angle (in degrees) between a new candidate function and the subspace spanned by the previously accepted functions.
See also [class description](#TMultiDimFit:description)
""" SetMinAngle(this::ByRef1{TMultiDimFit}, angle::Float64)

# Wrapper of void TMultiDimFit::SetMinRelativeError(Double_t)
@trydoc raw"""
    SetMinRelativeError(this::ByRef1{TMultiDimFit}, error::Float64)::Nothing
Set the acceptable relative error for when sum of square residuals is considered minimized.
For a full account, refer to the [class description](#TMultiDimFit:description)
""" SetMinRelativeError(this::ByRef1{TMultiDimFit}, error::Float64)

# Wrapper of void TMultiDimFit::SetPowerLimit(Double_t)
@trydoc raw"""
    SetPowerLimit(this::ByRef1{TMultiDimFit}, limit::Float64)::Nothing
Set the user parameter for the function selection.
The bigger the limit, the more functions are used. The meaning of this variable is defined in the [class description](#TMultiDimFit:description)
""" SetPowerLimit(this::ByRef1{TMultiDimFit}, limit::Float64)

# Wrapper of void TMultiDimFit::SetPowers(const Int_t *, Int_t)
@trydoc raw"""
    SetPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32}, terms::Int32)::Nothing
Define a user function.
The input array must be of the form (p11, ..., p1N, ... ,pL1, ..., pLN) Where N is the dimension of the data sample, L is the number of terms (given in terms) and the first number, labels the term, the second the variable. More information is given in the [class description](#TMultiDimFit:description)
""" SetPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32}, terms::Int32)

# Wrapper of Int_t TPolyMarker::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TPolyMarker}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a polymarker.
Compute the closest distance of approach from point px,py to each point of the polymarker. Returns when the distance found is below DistanceMaximum. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TPolyMarker}, px::Int32, py::Int32)

# Wrapper of void TPolyMarker::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TPolyMarker}, option::ByCopy{String})::Nothing
Draw.

""" Draw(this::ByRef1{TPolyMarker}, option::ByCopy{String})

# Wrapper of void TPolyMarker::DrawPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing
Draw polymarker.

""" DrawPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TPolyMarker::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TPolyMarker}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function must be implemented to realize the action corresponding to the mouse click on the object in the window
""" ExecuteEvent(this::ByRef1{TPolyMarker}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TPolyMarker::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TPolyMarker}, list::ByPtr1{TCollection})::Int32
Merge polymarkers in the collection in this polymarker.

""" Merge(this::ByRef1{TPolyMarker}, list::ByPtr1{TCollection})

# Wrapper of void TPolyMarker::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TPolyMarker}, option::ByCopy{String})::Nothing
Paint.

""" Paint(this::ByRef1{TPolyMarker}, option::ByCopy{String})

# Wrapper of void TPolyMarker::PaintPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing
Paint polymarker.

""" PaintPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of Int_t TPolyMarker::SetNextPoint(Double_t, Double_t)
@trydoc raw"""
    SetNextPoint(this::ByRef1{TPolyMarker}, x::Float64, y::Float64)::Int32
Set point following LastPoint to x, y.
Returns index of the point (new last point).
""" SetNextPoint(this::ByRef1{TPolyMarker}, x::Float64, y::Float64)

# Wrapper of void TPolyMarker::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TPolyMarker}, point::Int32, x::Float64, y::Float64)::Nothing
Set point number n.
if n is greater than the current size, the arrays are automatically extended
""" SetPoint(this::ByRef1{TPolyMarker}, point::Int32, x::Float64, y::Float64)

# Wrapper of void TPolyMarker::SetPolyMarker(Int_t)
@trydoc raw"""
    SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32)::Nothing
If n <= 0 the current arrays of points are deleted.

""" SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32)

# Wrapper of void TPolyMarker::SetPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing
If n <= 0 the current arrays of points are deleted.

""" SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TPolyMarker::SetPolyMarker(Int_t, Float_t *, Float_t *, Option_t *)
@trydoc raw"""
    SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})::Nothing
If n <= 0 the current arrays of points are deleted.

""" SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})

# Wrapper of Int_t TProfile2Poly::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64)::Int32
Fill.

""" Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64)

# Wrapper of Int_t TProfile2Poly::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64, weight::Float64)::Int32
Fill.

""" Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64, weight::Float64)

# Wrapper of Double_t TProfile2Poly::GetOverflowContent(Int_t)
@trydoc raw"""
    GetOverflowContent(this::ByRef1{TProfile2Poly}, idx::Int32)::Float64


""" GetOverflowContent(this::ByRef1{TProfile2Poly}, idx::Int32)

# Wrapper of Long64_t TProfile2Poly::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile2Poly}, in::ByPtr1{TCollection})::Int64
Merge.

""" Merge(this::ByRef1{TProfile2Poly}, in::ByPtr1{TCollection})

# Wrapper of void TProfile2Poly::PrintOverflowRegions()
@trydoc raw"""
    PrintOverflowRegions(this::ByRef1{TProfile2Poly})::Nothing
Print overflow regions.

""" PrintOverflowRegions(this::ByRef1{TProfile2Poly})

# Wrapper of void TProfile2Poly::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile2Poly}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TProfile2Poly}, option::ByCopy{String})

# Wrapper of void TProfile2Poly::SetContentToAverage()
@trydoc raw"""
    SetContentToAverage(this::ByRef1{TProfile2Poly})::Nothing
Set content to average.

""" SetContentToAverage(this::ByRef1{TProfile2Poly})

# Wrapper of void TProfile2Poly::SetContentToError()
@trydoc raw"""
    SetContentToError(this::ByRef1{TProfile2Poly})::Nothing
Set content to error.

""" SetContentToError(this::ByRef1{TProfile2Poly})

# Wrapper of void TProfile2Poly::SetErrorOption(EErrorType)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile2Poly}, type::ByCopy{EErrorType})::Nothing
Set error option.

""" SetErrorOption(this::ByRef1{TProfile2Poly}, type::ByCopy{EErrorType})

# Wrapper of void TProfile2PolyBin::ClearStats()
@trydoc raw"""
    ClearStats(this::ByRef1{TProfile2PolyBin})::Nothing
Clear statistics.

""" ClearStats(this::ByRef1{TProfile2PolyBin})

# Wrapper of void TProfile2PolyBin::Merge(const TProfile2PolyBin *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile2PolyBin}, toMerge::ByConstPtr1{TProfile2PolyBin})::Nothing
Merge.

""" Merge(this::ByRef1{TProfile2PolyBin}, toMerge::ByConstPtr1{TProfile2PolyBin})

# Wrapper of void TProfile2PolyBin::Update()
@trydoc raw"""
    Update(this::ByRef1{TProfile2PolyBin})::Nothing
Update.

""" Update(this::ByRef1{TProfile2PolyBin})

# Wrapper of Bool_t TProfile3D::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this profile3D by the addition of h1 and h2.
`this = c1*h1 + c2*h2`
""" Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TProfile3D::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: `this = this + c1*h1` .

""" Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TProfile3D::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: `this = this + c1*f1` .

""" Add(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TProfile3D::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TProfile3D}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TProfile3D}, action::Int32)

# Wrapper of void TProfile3D::BuildOptions(Double_t, Double_t, Option_t *)
@trydoc raw"""
    BuildOptions(this::ByRef1{TProfile3D}, tmin::Float64, tmax::Float64, option::ByCopy{String})::Nothing
Set Profile3D histogram structure and options.
- tmin: minimum value allowed for t
- tmax: maximum value allowed for t if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf)
- option: this is the option for the computation of the t error of the profile ( [TProfile3D!GetBinError](@ref) ) possible values for the options are documented in [TProfile3D!SetErrorOption](@ref)

see also [TProfile!BuildOptions](@ref) for a detailed description
""" BuildOptions(this::ByRef1{TProfile3D}, tmin::Float64, tmax::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile3D::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})::Bool
Divide this profile2D by h1.
`this = this/h1`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile3D::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile3D::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)` .
This function is not implemented
""" Divide(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TProfile3D::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TProfile3D}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Profile histogram is resized along axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the rebinned histogram. Takes into account errors (Sumw2) if any. The axis must be rebinnable before invoking this function. Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`
""" ExtendAxis(this::ByRef1{TProfile3D}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of Int_t TProfile3D::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64)::Int32
Fill a Profile3D histogram (no weights).

""" Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of Int_t TProfile3D::Fill(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64, w::Float64)::Int32
Fill a Profile3D histogram with weights.

""" Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64, w::Float64)

# Wrapper of Double_t TProfile3D::GetBinEffectiveEntries(Int_t)
@trydoc raw"""
    GetBinEffectiveEntries(this::ByRef1{TProfile3D}, bin::Int32)::Float64
Return bin effective entries for a weighted filled Profile histogram.
In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. [TProfile!Sumw2()](@ref) must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored.
""" GetBinEffectiveEntries(this::ByRef1{TProfile3D}, bin::Int32)

# Wrapper of TArrayD * TProfile3D::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByRef1{TProfile3D})::CxxPtr1{TArrayD}


""" GetBinSumw2(this::ByRef1{TProfile3D})

# Wrapper of void TProfile3D::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})::Nothing
Reduce the number of bins for this axis to the number of bins having a label.

""" LabelsDeflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})

# Wrapper of void TProfile3D::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})

# Wrapper of void TProfile3D::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TProfile3D}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Set option(s) to draw axis with labels.
option might have the following values:

- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TProfile3D}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TProfile3D::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile3D}, list::ByPtr1{TCollection})::Int64
Merge all histograms in the collection in this histogram.
This function computes the min/max for the axes, compute a new number of bins, if necessary, add bin contents, errors and statistics. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

IMPORTANT remark. The 2 axis x and y may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width.
""" Merge(this::ByRef1{TProfile3D}, list::ByPtr1{TCollection})

# Wrapper of Bool_t TProfile3D::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})::Bool
Multiply this profile2D by h1.
`this = this*h1`
""" Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile3D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`
""" Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile3D::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this*c1*f1` .

""" Multiply(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of TProfile3D & TProfile3D::operator=(const TProfile3D &)
@trydoc raw"""
    assign(this::ByRef1{TProfile3D}, profile::ByConstRef1{TProfile3D})::CxxRef1{TProfile3D}


""" assign(this::ByRef1{TProfile3D}, profile::ByConstRef1{TProfile3D})

# Wrapper of void TProfile3D::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TProfile3D}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TProfile3D}, stats::ByPtr2{Float64})

# Wrapper of void TProfile3D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile3D}, option::ByCopy{String})::Nothing
Reset contents of a Profile3D histogram.

""" Reset(this::ByRef1{TProfile3D}, option::ByCopy{String})

# Wrapper of void TProfile3D::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TProfile3D}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this profile2D by a constant c1.
`this = c1*this`

This function uses the services of [TProfile3D!Add](@ref)
""" Scale(this::ByRef1{TProfile3D}, c1::Float64, option::ByCopy{String})

# Wrapper of void TProfile3D::SetBinEntries(Int_t, Double_t)
@trydoc raw"""
    SetBinEntries(this::ByRef1{TProfile3D}, bin::Int32, w::Float64)::Nothing
Set the number of entries in bin.

""" SetBinEntries(this::ByRef1{TProfile3D}, bin::Int32, w::Float64)

# Wrapper of void TProfile3D::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile3D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64, nbinsz::Int32, zmin::Float64, zmax::Float64)::Nothing
Redefine x, y and z axis parameters.

""" SetBins(this::ByRef1{TProfile3D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64, nbinsz::Int32, zmin::Float64, zmax::Float64)

# Wrapper of void TProfile3D::SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile3D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})::Nothing
Redefine x, y and z axis parameters with variable bin sizes.

""" SetBins(this::ByRef1{TProfile3D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})

# Wrapper of void TProfile3D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TProfile3D}, n::Int32)::Nothing
Set total number of bins including under/overflow.
Reallocate bin contents array
""" SetBinsLength(this::ByRef1{TProfile3D}, n::Int32)

# Wrapper of void TProfile3D::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TProfile3D}, buffersize::Int32, opt::ByCopy{String})::Nothing
Set the buffer size in units of 8 bytes (double).

""" SetBuffer(this::ByRef1{TProfile3D}, buffersize::Int32, opt::ByCopy{String})

# Wrapper of void TProfile3D::SetErrorOption(Option_t *)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile3D}, option::ByCopy{String})::Nothing
Set option to compute profile3D errors.
The computation of the bin errors is based on the parameter option:

- ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T), i.e. the standard error of the bin contents. Note that if [TProfile3D!Approximate()](@ref) is called, an approximation is used when the spread in T is 0 and the number of bin entries is > 0
- 's' The bin errors are the standard deviations of the T bin values Note that if [TProfile3D!Approximate()](@ref) is called, an approximation is used when the spread in T is 0 and the number of bin entries is > 0
- 'i' Errors are as in default case (standard errors of the bin contents) The only difference is for the case when the spread in T is zero. In this case for N > 0 the error is 1./SQRT(12.*N)
- 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0. W is the sum in the bin of the weights of the profile. This option is for combining measurements t +/- dt, and the profile is filled with values t and weights w = 1/dt**2

    See [TProfile!BuildOptions](@ref) for explanation of all options
""" SetErrorOption(this::ByRef1{TProfile3D}, option::ByCopy{String})

# Wrapper of void TProfile3D::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TProfile3D}, flag::Bool)::Nothing
Create/Delete structure to store sum of squares of weights per bin This is needed to compute the correct statistical quantities of a profile filled with weights.
This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag = false the structure is deleted
""" Sumw2(this::ByRef1{TProfile3D}, flag::Bool)

# Wrapper of Int_t TScatter::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TScatter}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a scatter plot.
Compute the closest distance of approach from point px,py to this scatter plot. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TScatter}, px::Int32, py::Int32)

# Wrapper of void TScatter::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TScatter}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a graph is clicked with the locator

If Left button clicked on one of the line theend points, this point follows the cursor until button is released.

if Middle button clicked, the line is moved parallel to itself until the button is released.
""" ExecuteEvent(this::ByRef1{TScatter}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TScatter::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TScatter}, chopt::ByCopy{String})::Nothing
Paint this scatter plot with its current attributes.

""" Paint(this::ByRef1{TScatter}, chopt::ByCopy{String})

# Wrapper of void TScatter::SetHistogram(TH2F *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TScatter}, h::ByPtr1{TH2F})::Nothing


""" SetHistogram(this::ByRef1{TScatter}, h::ByPtr1{TH2F})

# Wrapper of void TScatter::SetMargin(Double_t)
@trydoc raw"""
    SetMargin(this::ByRef1{TScatter}, ::Float64)::Nothing
Set the margin around the plot in %.

""" SetMargin(this::ByRef1{TScatter}, ::Float64)

# Wrapper of void TScatter::SetMaxMarkerSize(Double_t)
@trydoc raw"""
    SetMaxMarkerSize(this::ByRef1{TScatter}, max::Float64)::Nothing
Set the largest marker size used to paint the markers.

""" SetMaxMarkerSize(this::ByRef1{TScatter}, max::Float64)

# Wrapper of void TScatter::SetMinMarkerSize(Double_t)
@trydoc raw"""
    SetMinMarkerSize(this::ByRef1{TScatter}, min::Float64)::Nothing
Set the smallest marker size used to paint the markers.

""" SetMinMarkerSize(this::ByRef1{TScatter}, min::Float64)

# Wrapper of Double_t & TSplinePoly::X()
@trydoc raw"""
    X(this::ByRef1{TSplinePoly})::CxxRef2{Float64}


""" X(this::ByRef1{TSplinePoly})

# Wrapper of Double_t & TSplinePoly::Y()
@trydoc raw"""
    Y(this::ByRef1{TSplinePoly})::CxxRef2{Float64}


""" Y(this::ByRef1{TSplinePoly})

# Wrapper of Double_t & TSplinePoly3::B()
@trydoc raw"""
    B(this::ByRef1{TSplinePoly3})::CxxRef2{Float64}


""" B(this::ByRef1{TSplinePoly3})

# Wrapper of Double_t & TSplinePoly3::C()
@trydoc raw"""
    C(this::ByRef1{TSplinePoly3})::CxxRef2{Float64}


""" C(this::ByRef1{TSplinePoly3})

# Wrapper of Double_t & TSplinePoly3::D()
@trydoc raw"""
    D(this::ByRef1{TSplinePoly3})::CxxRef2{Float64}


""" D(this::ByRef1{TSplinePoly3})

# Wrapper of Double_t & TSplinePoly5::B()
@trydoc raw"""
    B(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" B(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t & TSplinePoly5::C()
@trydoc raw"""
    C(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" C(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t & TSplinePoly5::D()
@trydoc raw"""
    D(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" D(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t & TSplinePoly5::E()
@trydoc raw"""
    E(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" E(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t & TSplinePoly5::F()
@trydoc raw"""
    F(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" F(this::ByRef1{TSplinePoly5})

# Wrapper of TSpline3 & TSpline3::operator=(const TSpline3 &)
@trydoc raw"""
    assign(this::ByRef1{TSpline3}, ::ByConstRef1{TSpline3})::CxxRef1{TSpline3}
Assignment operator.

""" assign(this::ByRef1{TSpline3}, ::ByConstRef1{TSpline3})

# Wrapper of void TSpline3::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TSpline3}, i::Int32, x::Float64, y::Float64)::Nothing
Set point number i.

""" SetPoint(this::ByRef1{TSpline3}, i::Int32, x::Float64, y::Float64)

# Wrapper of void TSpline3::SetPointCoeff(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointCoeff(this::ByRef1{TSpline3}, i::Int32, b::Float64, c::Float64, d::Float64)::Nothing
Set point coefficient number i.

""" SetPointCoeff(this::ByRef1{TSpline3}, i::Int32, b::Float64, c::Float64, d::Float64)

# Wrapper of TSpline5 & TSpline5::operator=(const TSpline5 &)
@trydoc raw"""
    assign(this::ByRef1{TSpline5}, ::ByConstRef1{TSpline5})::CxxRef1{TSpline5}
Assignment operator.

""" assign(this::ByRef1{TSpline5}, ::ByConstRef1{TSpline5})

# Wrapper of void TSpline5::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TSpline5}, i::Int32, x::Float64, y::Float64)::Nothing
Set point number i.

""" SetPoint(this::ByRef1{TSpline5}, i::Int32, x::Float64, y::Float64)

# Wrapper of void TSpline5::SetPointCoeff(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointCoeff(this::ByRef1{TSpline5}, i::Int32, b::Float64, c::Float64, d::Float64, e::Float64, f::Float64)::Nothing
Set point coefficient number i.

""" SetPointCoeff(this::ByRef1{TSpline5}, i::Int32, b::Float64, c::Float64, d::Float64, e::Float64, f::Float64)

# Wrapper of Double_t TSVDUnfold::ComputeChiSquared(const TH1D &, const TH1D &)
@trydoc raw"""
    ComputeChiSquared(this::ByRef1{TSVDUnfold}, truspec::ByConstRef1{TH1D}, unfspec::ByConstRef1{TH1D})::Float64
Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper.

""" ComputeChiSquared(this::ByRef1{TSVDUnfold}, truspec::ByConstRef1{TH1D}, unfspec::ByConstRef1{TH1D})

# Wrapper of TH2D * TSVDUnfold::GetAdetCovMatrix(Int_t, Int_t)
@trydoc raw"""
    GetAdetCovMatrix(this::ByRef1{TSVDUnfold}, ntoys::Int32, seed::Int32)::CxxPtr1{TH2D}
Determine covariance matrix of unfolded spectrum from finite statistics in response matrix using pseudo experiments "ntoys" - number of pseudo experiments used for the propagation "seed" - seed for pseudo experiments.

""" GetAdetCovMatrix(this::ByRef1{TSVDUnfold}, ntoys::Int32, seed::Int32)

# Wrapper of TH2D * TSVDUnfold::GetUnfoldCovMatrix(const TH2D *, Int_t, Int_t)
@trydoc raw"""
    GetUnfoldCovMatrix(this::ByRef1{TSVDUnfold}, cov::ByConstPtr1{TH2D}, ntoys::Int32, seed::Int32)::CxxPtr1{TH2D}
Determine for given input error matrix covariance matrix of unfolded spectrum from toy simulation given the passed covariance matrix on measured spectrum "cov" - covariance matrix on the measured spectrum, to be propagated "ntoys" - number of pseudo experiments used for the propagation "seed" - seed for pseudo experiments Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area.

""" GetUnfoldCovMatrix(this::ByRef1{TSVDUnfold}, cov::ByConstPtr1{TH2D}, ntoys::Int32, seed::Int32)

# Wrapper of void TSVDUnfold::SetNormalize(Bool_t)
@trydoc raw"""
    SetNormalize(this::ByRef1{TSVDUnfold}, normalize::Bool)::Nothing


""" SetNormalize(this::ByRef1{TSVDUnfold}, normalize::Bool)

# Wrapper of TH1D * TSVDUnfold::Unfold(Int_t)
@trydoc raw"""
    Unfold(this::ByRef1{TSVDUnfold}, kreg::Int32)::CxxPtr1{TH1D}
Perform the unfolding with regularisation parameter kreg.

""" Unfold(this::ByRef1{TSVDUnfold}, kreg::Int32)

# Wrapper of Int_t TVirtualGraphPainter::DistancetoPrimitiveHelper(TGraph *, Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitiveHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, px::Int32, py::Int32)::Int32


""" DistancetoPrimitiveHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, px::Int32, py::Int32)

# Wrapper of void TVirtualGraphPainter::DrawPanelHelper(TGraph *)
@trydoc raw"""
    DrawPanelHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})::Nothing


""" DrawPanelHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})

# Wrapper of void TVirtualGraphPainter::ExecuteEventHelper(TGraph *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEventHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteEventHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGraphPainter::PaintGraph(TGraph *, Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGraph(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing


""" PaintGraph(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintGrapHist(TGraph *, Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGrapHist(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing


""" PaintGrapHist(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintHelper(TGraph *, Option_t *)
@trydoc raw"""
    PaintHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, option::ByCopy{String})::Nothing


""" PaintHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, option::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintScatter(TScatter *, Option_t *)
@trydoc raw"""
    PaintScatter(this::ByRef1{TVirtualGraphPainter}, theScatter::ByPtr1{TScatter}, option::ByCopy{String})::Nothing


""" PaintScatter(this::ByRef1{TVirtualGraphPainter}, theScatter::ByPtr1{TScatter}, option::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintStats(TGraph *, TF1 *)
@trydoc raw"""
    PaintStats(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, fit::ByPtr1{TF1})::Nothing


""" PaintStats(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, fit::ByPtr1{TF1})

# Wrapper of void TVirtualGraphPainter::SetHighlight(TGraph *)
@trydoc raw"""
    SetHighlight(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})::Nothing


""" SetHighlight(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})

# Wrapper of void TVirtualPaveStats::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TVirtualPaveStats}, ::ByPtr1{TObject})::Nothing


""" SetParent(this::ByRef1{TVirtualPaveStats}, ::ByPtr1{TObject})

# Wrapper of TGDMLMatrix & TGDMLMatrix::operator=(const TGDMLMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGDMLMatrix}, rhs::ByConstRef1{TGDMLMatrix})::CxxRef1{TGDMLMatrix}


""" assign(this::ByRef1{TGDMLMatrix}, rhs::ByConstRef1{TGDMLMatrix})

# Wrapper of void TGDMLMatrix::Set(size_t, size_t, Double_t)
@trydoc raw"""
    Set(this::ByRef1{TGDMLMatrix}, r::Int64, c::Int64, a::Float64)::Nothing


""" Set(this::ByRef1{TGDMLMatrix}, r::Int64, c::Int64, a::Float64)

# Wrapper of void TGDMLMatrix::SetMatrixAsString(const char *)
@trydoc raw"""
    SetMatrixAsString(this::ByRef1{TGDMLMatrix}, mat::ByCopy{String})::Nothing


""" SetMatrixAsString(this::ByRef1{TGDMLMatrix}, mat::ByCopy{String})

# Wrapper of void TGeoShape::AfterStreamer()
@trydoc raw"""
    AfterStreamer(this::ByRef1{TGeoShape})::Nothing


""" AfterStreamer(this::ByRef1{TGeoShape})

# Wrapper of void TGeoShape::CheckShape(Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing
Test for shape navigation methods.
Summary for test numbers:

- 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2)
""" CheckShape(this::ByRef1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of void TGeoShape::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoShape})::Nothing


""" ComputeBBox(this::ByRef1{TGeoShape})

# Wrapper of void TGeoShape::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing


""" ComputeNormal(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoShape::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32)::Nothing


""" ComputeNormal_v(this::ByRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32)

# Wrapper of void TGeoShape::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoShape}, ::Int32)::Nothing


""" CreateThreadData(this::ByRef1{TGeoShape}, ::Int32)

# Wrapper of Int_t TGeoShape::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoShape}, px::Int32, py::Int32)::Int32
Computes distance from point (px,py) to the object.
This member function must be implemented for each graphics primitive. This default function returns a big number (999999).
""" DistancetoPrimitive(this::ByRef1{TGeoShape}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoShape::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}


""" Divide(this::ByRef1{TGeoShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoShape::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoShape}, option::ByCopy{String})::Nothing
Draw this shape.

""" Draw(this::ByRef1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TGeoShape::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoShape}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this shape.

""" ExecuteEvent(this::ByRef1{TGeoShape}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TGeoShape::InvertShapeBit(UInt_t)
@trydoc raw"""
    InvertShapeBit(this::ByRef1{TGeoShape}, f::UInt32)::Nothing


""" InvertShapeBit(this::ByRef1{TGeoShape}, f::UInt32)

# Wrapper of void TGeoShape::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoShape}, option::ByCopy{String})::Nothing
Paint this shape.

""" Paint(this::ByRef1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TGeoShape::ResetShapeBit(UInt_t)
@trydoc raw"""
    ResetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)::Nothing


""" ResetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)

# Wrapper of void TGeoShape::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoShape}, param::ByPtr2{Float64})::Nothing


""" SetDimensions(this::ByRef1{TGeoShape}, param::ByPtr2{Float64})

# Wrapper of void TGeoShape::SetId(Int_t)
@trydoc raw"""
    SetId(this::ByRef1{TGeoShape}, id::Int32)::Nothing


""" SetId(this::ByRef1{TGeoShape}, id::Int32)

# Wrapper of void TGeoShape::SetRuntime(Bool_t)
@trydoc raw"""
    SetRuntime(this::ByRef1{TGeoShape}, flag::Bool)::Nothing


""" SetRuntime(this::ByRef1{TGeoShape}, flag::Bool)

# Wrapper of void TGeoShape::SetShapeBit(UInt_t)
@trydoc raw"""
    SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)::Nothing


""" SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)

# Wrapper of void TGeoShape::SetShapeBit(UInt_t, Bool_t)
@trydoc raw"""
    SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32, set::Bool)::Nothing
Equivalent of [TObject!SetBit](@ref).
""" SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32, set::Bool)

# Wrapper of void TGeoMatrix::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoMatrix::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoMatrix::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoMatrix::RegisterYourself()
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoMatrix})::Nothing
Register the matrix in the current manager, which will become the owner.

""" RegisterYourself(this::ByRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" RotateX(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" RotateY(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" RotateZ(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetDefaultName()
@trydoc raw"""
    SetDefaultName(this::ByRef1{TGeoMatrix})::Nothing
If no name was supplied in the ctor, the type of transformation is checked.
A letter will be prepended to the name :

- t - translation
- r - rotation
- s - scale
- c - combi (translation + rotation)
- g - general (tr+rot+scale) The index of the transformation in gGeoManager list of transformations will be appended.
""" SetDefaultName(this::ByRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetShared(Bool_t)
@trydoc raw"""
    SetShared(this::ByRef1{TGeoMatrix}, flag::Bool)::Nothing


""" SetShared(this::ByRef1{TGeoMatrix}, flag::Bool)

# Wrapper of TGeoNode * TGeoVolume::AddNode(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::CxxPtr1{TGeoNode}
Add a [TGeoNode](@ref) to the list of nodes.
This is the usual method for adding daughters inside the container volume.
""" AddNode(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolume::AddNodeOffset(TGeoVolume *, Int_t, Double_t, Option_t *)
@trydoc raw"""
    AddNodeOffset(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, offset::Float64, option::ByCopy{String})::Nothing
Add a division node to the list of nodes.
The method is called by [TGeoVolume!Divide()](@ref) for creating the division nodes.
""" AddNodeOffset(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, offset::Float64, option::ByCopy{String})

# Wrapper of void TGeoVolume::AddNodeOverlap(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNodeOverlap(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::Nothing
Add a [TGeoNode](@ref) to the list of nodes.
This is the usual method for adding daughters inside the container volume.
""" AddNodeOverlap(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolume::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGeoVolume}, b::ByPtr1{TBrowser})::Nothing
How to browse a volume.

""" Browse(this::ByRef1{TGeoVolume}, b::ByPtr1{TBrowser})

# Wrapper of void TGeoVolume::CheckShape(Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TGeoVolume}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing
Tests for checking the shape navigation algorithms. See [TGeoShape!CheckShape()](@ref)
""" CheckShape(this::ByRef1{TGeoVolume}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of void TGeoVolume::CheckShapes()
@trydoc raw"""
    CheckShapes(this::ByRef1{TGeoVolume})::Nothing
check for negative parameters in shapes.

""" CheckShapes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::CleanAll()
@trydoc raw"""
    CleanAll(this::ByRef1{TGeoVolume})::Nothing
Clean data of the volume.

""" CleanAll(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::ClearNodes()
@trydoc raw"""
    ClearNodes(this::ByRef1{TGeoVolume})::Nothing


""" ClearNodes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::ClearShape()
@trydoc raw"""
    ClearShape(this::ByRef1{TGeoVolume})::Nothing
Clear the shape of this volume from the list held by the current manager.

""" ClearShape(this::ByRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::CountNodes(Int_t, Int_t)
@trydoc raw"""
    CountNodes(this::ByRef1{TGeoVolume}, nlevels::Int32, option::Int32)::Int32
Count total number of subnodes starting from this volume, nlevels down.
- option = 0 (default) - count only once per volume
- option = 1 - count every time
- option = 2 - count volumes on visible branches
- option = 3 - return maximum level counted already with option = 0
""" CountNodes(this::ByRef1{TGeoVolume}, nlevels::Int32, option::Int32)

# Wrapper of void TGeoVolume::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoVolume}, nthreads::Int32)::Nothing


""" CreateThreadData(this::ByRef1{TGeoVolume}, nthreads::Int32)

# Wrapper of Int_t TGeoVolume::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoVolume}, px::Int32, py::Int32)::Int32
compute the closest distance of approach from point px,py to this volume

""" DistancetoPrimitive(this::ByRef1{TGeoVolume}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoVolume::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Division a la G3.
The volume will be divided along IAXIS (see shape classes), in NDIV slices, from START with given STEP. The division volumes will have medium number NUMED. If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0, all range of IAXIS will be divided and the resulting number of divisions will be centered on IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV. Options (case insensitive):

- N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3)
- NX - divide range starting with START in NDIV cells (GSDVN2 in G3)
- S - divide all range with given STEP. NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3)
- SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3)
""" Divide(this::ByRef1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of void TGeoVolume::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
draw top volume according to option

""" Draw(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
draw only this volume

""" DrawOnly(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoVolume}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this volume.

""" ExecuteEvent(this::ByRef1{TGeoVolume}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TGeoVolume::Export(const char *, const char *, Option_t *)
@trydoc raw"""
    Export(this::ByRef1{TGeoVolume}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})::Int32
Export this volume to a file.
- Case 1: root file or root/xml file if filename theend with ".root". The key will be named name if filename theend with ".xml" a root/xml file is produced.
- Case 2: C++ script if filename theend with ".C"
- Case 3: gdml file if filename theend with ".gdml"

NOTE that to use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml
""" Export(this::ByRef1{TGeoVolume}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of TObjArray * TGeoVolume::GetNodes()
@trydoc raw"""
    GetNodes(this::ByRef1{TGeoVolume})::CxxPtr1{TObjArray}


""" GetNodes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::Grab()
@trydoc raw"""
    Grab(this::ByRef1{TGeoVolume})::Nothing


""" Grab(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::GrabFocus()
@trydoc raw"""
    GrabFocus(this::ByRef1{TGeoVolume})::Nothing
Move perspective view focus to this volume.

""" GrabFocus(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::Gsord(Int_t)
@trydoc raw"""
    Gsord(this::ByRef1{TGeoVolume}, ::Int32)::Nothing


""" Gsord(this::ByRef1{TGeoVolume}, ::Int32)

# Wrapper of void TGeoVolume::InvisibleAll(Bool_t)
@trydoc raw"""
    InvisibleAll(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Make volume and each of it daughters (in)visible.

""" InvisibleAll(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of TH2F * TGeoVolume::LegoPlot(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    LegoPlot(this::ByRef1{TGeoVolume}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})::CxxPtr1{TH2F}
Generate a lego plot fot the top volume, according to option.

""" LegoPlot(this::ByRef1{TGeoVolume}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})

# Wrapper of void TGeoVolume::MakeCopyNodes(const TGeoVolume *)
@trydoc raw"""
    MakeCopyNodes(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})::Nothing
make a new list of nodes and copy all nodes of other volume inside

""" MakeCopyNodes(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})

# Wrapper of TGeoVolume * TGeoVolume::MakeCopyVolume(TGeoShape *)
@trydoc raw"""
    MakeCopyVolume(this::ByRef1{TGeoVolume}, newshape::ByPtr1{TGeoShape})::CxxPtr1{TGeoVolume}
make a copy of this volume build a volume with same name, shape and medium

""" MakeCopyVolume(this::ByRef1{TGeoVolume}, newshape::ByPtr1{TGeoShape})

# Wrapper of Bool_t TGeoVolume::OptimizeVoxels()
@trydoc raw"""
    OptimizeVoxels(this::ByRef1{TGeoVolume})::Bool
Perform an extensive sampling to find which type of voxelization is most efficient.

""" OptimizeVoxels(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
paint volume

""" Paint(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::RandomPoints(Int_t, Option_t *)
@trydoc raw"""
    RandomPoints(this::ByRef1{TGeoVolume}, npoints::Int32, option::ByCopy{String})::Nothing
Draw random points in the bounding box of this volume.

""" RandomPoints(this::ByRef1{TGeoVolume}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TGeoVolume::RandomRays(Int_t, Double_t, Double_t, Double_t, const char *, Bool_t)
@trydoc raw"""
    RandomRays(this::ByRef1{TGeoVolume}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)::Nothing
Random raytracing method.

""" RandomRays(this::ByRef1{TGeoVolume}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)

# Wrapper of void TGeoVolume::Raytrace(Bool_t)
@trydoc raw"""
    Raytrace(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Draw this volume with current settings and perform raytracing in the pad.

""" Raytrace(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::RegisterYourself(Option_t *)
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
Register the volume and all materials/media/matrices/shapes to the manager.

""" RegisterYourself(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::Release()
@trydoc raw"""
    Release(this::ByRef1{TGeoVolume})::Nothing


""" Release(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::RemoveNode(TGeoNode *)
@trydoc raw"""
    RemoveNode(this::ByRef1{TGeoVolume}, node::ByPtr1{TGeoNode})::Nothing
Remove an existing daughter.

""" RemoveNode(this::ByRef1{TGeoVolume}, node::ByPtr1{TGeoNode})

# Wrapper of TGeoNode * TGeoVolume::ReplaceNode(TGeoNode *, TGeoShape *, TGeoMatrix *, TGeoMedium *)
@trydoc raw"""
    ReplaceNode(this::ByRef1{TGeoVolume}, nodeorig::ByPtr1{TGeoNode}, newshape::ByPtr1{TGeoShape}, newpos::ByPtr1{TGeoMatrix}, newmed::ByPtr1{TGeoMedium})::CxxPtr1{TGeoNode}
Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium.
Not allowed for positioned assemblies. For division cells, the new shape/matrix are ignored.
""" ReplaceNode(this::ByRef1{TGeoVolume}, nodeorig::ByPtr1{TGeoNode}, newshape::ByPtr1{TGeoShape}, newpos::ByPtr1{TGeoMatrix}, newmed::ByPtr1{TGeoMedium})

# Wrapper of void TGeoVolume::ReplayCreation(const TGeoVolume *)
@trydoc raw"""
    ReplayCreation(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})::Nothing
Recreate the content of the other volume without pointer copying.
Voxels are ignored and supposed to be created in a later step via Voxelize.
""" ReplayCreation(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})

# Wrapper of void TGeoVolume::ResetTransparency(Char_t)
@trydoc raw"""
    ResetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)::Nothing


""" ResetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)

# Wrapper of void TGeoVolume::SelectVolume(Bool_t)
@trydoc raw"""
    SelectVolume(this::ByRef1{TGeoVolume}, clear::Bool)::Nothing
Select this volume as matching an arbitrary criteria.
The volume is added to a static list and the flag [TGeoVolume!kVolumeSelected](@ref) is set. All flags need to be reset at the theend by calling the method with CLEAR=true. This will also clear the list.
""" SelectVolume(this::ByRef1{TGeoVolume}, clear::Bool)

# Wrapper of void TGeoVolume::SetActiveDaughters(Bool_t)
@trydoc raw"""
    SetActiveDaughters(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetActiveDaughters(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetActivity(Bool_t)
@trydoc raw"""
    SetActivity(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetActivity(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetAdded()
@trydoc raw"""
    SetAdded(this::ByRef1{TGeoVolume})::Nothing


""" SetAdded(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetAsTopVolume()
@trydoc raw"""
    SetAsTopVolume(this::ByRef1{TGeoVolume})::Nothing
Set this volume as the TOP one (the whole geometry starts from here)

""" SetAsTopVolume(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetAttVisibility(Bool_t)
@trydoc raw"""
    SetAttVisibility(this::ByRef1{TGeoVolume}, vis::Bool)::Nothing


""" SetAttVisibility(this::ByRef1{TGeoVolume}, vis::Bool)

# Wrapper of void TGeoVolume::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoVolume}, x::Float64, y::Float64, z::Float64)::Nothing
Set the current tracking point.

""" SetCurrentPoint(this::ByRef1{TGeoVolume}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoVolume::SetCylVoxels(Bool_t)
@trydoc raw"""
    SetCylVoxels(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetCylVoxels(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetField(TObject *)
@trydoc raw"""
    SetField(this::ByRef1{TGeoVolume}, field::ByPtr1{TObject})::Nothing


""" SetField(this::ByRef1{TGeoVolume}, field::ByPtr1{TObject})

# Wrapper of void TGeoVolume::SetFinder(TGeoPatternFinder *)
@trydoc raw"""
    SetFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoPatternFinder})::Nothing


""" SetFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoPatternFinder})

# Wrapper of void TGeoVolume::SetFWExtension(TGeoExtension *)
@trydoc raw"""
    SetFWExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})::Nothing
Connect framework defined extension to the volume.
The volume "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for the use by TGeo and the users should NOT connect extensions using this method
""" SetFWExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoVolume::SetInvisible()
@trydoc raw"""
    SetInvisible(this::ByRef1{TGeoVolume})::Nothing


""" SetInvisible(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TGeoVolume}, lcolor::Int16)::Nothing
Set the line color.

""" SetLineColor(this::ByRef1{TGeoVolume}, lcolor::Int16)

# Wrapper of void TGeoVolume::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TGeoVolume}, lstyle::Int16)::Nothing
Set the line style.

""" SetLineStyle(this::ByRef1{TGeoVolume}, lstyle::Int16)

# Wrapper of void TGeoVolume::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TGeoVolume}, lwidth::Int16)::Nothing
Set the line width.

""" SetLineWidth(this::ByRef1{TGeoVolume}, lwidth::Int16)

# Wrapper of void TGeoVolume::SetMedium(TGeoMedium *)
@trydoc raw"""
    SetMedium(this::ByRef1{TGeoVolume}, medium::ByPtr1{TGeoMedium})::Nothing


""" SetMedium(this::ByRef1{TGeoVolume}, medium::ByPtr1{TGeoMedium})

# Wrapper of void TGeoVolume::SetNodes(TObjArray *)
@trydoc raw"""
    SetNodes(this::ByRef1{TGeoVolume}, nodes::ByPtr1{TObjArray})::Nothing


""" SetNodes(this::ByRef1{TGeoVolume}, nodes::ByPtr1{TObjArray})

# Wrapper of void TGeoVolume::SetNtotal(Int_t)
@trydoc raw"""
    SetNtotal(this::ByRef1{TGeoVolume}, ntotal::Int32)::Nothing


""" SetNtotal(this::ByRef1{TGeoVolume}, ntotal::Int32)

# Wrapper of void TGeoVolume::SetNumber(Int_t)
@trydoc raw"""
    SetNumber(this::ByRef1{TGeoVolume}, number::Int32)::Nothing


""" SetNumber(this::ByRef1{TGeoVolume}, number::Int32)

# Wrapper of void TGeoVolume::SetOption(const char *)
@trydoc raw"""
    SetOption(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
Set the current options (none implemented)

""" SetOption(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::SetOverlappingCandidate(Bool_t)
@trydoc raw"""
    SetOverlappingCandidate(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetOverlappingCandidate(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetReplicated()
@trydoc raw"""
    SetReplicated(this::ByRef1{TGeoVolume})::Nothing


""" SetReplicated(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetShape(const TGeoShape *)
@trydoc raw"""
    SetShape(this::ByRef1{TGeoVolume}, shape::ByConstPtr1{TGeoShape})::Nothing
set the shape associated with this volume

""" SetShape(this::ByRef1{TGeoVolume}, shape::ByConstPtr1{TGeoShape})

# Wrapper of void TGeoVolume::SetTransparency(Char_t)
@trydoc raw"""
    SetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)::Nothing


""" SetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)

# Wrapper of void TGeoVolume::SetUserExtension(TGeoExtension *)
@trydoc raw"""
    SetUserExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})::Nothing
Connect user-defined extension to the volume.
The volume "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for user extensions and is guaranteed not to be used by TGeo
""" SetUserExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoVolume::SetVisContainers(Bool_t)
@trydoc raw"""
    SetVisContainers(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Set visibility for containers.

""" SetVisContainers(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoVolume}, vis::Bool)::Nothing
set visibility of this volume

""" SetVisibility(this::ByRef1{TGeoVolume}, vis::Bool)

# Wrapper of void TGeoVolume::SetVisLeaves(Bool_t)
@trydoc raw"""
    SetVisLeaves(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Set visibility for leaves.

""" SetVisLeaves(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetVisOnly(Bool_t)
@trydoc raw"""
    SetVisOnly(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Set visibility for leaves.

""" SetVisOnly(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetVoxelFinder(TGeoVoxelFinder *)
@trydoc raw"""
    SetVoxelFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoVoxelFinder})::Nothing


""" SetVoxelFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoVoxelFinder})

# Wrapper of void TGeoVolume::SortNodes()
@trydoc raw"""
    SortNodes(this::ByRef1{TGeoVolume})::Nothing
sort nodes by decreasing volume of the bounding box.
ONLY nodes comes first, then overlapping nodes and finally division nodes.
""" SortNodes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::UnmarkSaved()
@trydoc raw"""
    UnmarkSaved(this::ByRef1{TGeoVolume})::Nothing
Reset SavePrimitive bits.

""" UnmarkSaved(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::VisibleDaughters(Bool_t)
@trydoc raw"""
    VisibleDaughters(this::ByRef1{TGeoVolume}, vis::Bool)::Nothing
set visibility for daughters

""" VisibleDaughters(this::ByRef1{TGeoVolume}, vis::Bool)

# Wrapper of void TGeoVolume::Voxelize(Option_t *)
@trydoc raw"""
    Voxelize(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
build the voxels for this volume

""" Voxelize(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of Double_t TGeoVolume::Weight(Double_t, Option_t *)
@trydoc raw"""
    Weight(this::ByRef1{TGeoVolume}, precision::Float64, option::ByCopy{String})::Float64
Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.
Option can contain : v - verbose, a - analytical (default)
""" Weight(this::ByRef1{TGeoVolume}, precision::Float64, option::ByCopy{String})

# Wrapper of void TGeoBBox::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoBBox})::Nothing
Compute bounding box - nothing to do in this case.

""" ComputeBBox(this::ByRef1{TGeoBBox})

# Wrapper of void TGeoBBox::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Computes normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoBBox::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoBBox::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoBBox}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each corner.

""" DistancetoPrimitive(this::ByRef1{TGeoBBox}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoBBox::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoBBox}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this box shape belonging to volume "voldiv" into ndiv equal volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume. In case a wrong division axis is supplied, returns pointer to volume to be divided.
""" Divide(this::ByRef1{TGeoBBox}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoBBox::SetBoxDimensions(Double_t, Double_t, Double_t, Double_t *)
@trydoc raw"""
    SetBoxDimensions(this::ByRef1{TGeoBBox}, dx::Float64, dy::Float64, dz::Float64, origin::ByPtr2{Float64})::Nothing
Set parameters of the box.

""" SetBoxDimensions(this::ByRef1{TGeoBBox}, dx::Float64, dy::Float64, dz::Float64, origin::ByPtr2{Float64})

# Wrapper of void TGeoBBox::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoBBox}, param::ByPtr2{Float64})::Nothing
Set dimensions based on the array of parameters param[0] - half-length in x param[1] - half-length in y param[2] - half-length in z.

""" SetDimensions(this::ByRef1{TGeoBBox}, param::ByPtr2{Float64})

# Wrapper of void TGeoArb8::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoArb8})::Nothing
Computes bounding box for an Arb8 shape.

""" ComputeBBox(this::ByRef1{TGeoArb8})

# Wrapper of void TGeoArb8::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoArb8::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoArb8::ComputeTwist()
@trydoc raw"""
    ComputeTwist(this::ByRef1{TGeoArb8})::Nothing
Computes tangents of twist angles (angles between projections on XY plane of corresponding -dz +dz edges).
Computes also if the vertices are defined clockwise or anti-clockwise.
""" ComputeTwist(this::ByRef1{TGeoArb8})

# Wrapper of TGeoVolume * TGeoArb8::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoArb8}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this shape along one axis.

""" Divide(this::ByRef1{TGeoArb8}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t * TGeoArb8::GetVertices()
@trydoc raw"""
    GetVertices(this::ByRef1{TGeoArb8})::CxxPtr2{Float64}


""" GetVertices(this::ByRef1{TGeoArb8})

# Wrapper of void TGeoArb8::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoArb8}, param::ByPtr2{Float64})::Nothing
Set all arb8 params in one step.
param[0] = dz param[1] = x0 param[2] = y0 ...
""" SetDimensions(this::ByRef1{TGeoArb8}, param::ByPtr2{Float64})

# Wrapper of void TGeoArb8::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoArb8}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoArb8}, dz::Float64)

# Wrapper of void TGeoArb8::SetVertex(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetVertex(this::ByRef1{TGeoArb8}, vnum::Int32, x::Float64, y::Float64)::Nothing
Set values for a given vertex.

""" SetVertex(this::ByRef1{TGeoArb8}, vnum::Int32, x::Float64, y::Float64)

# Wrapper of TGeoVolume * TGeoTrap::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTrap}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this trapezoid shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Only Z divisions are supported. For Z divisions just return the pointer to the volume to be divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTrap}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoTrap::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTrap}, param::ByPtr2{Float64})::Nothing
Set all arb8 params in one step.
- param[0] = dz
- param[1] = theta
- param[2] = phi
- param[3] = h1
- param[4] = bl1
- param[5] = tl1
- param[6] = alpha1
- param[7] = h2
- param[8] = bl2
- param[9] = tl2
- param[10] = alpha2
""" SetDimensions(this::ByRef1{TGeoTrap}, param::ByPtr2{Float64})

# Wrapper of void TGeoGtra::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoGtra}, param::ByPtr2{Float64})::Nothing
Set all arb8 params in one step.
- param[0] = dz
- param[1] = theta
- param[2] = phi
- param[3] = h1
- param[4] = bl1
- param[5] = tl1
- param[6] = alpha1
- param[7] = h2
- param[8] = bl2
- param[9] = tl2
- param[10] = alpha2
- param[11] = twist
""" SetDimensions(this::ByRef1{TGeoGtra}, param::ByPtr2{Float64})

# Wrapper of void TGeoAtt::ResetAttBit(UInt_t)
@trydoc raw"""
    ResetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)::Nothing


""" ResetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)

# Wrapper of void TGeoAtt::SetActiveDaughters(Bool_t)
@trydoc raw"""
    SetActiveDaughters(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing


""" SetActiveDaughters(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetActivity(Bool_t)
@trydoc raw"""
    SetActivity(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing


""" SetActivity(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetAttBit(UInt_t)
@trydoc raw"""
    SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)::Nothing


""" SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)

# Wrapper of void TGeoAtt::SetAttBit(UInt_t, Bool_t)
@trydoc raw"""
    SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32, set::Bool)::Nothing


""" SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32, set::Bool)

# Wrapper of void TGeoAtt::SetOptimization(Option_t *)
@trydoc raw"""
    SetOptimization(this::ByRef1{TGeoAtt}, option::ByCopy{String})::Nothing
Set optimization flags.

""" SetOptimization(this::ByRef1{TGeoAtt}, option::ByCopy{String})

# Wrapper of void TGeoAtt::SetVisBranch()
@trydoc raw"""
    SetVisBranch(this::ByRef1{TGeoAtt})::Nothing
Set branch type visibility.

""" SetVisBranch(this::ByRef1{TGeoAtt})

# Wrapper of void TGeoAtt::SetVisContainers(Bool_t)
@trydoc raw"""
    SetVisContainers(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing
Set branch type visibility.

""" SetVisContainers(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisDaughters(Bool_t)
@trydoc raw"""
    SetVisDaughters(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Set visibility for the daughters.

""" SetVisDaughters(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoAtt::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Set visibility for this object.

""" SetVisibility(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoAtt::SetVisLeaves(Bool_t)
@trydoc raw"""
    SetVisLeaves(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing
Set branch type visibility.

""" SetVisLeaves(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisOnly(Bool_t)
@trydoc raw"""
    SetVisOnly(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing
Set branch type visibility.

""" SetVisOnly(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisRaytrace(Bool_t)
@trydoc raw"""
    SetVisRaytrace(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing


""" SetVisRaytrace(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisStreamed(Bool_t)
@trydoc raw"""
    SetVisStreamed(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Mark attributes as "streamed to file".

""" SetVisStreamed(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoAtt::SetVisTouched(Bool_t)
@trydoc raw"""
    SetVisTouched(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Mark visualization attributes as "modified".

""" SetVisTouched(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoBoolNode::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoBoolNode}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing


""" ComputeBBox(this::ByRef1{TGeoBoolNode}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoBoolNode::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing


""" ComputeNormal(this::ByRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoBoolNode::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoBoolNode}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoBoolNode}, nthreads::Int32)

# Wrapper of Int_t TGeoBoolNode::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoBoolNode}, px::Int32, py::Int32)::Int32


""" DistanceToPrimitive(this::ByRef1{TGeoBoolNode}, px::Int32, py::Int32)

# Wrapper of Int_t TGeoBoolNode::GetNpoints()
@trydoc raw"""
    GetNpoints(this::ByRef1{TGeoBoolNode})::Int32


""" GetNpoints(this::ByRef1{TGeoBoolNode})

# Wrapper of void TGeoBoolNode::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoBoolNode}, option::ByCopy{String})::Nothing
Special schema for feeding the 3D buffers to the painter client.

""" Paint(this::ByRef1{TGeoBoolNode}, option::ByCopy{String})

# Wrapper of void TGeoBoolNode::RegisterMatrices()
@trydoc raw"""
    RegisterMatrices(this::ByRef1{TGeoBoolNode})::Nothing
Register all matrices of the boolean node and descendents.

""" RegisterMatrices(this::ByRef1{TGeoBoolNode})

# Wrapper of Bool_t TGeoBoolNode::ReplaceMatrix(TGeoMatrix *, TGeoMatrix *)
@trydoc raw"""
    ReplaceMatrix(this::ByRef1{TGeoBoolNode}, mat::ByPtr1{TGeoMatrix}, newmat::ByPtr1{TGeoMatrix})::Bool
Replace one of the matrices.
Does not work with [TGeoIdentity](@ref). Returns true if replacement was successful.
""" ReplaceMatrix(this::ByRef1{TGeoBoolNode}, mat::ByPtr1{TGeoMatrix}, newmat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoBoolNode::SetSelected(Int_t)
@trydoc raw"""
    SetSelected(this::ByRef1{TGeoBoolNode}, sel::Int32)::Nothing
Set the selected branch.

""" SetSelected(this::ByRef1{TGeoBoolNode}, sel::Int32)

# Wrapper of void TGeoUnion::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoUnion}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing
Compute bounding box corresponding to a union of two shapes.

""" ComputeBBox(this::ByRef1{TGeoUnion}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoUnion::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0.

""" ComputeNormal(this::ByRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Int_t TGeoUnion::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoUnion}, px::Int32, py::Int32)::Int32
Compute minimum distance to shape vertices.

""" DistanceToPrimitive(this::ByRef1{TGeoUnion}, px::Int32, py::Int32)

# Wrapper of Int_t TGeoUnion::GetNpoints()
@trydoc raw"""
    GetNpoints(this::ByRef1{TGeoUnion})::Int32
Returns number of vertices for the composite shape described by this union.

""" GetNpoints(this::ByRef1{TGeoUnion})

# Wrapper of void TGeoUnion::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoUnion}, option::ByCopy{String})::Nothing
Paint method.

""" Paint(this::ByRef1{TGeoUnion}, option::ByCopy{String})

# Wrapper of void TGeoIntersection::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoIntersection}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing
Compute bounding box corresponding to a intersection of two shapes.

""" ComputeBBox(this::ByRef1{TGeoIntersection}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoIntersection::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0.

""" ComputeNormal(this::ByRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Int_t TGeoIntersection::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoIntersection}, px::Int32, py::Int32)::Int32
Compute minimum distance to shape vertices.

""" DistanceToPrimitive(this::ByRef1{TGeoIntersection}, px::Int32, py::Int32)

# Wrapper of Int_t TGeoIntersection::GetNpoints()
@trydoc raw"""
    GetNpoints(this::ByRef1{TGeoIntersection})::Int32
Returns number of vertices for the composite shape described by this intersection.

""" GetNpoints(this::ByRef1{TGeoIntersection})

# Wrapper of void TGeoIntersection::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoIntersection}, option::ByCopy{String})::Nothing
Paint method.

""" Paint(this::ByRef1{TGeoIntersection}, option::ByCopy{String})

# Wrapper of void TGeoSubtraction::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoSubtraction}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing
Compute bounding box corresponding to a subtraction of two shapes.

""" ComputeBBox(this::ByRef1{TGeoSubtraction}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoSubtraction::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0.

""" ComputeNormal(this::ByRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Int_t TGeoSubtraction::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoSubtraction}, px::Int32, py::Int32)::Int32
Compute minimum distance to shape vertices.

""" DistanceToPrimitive(this::ByRef1{TGeoSubtraction}, px::Int32, py::Int32)

# Wrapper of Int_t TGeoSubtraction::GetNpoints()
@trydoc raw"""
    GetNpoints(this::ByRef1{TGeoSubtraction})::Int32
Returns number of vertices for the composite shape described by this subtraction.

""" GetNpoints(this::ByRef1{TGeoSubtraction})

# Wrapper of void TGeoSubtraction::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoSubtraction}, option::ByCopy{String})::Nothing
Paint method.

""" Paint(this::ByRef1{TGeoSubtraction}, option::ByCopy{String})

# Wrapper of void TGeoHMatrix::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoHMatrix}, option::ByCopy{String})::Nothing
clear the data for this matrix

""" Clear(this::ByRef1{TGeoHMatrix}, option::ByCopy{String})

# Wrapper of void TGeoHMatrix::CopyFrom(const TGeoMatrix *)
@trydoc raw"""
    CopyFrom(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})::Nothing
Fast copy method.

""" CopyFrom(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::FastRotZ(const Double_t *)
@trydoc raw"""
    FastRotZ(this::ByRef1{TGeoHMatrix}, sincos::ByConstPtr2{Float64})::Nothing
Perform a rotation about Z having the sine/cosine of the rotation angle.

""" FastRotZ(this::ByRef1{TGeoHMatrix}, sincos::ByConstPtr2{Float64})

# Wrapper of Double_t * TGeoHMatrix::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByRef1{TGeoHMatrix})::CxxPtr2{Float64}


""" GetRotationMatrix(this::ByRef1{TGeoHMatrix})

# Wrapper of Double_t * TGeoHMatrix::GetScale()
@trydoc raw"""
    GetScale(this::ByRef1{TGeoHMatrix})::CxxPtr2{Float64}


""" GetScale(this::ByRef1{TGeoHMatrix})

# Wrapper of Double_t * TGeoHMatrix::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByRef1{TGeoHMatrix})::CxxPtr2{Float64}


""" GetTranslation(this::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoHMatrix::Multiply(const TGeoMatrix &)
@trydoc raw"""
    Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstRef1{TGeoMatrix})::Nothing


""" Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::Multiply(const TGeoMatrix *)
@trydoc raw"""
    Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstPtr1{TGeoMatrix})::Nothing
multiply to the right with an other transformation if right is identity matrix, just return

""" Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::MultiplyLeft(const TGeoMatrix &)
@trydoc raw"""
    MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstRef1{TGeoMatrix})::Nothing


""" MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::MultiplyLeft(const TGeoMatrix *)
@trydoc raw"""
    MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstPtr1{TGeoMatrix})::Nothing
multiply to the left with an other transformation if right is identity matrix, just return

""" MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstPtr1{TGeoMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator*=(const TGeoMatrix &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoHMatrix}
Composition.

""" mult!(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator=(const TGeoHMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoHMatrix})::CxxRef1{TGeoHMatrix}


""" assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoHMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoHMatrix}
assignment

""" assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator=(const TGeoMatrix *)
@trydoc raw"""
    assign(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})::CxxRef1{TGeoHMatrix}
assignment

""" assign(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoHMatrix::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoHMatrix::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoHMatrix::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoHMatrix}, angle::Float64)::Nothing
Rotate about X axis with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoHMatrix}, angle::Float64)

# Wrapper of void TGeoHMatrix::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoHMatrix}, angle::Float64)::Nothing
Rotate about Y axis with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoHMatrix}, angle::Float64)

# Wrapper of void TGeoHMatrix::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoHMatrix}, angle::Float64)::Nothing
Rotate about Z axis with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoHMatrix}, angle::Float64)

# Wrapper of void TGeoHMatrix::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoHMatrix}, dx::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoHMatrix}, dx::Float64)

# Wrapper of void TGeoHMatrix::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoHMatrix}, dy::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoHMatrix}, dy::Float64)

# Wrapper of void TGeoHMatrix::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoHMatrix}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoHMatrix}, dz::Float64)

# Wrapper of void TGeoHMatrix::SetRotation(const Double_t *)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoHMatrix}, matrix::ByConstPtr2{Float64})::Nothing


""" SetRotation(this::ByRef1{TGeoHMatrix}, matrix::ByConstPtr2{Float64})

# Wrapper of void TGeoHMatrix::SetScale(const Double_t *)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoHMatrix}, scale::ByConstPtr2{Float64})::Nothing


""" SetScale(this::ByRef1{TGeoHMatrix}, scale::ByConstPtr2{Float64})

# Wrapper of void TGeoHMatrix::SetTranslation(const Double_t *)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoHMatrix}, vect::ByConstPtr2{Float64})::Nothing


""" SetTranslation(this::ByRef1{TGeoHMatrix}, vect::ByConstPtr2{Float64})

# Wrapper of void TGeoTranslation::Add(const TGeoTranslation *)
@trydoc raw"""
    Add(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})::Nothing
Adding a translation to this one.

""" Add(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})

# Wrapper of TGeoTranslation & TGeoTranslation::operator*=(const TGeoTranslation &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})::CxxRef1{TGeoTranslation}
Translation composition.

""" mult!(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})

# Wrapper of TGeoTranslation & TGeoTranslation::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoTranslation}, matrix::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoTranslation}
Assignment from a general matrix.

""" assign(this::ByRef1{TGeoTranslation}, matrix::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoTranslation & TGeoTranslation::operator=(const TGeoTranslation &)
@trydoc raw"""
    assign(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})::CxxRef1{TGeoTranslation}


""" assign(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})

# Wrapper of void TGeoTranslation::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoTranslation}, angle::Float64)::Nothing
Rotate about X axis of the master frame with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoTranslation}, angle::Float64)

# Wrapper of void TGeoTranslation::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoTranslation}, angle::Float64)::Nothing
Rotate about Y axis of the master frame with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoTranslation}, angle::Float64)

# Wrapper of void TGeoTranslation::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoTranslation}, angle::Float64)::Nothing
Rotate about Z axis of the master frame with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoTranslation}, angle::Float64)

# Wrapper of void TGeoTranslation::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoTranslation}, dx::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoTranslation}, dx::Float64)

# Wrapper of void TGeoTranslation::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoTranslation}, dy::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoTranslation}, dy::Float64)

# Wrapper of void TGeoTranslation::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoTranslation}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoTranslation}, dz::Float64)

# Wrapper of void TGeoTranslation::SetTranslation(const TGeoMatrix &)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoMatrix})::Nothing
Set translation components.

""" SetTranslation(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoTranslation::SetTranslation(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoTranslation}, dx::Float64, dy::Float64, dz::Float64)::Nothing
Set translation components.

""" SetTranslation(this::ByRef1{TGeoTranslation}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of void TGeoTranslation::Subtract(const TGeoTranslation *)
@trydoc raw"""
    Subtract(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})::Nothing
Subtracting a translation from this one.

""" Subtract(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})

# Wrapper of void TGeoRotation::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoRotation}, option::ByCopy{String})::Nothing
reset data members

""" Clear(this::ByRef1{TGeoRotation}, option::ByCopy{String})

# Wrapper of void TGeoRotation::FastRotZ(const Double_t *)
@trydoc raw"""
    FastRotZ(this::ByRef1{TGeoRotation}, sincos::ByConstPtr2{Float64})::Nothing
Perform a rotation about Z having the sine/cosine of the rotation angle.

""" FastRotZ(this::ByRef1{TGeoRotation}, sincos::ByConstPtr2{Float64})

# Wrapper of void TGeoRotation::MultiplyBy(const TGeoRotation *, Bool_t)
@trydoc raw"""
    MultiplyBy(this::ByRef1{TGeoRotation}, rot::ByConstPtr1{TGeoRotation}, after::Bool)::Nothing
Multiply this rotation with the one specified by ROT.
- after=TRUE (default): THIS*ROT
- after=FALSE : ROT*THIS
""" MultiplyBy(this::ByRef1{TGeoRotation}, rot::ByConstPtr1{TGeoRotation}, after::Bool)

# Wrapper of TGeoRotation & TGeoRotation::operator*=(const TGeoRotation &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})::CxxRef1{TGeoRotation}
Composition.

""" mult!(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})

# Wrapper of TGeoRotation & TGeoRotation::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoRotation}
Assignment from a general matrix.

""" assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoRotation & TGeoRotation::operator=(const TGeoRotation &)
@trydoc raw"""
    assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})::CxxRef1{TGeoRotation}


""" assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoRotation::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoRotation::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoRotation::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoRotation::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoRotation}, angle::Float64)::Nothing
Rotate about X axis of the master frame with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoRotation}, angle::Float64)

# Wrapper of void TGeoRotation::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoRotation}, angle::Float64)::Nothing
Rotate about Y axis of the master frame with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoRotation}, angle::Float64)

# Wrapper of void TGeoRotation::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoRotation}, angle::Float64)::Nothing
Rotate about Z axis of the master frame with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoRotation}, angle::Float64)

# Wrapper of void TGeoRotation::SetAngles(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetAngles(this::ByRef1{TGeoRotation}, phi::Float64, theta::Float64, psi::Float64)::Nothing
Set matrix elements according to Euler angles.
Phi is the rotation angle about Z axis and is done first, theta is the rotation about new X and is done second, psi is the rotation angle about new Z and is done third. All angles are in degrees.
""" SetAngles(this::ByRef1{TGeoRotation}, phi::Float64, theta::Float64, psi::Float64)

# Wrapper of void TGeoRotation::SetAngles(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetAngles(this::ByRef1{TGeoRotation}, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)::Nothing
Set matrix elements in the GEANT3 way.

""" SetAngles(this::ByRef1{TGeoRotation}, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)

# Wrapper of void TGeoRotation::SetMatrix(const Double_t *)
@trydoc raw"""
    SetMatrix(this::ByRef1{TGeoRotation}, rot::ByConstPtr2{Float64})::Nothing


""" SetMatrix(this::ByRef1{TGeoRotation}, rot::ByConstPtr2{Float64})

# Wrapper of void TGeoRotation::SetRotation(const TGeoMatrix &)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})::Nothing
Copy rotation elements from other rotation matrix.

""" SetRotation(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoScale & TGeoScale::operator*=(const TGeoScale &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})::CxxRef1{TGeoScale}
Scale composition.

""" mult!(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})

# Wrapper of TGeoScale & TGeoScale::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoScale}
Assignment from a general matrix.

""" assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoScale & TGeoScale::operator=(const TGeoScale &)
@trydoc raw"""
    assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})::CxxRef1{TGeoScale}


""" assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})

# Wrapper of void TGeoScale::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoScale::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoScale::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoScale::SetScale(const TGeoMatrix &)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})::Nothing
Set scale from other transformation.

""" SetScale(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoScale::SetScale(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoScale}, sx::Float64, sy::Float64, sz::Float64)::Nothing
scale setter

""" SetScale(this::ByRef1{TGeoScale}, sx::Float64, sy::Float64, sz::Float64)

# Wrapper of void TGeoCombiTrans::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoCombiTrans}, option::ByCopy{String})::Nothing
Reset translation/rotation to identity.

""" Clear(this::ByRef1{TGeoCombiTrans}, option::ByCopy{String})

# Wrapper of void TGeoCombiTrans::Multiply(const TGeoMatrix *)
@trydoc raw"""
    Multiply(this::ByRef1{TGeoCombiTrans}, right::ByConstPtr1{TGeoMatrix})::Nothing
multiply to the right with an other transformation if right is identity matrix, just return

""" Multiply(this::ByRef1{TGeoCombiTrans}, right::ByConstPtr1{TGeoMatrix})

# Wrapper of TGeoCombiTrans & TGeoCombiTrans::operator*=(const TGeoMatrix &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoCombiTrans}
Composition.

""" mult!(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoCombiTrans & TGeoCombiTrans::operator=(const TGeoCombiTrans &)
@trydoc raw"""
    assign(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoCombiTrans})::CxxRef1{TGeoCombiTrans}


""" assign(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoCombiTrans})

# Wrapper of TGeoCombiTrans & TGeoCombiTrans::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoCombiTrans}, matrix::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoCombiTrans}
Assignment operator with generic matrix.

""" assign(this::ByRef1{TGeoCombiTrans}, matrix::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoCombiTrans::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoCombiTrans::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoCombiTrans::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoCombiTrans::RegisterYourself()
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoCombiTrans})::Nothing
Register the matrix in the current manager, which will become the owner.

""" RegisterYourself(this::ByRef1{TGeoCombiTrans})

# Wrapper of void TGeoCombiTrans::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoCombiTrans}, angle::Float64)::Nothing
Rotate about X axis with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoCombiTrans}, angle::Float64)

# Wrapper of void TGeoCombiTrans::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoCombiTrans}, angle::Float64)::Nothing
Rotate about Y axis with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoCombiTrans}, angle::Float64)

# Wrapper of void TGeoCombiTrans::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoCombiTrans}, angle::Float64)::Nothing
Rotate about Z axis with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoCombiTrans}, angle::Float64)

# Wrapper of void TGeoCombiTrans::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoCombiTrans}, dx::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoCombiTrans}, dx::Float64)

# Wrapper of void TGeoCombiTrans::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoCombiTrans}, dy::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoCombiTrans}, dy::Float64)

# Wrapper of void TGeoCombiTrans::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoCombiTrans}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoCombiTrans}, dz::Float64)

# Wrapper of void TGeoCombiTrans::SetRotation(const TGeoRotation &)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoRotation})::Nothing
Copy the rotation from another one.

""" SetRotation(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoCombiTrans::SetRotation(const TGeoRotation *)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoCombiTrans}, rot::ByConstPtr1{TGeoRotation})::Nothing
Assign a foreign rotation to the combi. The rotation is NOT owned by this.

""" SetRotation(this::ByRef1{TGeoCombiTrans}, rot::ByConstPtr1{TGeoRotation})

# Wrapper of void TGeoCombiTrans::SetTranslation(const TGeoTranslation &)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoCombiTrans}, tr::ByConstRef1{TGeoTranslation})::Nothing
copy the translation component

""" SetTranslation(this::ByRef1{TGeoCombiTrans}, tr::ByConstRef1{TGeoTranslation})

# Wrapper of void TGeoCombiTrans::SetTranslation(Double_t *)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoCombiTrans}, vect::ByPtr2{Float64})::Nothing
set the translation component

""" SetTranslation(this::ByRef1{TGeoCombiTrans}, vect::ByPtr2{Float64})

# Wrapper of void TGeoCombiTrans::SetTranslation(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoCombiTrans}, dx::Float64, dy::Float64, dz::Float64)::Nothing
set the translation component

""" SetTranslation(this::ByRef1{TGeoCombiTrans}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of void TGeoGenTrans::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoGenTrans}, option::ByCopy{String})::Nothing
clear the fields of this transformation

""" Clear(this::ByRef1{TGeoGenTrans}, option::ByCopy{String})

# Wrapper of Bool_t TGeoGenTrans::Normalize()
@trydoc raw"""
    Normalize(this::ByRef1{TGeoGenTrans})::Bool
A scale transformation should be normalized by sx*sy*sz factor.

""" Normalize(this::ByRef1{TGeoGenTrans})

# Wrapper of void TGeoGenTrans::SetScale(Double_t *)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoGenTrans}, scale::ByPtr2{Float64})::Nothing


""" SetScale(this::ByRef1{TGeoGenTrans}, scale::ByPtr2{Float64})

# Wrapper of void TGeoGenTrans::SetScale(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoGenTrans}, sx::Float64, sy::Float64, sz::Float64)::Nothing
set the scale

""" SetScale(this::ByRef1{TGeoGenTrans}, sx::Float64, sy::Float64, sz::Float64)

# Wrapper of void TGeoBranchArray::AddLevel(Int_t)
@trydoc raw"""
    AddLevel(this::ByRef1{TGeoBranchArray}, dindex::Int32)::Nothing
Add and extra daughter to the current path array. No validity check performed !

""" AddLevel(this::ByRef1{TGeoBranchArray}, dindex::Int32)

# Wrapper of void TGeoBranchArray::CleanMatrix()
@trydoc raw"""
    CleanMatrix(this::ByRef1{TGeoBranchArray})::Nothing
Garbage collect the stored matrix.

""" CleanMatrix(this::ByRef1{TGeoBranchArray})

# Wrapper of void TGeoBranchArray::CopyTo(TGeoBranchArray *)
@trydoc raw"""
    CopyTo(this::ByRef1{TGeoBranchArray}, dest::ByPtr1{TGeoBranchArray})::Nothing
Raw memcpy of the branch array content to an existing destination.

""" CopyTo(this::ByRef1{TGeoBranchArray}, dest::ByPtr1{TGeoBranchArray})

# Wrapper of void TGeoBranchArray::Init(TGeoNode **, TGeoMatrix *, Int_t)
@trydoc raw"""
    Init(this::ByRef1{TGeoBranchArray}, branch::ByPtr1{TGeoNode}, global_::ByPtr1{TGeoMatrix}, level::Int32)::Nothing
Init the branch array from an array of nodes, the global_ matrix for the path and the level.

""" Init(this::ByRef1{TGeoBranchArray}, branch::ByPtr1{TGeoNode}, global_::ByPtr1{TGeoMatrix}, level::Int32)

# Wrapper of void TGeoBranchArray::InitFromNavigator(TGeoNavigator *)
@trydoc raw"""
    InitFromNavigator(this::ByRef1{TGeoBranchArray}, nav::ByPtr1{TGeoNavigator})::Nothing
Init the branch array from current navigator state.

""" InitFromNavigator(this::ByRef1{TGeoBranchArray}, nav::ByPtr1{TGeoNavigator})

# Wrapper of TGeoBranchArray & TGeoBranchArray::operator=(const TGeoBranchArray &)
@trydoc raw"""
    assign(this::ByRef1{TGeoBranchArray}, ::ByConstRef1{TGeoBranchArray})::CxxRef1{TGeoBranchArray}
Assignment. Not valid anymore. Use [TGeoBranchArray!MakeCopy](@ref) instead.

""" assign(this::ByRef1{TGeoBranchArray}, ::ByConstRef1{TGeoBranchArray})

# Wrapper of void TGeoBranchArray::UpdateArray(size_t)
@trydoc raw"""
    UpdateArray(this::ByRef1{TGeoBranchArray}, nobj::Int64)::Nothing
Updates the internal addresses for n contiguous objects which have the same fMaxLevel Updates the internal addresses for n contiguous objects which have the same fMaxLevel.

""" UpdateArray(this::ByRef1{TGeoBranchArray}, nobj::Int64)

# Wrapper of void TGeoNode::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGeoNode}, b::ByPtr1{TBrowser})::Nothing
How-to-browse for a node.

""" Browse(this::ByRef1{TGeoNode}, b::ByPtr1{TBrowser})

# Wrapper of void TGeoNode::CheckOverlaps(Double_t, Option_t *)
@trydoc raw"""
    CheckOverlaps(this::ByRef1{TGeoNode}, ovlp::Float64, option::ByCopy{String})::Nothing
Check overlaps bigger than OVLP hierarchically, starting with this node.

""" CheckOverlaps(this::ByRef1{TGeoNode}, ovlp::Float64, option::ByCopy{String})

# Wrapper of void TGeoNode::CheckShapes()
@trydoc raw"""
    CheckShapes(this::ByRef1{TGeoNode})::Nothing
check for wrong parameters in shapes

""" CheckShapes(this::ByRef1{TGeoNode})

# Wrapper of Int_t TGeoNode::CountDaughters(Bool_t)
@trydoc raw"""
    CountDaughters(this::ByRef1{TGeoNode}, unique_volumes::Bool)::Int32
Returns the number of daughters.
Nodes pointing to same volume counted once if unique_volumes is set.
""" CountDaughters(this::ByRef1{TGeoNode}, unique_volumes::Bool)

# Wrapper of Int_t TGeoNode::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoNode}, px::Int32, py::Int32)::Int32
compute the closest distance of approach from point px,py to this node

""" DistancetoPrimitive(this::ByRef1{TGeoNode}, px::Int32, py::Int32)

# Wrapper of void TGeoNode::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoNode}, option::ByCopy{String})::Nothing
draw current node according to option

""" Draw(this::ByRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoNode::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TGeoNode}, option::ByCopy{String})::Nothing
draw only this node independently of its vis options

""" DrawOnly(this::ByRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoNode::DrawOverlaps()
@trydoc raw"""
    DrawOverlaps(this::ByRef1{TGeoNode})::Nothing
Method drawing the overlap candidates with this node.

""" DrawOverlaps(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoNode}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this volume.

""" ExecuteEvent(this::ByRef1{TGeoNode}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TGeoNode::FindNode(const TGeoNode *, Int_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoNode}, node::ByConstPtr1{TGeoNode}, level::Int32)::Int32
Search for a node within the branch of this one.

""" FindNode(this::ByRef1{TGeoNode}, node::ByConstPtr1{TGeoNode}, level::Int32)

# Wrapper of void TGeoNode::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoNode}, option::ByCopy{String})::Nothing
Paint this node and its content according to visualization settings.

""" Paint(this::ByRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoNode::SetAllInvisible()
@trydoc raw"""
    SetAllInvisible(this::ByRef1{TGeoNode})::Nothing


""" SetAllInvisible(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::SetCloned(Bool_t)
@trydoc raw"""
    SetCloned(this::ByRef1{TGeoNode}, flag::Bool)::Nothing


""" SetCloned(this::ByRef1{TGeoNode}, flag::Bool)

# Wrapper of void TGeoNode::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoNode}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoNode}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNode::SetFWExtension(TGeoExtension *)
@trydoc raw"""
    SetFWExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})::Nothing
Connect framework defined extension to the node.
The node "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for the use by TGeo and the users should NOT connect extensions using this method
""" SetFWExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoNode::SetInvisible()
@trydoc raw"""
    SetInvisible(this::ByRef1{TGeoNode})::Nothing


""" SetInvisible(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::SetMotherVolume(TGeoVolume *)
@trydoc raw"""
    SetMotherVolume(this::ByRef1{TGeoNode}, mother::ByPtr1{TGeoVolume})::Nothing


""" SetMotherVolume(this::ByRef1{TGeoNode}, mother::ByPtr1{TGeoVolume})

# Wrapper of void TGeoNode::SetNumber(Int_t)
@trydoc raw"""
    SetNumber(this::ByRef1{TGeoNode}, number::Int32)::Nothing


""" SetNumber(this::ByRef1{TGeoNode}, number::Int32)

# Wrapper of void TGeoNode::SetOverlapping(Bool_t)
@trydoc raw"""
    SetOverlapping(this::ByRef1{TGeoNode}, flag::Bool)::Nothing


""" SetOverlapping(this::ByRef1{TGeoNode}, flag::Bool)

# Wrapper of void TGeoNode::SetOverlaps(Int_t *, Int_t)
@trydoc raw"""
    SetOverlaps(this::ByRef1{TGeoNode}, ovlp::ByPtr2{Int32}, novlp::Int32)::Nothing
set the list of overlaps for this node (ovlp must be created with operator new)

""" SetOverlaps(this::ByRef1{TGeoNode}, ovlp::ByPtr2{Int32}, novlp::Int32)

# Wrapper of void TGeoNode::SetUserExtension(TGeoExtension *)
@trydoc raw"""
    SetUserExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})::Nothing
Connect user-defined extension to the node.
The node "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for user extensions and is guaranteed not to be used by TGeo
""" SetUserExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoNode::SetVirtual()
@trydoc raw"""
    SetVirtual(this::ByRef1{TGeoNode})::Nothing


""" SetVirtual(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoNode}, vis::Bool)::Nothing
Set visibility of the node (obsolete).

""" SetVisibility(this::ByRef1{TGeoNode}, vis::Bool)

# Wrapper of void TGeoNode::SetVolume(TGeoVolume *)
@trydoc raw"""
    SetVolume(this::ByRef1{TGeoNode}, volume::ByPtr1{TGeoVolume})::Nothing


""" SetVolume(this::ByRef1{TGeoNode}, volume::ByPtr1{TGeoVolume})

# Wrapper of void TGeoNode::VisibleDaughters(Bool_t)
@trydoc raw"""
    VisibleDaughters(this::ByRef1{TGeoNode}, vis::Bool)::Nothing
Set visibility of the daughters (obsolete).

""" VisibleDaughters(this::ByRef1{TGeoNode}, vis::Bool)

# Wrapper of void TGeoNavigator::BuildCache(Bool_t, Bool_t)
@trydoc raw"""
    BuildCache(this::ByRef1{TGeoNavigator}, dummy::Bool, nodeid::Bool)::Nothing
Builds the cache for physical nodes and global_ matrices.

""" BuildCache(this::ByRef1{TGeoNavigator}, dummy::Bool, nodeid::Bool)

# Wrapper of Bool_t TGeoNavigator::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TGeoNavigator}, path::ByCopy{String})::Bool
Browse the tree of nodes starting from top node according to pathname.
Changes the path accordingly. The path is changed to point to the top node in case of failure.
""" cd(this::ByRef1{TGeoNavigator}, path::ByCopy{String})

# Wrapper of void TGeoNavigator::CdDown(Int_t)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNavigator}, index::Int32)::Nothing
Make a daughter of current node current.
Can be called only with a valid daughter index (no check). Updates cache accordingly.
""" CdDown(this::ByRef1{TGeoNavigator}, index::Int32)

# Wrapper of void TGeoNavigator::CdDown(TGeoNode *)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNavigator}, node::ByPtr1{TGeoNode})::Nothing
Make a daughter of current node current.
Can be called only with a valid daughter node (no check). Updates cache accordingly.
""" CdDown(this::ByRef1{TGeoNavigator}, node::ByPtr1{TGeoNode})

# Wrapper of void TGeoNavigator::CdNext()
@trydoc raw"""
    CdNext(this::ByRef1{TGeoNavigator})::Nothing
Do a cd to the node found next by FindNextBoundary.

""" CdNext(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::CdNode(Int_t)
@trydoc raw"""
    CdNode(this::ByRef1{TGeoNavigator}, nodeid::Int32)::Nothing
Change current path to point to the node having this id.
Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)
""" CdNode(this::ByRef1{TGeoNavigator}, nodeid::Int32)

# Wrapper of void TGeoNavigator::CdTop()
@trydoc raw"""
    CdTop(this::ByRef1{TGeoNavigator})::Nothing
Make top level node the current node.
Updates the cache accordingly. Determine the overlapping state of current node.
""" CdTop(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::CdUp()
@trydoc raw"""
    CdUp(this::ByRef1{TGeoNavigator})::Nothing
Go one level up in geometry.
Updates cache accordingly. Determine the overlapping state of current node.
""" CdUp(this::ByRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::CrossBoundaryAndLocate(Bool_t, TGeoNode *)
@trydoc raw"""
    CrossBoundaryAndLocate(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode.

""" CrossBoundaryAndLocate(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByPtr1{TGeoNode})

# Wrapper of void TGeoNavigator::DoBackupState()
@trydoc raw"""
    DoBackupState(this::ByRef1{TGeoNavigator})::Nothing
Backup the current state without affecting the cache stack.

""" DoBackupState(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::DoRestoreState()
@trydoc raw"""
    DoRestoreState(this::ByRef1{TGeoNavigator})::Nothing
Restore a backed-up state without affecting the cache stack.

""" DoRestoreState(this::ByRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::FindNextBoundary(Double_t, const char *, Bool_t)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoNavigator}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)::CxxPtr1{TGeoNode}
Find distance to next boundary and store it in fStep.
Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : "Is STEPMAX a safe step ?" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.

Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly [TGeoManager!Safety()](@ref) if they want this computed for the current point.
""" FindNextBoundary(this::ByRef1{TGeoNavigator}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNextBoundaryAndStep(Double_t, Bool_t)
@trydoc raw"""
    FindNextBoundaryAndStep(this::ByRef1{TGeoNavigator}, stepmax::Float64, compsafe::Bool)::CxxPtr1{TGeoNode}
Compute distance to next boundary within STEPMAX.
If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node.
""" FindNextBoundaryAndStep(this::ByRef1{TGeoNavigator}, stepmax::Float64, compsafe::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNextDaughterBoundary(Double_t *, Double_t *, Int_t &, Bool_t)
@trydoc raw"""
    FindNextDaughterBoundary(this::ByRef1{TGeoNavigator}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)::CxxPtr1{TGeoNode}
Computes as fStep the distance to next daughter of the current volume.
The point and direction must be converted in the coordinate system of the current volume. The proposed step limit is fStep.
""" FindNextDaughterBoundary(this::ByRef1{TGeoNavigator}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNode(Bool_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoNavigator}, safe_start::Bool)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoNavigator}, safe_start::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNode(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of Double_t * TGeoNavigator::FindNormal(Bool_t)
@trydoc raw"""
    FindNormal(this::ByRef1{TGeoNavigator}, forward::Bool)::CxxPtr2{Float64}
Computes normal vector to the next surface that will be or was already crossed when propagating on a straight line from a given point/direction.
Returns the normal vector cosines in the MASTER coordinate system. The dot product of the normal and the current direction is positive defined.
""" FindNormal(this::ByRef1{TGeoNavigator}, forward::Bool)

# Wrapper of Double_t * TGeoNavigator::FindNormalFast()
@trydoc raw"""
    FindNormalFast(this::ByRef1{TGeoNavigator})::CxxPtr2{Float64}
Computes fast normal to next crossed boundary, assuming that the current point is close enough to the boundary.
Works only after calling FindNextBoundary.
""" FindNormalFast(this::ByRef1{TGeoNavigator})

# Wrapper of TGeoHMatrix * TGeoNavigator::GetHMatrix()
@trydoc raw"""
    GetHMatrix(this::ByRef1{TGeoNavigator})::CxxPtr1{TGeoHMatrix}
Return stored current matrix (global_ matrix of the next touched node).

""" GetHMatrix(this::ByRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetVirtualLevel()
@trydoc raw"""
    GetVirtualLevel(this::ByRef1{TGeoNavigator})::Int32
Find level of virtuality of current overlapping node (number of levels up having the same tracking media.

""" GetVirtualLevel(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::GotoSafeLevel()
@trydoc raw"""
    GotoSafeLevel(this::ByRef1{TGeoNavigator})::Bool
Go upwards the tree until a non-overlapping node.

""" GotoSafeLevel(this::ByRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::InitTrack(const Double_t *, const Double_t *)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of TGeoNode * TGeoNavigator::InitTrack(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of Bool_t TGeoNavigator::IsSameLocation(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    IsSameLocation(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, change::Bool)::Bool
Checks if point (x,y,z) is still in the current node.
check if this is an overlapping node
""" IsSameLocation(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, change::Bool)

# Wrapper of void TGeoNavigator::PopDummy(Int_t)
@trydoc raw"""
    PopDummy(this::ByRef1{TGeoNavigator}, ipop::Int32)::Nothing


""" PopDummy(this::ByRef1{TGeoNavigator}, ipop::Int32)

# Wrapper of Bool_t TGeoNavigator::PopPath()
@trydoc raw"""
    PopPath(this::ByRef1{TGeoNavigator})::Bool


""" PopPath(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::PopPath(Int_t)
@trydoc raw"""
    PopPath(this::ByRef1{TGeoNavigator}, index::Int32)::Bool


""" PopPath(this::ByRef1{TGeoNavigator}, index::Int32)

# Wrapper of Bool_t TGeoNavigator::PopPoint()
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoNavigator})::Bool


""" PopPoint(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::PopPoint(Int_t)
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoNavigator}, index::Int32)::Bool


""" PopPoint(this::ByRef1{TGeoNavigator}, index::Int32)

# Wrapper of Int_t TGeoNavigator::PushPath(Int_t)
@trydoc raw"""
    PushPath(this::ByRef1{TGeoNavigator}, startlevel::Int32)::Int32


""" PushPath(this::ByRef1{TGeoNavigator}, startlevel::Int32)

# Wrapper of Int_t TGeoNavigator::PushPoint(Int_t)
@trydoc raw"""
    PushPoint(this::ByRef1{TGeoNavigator}, startlevel::Int32)::Int32


""" PushPoint(this::ByRef1{TGeoNavigator}, startlevel::Int32)

# Wrapper of void TGeoNavigator::ResetAll()
@trydoc raw"""
    ResetAll(this::ByRef1{TGeoNavigator})::Nothing
Reset the navigator.

""" ResetAll(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::ResetState()
@trydoc raw"""
    ResetState(this::ByRef1{TGeoNavigator})::Nothing
Reset current state flags.

""" ResetState(this::ByRef1{TGeoNavigator})

# Wrapper of Double_t TGeoNavigator::Safety(Bool_t)
@trydoc raw"""
    Safety(this::ByRef1{TGeoNavigator}, inside::Bool)::Float64
Compute safe distance from the current point.
This represent the distance from POINT to the closest boundary.
""" Safety(this::ByRef1{TGeoNavigator}, inside::Bool)

# Wrapper of TGeoNode * TGeoNavigator::SearchNode(Bool_t, const TGeoNode *)
@trydoc raw"""
    SearchNode(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Returns the deepest node containing fPoint, which must be set a priori.
Check if parallel world navigation is enabled
""" SearchNode(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})

# Wrapper of void TGeoNavigator::SetCheckingOverlaps(Bool_t)
@trydoc raw"""
    SetCheckingOverlaps(this::ByRef1{TGeoNavigator}, flag::Bool)::Nothing


""" SetCheckingOverlaps(this::ByRef1{TGeoNavigator}, flag::Bool)

# Wrapper of void TGeoNavigator::SetCldirChecked(Double_t *)
@trydoc raw"""
    SetCldirChecked(this::ByRef1{TGeoNavigator}, dir::ByPtr2{Float64})::Nothing


""" SetCldirChecked(this::ByRef1{TGeoNavigator}, dir::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::SetCurrentDirection(const Double_t *)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoNavigator}, dir::ByConstPtr2{Float64})::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoNavigator}, dir::ByConstPtr2{Float64})

# Wrapper of void TGeoNavigator::SetCurrentDirection(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoNavigator}, nx::Float64, ny::Float64, nz::Float64)::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoNavigator}, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of void TGeoNavigator::SetCurrentPoint(const Double_t *)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64})::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoNavigator::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNavigator::SetLastPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetLastPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetLastPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNavigator::SetLastSafetyForPoint(Double_t, const Double_t *)
@trydoc raw"""
    SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, point::ByConstPtr2{Float64})::Nothing


""" SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, point::ByConstPtr2{Float64})

# Wrapper of void TGeoNavigator::SetLastSafetyForPoint(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, x::Float64, y::Float64, z::Float64)::Nothing


""" SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNavigator::SetOutside(Bool_t)
@trydoc raw"""
    SetOutside(this::ByRef1{TGeoNavigator}, flag::Bool)::Nothing


""" SetOutside(this::ByRef1{TGeoNavigator}, flag::Bool)

# Wrapper of void TGeoNavigator::SetStartSafe(Bool_t)
@trydoc raw"""
    SetStartSafe(this::ByRef1{TGeoNavigator}, flag::Bool)::Nothing


""" SetStartSafe(this::ByRef1{TGeoNavigator}, flag::Bool)

# Wrapper of void TGeoNavigator::SetStep(Double_t)
@trydoc raw"""
    SetStep(this::ByRef1{TGeoNavigator}, step::Float64)::Nothing


""" SetStep(this::ByRef1{TGeoNavigator}, step::Float64)

# Wrapper of TGeoNode * TGeoNavigator::Step(Bool_t, Bool_t)
@trydoc raw"""
    Step(this::ByRef1{TGeoNavigator}, is_geom::Bool, cross::Bool)::CxxPtr1{TGeoNode}
Make a rectiliniar step of length fStep from current point (fPoint) on current direction (fDirection).
If the step is imposed by geometry, is_geom flag must be true (default). The cross flag specifies if the boundary should be crossed in case of a geometry step (default true). Returns new node after step. Set also on boundary condition.
""" Step(this::ByRef1{TGeoNavigator}, is_geom::Bool, cross::Bool)

# Wrapper of Int_t TGeoBuilder::AddMaterial(TGeoMaterial *)
@trydoc raw"""
    AddMaterial(this::ByRef1{TGeoBuilder}, material::ByPtr1{TGeoMaterial})::Int32
Add a material to the list. Returns index of the material in list.

""" AddMaterial(this::ByRef1{TGeoBuilder}, material::ByPtr1{TGeoMaterial})

# Wrapper of Int_t TGeoBuilder::AddShape(TGeoShape *)
@trydoc raw"""
    AddShape(this::ByRef1{TGeoBuilder}, shape::ByPtr1{TGeoShape})::Int32
Add a shape to the list. Returns index of the shape in list.

""" AddShape(this::ByRef1{TGeoBuilder}, shape::ByPtr1{TGeoShape})

# Wrapper of Int_t TGeoBuilder::AddTransformation(TGeoMatrix *)
@trydoc raw"""
    AddTransformation(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})::Int32
Add a matrix to the list. Returns index of the matrix in list.

""" AddTransformation(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})

# Wrapper of TGeoVolume * TGeoBuilder::Division(const char *, const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Division(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Create a new volume by dividing an existing one (GEANT3 like)
Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER) The behavior of the division operation can be triggered using OPTION (case insensitive):

- N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3)
- NX - divide range starting with START in NDIV cells (GSDVN2 in G3)
- S - divide all range with given STEP. NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3)
- SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3)
""" Division(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of TGeoVolume * TGeoBuilder::MakeArb8(const char *, TGeoMedium *, Double_t, Double_t *)
@trydoc raw"""
    MakeArb8(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})::CxxPtr1{TGeoVolume}
Make an [TGeoArb8](@ref) volume.

""" MakeArb8(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoBuilder::MakeBox(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeBox(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a box shape with given medium.

""" MakeBox(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeCone(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCone(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone shape with given medium.

""" MakeCone(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeCons(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCons(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone segment shape with given medium.

""" MakeCons(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeCtub(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCtub(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.

""" MakeCtub(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeEltu(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeEltu(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeEltu(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeGtra(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeGtra(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a twisted trapezoid shape with given medium.

""" MakeGtra(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeHype(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeHype(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeHype(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakePara(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakePara(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a parallelepiped shape with given medium.

""" MakePara(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeParaboloid(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeParaboloid(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeParaboloid(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakePcon(const char *, TGeoMedium *, Double_t, Double_t, Int_t)
@trydoc raw"""
    MakePcon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polycone shape with given medium.

""" MakePcon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)

# Wrapper of TGeoVolume * TGeoBuilder::MakePgon(const char *, TGeoMedium *, Double_t, Double_t, Int_t, Int_t)
@trydoc raw"""
    MakePgon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polygone shape with given medium.

""" MakePgon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)

# Wrapper of TGeoVolume * TGeoBuilder::MakeSphere(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeSphere(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a sphere shape with given medium.

""" MakeSphere(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTorus(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTorus(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a torus shape with given medium.

""" MakeTorus(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTrap(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrap(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a trapezoid shape with given medium.

""" MakeTrap(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTrd1(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd1(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd1](@ref) shape with given medium.

""" MakeTrd1(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTrd2(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd2(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd2](@ref) shape with given medium.

""" MakeTrd2(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTube(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTube(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeTube(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTubs(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTubs(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.

""" MakeTubs(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolumeAssembly * TGeoBuilder::MakeVolumeAssembly(const char *)
@trydoc raw"""
    MakeVolumeAssembly(this::ByRef1{TGeoBuilder}, name::ByCopy{String})::CxxPtr1{TGeoVolumeAssembly}
Make an assembly of volumes.

""" MakeVolumeAssembly(this::ByRef1{TGeoBuilder}, name::ByCopy{String})

# Wrapper of TGeoVolumeMulti * TGeoBuilder::MakeVolumeMulti(const char *, TGeoMedium *)
@trydoc raw"""
    MakeVolumeMulti(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})::CxxPtr1{TGeoVolumeMulti}
Make a [TGeoVolumeMulti](@ref) handling a list of volumes.

""" MakeVolumeMulti(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})

# Wrapper of TGeoVolume * TGeoBuilder::MakeXtru(const char *, TGeoMedium *, Int_t)
@trydoc raw"""
    MakeXtru(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)::CxxPtr1{TGeoVolume}
Make a TGeoXtru-shaped volume with nz planes.

""" MakeXtru(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)

# Wrapper of TGeoMaterial * TGeoBuilder::Material(const char *, Double_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Material(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)::CxxPtr1{TGeoMaterial}
Create material with given A, Z and density, having an unique id.

""" Material(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)

# Wrapper of void TGeoBuilder::Matrix(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    GetMatrix(this::ByRef1{TGeoBuilder}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)::Nothing
Create rotation matrix named 'mat<index>'.
- index rotation matrix number
- theta1 polar angle for axis X
- phi1 azimuthal angle for axis X
- theta2 polar angle for axis Y
- phi2 azimuthal angle for axis Y
- theta3 polar angle for axis Z
- phi3 azimuthal angle for axis Z
""" GetMatrix(this::ByRef1{TGeoBuilder}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)

# Wrapper of TGeoMedium * TGeoBuilder::Medium(const char *, Int_t, Int_t, Int_t, Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Medium(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)::CxxPtr1{TGeoMedium}
Create tracking medium.
- numed tracking medium number assigned
- name tracking medium name
- nmat material number
- isvol sensitive volume flag
- ifield magnetic field
- fieldm max. field value (kilogauss)
- tmaxfd max. angle due to field (deg/step)
- stemax max. step allowed
- deemax max. fraction of energy lost in a step
- epsil tracking precision (cm)
- stmin min. step due to continuous processes (cm)
- ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;
- ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking performed with g3helix; ifield = 3 if tracking performed with g3helx3.
""" Medium(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)

# Wrapper of TGeoMaterial * TGeoBuilder::Mixture(const char *, Double_t *, Double_t *, Double_t, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)

# Wrapper of TGeoMaterial * TGeoBuilder::Mixture(const char *, Float_t *, Float_t *, Double_t, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)

# Wrapper of void TGeoBuilder::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Double_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of void TGeoBuilder::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Float_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of void TGeoBuilder::RegisterMatrix(TGeoMatrix *)
@trydoc raw"""
    RegisterMatrix(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})::Nothing
Register a matrix to the list of matrices.
It will be cleaned-up at the destruction [TGeoManager](@ref).
""" RegisterMatrix(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})

# Wrapper of TGeoVolume * TGeoBuilder::Volume(const char *, const char *, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of TGeoVolume * TGeoBuilder::Volume(const char *, const char *, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of void TGeoManager::AddBorderSurface(TGeoBorderSurface *)
@trydoc raw"""
    AddBorderSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoBorderSurface})::Nothing
Add border surface;.

""" AddBorderSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoBorderSurface})

# Wrapper of void TGeoManager::AddGDMLMatrix(TGDMLMatrix *)
@trydoc raw"""
    AddGDMLMatrix(this::ByRef1{TGeoManager}, mat::ByPtr1{TGDMLMatrix})::Nothing
Add GDML matrix;.

""" AddGDMLMatrix(this::ByRef1{TGeoManager}, mat::ByPtr1{TGDMLMatrix})

# Wrapper of Int_t TGeoManager::AddMaterial(const TGeoMaterial *)
@trydoc raw"""
    AddMaterial(this::ByRef1{TGeoManager}, material::ByConstPtr1{TGeoMaterial})::Int32
Add a material to the list. Returns index of the material in list.

""" AddMaterial(this::ByRef1{TGeoManager}, material::ByConstPtr1{TGeoMaterial})

# Wrapper of TGeoNavigator * TGeoManager::AddNavigator()
@trydoc raw"""
    AddNavigator(this::ByRef1{TGeoManager})::CxxPtr1{TGeoNavigator}
Add a navigator in the list of navigators.
If it is the first one make it current navigator.
""" AddNavigator(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::AddOpticalSurface(TGeoOpticalSurface *)
@trydoc raw"""
    AddOpticalSurface(this::ByRef1{TGeoManager}, optsurf::ByPtr1{TGeoOpticalSurface})::Nothing
Add optical surface;.

""" AddOpticalSurface(this::ByRef1{TGeoManager}, optsurf::ByPtr1{TGeoOpticalSurface})

# Wrapper of Int_t TGeoManager::AddOverlap(const TNamed *)
@trydoc raw"""
    AddOverlap(this::ByRef1{TGeoManager}, ovlp::ByConstPtr1{TNamed})::Int32
Add an illegal overlap/extrusion to the list.

""" AddOverlap(this::ByRef1{TGeoManager}, ovlp::ByConstPtr1{TNamed})

# Wrapper of Bool_t TGeoManager::AddProperty(const char *, Double_t)
@trydoc raw"""
    AddProperty(this::ByRef1{TGeoManager}, property::ByCopy{String}, value::Float64)::Bool
Add a user-defined property. Returns true if added, false if existing.

""" AddProperty(this::ByRef1{TGeoManager}, property::ByCopy{String}, value::Float64)

# Wrapper of Int_t TGeoManager::AddRegion(TGeoRegion *)
@trydoc raw"""
    AddRegion(this::ByRef1{TGeoManager}, region::ByPtr1{TGeoRegion})::Int32
Add a new region of volumes.

""" AddRegion(this::ByRef1{TGeoManager}, region::ByPtr1{TGeoRegion})

# Wrapper of Int_t TGeoManager::AddShape(const TGeoShape *)
@trydoc raw"""
    AddShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})::Int32
Add a shape to the list. Returns index of the shape in list.

""" AddShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})

# Wrapper of void TGeoManager::AddSkinSurface(TGeoSkinSurface *)
@trydoc raw"""
    AddSkinSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoSkinSurface})::Nothing
Add skin surface;.

""" AddSkinSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoSkinSurface})

# Wrapper of Int_t TGeoManager::AddTrack(Int_t, Int_t, TObject *)
@trydoc raw"""
    AddTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::Int32
Add a track to the list of tracks.
Use this for primaries only. For secondaries, add them to the parent track. The method create objects that are registered to the analysis manager but have to be cleaned-up by the user via [ClearTracks()](@ref).
""" AddTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of Int_t TGeoManager::AddTrack(TVirtualGeoTrack *)
@trydoc raw"""
    AddTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})::Int32
Add a track to the list of tracks.

""" AddTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})

# Wrapper of Int_t TGeoManager::AddTransformation(const TGeoMatrix *)
@trydoc raw"""
    AddTransformation(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})::Int32
Add a matrix to the list. Returns index of the matrix in list.

""" AddTransformation(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})

# Wrapper of Int_t TGeoManager::AddVolume(TGeoVolume *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoManager}, volume::ByPtr1{TGeoVolume})::Int32
Add a volume to the list. Returns index of the volume in list.

""" AddVolume(this::ByRef1{TGeoManager}, volume::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::AnimateTracks(Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    AnimateTracks(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64, nframes::Int32, option::ByCopy{String})::Nothing
Draw animation of tracks.

""" AnimateTracks(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64, nframes::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::BombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    BombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing
Get the new 'bombed' translation vector according current exploded view mode.

""" BombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of void TGeoManager::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGeoManager}, b::ByPtr1{TBrowser})::Nothing
Describe how to browse this object.

""" Browse(this::ByRef1{TGeoManager}, b::ByPtr1{TBrowser})

# Wrapper of void TGeoManager::BuildDefaultMaterials()
@trydoc raw"""
    BuildDefaultMaterials(this::ByRef1{TGeoManager})::Nothing
Now just a shortcut for GetElementTable.

""" BuildDefaultMaterials(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TGeoManager}, path::ByCopy{String})::Bool
Browse the tree of nodes starting from fTopNode according to pathname.
Changes the path accordingly.
""" cd(this::ByRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of void TGeoManager::CdDown(Int_t)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoManager}, index::Int32)::Nothing
Make a daughter of current node current.
Can be called only with a valid daughter index (no check). Updates cache accordingly.
""" CdDown(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::CdNext()
@trydoc raw"""
    CdNext(this::ByRef1{TGeoManager})::Nothing
Do a cd to the node found next by FindNextBoundary.

""" CdNext(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CdNode(Int_t)
@trydoc raw"""
    CdNode(this::ByRef1{TGeoManager}, nodeid::Int32)::Nothing
Change current path to point to the node having this id.
Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)
""" CdNode(this::ByRef1{TGeoManager}, nodeid::Int32)

# Wrapper of void TGeoManager::CdTop()
@trydoc raw"""
    CdTop(this::ByRef1{TGeoManager})::Nothing
Make top level node the current node.
Updates the cache accordingly. Determine the overlapping state of current node.
""" CdTop(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CdUp()
@trydoc raw"""
    CdUp(this::ByRef1{TGeoManager})::Nothing
Go one level up in geometry.
Updates cache accordingly. Determine the overlapping state of current node.
""" CdUp(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CheckBoundaryErrors(Int_t, Double_t)
@trydoc raw"""
    CheckBoundaryErrors(this::ByRef1{TGeoManager}, ntracks::Int32, radius::Float64)::Nothing
Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary.
If radius is not mentioned the full bounding box will be sampled.
""" CheckBoundaryErrors(this::ByRef1{TGeoManager}, ntracks::Int32, radius::Float64)

# Wrapper of void TGeoManager::CheckBoundaryReference(Int_t)
@trydoc raw"""
    CheckBoundaryReference(this::ByRef1{TGeoManager}, icheck::Int32)::Nothing
Check the boundary errors reference file created by CheckBoundaryErrors method.
The shape for which the crossing failed is drawn with the starting point in red and the extrapolated point to boundary (+/- failing push/pull) in yellow.
""" CheckBoundaryReference(this::ByRef1{TGeoManager}, icheck::Int32)

# Wrapper of void TGeoManager::CheckGeometry(Option_t *)
@trydoc raw"""
    CheckGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Perform last checks on the geometry.

""" CheckGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::CheckGeometryFull(Int_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    CheckGeometryFull(this::ByRef1{TGeoManager}, ntracks::Int32, vx::Float64, vy::Float64, vz::Float64, option::ByCopy{String})::Nothing
Geometry checking.
- if option contains 'o': Optional overlap checkings (by sampling and by mesh).
- if option contains 'b': Optional boundary crossing check + timing per volume.

STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be checked by user to get report, then [TGeoVolume!CheckOverlaps](@ref)(0.01, "s") can be called for the suspicious volumes.

STAGE 2: normal overlap checking using the shapes mesh - fills the list of overlaps.

STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of crossings per volume (rays propagated from boundary to boundary until geometry exit). Timing computed and results stored in a histo.

STAGE 4: shooting 1 mil. random rays inside EACH volume and calling [FindNextBoundary()](@ref) + [Safety()](@ref) for each call. The timing is normalized by the number of crossings computed at stage 2 and presented as percentage. One can get a picture on which are the most "burned" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced.
""" CheckGeometryFull(this::ByRef1{TGeoManager}, ntracks::Int32, vx::Float64, vy::Float64, vz::Float64, option::ByCopy{String})

# Wrapper of void TGeoManager::CheckOverlaps(Double_t, Option_t *)
@trydoc raw"""
    CheckOverlaps(this::ByRef1{TGeoManager}, ovlp::Float64, option::ByCopy{String})::Nothing
Check all geometry for illegal overlaps within a limit OVLP.

""" CheckOverlaps(this::ByRef1{TGeoManager}, ovlp::Float64, option::ByCopy{String})

# Wrapper of void TGeoManager::CheckPoint(Double_t, Double_t, Double_t, Option_t *, Double_t)
@trydoc raw"""
    CheckPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)::Nothing
Classify a given point. See [TGeoChecker!CheckPoint()](@ref).
""" CheckPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)

# Wrapper of void TGeoManager::CheckShape(TGeoShape *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TGeoManager}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing
Test for shape navigation methods.
Summary for test numbers:

- 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2)
""" CheckShape(this::ByRef1{TGeoManager}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::CleanGarbage()
@trydoc raw"""
    CleanGarbage(this::ByRef1{TGeoManager})::Nothing
Clean temporary volumes and shapes from garbage collection.

""" CleanGarbage(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearAttributes()
@trydoc raw"""
    ClearAttributes(this::ByRef1{TGeoManager})::Nothing
Reset all attributes to default ones.
Default attributes for visualization are those defined before closing the geometry.
""" ClearAttributes(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearNavigators()
@trydoc raw"""
    ClearNavigators(this::ByRef1{TGeoManager})::Nothing
Clear all navigators.

""" ClearNavigators(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearOverlaps()
@trydoc raw"""
    ClearOverlaps(this::ByRef1{TGeoManager})::Nothing
Clear the list of overlaps.

""" ClearOverlaps(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearPhysicalNodes(Bool_t)
@trydoc raw"""
    ClearPhysicalNodes(this::ByRef1{TGeoManager}, mustdelete::Bool)::Nothing
Clear the current list of physical nodes, so that we can thestart over with a new list.
If MUSTDELETE is true, delete previous nodes.
""" ClearPhysicalNodes(this::ByRef1{TGeoManager}, mustdelete::Bool)

# Wrapper of void TGeoManager::ClearShape(const TGeoShape *)
@trydoc raw"""
    ClearShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})::Nothing
Remove a shape from the list of shapes.

""" ClearShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})

# Wrapper of void TGeoManager::ClearTracks()
@trydoc raw"""
    ClearTracks(this::ByRef1{TGeoManager})::Nothing


""" ClearTracks(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CloseGeometry(Option_t *)
@trydoc raw"""
    CloseGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-time shapes)building the cache manager, voxelizing all volumes, counting the total number of physical nodes and registering the manager class to the browser.

""" CloseGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::ConvertReflections()
@trydoc raw"""
    ConvertReflections(this::ByRef1{TGeoManager})::Nothing
Convert all reflections in geometry to normal rotations + reflected shapes.

""" ConvertReflections(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CountLevels()
@trydoc raw"""
    CountLevels(this::ByRef1{TGeoManager})::Nothing
Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices.

""" CountLevels(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::CountNodes(const TGeoVolume *, Int_t, Int_t)
@trydoc raw"""
    CountNodes(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, nlevels::Int32, option::Int32)::Int32
Count the total number of nodes starting from a volume, nlevels down.

""" CountNodes(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, nlevels::Int32, option::Int32)

# Wrapper of TGeoParallelWorld * TGeoManager::CreateParallelWorld(const char *)
@trydoc raw"""
    CreateParallelWorld(this::ByRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoParallelWorld}
Create a parallel world for prioritised navigation.
This can be populated with physical nodes and can be navigated independently using its API. In case the flag SetUseParallelWorldNav is set, any navigation query in the main geometry is checked against the parallel geometry, which gets priority in case of overlaps with the main geometry volumes.
""" CreateParallelWorld(this::ByRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoNode * TGeoManager::CrossBoundaryAndLocate(Bool_t, TGeoNode *)
@trydoc raw"""
    CrossBoundaryAndLocate(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode.

""" CrossBoundaryAndLocate(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByPtr1{TGeoNode})

# Wrapper of void TGeoManager::DefaultAngles()
@trydoc raw"""
    DefaultAngles(this::ByRef1{TGeoManager})::Nothing
Set default angles for a given view.

""" DefaultAngles(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DefaultColors()
@trydoc raw"""
    DefaultColors(this::ByRef1{TGeoManager})::Nothing
Set default volume colors according to A of material.

""" DefaultColors(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DisableInactiveVolumes()
@trydoc raw"""
    DisableInactiveVolumes(this::ByRef1{TGeoManager})::Nothing


""" DisableInactiveVolumes(this::ByRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::Division(const char *, const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Division(this::ByRef1{TGeoManager}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Create a new volume by dividing an existing one (GEANT3 like)
Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER) The behavior of the division operation can be triggered using OPTION :

OPTION (case insensitive) :

- N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3)
- NX - divide range starting with START in NDIV cells (GSDVN2 in G3)
- S - divide all range with given STEP. NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3)
- SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3)
""" Division(this::ByRef1{TGeoManager}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::DoBackupState()
@trydoc raw"""
    DoBackupState(this::ByRef1{TGeoManager})::Nothing
Backup the current state without affecting the cache stack.

""" DoBackupState(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DoRestoreState()
@trydoc raw"""
    DoRestoreState(this::ByRef1{TGeoManager})::Nothing
Restore a backed-up state without affecting the cache stack.

""" DoRestoreState(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DrawCurrentPoint(Int_t)
@trydoc raw"""
    DrawCurrentPoint(this::ByRef1{TGeoManager}, color::Int32)::Nothing
Draw current point in the same view.

""" DrawCurrentPoint(this::ByRef1{TGeoManager}, color::Int32)

# Wrapper of void TGeoManager::DrawPath(const char *, Option_t *)
@trydoc raw"""
    DrawPath(this::ByRef1{TGeoManager}, path::ByCopy{String}, option::ByCopy{String})::Nothing
Draw current path.

""" DrawPath(this::ByRef1{TGeoManager}, path::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TGeoManager::DrawTracks(Option_t *)
@trydoc raw"""
    DrawTracks(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Draw tracks over the geometry, according to option.
By default, only primaries are drawn. See [TGeoTrack!Draw()](@ref) for additional options.
""" DrawTracks(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::Edit(Option_t *)
@trydoc raw"""
    Edit(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Append a pad for this geometry.

""" Edit(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::EnableInactiveVolumes()
@trydoc raw"""
    EnableInactiveVolumes(this::ByRef1{TGeoManager})::Nothing


""" EnableInactiveVolumes(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoManager}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this manager.

""" ExecuteEvent(this::ByRef1{TGeoManager}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TGeoManager::Export(const char *, const char *, Option_t *)
@trydoc raw"""
    Export(this::ByRef1{TGeoManager}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})::Int32
Export this geometry to a file.
- Case 1: root file or root/xml file if filename theend with ".root". The key will be named name By default the geometry is saved without the voxelisation info. Use option 'v" to save the voxelisation info.
   if filename theend with ".xml" a root/xml file is produced.

 - Case 2: C++ script
   if filename theend with ".C"

 - Case 3: gdml file
   if filename theend with ".gdml" NOTE that to use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/geom/gdml
""" Export(this::ByRef1{TGeoManager}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of TGeoNode * TGeoManager::FindNextBoundary(Double_t, const char *, Bool_t)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoManager}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)::CxxPtr1{TGeoNode}
Find distance to next boundary and store it in fStep.
Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : "Is STEPMAX a safe step ?" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.

Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly [TGeoManager!Safety()](@ref) if they want this computed for the current point.
""" FindNextBoundary(this::ByRef1{TGeoManager}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNextBoundaryAndStep(Double_t, Bool_t)
@trydoc raw"""
    FindNextBoundaryAndStep(this::ByRef1{TGeoManager}, stepmax::Float64, compsafe::Bool)::CxxPtr1{TGeoNode}
Compute distance to next boundary within STEPMAX.
If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node.
""" FindNextBoundaryAndStep(this::ByRef1{TGeoManager}, stepmax::Float64, compsafe::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNextDaughterBoundary(Double_t *, Double_t *, Int_t &, Bool_t)
@trydoc raw"""
    FindNextDaughterBoundary(this::ByRef1{TGeoManager}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)::CxxPtr1{TGeoNode}
Computes as fStep the distance to next daughter of the current volume.
The point and direction must be converted in the coordinate system of the current volume. The proposed step limit is fStep.
""" FindNextDaughterBoundary(this::ByRef1{TGeoManager}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNode(Bool_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoManager}, safe_start::Bool)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoManager}, safe_start::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNode(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of Double_t * TGeoManager::FindNormal(Bool_t)
@trydoc raw"""
    FindNormal(this::ByRef1{TGeoManager}, forward::Bool)::CxxPtr2{Float64}
Computes normal vector to the next surface that will be or was already crossed when propagating on a straight line from a given point/direction.
Returns the normal vector cosines in the MASTER coordinate system. The dot product of the normal and the current direction is positive defined.
""" FindNormal(this::ByRef1{TGeoManager}, forward::Bool)

# Wrapper of Double_t * TGeoManager::FindNormalFast()
@trydoc raw"""
    FindNormalFast(this::ByRef1{TGeoManager})::CxxPtr2{Float64}
Computes fast normal to next crossed boundary, assuming that the current point is close enough to the boundary.
Works only after calling FindNextBoundary.
""" FindNormalFast(this::ByRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::FindVolumeFast(const char *, Bool_t)
@trydoc raw"""
    FindVolumeFast(this::ByRef1{TGeoManager}, name::ByCopy{String}, multi::Bool)::CxxPtr1{TGeoVolume}
Fast search for a named volume. All trailing blanks stripped.

""" FindVolumeFast(this::ByRef1{TGeoManager}, name::ByCopy{String}, multi::Bool)

# Wrapper of UChar_t * TGeoManager::GetBits()
@trydoc raw"""
    GetBits(this::ByRef1{TGeoManager})::CxxPtr2{UInt8}


""" GetBits(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetByteCount(Option_t *)
@trydoc raw"""
    GetByteCount(this::ByRef1{TGeoManager}, option::ByCopy{String})::Int32
Get total size of geometry in bytes.

""" GetByteCount(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of TVirtualGeoTrack * TGeoManager::GetCurrentTrack()
@trydoc raw"""
    GetCurrentTrack(this::ByRef1{TGeoManager})::CxxPtr1{TVirtualGeoTrack}


""" GetCurrentTrack(this::ByRef1{TGeoManager})

# Wrapper of TGeoElementTable * TGeoManager::GetElementTable()
@trydoc raw"""
    GetElementTable(this::ByRef1{TGeoManager})::CxxPtr1{TGeoElementTable}
Returns material table. Creates it if not existing.

""" GetElementTable(this::ByRef1{TGeoManager})

# Wrapper of TVirtualGeoPainter * TGeoManager::GetGeomPainter()
@trydoc raw"""
    GetGeomPainter(this::ByRef1{TGeoManager})::CxxPtr1{TVirtualGeoPainter}
Make a default painter if none present. Returns pointer to it.

""" GetGeomPainter(this::ByRef1{TGeoManager})

# Wrapper of TGeoHMatrix * TGeoManager::GetHMatrix()
@trydoc raw"""
    GetHMatrix(this::ByRef1{TGeoManager})::CxxPtr1{TGeoHMatrix}
Return stored current matrix (global_ matrix of the next touched node).

""" GetHMatrix(this::ByRef1{TGeoManager})

# Wrapper of TVirtualGeoTrack * TGeoManager::GetLastTrack()
@trydoc raw"""
    GetLastTrack(this::ByRef1{TGeoManager})::CxxPtr1{TVirtualGeoTrack}


""" GetLastTrack(this::ByRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfNodes()
@trydoc raw"""
    GetListOfNodes(this::ByRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfNodes(this::ByRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfOverlaps()
@trydoc raw"""
    GetListOfOverlaps(this::ByRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfOverlaps(this::ByRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfPhysicalNodes()
@trydoc raw"""
    GetListOfPhysicalNodes(this::ByRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfPhysicalNodes(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNNodes()
@trydoc raw"""
    GetNNodes(this::ByRef1{TGeoManager})::Int32


""" GetNNodes(this::ByRef1{TGeoManager})

# Wrapper of TGeoRegion * TGeoManager::GetRegion(int)
@trydoc raw"""
    GetRegion(this::ByRef1{TGeoManager}, i::Int32)::CxxPtr1{TGeoRegion}


""" GetRegion(this::ByRef1{TGeoManager}, i::Int32)

# Wrapper of TVirtualGeoTrack * TGeoManager::GetTrack(Int_t)
@trydoc raw"""
    GetTrack(this::ByRef1{TGeoManager}, index::Int32)::CxxPtr1{TVirtualGeoTrack}


""" GetTrack(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of Int_t TGeoManager::GetVirtualLevel()
@trydoc raw"""
    GetVirtualLevel(this::ByRef1{TGeoManager})::Int32
Find level of virtuality of current overlapping node (number of levels up having the same tracking media.

""" GetVirtualLevel(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::GotoSafeLevel()
@trydoc raw"""
    GotoSafeLevel(this::ByRef1{TGeoManager})::Bool
Go upwards the tree until a non-overlapping node.

""" GotoSafeLevel(this::ByRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::InitTrack(const Double_t *, const Double_t *)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoManager}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoManager}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of TGeoNode * TGeoManager::InitTrack(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of Bool_t TGeoManager::IsSameLocation(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    IsSameLocation(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, change::Bool)::Bool
Checks if point (x,y,z) is still in the current node.

""" IsSameLocation(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, change::Bool)

# Wrapper of TGeoPhysicalNode * TGeoManager::MakeAlignablePN(const char *)
@trydoc raw"""
    MakeAlignablePN(this::ByRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoPhysicalNode}
Make a physical node from the path pointed by an alignable object with a given name.

""" MakeAlignablePN(this::ByRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoPhysicalNode * TGeoManager::MakeAlignablePN(TGeoPNEntry *)
@trydoc raw"""
    MakeAlignablePN(this::ByRef1{TGeoManager}, entry::ByPtr1{TGeoPNEntry})::CxxPtr1{TGeoPhysicalNode}
Make a physical node from the path pointed by a given alignable object.

""" MakeAlignablePN(this::ByRef1{TGeoManager}, entry::ByPtr1{TGeoPNEntry})

# Wrapper of TGeoVolume * TGeoManager::MakeArb8(const char *, TGeoMedium *, Double_t, Double_t *)
@trydoc raw"""
    MakeArb8(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})::CxxPtr1{TGeoVolume}
Make an [TGeoArb8](@ref) volume.

""" MakeArb8(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoManager::MakeBox(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeBox(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a box shape with given medium.

""" MakeBox(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeCone(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCone(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone shape with given medium.

""" MakeCone(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeCons(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCons(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone segment shape with given medium.

""" MakeCons(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeCtub(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCtub(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.

""" MakeCtub(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeEltu(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeEltu(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeEltu(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeGtra(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeGtra(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a twisted trapezoid shape with given medium.

""" MakeGtra(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeHype(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeHype(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeHype(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakePara(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakePara(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a parallelepiped shape with given medium.

""" MakePara(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeParaboloid(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeParaboloid(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeParaboloid(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakePcon(const char *, TGeoMedium *, Double_t, Double_t, Int_t)
@trydoc raw"""
    MakePcon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polycone shape with given medium.

""" MakePcon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)

# Wrapper of TGeoVolume * TGeoManager::MakePgon(const char *, TGeoMedium *, Double_t, Double_t, Int_t, Int_t)
@trydoc raw"""
    MakePgon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polygone shape with given medium.

""" MakePgon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)

# Wrapper of TGeoPhysicalNode * TGeoManager::MakePhysicalNode(const char *)
@trydoc raw"""
    MakePhysicalNode(this::ByRef1{TGeoManager}, path::ByCopy{String})::CxxPtr1{TGeoPhysicalNode}
Makes a physical node corresponding to a path.
If PATH is not specified, makes physical node matching current modeller state.
""" MakePhysicalNode(this::ByRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of TGeoVolume * TGeoManager::MakeSphere(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeSphere(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a sphere shape with given medium.

""" MakeSphere(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTorus(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTorus(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a torus shape with given medium.

""" MakeTorus(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)

# Wrapper of TVirtualGeoTrack * TGeoManager::MakeTrack(Int_t, Int_t, TObject *)
@trydoc raw"""
    MakeTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::CxxPtr1{TVirtualGeoTrack}
Makes a primary track but do not attach it to the list of tracks.
The track can be attached as daughter to another one with TVirtualGeoTrack!AddTrack
""" MakeTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of TGeoVolume * TGeoManager::MakeTrap(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrap(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a trapezoid shape with given medium.

""" MakeTrap(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTrd1(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd1(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd1](@ref) shape with given medium.

""" MakeTrd1(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTrd2(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd2(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd2](@ref) shape with given medium.

""" MakeTrd2(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTube(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTube(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeTube(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTubs(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTubs(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.
The segment will be from phiStart to phiEnd, the angles are expressed in degree
""" MakeTubs(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolumeAssembly * TGeoManager::MakeVolumeAssembly(const char *)
@trydoc raw"""
    MakeVolumeAssembly(this::ByRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoVolumeAssembly}
Make an assembly of volumes.

""" MakeVolumeAssembly(this::ByRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoVolumeMulti * TGeoManager::MakeVolumeMulti(const char *, TGeoMedium *)
@trydoc raw"""
    MakeVolumeMulti(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})::CxxPtr1{TGeoVolumeMulti}
Make a [TGeoVolumeMulti](@ref) handling a list of volumes.

""" MakeVolumeMulti(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})

# Wrapper of TGeoVolume * TGeoManager::MakeXtru(const char *, TGeoMedium *, Int_t)
@trydoc raw"""
    MakeXtru(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)::CxxPtr1{TGeoVolume}
Make a TGeoXtru-shaped volume with nz planes.

""" MakeXtru(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)

# Wrapper of TGeoMaterial * TGeoManager::Material(const char *, Double_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Material(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)::CxxPtr1{TGeoMaterial}
Create material with given A, Z and density, having an unique id.

""" Material(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)

# Wrapper of void TGeoManager::Matrix(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    GetMatrix(this::ByRef1{TGeoManager}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)::Nothing
Create rotation matrix named 'mat<index>'.
- index rotation matrix number
- theta1 polar angle for axis X
- phi1 azimuthal angle for axis X
- theta2 polar angle for axis Y
- phi2 azimuthal angle for axis Y
- theta3 polar angle for axis Z
- phi3 azimuthal angle for axis Z
""" GetMatrix(this::ByRef1{TGeoManager}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)

# Wrapper of TGeoMedium * TGeoManager::Medium(const char *, Int_t, Int_t, Int_t, Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Medium(this::ByRef1{TGeoManager}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)::CxxPtr1{TGeoMedium}
Create tracking medium.
- numed tracking medium number assigned
- name tracking medium name
- nmat material number
- isvol sensitive volume flag
- ifield magnetic field
- fieldm max. field value (kilogauss)
- tmaxfd max. angle due to field (deg/step)
- stemax max. step allowed
- deemax max. fraction of energy lost in a step
- epsil tracking precision (cm)
- stmin min. step due to continuous processes (cm)
- ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;
- ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking performed with g3helix; ifield = 3 if tracking performed with g3helx3.
""" Medium(this::ByRef1{TGeoManager}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)

# Wrapper of TGeoMaterial * TGeoManager::Mixture(const char *, Double_t *, Double_t *, Double_t, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)

# Wrapper of TGeoMaterial * TGeoManager::Mixture(const char *, Float_t *, Float_t *, Double_t, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)

# Wrapper of void TGeoManager::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Double_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of void TGeoManager::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Float_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of void TGeoManager::OptimizeVoxels(const char *)
@trydoc raw"""
    OptimizeVoxels(this::ByRef1{TGeoManager}, filename::ByCopy{String})::Nothing
Optimize voxelization type for all volumes. Save best choice in a macro.

""" OptimizeVoxels(this::ByRef1{TGeoManager}, filename::ByCopy{String})

# Wrapper of void TGeoManager::PopDummy(Int_t)
@trydoc raw"""
    PopDummy(this::ByRef1{TGeoManager}, ipop::Int32)::Nothing


""" PopDummy(this::ByRef1{TGeoManager}, ipop::Int32)

# Wrapper of Bool_t TGeoManager::PopPath()
@trydoc raw"""
    PopPath(this::ByRef1{TGeoManager})::Bool


""" PopPath(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::PopPath(Int_t)
@trydoc raw"""
    PopPath(this::ByRef1{TGeoManager}, index::Int32)::Bool


""" PopPath(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of Bool_t TGeoManager::PopPoint()
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoManager})::Bool


""" PopPoint(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::PopPoint(Int_t)
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoManager}, index::Int32)::Bool


""" PopPoint(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of Int_t TGeoManager::PushPath(Int_t)
@trydoc raw"""
    PushPath(this::ByRef1{TGeoManager}, startlevel::Int32)::Int32


""" PushPath(this::ByRef1{TGeoManager}, startlevel::Int32)

# Wrapper of Int_t TGeoManager::PushPoint(Int_t)
@trydoc raw"""
    PushPoint(this::ByRef1{TGeoManager}, startlevel::Int32)::Int32


""" PushPoint(this::ByRef1{TGeoManager}, startlevel::Int32)

# Wrapper of void TGeoManager::RandomPoints(const TGeoVolume *, Int_t, Option_t *)
@trydoc raw"""
    RandomPoints(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})::Nothing
Draw random points in the bounding box of a volume.

""" RandomPoints(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::RandomRays(Int_t, Double_t, Double_t, Double_t, const char *, Bool_t)
@trydoc raw"""
    RandomRays(this::ByRef1{TGeoManager}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)::Nothing
Randomly shoot nrays and plot intersections with surfaces for current top node.

""" RandomRays(this::ByRef1{TGeoManager}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)

# Wrapper of void TGeoManager::RefreshPhysicalNodes(Bool_t)
@trydoc raw"""
    RefreshPhysicalNodes(this::ByRef1{TGeoManager}, lock::Bool)::Nothing
Refresh physical nodes to reflect the actual geometry paths after alignment was applied.
Optionally locks physical nodes (default).
""" RefreshPhysicalNodes(this::ByRef1{TGeoManager}, lock::Bool)

# Wrapper of void TGeoManager::RegisterMatrix(const TGeoMatrix *)
@trydoc raw"""
    RegisterMatrix(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})::Nothing
Register a matrix to the list of matrices.
It will be cleaned-up at the destruction [TGeoManager](@ref).
""" RegisterMatrix(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoManager::RemoveMaterial(Int_t)
@trydoc raw"""
    RemoveMaterial(this::ByRef1{TGeoManager}, index::Int32)::Nothing
Remove material at given index.

""" RemoveMaterial(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::RemoveNavigator(const TGeoNavigator *)
@trydoc raw"""
    RemoveNavigator(this::ByRef1{TGeoManager}, nav::ByConstPtr1{TGeoNavigator})::Nothing
Clear a single navigator.

""" RemoveNavigator(this::ByRef1{TGeoManager}, nav::ByConstPtr1{TGeoNavigator})

# Wrapper of Int_t TGeoManager::ReplaceVolume(TGeoVolume *, TGeoVolume *)
@trydoc raw"""
    ReplaceVolume(this::ByRef1{TGeoManager}, vorig::ByPtr1{TGeoVolume}, vnew::ByPtr1{TGeoVolume})::Int32
Replaces all occurrences of VORIG with VNEW in the geometry tree.
The volume VORIG is not replaced from the list of volumes, but all node referencing it will reference VNEW instead. Returns number of occurrences changed.
""" ReplaceVolume(this::ByRef1{TGeoManager}, vorig::ByPtr1{TGeoVolume}, vnew::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::ResetState()
@trydoc raw"""
    ResetState(this::ByRef1{TGeoManager})::Nothing
Reset current state flags.

""" ResetState(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ResetUserData()
@trydoc raw"""
    ResetUserData(this::ByRef1{TGeoManager})::Nothing
Sets all pointers [TGeoVolume!fField](@ref) to NULL.
User data becomes decoupled from geometry. Deletion has to be managed by users.
""" ResetUserData(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::RestoreMasterVolume()
@trydoc raw"""
    RestoreMasterVolume(this::ByRef1{TGeoManager})::Nothing
Restore the master volume of the geometry.

""" RestoreMasterVolume(this::ByRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::Safety(Bool_t)
@trydoc raw"""
    Safety(this::ByRef1{TGeoManager}, inside::Bool)::Float64
Compute safe distance from the current point.
This represent the distance from POINT to the closest boundary.
""" Safety(this::ByRef1{TGeoManager}, inside::Bool)

# Wrapper of TGeoNode * TGeoManager::SamplePoints(Int_t, Double_t &, Double_t, const char *)
@trydoc raw"""
    SamplePoints(this::ByRef1{TGeoManager}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})::CxxPtr1{TGeoNode}
shoot npoints randomly in a box of 1E-5 around current point.
return minimum distance to points outside
""" SamplePoints(this::ByRef1{TGeoManager}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})

# Wrapper of void TGeoManager::SaveAttributes(const char *)
@trydoc raw"""
    SaveAttributes(this::ByRef1{TGeoManager}, filename::ByCopy{String})::Nothing
Save current attributes in a macro.

""" SaveAttributes(this::ByRef1{TGeoManager}, filename::ByCopy{String})

# Wrapper of TGeoNode * TGeoManager::SearchNode(Bool_t, const TGeoNode *)
@trydoc raw"""
    SearchNode(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Returns the deepest node containing fPoint, which must be set a priori.

""" SearchNode(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})

# Wrapper of void TGeoManager::SelectTrackingMedia()
@trydoc raw"""
    SelectTrackingMedia(this::ByRef1{TGeoManager})::Nothing
Define different tracking media.

""" SelectTrackingMedia(this::ByRef1{TGeoManager})

# Wrapper of TGeoPNEntry * TGeoManager::SetAlignableEntry(const char *, const char *, Int_t)
@trydoc raw"""
    SetAlignableEntry(this::ByRef1{TGeoManager}, unique_name::ByCopy{String}, path::ByCopy{String}, uid::Int32)::CxxPtr1{TGeoPNEntry}
Creates an alignable object with unique name corresponding to a path and adds it to the list of alignables.
An optional unique ID can be provided, in which case PN entries can be searched fast by uid.
""" SetAlignableEntry(this::ByRef1{TGeoManager}, unique_name::ByCopy{String}, path::ByCopy{String}, uid::Int32)

# Wrapper of void TGeoManager::SetAllIndex()
@trydoc raw"""
    SetAllIndex(this::ByRef1{TGeoManager})::Nothing
Assigns uid's for all materials,media and matrices.

""" SetAllIndex(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::SetAnimateTracks(Bool_t)
@trydoc raw"""
    SetAnimateTracks(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetAnimateTracks(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetBombFactors(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetBombFactors(this::ByRef1{TGeoManager}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)::Nothing
Set factors that will "bomb" all translations in cartesian and cylindrical coordinates.

""" SetBombFactors(this::ByRef1{TGeoManager}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)

# Wrapper of void TGeoManager::SetCheckedNode(TGeoNode *)
@trydoc raw"""
    SetCheckedNode(this::ByRef1{TGeoManager}, node::ByPtr1{TGeoNode})::Nothing
Assign a given node to be checked for overlaps. Any other overlaps will be ignored.

""" SetCheckedNode(this::ByRef1{TGeoManager}, node::ByPtr1{TGeoNode})

# Wrapper of void TGeoManager::SetCheckingOverlaps(Bool_t)
@trydoc raw"""
    SetCheckingOverlaps(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetCheckingOverlaps(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetCldirChecked(Double_t *)
@trydoc raw"""
    SetCldirChecked(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})::Nothing


""" SetCldirChecked(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})

# Wrapper of void TGeoManager::SetClipping(Bool_t)
@trydoc raw"""
    SetClipping(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetClipping(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetClippingShape(TGeoShape *)
@trydoc raw"""
    SetClippingShape(this::ByRef1{TGeoManager}, clip::ByPtr1{TGeoShape})::Nothing
Set a user-defined shape as clipping for ray tracing.

""" SetClippingShape(this::ByRef1{TGeoManager}, clip::ByPtr1{TGeoShape})

# Wrapper of void TGeoManager::SetCurrentDirection(Double_t *)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})

# Wrapper of void TGeoManager::SetCurrentDirection(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoManager}, nx::Float64, ny::Float64, nz::Float64)::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoManager}, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of Bool_t TGeoManager::SetCurrentNavigator(Int_t)
@trydoc raw"""
    SetCurrentNavigator(this::ByRef1{TGeoManager}, index::Int32)::Bool
Switch to another existing navigator for the calling thread.

""" SetCurrentNavigator(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::SetCurrentPoint(Double_t *)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoManager}, point::ByPtr2{Float64})::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoManager}, point::ByPtr2{Float64})

# Wrapper of void TGeoManager::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoManager::SetCurrentTrack(Int_t)
@trydoc raw"""
    SetCurrentTrack(this::ByRef1{TGeoManager}, i::Int32)::Nothing


""" SetCurrentTrack(this::ByRef1{TGeoManager}, i::Int32)

# Wrapper of void TGeoManager::SetCurrentTrack(TVirtualGeoTrack *)
@trydoc raw"""
    SetCurrentTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})::Nothing


""" SetCurrentTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})

# Wrapper of void TGeoManager::SetDrawExtraPaths(Bool_t)
@trydoc raw"""
    SetDrawExtraPaths(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetDrawExtraPaths(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetExplodedView(Int_t)
@trydoc raw"""
    SetExplodedView(this::ByRef1{TGeoManager}, iopt::Int32)::Nothing
Set type of exploding view (see [TGeoPainter!SetExplodedView()](@ref))
""" SetExplodedView(this::ByRef1{TGeoManager}, iopt::Int32)

# Wrapper of void TGeoManager::SetLastPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetLastPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetLastPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoManager::SetMatrixReflection(Bool_t)
@trydoc raw"""
    SetMatrixReflection(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetMatrixReflection(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetMatrixTransform(Bool_t)
@trydoc raw"""
    SetMatrixTransform(this::ByRef1{TGeoManager}, on::Bool)::Nothing


""" SetMatrixTransform(this::ByRef1{TGeoManager}, on::Bool)

# Wrapper of void TGeoManager::SetMaxThreads(Int_t)
@trydoc raw"""
    SetMaxThreads(this::ByRef1{TGeoManager}, nthreads::Int32)::Nothing
Set maximum number of threads for navigation.

""" SetMaxThreads(this::ByRef1{TGeoManager}, nthreads::Int32)

# Wrapper of void TGeoManager::SetMaxVisNodes(Int_t)
@trydoc raw"""
    SetMaxVisNodes(this::ByRef1{TGeoManager}, maxnodes::Int32)::Nothing
set the maximum number of visible nodes.

""" SetMaxVisNodes(this::ByRef1{TGeoManager}, maxnodes::Int32)

# Wrapper of void TGeoManager::SetNmeshPoints(Int_t)
@trydoc raw"""
    SetNmeshPoints(this::ByRef1{TGeoManager}, npoints::Int32)::Nothing
Set the number of points to be generated on the shape outline when checking for overlaps.

""" SetNmeshPoints(this::ByRef1{TGeoManager}, npoints::Int32)

# Wrapper of void TGeoManager::SetNodeSelectable(Bool_t)
@trydoc raw"""
    SetNodeSelectable(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetNodeSelectable(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetNsegments(Int_t)
@trydoc raw"""
    SetNsegments(this::ByRef1{TGeoManager}, nseg::Int32)::Nothing
Set number of segments for approximating circles in drawing.

""" SetNsegments(this::ByRef1{TGeoManager}, nseg::Int32)

# Wrapper of void TGeoManager::SetOutside(Bool_t)
@trydoc raw"""
    SetOutside(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetOutside(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetPaintVolume(TGeoVolume *)
@trydoc raw"""
    SetPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::SetParticleName(const char *)
@trydoc raw"""
    SetParticleName(this::ByRef1{TGeoManager}, pname::ByCopy{String})::Nothing


""" SetParticleName(this::ByRef1{TGeoManager}, pname::ByCopy{String})

# Wrapper of void TGeoManager::SetPdgName(Int_t, const char *)
@trydoc raw"""
    SetPdgName(this::ByRef1{TGeoManager}, pdg::Int32, name::ByCopy{String})::Nothing
Set a name for a particle having a given pdg.

""" SetPdgName(this::ByRef1{TGeoManager}, pdg::Int32, name::ByCopy{String})

# Wrapper of void TGeoManager::SetPhiRange(Double_t, Double_t)
@trydoc raw"""
    SetPhiRange(this::ByRef1{TGeoManager}, phimin::Float64, phimax::Float64)::Nothing
Set cut phi range.

""" SetPhiRange(this::ByRef1{TGeoManager}, phimin::Float64, phimax::Float64)

# Wrapper of void TGeoManager::SetRTmode(Int_t)
@trydoc raw"""
    SetRTmode(this::ByRef1{TGeoManager}, mode::Int32)::Nothing
Change raytracing mode.

""" SetRTmode(this::ByRef1{TGeoManager}, mode::Int32)

# Wrapper of void TGeoManager::SetStartSafe(Bool_t)
@trydoc raw"""
    SetStartSafe(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetStartSafe(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetStep(Double_t)
@trydoc raw"""
    SetStep(this::ByRef1{TGeoManager}, step::Float64)::Nothing


""" SetStep(this::ByRef1{TGeoManager}, step::Float64)

# Wrapper of void TGeoManager::SetTminTmax(Double_t, Double_t)
@trydoc raw"""
    SetTminTmax(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64)::Nothing
Set time cut interval for drawing tracks.
If called with no arguments, time cut will be disabled.
""" SetTminTmax(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64)

# Wrapper of void TGeoManager::SetTopVisible(Bool_t)
@trydoc raw"""
    SetTopVisible(this::ByRef1{TGeoManager}, vis::Bool)::Nothing
make top volume visible on screen

""" SetTopVisible(this::ByRef1{TGeoManager}, vis::Bool)

# Wrapper of void TGeoManager::SetTopVolume(TGeoVolume *)
@trydoc raw"""
    SetTopVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})::Nothing
Set the top volume and corresponding node as starting point of the geometry.

""" SetTopVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::SetUseParallelWorldNav(Bool_t)
@trydoc raw"""
    SetUseParallelWorldNav(this::ByRef1{TGeoManager}, flag::Bool)::Nothing
Activate/deactivate usage of parallel world navigation.
Can only be done if there is a parallel world. Activating navigation will automatically close the parallel geometry.
""" SetUseParallelWorldNav(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetUserPaintVolume(TGeoVolume *)
@trydoc raw"""
    SetUserPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetUserPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::SetVisDensity(Double_t)
@trydoc raw"""
    SetVisDensity(this::ByRef1{TGeoManager}, dens::Float64)::Nothing
Set density threshold.
Volumes with densities lower than this become transparent.
""" SetVisDensity(this::ByRef1{TGeoManager}, dens::Float64)

# Wrapper of void TGeoManager::SetVisibility(TObject *, Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoManager}, obj::ByPtr1{TObject}, vis::Bool)::Nothing
Set visibility for a volume.

""" SetVisibility(this::ByRef1{TGeoManager}, obj::ByPtr1{TObject}, vis::Bool)

# Wrapper of void TGeoManager::SetVisLevel(Int_t)
@trydoc raw"""
    SetVisLevel(this::ByRef1{TGeoManager}, level::Int32)::Nothing
set default level down to which visualization is performed

""" SetVisLevel(this::ByRef1{TGeoManager}, level::Int32)

# Wrapper of void TGeoManager::SetVisOption(Int_t)
@trydoc raw"""
    SetVisOption(this::ByRef1{TGeoManager}, option::Int32)::Nothing
set drawing mode :
- option=0 (default) all nodes drawn down to vislevel
- option=1 leaves and nodes at vislevel drawn
- option=2 path is drawn
- option=4 visibility changed
""" SetVisOption(this::ByRef1{TGeoManager}, option::Int32)

# Wrapper of void TGeoManager::SetVolumeAttribute(const char *, const char *, Int_t)
@trydoc raw"""
    SetVolumeAttribute(this::ByRef1{TGeoManager}, name::ByCopy{String}, att::ByCopy{String}, val::Int32)::Nothing
Set volume attributes in G3 style.

""" SetVolumeAttribute(this::ByRef1{TGeoManager}, name::ByCopy{String}, att::ByCopy{String}, val::Int32)

# Wrapper of ULong_t TGeoManager::SizeOf(const TGeoNode *, Option_t *)
@trydoc raw"""
    SizeOf(this::ByRef1{TGeoManager}, node::ByConstPtr1{TGeoNode}, option::ByCopy{String})::UInt64
computes the total size in bytes of the branch starting with node.
The option can specify if all the branch has to be parsed or only the node
""" SizeOf(this::ByRef1{TGeoManager}, node::ByConstPtr1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoManager::SortOverlaps()
@trydoc raw"""
    SortOverlaps(this::ByRef1{TGeoManager})::Nothing
Sort overlaps by decreasing overlap distance. Extrusions comes first.

""" SortOverlaps(this::ByRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::Step(Bool_t, Bool_t)
@trydoc raw"""
    Step(this::ByRef1{TGeoManager}, is_geom::Bool, cross::Bool)::CxxPtr1{TGeoNode}
Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection).
If the step is imposed by geometry, is_geom flag must be true (default). The cross flag specifies if the boundary should be crossed in case of a geometry step (default true). Returns new node after step. Set also on boundary condition.
""" Step(this::ByRef1{TGeoManager}, is_geom::Bool, cross::Bool)

# Wrapper of void TGeoManager::Test(Int_t, Option_t *)
@trydoc raw"""
    Test(this::ByRef1{TGeoManager}, npoints::Int32, option::ByCopy{String})::Nothing
Check time of finding "Where am I" for n points.

""" Test(this::ByRef1{TGeoManager}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::TestOverlaps(const char *)
@trydoc raw"""
    TestOverlaps(this::ByRef1{TGeoManager}, path::ByCopy{String})::Nothing
Geometry overlap checker based on sampling.

""" TestOverlaps(this::ByRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of Int_t TGeoManager::TransformVolumeToAssembly(const char *)
@trydoc raw"""
    TransformVolumeToAssembly(this::ByRef1{TGeoManager}, vname::ByCopy{String})::Int32
Transform all volumes named VNAME to assemblies. The volumes must be virtual.

""" TransformVolumeToAssembly(this::ByRef1{TGeoManager}, vname::ByCopy{String})

# Wrapper of void TGeoManager::UnbombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    UnbombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing
Get the new 'unbombed' translation vector according current exploded view mode.

""" UnbombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of void TGeoManager::ViewLeaves(Bool_t)
@trydoc raw"""
    ViewLeaves(this::ByRef1{TGeoManager}, flag::Bool)::Nothing
Set visualization option (leaves only OR all volumes)

""" ViewLeaves(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of TGeoVolume * TGeoManager::Volume(const char *, const char *, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of TGeoVolume * TGeoManager::Volume(const char *, const char *, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of Double_t TGeoManager::Weight(Double_t, Option_t *)
@trydoc raw"""
    Weight(this::ByRef1{TGeoManager}, precision::Float64, option::ByCopy{String})::Float64
Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.
Option can be "v" - verbose (default)
""" Weight(this::ByRef1{TGeoManager}, precision::Float64, option::ByCopy{String})

# Wrapper of bool TGeoMaterial::AddConstProperty(const char *, const char *)
@trydoc raw"""
    AddConstProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddConstProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of bool TGeoMaterial::AddProperty(const char *, const char *)
@trydoc raw"""
    AddProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of TGeoMaterial * TGeoMaterial::DecayMaterial(Double_t, Double_t)
@trydoc raw"""
    DecayMaterial(this::ByRef1{TGeoMaterial}, time::Float64, precision::Float64)::CxxPtr1{TGeoMaterial}
Create the material representing the decay product of this material at a given time.
The precision represent the minimum cumulative branching ratio for which decay products are still taken into account.
""" DecayMaterial(this::ByRef1{TGeoMaterial}, time::Float64, precision::Float64)

# Wrapper of void TGeoMaterial::FillMaterialEvolution(TObjArray *, Double_t)
@trydoc raw"""
    FillMaterialEvolution(this::ByRef1{TGeoMaterial}, population::ByPtr1{TObjArray}, precision::Float64)::Nothing
Fills a user array with all the elements deriving from the possible decay of the top element composing the mixture.
Each element contained by `<population>` may be a radionuclide having a Bateman solution attached. The precision represent the minimum cumulative branching ratio for which decay products are still taken into account. To visualize the time evolution of each decay product one can use: 

    TGeoElement *elem = population->At(index);
    TGeoElementRN *elemrn = 0;
    if (elem->IsRadioNuclide()) elemrn = (TGeoElementRN*)elem;

(C++ version of the code)

 One can get Ni/N1(t=0) at any moment of time. Ni is the number of atoms of one of the decay products, N1(0) is the number of atoms of the top element at t=0. 

    Double_t fraction_weight = elemrn->Ratio()->Concentration(time);

(C++ version of the code)

 One can also display the time evolution of the fractional weight: 

    elemrn->Ratio()->Draw(option);

(C++ version of the code)
""" FillMaterialEvolution(this::ByRef1{TGeoMaterial}, population::ByPtr1{TObjArray}, precision::Float64)

# Wrapper of void TGeoMaterial::GetElementProp(Double_t &, Double_t &, Double_t &, Int_t)
@trydoc raw"""
    GetElementProp(this::ByRef1{TGeoMaterial}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)::Nothing
Single interface to get element properties.

""" GetElementProp(this::ByRef1{TGeoMaterial}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)

# Wrapper of Int_t TGeoMaterial::GetIndex()
@trydoc raw"""
    GetIndex(this::ByRef1{TGeoMaterial})::Int32
Retrieve material index in the list of materials.

""" GetIndex(this::ByRef1{TGeoMaterial})

# Wrapper of void TGeoMaterial::SetA(Double_t)
@trydoc raw"""
    SetA(this::ByRef1{TGeoMaterial}, a::Float64)::Nothing


""" SetA(this::ByRef1{TGeoMaterial}, a::Float64)

# Wrapper of void TGeoMaterial::SetCerenkovProperties(TObject *)
@trydoc raw"""
    SetCerenkovProperties(this::ByRef1{TGeoMaterial}, cerenkov::ByPtr1{TObject})::Nothing


""" SetCerenkovProperties(this::ByRef1{TGeoMaterial}, cerenkov::ByPtr1{TObject})

# Wrapper of void TGeoMaterial::SetDensity(Double_t)
@trydoc raw"""
    SetDensity(this::ByRef1{TGeoMaterial}, density::Float64)::Nothing


""" SetDensity(this::ByRef1{TGeoMaterial}, density::Float64)

# Wrapper of void TGeoMaterial::SetFWExtension(TGeoExtension *)
@trydoc raw"""
    SetFWExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})::Nothing
Connect framework defined extension to the material.
The material "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for the use by TGeo and the users should NOT connect extensions using this method
""" SetFWExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoMaterial::SetIndex(Int_t)
@trydoc raw"""
    SetIndex(this::ByRef1{TGeoMaterial}, index::Int32)::Nothing


""" SetIndex(this::ByRef1{TGeoMaterial}, index::Int32)

# Wrapper of void TGeoMaterial::SetPressure(Double_t)
@trydoc raw"""
    SetPressure(this::ByRef1{TGeoMaterial}, pressure::Float64)::Nothing


""" SetPressure(this::ByRef1{TGeoMaterial}, pressure::Float64)

# Wrapper of void TGeoMaterial::SetRadLen(Double_t, Double_t)
@trydoc raw"""
    SetRadLen(this::ByRef1{TGeoMaterial}, radlen::Float64, intlen::Float64)::Nothing
Set radiation/absorption lengths.
If the values are negative, their absolute value is taken, otherwise radlen is recomputed using G3 formula.
""" SetRadLen(this::ByRef1{TGeoMaterial}, radlen::Float64, intlen::Float64)

# Wrapper of void TGeoMaterial::SetTemperature(Double_t)
@trydoc raw"""
    SetTemperature(this::ByRef1{TGeoMaterial}, temperature::Float64)::Nothing


""" SetTemperature(this::ByRef1{TGeoMaterial}, temperature::Float64)

# Wrapper of void TGeoMaterial::SetTransparency(Char_t)
@trydoc raw"""
    SetTransparency(this::ByRef1{TGeoMaterial}, transparency::Int8)::Nothing


""" SetTransparency(this::ByRef1{TGeoMaterial}, transparency::Int8)

# Wrapper of void TGeoMaterial::SetUsed(Bool_t)
@trydoc raw"""
    SetUsed(this::ByRef1{TGeoMaterial}, flag::Bool)::Nothing


""" SetUsed(this::ByRef1{TGeoMaterial}, flag::Bool)

# Wrapper of void TGeoMaterial::SetUserExtension(TGeoExtension *)
@trydoc raw"""
    SetUserExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})::Nothing
Connect user-defined extension to the material.
The material "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for user extensions and is guaranteed not to be used by TGeo
""" SetUserExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoMaterial::SetZ(Double_t)
@trydoc raw"""
    SetZ(this::ByRef1{TGeoMaterial}, z::Float64)::Nothing


""" SetZ(this::ByRef1{TGeoMaterial}, z::Float64)

# Wrapper of void TGeoMedium::SetCerenkovProperties(TObject *)
@trydoc raw"""
    SetCerenkovProperties(this::ByRef1{TGeoMedium}, cerenkov::ByPtr1{TObject})::Nothing


""" SetCerenkovProperties(this::ByRef1{TGeoMedium}, cerenkov::ByPtr1{TObject})

# Wrapper of void TGeoMedium::SetId(Int_t)
@trydoc raw"""
    SetId(this::ByRef1{TGeoMedium}, id::Int32)::Nothing


""" SetId(this::ByRef1{TGeoMedium}, id::Int32)

# Wrapper of void TGeoMedium::SetMaterial(TGeoMaterial *)
@trydoc raw"""
    SetMaterial(this::ByRef1{TGeoMedium}, mat::ByPtr1{TGeoMaterial})::Nothing


""" SetMaterial(this::ByRef1{TGeoMedium}, mat::ByPtr1{TGeoMaterial})

# Wrapper of void TGeoMedium::SetParam(Int_t, Double_t)
@trydoc raw"""
    SetParam(this::ByRef1{TGeoMedium}, i::Int32, val::Float64)::Nothing


""" SetParam(this::ByRef1{TGeoMedium}, i::Int32, val::Float64)

# Wrapper of TGeoNode * TGeoVolumeAssembly::AddNode(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::CxxPtr1{TGeoNode}
Add a component to the assembly.

""" AddNode(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::AddNodeOverlap(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNodeOverlap(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::Nothing
Add an overlapping node - not allowed for assemblies.

""" AddNodeOverlap(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoVolumeAssembly}, nthreads::Int32)::Nothing


""" CreateThreadData(this::ByRef1{TGeoVolumeAssembly}, nthreads::Int32)

# Wrapper of TGeoVolume * TGeoVolumeAssembly::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolumeAssembly}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Division makes no sense for assemblies.

""" Divide(this::ByRef1{TGeoVolumeAssembly}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of TGeoVolume * TGeoVolumeAssembly::Divide(TGeoVolume *, TGeoPatternFinder *, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolumeAssembly}, cell::ByPtr1{TGeoVolume}, pattern::ByPtr1{TGeoPatternFinder}, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Assign to the assembly a collection of identical volumes positioned according a predefined pattern.
The option can be spaced out or touching depending on the empty space between volumes.
""" Divide(this::ByRef1{TGeoVolumeAssembly}, cell::ByPtr1{TGeoVolume}, pattern::ByPtr1{TGeoPatternFinder}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TGeoVolumeAssembly}, option::ByCopy{String})::Nothing
draw only this volume

""" DrawOnly(this::ByRef1{TGeoVolumeAssembly}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::SetCurrentNodeIndex(Int_t)
@trydoc raw"""
    SetCurrentNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)::Nothing


""" SetCurrentNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)

# Wrapper of void TGeoVolumeAssembly::SetNextNodeIndex(Int_t)
@trydoc raw"""
    SetNextNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)::Nothing


""" SetNextNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)

# Wrapper of TGeoNode * TGeoVolumeMulti::AddNode(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::CxxPtr1{TGeoNode}
Add a new node to the list of nodes.
This is the usual method for adding daughters inside the container volume.
""" AddNode(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeMulti::AddNodeOverlap(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNodeOverlap(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::Nothing
Add a new node to the list of nodes, This node is possibly overlapping with other daughters of the volume or extruding the volume.

""" AddNodeOverlap(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeMulti::AddVolume(TGeoVolume *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume})::Nothing
Add a volume with valid shape to the list of volumes.
Copy all existing nodes to this volume
""" AddVolume(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume})

# Wrapper of TGeoVolume * TGeoVolumeMulti::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolumeMulti}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
division of multiple volumes

""" Divide(this::ByRef1{TGeoVolumeMulti}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of TGeoVolume * TGeoVolumeMulti::MakeCopyVolume(TGeoShape *)
@trydoc raw"""
    MakeCopyVolume(this::ByRef1{TGeoVolumeMulti}, newshape::ByPtr1{TGeoShape})::CxxPtr1{TGeoVolume}
Make a copy of this volume build a volume with same name, shape and medium.

""" MakeCopyVolume(this::ByRef1{TGeoVolumeMulti}, newshape::ByPtr1{TGeoShape})

# Wrapper of void TGeoVolumeMulti::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TGeoVolumeMulti}, lcolor::Int16)::Nothing
Set the line color for all components.

""" SetLineColor(this::ByRef1{TGeoVolumeMulti}, lcolor::Int16)

# Wrapper of void TGeoVolumeMulti::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TGeoVolumeMulti}, lstyle::Int16)::Nothing
Set the line style for all components.

""" SetLineStyle(this::ByRef1{TGeoVolumeMulti}, lstyle::Int16)

# Wrapper of void TGeoVolumeMulti::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TGeoVolumeMulti}, lwidth::Int16)::Nothing
Set the line width for all components.

""" SetLineWidth(this::ByRef1{TGeoVolumeMulti}, lwidth::Int16)

# Wrapper of void TGeoVolumeMulti::SetMedium(TGeoMedium *)
@trydoc raw"""
    SetMedium(this::ByRef1{TGeoVolumeMulti}, medium::ByPtr1{TGeoMedium})::Nothing
Set medium for a multiple volume.

""" SetMedium(this::ByRef1{TGeoVolumeMulti}, medium::ByPtr1{TGeoMedium})

# Wrapper of void TGeoVolumeMulti::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoVolumeMulti}, vis::Bool)::Nothing
Set visibility for all components.

""" SetVisibility(this::ByRef1{TGeoVolumeMulti}, vis::Bool)

# Wrapper of void TGeoElement::AddIsotope(TGeoIsotope *, Double_t)
@trydoc raw"""
    AddIsotope(this::ByRef1{TGeoElement}, isotope::ByPtr1{TGeoIsotope}, relativeAbundance::Float64)::Nothing
Add an isotope for this element. All isotopes have to be isotopes of the same element.

""" AddIsotope(this::ByRef1{TGeoElement}, isotope::ByPtr1{TGeoIsotope}, relativeAbundance::Float64)

# Wrapper of void TGeoElement::ComputeDerivedQuantities()
@trydoc raw"""
    ComputeDerivedQuantities(this::ByRef1{TGeoElement})::Nothing
Calculate properties for an atomic number.

""" ComputeDerivedQuantities(this::ByRef1{TGeoElement})

# Wrapper of void TGeoElement::SetDefined(Bool_t)
@trydoc raw"""
    SetDefined(this::ByRef1{TGeoElement}, flag::Bool)::Nothing


""" SetDefined(this::ByRef1{TGeoElement}, flag::Bool)

# Wrapper of void TGeoElement::SetUsed(Bool_t)
@trydoc raw"""
    SetUsed(this::ByRef1{TGeoElement}, flag::Bool)::Nothing


""" SetUsed(this::ByRef1{TGeoElement}, flag::Bool)

# Wrapper of void TGeoElementTable::AddElement(const char *, const char *, Int_t, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, a::Float64)::Nothing
Add an element to the table. Obsolete.

""" AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, a::Float64)

# Wrapper of void TGeoElementTable::AddElement(const char *, const char *, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, n::Int32, a::Float64)::Nothing
Add an element to the table.

""" AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, n::Int32, a::Float64)

# Wrapper of void TGeoElementTable::AddElement(TGeoElement *)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElement})::Nothing
Add a custom element to the table.

""" AddElement(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElement})

# Wrapper of void TGeoElementTable::AddElementRN(TGeoElementRN *)
@trydoc raw"""
    AddElementRN(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElementRN})::Nothing
Add a radionuclide to the table and map it.

""" AddElementRN(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElementRN})

# Wrapper of void TGeoElementTable::AddIsotope(TGeoIsotope *)
@trydoc raw"""
    AddIsotope(this::ByRef1{TGeoElementTable}, isotope::ByPtr1{TGeoIsotope})::Nothing
Add isotope to the table.

""" AddIsotope(this::ByRef1{TGeoElementTable}, isotope::ByPtr1{TGeoIsotope})

# Wrapper of void TGeoElementTable::BuildDefaultElements()
@trydoc raw"""
    BuildDefaultElements(this::ByRef1{TGeoElementTable})::Nothing
Creates the default element table.

""" BuildDefaultElements(this::ByRef1{TGeoElementTable})

# Wrapper of void TGeoElementTable::ExportElementsRN(const char *)
@trydoc raw"""
    ExportElementsRN(this::ByRef1{TGeoElementTable}, filename::ByCopy{String})::Nothing
Export radionuclides in a file.

""" ExportElementsRN(this::ByRef1{TGeoElementTable}, filename::ByCopy{String})

# Wrapper of TGeoElement * TGeoElementTable::GetElement(Int_t)
@trydoc raw"""
    GetElement(this::ByRef1{TGeoElementTable}, z::Int32)::CxxPtr1{TGeoElement}


""" GetElement(this::ByRef1{TGeoElementTable}, z::Int32)

# Wrapper of void TGeoElementTable::ImportElementsRN()
@trydoc raw"""
    ImportElementsRN(this::ByRef1{TGeoElementTable})::Nothing
Creates the list of radionuclides.

""" ImportElementsRN(this::ByRef1{TGeoElementTable})

# Wrapper of void TGeoElementRN::AddDecay(Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    AddDecay(this::ByRef1{TGeoElementRN}, decay::Int32, diso::Int32, branchingRatio::Float64, qValue::Float64)::Nothing
Adds a decay mode for this element.

""" AddDecay(this::ByRef1{TGeoElementRN}, decay::Int32, diso::Int32, branchingRatio::Float64, qValue::Float64)

# Wrapper of void TGeoElementRN::AddDecay(TGeoDecayChannel *)
@trydoc raw"""
    AddDecay(this::ByRef1{TGeoElementRN}, dc::ByPtr1{TGeoDecayChannel})::Nothing
Adds a decay channel to the list of decays.

""" AddDecay(this::ByRef1{TGeoElementRN}, dc::ByPtr1{TGeoDecayChannel})

# Wrapper of void TGeoElementRN::AddRatio(TGeoBatemanSol &)
@trydoc raw"""
    AddRatio(this::ByRef1{TGeoElementRN}, ratio::ByRef1{TGeoBatemanSol})::Nothing
Adds a proportion ratio to the existing one.

""" AddRatio(this::ByRef1{TGeoElementRN}, ratio::ByRef1{TGeoBatemanSol})

# Wrapper of void TGeoElementRN::FillPopulation(TObjArray *, Double_t, Double_t)
@trydoc raw"""
    FillPopulation(this::ByRef1{TGeoElementRN}, population::ByPtr1{TObjArray}, precision::Float64, factor::Float64)::Nothing
Fills the input array with the set of RN elements resulting from the decay of this one.
All element in the list will contain the time evolution of their proportion by number with respect to this element. The proportion can be retrieved via the method [TGeoElementRN!Ratio()](@ref). The precision represent the minimum cumulative branching ratio for which decay products are still taken into account.
""" FillPopulation(this::ByRef1{TGeoElementRN}, population::ByPtr1{TObjArray}, precision::Float64, factor::Float64)

# Wrapper of void TGeoElementRN::ResetRatio()
@trydoc raw"""
    ResetRatio(this::ByRef1{TGeoElementRN})::Nothing
Clears the existing ratio.

""" ResetRatio(this::ByRef1{TGeoElementRN})

# Wrapper of TGeoDecayChannel & TGeoDecayChannel::operator=(const TGeoDecayChannel &)
@trydoc raw"""
    assign(this::ByRef1{TGeoDecayChannel}, dc::ByConstRef1{TGeoDecayChannel})::CxxRef1{TGeoDecayChannel}
Assignment.
assignment operator
""" assign(this::ByRef1{TGeoDecayChannel}, dc::ByConstRef1{TGeoDecayChannel})

# Wrapper of void TGeoDecayChannel::SetDaughter(TGeoElementRN *)
@trydoc raw"""
    SetDaughter(this::ByRef1{TGeoDecayChannel}, daughter::ByPtr1{TGeoElementRN})::Nothing


""" SetDaughter(this::ByRef1{TGeoDecayChannel}, daughter::ByPtr1{TGeoElementRN})

# Wrapper of void TGeoDecayChannel::SetParent(TGeoElementRN *)
@trydoc raw"""
    SetParent(this::ByRef1{TGeoDecayChannel}, parent::ByPtr1{TGeoElementRN})::Nothing


""" SetParent(this::ByRef1{TGeoDecayChannel}, parent::ByPtr1{TGeoElementRN})

# Wrapper of void TGeoBatemanSol::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoBatemanSol}, option::ByCopy{String})::Nothing
Draw the solution of Bateman equation versus time.

""" Draw(this::ByRef1{TGeoBatemanSol}, option::ByCopy{String})

# Wrapper of void TGeoBatemanSol::FindSolution(const TObjArray *)
@trydoc raw"""
    FindSolution(this::ByRef1{TGeoBatemanSol}, array::ByConstPtr1{TObjArray})::Nothing
Find the solution for the Bateman equations corresponding to the decay chain described by an array ending with element X.
A->B->...->X Cn = SUM [Ain * exp(-LMBDi*t)]; Cn - concentration Nx/Na n - order of X in chain (A->B->X => n=3) LMBDi - decay constant for element of order i in the chain Ain = LMBD1*...*LMBD(n-1) * br1*...*br(n-1)/(LMBD1-LMBDi)...(LMBDn-LMBDi) bri - branching ratio for decay Ei->Ei+1
""" FindSolution(this::ByRef1{TGeoBatemanSol}, array::ByConstPtr1{TObjArray})

# Wrapper of void TGeoBatemanSol::Normalize(Double_t)
@trydoc raw"""
    Normalize(this::ByRef1{TGeoBatemanSol}, factor::Float64)::Nothing
Normalize all coefficients with a given factor.

""" Normalize(this::ByRef1{TGeoBatemanSol}, factor::Float64)

# Wrapper of TGeoBatemanSol & TGeoBatemanSol::operator+=(const TGeoBatemanSol &)
@trydoc raw"""
    add!(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})::CxxRef1{TGeoBatemanSol}
Addition of other solution.

""" add!(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})

# Wrapper of TGeoBatemanSol & TGeoBatemanSol::operator=(const TGeoBatemanSol &)
@trydoc raw"""
    assign(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})::CxxRef1{TGeoBatemanSol}
Assignment.

""" assign(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})

# Wrapper of void TGeoBatemanSol::SetFactor(Double_t)
@trydoc raw"""
    SetFactor(this::ByRef1{TGeoBatemanSol}, factor::Float64)::Nothing


""" SetFactor(this::ByRef1{TGeoBatemanSol}, factor::Float64)

# Wrapper of void TGeoBatemanSol::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TGeoBatemanSol}, tmin::Float64, tmax::Float64)::Nothing


""" SetRange(this::ByRef1{TGeoBatemanSol}, tmin::Float64, tmax::Float64)

# Wrapper of TGeoElementRN * TGeoElemIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TGeoElemIter})::CxxPtr1{TGeoElementRN}
Return next element.

""" Next(this::ByRef1{TGeoElemIter})

# Wrapper of TGeoElementRN * TGeoElemIter::operator()()
@trydoc raw"""
    paren(this::ByRef1{TGeoElemIter})::CxxPtr1{TGeoElementRN}
() operator.

""" paren(this::ByRef1{TGeoElemIter})

# Wrapper of TGeoElemIter & TGeoElemIter::operator=(const TGeoElemIter &)
@trydoc raw"""
    assign(this::ByRef1{TGeoElemIter}, iter::ByConstRef1{TGeoElemIter})::CxxRef1{TGeoElemIter}
Assignment.

""" assign(this::ByRef1{TGeoElemIter}, iter::ByConstRef1{TGeoElemIter})

# Wrapper of void TGeoElemIter::SetLimitRatio(Double_t)
@trydoc raw"""
    SetLimitRatio(this::ByRef1{TGeoElemIter}, limit::Float64)::Nothing


""" SetLimitRatio(this::ByRef1{TGeoElemIter}, limit::Float64)

# Wrapper of TGeoExtension * TGeoExtension::Grab()
@trydoc raw"""
    Grab(this::ByRef1{TGeoExtension})::CxxPtr1{TGeoExtension}


""" Grab(this::ByRef1{TGeoExtension})

# Wrapper of void TGeoMixture::AddElement(Double_t, Double_t, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, a::Float64, z::Float64, weight::Float64)::Nothing
add an element to the mixture using fraction by weight Check if the element is already defined

""" AddElement(this::ByRef1{TGeoMixture}, a::Float64, z::Float64, weight::Float64)

# Wrapper of void TGeoMixture::AddElement(TGeoElement *, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, weight::Float64)::Nothing
add an element to the mixture using fraction by weight

""" AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, weight::Float64)

# Wrapper of void TGeoMixture::AddElement(TGeoElement *, Int_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, natoms::Int32)::Nothing
Add a mixture element by number of atoms in the chemical formula.

""" AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, natoms::Int32)

# Wrapper of void TGeoMixture::AddElement(TGeoMaterial *, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, mat::ByPtr1{TGeoMaterial}, weight::Float64)::Nothing
Define one component of the mixture as an existing material/mixture.

""" AddElement(this::ByRef1{TGeoMixture}, mat::ByPtr1{TGeoMaterial}, weight::Float64)

# Wrapper of void TGeoMixture::ComputeDerivedQuantities()
@trydoc raw"""
    ComputeDerivedQuantities(this::ByRef1{TGeoMixture})::Nothing
Compute Derived Quantities as in Geant4.

""" ComputeDerivedQuantities(this::ByRef1{TGeoMixture})

# Wrapper of void TGeoMixture::ComputeNuclearInterLength()
@trydoc raw"""
    ComputeNuclearInterLength(this::ByRef1{TGeoMixture})::Nothing
Compute Nuclear Interaction Length based on Geant4 formula.

""" ComputeNuclearInterLength(this::ByRef1{TGeoMixture})

# Wrapper of void TGeoMixture::ComputeRadiationLength()
@trydoc raw"""
    ComputeRadiationLength(this::ByRef1{TGeoMixture})::Nothing
Compute Radiation Length based on Geant4 formula.

""" ComputeRadiationLength(this::ByRef1{TGeoMixture})

# Wrapper of TGeoMaterial * TGeoMixture::DecayMaterial(Double_t, Double_t)
@trydoc raw"""
    DecayMaterial(this::ByRef1{TGeoMixture}, time::Float64, precision::Float64)::CxxPtr1{TGeoMaterial}
Create the mixture representing the decay product of this material at a given time.
The precision represent the minimum cumulative branching ratio for which decay products are still taken into account.
""" DecayMaterial(this::ByRef1{TGeoMixture}, time::Float64, precision::Float64)

# Wrapper of void TGeoMixture::DefineElement(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, a::Float64, z::Float64, weight::Float64)::Nothing


""" DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, a::Float64, z::Float64, weight::Float64)

# Wrapper of void TGeoMixture::DefineElement(Int_t, Int_t, Int_t)
@trydoc raw"""
    DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, z::Int32, natoms::Int32)::Nothing
Define the mixture element at index iel by number of atoms in the chemical formula.

""" DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, z::Int32, natoms::Int32)

# Wrapper of void TGeoMixture::DefineElement(Int_t, TGeoElement *, Double_t)
@trydoc raw"""
    DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, elem::ByPtr1{TGeoElement}, weight::Float64)::Nothing


""" DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, elem::ByPtr1{TGeoElement}, weight::Float64)

# Wrapper of void TGeoMixture::FillMaterialEvolution(TObjArray *, Double_t)
@trydoc raw"""
    FillMaterialEvolution(this::ByRef1{TGeoMixture}, population::ByPtr1{TObjArray}, precision::Float64)::Nothing
Fills a user array with all the elements deriving from the possible decay of the top elements composing the mixture.
Each element contained by `<population>` may be a radionuclide having a Bateman solution attached. The precision represent the minimum cumulative branching ratio for which decay products are still taken into account. To visualize the time evolution of each decay product one can use: 

    TGeoElement *elem = population->At(index);
    TGeoElementRN *elemrn = 0;
    if (elem->IsRadioNuclide()) elemrn = (TGeoElementRN*)elem;

(C++ version of the code)

 One can get Ni/N1(t=0) at any moment of time. Ni is the number of atoms of one of the decay products, N1(0) is the number of atoms of the first top element at t=0. 

    Double_t fraction_weight = elemrn->Ratio()->Concentration(time);

(C++ version of the code)

 One can also display the time evolution of the fractional weight: 

    elemrn->Ratio()->Draw(option);

(C++ version of the code)
""" FillMaterialEvolution(this::ByRef1{TGeoMixture}, population::ByPtr1{TObjArray}, precision::Float64)

# Wrapper of void TGeoMixture::GetElementProp(Double_t &, Double_t &, Double_t &, Int_t)
@trydoc raw"""
    GetElementProp(this::ByRef1{TGeoMixture}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)::Nothing
Single interface to get element properties.

""" GetElementProp(this::ByRef1{TGeoMixture}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)

# Wrapper of void TGeoMixture::SetA(Double_t)
@trydoc raw"""
    SetA(this::ByRef1{TGeoMixture}, a::Float64)::Nothing


""" SetA(this::ByRef1{TGeoMixture}, a::Float64)

# Wrapper of void TGeoMixture::SetDensity(Double_t)
@trydoc raw"""
    SetDensity(this::ByRef1{TGeoMixture}, density::Float64)::Nothing


""" SetDensity(this::ByRef1{TGeoMixture}, density::Float64)

# Wrapper of void TGeoMixture::SetZ(Double_t)
@trydoc raw"""
    SetZ(this::ByRef1{TGeoMixture}, z::Float64)::Nothing


""" SetZ(this::ByRef1{TGeoMixture}, z::Float64)

# Wrapper of void TGeoPatternFinder::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternFinder}, ::Int32)::Nothing


""" cd(this::ByRef1{TGeoPatternFinder}, ::Int32)

# Wrapper of TGeoNode * TGeoPatternFinder::CdNext()
@trydoc raw"""
    CdNext(this::ByRef1{TGeoPatternFinder})::CxxPtr1{TGeoNode}
Make next node (if any) current.

""" CdNext(this::ByRef1{TGeoPatternFinder})

# Wrapper of void TGeoPatternFinder::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoPatternFinder}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoPatternFinder}, nthreads::Int32)

# Wrapper of TGeoNode * TGeoPatternFinder::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternFinder}, ::ByPtr2{Float64}, ::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}


""" FindNode(this::ByRef1{TGeoPatternFinder}, ::ByPtr2{Float64}, ::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternFinder::GetCurrent()
@trydoc raw"""
    GetCurrent(this::ByRef1{TGeoPatternFinder})::Int32
Return current index.

""" GetCurrent(this::ByRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternFinder})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetDivIndex()
@trydoc raw"""
    GetDivIndex(this::ByRef1{TGeoPatternFinder})::Int32


""" GetDivIndex(this::ByRef1{TGeoPatternFinder})

# Wrapper of TGeoMatrix * TGeoPatternFinder::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByRef1{TGeoPatternFinder})::CxxPtr1{TGeoMatrix}
Return current matrix.

""" GetMatrix(this::ByRef1{TGeoPatternFinder})

# Wrapper of TGeoNode * TGeoPatternFinder::GetNodeOffset(Int_t)
@trydoc raw"""
    GetNodeOffset(this::ByRef1{TGeoPatternFinder}, idiv::Int32)::CxxPtr1{TGeoNode}


""" GetNodeOffset(this::ByRef1{TGeoPatternFinder}, idiv::Int32)

# Wrapper of TGeoPatternFinder * TGeoPatternFinder::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternFinder}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}


""" MakeCopy(this::ByRef1{TGeoPatternFinder}, reflect::Bool)

# Wrapper of void TGeoPatternFinder::Reflect(Bool_t)
@trydoc raw"""
    Reflect(this::ByRef1{TGeoPatternFinder}, flag::Bool)::Nothing


""" Reflect(this::ByRef1{TGeoPatternFinder}, flag::Bool)

# Wrapper of void TGeoPatternFinder::SetDivIndex(Int_t)
@trydoc raw"""
    SetDivIndex(this::ByRef1{TGeoPatternFinder}, index::Int32)::Nothing


""" SetDivIndex(this::ByRef1{TGeoPatternFinder}, index::Int32)

# Wrapper of void TGeoPatternFinder::SetNext(Int_t)
@trydoc raw"""
    SetNext(this::ByRef1{TGeoPatternFinder}, index::Int32)::Nothing
Set index of next division.

""" SetNext(this::ByRef1{TGeoPatternFinder}, index::Int32)

# Wrapper of void TGeoPatternFinder::SetRange(Double_t, Double_t, Int_t)
@trydoc raw"""
    SetRange(this::ByRef1{TGeoPatternFinder}, thestart::Float64, step::Float64, ndivisions::Int32)::Nothing
Set division range. Use this method only when dividing an assembly.

""" SetRange(this::ByRef1{TGeoPatternFinder}, thestart::Float64, step::Float64, ndivisions::Int32)

# Wrapper of void TGeoPatternFinder::SetSpacedOut(Bool_t)
@trydoc raw"""
    SetSpacedOut(this::ByRef1{TGeoPatternFinder}, flag::Bool)::Nothing


""" SetSpacedOut(this::ByRef1{TGeoPatternFinder}, flag::Bool)

# Wrapper of void TGeoPatternFinder::SetVolume(TGeoVolume *)
@trydoc raw"""
    SetVolume(this::ByRef1{TGeoPatternFinder}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetVolume(this::ByRef1{TGeoPatternFinder}, vol::ByPtr1{TGeoVolume})

# Wrapper of Double_t TGeoVoxelFinder::Efficiency()
@trydoc raw"""
    Efficiency(this::ByRef1{TGeoVoxelFinder})::Float64
Compute voxelization efficiency.

""" Efficiency(this::ByRef1{TGeoVoxelFinder})

# Wrapper of Int_t * TGeoVoxelFinder::GetCheckList(const Double_t *, Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetCheckList(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, nelem::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}
get the list of daughter indices for which point is inside their bbox

""" GetCheckList(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, nelem::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of Int_t * TGeoVoxelFinder::GetNextCandidates(const Double_t *, Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetNextCandidates(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}
Returns list of new candidates in next voxel.
If NULL, nowhere to go next.
""" GetNextCandidates(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of Int_t * TGeoVoxelFinder::GetNextVoxel(const Double_t *, const Double_t *, Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetNextVoxel(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}
get the list of new candidates for the next voxel crossed by current ray printf("### GetNextVoxel\n");

""" GetNextVoxel(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of void TGeoVoxelFinder::SetInvalid(Bool_t)
@trydoc raw"""
    SetInvalid(this::ByRef1{TGeoVoxelFinder}, flag::Bool)::Nothing


""" SetInvalid(this::ByRef1{TGeoVoxelFinder}, flag::Bool)

# Wrapper of void TGeoVoxelFinder::SetNeedRebuild(Bool_t)
@trydoc raw"""
    SetNeedRebuild(this::ByRef1{TGeoVoxelFinder}, flag::Bool)::Nothing


""" SetNeedRebuild(this::ByRef1{TGeoVoxelFinder}, flag::Bool)

# Wrapper of void TGeoVoxelFinder::SortCrossedVoxels(const Double_t *, const Double_t *, TGeoStateInfo &)
@trydoc raw"""
    SortCrossedVoxels(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, td::ByRef1{TGeoStateInfo})::Nothing
get the list in the next voxel crossed by a ray

""" SortCrossedVoxels(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, td::ByRef1{TGeoStateInfo})

# Wrapper of void TGeoVoxelFinder::Voxelize(Option_t *)
@trydoc raw"""
    Voxelize(this::ByRef1{TGeoVoxelFinder}, option::ByCopy{String})::Nothing
Voxelize attached volume according to option If the volume is an assembly, make sure the bbox is computed.

""" Voxelize(this::ByRef1{TGeoVoxelFinder}, option::ByCopy{String})

# Wrapper of void TGeoPatternX::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternX}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternX}, idiv::Int32)

# Wrapper of Double_t TGeoPatternX::FindNextBoundary(Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})::Float64
Compute distance to next division layer returning the index of next section.
Point is in the frame of the divided volume.
""" FindNextBoundary(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})

# Wrapper of TGeoNode * TGeoPatternX::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Find the cell corresponding to point and next cell along dir (if asked)

""" FindNode(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternX::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternX})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternX})

# Wrapper of TGeoPatternFinder * TGeoPatternX::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternX}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternX}, reflect::Bool)

# Wrapper of TGeoPatternX & TGeoPatternX::operator=(const TGeoPatternX &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternX}, ::ByConstRef1{TGeoPatternX})::CxxRef1{TGeoPatternX}
assignment operator

""" assign(this::ByRef1{TGeoPatternX}, ::ByConstRef1{TGeoPatternX})

# Wrapper of void TGeoPatternY::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternY}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternY}, idiv::Int32)

# Wrapper of Double_t TGeoPatternY::FindNextBoundary(Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})::Float64
Compute distance to next division layer returning the index of next section.
Point is in the frame of the divided volume.
""" FindNextBoundary(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})

# Wrapper of TGeoNode * TGeoPatternY::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Find the cell corresponding to point and next cell along dir (if asked)

""" FindNode(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternY::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternY})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternY})

# Wrapper of TGeoPatternFinder * TGeoPatternY::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternY}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternY}, reflect::Bool)

# Wrapper of TGeoPatternY & TGeoPatternY::operator=(const TGeoPatternY &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternY}, ::ByConstRef1{TGeoPatternY})::CxxRef1{TGeoPatternY}
assignment operator

""" assign(this::ByRef1{TGeoPatternY}, ::ByConstRef1{TGeoPatternY})

# Wrapper of void TGeoPatternZ::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternZ}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternZ}, idiv::Int32)

# Wrapper of Double_t TGeoPatternZ::FindNextBoundary(Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})::Float64
Compute distance to next division layer returning the index of next section.
Point is in the frame of the divided volume.
""" FindNextBoundary(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})

# Wrapper of TGeoNode * TGeoPatternZ::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Find the cell corresponding to point and next cell along dir (if asked)

""" FindNode(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternZ::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternZ})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternZ})

# Wrapper of TGeoPatternFinder * TGeoPatternZ::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternZ}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternZ}, reflect::Bool)

# Wrapper of TGeoPatternZ & TGeoPatternZ::operator=(const TGeoPatternZ &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternZ}, ::ByConstRef1{TGeoPatternZ})::CxxRef1{TGeoPatternZ}
assignment operator

""" assign(this::ByRef1{TGeoPatternZ}, ::ByConstRef1{TGeoPatternZ})

# Wrapper of void TGeoPatternParaX::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternParaX}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternParaX}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternParaX::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternParaX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternParaX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternParaX::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternParaX})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternParaX})

# Wrapper of TGeoPatternFinder * TGeoPatternParaX::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternParaX}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternParaX}, reflect::Bool)

# Wrapper of TGeoPatternParaX & TGeoPatternParaX::operator=(const TGeoPatternParaX &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternParaX}, ::ByConstRef1{TGeoPatternParaX})::CxxRef1{TGeoPatternParaX}
assignment operator

""" assign(this::ByRef1{TGeoPatternParaX}, ::ByConstRef1{TGeoPatternParaX})

# Wrapper of void TGeoPatternParaY::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternParaY}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternParaY}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternParaY::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternParaY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternParaY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternParaY::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternParaY})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternParaY})

# Wrapper of TGeoPatternFinder * TGeoPatternParaY::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternParaY}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternParaY}, reflect::Bool)

# Wrapper of TGeoPatternParaY & TGeoPatternParaY::operator=(const TGeoPatternParaY &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternParaY}, ::ByConstRef1{TGeoPatternParaY})::CxxRef1{TGeoPatternParaY}
assignment operator

""" assign(this::ByRef1{TGeoPatternParaY}, ::ByConstRef1{TGeoPatternParaY})

# Wrapper of void TGeoPatternParaZ::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternParaZ}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternParaZ}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternParaZ::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternParaZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternParaZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternParaZ::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternParaZ})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternParaZ})

# Wrapper of TGeoPatternFinder * TGeoPatternParaZ::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternParaZ}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternParaZ}, reflect::Bool)

# Wrapper of TGeoPatternParaZ & TGeoPatternParaZ::operator=(const TGeoPatternParaZ &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternParaZ}, ::ByConstRef1{TGeoPatternParaZ})::CxxRef1{TGeoPatternParaZ}
assignment operator

""" assign(this::ByRef1{TGeoPatternParaZ}, ::ByConstRef1{TGeoPatternParaZ})

# Wrapper of void TGeoPatternTrapZ::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternTrapZ}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternTrapZ}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternTrapZ::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternTrapZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternTrapZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternTrapZ::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternTrapZ})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternTrapZ})

# Wrapper of TGeoPatternFinder * TGeoPatternTrapZ::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternTrapZ}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternTrapZ}, reflect::Bool)

# Wrapper of TGeoPatternTrapZ & TGeoPatternTrapZ::operator=(const TGeoPatternTrapZ &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternTrapZ}, ::ByConstRef1{TGeoPatternTrapZ})::CxxRef1{TGeoPatternTrapZ}
assignment operator

""" assign(this::ByRef1{TGeoPatternTrapZ}, ::ByConstRef1{TGeoPatternTrapZ})

# Wrapper of void TGeoPatternCylR::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternCylR}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternCylR}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternCylR::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternCylR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternCylR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternCylR::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternCylR})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternCylR})

# Wrapper of TGeoPatternFinder * TGeoPatternCylR::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternCylR}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternCylR}, reflect::Bool)

# Wrapper of TGeoPatternCylR & TGeoPatternCylR::operator=(const TGeoPatternCylR &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternCylR}, ::ByConstRef1{TGeoPatternCylR})::CxxRef1{TGeoPatternCylR}
assignment operator

""" assign(this::ByRef1{TGeoPatternCylR}, ::ByConstRef1{TGeoPatternCylR})

# Wrapper of void TGeoPatternCylPhi::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternCylPhi}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternCylPhi}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternCylPhi::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternCylPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternCylPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternCylPhi::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternCylPhi})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternCylPhi})

# Wrapper of TGeoPatternFinder * TGeoPatternCylPhi::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternCylPhi}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternCylPhi}, reflect::Bool)

# Wrapper of void TGeoPatternSphR::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternSphR}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternSphR}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternSphR::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternSphR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternSphR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternSphR::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternSphR})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternSphR})

# Wrapper of TGeoPatternFinder * TGeoPatternSphR::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternSphR}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternSphR}, reflect::Bool)

# Wrapper of TGeoPatternSphR & TGeoPatternSphR::operator=(const TGeoPatternSphR &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternSphR}, ::ByConstRef1{TGeoPatternSphR})::CxxRef1{TGeoPatternSphR}
assignment operator

""" assign(this::ByRef1{TGeoPatternSphR}, ::ByConstRef1{TGeoPatternSphR})

# Wrapper of void TGeoPatternSphTheta::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternSphTheta}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternSphTheta}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternSphTheta::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternSphTheta}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternSphTheta}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternSphTheta::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternSphTheta})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternSphTheta})

# Wrapper of TGeoPatternFinder * TGeoPatternSphTheta::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternSphTheta}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternSphTheta}, reflect::Bool)

# Wrapper of TGeoPatternSphTheta & TGeoPatternSphTheta::operator=(const TGeoPatternSphTheta &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternSphTheta}, ::ByConstRef1{TGeoPatternSphTheta})::CxxRef1{TGeoPatternSphTheta}
assignment operator

""" assign(this::ByRef1{TGeoPatternSphTheta}, ::ByConstRef1{TGeoPatternSphTheta})

# Wrapper of void TGeoPatternSphPhi::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternSphPhi}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternSphPhi}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternSphPhi::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternSphPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternSphPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternSphPhi::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternSphPhi})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternSphPhi})

# Wrapper of TGeoPatternFinder * TGeoPatternSphPhi::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternSphPhi}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternSphPhi}, reflect::Bool)

# Wrapper of void TGeoPatternHoneycomb::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternHoneycomb}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternHoneycomb}, idiv::Int32)

# Wrapper of TGeoNode * TGeoPatternHoneycomb::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternHoneycomb}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternHoneycomb}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternHoneycomb::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternHoneycomb}, ::Bool)::CxxPtr1{TGeoPatternFinder}


""" MakeCopy(this::ByRef1{TGeoPatternHoneycomb}, ::Bool)

# Wrapper of void TGeoNodeMatrix::SetMatrix(const TGeoMatrix *)
@trydoc raw"""
    SetMatrix(this::ByRef1{TGeoNodeMatrix}, matrix::ByConstPtr1{TGeoMatrix})::Nothing
Matrix setter.

""" SetMatrix(this::ByRef1{TGeoNodeMatrix}, matrix::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoNodeOffset::SetFinder(TGeoPatternFinder *)
@trydoc raw"""
    SetFinder(this::ByRef1{TGeoNodeOffset}, finder::ByPtr1{TGeoPatternFinder})::Nothing


""" SetFinder(this::ByRef1{TGeoNodeOffset}, finder::ByPtr1{TGeoPatternFinder})

# Wrapper of TGeoNode * TGeoIterator::Next()
@trydoc raw"""
    Next(this::ByRef1{TGeoIterator})::CxxPtr1{TGeoNode}
Returns next node.

""" Next(this::ByRef1{TGeoIterator})

# Wrapper of TGeoNode * TGeoIterator::operator()()
@trydoc raw"""
    paren(this::ByRef1{TGeoIterator})::CxxPtr1{TGeoNode}
Returns next node.

""" paren(this::ByRef1{TGeoIterator})

# Wrapper of TGeoIterator & TGeoIterator::operator=(const TGeoIterator &)
@trydoc raw"""
    assign(this::ByRef1{TGeoIterator}, iter::ByConstRef1{TGeoIterator})::CxxRef1{TGeoIterator}
Assignment.

""" assign(this::ByRef1{TGeoIterator}, iter::ByConstRef1{TGeoIterator})

# Wrapper of void TGeoIterator::Reset(TGeoVolume *)
@trydoc raw"""
    Reset(this::ByRef1{TGeoIterator}, top::ByPtr1{TGeoVolume})::Nothing
Resets the iterator for volume TOP.

""" Reset(this::ByRef1{TGeoIterator}, top::ByPtr1{TGeoVolume})

# Wrapper of void TGeoIterator::SetPluginAutoexec(Bool_t)
@trydoc raw"""
    SetPluginAutoexec(this::ByRef1{TGeoIterator}, mode::Bool)::Nothing


""" SetPluginAutoexec(this::ByRef1{TGeoIterator}, mode::Bool)

# Wrapper of void TGeoIterator::SetTopName(const char *)
@trydoc raw"""
    SetTopName(this::ByRef1{TGeoIterator}, name::ByCopy{String})::Nothing
Set the top name for path.

""" SetTopName(this::ByRef1{TGeoIterator}, name::ByCopy{String})

# Wrapper of void TGeoIterator::SetType(Int_t)
@trydoc raw"""
    SetType(this::ByRef1{TGeoIterator}, type::Int32)::Nothing


""" SetType(this::ByRef1{TGeoIterator}, type::Int32)

# Wrapper of void TGeoIterator::SetUserPlugin(TGeoIteratorPlugin *)
@trydoc raw"""
    SetUserPlugin(this::ByRef1{TGeoIterator}, plugin::ByPtr1{TGeoIteratorPlugin})::Nothing
Set a plugin.

""" SetUserPlugin(this::ByRef1{TGeoIterator}, plugin::ByPtr1{TGeoIteratorPlugin})

# Wrapper of void TGeoIterator::Skip()
@trydoc raw"""
    Skip(this::ByRef1{TGeoIterator})::Nothing
Stop iterating the current branch.
The iteration of the next node will behave as if the branch starting from the current node (included) is not existing.
""" Skip(this::ByRef1{TGeoIterator})

# Wrapper of void TGeoIterator::Up()
@trydoc raw"""
    Up(this::ByRef1{TGeoIterator})::Nothing


""" Up(this::ByRef1{TGeoIterator})

# Wrapper of void TGeoIteratorPlugin::ProcessNode()
@trydoc raw"""
    ProcessNode(this::ByRef1{TGeoIteratorPlugin})::Nothing


""" ProcessNode(this::ByRef1{TGeoIteratorPlugin})

# Wrapper of void TGeoIteratorPlugin::SetIterator(const TGeoIterator *)
@trydoc raw"""
    SetIterator(this::ByRef1{TGeoIteratorPlugin}, iter::ByConstPtr1{TGeoIterator})::Nothing


""" SetIterator(this::ByRef1{TGeoIteratorPlugin}, iter::ByConstPtr1{TGeoIterator})

# Wrapper of void TGeoPolygon::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoPolygon}, option::ByCopy{String})::Nothing
Draw the polygon.

""" Draw(this::ByRef1{TGeoPolygon}, option::ByCopy{String})

# Wrapper of void TGeoPolygon::FinishPolygon()
@trydoc raw"""
    FinishPolygon(this::ByRef1{TGeoPolygon})::Nothing
Decompose polygon in a convex outscribed part and a list of daughter polygons that have to be subtracted to get the actual one.

""" FinishPolygon(this::ByRef1{TGeoPolygon})

# Wrapper of Double_t * TGeoPolygon::GetX()
@trydoc raw"""
    GetX(this::ByRef1{TGeoPolygon})::CxxPtr2{Float64}


""" GetX(this::ByRef1{TGeoPolygon})

# Wrapper of Double_t * TGeoPolygon::GetY()
@trydoc raw"""
    GetY(this::ByRef1{TGeoPolygon})::CxxPtr2{Float64}


""" GetY(this::ByRef1{TGeoPolygon})

# Wrapper of void TGeoPolygon::SetConvex(Bool_t)
@trydoc raw"""
    SetConvex(this::ByRef1{TGeoPolygon}, flag::Bool)::Nothing


""" SetConvex(this::ByRef1{TGeoPolygon}, flag::Bool)

# Wrapper of void TGeoPolygon::SetNextIndex(Int_t)
@trydoc raw"""
    SetNextIndex(this::ByRef1{TGeoPolygon}, index::Int32)::Nothing
Sets the next polygone index.
If index<0 sets all indices consecutive in increasing order.
""" SetNextIndex(this::ByRef1{TGeoPolygon}, index::Int32)

# Wrapper of void TGeoPolygon::SetXY(Double_t *, Double_t *)
@trydoc raw"""
    SetXY(this::ByRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})::Nothing
Set X/Y array pointer for the polygon and daughters.

""" SetXY(this::ByRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})

# Wrapper of void TGeoCacheState::SetState(Int_t, Int_t, Int_t, Bool_t, Double_t *)
@trydoc raw"""
    SetState(this::ByRef1{TGeoCacheState}, level::Int32, startlevel::Int32, nmany::Int32, ovlp::Bool, point::ByPtr2{Float64})::Nothing
Fill current modeller state.

""" SetState(this::ByRef1{TGeoCacheState}, level::Int32, startlevel::Int32, nmany::Int32, ovlp::Bool, point::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::BuildIdArray()
@trydoc raw"""
    BuildIdArray(this::ByRef1{TGeoNodeCache})::Nothing
Builds node id array.

""" BuildIdArray(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::BuildInfoBranch()
@trydoc raw"""
    BuildInfoBranch(this::ByRef1{TGeoNodeCache})::Nothing
Builds info branch. Navigation is possible only after this step.

""" BuildInfoBranch(this::ByRef1{TGeoNodeCache})

# Wrapper of Bool_t TGeoNodeCache::CdDown(Int_t)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNodeCache}, index::Int32)::Bool
Make daughter INDEX of current node the active state. Compute global_ matrix.

""" CdDown(this::ByRef1{TGeoNodeCache}, index::Int32)

# Wrapper of Bool_t TGeoNodeCache::CdDown(TGeoNode *)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNodeCache}, node::ByPtr1{TGeoNode})::Bool
Make daughter INDEX of current node the active state. Compute global_ matrix.

""" CdDown(this::ByRef1{TGeoNodeCache}, node::ByPtr1{TGeoNode})

# Wrapper of void TGeoNodeCache::CdNode(Int_t)
@trydoc raw"""
    CdNode(this::ByRef1{TGeoNodeCache}, nodeid::Int32)::Nothing
Change current path to point to the node having this id.
Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)
""" CdNode(this::ByRef1{TGeoNodeCache}, nodeid::Int32)

# Wrapper of void TGeoNodeCache::CdTop()
@trydoc raw"""
    CdTop(this::ByRef1{TGeoNodeCache})::Nothing


""" CdTop(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::CdUp()
@trydoc raw"""
    CdUp(this::ByRef1{TGeoNodeCache})::Nothing
Make mother of current node the active state.

""" CdUp(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::FillIdBranch(const Int_t *, Int_t)
@trydoc raw"""
    FillIdBranch(this::ByRef1{TGeoNodeCache}, br::ByConstPtr2{Int32}, startlevel::Int32)::Nothing


""" FillIdBranch(this::ByRef1{TGeoNodeCache}, br::ByConstPtr2{Int32}, startlevel::Int32)

# Wrapper of TGeoStateInfo * TGeoNodeCache::GetInfo()
@trydoc raw"""
    GetInfo(this::ByRef1{TGeoNodeCache})::CxxPtr1{TGeoStateInfo}
Get next state info pointer.

""" GetInfo(this::ByRef1{TGeoNodeCache})

# Wrapper of TGeoStateInfo * TGeoNodeCache::GetMakePWInfo(Int_t)
@trydoc raw"""
    GetMakePWInfo(this::ByRef1{TGeoNodeCache}, nd::Int32)::CxxPtr1{TGeoStateInfo}
Get the PW info, if none create one.

""" GetMakePWInfo(this::ByRef1{TGeoNodeCache}, nd::Int32)

# Wrapper of const char * TGeoNodeCache::GetPath()
@trydoc raw"""
    GetPath(this::ByRef1{TGeoNodeCache})::ByCopy{String}
Returns the current geometry path.

""" GetPath(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::PopDummy(Int_t)
@trydoc raw"""
    PopDummy(this::ByRef1{TGeoNodeCache}, ipop::Int32)::Nothing


""" PopDummy(this::ByRef1{TGeoNodeCache}, ipop::Int32)

# Wrapper of Bool_t TGeoNodeCache::PopState(Int_t &, Double_t *)
@trydoc raw"""
    PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, point::ByPtr2{Float64})::Bool
Pop next state/point from heap.

""" PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, point::ByPtr2{Float64})

# Wrapper of Bool_t TGeoNodeCache::PopState(Int_t &, Int_t, Double_t *)
@trydoc raw"""
    PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, level::Int32, point::ByPtr2{Float64})::Bool
Pop next state/point from heap and restore matrices starting from LEVEL.

""" PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, level::Int32, point::ByPtr2{Float64})

# Wrapper of Int_t TGeoNodeCache::PushState(Bool_t, Int_t, Int_t, Double_t *)
@trydoc raw"""
    PushState(this::ByRef1{TGeoNodeCache}, ovlp::Bool, ntmany::Int32, startlevel::Int32, point::ByPtr2{Float64})::Int32
Push current state into heap.

""" PushState(this::ByRef1{TGeoNodeCache}, ovlp::Bool, ntmany::Int32, startlevel::Int32, point::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TGeoNodeCache})::Nothing


""" Refresh(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::ReleaseInfo()
@trydoc raw"""
    ReleaseInfo(this::ByRef1{TGeoNodeCache})::Nothing
Release last used state info pointer.

""" ReleaseInfo(this::ByRef1{TGeoNodeCache})

# Wrapper of Bool_t TGeoNodeCache::RestoreState(Int_t &, TGeoCacheState *, Double_t *)
@trydoc raw"""
    RestoreState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, state::ByPtr1{TGeoCacheState}, point::ByPtr2{Float64})::Bool
Pop next state/point from a backed-up state.

""" RestoreState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, state::ByPtr1{TGeoCacheState}, point::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoCompositeShape})::Nothing
compute bounding box of the sphere

""" ComputeBBox(this::ByRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Computes normal vector in POINT to the composite shape.

""" ComputeNormal(this::ByRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoCompositeShape::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoCompositeShape}, nthreads::Int32)::Nothing
Needed just for cleanup.

""" CreateThreadData(this::ByRef1{TGeoCompositeShape}, nthreads::Int32)

# Wrapper of Int_t TGeoCompositeShape::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoCompositeShape}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each corner.

""" DistancetoPrimitive(this::ByRef1{TGeoCompositeShape}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoCompositeShape::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoCompositeShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide all range of iaxis in range/step cells.

""" Divide(this::ByRef1{TGeoCompositeShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoCompositeShape::MakeNode(const char *)
@trydoc raw"""
    MakeNode(this::ByRef1{TGeoCompositeShape}, expression::ByCopy{String})::Nothing
Make a boolean node according to the top level boolean operation of expression.
Propagates signal to branches until expression is fully decomposed. printf("Making node for : %s\n", expression);
""" MakeNode(this::ByRef1{TGeoCompositeShape}, expression::ByCopy{String})

# Wrapper of void TGeoCompositeShape::RegisterYourself()
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoCompositeShape})::Nothing
Register the shape and all components to [TGeoManager](@ref) class.

""" RegisterYourself(this::ByRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoCompositeShape}, param::ByPtr2{Float64})::Nothing
Set dimensions based on the array of parameters param[0] - half-length in x param[1] - half-length in y param[2] - half-length in z.

""" SetDimensions(this::ByRef1{TGeoCompositeShape}, param::ByPtr2{Float64})

# Wrapper of void TGeoCone::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoCone})::Nothing
compute bounding box of the sphere

""" ComputeBBox(this::ByRef1{TGeoCone})

# Wrapper of void TGeoCone::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoCone::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoCone::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoCone}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoCone}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoCone::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoCone}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this cone shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For Z division creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoCone}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoCone::SetConeDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetConeDimensions(this::ByRef1{TGeoCone}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::Nothing
Set cone dimensions.

""" SetConeDimensions(this::ByRef1{TGeoCone}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of void TGeoCone::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoCone}, param::ByPtr2{Float64})::Nothing
Set cone dimensions from an array.

""" SetDimensions(this::ByRef1{TGeoCone}, param::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::AfterStreamer()
@trydoc raw"""
    AfterStreamer(this::ByRef1{TGeoConeSeg})::Nothing
Function called after streaming an object of this class.

""" AfterStreamer(this::ByRef1{TGeoConeSeg})

# Wrapper of void TGeoConeSeg::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoConeSeg})::Nothing
compute bounding box of the tube segment

""" ComputeBBox(this::ByRef1{TGeoConeSeg})

# Wrapper of void TGeoConeSeg::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoConeSeg::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoConeSeg}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoConeSeg}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoConeSeg::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoConeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this cone segment shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For Z division creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoConeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoConeSeg::SetConsDimensions(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetConsDimensions(this::ByRef1{TGeoConeSeg}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::Nothing
Set dimensions of the cone segment.

""" SetConsDimensions(this::ByRef1{TGeoConeSeg}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoConeSeg::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoConeSeg}, param::ByPtr2{Float64})::Nothing
Set dimensions of the cone segment from an array.

""" SetDimensions(this::ByRef1{TGeoConeSeg}, param::ByPtr2{Float64})

# Wrapper of void TGeoTube::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTube})::Nothing
compute bounding box of the tube

""" ComputeBBox(this::ByRef1{TGeoTube})

# Wrapper of void TGeoTube::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTube::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoTube::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTube}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoTube}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoTube::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTube}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this tube shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For radial division creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTube}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoTube::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTube}, param::ByPtr2{Float64})::Nothing
Set tube dimensions starting from a list.

""" SetDimensions(this::ByRef1{TGeoTube}, param::ByPtr2{Float64})

# Wrapper of void TGeoTube::SetTubeDimensions(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTubeDimensions(this::ByRef1{TGeoTube}, rmin::Float64, rmax::Float64, dz::Float64)::Nothing
Set tube dimensions.

""" SetTubeDimensions(this::ByRef1{TGeoTube}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of void TGeoTubeSeg::AfterStreamer()
@trydoc raw"""
    AfterStreamer(this::ByRef1{TGeoTubeSeg})::Nothing
Function called after streaming an object of this class.

""" AfterStreamer(this::ByRef1{TGeoTubeSeg})

# Wrapper of void TGeoTubeSeg::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTubeSeg})::Nothing
compute bounding box of the tube segment

""" ComputeBBox(this::ByRef1{TGeoTubeSeg})

# Wrapper of void TGeoTubeSeg::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoTubeSeg::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTubeSeg}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoTubeSeg}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoTubeSeg::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTubeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this tube segment shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For radialdivision creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTubeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoTubeSeg::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTubeSeg}, param::ByPtr2{Float64})::Nothing
Set dimensions of the tube segment starting from a list.

""" SetDimensions(this::ByRef1{TGeoTubeSeg}, param::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::SetTubsDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTubsDimensions(this::ByRef1{TGeoTubeSeg}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::Nothing
Set dimensions of the tube segment.
The segment will be from phiStart to phiEnd expressed in degree.
""" SetTubsDimensions(this::ByRef1{TGeoTubeSeg}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoCtub::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoCtub})::Nothing
compute minimum bounding box of the ctub

""" ComputeBBox(this::ByRef1{TGeoCtub})

# Wrapper of void TGeoCtub::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoCtub::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of TGeoVolume * TGeoCtub::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoCtub}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the tube along one axis.

""" Divide(this::ByRef1{TGeoCtub}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoCtub::SetCtubDimensions(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCtubDimensions(this::ByRef1{TGeoCtub}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)::Nothing
set dimensions of a cut tube

""" SetCtubDimensions(this::ByRef1{TGeoCtub}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)

# Wrapper of void TGeoCtub::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoCtub}, param::ByPtr2{Float64})::Nothing
Set dimensions of the cut tube starting from a list.

""" SetDimensions(this::ByRef1{TGeoCtub}, param::ByPtr2{Float64})

# Wrapper of void TGeoEltu::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoEltu})::Nothing
compute bounding box of the tube

""" ComputeBBox(this::ByRef1{TGeoEltu})

# Wrapper of void TGeoEltu::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoEltu::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoEltu::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoEltu}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex

""" DistancetoPrimitive(this::ByRef1{TGeoEltu}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoEltu::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoEltu}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the shape along one axis.

""" Divide(this::ByRef1{TGeoEltu}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoEltu::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoEltu}, param::ByPtr2{Float64})::Nothing
Set shape dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoEltu}, param::ByPtr2{Float64})

# Wrapper of void TGeoEltu::SetEltuDimensions(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetEltuDimensions(this::ByRef1{TGeoEltu}, a::Float64, b::Float64, dz::Float64)::Nothing
Set dimensions of the elliptical tube.

""" SetEltuDimensions(this::ByRef1{TGeoEltu}, a::Float64, b::Float64, dz::Float64)

# Wrapper of TGeoExtension * TGeoRCExtension::Grab()
@trydoc raw"""
    Grab(this::ByRef1{TGeoRCExtension})::CxxPtr1{TGeoExtension}


""" Grab(this::ByRef1{TGeoRCExtension})

# Wrapper of void TGeoRCExtension::SetUserObject(TObject *)
@trydoc raw"""
    SetUserObject(this::ByRef1{TGeoRCExtension}, obj::ByPtr1{TObject})::Nothing


""" SetUserObject(this::ByRef1{TGeoRCExtension}, obj::ByPtr1{TObject})

# Wrapper of void TVirtualMagField::Field(const Double_t *, Double_t *)
@trydoc raw"""
    Field(this::ByRef1{TVirtualMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})::Nothing


""" Field(this::ByRef1{TVirtualMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})

# Wrapper of void TGeoUniformMagField::Field(const Double_t *, Double_t *)
@trydoc raw"""
    Field(this::ByRef1{TGeoUniformMagField}, ::ByConstPtr2{Float64}, B::ByPtr2{Float64})::Nothing


""" Field(this::ByRef1{TGeoUniformMagField}, ::ByConstPtr2{Float64}, B::ByPtr2{Float64})

# Wrapper of void TGeoUniformMagField::SetFieldValue(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetFieldValue(this::ByRef1{TGeoUniformMagField}, Bx::Float64, By::Float64, Bz::Float64)::Nothing


""" SetFieldValue(this::ByRef1{TGeoUniformMagField}, Bx::Float64, By::Float64, Bz::Float64)

# Wrapper of void TGeoGlobalMagField::Field(const Double_t *, Double_t *)
@trydoc raw"""
    Field(this::ByRef1{TGeoGlobalMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})::Nothing


""" Field(this::ByRef1{TGeoGlobalMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})

# Wrapper of Bool_t TGeoGlobalMagField::IsLocked()
@trydoc raw"""
    IsLocked(this::ByRef1{TGeoGlobalMagField})::Bool


""" IsLocked(this::ByRef1{TGeoGlobalMagField})

# Wrapper of void TGeoGlobalMagField::Lock()
@trydoc raw"""
    Lock(this::ByRef1{TGeoGlobalMagField})::Nothing
Locks the global_ magnetic field if this is set. Cannot be unlocked.

""" Lock(this::ByRef1{TGeoGlobalMagField})

# Wrapper of void TGeoGlobalMagField::SetField(TVirtualMagField *)
@trydoc raw"""
    SetField(this::ByRef1{TGeoGlobalMagField}, field::ByPtr1{TVirtualMagField})::Nothing
Field setter. Deletes previous field if any. Acts only if fLock=kFALSE.

""" SetField(this::ByRef1{TGeoGlobalMagField}, field::ByPtr1{TVirtualMagField})

# Wrapper of void TGeoHalfSpace::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoHalfSpace})::Nothing
Compute bounding box - nothing to do in this case.

""" ComputeBBox(this::ByRef1{TGeoHalfSpace})

# Wrapper of void TGeoHalfSpace::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoHalfSpace::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoHalfSpace::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoHalfSpace}, px::Int32, py::Int32)::Int32
A half-space does not have a mesh primitive.

""" DistancetoPrimitive(this::ByRef1{TGeoHalfSpace}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoHalfSpace::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoHalfSpace}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the shape along one axis.

""" Divide(this::ByRef1{TGeoHalfSpace}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t * TGeoHalfSpace::GetNorm()
@trydoc raw"""
    GetNorm(this::ByRef1{TGeoHalfSpace})::CxxPtr2{Float64}


""" GetNorm(this::ByRef1{TGeoHalfSpace})

# Wrapper of Double_t * TGeoHalfSpace::GetPoint()
@trydoc raw"""
    GetPoint(this::ByRef1{TGeoHalfSpace})::CxxPtr2{Float64}


""" GetPoint(this::ByRef1{TGeoHalfSpace})

# Wrapper of void TGeoHalfSpace::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoHalfSpace}, param::ByPtr2{Float64})::Nothing
Set half-space parameters as stored in an array.

""" SetDimensions(this::ByRef1{TGeoHalfSpace}, param::ByPtr2{Float64})

# Wrapper of void TGeoHelix::InitDirection(Double_t *, Bool_t)
@trydoc raw"""
    InitDirection(this::ByRef1{TGeoHelix}, dir::ByPtr2{Float64}, is_normalized::Bool)::Nothing
Initialize particle direction (tangent on the helix in initial point)

""" InitDirection(this::ByRef1{TGeoHelix}, dir::ByPtr2{Float64}, is_normalized::Bool)

# Wrapper of void TGeoHelix::InitDirection(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    InitDirection(this::ByRef1{TGeoHelix}, dirx::Float64, diry::Float64, dirz::Float64, is_normalized::Bool)::Nothing
Initialize particle direction (tangent on the helix in initial point)

""" InitDirection(this::ByRef1{TGeoHelix}, dirx::Float64, diry::Float64, dirz::Float64, is_normalized::Bool)

# Wrapper of void TGeoHelix::InitPoint(Double_t *)
@trydoc raw"""
    InitPoint(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64})::Nothing
Set initial point on the helix.

""" InitPoint(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64})

# Wrapper of void TGeoHelix::InitPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    InitPoint(this::ByRef1{TGeoHelix}, x0::Float64, y0::Float64, z0::Float64)::Nothing
Initialize coordinates of a point on the helix.

""" InitPoint(this::ByRef1{TGeoHelix}, x0::Float64, y0::Float64, z0::Float64)

# Wrapper of void TGeoHelix::ResetStep()
@trydoc raw"""
    ResetStep(this::ByRef1{TGeoHelix})::Nothing
Reset current point/direction to initial values.

""" ResetStep(this::ByRef1{TGeoHelix})

# Wrapper of void TGeoHelix::SetCharge(Int_t)
@trydoc raw"""
    SetCharge(this::ByRef1{TGeoHelix}, charge::Int32)::Nothing
Positive charge means left-handed helix.

""" SetCharge(this::ByRef1{TGeoHelix}, charge::Int32)

# Wrapper of void TGeoHelix::SetField(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    SetField(this::ByRef1{TGeoHelix}, bx::Float64, by::Float64, bz::Float64, is_normalized::Bool)::Nothing
Initialize particle direction (tangent on the helix in initial point)

""" SetField(this::ByRef1{TGeoHelix}, bx::Float64, by::Float64, bz::Float64, is_normalized::Bool)

# Wrapper of void TGeoHelix::SetHelixStep(Double_t)
@trydoc raw"""
    SetHelixStep(this::ByRef1{TGeoHelix}, hstep::Float64)::Nothing
Set Z step of the helix on a complete turn. Positive or null.

""" SetHelixStep(this::ByRef1{TGeoHelix}, hstep::Float64)

# Wrapper of void TGeoHelix::SetXYcurvature(Double_t)
@trydoc raw"""
    SetXYcurvature(this::ByRef1{TGeoHelix}, curvature::Float64)::Nothing
Set XY curvature: c = 1/Rxy.

""" SetXYcurvature(this::ByRef1{TGeoHelix}, curvature::Float64)

# Wrapper of void TGeoHelix::Step(Double_t)
@trydoc raw"""
    Step(this::ByRef1{TGeoHelix}, step::Float64)::Nothing
Make a step from current point along the helix and compute new point, direction and angle To reach a plane/ shape boundary, one has to:
1. Compute the safety to the plane/boundary
2. Define / update a helix according local_ field and particle state (position, direction, charge)
3. Compute the magnetic safety (maximum distance for which the field can be considered constant)
4. Call [TGeoHelix!Step()](@ref) having as argument the minimum between 1. and 3.
5. Repeat from 1. until the step to be made is small enough.
6. Add to the total step the distance along a straight line from the last point to the plane/shape boundary
""" Step(this::ByRef1{TGeoHelix}, step::Float64)

# Wrapper of Double_t TGeoHelix::StepToPlane(Double_t *, Double_t *)
@trydoc raw"""
    StepToPlane(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64}, norm::ByPtr2{Float64})::Float64
Propagate initial point up to a given Z position in MARS.

""" StepToPlane(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoHelix::UpdateHelix()
@trydoc raw"""
    UpdateHelix(this::ByRef1{TGeoHelix})::Nothing
Update the local_ helix matrix.

""" UpdateHelix(this::ByRef1{TGeoHelix})

# Wrapper of void TGeoHype::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoHype})::Nothing
Compute bounding box of the hyperboloid.

""" ComputeBBox(this::ByRef1{TGeoHype})

# Wrapper of void TGeoHype::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoHype::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoHype::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoHype}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoHype}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoHype::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoHype}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Cannot divide hyperboloids.

""" Divide(this::ByRef1{TGeoHype}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoHype::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoHype}, param::ByPtr2{Float64})::Nothing
Set dimensions of the hyperboloid starting from an array.
- param[0] = dz
- param[1] = rin
- param[2] = stin
- param[3] = rout
- param[4] = stout
""" SetDimensions(this::ByRef1{TGeoHype}, param::ByPtr2{Float64})

# Wrapper of void TGeoHype::SetHypeDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetHypeDimensions(this::ByRef1{TGeoHype}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)::Nothing
Set dimensions of the hyperboloid.

""" SetHypeDimensions(this::ByRef1{TGeoHype}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)

# Wrapper of TGeoNavigator * TGeoNavigatorArray::AddNavigator()
@trydoc raw"""
    AddNavigator(this::ByRef1{TGeoNavigatorArray})::CxxPtr1{TGeoNavigator}
Add a new navigator to the array.

""" AddNavigator(this::ByRef1{TGeoNavigatorArray})

# Wrapper of TGeoNavigator * TGeoNavigatorArray::SetCurrentNavigator(Int_t)
@trydoc raw"""
    SetCurrentNavigator(this::ByRef1{TGeoNavigatorArray}, inav::Int32)::CxxPtr1{TGeoNavigator}


""" SetCurrentNavigator(this::ByRef1{TGeoNavigatorArray}, inav::Int32)

# Wrapper of void TGeoRegion::AddCut(const char *, Double_t)
@trydoc raw"""
    AddCut(this::ByRef1{TGeoRegion}, name::ByCopy{String}, cut::Float64)::Nothing
Add cut to the region.

""" AddCut(this::ByRef1{TGeoRegion}, name::ByCopy{String}, cut::Float64)

# Wrapper of void TGeoRegion::AddCut(const TGeoRegionCut &)
@trydoc raw"""
    AddCut(this::ByRef1{TGeoRegion}, regioncut::ByConstRef1{TGeoRegionCut})::Nothing
Add an identical cut to the region.

""" AddCut(this::ByRef1{TGeoRegion}, regioncut::ByConstRef1{TGeoRegionCut})

# Wrapper of bool TGeoRegion::AddVolume(const char *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoRegion}, name::ByCopy{String})::Bool
Add an existing volume to the region.

""" AddVolume(this::ByRef1{TGeoRegion}, name::ByCopy{String})

# Wrapper of void TGeoRegion::AddVolume(TGeoVolume *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoRegion}, vol::ByPtr1{TGeoVolume})::Nothing


""" AddVolume(this::ByRef1{TGeoRegion}, vol::ByPtr1{TGeoVolume})

# Wrapper of TGeoRegion & TGeoRegion::operator=(const TGeoRegion &)
@trydoc raw"""
    assign(this::ByRef1{TGeoRegion}, other::ByConstRef1{TGeoRegion})::CxxRef1{TGeoRegion}
Assignment operator.

""" assign(this::ByRef1{TGeoRegion}, other::ByConstRef1{TGeoRegion})

# Wrapper of TVirtualGeoTrack * TVirtualGeoTrack::AddDaughter(Int_t, Int_t, TObject *)
@trydoc raw"""
    AddDaughter(this::ByRef1{TVirtualGeoTrack}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::CxxPtr1{TVirtualGeoTrack}


""" AddDaughter(this::ByRef1{TVirtualGeoTrack}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of Int_t TVirtualGeoTrack::AddDaughter(TVirtualGeoTrack *)
@trydoc raw"""
    AddDaughter(this::ByRef1{TVirtualGeoTrack}, other::ByPtr1{TVirtualGeoTrack})::Int32


""" AddDaughter(this::ByRef1{TVirtualGeoTrack}, other::ByPtr1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::AddPoint(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    AddPoint(this::ByRef1{TVirtualGeoTrack}, x::Float64, y::Float64, z::Float64, t::Float64)::Nothing


""" AddPoint(this::ByRef1{TVirtualGeoTrack}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of void TVirtualGeoTrack::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})

# Wrapper of void TVirtualGeoTrack::PaintCollect(Double_t, Double_t *)
@trydoc raw"""
    PaintCollect(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})::Nothing


""" PaintCollect(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})

# Wrapper of void TVirtualGeoTrack::PaintCollectTrack(Double_t, Double_t *)
@trydoc raw"""
    PaintCollectTrack(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})::Nothing


""" PaintCollectTrack(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})

# Wrapper of void TVirtualGeoTrack::PaintTrack(Option_t *)
@trydoc raw"""
    PaintTrack(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})::Nothing


""" PaintTrack(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})

# Wrapper of void TVirtualGeoTrack::ResetTrack()
@trydoc raw"""
    ResetTrack(this::ByRef1{TVirtualGeoTrack})::Nothing


""" ResetTrack(this::ByRef1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::SetId(Int_t)
@trydoc raw"""
    SetId(this::ByRef1{TVirtualGeoTrack}, id::Int32)::Nothing


""" SetId(this::ByRef1{TVirtualGeoTrack}, id::Int32)

# Wrapper of void TVirtualGeoTrack::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TVirtualGeoTrack}, name::ByCopy{String})::Nothing
Set a default name for this track.

""" SetName(this::ByRef1{TVirtualGeoTrack}, name::ByCopy{String})

# Wrapper of void TVirtualGeoTrack::SetParent(TVirtualGeoTrack *)
@trydoc raw"""
    SetParent(this::ByRef1{TVirtualGeoTrack}, parent::ByPtr1{TVirtualGeoTrack})::Nothing


""" SetParent(this::ByRef1{TVirtualGeoTrack}, parent::ByPtr1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::SetParticle(TObject *)
@trydoc raw"""
    SetParticle(this::ByRef1{TVirtualGeoTrack}, particle::ByPtr1{TObject})::Nothing


""" SetParticle(this::ByRef1{TVirtualGeoTrack}, particle::ByPtr1{TObject})

# Wrapper of void TVirtualGeoTrack::SetPDG(Int_t)
@trydoc raw"""
    SetPDG(this::ByRef1{TVirtualGeoTrack}, pdgcode::Int32)::Nothing


""" SetPDG(this::ByRef1{TVirtualGeoTrack}, pdgcode::Int32)

# Wrapper of void TVirtualGeoPainter::AddSize3D(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddSize3D(this::ByRef1{TVirtualGeoPainter}, numpoints::Int32, numsegs::Int32, numpolys::Int32)::Nothing


""" AddSize3D(this::ByRef1{TVirtualGeoPainter}, numpoints::Int32, numsegs::Int32, numpolys::Int32)

# Wrapper of TVirtualGeoTrack * TVirtualGeoPainter::AddTrack(Int_t, Int_t, TObject *)
@trydoc raw"""
    AddTrack(this::ByRef1{TVirtualGeoPainter}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::CxxPtr1{TVirtualGeoTrack}


""" AddTrack(this::ByRef1{TVirtualGeoPainter}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of void TVirtualGeoPainter::AddTrackPoint(Double_t *, Double_t *, Bool_t)
@trydoc raw"""
    AddTrackPoint(this::ByRef1{TVirtualGeoPainter}, point::ByPtr2{Float64}, box::ByPtr2{Float64}, reset::Bool)::Nothing


""" AddTrackPoint(this::ByRef1{TVirtualGeoPainter}, point::ByPtr2{Float64}, box::ByPtr2{Float64}, reset::Bool)

# Wrapper of void TVirtualGeoPainter::BombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    BombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing


""" BombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of void TVirtualGeoPainter::CheckBoundaryErrors(Int_t, Double_t)
@trydoc raw"""
    CheckBoundaryErrors(this::ByRef1{TVirtualGeoPainter}, ntracks::Int32, radius::Float64)::Nothing


""" CheckBoundaryErrors(this::ByRef1{TVirtualGeoPainter}, ntracks::Int32, radius::Float64)

# Wrapper of void TVirtualGeoPainter::CheckBoundaryReference(Int_t)
@trydoc raw"""
    CheckBoundaryReference(this::ByRef1{TVirtualGeoPainter}, icheck::Int32)::Nothing


""" CheckBoundaryReference(this::ByRef1{TVirtualGeoPainter}, icheck::Int32)

# Wrapper of void TVirtualGeoPainter::CheckGeometryFull(Bool_t, Bool_t, Int_t, const Double_t *)
@trydoc raw"""
    CheckGeometryFull(this::ByRef1{TVirtualGeoPainter}, checkoverlaps::Bool, checkcrossings::Bool, nrays::Int32, vertex::ByConstPtr2{Float64})::Nothing


""" CheckGeometryFull(this::ByRef1{TVirtualGeoPainter}, checkoverlaps::Bool, checkcrossings::Bool, nrays::Int32, vertex::ByConstPtr2{Float64})

# Wrapper of void TVirtualGeoPainter::CheckPoint(Double_t, Double_t, Double_t, Option_t *, Double_t)
@trydoc raw"""
    CheckPoint(this::ByRef1{TVirtualGeoPainter}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)::Nothing


""" CheckPoint(this::ByRef1{TVirtualGeoPainter}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)

# Wrapper of void TVirtualGeoPainter::CheckShape(TGeoShape *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing


""" CheckShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of Int_t TVirtualGeoPainter::CountVisibleNodes()
@trydoc raw"""
    CountVisibleNodes(this::ByRef1{TVirtualGeoPainter})::Int32


""" CountVisibleNodes(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::DefaultAngles()
@trydoc raw"""
    DefaultAngles(this::ByRef1{TVirtualGeoPainter})::Nothing


""" DefaultAngles(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::DefaultColors()
@trydoc raw"""
    DefaultColors(this::ByRef1{TVirtualGeoPainter})::Nothing


""" DefaultColors(this::ByRef1{TVirtualGeoPainter})

# Wrapper of Int_t TVirtualGeoPainter::DistanceToPrimitiveVol(TGeoVolume *, Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitiveVol(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, px::Int32, py::Int32)::Int32


""" DistanceToPrimitiveVol(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::DrawBatemanSol(TGeoBatemanSol *, Option_t *)
@trydoc raw"""
    DrawBatemanSol(this::ByRef1{TVirtualGeoPainter}, sol::ByPtr1{TGeoBatemanSol}, option::ByCopy{String})::Nothing


""" DrawBatemanSol(this::ByRef1{TVirtualGeoPainter}, sol::ByPtr1{TGeoBatemanSol}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawCurrentPoint(Int_t)
@trydoc raw"""
    DrawCurrentPoint(this::ByRef1{TVirtualGeoPainter}, color::Int32)::Nothing


""" DrawCurrentPoint(this::ByRef1{TVirtualGeoPainter}, color::Int32)

# Wrapper of void TVirtualGeoPainter::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing


""" DrawOnly(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawOverlap(void *, Option_t *)
@trydoc raw"""
    DrawOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})::Nothing


""" DrawOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TVirtualGeoPainter})::Nothing


""" DrawPanel(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::DrawPath(const char *, Option_t *)
@trydoc raw"""
    DrawPath(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String}, option::ByCopy{String})::Nothing


""" DrawPath(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawPolygon(const TGeoPolygon *)
@trydoc raw"""
    DrawPolygon(this::ByRef1{TVirtualGeoPainter}, poly::ByConstPtr1{TGeoPolygon})::Nothing


""" DrawPolygon(this::ByRef1{TVirtualGeoPainter}, poly::ByConstPtr1{TGeoPolygon})

# Wrapper of void TVirtualGeoPainter::DrawShape(TGeoShape *, Option_t *)
@trydoc raw"""
    DrawShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})::Nothing


""" DrawShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawVolume(TGeoVolume *, Option_t *)
@trydoc raw"""
    DrawVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String})::Nothing


""" DrawVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::EditGeometry(Option_t *)
@trydoc raw"""
    EditGeometry(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing


""" EditGeometry(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::EstimateCameraMove(Double_t, Double_t, Double_t *, Double_t *)
@trydoc raw"""
    EstimateCameraMove(this::ByRef1{TVirtualGeoPainter}, ::Float64, ::Float64, ::ByPtr2{Float64}, ::ByPtr2{Float64})::Nothing


""" EstimateCameraMove(this::ByRef1{TVirtualGeoPainter}, ::Float64, ::Float64, ::ByPtr2{Float64}, ::ByPtr2{Float64})

# Wrapper of void TVirtualGeoPainter::ExecuteManagerEvent(TGeoManager *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteManagerEvent(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteManagerEvent(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::ExecuteShapeEvent(TGeoShape *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteShapeEvent(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteShapeEvent(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::ExecuteVolumeEvent(TGeoVolume *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteVolumeEvent(this::ByRef1{TVirtualGeoPainter}, volume::ByPtr1{TGeoVolume}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteVolumeEvent(this::ByRef1{TVirtualGeoPainter}, volume::ByPtr1{TGeoVolume}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::GetViewAngles(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetViewAngles(this::ByRef1{TVirtualGeoPainter}, ::ByRef2{Float64}, ::ByRef2{Float64}, ::ByRef2{Float64})::Nothing


""" GetViewAngles(this::ByRef1{TVirtualGeoPainter}, ::ByRef2{Float64}, ::ByRef2{Float64}, ::ByRef2{Float64})

# Wrapper of Double_t * TVirtualGeoPainter::GetViewBox()
@trydoc raw"""
    GetViewBox(this::ByRef1{TVirtualGeoPainter})::CxxPtr2{Float64}


""" GetViewBox(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::GrabFocus(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    GrabFocus(this::ByRef1{TVirtualGeoPainter}, nfr::Int32, dlong::Float64, dlat::Float64, dpsi::Float64)::Nothing


""" GrabFocus(this::ByRef1{TVirtualGeoPainter}, nfr::Int32, dlong::Float64, dlat::Float64, dpsi::Float64)

# Wrapper of TH2F * TVirtualGeoPainter::LegoPlot(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    LegoPlot(this::ByRef1{TVirtualGeoPainter}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})::CxxPtr1{TH2F}


""" LegoPlot(this::ByRef1{TVirtualGeoPainter}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::OpProgress(const char *, Long64_t, Long64_t, TStopwatch *, Bool_t, Bool_t, const char *)
@trydoc raw"""
    OpProgress(this::ByRef1{TVirtualGeoPainter}, opname::ByCopy{String}, current::Int64, size::Int64, watch::ByPtr1{TStopwatch}, last::Bool, refresh::Bool, msg::ByCopy{String})::Nothing


""" OpProgress(this::ByRef1{TVirtualGeoPainter}, opname::ByCopy{String}, current::Int64, size::Int64, watch::ByPtr1{TStopwatch}, last::Bool, refresh::Bool, msg::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::PaintNode(TGeoNode *, Option_t *, TGeoMatrix *)
@trydoc raw"""
    PaintNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})::Nothing


""" PaintNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})

# Wrapper of void TVirtualGeoPainter::PaintOverlap(void *, Option_t *)
@trydoc raw"""
    PaintOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})::Nothing


""" PaintOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::PaintShape(TGeoShape *, Option_t *)
@trydoc raw"""
    PaintShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})::Nothing


""" PaintShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::PaintVolume(TGeoVolume *, Option_t *, TGeoMatrix *)
@trydoc raw"""
    PaintVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})::Nothing


""" PaintVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})

# Wrapper of void TVirtualGeoPainter::RandomPoints(const TGeoVolume *, Int_t, Option_t *)
@trydoc raw"""
    RandomPoints(this::ByRef1{TVirtualGeoPainter}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})::Nothing


""" RandomPoints(this::ByRef1{TVirtualGeoPainter}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::RandomRays(Int_t, Double_t, Double_t, Double_t, const char *, Bool_t)
@trydoc raw"""
    RandomRays(this::ByRef1{TVirtualGeoPainter}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)::Nothing


""" RandomRays(this::ByRef1{TVirtualGeoPainter}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)

# Wrapper of void TVirtualGeoPainter::Raytrace(Option_t *)
@trydoc raw"""
    Raytrace(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing


""" Raytrace(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of TGeoNode * TVirtualGeoPainter::SamplePoints(Int_t, Double_t &, Double_t, const char *)
@trydoc raw"""
    SamplePoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})::CxxPtr1{TGeoNode}


""" SamplePoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::SetBombFactors(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetBombFactors(this::ByRef1{TVirtualGeoPainter}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)::Nothing


""" SetBombFactors(this::ByRef1{TVirtualGeoPainter}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)

# Wrapper of void TVirtualGeoPainter::SetCheckedNode(TGeoNode *)
@trydoc raw"""
    SetCheckedNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode})::Nothing


""" SetCheckedNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode})

# Wrapper of void TVirtualGeoPainter::SetClippingShape(TGeoShape *)
@trydoc raw"""
    SetClippingShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape})::Nothing


""" SetClippingShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape})

# Wrapper of void TVirtualGeoPainter::SetExplodedView(Int_t)
@trydoc raw"""
    SetExplodedView(this::ByRef1{TVirtualGeoPainter}, iopt::Int32)::Nothing


""" SetExplodedView(this::ByRef1{TVirtualGeoPainter}, iopt::Int32)

# Wrapper of void TVirtualGeoPainter::SetGeoManager(TGeoManager *)
@trydoc raw"""
    SetGeoManager(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager})::Nothing


""" SetGeoManager(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager})

# Wrapper of void TVirtualGeoPainter::SetIteratorPlugin(TGeoIteratorPlugin *)
@trydoc raw"""
    SetIteratorPlugin(this::ByRef1{TVirtualGeoPainter}, plugin::ByPtr1{TGeoIteratorPlugin})::Nothing


""" SetIteratorPlugin(this::ByRef1{TVirtualGeoPainter}, plugin::ByPtr1{TGeoIteratorPlugin})

# Wrapper of void TVirtualGeoPainter::SetNmeshPoints(Int_t)
@trydoc raw"""
    SetNmeshPoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32)::Nothing


""" SetNmeshPoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32)

# Wrapper of void TVirtualGeoPainter::SetNsegments(Int_t)
@trydoc raw"""
    SetNsegments(this::ByRef1{TVirtualGeoPainter}, nseg::Int32)::Nothing


""" SetNsegments(this::ByRef1{TVirtualGeoPainter}, nseg::Int32)

# Wrapper of void TVirtualGeoPainter::SetRaytracing(Bool_t)
@trydoc raw"""
    SetRaytracing(this::ByRef1{TVirtualGeoPainter}, flag::Bool)::Nothing


""" SetRaytracing(this::ByRef1{TVirtualGeoPainter}, flag::Bool)

# Wrapper of void TVirtualGeoPainter::SetTopVisible(Bool_t)
@trydoc raw"""
    SetTopVisible(this::ByRef1{TVirtualGeoPainter}, vis::Bool)::Nothing


""" SetTopVisible(this::ByRef1{TVirtualGeoPainter}, vis::Bool)

# Wrapper of void TVirtualGeoPainter::SetTopVolume(TGeoVolume *)
@trydoc raw"""
    SetTopVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetTopVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TVirtualGeoPainter::SetVisLevel(Int_t)
@trydoc raw"""
    SetVisLevel(this::ByRef1{TVirtualGeoPainter}, level::Int32)::Nothing


""" SetVisLevel(this::ByRef1{TVirtualGeoPainter}, level::Int32)

# Wrapper of void TVirtualGeoPainter::SetVisOption(Int_t)
@trydoc raw"""
    SetVisOption(this::ByRef1{TVirtualGeoPainter}, option::Int32)::Nothing


""" SetVisOption(this::ByRef1{TVirtualGeoPainter}, option::Int32)

# Wrapper of void TVirtualGeoPainter::Test(Int_t, Option_t *)
@trydoc raw"""
    Test(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, option::ByCopy{String})::Nothing


""" Test(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::TestOverlaps(const char *)
@trydoc raw"""
    TestOverlaps(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String})::Nothing


""" TestOverlaps(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String})

# Wrapper of Bool_t TVirtualGeoPainter::TestVoxels(TGeoVolume *)
@trydoc raw"""
    TestVoxels(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})::Bool


""" TestVoxels(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TVirtualGeoPainter::UnbombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    UnbombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing


""" UnbombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of Double_t TVirtualGeoPainter::Weight(Double_t, Option_t *)
@trydoc raw"""
    Weight(this::ByRef1{TVirtualGeoPainter}, precision::Float64, option::ByCopy{String})::Float64


""" Weight(this::ByRef1{TVirtualGeoPainter}, precision::Float64, option::ByCopy{String})

# Wrapper of void TGeoPNEntry::SetMatrix(const TGeoHMatrix *)
@trydoc raw"""
    SetMatrix(this::ByRef1{TGeoPNEntry}, matrix::ByConstPtr1{TGeoHMatrix})::Nothing
Set the additional matrix for this node entry.
The matrix will be deleted by this class unless registered by the user to gGeoManager
""" SetMatrix(this::ByRef1{TGeoPNEntry}, matrix::ByConstPtr1{TGeoHMatrix})

# Wrapper of void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *)
@trydoc raw"""
    SetPhysicalNode(this::ByRef1{TGeoPNEntry}, node::ByPtr1{TGeoPhysicalNode})::Nothing
Setter for the corresponding physical node.

""" SetPhysicalNode(this::ByRef1{TGeoPNEntry}, node::ByPtr1{TGeoPhysicalNode})

# Wrapper of Bool_t TGeoPhysicalNode::Align(TGeoMatrix *, TGeoShape *, Bool_t, Double_t)
@trydoc raw"""
    Align(this::ByRef1{TGeoPhysicalNode}, newmat::ByPtr1{TGeoMatrix}, newshape::ByPtr1{TGeoShape}, check::Bool, ovlp::Float64)::Bool
Align a physical node with a new relative matrix/shape.
Example: /TOP_1/A_1/B_1/C_1 node->Align(transl_1, box) will perform:

- change RELATIVE translation of C_1 node (with respect to its container volume B) to transl_1
- change the shape of the C volume *NOTE* The operations will affect ONLY the LAST node in the branch. All volumes/nodes in the branch represented by this physical node are CLONED so the operation does not affect other possible replicas.
""" Align(this::ByRef1{TGeoPhysicalNode}, newmat::ByPtr1{TGeoMatrix}, newshape::ByPtr1{TGeoShape}, check::Bool, ovlp::Float64)

# Wrapper of void TGeoPhysicalNode::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})::Nothing
Draw this node.

""" Draw(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})

# Wrapper of void TGeoPhysicalNode::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})::Nothing
Paint this node and its content according to visualization settings.

""" Paint(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})

# Wrapper of void TGeoPhysicalNode::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TGeoPhysicalNode})::Nothing
Refresh this physical node.
Called for all registered physical nodes after an [Align()](@ref) call.
""" Refresh(this::ByRef1{TGeoPhysicalNode})

# Wrapper of void TGeoPhysicalNode::SetIsVolAtt(Bool_t)
@trydoc raw"""
    SetIsVolAtt(this::ByRef1{TGeoPhysicalNode}, flag::Bool)::Nothing


""" SetIsVolAtt(this::ByRef1{TGeoPhysicalNode}, flag::Bool)

# Wrapper of void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *)
@trydoc raw"""
    SetMatrixOrig(this::ByRef1{TGeoPhysicalNode}, local_::ByConstPtr1{TGeoMatrix})::Nothing
Allows PN entries (or users) to preset the local_ original matrix for the last node pointed by the path.

""" SetMatrixOrig(this::ByRef1{TGeoPhysicalNode}, local_::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoPhysicalNode::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoPhysicalNode}, flag::Bool)::Nothing


""" SetVisibility(this::ByRef1{TGeoPhysicalNode}, flag::Bool)

# Wrapper of void TGeoPhysicalNode::SetVisibleFull(Bool_t)
@trydoc raw"""
    SetVisibleFull(this::ByRef1{TGeoPhysicalNode}, flag::Bool)::Nothing


""" SetVisibleFull(this::ByRef1{TGeoPhysicalNode}, flag::Bool)

# Wrapper of bool TGeoOpticalSurface::AddConstProperty(const char *, const char *)
@trydoc raw"""
    AddConstProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddConstProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of bool TGeoOpticalSurface::AddProperty(const char *, const char *)
@trydoc raw"""
    AddProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of const char * TGeoOpticalSurface::GetPropertyRef(const char *)
@trydoc raw"""
    GetPropertyRef(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String})::ByCopy{String}


""" GetPropertyRef(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String})

# Wrapper of void TGeoOpticalSurface::SetPolish(Double_t)
@trydoc raw"""
    SetPolish(this::ByRef1{TGeoOpticalSurface}, polish::Float64)::Nothing


""" SetPolish(this::ByRef1{TGeoOpticalSurface}, polish::Float64)

# Wrapper of void TGeoOpticalSurface::SetSigmaAlpha(Double_t)
@trydoc raw"""
    SetSigmaAlpha(this::ByRef1{TGeoOpticalSurface}, sigmaalpha::Float64)::Nothing


""" SetSigmaAlpha(this::ByRef1{TGeoOpticalSurface}, sigmaalpha::Float64)

# Wrapper of void TGeoOpticalSurface::SetValue(Double_t)
@trydoc raw"""
    SetValue(this::ByRef1{TGeoOpticalSurface}, value::Float64)::Nothing


""" SetValue(this::ByRef1{TGeoOpticalSurface}, value::Float64)

# Wrapper of void TGeoPara::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoPara})::Nothing
compute bounding box

""" ComputeBBox(this::ByRef1{TGeoPara})

# Wrapper of void TGeoPara::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoPara::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of TGeoVolume * TGeoPara::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoPara}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this parallelepiped shape belonging to volume "voldiv" into ndiv equal volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume. In case a wrong division axis is supplied, returns pointer to volume to be divided.
""" Divide(this::ByRef1{TGeoPara}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoPara::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoPara}, param::ByPtr2{Float64})::Nothing
Set dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoPara}, param::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoParaboloid})::Nothing
compute bounding box of the tube

""" ComputeBBox(this::ByRef1{TGeoParaboloid})

# Wrapper of void TGeoParaboloid::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoParaboloid::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoParaboloid}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex

""" DistancetoPrimitive(this::ByRef1{TGeoParaboloid}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoParaboloid::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoParaboloid}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the paraboloid along one axis.

""" Divide(this::ByRef1{TGeoParaboloid}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoParaboloid::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoParaboloid}, param::ByPtr2{Float64})::Nothing
Set paraboloid dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoParaboloid}, param::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::SetParaboloidDimensions(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParaboloidDimensions(this::ByRef1{TGeoParaboloid}, rlo::Float64, rhi::Float64, dz::Float64)::Nothing
Set paraboloid dimensions.

""" SetParaboloidDimensions(this::ByRef1{TGeoParaboloid}, rlo::Float64, rhi::Float64, dz::Float64)

# Wrapper of void TGeoParallelWorld::AddNode(const char *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoParallelWorld}, path::ByCopy{String})::Nothing
Add a node normally to this world. Overlapping nodes not allowed.

""" AddNode(this::ByRef1{TGeoParallelWorld}, path::ByCopy{String})

# Wrapper of void TGeoParallelWorld::AddOverlap(const char *, Bool_t)
@trydoc raw"""
    AddOverlap(this::ByRef1{TGeoParallelWorld}, volname::ByCopy{String}, activate::Bool)::Nothing
To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world.
Better be done before misalignment
""" AddOverlap(this::ByRef1{TGeoParallelWorld}, volname::ByCopy{String}, activate::Bool)

# Wrapper of void TGeoParallelWorld::AddOverlap(TGeoVolume *, Bool_t)
@trydoc raw"""
    AddOverlap(this::ByRef1{TGeoParallelWorld}, vol::ByPtr1{TGeoVolume}, activate::Bool)::Nothing
To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world.
Better be done before misalignment
""" AddOverlap(this::ByRef1{TGeoParallelWorld}, vol::ByPtr1{TGeoVolume}, activate::Bool)

# Wrapper of void TGeoParallelWorld::CheckOverlaps(Double_t)
@trydoc raw"""
    CheckOverlaps(this::ByRef1{TGeoParallelWorld}, ovlp::Float64)::Nothing
Check overlaps within a tolerance value.

""" CheckOverlaps(this::ByRef1{TGeoParallelWorld}, ovlp::Float64)

# Wrapper of Bool_t TGeoParallelWorld::CloseGeometry()
@trydoc raw"""
    CloseGeometry(this::ByRef1{TGeoParallelWorld})::Bool
The main geometry must be closed.

""" CloseGeometry(this::ByRef1{TGeoParallelWorld})

# Wrapper of void TGeoParallelWorld::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoParallelWorld}, option::ByCopy{String})::Nothing
Draw the parallel world.

""" Draw(this::ByRef1{TGeoParallelWorld}, option::ByCopy{String})

# Wrapper of void TGeoParallelWorld::RefreshPhysicalNodes()
@trydoc raw"""
    RefreshPhysicalNodes(this::ByRef1{TGeoParallelWorld})::Nothing
Refresh the node pointers and re-voxelize.
To be called mandatory in case re-alignment happened.
""" RefreshPhysicalNodes(this::ByRef1{TGeoParallelWorld})

# Wrapper of void TGeoParallelWorld::SetUseOverlaps(Bool_t)
@trydoc raw"""
    SetUseOverlaps(this::ByRef1{TGeoParallelWorld}, flag::Bool)::Nothing


""" SetUseOverlaps(this::ByRef1{TGeoParallelWorld}, flag::Bool)

# Wrapper of void TGeoPcon::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoPcon})::Nothing
compute bounding box of the pcon Check if the sections are in increasing Z order

""" ComputeBBox(this::ByRef1{TGeoPcon})

# Wrapper of void TGeoPcon::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoPcon::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoPcon::DefineSection(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DefineSection(this::ByRef1{TGeoPcon}, snum::Int32, z::Float64, rmin::Float64, rmax::Float64)::Nothing
Defines z position of a section plane, rmin and rmax at this z.
Sections should be defined in increasing or decreasing Z order and the last section HAS to be snum = fNz-1
""" DefineSection(this::ByRef1{TGeoPcon}, snum::Int32, z::Float64, rmin::Float64, rmax::Float64)

# Wrapper of Int_t TGeoPcon::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoPcon}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoPcon}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoPcon::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoPcon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this polycone shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. Z divisions can be performed if the divided range is in between two consecutive Z planes. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoPcon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t & TGeoPcon::Dphi()
@trydoc raw"""
    Dphi(this::ByRef1{TGeoPcon})::CxxRef2{Float64}


""" Dphi(this::ByRef1{TGeoPcon})

# Wrapper of Double_t & TGeoPcon::Phi1()
@trydoc raw"""
    Phi1(this::ByRef1{TGeoPcon})::CxxRef2{Float64}


""" Phi1(this::ByRef1{TGeoPcon})

# Wrapper of Double_t & TGeoPcon::Rmax(Int_t)
@trydoc raw"""
    Rmax(this::ByRef1{TGeoPcon}, ipl::Int32)::CxxRef2{Float64}


""" Rmax(this::ByRef1{TGeoPcon}, ipl::Int32)

# Wrapper of Double_t & TGeoPcon::Rmin(Int_t)
@trydoc raw"""
    Rmin(this::ByRef1{TGeoPcon}, ipl::Int32)::CxxRef2{Float64}


""" Rmin(this::ByRef1{TGeoPcon}, ipl::Int32)

# Wrapper of void TGeoPcon::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoPcon}, param::ByPtr2{Float64})::Nothing
Set polycone dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoPcon}, param::ByPtr2{Float64})

# Wrapper of Double_t & TGeoPcon::Z(Int_t)
@trydoc raw"""
    Z(this::ByRef1{TGeoPcon}, ipl::Int32)::CxxRef2{Float64}


""" Z(this::ByRef1{TGeoPcon}, ipl::Int32)

# Wrapper of void TGeoPgon::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoPgon})::Nothing
compute bounding box for a polygone Check if the sections are in increasing Z order

""" ComputeBBox(this::ByRef1{TGeoPgon})

# Wrapper of void TGeoPgon::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoPgon::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoPgon::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoPgon}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoPgon}, nthreads::Int32)

# Wrapper of Int_t TGeoPgon::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoPgon}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoPgon}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoPgon::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoPgon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this polygone shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. Phi divisions are allowed only if nedgesndiv=0 and create polygone "segments" with nedges/ndiv edges. Z divisions can be performed if the divided range is in between two consecutive Z planes. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoPgon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoPgon::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoPgon}, param::ByPtr2{Float64})::Nothing
Set PGON dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoPgon}, param::ByPtr2{Float64})

# Wrapper of void TGeoPgon::SetNedges(Int_t)
@trydoc raw"""
    SetNedges(this::ByRef1{TGeoPgon}, ne::Int32)::Nothing


""" SetNedges(this::ByRef1{TGeoPgon}, ne::Int32)

# Wrapper of void TGeoRegionCut::SetCut(Double_t)
@trydoc raw"""
    SetCut(this::ByRef1{TGeoRegionCut}, cut::Float64)::Nothing


""" SetCut(this::ByRef1{TGeoRegionCut}, cut::Float64)

# Wrapper of void TGeoScaledShape::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoScaledShape})::Nothing
Compute bounding box of the scaled shape.

""" ComputeBBox(this::ByRef1{TGeoScaledShape})

# Wrapper of void TGeoScaledShape::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoScaledShape::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoScaledShape::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoScaledShape}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex. Should not be called.

""" DistancetoPrimitive(this::ByRef1{TGeoScaledShape}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoScaledShape::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoScaledShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Cannot divide assemblies.

""" Divide(this::ByRef1{TGeoScaledShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoScaledShape::SetScale(TGeoScale *)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoScaledShape}, scale::ByPtr1{TGeoScale})::Nothing


""" SetScale(this::ByRef1{TGeoScaledShape}, scale::ByPtr1{TGeoScale})

# Wrapper of void TGeoShapeAssembly::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoShapeAssembly})::Nothing
Compute bounding box of the assembly.

""" ComputeBBox(this::ByRef1{TGeoShapeAssembly})

# Wrapper of void TGeoShapeAssembly::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT. Should not be called.

""" ComputeNormal(this::ByRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoShapeAssembly::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoShapeAssembly::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoShapeAssembly}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex. Should not be called.

""" DistancetoPrimitive(this::ByRef1{TGeoShapeAssembly}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoShapeAssembly::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoShapeAssembly}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Cannot divide assemblies.

""" Divide(this::ByRef1{TGeoShapeAssembly}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoShapeAssembly::NeedsBBoxRecompute()
@trydoc raw"""
    NeedsBBoxRecompute(this::ByRef1{TGeoShapeAssembly})::Nothing


""" NeedsBBoxRecompute(this::ByRef1{TGeoShapeAssembly})

# Wrapper of void TGeoShapeAssembly::RecomputeBoxLast()
@trydoc raw"""
    RecomputeBoxLast(this::ByRef1{TGeoShapeAssembly})::Nothing
Recompute bounding box of the assembly after adding a node.

""" RecomputeBoxLast(this::ByRef1{TGeoShapeAssembly})

# Wrapper of void TGeoSphere::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoSphere})::Nothing
compute bounding box of the sphere

""" ComputeBBox(this::ByRef1{TGeoSphere})

# Wrapper of void TGeoSphere::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoSphere::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoSphere::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoSphere}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoSphere}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoSphere::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoSphere}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this box shape belonging to volume "voldiv" into ndiv equal volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume. In case a wrong division axis is supplied, returns pointer to volume to be divided.
""" Divide(this::ByRef1{TGeoSphere}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoSphere::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64})::Nothing
Set dimensions of the spherical segment starting from a list of parameters.
Only takes rmin and rmax
""" SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64})

# Wrapper of void TGeoSphere::SetDimensions(Double_t *, Int_t)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64}, nparam::Int32)::Nothing
Set dimensions of the spherical segment starting from a list of parameters.

""" SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64}, nparam::Int32)

# Wrapper of void TGeoSphere::SetNumberOfDivisions(Int_t)
@trydoc raw"""
    SetNumberOfDivisions(this::ByRef1{TGeoSphere}, p::Int32)::Nothing
Set the number of divisions of mesh circles keeping aspect ratio.

""" SetNumberOfDivisions(this::ByRef1{TGeoSphere}, p::Int32)

# Wrapper of void TGeoSphere::SetSphDimensions(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetSphDimensions(this::ByRef1{TGeoSphere}, rmin::Float64, rmax::Float64, theta1::Float64, theta2::Float64, phi1::Float64, phi2::Float64)::Nothing
Set spherical segment dimensions.

""" SetSphDimensions(this::ByRef1{TGeoSphere}, rmin::Float64, rmax::Float64, theta1::Float64, theta2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoFacet::Flip()
@trydoc raw"""
    Flip(this::ByRef1{TGeoFacet})::Nothing


""" Flip(this::ByRef1{TGeoFacet})

# Wrapper of bool TGeoTessellated::AddFacet(int, int, int)
@trydoc raw"""
    AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32)::Bool
Adding a triangular facet from indices of vertices.

""" AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32)

# Wrapper of bool TGeoTessellated::AddFacet(int, int, int, int)
@trydoc raw"""
    AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32, i4::Int32)::Bool
Adding a quadrilateral facet from indices of vertices.

""" AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32, i4::Int32)

# Wrapper of bool TGeoTessellated::CheckClosure(bool, bool)
@trydoc raw"""
    CheckClosure(this::ByRef1{TGeoTessellated}, fixFlipped::Bool, verbose::Bool)::Bool
Check closure of the solid and check/fix flipped normals.

""" CheckClosure(this::ByRef1{TGeoTessellated}, fixFlipped::Bool, verbose::Bool)

# Wrapper of void TGeoTessellated::CloseShape(bool, bool, bool)
@trydoc raw"""
    CloseShape(this::ByRef1{TGeoTessellated}, check::Bool, fixFlipped::Bool, verbose::Bool)::Nothing
Close the shape: calculate bounding box and compact vertices.

""" CloseShape(this::ByRef1{TGeoTessellated}, check::Bool, fixFlipped::Bool, verbose::Bool)

# Wrapper of void TGeoTessellated::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTessellated})::Nothing
Compute bounding box.

""" ComputeBBox(this::ByRef1{TGeoTessellated})

# Wrapper of int TGeoTessellated::DistancetoPrimitive(int, int)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTessellated}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each corner.

""" DistancetoPrimitive(this::ByRef1{TGeoTessellated}, px::Int32, py::Int32)

# Wrapper of void TGeoTessellated::FlipFacets()
@trydoc raw"""
    FlipFacets(this::ByRef1{TGeoTessellated})::Nothing
Flip all facets.

""" FlipFacets(this::ByRef1{TGeoTessellated})

# Wrapper of void TGeoTessellated::ResizeCenter(double)
@trydoc raw"""
    ResizeCenter(this::ByRef1{TGeoTessellated}, maxsize::Float64)::Nothing
Resize and center the shape in a box of size maxsize.
Resize the shape by scaling vertices within maxsize and center to origin.
""" ResizeCenter(this::ByRef1{TGeoTessellated}, maxsize::Float64)

# Wrapper of void TGeoTorus::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTorus})::Nothing
Compute bounding box of the torus.

""" ComputeBBox(this::ByRef1{TGeoTorus})

# Wrapper of void TGeoTorus::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTorus::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Int_t TGeoTorus::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTorus}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each vertex.

""" DistancetoPrimitive(this::ByRef1{TGeoTorus}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoTorus::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTorus}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this torus shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.

""" Divide(this::ByRef1{TGeoTorus}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoTorus::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTorus}, param::ByPtr2{Float64})::Nothing
Set torus dimensions starting from a list.

""" SetDimensions(this::ByRef1{TGeoTorus}, param::ByPtr2{Float64})

# Wrapper of void TGeoTorus::SetTorusDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTorusDimensions(this::ByRef1{TGeoTorus}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)::Nothing
Set torus dimensions.

""" SetTorusDimensions(this::ByRef1{TGeoTorus}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)

# Wrapper of void TGeoTrd1::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTrd1})::Nothing
compute bounding box for a trd1

""" ComputeBBox(this::ByRef1{TGeoTrd1})

# Wrapper of void TGeoTrd1::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of TGeoVolume * TGeoTrd1::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTrd1}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this trd1 shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Y divisions. For Z divisions just return the pointer to the volume to be divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTrd1}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoTrd1::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTrd1}, param::ByPtr2{Float64})::Nothing
set trd1 params in one step :

""" SetDimensions(this::ByRef1{TGeoTrd1}, param::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTrd2})::Nothing
compute bounding box for a trd2

""" ComputeBBox(this::ByRef1{TGeoTrd2})

# Wrapper of void TGeoTrd2::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of TGeoVolume * TGeoTrd2::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTrd2}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this trd2 shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Only Z divisions are supported. For Z divisions just return the pointer to the volume to be divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTrd2}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoTrd2::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTrd2}, param::ByPtr2{Float64})::Nothing
set arb8 params in one step :

""" SetDimensions(this::ByRef1{TGeoTrd2}, param::ByPtr2{Float64})

# Wrapper of void TGeoXtru::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoXtru})::Nothing
compute bounding box of the pcon

""" ComputeBBox(this::ByRef1{TGeoXtru})

# Wrapper of void TGeoXtru::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoXtru::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoXtru::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoXtru}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoXtru}, nthreads::Int32)

# Wrapper of Bool_t TGeoXtru::DefinePolygon(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    DefinePolygon(this::ByRef1{TGeoXtru}, nvert::Int32, xv::ByConstPtr2{Float64}, yv::ByConstPtr2{Float64})::Bool
Creates the polygon representing the blueprint of any Xtru section.
- nvert = number of vertices >2
- xv[nvert] = array of X vertex positions
- yv[nvert] = array of Y vertex positions

*NOTE* should be called before DefineSection or ctor with 'param'
""" DefinePolygon(this::ByRef1{TGeoXtru}, nvert::Int32, xv::ByConstPtr2{Float64}, yv::ByConstPtr2{Float64})

# Wrapper of void TGeoXtru::DefineSection(Int_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DefineSection(this::ByRef1{TGeoXtru}, snum::Int32, z::Float64, x0::Float64, y0::Float64, scale::Float64)::Nothing
defines z position of a section plane, rmin and rmax at this z.

""" DefineSection(this::ByRef1{TGeoXtru}, snum::Int32, z::Float64, x0::Float64, y0::Float64, scale::Float64)

# Wrapper of Int_t TGeoXtru::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoXtru}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoXtru}, px::Int32, py::Int32)

# Wrapper of void TGeoXtru::DrawPolygon(Option_t *)
@trydoc raw"""
    DrawPolygon(this::ByRef1{TGeoXtru}, option::ByCopy{String})::Nothing
Draw the section polygon.

""" DrawPolygon(this::ByRef1{TGeoXtru}, option::ByCopy{String})

# Wrapper of void TGeoXtru::SetCurrentVertices(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentVertices(this::ByRef1{TGeoXtru}, x0::Float64, y0::Float64, scale::Float64)::Nothing
Set current vertex coordinates according X0, Y0 and SCALE.

""" SetCurrentVertices(this::ByRef1{TGeoXtru}, x0::Float64, y0::Float64, scale::Float64)

# Wrapper of void TGeoXtru::SetCurrentZ(Double_t, Int_t)
@trydoc raw"""
    SetCurrentZ(this::ByRef1{TGeoXtru}, z::Float64, iz::Int32)::Nothing
Recompute current section vertices for a given Z position within range of section iz.

""" SetCurrentZ(this::ByRef1{TGeoXtru}, z::Float64, iz::Int32)

# Wrapper of void TGeoXtru::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoXtru}, param::ByPtr2{Float64})::Nothing

- param[0] = nz // number of z planes
- param[1] = z1 // Z position of first plane
- param[2] = x1 // X position of first plane
- param[3] = y1 // Y position of first plane
- param[4] = scale1 // scale factor for first plane ...
- param[4*(nz-1]+1] = zn
- param[4*(nz-1)+2] = xn
- param[4*(nz-1)+3] = yn
- param[4*(nz-1)+4] = scalen
""" SetDimensions(this::ByRef1{TGeoXtru}, param::ByPtr2{Float64})

# Wrapper of Double_t & TGeoXtru::Z(Int_t)
@trydoc raw"""
    Z(this::ByRef1{TGeoXtru}, ipl::Int32)::CxxRef2{Float64}


""" Z(this::ByRef1{TGeoXtru}, ipl::Int32)
#
######################################################################

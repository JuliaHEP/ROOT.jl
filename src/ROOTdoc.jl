# Reexport from CxxWrap:
export CxxPtr, ConstCxxPtr, CxxRef, ConstCxxRef

# Export type aliases used in the documentation
export ByCopy, ByConstRef1, ByRef1, ByConstPtr1, ByPtr1, ByConstRef2, ByRef2, ByConstPtr2, ByPtr2

# Wrapper of @doc that turns the possible exception
macro trydoc(doc, entity)
    sentity = string(entity)
    quote
        try
            @doc $(esc(doc)) $entity
        catch e
            @warn("Error when setting documentation for " * $sentity * ": " * sprint(showerror, e) * ".")
        end
    end
end

# Wrapper to catch error on expr resulting in an unexpected dispatch
macro trydoc(expr)
    sexpr = string(expr)
    quote
        @warn("Error when setting documentation for " * $sexpr * ".")
    end
end

######################################################################
# Type aliases used in the documentation

"""
    ByCopy{T}

Alias for Union{T, ConstCxxRef{T}, CxxRef{T}}. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type passed by copy. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByCopy{T} = Union{T, CxxRef{T}, ConstCxxRef{T}}

"""
    ByConstRef1{T}

Alias for Union{T, ConstCxxRef{<:T}, CxxRef{<:T}}. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type passed by reference. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByConstRef1{T} = Union{T, CxxRef{<:T}, ConstCxxRef{<:T}}


"""
    ByRef1{T}

Alias for `Union{T, ConstCxxRef{<:T}, CxxRef{<:T}}`. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type passed by reference. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByRef1{T} = Union{T, ConstCxxRef{<:T}, CxxRef{<:T}}

"""
    ByConstPtr1{T}

Alias for `Union{Ptr{Nothing}, ConstCxxPtr{<:T}, CxxPtr{<:T}}`. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type  passed by pointer. It allows to pass `C_NULL` or an object pointer, returned by another C++ function wrapper created with `ConstCxxPtr(obj)` with `obj::T`.
"""
const ByConstPtr1{T} = Union{Ptr{Nothing}, ConstCxxPtr{<:T}, CxxPtr{<:T}}

"""
    ByPtr1{T}

Alias for `Union{CxxPtr{<:T}, Ptr{Nothing}}`. This type is used in the Julia wrappers of C++ functions for arguments passed by pointer. It allows to pass C_NULL or an object pointer, returned by another C++ function wrapper created with `CxxPtr(obj)` with obj::T..
"""
const ByPtr1{T} = Union{CxxPtr{<:T}, Ptr{Nothing}}

"""
    ByConstRef2{T}

Alias for Union{T, Ref{T}}, with `ConstCxxRef` and `CxxRef` defined in the `CxxWrap` module. This type is used in the Julia wrappers of C++ functions for arguments of isbit type passed by reference.
"""
const ByConstRef2{T} = Union{T, Ref{T}}

"""
    ByRef2{T}

Alias for Union{T, Ptr{T}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}, with `ConstCxxRef` and `CxxRef` defined in the `CxxWrap` module. This type is used in the Julia wrappers of C++ functions for arguments of isbit type passed by reference.
"""
const ByRef2{T} = Union{T, Ptr{T}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}


"""
    ByConstPtr2{T}

Alias for  Union{Ptr{Nothing}, Ref{T}, Array{T}}, with ConstCxxPtr and CxxPtr defined in the CxxWrap module. This type is used in the Julia wrappers of C++ functions for arguments of C++ class type  passed by pointer. It allows to pass an object allocated with a contructor (e.g., T()) or an object reference returnes by another C++ function wrapper.
"""
const ByConstPtr2{T} = Union{Ptr{Nothing}, Ref{T}, Array{T}}

"""
    ByPtr2{T}

Alias for `Union{T, Ptr{T}, Ptr{Nothing}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}`. This type is used in the Julia wrappers of C++ functions for arguments passed by pointer. It allows to pass an object pointer returned by another C++ function wrapper or C_NULL. To pass an object instance obj, uses `CxxWrap.CxxPtr(obj)`.
"""
const ByPtr2{T} = Union{T, Ptr{T}, Ptr{Nothing}, CxxPtr{T}, CxxRef{T}, Base.RefValue{T}, Array{T}}

#
######################################################################

######################################################################
# Documentation of ROOT types

# Wrapper of TClass
@trydoc raw"""
    ROOT.TClass

[TClass](@ref) instances represent classes, structs and namespaces in the [ROOT](@ref) type system.

[TClass](@ref) instances are created starting from different sources of information:

1. [TStreamerInfo](@ref) instances saved in a [ROOT](@ref) file which is opened. This is called in jargon an <i>emulated [TClass](@ref)</i>.
2. From [TProtoClass](@ref) instances saved in a [ROOT](@ref) pcm file created by the dictionary generator and the dictionary itself.
3. From a lookup in the AST built by cling.

If a [TClass](@ref) instance is built through the mechanisms 1. and 2., it does not contain information about methods of the class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary to [ROOT](@ref) to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the [TClass](@ref) instance.

In order to retrieve a [TClass](@ref) instance from the type system, a query can be executed as follows through the static [TClass!GetClass](@ref) method:

    auto myClassTClass_0 = TClass!GetClass("myClass");
    auto myClassTClass_1 = TClass!GetClass<myClass>();
    auto myClassTClass_2 = TClass!GetClass(myClassTypeInfo);

(C++ version of the code)

The name of classes is crucial for [ROOT](@ref). A careful procedure of *name normalization* is carried out for each and every class. A *normalized name* is a valid C++ class name. In order to access the name of a class within the [ROOT](@ref) type system, the method [TClass!GetName()](@ref) can be used.

Related functions: [`AddImplFile`](@ref), [`AddInstance`](@ref), [`AdoptMemberStreamer`](@ref), [`AdoptReferenceProxy`](@ref), [`AdoptSchemaRules`](@ref), [`AdoptStreamer`](@ref), [`Browse`](@ref), [`BuildEmulatedRealData`](@ref), [`BuildRealData`](@ref), [`CalculateStreamerOffset`](@ref), [`CallShowMembers`](@ref), [`CanIgnoreTObjectStreamer`](@ref), [`CanSplit`](@ref), [`ClassProperty`](@ref), [`Clone`](@ref), [`CopyCollectionProxy`](@ref), [`DeleteArray`](@ref), [`Destructor`](@ref), [`Draw`](@ref), [`Dump`](@ref), [`DynamicCast`](@ref), [`EscapeChars`](@ref), [`FindConversionStreamerInfo`](@ref), [`FindStreamerInfoAbstractEmulated`](@ref), [`FindStreamerInfo`](@ref), [`ForceReload`](@ref), [`GetActualClass`](@ref), [`GetBaseClassOffset`](@ref), [`GetBaseClass`](@ref), [`GetBaseDataMember`](@ref), [`GetCheckSum`](@ref), [`GetClassInfo`](@ref), [`GetClassMethodWithPrototype`](@ref), [`GetClassMethod`](@ref), [`GetClassSize`](@ref), [`GetClassVersion`](@ref), [`GetCollectionProxy`](@ref), [`GetCollectionType`](@ref), [`GetContextMenuTitle`](@ref), [`GetConvStreamerFunc`](@ref), [`GetConversionStreamerInfo`](@ref), [`GetCurrentStreamerInfo`](@ref), [`GetDataMemberOffset`](@ref), [`GetDataMember`](@ref), [`GetDeclFileLine`](@ref), [`GetDeclFileName`](@ref), [`GetDeleteArray`](@ref), [`GetDelete`](@ref), [`GetDestructor`](@ref), [`GetDirectoryAutoAdd`](@ref), [`GetFunctionTemplate`](@ref), [`GetHeapInstanceCount`](@ref), [`GetImplFileLine`](@ref), [`GetImplFileName`](@ref), [`GetInstanceCount`](@ref), [`GetIsAProxy`](@ref), [`GetLastReadInfo`](@ref), [`GetListOfAllPublicDataMembers`](@ref), [`GetListOfAllPublicMethods`](@ref), [`GetListOfBases`](@ref), [`GetListOfDataMembers`](@ref), [`GetListOfEnums`](@ref), [`GetListOfFunctionTemplates`](@ref), [`GetListOfMethodOverloads`](@ref), [`GetListOfMethods`](@ref), [`GetListOfRealData`](@ref), [`GetListOfUsingDataMembers`](@ref), [`GetMenuItems`](@ref), [`GetMenuList`](@ref), [`GetMerge`](@ref), [`GetMethodAllAny`](@ref), [`GetMethodAny`](@ref), [`GetMethodWithPrototype`](@ref), [`GetMethod`](@ref), [`GetMissingDictionaries`](@ref), [`GetNdata`](@ref), [`GetNewArray`](@ref), [`GetNew`](@ref), [`GetNmethods`](@ref), [`GetPersistentRef`](@ref), [`GetRealData`](@ref), [`GetReferenceProxy`](@ref), [`GetResetAfterMerge`](@ref), [`GetSchemaRules`](@ref), [`GetSharedLibs`](@ref), [`GetShowMembersWrapper`](@ref), [`GetState`](@ref), [`GetStreamerFunc`](@ref), [`GetStreamerInfoAbstractEmulated`](@ref), [`GetStreamerInfo`](@ref), [`GetStreamerInfos`](@ref), [`GetStreamer`](@ref), [`GetTypeInfo`](@ref), [`HasConsistentHashMember`](@ref), [`HasCustomStreamerMember`](@ref), [`HasDataMemberInfo`](@ref), [`HasDefaultConstructor`](@ref), [`HasDictionary`](@ref), [`HasDirectStreamerInfoUse`](@ref), [`HasInterpreterInfoInMemory`](@ref), [`HasInterpreterInfo`](@ref), [`HasLocalHashMember`](@ref), [`IgnoreTObjectStreamer`](@ref), [`InheritsFrom`](@ref), [`InterpretedShowMembers`](@ref), [`IsFolder`](@ref), [`IsForeign`](@ref), [`IsLoaded`](@ref), [`IsStartingWithTObject`](@ref), [`IsSyntheticPair`](@ref), [`IsTObject`](@ref), [`IsVersioned`](@ref), [`MakeCustomMenuList`](@ref), [`MatchLegacyCheckSum`](@ref), [`Move`](@ref), [`NewArray`](@ref), [`NewObjectArray`](@ref), [`NewObject`](@ref), [`New`](@ref), [`PostLoadCheck`](@ref), [`Property`](@ref), [`ReadBuffer`](@ref), [`RegisterStreamerInfo`](@ref), [`RemoveStreamerInfo`](@ref), [`ReplaceWith`](@ref), [`ResetCaches`](@ref), [`ResetClassInfo`](@ref), [`ResetInstanceCount`](@ref), [`ResetMenuList`](@ref), [`SetCanSplit`](@ref), [`SetCollectionProxy`](@ref), [`SetContextMenuTitle`](@ref), [`SetConvStreamerFunc`](@ref), [`SetCurrentStreamerInfo`](@ref), [`SetDeclFile`](@ref), [`SetDeleteArray`](@ref), [`SetDelete`](@ref), [`SetDestructor`](@ref), [`SetDirectoryAutoAdd`](@ref), [`SetGlobalIsA`](@ref), [`SetImplFileName`](@ref), [`SetLastReadInfo`](@ref), [`SetMemberStreamer`](@ref), [`SetMerge`](@ref), [`SetNewArray`](@ref), [`SetNew`](@ref), [`SetResetAfterMerge`](@ref), [`SetStreamerFunc`](@ref), [`SetStreamerInfo`](@ref), [`SetUnloaded`](@ref), [`Size`](@ref), [`Store`](@ref), [`Streamer`](@ref), [`TClass!AddClassToDeclIdMap`](@ref), [`TClass!AddClass`](@ref), [`TClass!AddRule`](@ref), [`TClass!AutoBrowse`](@ref), [`TClass!GetClass`](@ref), [`TClass!GetDict`](@ref), [`TClass!HasDictionarySelection`](@ref), [`TClass!IsCallingNew`](@ref), [`TClass!LoadClass`](@ref), [`TClass!Load`](@ref), [`TClass!ReadRules`](@ref), [`TClass!RegisterReadRules`](@ref), [`TClass!RemoveClassDeclId`](@ref), [`TClass!RemoveClass`](@ref), [`TClass`](@ref), [`WriteBuffer`](@ref), [`ls`](@ref)
""" TClass

# Wrapper of TVirtualIsAProxy
@trydoc raw"""
    ROOT.TVirtualIsAProxy





Related functions: [`SetClass`](@ref), [`paren`](@ref)
""" TVirtualIsAProxy

# Wrapper of TNamed
@trydoc raw"""
    ROOT.TNamed

The [TNamed](@ref) class is the base class for all named [ROOT](@ref) classes.

A [TNamed](@ref) contains the essential elements (name, title) to identify a derived object in containers, directories and files. Most member functions defined in this base class are in general overridden by the derived classes.

Related functions: [`Clear`](@ref), [`Clone`](@ref), [`Compare`](@ref), [`Copy`](@ref), [`FillBuffer`](@ref), [`GetName`](@ref), [`GetTitle`](@ref), [`Hash`](@ref), [`IsA`](@ref), [`IsSortable`](@ref), [`Print`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetTitle`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TNamed!Class_Name`](@ref), [`TNamed!Class_Version`](@ref), [`TNamed!Class`](@ref), [`TNamed!DeclFileName`](@ref), [`TNamed`](@ref), [`assign`](@ref), [`ls`](@ref)
""" TNamed

# Wrapper of TObject
@trydoc raw"""
    ROOT.TObject

Mother of all [ROOT](@ref) objects.

The [TObject](@ref) class provides default behaviour and protocol for all objects in the [ROOT](@ref) system. It provides protocol for object I/O, error handling, sorting, inspection, printing, drawing, etc. Every object which inherits from [TObject](@ref) can be stored in the [ROOT](@ref) collection classes.

[TObject](@ref)'s bits can be used as flags, bits 0 - 13 and 24-31 are reserved as global_ bits while bits 14 - 23 can be used in different class hierarchies (watch out for overlaps).

\Note Class inheriting directly or indirectly from [TObject](@ref) should not use `= default` for any of the constructors. The default implementation for a constructor can sometime do 'more' than we expect (and still being standard compliant). On some platforms it will reset all the data member of the class including its base class's member before the actual execution of the base class constructor. `TObject`'s implementation of the `IsOnHeap` bit requires the memory occupied by `TObject!fUniqueID` to *not* be reset between the execution of `TObject!operator new` and the `TObject` constructor (Finding the magic pattern there is how we can determine that the object was allocated on the heap).

Related functions: [`AbstractMethod`](@ref), [`AppendPad`](@ref), [`Browse`](@ref), [`CheckedHash`](@ref), [`ClassName`](@ref), [`Clear`](@ref), [`Clone`](@ref), [`Compare`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`DistancetoPrimitive`](@ref), [`DrawClass`](@ref), [`DrawClone`](@ref), [`Draw`](@ref), [`Dump`](@ref), [`Error`](@ref), [`ExecuteEvent`](@ref), [`Execute`](@ref), [`Fatal`](@ref), [`FindObject`](@ref), [`GetDrawOption`](@ref), [`GetIconName`](@ref), [`GetName`](@ref), [`GetObjectInfo`](@ref), [`GetOption`](@ref), [`GetTitle`](@ref), [`GetUniqueID`](@ref), [`HandleTimer`](@ref), [`HasInconsistentHash`](@ref), [`Hash`](@ref), [`Info`](@ref), [`InheritsFrom`](@ref), [`Inspect`](@ref), [`InvertBit`](@ref), [`IsA`](@ref), [`IsDestructed`](@ref), [`IsEqual`](@ref), [`IsFolder`](@ref), [`IsOnHeap`](@ref), [`IsSortable`](@ref), [`IsZombie`](@ref), [`MayNotUse`](@ref), [`Notify`](@ref), [`Obsolete`](@ref), [`Paint`](@ref), [`Pop`](@ref), [`Print`](@ref), [`Read`](@ref), [`RecursiveRemove`](@ref), [`ResetBit`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SetBit`](@ref), [`SetDrawOption`](@ref), [`SetUniqueID`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`SysError`](@ref), [`TObject!Class_Name`](@ref), [`TObject!Class_Version`](@ref), [`TObject!Class`](@ref), [`TObject!DeclFileName`](@ref), [`TObject!GetDtorOnly`](@ref), [`TObject!GetObjectStat`](@ref), [`TObject!SetDtorOnly`](@ref), [`TObject!SetObjectStat`](@ref), [`TObject`](@ref), [`TestBit`](@ref), [`TestBits`](@ref), [`UseCurrentStyle`](@ref), [`Warning`](@ref), [`Write`](@ref), [`assign`](@ref), [`delete`](@ref), [`deletearray`](@ref), [`ls`](@ref), [`new`](@ref), [`newarray`](@ref)
""" TObject

# Wrapper of TBrowser
@trydoc raw"""
    ROOT.TBrowser

Using a [TBrowser](@ref) one can browse all [ROOT](@ref) objects.

It shows in a list on the left side of the window all browsable [ROOT](@ref) classes. Selecting one of the classes displays, in the icon-box on the right side, all objects in the class. Selecting one of the objects in the icon-box, will place all browsable objects in a new list and draws the contents of the selected class in the icon-box. And so on....

![https://root.cern/doc/v636/base_browser.png](https://root.cern/doc/v636/base_browser.png)

###Since

ROOT version 6.24/00

[TBrowser](@ref) invokes by default the Web-based ROOT file browser [RBrowser]([ROOT!RBrowser](@ref)) To change this behaviour, and invoke the standard [TBrowser](@ref), one should put the following directive in the `.rootrc` file: 

    Browser.Name:      TRootBrowser

(C++ version of the code)

Related functions: [`AddCheckBox`](@ref), [`Add`](@ref), [`BrowseObject`](@ref), [`CheckObjectItem`](@ref), [`Create`](@ref), [`Destructor`](@ref), [`Draw`](@ref), [`ExecPlugin`](@ref), [`ExecuteDefaultAction`](@ref), [`GetBrowserImp`](@ref), [`GetContextMenu`](@ref), [`GetDrawOption`](@ref), [`GetRefreshFlag`](@ref), [`GetSelected`](@ref), [`Iconify`](@ref), [`IsWeb`](@ref), [`RecursiveRemove`](@ref), [`Refresh`](@ref), [`RemoveCheckBox`](@ref), [`SetBrowserImp`](@ref), [`SetDrawOption`](@ref), [`SetRefreshFlag`](@ref), [`SetSelected`](@ref), [`SetStatusText`](@ref), [`Show`](@ref), [`StartEmbedding`](@ref), [`StopEmbedding`](@ref), [`TBrowser`](@ref)
""" TBrowser

# Wrapper of TObjArray
@trydoc raw"""
    ROOT.TObjArray

An array of TObjects.

The array expands automatically when objects are added (shrinking can be done by hand using [Expand()](@ref), how nice to have meaningful names -:)). Use operator[] to have "real" array behaviour.

Note on ownership and copy: By default the [TObjArray](@ref) does not own the objects it points to and will not delete them unless explicitly asked (via a call to the Delete member function). To assign ownership of the content to the array, call: 

    myarr->SetOwner(kTRUE);

(C++ version of the code)

 When the array owns its content a call to Clear or the deletion of the array itself will lead to the deletion of its contents.

You can either make a shallow copy of the array: 

     otherarr = new TObjArray(*myarr);
    *otherarr = *myarr;

(C++ version of the code)

 in which case ownership (if any) is not transfered but the other array points to the same object as the original array. Note that if the content of either array is deleted the other array is not notified in any way (i.e. still points to the now deleted objects).

You can also make a deep copy of the array: 

    otherarr = (TObjArray*)myarr->Clone();

(C++ version of the code)

 in which case the array and the content are both duplicated (i.e. otherarr and myarr do not point to the same objects). If myarr is set to the be the owner of its content, otherarr will also be set to the owner of its own content.

Related functions: [`AddAfter`](@ref), [`AddAtAndExpand`](@ref), [`AddAtFree`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Before`](@ref), [`BinarySearch`](@ref), [`Clear`](@ref), [`Compress`](@ref), [`Delete`](@ref), [`Expand`](@ref), [`FindObject`](@ref), [`First`](@ref), [`GetEntriesFast`](@ref), [`GetEntriesUnsafe`](@ref), [`GetEntries`](@ref), [`GetLast`](@ref), [`GetObjectRef`](@ref), [`IndexOf`](@ref), [`IsEmpty`](@ref), [`Last`](@ref), [`LowerBound`](@ref), [`MakeIterator`](@ref), [`Randomize`](@ref), [`RecursiveRemove`](@ref), [`RemoveAt`](@ref), [`RemoveRange`](@ref), [`Remove`](@ref), [`SetLast`](@ref), [`Sort`](@ref), [`TObjArray`](@ref), [`UncheckedAt`](@ref), [`assign`](@ref)
""" TObjArray

# Wrapper of TBuffer
@trydoc raw"""
    ROOT.TBuffer

Buffer base class used for serializing objects.



Related functions: [`ApplySequenceVecPtr`](@ref), [`ApplySequence`](@ref), [`AutoExpand`](@ref), [`BufferSize`](@ref), [`Buffer`](@ref), [`ByteSwapBuffer`](@ref), [`CheckByteCount`](@ref), [`CheckObject`](@ref), [`ClassBegin`](@ref), [`ClassEnd`](@ref), [`ClassMember`](@ref), [`DecrementLevel`](@ref), [`DetachBuffer`](@ref), [`Expand`](@ref), [`ForceWriteInfoClones`](@ref), [`ForceWriteInfo`](@ref), [`GetBufferDisplacement`](@ref), [`GetBufferVersion`](@ref), [`GetCurrent`](@ref), [`GetInfo`](@ref), [`GetLastProcessID`](@ref), [`GetMapCount`](@ref), [`GetMappedObject`](@ref), [`GetParent`](@ref), [`GetPidOffset`](@ref), [`GetReAllocFunc`](@ref), [`GetTRefExecId`](@ref), [`GetVersionOwner`](@ref), [`IncrementLevel`](@ref), [`InitMap`](@ref), [`IsA`](@ref), [`IsReading`](@ref), [`IsWriting`](@ref), [`Length`](@ref), [`MapObject`](@ref), [`PeekDataCache`](@ref), [`PopDataCache`](@ref), [`PushDataCache`](@ref), [`ReadArrayDouble32`](@ref), [`ReadArrayFloat16`](@ref), [`ReadArray`](@ref), [`ReadBool`](@ref), [`ReadBuf`](@ref), [`ReadCharP`](@ref), [`ReadCharStar`](@ref), [`ReadChar`](@ref), [`ReadClassBuffer`](@ref), [`ReadClassEmulated`](@ref), [`ReadClass`](@ref), [`ReadClones`](@ref), [`ReadDouble32`](@ref), [`ReadDouble`](@ref), [`ReadFastArrayDouble32`](@ref), [`ReadFastArrayFloat16`](@ref), [`ReadFastArrayString`](@ref), [`ReadFastArrayWithFactor`](@ref), [`ReadFastArrayWithNbits`](@ref), [`ReadFastArray`](@ref), [`ReadFloat16`](@ref), [`ReadFloat`](@ref), [`ReadInt`](@ref), [`ReadLong64`](@ref), [`ReadLong`](@ref), [`ReadObjectAny`](@ref), [`ReadObject`](@ref), [`ReadProcessID`](@ref), [`ReadShort`](@ref), [`ReadStaticArrayDouble32`](@ref), [`ReadStaticArrayFloat16`](@ref), [`ReadStaticArray`](@ref), [`ReadStdString`](@ref), [`ReadString`](@ref), [`ReadTString`](@ref), [`ReadUChar`](@ref), [`ReadUInt`](@ref), [`ReadULong64`](@ref), [`ReadULong`](@ref), [`ReadUShort`](@ref), [`ReadVersionForMemberWise`](@ref), [`ReadVersionNoCheckSum`](@ref), [`ReadVersion`](@ref), [`ReadWithFactor`](@ref), [`ReadWithNbits`](@ref), [`ResetMap`](@ref), [`Reset`](@ref), [`SetBufferDisplacement`](@ref), [`SetBufferOffset`](@ref), [`SetBuffer`](@ref), [`SetByteCount`](@ref), [`SetParent`](@ref), [`SetPidOffset`](@ref), [`SetReAllocFunc`](@ref), [`SetReadMode`](@ref), [`SetReadParam`](@ref), [`SetStreamerElementNumber`](@ref), [`SetWriteMode`](@ref), [`SetWriteParam`](@ref), [`SkipObjectAny`](@ref), [`SkipVersion`](@ref), [`StreamObject`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TBuffer!Class_Name`](@ref), [`TBuffer!Class_Version`](@ref), [`TBuffer!Class`](@ref), [`TBuffer!DeclFileName`](@ref), [`TBuffer!GetClass`](@ref), [`TBuffer`](@ref), [`TagStreamerInfo`](@ref), [`WriteArrayDouble32`](@ref), [`WriteArrayFloat16`](@ref), [`WriteArray`](@ref), [`WriteBool`](@ref), [`WriteBuf`](@ref), [`WriteCharP`](@ref), [`WriteCharStar`](@ref), [`WriteChar`](@ref), [`WriteClassBuffer`](@ref), [`WriteClass`](@ref), [`WriteClones`](@ref), [`WriteDouble32`](@ref), [`WriteDouble`](@ref), [`WriteFastArrayDouble32`](@ref), [`WriteFastArrayFloat16`](@ref), [`WriteFastArrayString`](@ref), [`WriteFastArray`](@ref), [`WriteFloat16`](@ref), [`WriteFloat`](@ref), [`WriteInt`](@ref), [`WriteLong64`](@ref), [`WriteLong`](@ref), [`WriteObjectAny`](@ref), [`WriteObject`](@ref), [`WriteProcessID`](@ref), [`WriteShort`](@ref), [`WriteStdString`](@ref), [`WriteString`](@ref), [`WriteTString`](@ref), [`WriteUChar`](@ref), [`WriteUInt`](@ref), [`WriteULong64`](@ref), [`WriteULong`](@ref), [`WriteUShort`](@ref), [`WriteVersionMemberWise`](@ref), [`WriteVersion`](@ref)
""" TBuffer

# Wrapper of TVectorT
@trydoc raw"""
    ROOT.TVectorT

[TVectorT](@ref).

Template class of Vectors in the linear algebra package.

See the [Matrix Linear Algebra](@ref) page for the documentation of the linear algebra package

Unless otherwise specified, vector indices always thestart with 0, spanning up to the specified limit-1.

For (n) vectors where n <= kSizeMax (5 currently) storage space is available on the stack, thus avoiding expensive allocation/ deallocation of heap space . However, this introduces of course kSizeMax overhead for each vector object . If this is an issue recompile with a new appropriate value (>=0) for kSizeMax

Another way to assign and store vector data is through Use see for instance stressLinear.cxx file .

Note that Constructors/assignments exists for all different matrix views

For usage examples see `$ROOTSYS/test/stressLinear.cxx`

Related functions: [`Abs`](@ref), [`AddSomeConstant`](@ref), [`Add`](@ref), [`Apply`](@ref), [`Base.:(!=)`](@ref), [`Base.:(<)`](@ref), [`Base.:(<=)`](@ref), [`Base.:(==)`](@ref), [`Base.:(>)`](@ref), [`Base.:(>=)`](@ref), [`Base.getindex`](@ref), [`Class`](@ref), [`Clear`](@ref), [`Draw`](@ref), [`GetLwb`](@ref), [`GetMatrixArray`](@ref), [`GetNoElements`](@ref), [`GetNrows`](@ref), [`GetSub`](@ref), [`GetUpb`](@ref), [`Invalidate`](@ref), [`Invert`](@ref), [`IsOwner`](@ref), [`IsValid`](@ref), [`MakeValid`](@ref), [`MatchesNonZeroPattern`](@ref), [`Max`](@ref), [`Min`](@ref), [`NonZeros`](@ref), [`Norm1`](@ref), [`Norm2Sqr`](@ref), [`NormInf`](@ref), [`Print`](@ref), [`Randomize`](@ref), [`ResizeTo`](@ref), [`SelectNonZeros`](@ref), [`SetElements`](@ref), [`SetSub`](@ref), [`Shift`](@ref), [`SomePositive`](@ref), [`Sqr`](@ref), [`Sqrt`](@ref), [`Sum`](@ref), [`TVectorT`](@ref), [`Use`](@ref), [`Zero`](@ref), [`add!`](@ref), [`assign`](@ref), [`data`](@ref), [`mult!`](@ref), [`paren`](@ref), [`size`](@ref), [`sub!`](@ref)
""" TVectorT

# Wrapper of TString
@trydoc raw"""
    ROOT.TString

Basic string class.

Cannot be stored in a [TCollection](@ref)... use [TObjString](@ref) instead.

The underlying string is stored as a char* that can be accessed via [TString!Data()](@ref). [TString](@ref) provides Short String Optimization (SSO) so that short strings (<15 on 64-bit and <11 on 32-bit) are contained in the [TString](@ref) internal data structure without the need for mallocing the required space.

Substring operations are provided by the [TSubString](@ref) class, which holds a reference to the original string and its data, along with the offset and length of the substring. To retrieve the substring as a [TString](@ref), construct a [TString](@ref) from it, eg: 

    root [0] TString s("hello world")
    root [1] TString s2( s(0,5) )
    root [2] s2
    (class TString)"hello"

(C++ version of the code)

Related functions: [`Append`](@ref), [`Atof`](@ref), [`Atoi`](@ref), [`Atoll`](@ref), [`Base.getindex`](@ref), [`BeginsWith`](@ref), [`Capacity`](@ref), [`Chop`](@ref), [`Clear`](@ref), [`CompareTo`](@ref), [`Contains`](@ref), [`Copy`](@ref), [`CountChar`](@ref), [`Data`](@ref), [`EndsWith`](@ref), [`EqualTo`](@ref), [`FillBuffer`](@ref), [`First`](@ref), [`Form`](@ref), [`Gets`](@ref), [`Hash`](@ref), [`Index`](@ref), [`Insert`](@ref), [`IsA`](@ref), [`IsAlnum`](@ref), [`IsAlpha`](@ref), [`IsAscii`](@ref), [`IsBin`](@ref), [`IsDec`](@ref), [`IsDigit`](@ref), [`IsFloat`](@ref), [`IsHex`](@ref), [`IsInBaseN`](@ref), [`IsNull`](@ref), [`IsOct`](@ref), [`IsWhitespace`](@ref), [`Last`](@ref), [`Length`](@ref), [`MD5`](@ref), [`MaybeRegexp`](@ref), [`MaybeWildcard`](@ref), [`Prepend`](@ref), [`Puts`](@ref), [`ReadBuffer`](@ref), [`ReadFile`](@ref), [`ReadLine`](@ref), [`ReadString`](@ref), [`ReadToDelim`](@ref), [`ReadToken`](@ref), [`Remove`](@ref), [`ReplaceAll`](@ref), [`ReplaceSpecialCppChars`](@ref), [`Replace`](@ref), [`Resize`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Strip`](@ref), [`SubString`](@ref), [`Swap`](@ref), [`TString!BaseConvert`](@ref), [`TString!Class_Name`](@ref), [`TString!Class_Version`](@ref), [`TString!Class`](@ref), [`TString!DeclFileName`](@ref), [`TString!Format`](@ref), [`TString!GetInitialCapacity`](@ref), [`TString!GetMaxWaste`](@ref), [`TString!GetResizeIncrement`](@ref), [`TString!Hash`](@ref), [`TString!InitialCapacity`](@ref), [`TString!Itoa`](@ref), [`TString!LLtoa`](@ref), [`TString!MaxWaste`](@ref), [`TString!ReadString`](@ref), [`TString!ResizeIncrement`](@ref), [`TString!UItoa`](@ref), [`TString!ULLtoa`](@ref), [`TString!WriteString`](@ref), [`TString`](@ref), [`ToLower`](@ref), [`ToUpper`](@ref), [`Tokenize`](@ref), [`View`](@ref), [`add!`](@ref), [`assign`](@ref), [`const char *`](@ref), [`paren`](@ref)
""" TString

# Wrapper of TObjArrayIter
@trydoc raw"""
    ROOT.TObjArrayIter

Iterator of object array.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TObjArrayIter`](@ref), [`assign`](@ref)
""" TObjArrayIter

# Wrapper of TCollection
@trydoc raw"""
    ROOT.TCollection

Collection abstract base class.

This class describes the base protocol all collection classes have to implement. The [ROOT](@ref) collection classes always store pointers to objects that inherit from [TObject](@ref). They never adopt the objects. Therefore, it is the user's responsibility to take care of deleting the actual objects once they are not needed anymore. In exceptional cases, when the user is 100% sure nothing else is referencing the objects in the collection, one can delete all objects and the collection at the same time using the [Delete()](@ref) function.

Collections can be iterated using an iterator object (see [TIterator](@ref)). Depending on the concrete collection class there may be some additional methods of iterating. See the respective classes.

[TCollection](@ref) inherits from [TObject](@ref) since we want to be able to have collections of collections.

In a later release the collections may become templatized.

The following describes how you can access the elements in case an interface returns a [ROOT](@ref) collection type such as [TList](@ref) or [TObjArray](@ref). These type of [ROOT](@ref) collections hold pointers to [TObject](@ref). In other words, to store an object in a [ROOT](@ref) collection, it must inherit from [TObject](@ref). You can think of a [TList](@ref) as a std!list<TObject*>.

###Note

For historical reasons, some of ROOT’s interfaces use ROOT’s own collection types such as TList and TObjArray. In modern code (within ROOT and your own), it's recommended to rather use std!array or std!vector etc. from the C++ Standard Library, and their standard iterators.

Traditional ways of iterating through these elements rely on the use of [TIter](@ref), R__FOR_EACH, std!for_each, range-based for, [TObjLink!Next](@ref) or [TList!After](@ref), as described in the 6 examples of [TList](@ref) documentation.

However, these ways of retrieval through the parent class TObject* are often not useful, since those pointers have to be cast back to the correct subclass. For instance, with [TTree!GetListOfBranches()](@ref), you know that the derived class is of type TBranch*. For this purpose, [ROOT](@ref) offers a specific tools for range-based for loops: such as [ROOT!RRangeCast](@ref), TRangeStaticCast and TRangeDynCast (in this example):

    for (auto br : TRangeDynCast<TBranch>( tree->GetListOfBranches() )) {
        if (!br) continue;
        // Use br as a TBranch*
    }

(C++ version of the code)

Related functions: [`AddAll`](@ref), [`AddVector`](@ref), [`Add`](@ref), [`AssertClass`](@ref), [`Browse`](@ref), [`Capacity`](@ref), [`Clear`](@ref), [`Clone`](@ref), [`Compare`](@ref), [`Contains`](@ref), [`Delete`](@ref), [`Draw`](@ref), [`Dump`](@ref), [`FindObject`](@ref), [`GetEntries`](@ref), [`GetName`](@ref), [`GetObjectRef`](@ref), [`GetSize`](@ref), [`GrowBy`](@ref), [`Hash`](@ref), [`IsArgNull`](@ref), [`IsEmpty`](@ref), [`IsFolder`](@ref), [`IsOwner`](@ref), [`IsSortable`](@ref), [`IsUsingRWLock`](@ref), [`MakeIterator`](@ref), [`MakeReverseIterator`](@ref), [`Notify`](@ref), [`Paint`](@ref), [`Print`](@ref), [`RecursiveRemove`](@ref), [`RemoveAll`](@ref), [`Remove`](@ref), [`SetCurrentCollection`](@ref), [`SetName`](@ref), [`SetOwner`](@ref), [`TCollection!EmptyGarbageCollection`](@ref), [`TCollection!GarbageCollect`](@ref), [`TCollection!GetCurrentCollection`](@ref), [`TCollection!StartGarbageCollection`](@ref), [`UseRWLock`](@ref), [`Write`](@ref), [`ls`](@ref), [`paren`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TCollection

# Wrapper of TDirectory
@trydoc raw"""
    ROOT.TDirectory

Describe directory structure in memory.



Related functions: [`Add`](@ref), [`AppendKey`](@ref), [`Append`](@ref), [`Browse`](@ref), [`Build`](@ref), [`Clear`](@ref), [`CloneObject`](@ref), [`Close`](@ref), [`Copy`](@ref), [`DeleteAll`](@ref), [`Delete`](@ref), [`Draw`](@ref), [`FindKeyAny`](@ref), [`FindKey`](@ref), [`FindObjectAnyFile`](@ref), [`FindObjectAny`](@ref), [`FindObject`](@ref), [`GetBufferSize`](@ref), [`GetDirectory`](@ref), [`GetFile`](@ref), [`GetKey`](@ref), [`GetListOfKeys`](@ref), [`GetList`](@ref), [`GetMotherDir`](@ref), [`GetMother`](@ref), [`GetNbytesKeys`](@ref), [`GetNkeys`](@ref), [`GetObjectChecked`](@ref), [`GetObjectUnchecked`](@ref), [`GetObject`](@ref), [`GetPathStatic`](@ref), [`GetPath`](@ref), [`GetSeekDir`](@ref), [`GetSeekKeys`](@ref), [`GetSeekParent`](@ref), [`GetUUID`](@ref), [`Get`](@ref), [`IsA`](@ref), [`IsBuilt`](@ref), [`IsFolder`](@ref), [`IsModified`](@ref), [`IsWritable`](@ref), [`OpenFile`](@ref), [`Paint`](@ref), [`Print`](@ref), [`Purge`](@ref), [`ReadAll`](@ref), [`ReadKeys`](@ref), [`ReadTObject`](@ref), [`RecursiveRemove`](@ref), [`Remove`](@ref), [`SaveObjectAs`](@ref), [`SaveSelf`](@ref), [`Save`](@ref), [`SetBufferSize`](@ref), [`SetModified`](@ref), [`SetMother`](@ref), [`SetName`](@ref), [`SetSeekDir`](@ref), [`SetTRefAction`](@ref), [`SetWritable`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TDirectory!AddDirectoryStatus`](@ref), [`TDirectory!AddDirectory`](@ref), [`TDirectory!Cd`](@ref), [`TDirectory!Class_Name`](@ref), [`TDirectory!Class_Version`](@ref), [`TDirectory!Class`](@ref), [`TDirectory!CurrentDirectory`](@ref), [`TDirectory!DeclFileName`](@ref), [`TDirectory!DecodeNameCycle`](@ref), [`TDirectory`](@ref), [`WriteDirHeader`](@ref), [`WriteKeys`](@ref), [`WriteObjectAny`](@ref), [`WriteObject`](@ref), [`WriteTObject`](@ref), [`Write`](@ref), [`cd`](@ref), [`ls`](@ref), [`mkdir`](@ref), [`pwd`](@ref), [`rmdir`](@ref)
""" TDirectory

# Wrapper of TKey
@trydoc raw"""
    ROOT.TKey

Book space in a file, create I/O buffers, to fill them, (un)compress them.

The [TKey](@ref) class includes functions to book space in a file, to create I/O buffers, to fill these buffers, to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must be created. The key structure contains all the information to uniquely identify a persistent object in a file. 
| **Data Member** | **Explanation**                                                                                                                 |
|:----------------|:--------------------------------------------------------------------------------------------------------------------------------|
| fNbytes         | Number of bytes for the compressed object and key.                                                                              |
| fObjlen         | Length of uncompressed object.                                                                                                  |
| fDatime         | Date/Time when the object was written.                                                                                          |
| fKeylen         | Number of bytes for the key structure.                                                                                          |
| fCycle          | Cycle number of the object.                                                                                                     |
| fSeekKey        | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |
| fSeekPdir       | Pointer to the directory supporting this object.                                                                                |
| fClassName      | Object class name.                                                                                                              |
| fName           | Name of the object.                                                                                                             |
| fTitle          | Title of the object.                                                                                                            |

In the 16 highest bits of fSeekPdir is encoded a pid offset. This offset is to be added to the pid index stored in the [TRef](@ref) object and the referenced [TObject](@ref).

The [TKey](@ref) class is used by [ROOT](@ref) to:

- Write an object in the current directory
- Write a new ntuple buffer

The structure of a file is shown in TFile!TFile. The structure of a directory is shown in TDirectoryFile!TDirectoryFile. The [TKey](@ref) class is used by the [TBasket](@ref) class. See also [TTree](@ref).

Related functions: [`Browse`](@ref), [`ClassDefOverride`](@ref), [`DeleteBuffer`](@ref), [`Delete`](@ref), [`FillBuffer`](@ref), [`GetBufferRef`](@ref), [`GetBuffer`](@ref), [`GetClassName`](@ref), [`GetCycle`](@ref), [`GetDatime`](@ref), [`GetFile`](@ref), [`GetIconName`](@ref), [`GetKeep`](@ref), [`GetKeylen`](@ref), [`GetMotherDir`](@ref), [`GetNbytes`](@ref), [`GetObjlen`](@ref), [`GetSeekKey`](@ref), [`GetSeekPdir`](@ref), [`GetTitle`](@ref), [`GetVersion`](@ref), [`IncrementPidOffset`](@ref), [`IsFolder`](@ref), [`Keep`](@ref), [`Print`](@ref), [`ReadBuffer`](@ref), [`ReadFile`](@ref), [`ReadKeyBuffer`](@ref), [`ReadObjWithBuffer`](@ref), [`ReadObj`](@ref), [`ReadObjectAny`](@ref), [`ReadObject`](@ref), [`Read`](@ref), [`SetBuffer`](@ref), [`SetMotherDir`](@ref), [`SetParent`](@ref), [`Sizeof`](@ref), [`TKey`](@ref), [`WriteFile`](@ref), [`ls`](@ref)
""" TKey

# Wrapper of TFile
@trydoc raw"""
    ROOT.TFile

A [ROOT](@ref) file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies.

###Note

See also Input/Output Library 

###Note

See also rootio (or io/doc/TFile folder in your codebase)

 **[ROOT](@ref) file data format specification**

A [ROOT](@ref) file is composed of a header, followed by consecutive data records (`TKey` instances) with a well defined format.

The first data record starts at byte fBEGIN (currently set to kBEGIN). Bytes 1->kBEGIN contain the file description, when fVersion >= 1000000 it is a large file (> 2 GB) and the offsets will be 8 bytes long and fUnits will be set to 8:

| **Byte Range**  | **Record Name** | **Description**                                    |
|:----------------|:----------------|:---------------------------------------------------|
| 1->4            | "root"          | Root file identifier                               |
| 5->8            | fVersion        | File format version                                |
| 9->12           | fBEGIN          | Pointer to first data record                       |
| 13->16 [13->20] | fEND            | Pointer to first free word at the EOF              |
| 17->20 [21->28] | fSeekFree       | Pointer to FREE data record                        |
| 21->24 [29->32] | fNbytesFree     | Number of bytes in FREE data record                |
| 25->28 [33->36] | nfree           | Number of free data records                        |
| 29->32 [37->40] | fNbytesName     | Number of bytes in [TNamed](@ref) at creation time |
| 33->33 [41->41] | fUnits          | Number of bytes for file pointers                  |
| 34->37 [42->45] | fCompress       | Compression level and algorithm                    |
| 38->41 [46->53] | fSeekInfo       | Pointer to [TStreamerInfo](@ref) record            |
| 42->45 [54->57] | fNbytesInfo     | Number of bytes in [TStreamerInfo](@ref) record    |
| 46->63 [58->75] | fUUID           | Universal Unique ID                                |

For the purpose of magic bytes in the context of [ROOT](@ref) files' MIME definition, the following additional requirements are introduced:

- The value of `fBEGIN` is fixed at 100.
- The four bytes starting at position 96 are reserved and must be 0. If any changes to this need to be made, `media-types@iana.org` needs to be notified in accordance with RFC 6838.

The key structure is as follows; if a key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 instead of 4 bytes (see parts marked with square brackets below):

| **Byte Range**  | **Member Name** | **Description**                               |
|:----------------|:----------------|:----------------------------------------------|
| 1->4            | Nbytes          | Length of compressed object (in bytes)        |
| 5->6            | Version         | [TKey](@ref) version identifier               |
| 7->10           | ObjLen          | Length of uncompressed object                 |
| 11->14          | Datime          | Date and time when object was written to file |
| 15->16          | KeyLen          | Length of the key structure (in bytes)        |
| 17->18          | Cycle           | Cycle of key                                  |
| 19->22 [19->26] | SeekKey         | Pointer to record itself (consistency check)  |
| 23->26 [27->34] | SeekPdir        | Pointer to directory header                   |
| 27->27 [35->35] | lname           | Number of bytes in the class name             |
| 28->.. [36->..] | ClassName       | Object Class Name                             |
| ..->..          | lname           | Number of bytes in the object name            |
| ..->..          | Name            | lName bytes with the name of the object       |
| ..->..          | lTitle          | Number of bytes in the object title           |
| ..->..          | Title           | Title of the object                           |
| --—>            | DATA            | Data bytes associated to the object           |

![https://root.cern/doc/v636/pict1_TFile_001.png](https://root.cern/doc/v636/pict1_TFile_001.png)

The structure of a directory is shown in TDirectoryFile!TDirectoryFile

Related functions: [`Close`](@ref), [`Copy`](@ref), [`Cp`](@ref), [`CreateKey`](@ref), [`Delete`](@ref), [`DrawMap`](@ref), [`Draw`](@ref), [`FillBuffer`](@ref), [`Flush`](@ref), [`GetArchiveOffset`](@ref), [`GetArchive`](@ref), [`GetBestBuffer`](@ref), [`GetBytesReadExtra`](@ref), [`GetBytesRead`](@ref), [`GetBytesToPrefetch`](@ref), [`GetBytesWritten`](@ref), [`GetCacheRead`](@ref), [`GetCacheWrite`](@ref), [`GetClassIndex`](@ref), [`GetCompressionAlgorithm`](@ref), [`GetCompressionFactor`](@ref), [`GetCompressionLevel`](@ref), [`GetCompressionSettings`](@ref), [`GetEND`](@ref), [`GetEndpointUrl`](@ref), [`GetErrno`](@ref), [`GetFd`](@ref), [`GetListOfFree`](@ref), [`GetListOfProcessIDs`](@ref), [`GetNProcessIDs`](@ref), [`GetNbytesFree`](@ref), [`GetNbytesInfo`](@ref), [`GetNewUrl`](@ref), [`GetNfree`](@ref), [`GetOption`](@ref), [`GetReadCalls`](@ref), [`GetRecordHeader`](@ref), [`GetRelOffset`](@ref), [`GetSeekFree`](@ref), [`GetSeekInfo`](@ref), [`GetSize`](@ref), [`GetStreamerInfoCache`](@ref), [`GetStreamerInfoList`](@ref), [`GetVersion`](@ref), [`IncrementProcessIDs`](@ref), [`IsArchive`](@ref), [`IsBinary`](@ref), [`IsOpen`](@ref), [`IsRaw`](@ref), [`MakeFree`](@ref), [`MakeProject`](@ref), [`Map`](@ref), [`Matches`](@ref), [`MustFlush`](@ref), [`Paint`](@ref), [`Print`](@ref), [`ReOpen`](@ref), [`ReadBufferAsync`](@ref), [`ReadBuffer`](@ref), [`ReadBuffers`](@ref), [`ReadFree`](@ref), [`ReadProcessID`](@ref), [`ReadStreamerInfo`](@ref), [`Recover`](@ref), [`ResetErrno`](@ref), [`Seek`](@ref), [`SetCacheRead`](@ref), [`SetCacheWrite`](@ref), [`SetCompressionAlgorithm`](@ref), [`SetCompressionLevel`](@ref), [`SetCompressionSettings`](@ref), [`SetEND`](@ref), [`SetOffset`](@ref), [`SetOption`](@ref), [`SetReadCalls`](@ref), [`ShowStreamerInfo`](@ref), [`Sizeof`](@ref), [`SumBuffer`](@ref), [`TFile!AsyncOpen`](@ref), [`TFile!Cp`](@ref), [`TFile!CurrentFile`](@ref), [`TFile!GetAsyncOpenStatus`](@ref), [`TFile!GetCacheFileDir`](@ref), [`TFile!GetEndpointUrl`](@ref), [`TFile!GetFileBytesRead`](@ref), [`TFile!GetFileBytesWritten`](@ref), [`TFile!GetFileCounter`](@ref), [`TFile!GetFileReadCalls`](@ref), [`TFile!GetOnlyStaged`](@ref), [`TFile!GetOpenTimeout`](@ref), [`TFile!GetReadStreamerInfo`](@ref), [`TFile!GetReadaheadSize`](@ref), [`TFile!GetType`](@ref), [`TFile!IncrementFileCounter`](@ref), [`TFile!Open`](@ref), [`TFile!SetCacheFileDir`](@ref), [`TFile!SetFileBytesRead`](@ref), [`TFile!SetFileBytesWritten`](@ref), [`TFile!SetFileReadCalls`](@ref), [`TFile!SetOnlyStaged`](@ref), [`TFile!SetOpenTimeout`](@ref), [`TFile!SetReadStreamerInfo`](@ref), [`TFile!SetReadaheadSize`](@ref), [`TFile!ShrinkCacheFileDir`](@ref), [`TFile`](@ref), [`WalkTKeys`](@ref), [`WriteBuffer`](@ref), [`WriteFree`](@ref), [`WriteHeader`](@ref), [`WriteProcessID`](@ref), [`WriteStreamerInfo`](@ref), [`Write`](@ref), [`ls`](@ref)
""" TFile

# Wrapper of TList
@trydoc raw"""
    ROOT.TList

A doubly linked list.

All classes inheriting from [TObject](@ref) can be inserted in a [TList](@ref). Before being inserted into the list the object pointer is wrapped in a [TObjLink](@ref) object which contains, besides the object pointer also a previous and next pointer.

There are several ways to iterate over a [TList](@ref); in order of preference, if not forced by other constraints:

1. (Preferred way) Using the C++ range-based `for` or `thebegin()` / `theend()`: 

        for(TObject *obj: *GetListOfPrimitives())
           obj->Write();

(C++ version of the code)

2. Using the R__FOR_EACH macro: 

        GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);

(C++ version of the code)

3. Using the [TList](@ref) iterator [TListIter](@ref) (via the wrapper class [TIter](@ref)): 

        TIter next(GetListOfPrimitives());
        while (TObject *obj = next())
           obj->Draw(next.GetOption());

(C++ version of the code)

4. Using the [TList](@ref) iterator [TListIter](@ref) and std!for_each algorithm: 

        // A function object, which will be applied to each element
        // of the given range.
        struct STestFunctor {
           bool operator()(TObject *aObj) {
              ...
              return true;
           }
        }
        ...
        ...
        TIter iter(mylist);
        for_each( iter.Begin(), TIter!End(), STestFunctor() );

(C++ version of the code)

5. Using the [TObjLink](@ref) list entries (that wrap the TObject*): 

        TObjLink *lnk = GetListOfPrimitives()->FirstLink();
        while (lnk) {
           lnk->GetObject()->Draw(lnk->GetOption());
           lnk = lnk->Next();
        }

(C++ version of the code)

6. Using the [TList](@ref)'s [After()](@ref) and [Before()](@ref) member functions: 

        TFree *idcur = this;
        while (idcur) {
           ...
           ...
           idcur = (TFree*)GetListOfFree()->After(idcur);
        }

(C++ version of the code)

 Methods 3, 4 and 5 can also easily iterate backwards using either a backward [TIter](@ref) (using argument kIterBackward) or by using [LastLink()](@ref) and lnk->Prev() or by using the [Before()](@ref) member.

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Before`](@ref), [`Clear`](@ref), [`Delete`](@ref), [`FindObject`](@ref), [`FirstLink`](@ref), [`First`](@ref), [`GetObjectRef`](@ref), [`IsAscending`](@ref), [`LastLink`](@ref), [`Last`](@ref), [`MakeIterator`](@ref), [`RecursiveRemove`](@ref), [`RemoveLast`](@ref), [`Remove`](@ref), [`Sort`](@ref), [`TList`](@ref)
""" TList

# Wrapper of TUUID
@trydoc raw"""
    ROOT.TUUID

This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier).

A UUID is 128 bits long, and if generated according to this algorithm, is either guaranteed to be different from all other UUIDs/GUIDs generated until 3400 A.D. or extremely likely to be different. UUIDs were originally used in the Network Computing System (NCS) and later in the Open Software Foundation's (OSF) Distributed Computing Environment (DCE).

###Note

In the way this UUID is constructed, when used outside of their original concept (NCS), they are actually not Globally unique and indeed multiple distinct concurrent processes are actually likely to generate the same UUID. Technically this is because the UUID is constructed only from the node information and time information. To make a globally unique number, this needs to be combined with TProcessUUID.

Structure of universal unique IDs (UUIDs).

Depending on the network data representation, the multi- octet unsigned integer fields are subject to byte swapping when communicated between dissimilar endian machines. 

    +-----------------------------------+
    |     low 32 bits of time           |  0-3   .fTimeLow
    +-------------------------------+----
    |     mid 16 bits of time       |      4-5   .fTimeMid
    +-------+-----------------------+
    | vers. |   hi 12 bits of time  |      6-7   .fTimeHiAndVersion
    +-------+-------+---------------+
    |Res | clkSeqHi |                      8     .fClockSeqHiAndReserved
    +---------------+
    |   clkSeqLow   |                      9     .fClockSeqLow
    +---------------+------------------+
    |            node ID               |   10-15 .fNode
    +----------------------------------+

(C++ version of the code)

The adjusted time stamp is split into three fields, and the clockSeq is split into two fields.

The timestamp is a 60-bit value. For UUID version 1, this is represented by Coordinated Universal Time (UTC/GMT) as a count of 100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar).

The version number is multiplexed in the 4 most significant bits of the 'fTimeHiAndVersion' field. There are two defined versions: 

                  MSB <---
    Version      4-Bit Code      Description
    ------------------------------------------------------------
    |  1           0 0 0 1     DCE version, as specified herein.
    |  2           0 0 1 0     DCE Security version, with
    |                          embedded POSIX UIDs.
    |  3           0 0 1 1     node id is a random value
    ------------------------------------------------------------

(C++ version of the code)

## Clock Sequence

The clock sequence value must be changed whenever:

The UUID generator detects that the local_ value of UTC has gone backward; this may be due to re-syncing of the system clock.

While a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.

The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly.

## Clock Adjustment

UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is read and incremented, and then added to the UTC time field of the UUID.

## Clock Overrun

The 100-nanosecond granularity of time should prove sufficient even for bursts of UUID production in the next generation of high-performance multiprocessors. If a system overruns the clock adjustment by requesting too many UUIDs within a single system clock tick, the UUID generator will stall until the system clock catches up.

Related functions: [`AsString`](@ref), [`Compare`](@ref), [`FillBuffer`](@ref), [`GetHostAddress`](@ref), [`GetTime`](@ref), [`GetUUIDNumber`](@ref), [`GetUUID`](@ref), [`Hash`](@ref), [`IsA`](@ref), [`Print`](@ref), [`ReadBuffer`](@ref), [`SetUUIDNumber`](@ref), [`SetUUID`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`StreamerV1`](@ref), [`Streamer`](@ref), [`TUUID!Class_Name`](@ref), [`TUUID!Class_Version`](@ref), [`TUUID!Class`](@ref), [`TUUID!DeclFileName`](@ref), [`TUUID`](@ref)
""" TUUID

# Wrapper of TVirtualMutex
@trydoc raw"""
    ROOT.TVirtualMutex

This class implements a mutex interface.

The actual work is done via [TMutex](@ref) which is available as soon as the thread library is loaded.

and

[TLockGuard](@ref)

This class provides mutex resource management in a guaranteed and exception safe way. Use like this: 

    {
       TLockGuard guard(mutex);
       ... // do something
    }

(C++ version of the code)

 when guard goes out of scope the mutex is unlocked in the [TLockGuard](@ref) destructor. The exception mechanism takes care of calling the dtors of local_ objects so it is exception safe.

Related functions: [`Acquire`](@ref), [`CleanUp`](@ref), [`Factory`](@ref), [`IsA`](@ref), [`Lock`](@ref), [`Release`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualMutex!Class_Name`](@ref), [`TVirtualMutex!Class_Version`](@ref), [`TVirtualMutex!Class`](@ref), [`TVirtualMutex!DeclFileName`](@ref), [`TVirtualMutex`](@ref), [`TryLock`](@ref), [`UnLock`](@ref)
""" TVirtualMutex

# Wrapper of TROOT
@trydoc raw"""
    ROOT.TROOT

[ROOT](@ref) top level object description.

The [TROOT](@ref) object is the entry point to the [ROOT](@ref) system. The single instance of [TROOT](@ref) is accessible via the global_ gROOT. Using the gROOT pointer one has access to basically every object created in a [ROOT](@ref) based program. The [TROOT](@ref) object is essentially a container of several lists pointing to the main [ROOT](@ref) objects.

The following lists are accessible from gROOT object:

    gROOT->GetListOfClasses
    gROOT->GetListOfColors
    gROOT->GetListOfTypes
    gROOT->GetListOfGlobals
    gROOT->GetListOfGlobalFunctions
    gROOT->GetListOfFiles
    gROOT->GetListOfMappedFiles
    gROOT->GetListOfSockets
    gROOT->GetListOfSecContexts
    gROOT->GetListOfCanvases
    gROOT->GetListOfStyles
    gROOT->GetListOfFunctions
    gROOT->GetListOfSpecials (for example graphical cuts)
    gROOT->GetListOfGeometries
    gROOT->GetListOfBrowsers
    gROOT->GetListOfCleanups
    gROOT->GetListOfMessageHandlers

(C++ version of the code)

The [TROOT](@ref) class provides also many useful services:

- Get pointer to an object in any of the lists above
- Time utilities [TROOT!Time](@ref)

The [ROOT](@ref) object must be created as a static object. An example of a main program creating an interactive version is shown below:

### Example of a main program

    #include "TRint.h"
    int main(int argc, char **argv)
    {
       TRint *theApp = new TRint("ROOT example", &argc, argv);
       // Init Intrinsics, build all windows, and enter event loop
       theApp->Run();
       return(0);
    }

(C++ version of the code)

Related functions: [`AddClassGenerator`](@ref), [`AddClass`](@ref), [`Append`](@ref), [`Browse`](@ref), [`ClassSaved`](@ref), [`CloseFiles`](@ref), [`EndOfProcessCleanups`](@ref), [`FindObjectAnyFile`](@ref), [`FindObjectAny`](@ref), [`FindObjectClassName`](@ref), [`FindObjectPathName`](@ref), [`FindObject`](@ref), [`FindSTLClass`](@ref), [`FindSpecialObject`](@ref), [`ForceStyle`](@ref), [`FromPopUp`](@ref), [`GetApplication`](@ref), [`GetBuiltDate`](@ref), [`GetBuiltTime`](@ref), [`GetClass`](@ref), [`GetClipboard`](@ref), [`GetColor`](@ref), [`GetConfigFeatures`](@ref), [`GetConfigOptions`](@ref), [`GetCutClassName`](@ref), [`GetDefCanvasName`](@ref), [`GetEditHistograms`](@ref), [`GetEditorMode`](@ref), [`GetFile`](@ref), [`GetForceStyle`](@ref), [`GetFunctionTemplate`](@ref), [`GetFunction`](@ref), [`GetGeometry`](@ref), [`GetGitBranch`](@ref), [`GetGitCommit`](@ref), [`GetGitDate`](@ref), [`GetGlobalFunctionWithPrototype`](@ref), [`GetGlobalFunction`](@ref), [`GetGlobal`](@ref), [`GetInterpreter`](@ref), [`GetListOfBrowsables`](@ref), [`GetListOfBrowsers`](@ref), [`GetListOfCanvases`](@ref), [`GetListOfClassGenerators`](@ref), [`GetListOfClasses`](@ref), [`GetListOfCleanups`](@ref), [`GetListOfClosedObjects`](@ref), [`GetListOfColors`](@ref), [`GetListOfDataSets`](@ref), [`GetListOfEnums`](@ref), [`GetListOfFiles`](@ref), [`GetListOfFunctionOverloads`](@ref), [`GetListOfFunctionTemplates`](@ref), [`GetListOfFunctions`](@ref), [`GetListOfGeometries`](@ref), [`GetListOfGlobalFunctions`](@ref), [`GetListOfGlobals`](@ref), [`GetListOfMappedFiles`](@ref), [`GetListOfMessageHandlers`](@ref), [`GetListOfProofs`](@ref), [`GetListOfSecContexts`](@ref), [`GetListOfSockets`](@ref), [`GetListOfSpecials`](@ref), [`GetListOfStreamerInfo`](@ref), [`GetListOfStyles`](@ref), [`GetListOfTasks`](@ref), [`GetListOfTypes`](@ref), [`GetNclasses`](@ref), [`GetNtypes`](@ref), [`GetPluginManager`](@ref), [`GetRootFolder`](@ref), [`GetSelectedPad`](@ref), [`GetSelectedPrimitive`](@ref), [`GetStyle`](@ref), [`GetType`](@ref), [`GetUUIDs`](@ref), [`GetVersionCode`](@ref), [`GetVersionDate`](@ref), [`GetVersionInt`](@ref), [`GetVersionTime`](@ref), [`GetVersion`](@ref), [`GetWebDisplay`](@ref), [`Idle`](@ref), [`IgnoreInclude`](@ref), [`IsA`](@ref), [`IsBatch`](@ref), [`IsEscaped`](@ref), [`IsExecutingMacro`](@ref), [`IsFolder`](@ref), [`IsInterrupted`](@ref), [`IsLineProcessing`](@ref), [`IsProofServ`](@ref), [`IsRootFile`](@ref), [`IsWebDisplayBatch`](@ref), [`IsWebDisplay`](@ref), [`LoadClass`](@ref), [`LoadMacro`](@ref), [`Macro`](@ref), [`MakeDefCanvas`](@ref), [`Message`](@ref), [`MustClean`](@ref), [`ProcessLineFast`](@ref), [`ProcessLineSync`](@ref), [`ProcessLine`](@ref), [`ReadingObject`](@ref), [`RecursiveRemove`](@ref), [`RefreshBrowsers`](@ref), [`RemoveClass`](@ref), [`Remove`](@ref), [`ResetClassSaved`](@ref), [`Reset`](@ref), [`SaveContext`](@ref), [`SetApplication`](@ref), [`SetBatch`](@ref), [`SetCutClassName`](@ref), [`SetDefCanvasName`](@ref), [`SetEditHistograms`](@ref), [`SetEditorMode`](@ref), [`SetEscape`](@ref), [`SetExecutingMacro`](@ref), [`SetFromPopUp`](@ref), [`SetInterrupt`](@ref), [`SetLineHasBeenProcessed`](@ref), [`SetLineIsProcessing`](@ref), [`SetMustClean`](@ref), [`SetReadingObject`](@ref), [`SetSelectedPad`](@ref), [`SetSelectedPrimitive`](@ref), [`SetStyle`](@ref), [`SetWebDisplay`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TROOT!AddExtraInterpreterArgs`](@ref), [`TROOT!Class_Name`](@ref), [`TROOT!Class_Version`](@ref), [`TROOT!Class`](@ref), [`TROOT!ConvertVersionCode2Int`](@ref), [`TROOT!ConvertVersionInt2Code`](@ref), [`TROOT!DeclFileName`](@ref), [`TROOT!DecreaseDirLevel`](@ref), [`TROOT!GetBinDir`](@ref), [`TROOT!GetDataDir`](@ref), [`TROOT!GetDirLevel`](@ref), [`TROOT!GetDocDir`](@ref), [`TROOT!GetEtcDir`](@ref), [`TROOT!GetExtraInterpreterArgs`](@ref), [`TROOT!GetIconPath`](@ref), [`TROOT!GetIncludeDir`](@ref), [`TROOT!GetLibDir`](@ref), [`TROOT!GetMacroDir`](@ref), [`TROOT!GetMacroPath`](@ref), [`TROOT!GetRootSys`](@ref), [`TROOT!GetSharedLibDir`](@ref), [`TROOT!GetSourceDir`](@ref), [`TROOT!GetTTFFontDir`](@ref), [`TROOT!GetTutorialDir`](@ref), [`TROOT!GetTutorialsDir`](@ref), [`TROOT!IncreaseDirLevel`](@ref), [`TROOT!IndentLevel`](@ref), [`TROOT!Initialize`](@ref), [`TROOT!Initialized`](@ref), [`TROOT!RegisterModule`](@ref), [`TROOT!RootVersionCode`](@ref), [`TROOT!SetDirLevel`](@ref), [`TROOT!SetMacroPath`](@ref), [`TROOT!ShutDown`](@ref), [`TROOT`](@ref), [`Time`](@ref), [`Timer`](@ref), [`ls`](@ref)
""" TROOT

# Wrapper of TApplication
@trydoc raw"""
    ROOT.TApplication

This class creates the [ROOT](@ref) Application Environment that interfaces to the windowing system eventloop and eventhandlers.

This class must be instantiated exactly once in any given application. Normally the specific application class inherits from [TApplication](@ref) (see [TRint](@ref)).

Related functions: [`ApplicationName`](@ref), [`Argc`](@ref), [`Argv`](@ref), [`ClearInputFiles`](@ref), [`ExitOnException`](@ref), [`GetAppRemote`](@ref), [`GetApplicationImp`](@ref), [`GetIdleCommand`](@ref), [`GetOptions`](@ref), [`GetSetup`](@ref), [`GetSignalHandler`](@ref), [`HandleException`](@ref), [`HandleIdleTimer`](@ref), [`HandleTermInput`](@ref), [`Hide`](@ref), [`Iconify`](@ref), [`Init`](@ref), [`InitializeGraphics`](@ref), [`InputFiles`](@ref), [`IsA`](@ref), [`IsCmdThread`](@ref), [`IsRunning`](@ref), [`KeyPressed`](@ref), [`LineProcessed`](@ref), [`Lower`](@ref), [`NoLogOpt`](@ref), [`NoLogoOpt`](@ref), [`OpenForumTopic`](@ref), [`OpenGitHubIssue`](@ref), [`OpenInBrowser`](@ref), [`OpenReferenceGuideFor`](@ref), [`Open`](@ref), [`ProcessFile`](@ref), [`ProcessLine`](@ref), [`QuitOpt`](@ref), [`Raise`](@ref), [`RemoveIdleTimer`](@ref), [`ReturnFromRun`](@ref), [`ReturnPressed`](@ref), [`Run`](@ref), [`SetEchoMode`](@ref), [`SetIdleTimer`](@ref), [`SetReturnFromRun`](@ref), [`Show`](@ref), [`StartIdleing`](@ref), [`StopIdleing`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TApplication!Class_Name`](@ref), [`TApplication!Class_Version`](@ref), [`TApplication!Class`](@ref), [`TApplication!CreateApplication`](@ref), [`TApplication!DeclFileName`](@ref), [`TApplication!ExecuteFile`](@ref), [`TApplication!GetApplications`](@ref), [`TApplication!NeedGraphicsLibs`](@ref), [`TApplication`](@ref), [`TabCompletionHook`](@ref), [`Terminate`](@ref), [`WorkingDirectory`](@ref), [`ls`](@ref)
""" TApplication

# Wrapper of TInterpreter
@trydoc raw"""
    ROOT.TInterpreter

This class defines an abstract interface to a generic command line interpreter.



Related functions: [`AddAvailableIndentifiers`](@ref), [`AddIncludePath`](@ref), [`AutoLoad`](@ref), [`AutoParse`](@ref), [`BaseClassInfo_ClassInfo`](@ref), [`BaseClassInfo_Delete`](@ref), [`BaseClassInfo_Factory`](@ref), [`BaseClassInfo_FullName`](@ref), [`BaseClassInfo_Name`](@ref), [`BaseClassInfo_Next`](@ref), [`BaseClassInfo_Offset`](@ref), [`BaseClassInfo_Property`](@ref), [`BaseClassInfo_Tagnum`](@ref), [`BaseClassInfo_TmpltName`](@ref), [`Calc`](@ref), [`CallFunc_Delete`](@ref), [`CallFunc_ExecDouble`](@ref), [`CallFunc_ExecInt64`](@ref), [`CallFunc_ExecInt`](@ref), [`CallFunc_ExecWithArgsAndReturn`](@ref), [`CallFunc_ExecWithReturn`](@ref), [`CallFunc_Exec`](@ref), [`CallFunc_FactoryCopy`](@ref), [`CallFunc_FactoryMethod`](@ref), [`CallFunc_Factory`](@ref), [`CallFunc_GetWrapperCode`](@ref), [`CallFunc_IFacePtr`](@ref), [`CallFunc_IgnoreExtraArgs`](@ref), [`CallFunc_Init`](@ref), [`CallFunc_IsValid`](@ref), [`CallFunc_ResetArg`](@ref), [`CallFunc_SetArgArray`](@ref), [`CallFunc_SetArgImpl`](@ref), [`CallFunc_SetArgRef`](@ref), [`CallFunc_SetArg`](@ref), [`CallFunc_SetArgs`](@ref), [`CallFunc_SetArguments`](@ref), [`CallFunc_SetFuncProto`](@ref), [`CallFunc_SetFunc`](@ref), [`CheckClassInfo`](@ref), [`CheckClassTemplate`](@ref), [`ClassInfo_ClassProperty`](@ref), [`ClassInfo_Contains`](@ref), [`ClassInfo_DeleteArray`](@ref), [`ClassInfo_Delete`](@ref), [`ClassInfo_Destruct`](@ref), [`ClassInfo_Factory`](@ref), [`ClassInfo_FileName`](@ref), [`ClassInfo_FullName`](@ref), [`ClassInfo_GetBaseOffset`](@ref), [`ClassInfo_GetMethodNArg`](@ref), [`ClassInfo_GetUnderlyingType`](@ref), [`ClassInfo_HasDefaultConstructor`](@ref), [`ClassInfo_HasMethod`](@ref), [`ClassInfo_Init`](@ref), [`ClassInfo_IsBase`](@ref), [`ClassInfo_IsEnum`](@ref), [`ClassInfo_IsLoaded`](@ref), [`ClassInfo_IsScopedEnum`](@ref), [`ClassInfo_IsValidMethod`](@ref), [`ClassInfo_IsValid`](@ref), [`ClassInfo_Name`](@ref), [`ClassInfo_New`](@ref), [`ClassInfo_Next`](@ref), [`ClassInfo_Property`](@ref), [`ClassInfo_Size`](@ref), [`ClassInfo_Tagnum`](@ref), [`ClassInfo_Title`](@ref), [`ClassInfo_TmpltName`](@ref), [`ClearFileBusy`](@ref), [`ClearStack`](@ref), [`CodeComplete`](@ref), [`CreateEnum`](@ref), [`CreateListOfBaseClasses`](@ref), [`CreateListOfDataMembers`](@ref), [`CreateListOfMethodArgs`](@ref), [`CreateListOfMethods`](@ref), [`CreateTemporary`](@ref), [`DataMemberInfo_ArrayDim`](@ref), [`DataMemberInfo_Delete`](@ref), [`DataMemberInfo_FactoryCopy`](@ref), [`DataMemberInfo_Factory`](@ref), [`DataMemberInfo_IsValid`](@ref), [`DataMemberInfo_MaxIndex`](@ref), [`DataMemberInfo_Name`](@ref), [`DataMemberInfo_Next`](@ref), [`DataMemberInfo_Offset`](@ref), [`DataMemberInfo_Property`](@ref), [`DataMemberInfo_Title`](@ref), [`DataMemberInfo_TypeName`](@ref), [`DataMemberInfo_TypeProperty`](@ref), [`DataMemberInfo_TypeSize`](@ref), [`DataMemberInfo_TypeTrueName`](@ref), [`DataMemberInfo_ValidArrayIndex`](@ref), [`Declare`](@ref), [`DeleteGlobal`](@ref), [`DeleteVariable`](@ref), [`DiagnoseIfInterpreterException`](@ref), [`DisplayClass`](@ref), [`DisplayIncludePath`](@ref), [`EndOfLineAction`](@ref), [`Evaluate`](@ref), [`ExecuteMacro`](@ref), [`ExecuteWithArgsAndReturn`](@ref), [`Execute`](@ref), [`FindSym`](@ref), [`ForgetMutexState`](@ref), [`FuncTempInfo_Delete`](@ref), [`FuncTempInfo_ExtraProperty`](@ref), [`FuncTempInfo_FactoryCopy`](@ref), [`FuncTempInfo_Factory`](@ref), [`FuncTempInfo_IsValid`](@ref), [`FuncTempInfo_Name`](@ref), [`FuncTempInfo_Property`](@ref), [`FuncTempInfo_TemplateMinReqArgs`](@ref), [`FuncTempInfo_TemplateNargs`](@ref), [`FuncTempInfo_Title`](@ref), [`GenerateDictionary`](@ref), [`GenerateTClass`](@ref), [`GenericError`](@ref), [`GetAutoLoadCallBack`](@ref), [`GetClassSharedLibs`](@ref), [`GetClass`](@ref), [`GetCurrentMacroName`](@ref), [`GetDataMemberAtAddr`](@ref), [`GetDataMemberWithValue`](@ref), [`GetDataMember`](@ref), [`GetDeclId`](@ref), [`GetEnum`](@ref), [`GetExecByteCode`](@ref), [`GetExitCode`](@ref), [`GetFunctionOverloads`](@ref), [`GetFunctionTemplate`](@ref), [`GetFunctionWithPrototype`](@ref), [`GetFunctionWithValues`](@ref), [`GetFunction`](@ref), [`GetIncludePath`](@ref), [`GetInterfaceMethodWithPrototype`](@ref), [`GetInterfaceMethod`](@ref), [`GetInterpreterStateMarker`](@ref), [`GetInterpreterTypeName`](@ref), [`GetMangledNameWithPrototype`](@ref), [`GetMangledName`](@ref), [`GetMapfile`](@ref), [`GetMore`](@ref), [`GetPrompt`](@ref), [`GetRootMapFiles`](@ref), [`GetSTLIncludePath`](@ref), [`GetSecurityError`](@ref), [`GetSharedLibDeps`](@ref), [`GetSharedLibs`](@ref), [`GetTopLevelMacroName`](@ref), [`GetUsingNamespaces`](@ref), [`HasPCMForLibrary`](@ref), [`Initialize`](@ref), [`InspectMembers`](@ref), [`IsAutoParsingSuspended`](@ref), [`IsErrorMessagesEnabled`](@ref), [`IsFloatingType`](@ref), [`IsIntegerType`](@ref), [`IsLibraryLoaded`](@ref), [`IsLoaded`](@ref), [`IsPointerType`](@ref), [`IsProcessLineLocked`](@ref), [`IsSameType`](@ref), [`IsSignedIntegerType`](@ref), [`IsUnsignedIntegerType`](@ref), [`IsValid`](@ref), [`IsVoidPointerType`](@ref), [`LoadEnums`](@ref), [`LoadFile`](@ref), [`LoadFunctionTemplates`](@ref), [`LoadLibraryMap`](@ref), [`LoadMacro`](@ref), [`LoadText`](@ref), [`Load`](@ref), [`MakeInterpreterValue`](@ref), [`MapCppName`](@ref), [`MethodArgInfo_DefaultValue`](@ref), [`MethodArgInfo_Delete`](@ref), [`MethodArgInfo_FactoryCopy`](@ref), [`MethodArgInfo_Factory`](@ref), [`MethodArgInfo_IsValid`](@ref), [`MethodArgInfo_Name`](@ref), [`MethodArgInfo_Next`](@ref), [`MethodArgInfo_Property`](@ref), [`MethodArgInfo_TypeInfo`](@ref), [`MethodArgInfo_TypeName`](@ref), [`MethodArgInfo_TypeNormalizedName`](@ref), [`MethodCallReturnType`](@ref), [`MethodInfo_CreateSignature`](@ref), [`MethodInfo_Delete`](@ref), [`MethodInfo_ExtraProperty`](@ref), [`MethodInfo_FactoryCopy`](@ref), [`MethodInfo_Factory`](@ref), [`MethodInfo_GetMangledName`](@ref), [`MethodInfo_GetPrototype`](@ref), [`MethodInfo_InterfaceMethod`](@ref), [`MethodInfo_IsValid`](@ref), [`MethodInfo_MethodCallReturnType`](@ref), [`MethodInfo_NArg`](@ref), [`MethodInfo_NDefaultArg`](@ref), [`MethodInfo_Name`](@ref), [`MethodInfo_Next`](@ref), [`MethodInfo_Property`](@ref), [`MethodInfo_Title`](@ref), [`MethodInfo_TypeName`](@ref), [`MethodInfo_TypeNormalizedName`](@ref), [`MethodInfo_Type`](@ref), [`PrintIntro`](@ref), [`ProcessLineSynch`](@ref), [`ProcessLine`](@ref), [`RegisterModule`](@ref), [`RegisterPrebuiltModulePath`](@ref), [`RegisterTClassUpdate`](@ref), [`ReloadAllSharedLibraryMaps`](@ref), [`ReportDiagnosticsToErrorHandler`](@ref), [`RescanLibraryMap`](@ref), [`ResetAll`](@ref), [`ResetGlobalVar`](@ref), [`ResetGlobals`](@ref), [`Reset`](@ref), [`RewindDictionary`](@ref), [`SaveContext`](@ref), [`SaveGlobalsContext`](@ref), [`SetAlloclockfunc`](@ref), [`SetAllocunlockfunc`](@ref), [`SetAutoLoadCallBack`](@ref), [`SetClassAutoLoading`](@ref), [`SetClassAutoloading`](@ref), [`SetClassAutoparsing`](@ref), [`SetClassInfo`](@ref), [`SetClassSharedLibs`](@ref), [`SetDeclAttr`](@ref), [`SetErrmsgcallback`](@ref), [`SetErrorMessages`](@ref), [`SetGetline`](@ref), [`SetProcessLineLock`](@ref), [`SetTempLevel`](@ref), [`ShutDown`](@ref), [`SnapshotMutexState`](@ref), [`TInterpreter!Instance`](@ref), [`TInterpreter`](@ref), [`ToString`](@ref), [`TypeInfo_Delete`](@ref), [`TypeInfo_FactoryCopy`](@ref), [`TypeInfo_Factory`](@ref), [`TypeInfo_Init`](@ref), [`TypeInfo_IsValid`](@ref), [`TypeInfo_Name`](@ref), [`TypeInfo_Property`](@ref), [`TypeInfo_QualTypePtr`](@ref), [`TypeInfo_RefType`](@ref), [`TypeInfo_Size`](@ref), [`TypeInfo_TrueName`](@ref), [`TypeName`](@ref), [`TypedefInfo_Delete`](@ref), [`TypedefInfo_FactoryCopy`](@ref), [`TypedefInfo_Factory`](@ref), [`TypedefInfo_Init`](@ref), [`TypedefInfo_IsValid`](@ref), [`TypedefInfo_Name`](@ref), [`TypedefInfo_Next`](@ref), [`TypedefInfo_Property`](@ref), [`TypedefInfo_Size`](@ref), [`TypedefInfo_Title`](@ref), [`TypedefInfo_TrueName`](@ref), [`UnRegisterTClassUpdate`](@ref), [`UnloadAllSharedLibraryMaps`](@ref), [`UnloadFile`](@ref), [`UnloadLibraryMap`](@ref), [`UpdateEnumConstants`](@ref), [`UpdateListOfGlobalFunctions`](@ref), [`UpdateListOfGlobals`](@ref), [`UpdateListOfMethods`](@ref), [`UpdateListOfTypes`](@ref)
""" TInterpreter

# Wrapper of TSeqCollection
@trydoc raw"""
    ROOT.TSeqCollection

Sequenceable collection abstract base class.

[TSeqCollection](@ref)'s have an ordering relation, i.e. there is a first and last element.

Related functions: [`AddAfter`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`Add`](@ref), [`After`](@ref), [`At`](@ref), [`Before`](@ref), [`First`](@ref), [`GetLast`](@ref), [`IndexOf`](@ref), [`IsSorted`](@ref), [`LastIndex`](@ref), [`Last`](@ref), [`Merge`](@ref), [`RemoveAfter`](@ref), [`RemoveAt`](@ref), [`RemoveBefore`](@ref), [`RemoveFirst`](@ref), [`RemoveLast`](@ref), [`TSeqCollection!ObjCompare`](@ref), [`TSeqCollection!QSort`](@ref), [`UnSort`](@ref)
""" TSeqCollection

# Wrapper of TDataType
@trydoc raw"""
    ROOT.TDataType

Basic data type descriptor (datatype information is obtained from CINT).

This class describes the attributes of type definitions (typedef's). The [TROOT](@ref) class contains a list of all currently defined types (accessible via [TROOT!GetListOfTypes()](@ref)).

Related functions: [`AsString`](@ref), [`GetFullTypeName`](@ref), [`GetTypeName`](@ref), [`GetType`](@ref), [`Property`](@ref), [`Size`](@ref), [`TDataType!AddBuiltins`](@ref), [`TDataType!GetDataType`](@ref), [`TDataType!GetTypeName`](@ref), [`TDataType!GetType`](@ref), [`TDataType`](@ref)
""" TDataType

# Wrapper of TVirtualPad
@trydoc raw"""
    ROOT.TVirtualPad

[TVirtualPad](@ref) is an abstract base class for the Pad and Canvas classes.



Related functions: [`AbsCoordinates`](@ref), [`AbsPixeltoX`](@ref), [`AbsPixeltoY`](@ref), [`AddExec`](@ref), [`AddFirst`](@ref), [`Add`](@ref), [`BuildLegend`](@ref), [`Clear`](@ref), [`Clip`](@ref), [`CloseToolTip`](@ref), [`Close`](@ref), [`CopyPixmap`](@ref), [`CopyPixmaps`](@ref), [`CreateToolTip`](@ref), [`DeleteExec`](@ref), [`DeleteToolTip`](@ref), [`Divide`](@ref), [`DrawClassObject`](@ref), [`DrawFrame`](@ref), [`Draw`](@ref), [`ExecuteEventAxis`](@ref), [`GetAbsHNDC`](@ref), [`GetAbsWNDC`](@ref), [`GetAbsXlowNDC`](@ref), [`GetAbsYlowNDC`](@ref), [`GetAspectRatio`](@ref), [`GetBorderMode`](@ref), [`GetBorderSize`](@ref), [`GetCanvasID`](@ref), [`GetCanvasImp`](@ref), [`GetCanvas`](@ref), [`GetEventX`](@ref), [`GetEventY`](@ref), [`GetEvent`](@ref), [`GetFrame`](@ref), [`GetGLDevice`](@ref), [`GetGridx`](@ref), [`GetGridy`](@ref), [`GetHNDC`](@ref), [`GetHighLightColor`](@ref), [`GetListOfExecs`](@ref), [`GetListOfPrimitives`](@ref), [`GetLogx`](@ref), [`GetLogy`](@ref), [`GetLogz`](@ref), [`GetMother`](@ref), [`GetName`](@ref), [`GetNumber`](@ref), [`GetPadPaint`](@ref), [`GetPadPar`](@ref), [`GetPadPointer`](@ref), [`GetPadSave`](@ref), [`GetPad`](@ref), [`GetPainter`](@ref), [`GetPhi`](@ref), [`GetPixmapID`](@ref), [`GetPrimitive`](@ref), [`GetRangeAxis`](@ref), [`GetRange`](@ref), [`GetSelectedPad`](@ref), [`GetSelected`](@ref), [`GetTheta`](@ref), [`GetTickx`](@ref), [`GetTicky`](@ref), [`GetTitle`](@ref), [`GetUxmax`](@ref), [`GetUxmin`](@ref), [`GetUymax`](@ref), [`GetUymin`](@ref), [`GetView3D`](@ref), [`GetView`](@ref), [`GetViewer3D`](@ref), [`GetVirtCanvas`](@ref), [`GetWNDC`](@ref), [`GetWh`](@ref), [`GetWw`](@ref), [`GetX1`](@ref), [`GetX2`](@ref), [`GetXlowNDC`](@ref), [`GetY1`](@ref), [`GetY2`](@ref), [`GetYlowNDC`](@ref), [`HasCrosshair`](@ref), [`HasFixedAspectRatio`](@ref), [`HasViewer3D`](@ref), [`HighLight`](@ref), [`IncrementPaletteColor`](@ref), [`IsA`](@ref), [`IsBatch`](@ref), [`IsBeingResized`](@ref), [`IsEditable`](@ref), [`IsModified`](@ref), [`IsRetained`](@ref), [`IsVertical`](@ref), [`IsWeb`](@ref), [`ModifiedUpdate`](@ref), [`Modified`](@ref), [`NextPaletteColor`](@ref), [`OpaqueMoving`](@ref), [`OpaqueResizing`](@ref), [`PadInHighlightMode`](@ref), [`PadInSelectionMode`](@ref), [`PadtoX`](@ref), [`PadtoY`](@ref), [`PaintBorderPS`](@ref), [`PaintBox`](@ref), [`PaintFillAreaNDC`](@ref), [`PaintFillArea`](@ref), [`PaintLine3D`](@ref), [`PaintLineNDC`](@ref), [`PaintLine`](@ref), [`PaintModified`](@ref), [`PaintPadFrame`](@ref), [`PaintPolyLine3D`](@ref), [`PaintPolyLineNDC`](@ref), [`PaintPolyLine`](@ref), [`PaintPolyMarker`](@ref), [`PaintTextNDC`](@ref), [`PaintText`](@ref), [`Paint`](@ref), [`PixeltoX`](@ref), [`PixeltoY`](@ref), [`PlaceBox`](@ref), [`PopTopLevelSelectable`](@ref), [`Pop`](@ref), [`Print`](@ref), [`PushSelectableObject`](@ref), [`PushTopLevelSelectable`](@ref), [`RangeAxisChanged`](@ref), [`RangeAxis`](@ref), [`Range`](@ref), [`RecursiveRemove`](@ref), [`RedrawAxis`](@ref), [`ReleaseViewer3D`](@ref), [`Remove`](@ref), [`ResetToolTip`](@ref), [`ResetView3D`](@ref), [`ResizePad`](@ref), [`SaveAs`](@ref), [`SetAttFillPS`](@ref), [`SetAttLinePS`](@ref), [`SetAttMarkerPS`](@ref), [`SetAttTextPS`](@ref), [`SetBatch`](@ref), [`SetBorderMode`](@ref), [`SetBorderSize`](@ref), [`SetCanvasSize`](@ref), [`SetCanvas`](@ref), [`SetCopyGLDevice`](@ref), [`SetCrosshair`](@ref), [`SetCursor`](@ref), [`SetDoubleBuffer`](@ref), [`SetEditable`](@ref), [`SetFixedAspectRatio`](@ref), [`SetGrid`](@ref), [`SetGridx`](@ref), [`SetGridy`](@ref), [`SetLogx`](@ref), [`SetLogy`](@ref), [`SetLogz`](@ref), [`SetName`](@ref), [`SetPad`](@ref), [`SetPhi`](@ref), [`SetSelected`](@ref), [`SetTheta`](@ref), [`SetTicks`](@ref), [`SetTickx`](@ref), [`SetTicky`](@ref), [`SetTitle`](@ref), [`SetToolTipText`](@ref), [`SetVertical`](@ref), [`SetView`](@ref), [`SetViewer3D`](@ref), [`ShowGuidelines`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TVirtualPad!Class_Name`](@ref), [`TVirtualPad!Class_Version`](@ref), [`TVirtualPad!Class`](@ref), [`TVirtualPad!DeclFileName`](@ref), [`TVirtualPad!Pad`](@ref), [`TVirtualPad`](@ref), [`UnZoomed`](@ref), [`UpdateAsync`](@ref), [`Update`](@ref), [`UtoAbsPixel`](@ref), [`UtoPixel`](@ref), [`VtoAbsPixel`](@ref), [`VtoPixel`](@ref), [`WaitPrimitive`](@ref), [`XtoAbsPixel`](@ref), [`XtoPad`](@ref), [`XtoPixel`](@ref), [`YtoAbsPixel`](@ref), [`YtoPad`](@ref), [`YtoPixel`](@ref), [`cd`](@ref), [`ls`](@ref)
""" TVirtualPad

# Wrapper of TCanvas
@trydoc raw"""
    ROOT.TCanvas





Related functions: [`Browse`](@ref), [`ClearPadSave`](@ref), [`Clear`](@ref), [`Cleared`](@ref), [`Close`](@ref), [`Closed`](@ref), [`Constructor`](@ref), [`DeleteCanvasPainter`](@ref), [`Delete`](@ref), [`Destructor`](@ref), [`DisconnectWidget`](@ref), [`DrawClonePad`](@ref), [`DrawClone`](@ref), [`Draw`](@ref), [`EditorBar`](@ref), [`EmbedInto`](@ref), [`EnterLeave`](@ref), [`FeedbackMode`](@ref), [`Flush`](@ref), [`ForceUpdate`](@ref), [`GetAutoExec`](@ref), [`GetCanvasID`](@ref), [`GetCanvasImp`](@ref), [`GetCanvasPainter`](@ref), [`GetCanvasPar`](@ref), [`GetClickSelectedPad`](@ref), [`GetClickSelected`](@ref), [`GetContextMenu`](@ref), [`GetDISPLAY`](@ref), [`GetDoubleBuffer`](@ref), [`GetEventX`](@ref), [`GetEventY`](@ref), [`GetEvent`](@ref), [`GetHighLightColor`](@ref), [`GetPadSave`](@ref), [`GetSelectedOpt`](@ref), [`GetSelectedPad`](@ref), [`GetSelectedX`](@ref), [`GetSelectedY`](@ref), [`GetSelected`](@ref), [`GetShowEditor`](@ref), [`GetShowEventStatus`](@ref), [`GetShowToolBar`](@ref), [`GetShowToolTips`](@ref), [`GetWh`](@ref), [`GetWindowHeight`](@ref), [`GetWindowTopX`](@ref), [`GetWindowTopY`](@ref), [`GetWindowWidth`](@ref), [`GetWw`](@ref), [`GetXsizeReal`](@ref), [`GetXsizeUser`](@ref), [`GetYsizeReal`](@ref), [`GetYsizeUser`](@ref), [`HandleInput`](@ref), [`HasMenuBar`](@ref), [`HighlightConnect`](@ref), [`Highlighted`](@ref), [`Iconify`](@ref), [`IsBatch`](@ref), [`IsDrawn`](@ref), [`IsFolder`](@ref), [`IsGrayscale`](@ref), [`IsRetained`](@ref), [`IsUpdated`](@ref), [`IsWeb`](@ref), [`MoveOpaque`](@ref), [`OpaqueMoving`](@ref), [`OpaqueResizing`](@ref), [`Paint`](@ref), [`Pick`](@ref), [`Picked`](@ref), [`ProcessedEvent`](@ref), [`RaiseWindow`](@ref), [`ResetDrawn`](@ref), [`ResetUpdated`](@ref), [`ResizeOpaque`](@ref), [`Resize`](@ref), [`SavePrimitive`](@ref), [`SaveSource`](@ref), [`Selected`](@ref), [`SetBatch`](@ref), [`SetCanvasImp`](@ref), [`SetCanvasSize`](@ref), [`SetClickSelectedPad`](@ref), [`SetClickSelected`](@ref), [`SetCursor`](@ref), [`SetDoubleBuffer`](@ref), [`SetFixedAspectRatio`](@ref), [`SetGrayscale`](@ref), [`SetHighLightColor`](@ref), [`SetName`](@ref), [`SetPadSave`](@ref), [`SetRealAspectRatio`](@ref), [`SetRetained`](@ref), [`SetSelectedPad`](@ref), [`SetSelected`](@ref), [`SetSupportGL`](@ref), [`SetTitle`](@ref), [`SetWindowPosition`](@ref), [`SetWindowSize`](@ref), [`Show`](@ref), [`Size`](@ref), [`TCanvas!MakeDefCanvas`](@ref), [`TCanvas!SaveAll`](@ref), [`TCanvas!SetFolder`](@ref), [`TCanvas!SupportAlpha`](@ref), [`TCanvas`](@ref), [`ToggleAutoExec`](@ref), [`ToggleEditor`](@ref), [`ToggleEventStatus`](@ref), [`ToggleToolBar`](@ref), [`ToggleToolTips`](@ref), [`UpdateAsync`](@ref), [`Update`](@ref), [`UseCurrentStyle`](@ref), [`UseGL`](@ref), [`cd`](@ref), [`ls`](@ref)
""" TCanvas

# Wrapper of TBrowserImp
@trydoc raw"""
    ROOT.TBrowserImp

ABC describing GUI independent browser implementation protocol.



Related functions: [`AddCheckBox`](@ref), [`Add`](@ref), [`BrowseObj`](@ref), [`Browser`](@ref), [`CheckObjectItem`](@ref), [`CloseTabs`](@ref), [`ExecPlugin`](@ref), [`ExecuteDefaultAction`](@ref), [`GetBrowser`](@ref), [`GetDrawOption`](@ref), [`GetMainFrame`](@ref), [`Iconify`](@ref), [`IsWeb`](@ref), [`RecursiveRemove`](@ref), [`Refresh`](@ref), [`RemoveCheckBox`](@ref), [`SetBrowser`](@ref), [`SetDrawOption`](@ref), [`SetStatusText`](@ref), [`Show`](@ref), [`StartEmbedding`](@ref), [`StopEmbedding`](@ref), [`TBrowserImp`](@ref)
""" TBrowserImp

# Wrapper of TProcessEventTimer
@trydoc raw"""
    ROOT.TProcessEventTimer





Related functions: [`IsA`](@ref), [`Notify`](@ref), [`ProcessEvents`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TProcessEventTimer!Class_Name`](@ref), [`TProcessEventTimer!Class_Version`](@ref), [`TProcessEventTimer!Class`](@ref), [`TProcessEventTimer!DeclFileName`](@ref), [`TProcessEventTimer`](@ref)
""" TProcessEventTimer

# Wrapper of TSystem
@trydoc raw"""
    ROOT.TSystem

Abstract base class defining a generic interface to the underlying Operating System.

This is not an ABC in the strict sense of the (C++) word. For every member function there is an implementation (often not more than a call to [AbstractMethod()](@ref) which prints a warning saying that the method should be overridden in a derived class), which allows a simple partial implementation for new OS'es.

Related functions: [`Abort`](@ref), [`AcceptConnection`](@ref), [`AccessPathName`](@ref), [`AddDynamicPath`](@ref), [`AddFileHandler`](@ref), [`AddIncludePath`](@ref), [`AddLinkedLibs`](@ref), [`AddSignalHandler`](@ref), [`AddStdExceptionHandler`](@ref), [`AddTimer`](@ref), [`AnnounceTcpService`](@ref), [`AnnounceUdpService`](@ref), [`AnnounceUnixService`](@ref), [`BaseName`](@ref), [`Beep`](@ref), [`ChangeDirectory`](@ref), [`Chmod`](@ref), [`CleanCompiledMacros`](@ref), [`CloseConnection`](@ref), [`ClosePipe`](@ref), [`Closelog`](@ref), [`CompileMacro`](@ref), [`ConcatFileName`](@ref), [`CopyFile`](@ref), [`DirName`](@ref), [`DispatchOneEvent`](@ref), [`DynFindSymbol`](@ref), [`DynamicPathName`](@ref), [`Exec`](@ref), [`ExitLoop`](@ref), [`Exit`](@ref), [`ExpandPathName`](@ref), [`FindDynamicLibrary`](@ref), [`FindFile`](@ref), [`FreeDirectory`](@ref), [`GetAclicMode`](@ref), [`GetAclicProperties`](@ref), [`GetBeepDefaults`](@ref), [`GetBuildArch`](@ref), [`GetBuildCompilerVersionStr`](@ref), [`GetBuildCompilerVersion`](@ref), [`GetBuildCompiler`](@ref), [`GetBuildDir`](@ref), [`GetBuildNode`](@ref), [`GetCpuInfo`](@ref), [`GetCryptoRandom`](@ref), [`GetDirEntry`](@ref), [`GetDirName`](@ref), [`GetDirPtr`](@ref), [`GetDynamicPath`](@ref), [`GetEffectiveGid`](@ref), [`GetEffectiveUid`](@ref), [`GetErrorStr`](@ref), [`GetError`](@ref), [`GetFPEMask`](@ref), [`GetFlagsDebug`](@ref), [`GetFlagsOpt`](@ref), [`GetFromPipe`](@ref), [`GetFsInfo`](@ref), [`GetGid`](@ref), [`GetGroupInfo`](@ref), [`GetHomeDirectory`](@ref), [`GetHostByName`](@ref), [`GetIncludePath`](@ref), [`GetLibraries`](@ref), [`GetLinkdefSuffix`](@ref), [`GetLinkedLibs`](@ref), [`GetListOfFileHandlers`](@ref), [`GetListOfSignalHandlers`](@ref), [`GetListOfStdExceptionHandlers`](@ref), [`GetListOfTimers`](@ref), [`GetMakeExe`](@ref), [`GetMakeSharedLib`](@ref), [`GetMemInfo`](@ref), [`GetObjExt`](@ref), [`GetPathInfo`](@ref), [`GetPeerName`](@ref), [`GetPid`](@ref), [`GetProcInfo`](@ref), [`GetServiceByName`](@ref), [`GetServiceByPort`](@ref), [`GetSoExt`](@ref), [`GetSockName`](@ref), [`GetSockOpt`](@ref), [`GetSysInfo`](@ref), [`GetUid`](@ref), [`GetUserInfo`](@ref), [`GetVolumes`](@ref), [`GetWorkingDirectory`](@ref), [`Getenv`](@ref), [`HomeDirectory`](@ref), [`HostName`](@ref), [`IgnoreInterrupt`](@ref), [`IgnoreSignal`](@ref), [`InControl`](@ref), [`Init`](@ref), [`InnerLoop`](@ref), [`IsA`](@ref), [`IsAbsoluteFileName`](@ref), [`IsFileInIncludePath`](@ref), [`IsPathLocal`](@ref), [`Link`](@ref), [`ListLibraries`](@ref), [`ListSymbols`](@ref), [`LoadAllLibraries`](@ref), [`Load`](@ref), [`MakeDirectory`](@ref), [`NextTimeOut`](@ref), [`NotifyApplicationCreated`](@ref), [`Now`](@ref), [`OpenConnection`](@ref), [`OpenDirectory`](@ref), [`OpenPipe`](@ref), [`Openlog`](@ref), [`PrependPathName`](@ref), [`ProcessEvents`](@ref), [`RecvBuf`](@ref), [`RecvRaw`](@ref), [`RedirectOutput`](@ref), [`RemoveFileHandler`](@ref), [`RemoveOnExit`](@ref), [`RemoveSignalHandler`](@ref), [`RemoveStdExceptionHandler`](@ref), [`RemoveTimer`](@ref), [`Rename`](@ref), [`ResetSignal`](@ref), [`ResetSignals`](@ref), [`ResetTimer`](@ref), [`Run`](@ref), [`Select`](@ref), [`SendBuf`](@ref), [`SendRaw`](@ref), [`SetAclicMode`](@ref), [`SetBuildDir`](@ref), [`SetDisplay`](@ref), [`SetDynamicPath`](@ref), [`SetErrorStr`](@ref), [`SetFPEMask`](@ref), [`SetFlagsDebug`](@ref), [`SetFlagsOpt`](@ref), [`SetIncludePath`](@ref), [`SetLinkdefSuffix`](@ref), [`SetLinkedLibs`](@ref), [`SetMakeExe`](@ref), [`SetMakeSharedLib`](@ref), [`SetObjExt`](@ref), [`SetProgname`](@ref), [`SetSoExt`](@ref), [`SetSockOpt`](@ref), [`Setenv`](@ref), [`ShowOutput`](@ref), [`Sleep`](@ref), [`SplitAclicMode`](@ref), [`StackTrace`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`Symlink`](@ref), [`Syslog`](@ref), [`TSystem!Class_Name`](@ref), [`TSystem!Class_Version`](@ref), [`TSystem!Class`](@ref), [`TSystem!DeclFileName`](@ref), [`TSystem!GetErrno`](@ref), [`TSystem!ResetErrno`](@ref), [`TSystem`](@ref), [`TempDirectory`](@ref), [`TempFileName`](@ref), [`Umask`](@ref), [`UnixPathName`](@ref), [`Unlink`](@ref), [`Unload`](@ref), [`Unsetenv`](@ref), [`Utime`](@ref), [`Which`](@ref), [`WorkingDirectory`](@ref), [`cd`](@ref), [`mkdir`](@ref), [`pwd`](@ref)
""" TSystem

# Wrapper of TFileHandler
@trydoc raw"""
    ROOT.TFileHandler





Related functions: [`Add`](@ref), [`GetFd`](@ref), [`HasReadInterest`](@ref), [`HasWriteInterest`](@ref), [`IsA`](@ref), [`IsReadReady`](@ref), [`IsWriteReady`](@ref), [`Notify`](@ref), [`ReadNotify`](@ref), [`Remove`](@ref), [`ResetReadyMask`](@ref), [`SetFd`](@ref), [`SetInterest`](@ref), [`SetReadReady`](@ref), [`SetWriteReady`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TFileHandler!Class_Name`](@ref), [`TFileHandler!Class_Version`](@ref), [`TFileHandler!Class`](@ref), [`TFileHandler!DeclFileName`](@ref), [`TFileHandler`](@ref), [`WriteNotify`](@ref)
""" TFileHandler

# Wrapper of TSignalHandler
@trydoc raw"""
    ROOT.TSignalHandler





Related functions: [`Add`](@ref), [`Delay`](@ref), [`GetSignal`](@ref), [`HandleDelayedSignal`](@ref), [`IsA`](@ref), [`IsAsync`](@ref), [`IsSync`](@ref), [`Notify`](@ref), [`Remove`](@ref), [`SetSignal`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TSignalHandler!Class_Name`](@ref), [`TSignalHandler!Class_Version`](@ref), [`TSignalHandler!Class`](@ref), [`TSignalHandler!DeclFileName`](@ref), [`TSignalHandler`](@ref)
""" TSignalHandler

# Wrapper of TStdExceptionHandler
@trydoc raw"""
    ROOT.TStdExceptionHandler





Related functions: [`Add`](@ref), [`Handle`](@ref), [`IsA`](@ref), [`Notify`](@ref), [`Remove`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TStdExceptionHandler!Class_Name`](@ref), [`TStdExceptionHandler!Class_Version`](@ref), [`TStdExceptionHandler!Class`](@ref), [`TStdExceptionHandler!DeclFileName`](@ref), [`TStdExceptionHandler`](@ref)
""" TStdExceptionHandler

# Wrapper of TTime
@trydoc raw"""
    ROOT.TTime

Basic time type with millisecond precision.



Related functions: [`AsString`](@ref), [`IsA`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TTime!Class_Name`](@ref), [`TTime!Class_Version`](@ref), [`TTime!Class`](@ref), [`TTime!DeclFileName`](@ref), [`TTime`](@ref), [`add!`](@ref), [`assign`](@ref), [`fdiv!`](@ref), [`long long`](@ref), [`long`](@ref), [`mult!`](@ref), [`sub!`](@ref), [`unsigned long long`](@ref), [`unsigned long`](@ref)
""" TTime

# Wrapper of TTimer
@trydoc raw"""
    ROOT.TTimer

Handles synchronous and a-synchronous timer events.

1. synchronous timer is registered into [TSystem](@ref) and is processed within the standard [ROOT](@ref) event-loop.
2. asynchronous timer is passed to the operating system which sends an external signal to [ROOT](@ref) and thus interrupts its event-loop.

You can use this class in one of the following ways:

- Sub-class [TTimer](@ref) and override the [Notify()](@ref) method.
- Re-implement the [TObject!HandleTimer()](@ref) method in your class and pass a pointer to this object to timer, see the [SetObject()](@ref) method.
- Pass an interpreter command to timer, see [SetCommand()](@ref) method.
- Create a [TTimer](@ref), connect its [Timeout()](@ref) signal to the appropriate methods. Then when the time is up it will emit a [Timeout()](@ref) signal and call connected slots.

Minimum timeout interval is defined in TSystem!ESysConstants as `kItimerResolution` (currently 10 ms).

Signal/slots example: 

    TTimer *timer = new TTimer();
    timer->Connect("Timeout()", "myObjectClassName",
                   myObject, "TimerDone()");
    timer->Start(2000, kTRUE);   // 2 seconds single-shot

(C++ version of the code)

 To emit the Timeout signal repeatedly with minimum timeout: 

    timer->Start(0, kFALSE);

(C++ version of the code)

Related functions: [`Add`](@ref), [`CheckTimer`](@ref), [`GetAbsTime`](@ref), [`GetCommand`](@ref), [`GetObject`](@ref), [`GetTime`](@ref), [`GetTimerID`](@ref), [`HasTimedOut`](@ref), [`IsA`](@ref), [`IsAsync`](@ref), [`IsInterruptingSyscalls`](@ref), [`IsRunning`](@ref), [`IsSync`](@ref), [`Notify`](@ref), [`Remove`](@ref), [`Reset`](@ref), [`SetCommand`](@ref), [`SetInterruptSyscalls`](@ref), [`SetObject`](@ref), [`SetTime`](@ref), [`SetTimerID`](@ref), [`Start`](@ref), [`Stop`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TTimer!Class_Name`](@ref), [`TTimer!Class_Version`](@ref), [`TTimer!Class`](@ref), [`TTimer!DeclFileName`](@ref), [`TTimer!SingleShot`](@ref), [`TTimer`](@ref), [`Timeout`](@ref), [`TurnOff`](@ref), [`TurnOn`](@ref)
""" TTimer

# Wrapper of TInetAddress
@trydoc raw"""
    ROOT.TInetAddress

This class represents an Internet Protocol (IP) address.



Related functions: [`GetAddressBytes`](@ref), [`GetAddress`](@ref), [`GetAddresses`](@ref), [`GetAliases`](@ref), [`GetFamily`](@ref), [`GetHostAddress`](@ref), [`GetHostName`](@ref), [`GetPort`](@ref), [`IsA`](@ref), [`IsValid`](@ref), [`Print`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TInetAddress!Class_Name`](@ref), [`TInetAddress!Class_Version`](@ref), [`TInetAddress!Class`](@ref), [`TInetAddress!DeclFileName`](@ref), [`TInetAddress!GetHostAddress`](@ref), [`TInetAddress`](@ref), [`assign`](@ref)
""" TInetAddress

# Wrapper of TApplicationImp
@trydoc raw"""
    ROOT.TApplicationImp

ABC describing GUI independent application implementation protocol.



Related functions: [`ApplicationName`](@ref), [`ExecCommand`](@ref), [`Hide`](@ref), [`Iconify`](@ref), [`Init`](@ref), [`IsCmdThread`](@ref), [`Lower`](@ref), [`Open`](@ref), [`Raise`](@ref), [`Show`](@ref), [`TApplicationImp`](@ref)
""" TApplicationImp

# Wrapper of TBranch
@trydoc raw"""
    ROOT.TBranch

A [TTree](@ref) is a list of TBranches.

A [TBranch](@ref) supports:

- The list of [TLeaf](@ref) describing this branch.
- The list of [TBasket](@ref) (branch buffers).

See [TBranch](@ref) structure in [TTree](@ref).

See also specialized branches:

- [TBranchObject](@ref) in case the branch is one object
- [TBranchClones](@ref) in case the branch is an array of clone objects

Related functions: [`AddBasket`](@ref), [`AddLastBasket`](@ref), [`BackFill`](@ref), [`Browse`](@ref), [`ClassDefOverride`](@ref), [`DeleteBaskets`](@ref), [`DropBaskets`](@ref), [`ExpandBasketArrays`](@ref), [`FillImpl`](@ref), [`Fill`](@ref), [`FindBranch`](@ref), [`FindLeaf`](@ref), [`FlushBaskets`](@ref), [`FlushOneBasket`](@ref), [`GetAddress`](@ref), [`GetBasketBytes`](@ref), [`GetBasketEntry`](@ref), [`GetBasketSeek`](@ref), [`GetBasketSize`](@ref), [`GetBasket`](@ref), [`GetBrowsables`](@ref), [`GetBulkRead`](@ref), [`GetClassName`](@ref), [`GetCompressionAlgorithm`](@ref), [`GetCompressionLevel`](@ref), [`GetCompressionSettings`](@ref), [`GetDirectory`](@ref), [`GetEntries`](@ref), [`GetEntryExport`](@ref), [`GetEntryNumber`](@ref), [`GetEntryOffsetLen`](@ref), [`GetEntry`](@ref), [`GetEvent`](@ref), [`GetExpectedType`](@ref), [`GetFileName`](@ref), [`GetFile`](@ref), [`GetFirstEntry`](@ref), [`GetFullName`](@ref), [`GetIOFeatures`](@ref), [`GetIconName`](@ref), [`GetLeaf`](@ref), [`GetListOfBaskets`](@ref), [`GetListOfBranches`](@ref), [`GetListOfLeaves`](@ref), [`GetMakeClass`](@ref), [`GetMaxBaskets`](@ref), [`GetMother`](@ref), [`GetNleaves`](@ref), [`GetOffset`](@ref), [`GetReadBasket`](@ref), [`GetReadEntry`](@ref), [`GetRow`](@ref), [`GetSplitLevel`](@ref), [`GetSubBranch`](@ref), [`GetTotBytes`](@ref), [`GetTotalSize`](@ref), [`GetTransientBuffer`](@ref), [`GetTree`](@ref), [`GetWriteBasket`](@ref), [`GetZipBytes`](@ref), [`IsAutoDelete`](@ref), [`IsFolder`](@ref), [`KeepCircular`](@ref), [`LoadBaskets`](@ref), [`PrintCacheInfo`](@ref), [`Print`](@ref), [`ReadBasket`](@ref), [`Refresh`](@ref), [`ResetAddress`](@ref), [`ResetAfterMerge`](@ref), [`ResetReadEntry`](@ref), [`Reset`](@ref), [`SetAddress`](@ref), [`SetAutoDelete`](@ref), [`SetBasketSize`](@ref), [`SetBufferAddress`](@ref), [`SetCompressionAlgorithm`](@ref), [`SetCompressionLevel`](@ref), [`SetCompressionSettings`](@ref), [`SetEntries`](@ref), [`SetEntryOffsetLen`](@ref), [`SetFile`](@ref), [`SetFirstEntry`](@ref), [`SetIOFeatures`](@ref), [`SetMakeClass`](@ref), [`SetObject`](@ref), [`SetOffset`](@ref), [`SetStatus`](@ref), [`SetTree`](@ref), [`SetupAddresses`](@ref), [`SupportsBulkRead`](@ref), [`TBranch!ResetCount`](@ref), [`TBranch`](@ref), [`UpdateAddress`](@ref), [`UpdateFile`](@ref)
""" TBranch

# Wrapper of TTree
@trydoc raw"""
    ROOT.TTree

A [TTree](@ref) represents a columnar dataset.

Any C++ type can be stored in its columns. The modern version of [TTree](@ref) is RNTuple: please consider using it before opting for [TTree](@ref).

A [TTree](@ref), often called in jargon *tree*, consists of a list of independent columns or *branches*, represented by the [TBranch](@ref) class. Behind each branch, buffers are allocated automatically by [ROOT](@ref). Such buffers are automatically written to disk or kept in memory until the size stored in the attribute fMaxVirtualSize is reached. Variables of one branch are written to the same buffer. A branch buffer is automatically compressed if the file compression attribute is set (default). Branches may be written to different files (see [TBranch!SetFile](@ref)).

The [ROOT](@ref) user can decide to make one single branch and serialize one object into one single I/O buffer or to make several branches. Making several branches is particularly interesting in the data analysis phase, when it is desirable to have a high reading rate and not all columns are equally interesting

## Create a TTree to store columnar data

- [Construct a TTree](@ref)
- [Add a column of Fundamental Types and Arrays thereof](@ref)
- [Add a column of a STL Collection instances](@ref)
- [Add a column holding an object](@ref)
- [Add a column holding a TObjectArray](@ref)
- [Fill the tree](@ref)
- [Add a column to an already existing Tree](@ref)
- [An Example](@ref)

## Construct a TTree

    TTree tree(name, title)

(C++ version of the code)

 Creates a Tree with name and title.

Various kinds of branches can be added to a tree:

- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.
- Any C++ object or collection, provided by the STL or [ROOT](@ref).

In the following, the details about the creation of different types of branches are given.

## Add a column ("branch") holding fundamental types and arrays thereof

This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.

    auto branch = tree.Branch(branchname, address, leaflist, bufsize)

(C++ version of the code)

- `address` is the address of the first item of a structure
- `leaflist` is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:

    - `C` : a character string terminated by the 0 character
    - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.
    - `b` : an 8 bit unsigned integer (`UChar_t`)
    - `S` : a 16 bit signed integer (`Short_t`)
    - `s` : a 16 bit unsigned integer (`UShort_t`)
    - `I` : a 32 bit signed integer (`Int_t`)
    - `i` : a 32 bit unsigned integer (`UInt_t`)
    - `F` : a 32 bit floating point (`Float_t`)
    - `f` : a 21 bit floating point with truncated mantissa (`Float16_t`): 1 for the sign, 8 for the exponent and 12 for the mantissa.
    - `D` : a 64 bit floating point (`Double_t`)
    - `d` : a 32 bit truncated floating point (`Double32_t`): 1 for the sign, 8 for the exponent and 23 for the mantissa.
    - `L` : a 64 bit signed integer (`Long64_t`)
    - `l` : a 64 bit unsigned integer (`ULong64_t`)
    - `G` : a long signed integer, stored as 64 bit (`Long_t`)
    - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`)
    - `O` : [the letter `o`, not a zero] a boolean (`bool`)

    Examples:

    - A int: "myVar/I"
    - A float array with fixed size: "myArrfloat[42]/F"
    - An double array with variable size, held by the `myvar` column: "myArrdouble[myvar]/D"
    - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: "myArr[myvar]/d[0,10]"
    - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).
- If the address points to a single numerical variable, the leaflist is optional: 

        int value;
        tree->Branch(branchname, &value);

(C++ version of the code)

- If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable [TTree](@ref) (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.
- In case of the truncated floating point types (`Float16_t` and `Double32_t`) you can also specify the range in the style `[xmin,xmax]` or `[xmin,xmax,nbits]` after the type character. For example, for storing a variable size array `myArr` of `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified, the standard rules of opaque typedefs annotation are valid. For example, if only 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`

## Adding a column holding STL collection instances (e.g. std::vector or std::list)

    auto branch = tree.Branch( branchname, STLcollection, buffsize, splitlevel);

(C++ version of the code)

 `STLcollection` is the address of a pointer to a container of the standard library such as `std!vector`, `std!list`, containing pointers, fundamental types or objects. If the splitlevel is a value bigger than 100 (`TTree!kSplitCollectionOfPointers`) then the collection will be written in split mode, i.e. transparently storing individual data members as arrays, therewith potentially increasing compression ratio.

### Note

In case of dynamic structures changing with each entry, see e.g. 

    branch->SetAddress(void *address)

(C++ version of the code)

 one must redefine the branch address before filling the branch again. This is done via the `TBranch!SetAddress` member function.

## Add a column holding objects

    MyClass object;
    auto branch = tree.Branch(branchname, &object, bufsize, splitlevel)

(C++ version of the code)

 Note: The 2nd parameter must be the address of a valid object. The object must not be destroyed (i.e. be deleted) until the [TTree](@ref) is deleted or [TTree!ResetBranchAddress](@ref) is called.

- if splitlevel=0, the object is serialized in the branch buffer.
- if splitlevel=1 (default), this branch will automatically be split into subbranches, with one subbranch for each data member or object of the object itself. In case the object member is a [TClonesArray](@ref), the mechanism described in case C is applied to this array.
- if splitlevel=2 ,this branch will automatically be split into subbranches, with one subbranch for each data member or object of the object itself. In case the object member is a [TClonesArray](@ref), it is processed as a TObject*, only one branch.

Another available syntax is the following:

    auto branch_a = tree.Branch(branchname, &p_object, bufsize, splitlevel)
    auto branch_b = tree.Branch(branchname, className, &p_object, bufsize, splitlevel)

(C++ version of the code)

- `p_object` is a pointer to an object.
- If `className` is not specified, the `Branch` method uses the type of `p_object` to determine the type of the object.
- If `className` is used to specify explicitly the object type, the `className` must be of a type related to the one pointed to by the pointer. It should be either a parent or derived class.

Note: The pointer whose address is passed to `TTree!Branch` must not be destroyed (i.e. go out of scope) until the [TTree](@ref) is deleted or [TTree!ResetBranchAddress](@ref) is called.

Note: The pointer `p_object` can be initialized before calling `TTree!Branch` 

    auto p_object = new MyDataClass;
    tree.Branch(branchname, &p_object);

(C++ version of the code)

 or not 

    MyDataClass* p_object = nullptr;
    tree.Branch(branchname, &p_object);

(C++ version of the code)

 In either case, the ownership of the object is not taken over by the `TTree`. Even though in the first case an object is be allocated by `TTree!Branch`, the object will **not** be deleted when the `TTree` is deleted.

## Add a column holding TClonesArray instances

The usage of `TClonesArray` should be abandoned in favour of `std!vector`, for which `TTree` has been heavily optimised, as well as `RNTuple`.*

    // clonesarray is the address of a pointer to a TClonesArray.
    auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel)

(C++ version of the code)

 The [TClonesArray](@ref) is a direct access list of objects of the same class. For example, if the [TClonesArray](@ref) is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack.

## Fill the Tree

A [TTree](@ref) instance is filled with the invocation of the [TTree!Fill](@ref) method: 

    tree.Fill()

(C++ version of the code)

 Upon its invocation, a loop on all defined branches takes place that for each branch invokes the [TBranch!Fill](@ref) method.

## Add a column to an already existing Tree

You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the `kOverwrite` option in the `Write` method: it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. 

    void addBranchToTree() {
        TFile f("tree.root", "update");
        Float_t new_v;
        auto mytree = f->Get<TTree>("mytree");
        auto newBranch = mytree->Branch("new_v", &new_v, "new_v/F");
        auto nentries = mytree->GetEntries(); // read the number of entries in the mytree
        for (Long64_t i = 0; i < nentries; i++) {
            new_v = gRandom->Gaus(0, 1);
            newBranch->Fill();
        }
        mytree->Write("", TObject!kOverwrite); // save only the new version of the tree
    }

(C++ version of the code)

 It is not always possible to add branches to existing datasets stored in TFiles: for example, these files might not be writeable, just readable. In addition, modifying in place a [TTree](@ref) causes a new [TTree](@ref) instance to be written and the previous one to be deleted. For this reasons, [ROOT](@ref) offers the concept of friends for [TTree](@ref) and [TChain](@ref).

## A Complete Example

    // A simple example creating a tree
    // Compile it with: `g++ myTreeExample.cpp -o myTreeExample `root-config --cflags --libs`
    #include "TFile.h"
    #include "TH1D.h"
    #include "TRandom3.h"
    #include "TTree.h"
    int main()
    {
       // Create a new ROOT binary machine independent file.
       // Note that this file may contain any kind of ROOT objects, histograms,trees
       // pictures, graphics objects, detector geometries, tracks, events, etc..
       TFile hfile("htree.root", "RECREATE", "Demo ROOT file with trees");
       // Define a histogram and some simple structures
       TH1D hpx("hpx", "This is the px distribution", 100, -4, 4);
       typedef struct {
          Float_t x, y, z;
       } Point;
       typedef struct {
          Int_t   ntrack, nseg, nvertex;
          UInt_t  flag;
          Float_t temperature;
       } Event;
       Point point;
       Event event;
       // Create a ROOT Tree
       TTree tree("T", "An example of ROOT tree with a few branches");
       tree.Branch("point", &point, "x:y:z");
       tree.Branch("event", &event, "ntrack/I:nseg:nvertex:flag/i:temperature/F");
       tree.Branch("hpx", &hpx);
       float px, py;
       TRandom3 myGenerator;
       // Here we thestart a loop on 1000 events
       for (Int_t i = 0; i < 1000; i++) {
          myGenerator.Rannor(px, py);
          const auto random = myGenerator.Rndm(1);
          // Fill histogram
          hpx.Fill(px);
          // Fill structures
          point.x           = 10 * (random - 1);
          point.y           = 5 * random;
          point.z           = 20 * random;
          event.ntrack      = int(100 * random);
          event.nseg        = int(2 * event.ntrack);
          event.nvertex     = 1;
          event.flag        = int(random + 0.5);
          event.temperature = 20 + random;
          // Fill the tree. For each event, save the 2 structures and object.
          // In this simple example, the objects hpx, hprof and hpxpy are only slightly
          // different from event to event. We expect a big compression factor!
          tree.Fill();
       }
       // Save all objects in this file
       hfile.Write();
       // Close the file. Note that this is automatically done when you leave
       // the application upon file destruction.
       hfile.Close();
       return 0;
    }

(C++ version of the code)

 

## TTree Diagram

The following diagram shows the organisation of the federation of classes related to [TTree](@ref).

![https://root.cern/doc/v636/pict1_TTree_001.png](https://root.cern/doc/v636/pict1_TTree_001.png)

Related functions: [`AddAllocationCount`](@ref), [`AddBranchToCache`](@ref), [`AddClone`](@ref), [`AddFriend`](@ref), [`AddTotBytes`](@ref), [`AddZipBytes`](@ref), [`AutoSave`](@ref), [`BranchOld`](@ref), [`BranchRef`](@ref), [`Branch`](@ref), [`Bronch`](@ref), [`Browse`](@ref), [`BuildIndex`](@ref), [`BuildStreamerInfo`](@ref), [`ChangeFile`](@ref), [`CloneTree`](@ref), [`CopyAddresses`](@ref), [`CopyEntries`](@ref), [`CopyTree`](@ref), [`CreateBasket`](@ref), [`Debug`](@ref), [`Delete`](@ref), [`DirectoryAutoAdd`](@ref), [`Draw`](@ref), [`DropBaskets`](@ref), [`DropBranchFromCache`](@ref), [`DropBuffers`](@ref), [`EnableCache`](@ref), [`Fill`](@ref), [`FindBranch`](@ref), [`FindLeaf`](@ref), [`Fit`](@ref), [`FlushBaskets`](@ref), [`GetAlias`](@ref), [`GetAllocationCount`](@ref), [`GetAutoFlush`](@ref), [`GetAutoSave`](@ref), [`GetBranchRef`](@ref), [`GetBranchStatus`](@ref), [`GetBranch`](@ref), [`GetCacheSize`](@ref), [`GetChainEntryNumber`](@ref), [`GetChainOffset`](@ref), [`GetClusterIterator`](@ref), [`GetClusterPrefetch`](@ref), [`GetCurrentFile`](@ref), [`GetDebugMax`](@ref), [`GetDebugMin`](@ref), [`GetDefaultEntryOffsetLen`](@ref), [`GetDirectory`](@ref), [`GetEntriesFast`](@ref), [`GetEntriesFriend`](@ref), [`GetEntries`](@ref), [`GetEntryList`](@ref), [`GetEntryNumberWithBestIndex`](@ref), [`GetEntryNumberWithIndex`](@ref), [`GetEntryNumber`](@ref), [`GetEntryWithIndex`](@ref), [`GetEntry`](@ref), [`GetEstimate`](@ref), [`GetEventList`](@ref), [`GetEvent`](@ref), [`GetFileNumber`](@ref), [`GetFriendAlias`](@ref), [`GetFriend`](@ref), [`GetHistogram`](@ref), [`GetIOFeatures`](@ref), [`GetImplicitMT`](@ref), [`GetIndexValues`](@ref), [`GetIndex`](@ref), [`GetIteratorOnAllLeaves`](@ref), [`GetLeaf`](@ref), [`GetListOfAliases`](@ref), [`GetListOfBranches`](@ref), [`GetListOfClones`](@ref), [`GetListOfFriends`](@ref), [`GetListOfLeaves`](@ref), [`GetMakeClass`](@ref), [`GetMaxEntryLoop`](@ref), [`GetMaxVirtualSize`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNbranches`](@ref), [`GetNotify`](@ref), [`GetPacketSize`](@ref), [`GetPerfStats`](@ref), [`GetPlayer`](@ref), [`GetReadCache`](@ref), [`GetReadEntry`](@ref), [`GetReadEvent`](@ref), [`GetScanField`](@ref), [`GetSelect`](@ref), [`GetSelectedRows`](@ref), [`GetTargetMemoryRatio`](@ref), [`GetTimerInterval`](@ref), [`GetTotBytes`](@ref), [`GetTransientBuffer`](@ref), [`GetTreeIndex`](@ref), [`GetTreeNumber`](@ref), [`GetTree`](@ref), [`GetUpdate`](@ref), [`GetUserInfo`](@ref), [`GetV1`](@ref), [`GetV2`](@ref), [`GetV3`](@ref), [`GetV4`](@ref), [`GetVal`](@ref), [`GetVar1`](@ref), [`GetVar2`](@ref), [`GetVar3`](@ref), [`GetVar4`](@ref), [`GetVar`](@ref), [`GetW`](@ref), [`GetWeight`](@ref), [`GetZipBytes`](@ref), [`InPlaceClone`](@ref), [`IncrementTotalBuffers`](@ref), [`IsFolder`](@ref), [`LoadBaskets`](@ref), [`LoadTreeFriend`](@ref), [`LoadTree`](@ref), [`MakeClass`](@ref), [`MakeCode`](@ref), [`MakeProxy`](@ref), [`MakeSelector`](@ref), [`MemoryFull`](@ref), [`Merge`](@ref), [`Notify`](@ref), [`OptimizeBaskets`](@ref), [`Principal`](@ref), [`PrintCacheStats`](@ref), [`Print`](@ref), [`Process`](@ref), [`Project`](@ref), [`Query`](@ref), [`ReadFile`](@ref), [`ReadStream`](@ref), [`RecursiveRemove`](@ref), [`Refresh`](@ref), [`RegisterExternalFriend`](@ref), [`RemoveExternalFriend`](@ref), [`RemoveFriend`](@ref), [`ResetAfterMerge`](@ref), [`ResetBranchAddress`](@ref), [`ResetBranchAddresses`](@ref), [`Reset`](@ref), [`Scan`](@ref), [`SetAlias`](@ref), [`SetAutoFlush`](@ref), [`SetAutoSave`](@ref), [`SetBasketSize`](@ref), [`SetBranchAddress`](@ref), [`SetBranchStatus`](@ref), [`SetCacheEntryRange`](@ref), [`SetCacheLearnEntries`](@ref), [`SetCacheSize`](@ref), [`SetChainOffset`](@ref), [`SetCircular`](@ref), [`SetClusterPrefetch`](@ref), [`SetDebug`](@ref), [`SetDefaultEntryOffsetLen`](@ref), [`SetDirectory`](@ref), [`SetEntries`](@ref), [`SetEntryList`](@ref), [`SetEstimate`](@ref), [`SetEventList`](@ref), [`SetFileNumber`](@ref), [`SetIOFeatures`](@ref), [`SetImplicitMT`](@ref), [`SetMakeClass`](@ref), [`SetMaxEntryLoop`](@ref), [`SetMaxVirtualSize`](@ref), [`SetName`](@ref), [`SetNotify`](@ref), [`SetObject`](@ref), [`SetParallelUnzip`](@ref), [`SetPerfStats`](@ref), [`SetScanField`](@ref), [`SetTargetMemoryRatio`](@ref), [`SetTimerInterval`](@ref), [`SetTreeIndex`](@ref), [`SetUpdate`](@ref), [`SetWeight`](@ref), [`Show`](@ref), [`StartViewer`](@ref), [`StopCacheLearningPhase`](@ref), [`TTree!GetBranchStyle`](@ref), [`TTree!GetMaxTreeSize`](@ref), [`TTree!MergeTrees`](@ref), [`TTree!SetBranchStyle`](@ref), [`TTree!SetMaxTreeSize`](@ref), [`TTree`](@ref), [`UnbinnedFit`](@ref), [`UseCurrentStyle`](@ref), [`Write`](@ref), [`assign`](@ref)
""" TTree

# Wrapper of TLeaf
@trydoc raw"""
    ROOT.TLeaf

A [TLeaf](@ref) describes individual elements of a [TBranch](@ref) See [TBranch](@ref) structure in [TTree](@ref).

A [TTree](@ref) object is a list of [TBranch](@ref). A [TBranch](@ref) object is a list of [TLeaf](@ref). In most cases, the [TBranch](@ref) will have one [TLeaf](@ref). A [TLeaf](@ref) describes the branch data types and holds the data.

A few notes about the data held by the leaf. It can contain:

1. a single object or primitive (e.g., one float),
2. a fixed-number of objects (e.g., each entry has two floats). The number of elements per entry is saved in `fLen`.
3. a dynamic number of primitives. The number of objects in each entry is saved in the `fLeafCount` branch.

Note options (2) and (3) can combined - if fLeafCount says an entry has 3 elements and fLen is 2, then there will be 6 objects in that entry.

Additionally, `fNdata` is transient and generated on read to determine the necessary size of a buffer to hold event data; depending on the call-site, it may be sized larger than the number of elements

Related functions: [`Browse`](@ref), [`CanGenerateOffsetArray`](@ref), [`ClassDefOverride`](@ref), [`Export`](@ref), [`FillBasket`](@ref), [`GenerateOffsetArray`](@ref), [`GetBranch`](@ref), [`GetDeserializeType`](@ref), [`GetFullName`](@ref), [`GetLeafCountValues`](@ref), [`GetLeafCount`](@ref), [`GetLeafCounter`](@ref), [`GetLenStatic`](@ref), [`GetLenType`](@ref), [`GetLen`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNdata`](@ref), [`GetOffset`](@ref), [`GetTypeName`](@ref), [`GetTypedValue`](@ref), [`GetValueLong64`](@ref), [`GetValueLongDouble`](@ref), [`GetValuePointer`](@ref), [`GetValue`](@ref), [`Import`](@ref), [`IncludeRange`](@ref), [`IsOnTerminalBranch`](@ref), [`IsRange`](@ref), [`IsUnsigned`](@ref), [`PrintValue`](@ref), [`ReadBasketExport`](@ref), [`ReadBasketFast`](@ref), [`ReadBasketSerialized`](@ref), [`ReadBasket`](@ref), [`ReadValue`](@ref), [`ResetAddress`](@ref), [`SetAddress`](@ref), [`SetBranch`](@ref), [`SetLeafCount`](@ref), [`SetLen`](@ref), [`SetOffset`](@ref), [`SetRange`](@ref), [`SetUnsigned`](@ref), [`TLeaf`](@ref)
""" TLeaf

# Wrapper of TClonesArray
@trydoc raw"""
    ROOT.TClonesArray

An array of clone (identical) objects.

Memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as [TObjArray](@ref).

To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete): 

    TObjArray a(10000);
    while (TEvent *ev = (TEvent *)next()) {      // O(100000) events
       for (int i = 0; i < ev->Ntracks; i++) {   // O(10000) tracks
          a[i] = new TTrack(x,y,z,...);
          ...
          ...
       }
       ...
       a.Delete();
    }

(C++ version of the code)

 One better uses a [TClonesArray](@ref) which reduces the number of new/delete calls to only O(10000): 

    TClonesArray a("TTrack", 10000);
    while (TEvent *ev = (TEvent *)next()) {      // O(100000) events
       for (int i = 0; i < ev->Ntracks; i++) {   // O(10000) tracks
          new(a[i]) TTrack(x,y,z,...);
          ...
          ...
       }
       ...
       a.Delete(); // or a.Clear() or a.Clear("C")
    }

(C++ version of the code)

 To reduce the number of call to the constructor (especially useful if the user class requires memory allocation), the object can be added (and constructed when needed) using ConstructedAt which only calls the constructor once per slot. 

    TClonesArray a("TTrack", 10000);
    while (TEvent *ev = (TEvent *)next()) {      // O(100000) events
       for (int i = 0; i < ev->Ntracks; i++) {   // O(10000) tracks
          TTrack *track = (TTrack*)a.ConstructedAt(i);
          track->Set(x,y,z,....);
          ...
          ...
       }
       ...
       a.Clear(); // or a.Clear("C");
    }

(C++ version of the code)

 Note: the only supported way to add objects to a [TClonesArray](@ref) is via the new with placement method or the ConstructedAt method. The other [Add()](@ref) methods ofTObjArray and its base classes are not allowed.

Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours.

### NOTE 1

C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a "memory leak", i.e. the memory of your process grows and eventually your program crashes. Even if you *always* delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of "holes" which reduce the efficiency of memory access; this is called "memory
fragmentation". Moreover new / delete are expensive operations in terms of CPU time.

Without entering into technical details, [TClonesArray](@ref) allows you to "reuse" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the [TClonesArray](@ref) has to be reused, the [Clear()](@ref) method is used. To provide its benefits, each [TClonesArray](@ref) must be allocated *once* per process and disposed of (deleted) *only when not needed any more*.

So a job should see *only one* deletion for each [TClonesArray](@ref), which should be [Clear()](@ref)ed during the job several times. Deleting a [TClonesArray](@ref) is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the [TClonesArray](@ref) itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code.

### NOTE 2

When investigating misuse of [TClonesArray](@ref), please make sure of the following:

- Use [Clear()](@ref) or Clear("C") instead of [Delete()](@ref). This will improve program execution time.
- [TClonesArray](@ref) object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear("C") must be used for clearing [TClonesArray](@ref). When option "C" is specified, [ROOT](@ref) automatically executes the [Clear()](@ref) method (by default it is empty contained in [TObject](@ref)). This method must be overridden in the relevant [TClonesArray](@ref) object class, implementing the reset procedure for pointer objects.
- If the objects are added using the placement new then the Clear must deallocate the memory.
- If the objects are added using [TClonesArray!ConstructedAt](@ref) then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.
- To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/theend of the run.

Related functions: [`AbsorbObjects`](@ref), [`AddAfter`](@ref), [`AddAtAndExpand`](@ref), [`AddAtFree`](@ref), [`AddAt`](@ref), [`AddBefore`](@ref), [`AddFirst`](@ref), [`AddLast`](@ref), [`AddrAt`](@ref), [`Base.getindex`](@ref), [`BypassStreamer`](@ref), [`CanBypassStreamer`](@ref), [`Clear`](@ref), [`Compress`](@ref), [`ConstructedAt`](@ref), [`Delete`](@ref), [`ExpandCreateFast`](@ref), [`ExpandCreate`](@ref), [`Expand`](@ref), [`GetClass`](@ref), [`MultiSort`](@ref), [`New`](@ref), [`RemoveAt`](@ref), [`RemoveRange`](@ref), [`Remove`](@ref), [`SetClass`](@ref), [`SetOwner`](@ref), [`Sort`](@ref), [`TClonesArray`](@ref), [`assign`](@ref)
""" TClonesArray

# Wrapper of TStreamerInfo
@trydoc raw"""
    ROOT.TStreamerInfo

Describes a persistent version of a class.

A [ROOT](@ref) file contains the list of [TStreamerInfo](@ref) objects for all the class versions written to this file. When reading a file, all the [TStreamerInfo](@ref) objects are read back in memory and registered to the [TClass](@ref) list of [TStreamerInfo](@ref). One can see the list and contents of the [TStreamerInfo](@ref) on a file with, e.g., 

    TFile f("myfile.root");
    f.ShowStreamerInfo();

(C++ version of the code)

 A [TStreamerInfo](@ref) is a list of [TStreamerElement](@ref) objects (one per data member or base class). When streaming an object, the system ([TClass](@ref)) loops on all the [TStreamerElement](@ref) objects and calls the appropriate function for each element type.

Related functions: [`BuildCheck`](@ref), [`BuildEmulated`](@ref), [`BuildFor`](@ref), [`BuildOld`](@ref), [`Build`](@ref), [`CallShowMembers`](@ref), [`Clear`](@ref), [`Clone`](@ref), [`CompareContent`](@ref), [`Compile`](@ref), [`ComputeSize`](@ref), [`DeleteArray`](@ref), [`Destructor`](@ref), [`ForceWriteInfo`](@ref), [`GenEmulatedClassStreamer`](@ref), [`GenEmulatedProxy`](@ref), [`GenExplicitClassStreamer`](@ref), [`GenExplicitProxy`](@ref), [`GenerateHeaderFile`](@ref), [`GenerateInfoForPair`](@ref), [`GetActualClass`](@ref), [`GetCheckSum`](@ref), [`GetClassVersion`](@ref), [`GetClass`](@ref), [`GetDataMemberOffset`](@ref), [`GetElem`](@ref), [`GetElementOffset`](@ref), [`GetElement`](@ref), [`GetElements`](@ref), [`GetLength`](@ref), [`GetMethod`](@ref), [`GetNdata`](@ref), [`GetNelement`](@ref), [`GetNewType`](@ref), [`GetNumber`](@ref), [`GetOffset`](@ref), [`GetOldVersion`](@ref), [`GetOnFileClassVersion`](@ref), [`GetReadMemberWiseActions`](@ref), [`GetReadObjectWiseActions`](@ref), [`GetReadTextActions`](@ref), [`GetSizeElements`](@ref), [`GetSize`](@ref), [`GetStreamerElementReal`](@ref), [`GetStreamerElement`](@ref), [`GetType`](@ref), [`GetTypedValueClones`](@ref), [`GetTypedValueSTLP`](@ref), [`GetTypedValueSTL`](@ref), [`GetTypedValue`](@ref), [`GetValueClones`](@ref), [`GetValueSTLP`](@ref), [`GetValueSTL`](@ref), [`GetValue`](@ref), [`GetWriteMemberWiseActions`](@ref), [`GetWriteObjectWiseActions`](@ref), [`GetWriteTextActions`](@ref), [`MatchLegacyCheckSum`](@ref), [`NewArray`](@ref), [`NewInfo`](@ref), [`New`](@ref), [`PrintValueClones`](@ref), [`PrintValueSTL`](@ref), [`PrintValue`](@ref), [`ReadBufferArtificial`](@ref), [`ReadBufferClones`](@ref), [`ReadBufferConv`](@ref), [`ReadBufferSTL`](@ref), [`ReadBufferSkip`](@ref), [`ReadBuffer`](@ref), [`SetCheckSum`](@ref), [`SetClassVersion`](@ref), [`SetClass`](@ref), [`SetOnFileClassVersion`](@ref), [`TStreamerInfo!GetCurrentElement`](@ref), [`TStreamerInfo`](@ref), [`TagFile`](@ref), [`Update`](@ref), [`WriteBufferAux`](@ref), [`ls`](@ref)
""" TStreamerInfo

# Wrapper of TEntryList
@trydoc raw"""
    ROOT.TEntryList

A List of entry numbers in a [TTree](@ref) or [TChain](@ref).

Note: It is recommended to use approaches such as TTreeReader!SetEntryRange or [ROOT!RDataFrame](@ref) instead of [TEntryList](@ref) if possible.

## Operations on entry lists

- **Add**() - if the lists are for the same tree, adds all the entries of the second list to the first list. If the lists are for different trees, creates a [TEntryList](@ref) with 2 sublists for each [TTree](@ref). If the lists are for TChains, merges the ones for the same trees and adds new sublists for the TTrees that were not included in the first [TEntryList](@ref)
- **Subtract**() - if the lists are for the same [TTree](@ref), removes the entries of the second list from the first list. If the lists are for TChains, loops over all sub-lists
- **GetEntry(n)** - returns the n-th entry number
- **Next**() - returns next entry number. Note, that this function is much faster than GetEntry, and it's called when [GetEntry()](@ref) is called for 2 or more indices in a row.

## TTree::Draw() and TChain::Draw()

Use option **entrylist** to write the results of [TTree!Draw](@ref) and [TChain!Draw](@ref) into an entry list. Example: 

    tree->Draw(">>elist", "x<0 && y>0", "entrylist");
    TEntryList *elist = (TEntryList*)gDirectory->Get("elist");

(C++ version of the code)

 

## Example of Loop on TEntryList with a TChain

    void loopChain() {
       TFile *fe = TFile!Open("myelist.root");
       TEntryList *myelist = (TEntryList*)fe->Get("myelist");
       TChain *chain = new TChain("ntuple");
       chain->Add("hsimple.root");
       chain->Add("hsimple2.root");
       Long64_t listEntries = myelist->GetN();
       Long64_t chainEntries = chain->GetEntries();
       Int_t treenum = 0;
       chain->SetEntryList(myelist);
       for (entry=thestart;entry < theend;entry++) {
          entryNumber = chain->GetEntryNumber(entry);
          if (entryNumber < 0) break;
          localEntry = chain->LoadTree(entryNumber);
          if (localEntry < 0) break;
          ....
          then either call
             branch->GetEntry(localEntry);
          or
             chain->GetEntry(entryNumber);
          In the later case the LoadTree is then somewhat redundant.
          ...
       }
    }

(C++ version of the code)

 When using the [TEntryList](@ref) interface directly, you can get the 'tree number' and entry in the current tree (i.e. value similar to the return value of LoadTree) from calling [TEntryList!GetEntryAndTree](@ref): 

    Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);

(C++ version of the code)

 to obtain the entry number within the chain you need to add to it the value of `treeEntry+ch->GetTreeOffset()[treenum]` such that the loop in the previous example can also be written as: 

    for (Long64_t el = 0; el < listEntries; el++) {
       Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);
       Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];
       printf("el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n", el, treeEntry, chainEntry, treenum);
       ch->LoadTree(chainEntry); // this also returns treeEntry
       needed_branch->GetEntry(treeEntry);
    }

(C++ version of the code)

 

## TSelectors

To fill an [TEntryList](@ref) from a [TSelector](@ref) correctly, one must add the [TEntryList](@ref) object to the output list of the selector ([TSelector!fOutput](@ref)). This is the only way to make the sub-lists of the [TEntryList](@ref) switch when the current tree of the [TChain](@ref) is changed.

## Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList())

while the [TTree!SetEntryList()](@ref) function is only setting the [TTree!fEntryList](@ref) data member, the same function in [TChain](@ref) also finds correspondence between the TTrees of this [TChain](@ref) and the sub-lists of this [TEntryList](@ref).

## TEntryList and the current directory

[TEntryList](@ref) objects are automatically added to the current directory (like TTrees). However, in case of a [TEntryList](@ref) for a chain, only the top-level entry list is added, not the sub-lists for specific trees. Placing entry lists in the current directory allows calling them as a part of a [TTreeFormula](@ref) expression, so if the user wants to extract a sublist from a [TChain](@ref) entry list via the [GetEntryList()](@ref) or some other function, they have to add it to the current directory to be able to use it in [TTreeFormula](@ref) expressions.

## TEntryList and TEventList

[TTree!SetEventList()](@ref) and [TChain!SetEventList()](@ref) transform a [TEventList](@ref) into a [TEntryList](@ref) See comments to those functions for more details

## Types of entry lists

There are two types of entry lists:

#### 1.

for a [TTree](@ref) (fBlocks data member is non-zero) Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored in the [TObjArray](@ref) fBlocks. The range of the entry numbers is cut into intervals of kBlockSize entries (currently 64000), so that the first block contains information which entries out of the first 64000 pass the selection, the second block - which entries out of the 64000-127999 interval pass the selection, etc. Some blocks, obviously, might be empty. The internal representation of entry numbers in the blocks is described in the [TEntryListBlock](@ref) class description, and this representation might be changed by calling [OptimizeStorage()](@ref) function (when the list is filled via the [Enter()](@ref) function, this is done automatically, except for the last block). Individual entry lists can be merged (functions [Merge()](@ref) and [Add()](@ref)) to make an entry list for a [TChain](@ref) of corresponding TTrees.

![https://root.cern/doc/v636/pict1_TEntryList_001.png](https://root.cern/doc/v636/pict1_TEntryList_001.png)

#### 2.

for a [TChain](@ref) (fLists data member is non-zero) It contains a [TList](@ref) of sub-lists ([TEntryList](@ref) objects, corresponding to each [TTree](@ref)) Trees and lists are matched by the [TTree](@ref) name and its file name (full path). All sub-lists are returned by the [GetLists()](@ref) function and individual lists are returned by [GetEntryList()](@ref) function. Such lists are no different from the lists for TTrees, described above.

![https://root.cern/doc/v636/pict1_TEntryList_002.png](https://root.cern/doc/v636/pict1_TEntryList_002.png)

Related functions: [`AddSubList`](@ref), [`Add`](@ref), [`ClassDefOverride`](@ref), [`Contains`](@ref), [`DirectoryAutoAdd`](@ref), [`EnterRange`](@ref), [`Enter`](@ref), [`GetCurrentList`](@ref), [`GetDirectory`](@ref), [`GetEntriesToProcess`](@ref), [`GetEntryAndTree`](@ref), [`GetEntryList`](@ref), [`GetEntry`](@ref), [`GetFileName`](@ref), [`GetLists`](@ref), [`GetN`](@ref), [`GetReapplyCut`](@ref), [`GetTreeName`](@ref), [`GetTreeNumber`](@ref), [`IsValid`](@ref), [`Merge`](@ref), [`Next`](@ref), [`OptimizeStorage`](@ref), [`Print`](@ref), [`RelocatePaths`](@ref), [`Remove`](@ref), [`Reset`](@ref), [`ScanPaths`](@ref), [`SetDirectory`](@ref), [`SetEntriesToProcess`](@ref), [`SetFileName`](@ref), [`SetReapplyCut`](@ref), [`SetShift`](@ref), [`SetTreeName`](@ref), [`SetTreeNumber`](@ref), [`SetTree`](@ref), [`Subtract`](@ref), [`TEntryList!Relocate`](@ref), [`TEntryList!Scan`](@ref), [`TEntryList`](@ref)
""" TEntryList

# Wrapper of TH1
@trydoc raw"""
    ROOT.TH1

[TH1](@ref) is the base class of all histogram classes in ROOT.

It provides the common interface for operations such as binning, filling, drawing, which will be detailed below.

1. [Creating histograms](@ref)

    - [Labelling axes](@ref)
2. [Binning](@ref)

    - [Fix or variable bin size](@ref)
    - [Convention for numbering bins](@ref)
    - [Alphanumeric Bin Labels](@ref)
    - [Histograms with automatic bins](@ref)
    - [Rebinning](@ref)
3. [Filling histograms](@ref)

    - [Associated errors](@ref)
    - [Associated functions](@ref)
    - [Projections of histograms](@ref)
    - [Random Numbers and histograms](@ref)
    - [Making a copy of a histogram](@ref)
    - [Normalizing histograms](@ref)
4. [Drawing histograms](@ref)

    - [Setting Drawing histogram contour levels (2-D hists only)](@ref)
    - [Setting histogram graphics attributes](@ref)
    - [Customising how axes are drawn](@ref)
5. [Fitting histograms](@ref)
6. [Saving/reading histograms to/from a ROOT file](@ref)
7. [Operations on histograms](@ref)
8. [Miscellaneous operations](@ref)

[ROOT](@ref) supports the following histogram types:

- 1-D histograms:

    - [TH1C](@ref) : histograms with one byte per channel. Maximum bin content = 127
    - [TH1S](@ref) : histograms with one short per channel. Maximum bin content = 32767
    - [TH1I](@ref) : histograms with one int per channel. Maximum bin content = INT_MAX ([*](@ref))
    - [TH1L](@ref) : histograms with one long64 per channel. Maximum bin content = LLONG_MAX ([**](@ref))
    - [TH1F](@ref) : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
    - [TH1D](@ref) : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))
- 2-D histograms:

    - [TH2C](@ref) : histograms with one byte per channel. Maximum bin content = 127
    - [TH2S](@ref) : histograms with one short per channel. Maximum bin content = 32767
    - [TH2I](@ref) : histograms with one int per channel. Maximum bin content = INT_MAX ([*](@ref))
    - [TH2L](@ref) : histograms with one long64 per channel. Maximum bin content = LLONG_MAX ([**](@ref))
    - [TH2F](@ref) : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
    - [TH2D](@ref) : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))
- 3-D histograms:

    - [TH3C](@ref) : histograms with one byte per channel. Maximum bin content = 127
    - [TH3S](@ref) : histograms with one short per channel. Maximum bin content = 32767
    - [TH3I](@ref) : histograms with one int per channel. Maximum bin content = INT_MAX ([*](@ref))
    - [TH3L](@ref) : histograms with one long64 per channel. Maximum bin content = LLONG_MAX ([**](@ref))
    - [TH3F](@ref) : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
    - [TH3D](@ref) : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))
- Profile histograms: See classes [TProfile](@ref), [TProfile2D](@ref) and [TProfile3D](@ref). Profile histograms are used to display the mean value of Y and its standard deviation for each bin in X. Profile histograms are in many cases an elegant replacement of two-dimensional histograms : the inter-relation of two measured quantities X and Y can always be visualized by a two-dimensional histogram or scatter-plot; If Y is an unknown (but single-valued) approximate function of X, this function is displayed by a profile histogram with much better precision than by a scatter-plot.

<sup> (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br/>
 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760) </sup>

The inheritance hierarchy looks as follows:

![https://root.cern/doc/v636/classTH1__inherit__graph_org.svg](https://root.cern/doc/v636/classTH1__inherit__graph_org.svg)

## Creating histograms

Histograms are created by invoking one of the constructors, e.g. 

    TH1F *h1 = new TH1F("h1", "h1 title", 100, 0, 4.4);
    TH2F *h2 = new TH2F("h2", "h2 title", 40, 0, 4, 30, -3, 3);

(C++ version of the code)

 Histograms may also be created by:

- calling the [Clone()](@ref) function, see below
- making a projection from a 2-D or 3-D histogram, see below
- reading a histogram from a file

When a histogram is created, a reference to it is automatically added to the list of in-memory objects for the current file or directory. Then the pointer to this histogram in the current directory can be found by its name, doing: 

    TH1F *h1 = (TH1F*)gDirectory->FindObject(name);

(C++ version of the code)

This default behaviour can be changed by: 

    h->SetDirectory(nullptr);          // for the current histogram h
    TH1!AddDirectory(kFALSE);   // sets a global_ switch disabling the referencing

(C++ version of the code)

 When the histogram is deleted, the reference to it is removed from the list of objects in memory. When a file is closed, all histograms in memory associated with this file are automatically deleted.

### Labelling axes

Axis titles can be specified in the title argument of the constructor. They must be separated by ";": 

    TH1F* h=new TH1F("h", "Histogram title;X Axis;Y Axis", 100, 0, 1);

(C++ version of the code)

 The histogram title and the axis titles can be any [TLatex](@ref) string, and are persisted if a histogram is written to a file.

Any title can be omitted: 

    TH1F* h=new TH1F("h", "Histogram title;;Y Axis", 100, 0, 1);
    TH1F* h=new TH1F("h", ";;Y Axis", 100, 0, 1);

(C++ version of the code)

 The method [SetTitle()](@ref) has the same syntax: 

    h->SetTitle("Histogram title;Another X title Axis");

(C++ version of the code)

 Alternatively, the title of each axis can be set directly: 

    h->GetXaxis()->SetTitle("X axis title");
    h->GetYaxis()->SetTitle("Y axis title");

(C++ version of the code)

 For bin labels see [binning](@ref).

## Binning

### Fix or variable bin size

All histogram types support either fix or variable bin sizes. 2-D histograms may have fix size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw or access histograms are identical in both cases.

Each histogram always contains 3 axis objects of type [TAxis](@ref): fXaxis, fYaxis and fZaxis. To access the axis parameters, use: 

    TAxis *xaxis = h->GetXaxis(); etc.
    Double_t binCenter = xaxis->GetBinCenter(bin), etc.

(C++ version of the code)

 See class [TAxis](@ref) for a description of all the access functions. The axis range is always stored internally in double precision.

### Convention for numbering bins

For all histogram types: nbins, xlow, xup 

    bin = 0;       underflow bin
    bin = 1;       first bin with low-edge xlow INCLUDED
    bin = nbins;   last bin with upper-edge xup EXCLUDED
    bin = nbins+1; overflow bin

(C++ version of the code)

 In case of 2-D or 3-D histograms, a "global_ bin" number is defined. For example, assuming a 3-D histogram with (binx, biny, binz), the function 

    Int_t gbin = h->GetBin(binx, biny, binz);

(C++ version of the code)

 returns a global_/linearized gbin number. This global_ gbin is useful to access the bin content/error information independently of the dimension. Note that to access the information other than bin content and errors one should use the [TAxis](@ref) object directly with e.g.: 

    Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);

(C++ version of the code)

 returns the center along z of bin number 27 (not the global_ bin) in the 3-D histogram h3.

### Alphanumeric Bin Labels

By default, a histogram axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead with:

- call TAxis!SetBinLabel(bin, label); This can always be done before or after filling. When the histogram is drawn, bin labels will be automatically drawn. See examples labels1.C and labels2.C
- call to a Fill function with one of the arguments being a string, e.g. 

        hist1->Fill(somename, weight);
        hist2->Fill(x, somename, weight);
        hist2->Fill(somename, y, weight);
        hist2->Fill(somenamex, somenamey, weight);

(C++ version of the code)

 See examples hlabels1.C and hlabels2.C
- via [TTree!Draw](@ref). see for example cernstaff.C 

        tree.Draw("Nation!Division");

(C++ version of the code)

 where "Nation" and "Division" are two branches of a Tree.

When using the options 2 or 3 above, the labels are automatically added to the list ([THashList](@ref)) of labels for a given axis. By default, an axis is drawn with the order of bins corresponding to the filling sequence. It is possible to reorder the axis

- alphabetically
- by increasing or decreasing values

The reordering can be triggered via the [TAxis](@ref) context menu by selecting the menu item "LabelsOption" or by calling directly TH1!LabelsOption(option, axis) where

- axis may be "X", "Y" or "Z"
- option may be:

    - "a" sort by alphabetic order
    - ">" sort by decreasing values
    - "<" sort by increasing values
    - "h" draw labels horizontal
    - "v" draw labels vertical
    - "u" draw labels up (theend of label right adjusted)
    - "d" draw labels down (thestart of label left adjusted)

When using the option 2 above, new labels are added by doubling the current number of bins in case one label does not exist yet. When the Filling is terminated, it is possible to trim the number of bins to match the number of active labels by calling 

    TH1!LabelsDeflate(axis) with axis = "X", "Y" or "Z"

(C++ version of the code)

 This operation is automatic when using [TTree!Draw](@ref). Once bin labels have been created, they become persistent if the histogram is written to a file or when generating the C++ code via SavePrimitive.

### Histograms with automatic bins

When a histogram is created with an axis lower limit greater or equal to its upper limit, the SetBuffer is automatically called with an argument fBufferSize equal to fgBufferSize (default value=1000). fgBufferSize may be reset via the static function [TH1!SetDefaultBufferSize](@ref). The axis limits will be automatically computed when the buffer will be full or when the function BufferEmpty is called.

### Rebinning

At any time, a histogram can be rebinned via [TH1!Rebin](@ref). This function returns a new histogram with the rebinned contents. If bin errors were stored, they are recomputed during the rebinning.

## Filling histograms

A histogram is typically filled with statements like: 

    h1->Fill(x);
    h1->Fill(x, w); //fill with weight
    h2->Fill(x, y)
    h2->Fill(x, y, w)
    h3->Fill(x, y, z)
    h3->Fill(x, y, z, w)

(C++ version of the code)

 or via one of the Fill functions accepting names described above. The Fill functions compute the bin number corresponding to the given x, y or z argument and increment this bin by the given weight. The Fill functions return the bin number for 1-D histograms or global_ bin number for 2-D and 3-D histograms. If [TH1!Sumw2](@ref) has been called before filling, the sum of squares of weights is also stored. One can also increment directly a bin number via [TH1!AddBinContent](@ref) or replace the existing content via [TH1!SetBinContent](@ref). Passing an out-of-range bin to [TH1!AddBinContent](@ref) leads to undefined behavior. To access the bin content of a given bin, do: 

    Double_t binContent = h->GetBinContent(bin);

(C++ version of the code)

By default, the bin number is computed using the current axis ranges. If the automatic binning option has been set via 

    h->SetCanExtend(TH1!kAllAxes);

(C++ version of the code)

 then, the Fill Function will automatically extend the axis range to accomodate the new value specified in the Fill argument. The method used is to double the bin size until the new value fits in the range, merging bins two by two. This automatic binning options is extensively used by the [TTree!Draw](@ref) function when histogramming Tree variables with an unknown range. This automatic binning option is supported for 1-D, 2-D and 3-D histograms.

During filling, some statistics parameters are incremented to compute the mean value and Root Mean Square with the maximum precision.

In case of histograms of type [TH1C](@ref), [TH1S](@ref), [TH2C](@ref), [TH2S](@ref), [TH3C](@ref), [TH3S](@ref) a check is made that the bin contents do not exceed the maximum positive capacity (127 or 32767). Histograms of all types may have positive or/and negative bin contents.

### Associated errors

By default, for each bin, the sum of weights is computed at fill time. One can also call [TH1!Sumw2](@ref) to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights), otherwise the error is set equal to the sqrt(bin content). To return the error for a given bin number, do: 

    Double_t error = h->GetBinError(bin);

(C++ version of the code)

### Associated functions

One or more objects (typically a TF1*) can be added to the list of functions (fFunctions) associated to each histogram. When [TH1!Fit](@ref) is invoked, the fitted function is added to this list. Given a histogram (or [TGraph](@ref)) `h`, one can retrieve an associated function with: 

    TF1 *myfunc = h->GetFunction("myfunc");

(C++ version of the code)

## Operations on histograms

Many types of operations are supported on histograms or between histograms

- Addition of a histogram to the current histogram.
- Additions of two histograms with coefficients and storage into the current histogram.
- Multiplications and Divisions are supported in the same way as additions.
- The Add, Divide and Multiply functions also exist to add, divide or multiply a histogram by a function.

If a histogram has associated error bars ([TH1!Sumw2](@ref) has been called), the resulting error bars are also computed assuming independent histograms. In case of divisions, Binomial errors are also supported. One can mark a histogram to be an "average" histogram by setting its bit kIsAverage via myhist.SetBit(TH1!kIsAverage); When adding (see [TH1!Add](@ref)) average histograms, the histograms are averaged and not summed.

### Projections of histograms

One can:

- make a 1-D projection of a 2-D histogram or Profile see functions [TH2!ProjectionX](@ref),Y, [TH2!ProfileX](@ref),Y, [TProfile!ProjectionX](@ref)
- make a 1-D, 2-D or profile out of a 3-D histogram see functions [TH3!ProjectionZ](@ref), [TH3!Project3D](@ref).

One can fit these projections via: 

    TH2!FitSlicesX,Y, TH3!FitSlicesZ.

(C++ version of the code)

### Random Numbers and histograms

[TH1!FillRandom](@ref) can be used to randomly fill a histogram using the contents of an existing [TF1](@ref) function or another [TH1](@ref) histogram (for all dimensions). For example, the following two statements create and fill a histogram 10000 times with a default gaussian distribution of mean 0 and sigma 1: 

    TH1F h1("h1", "histo from a gaussian", 100, -3, 3);
    h1.FillRandom("gaus", 10000);

(C++ version of the code)

 [TH1!GetRandom](@ref) can be used to return a random number distributed according to the contents of a histogram.

### Making a copy of a histogram

Like for any other [ROOT](@ref) object derived from [TObject](@ref), one can use the [Clone()](@ref) function. This makes an identical copy of the original histogram including all associated errors and functions, e.g.: 

    TH1F *hnew = (TH1F*)h->Clone("hnew");

(C++ version of the code)

### Normalizing histograms

One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1!Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram.

## Drawing histograms

Histograms are drawn via the [THistPainter](@ref) class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). Many drawing options are supported. See [THistPainter!Paint()](@ref) for more details.

The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use 

    h->DrawCopy();

(C++ version of the code)

 This makes a clone (see Clone below) of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone.

One can use [TH1!SetMaximum()](@ref) and [TH1!SetMinimum()](@ref) to force a particular value for the maximum or the minimum scale on the plot. (For 1-D histograms this means the y-axis, while for 2-D histograms these functions affect the z-axis).

[TH1!UseCurrentStyle()](@ref) can be used to change all histogram graphics attributes to correspond to the current selected style. This function must be called for each histogram. In case one reads and draws many histograms from a file, one can force the histograms to inherit automatically the current graphics style by calling before gROOT->ForceStyle().

### Setting Drawing histogram contour levels (2-D hists only)

By default contours are automatically generated at equidistant intervals. A default value of 20 levels is used. This can be modified via [TH1!SetContour()](@ref) or [TH1!SetContourLevel()](@ref). the contours level info is used by the drawing options "cont", "surf", and "lego".

### Setting histogram graphics attributes

The histogram classes inherit from the attribute classes: [TAttLine](@ref), [TAttFill](@ref), and [TAttMarker](@ref). See the member functions of these classes for the list of options.

### Customizing how axes are drawn

Use the functions of [TAxis](@ref), such as 

    histogram.GetXaxis()->SetTicks("+");
    histogram.GetYaxis()->SetRangeUser(1., 5.);

(C++ version of the code)

## Fitting histograms

Histograms (1-D, 2-D, 3-D and Profiles) can be fitted with a user specified function or a pre-defined function via [TH1!Fit](@ref). See [TH1!Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t)](@ref) for the fitting documentation and the possible [fitting options](@ref)

The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel).

## Saving/reading histograms to/from a ROOT file

The following statements create a [ROOT](@ref) file and store a histogram on the file. Because [TH1](@ref) derives from [TNamed](@ref), the key identifier on the file is the histogram name: 

    TFile f("histos.root", "new");
    TH1F h1("hgaus", "histo from a gaussian", 100, -3, 3);
    h1.FillRandom("gaus", 10000);
    h1->Write();

(C++ version of the code)

 To read this histogram in another Root session, do: 

    TFile f("histos.root");
    TH1F *h = (TH1F*)f.Get("hgaus");

(C++ version of the code)

 One can save all histograms in memory to the file by: 

    file->Write();

(C++ version of the code)

## Miscellaneous operations

    TH1!KolmogorovTest(): statistical test of compatibility in shape
                         between two histograms
    TH1!Smooth() smooths the bin contents of a 1-d histogram
    TH1!Integral() returns the integral of bin contents in a given bin range
    TH1!GetMean(int axis) returns the mean value along axis
    TH1!GetStdDev(int axis)  returns the sigma distribution along axis
    TH1!GetEntries() returns the number of entries
    TH1!Reset() resets the bin contents and errors of a histogram

(C++ version of the code)

 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the histogram statistics are calculated. By default, if no range has been set, the returned values are the (unbinned) ones calculated at fill time. If a range has been set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis!SetRange(0, 0) to unset the range. To ensure that the returned values are always those of the binned data stored in the histogram, call [TH1!ResetStats](@ref). See [TH1!GetStats](@ref).

Related functions: [`AddBinContent`](@ref), [`Add`](@ref), [`AndersonDarlingTest`](@ref), [`Browse`](@ref), [`BufferEmpty`](@ref), [`CanExtendAllAxes`](@ref), [`Chi2TestX`](@ref), [`Chi2Test`](@ref), [`Chisquare`](@ref), [`ClearUnderflowAndOverflow`](@ref), [`Clone`](@ref), [`ComputeIntegral`](@ref), [`Copy`](@ref), [`DirectoryAutoAdd`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`DrawCopy`](@ref), [`DrawNormalized`](@ref), [`DrawPanel`](@ref), [`Draw`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`ExtendAxis`](@ref), [`FFT`](@ref), [`FillN`](@ref), [`FillRandom`](@ref), [`Fill`](@ref), [`FindBin`](@ref), [`FindFirstBinAbove`](@ref), [`FindFixBin`](@ref), [`FindLastBinAbove`](@ref), [`FindObject`](@ref), [`FitPanel`](@ref), [`Fit`](@ref), [`GetAsymmetry`](@ref), [`GetAxisColor`](@ref), [`GetBarOffset`](@ref), [`GetBarWidth`](@ref), [`GetBinCenter`](@ref), [`GetBinContent`](@ref), [`GetBinErrorLow`](@ref), [`GetBinErrorOption`](@ref), [`GetBinErrorSqUnchecked`](@ref), [`GetBinErrorUp`](@ref), [`GetBinError`](@ref), [`GetBinLowEdge`](@ref), [`GetBinWidth`](@ref), [`GetBinWithContent`](@ref), [`GetBinXYZ`](@ref), [`GetBin`](@ref), [`GetBufferLength`](@ref), [`GetBufferSize`](@ref), [`GetBuffer`](@ref), [`GetCellContent`](@ref), [`GetCellError`](@ref), [`GetCenter`](@ref), [`GetContourLevelPad`](@ref), [`GetContourLevel`](@ref), [`GetContour`](@ref), [`GetCumulative`](@ref), [`GetDimension`](@ref), [`GetDirectory`](@ref), [`GetEffectiveEntries`](@ref), [`GetEntries`](@ref), [`GetFunction`](@ref), [`GetIntegral`](@ref), [`GetKurtosis`](@ref), [`GetLabelColor`](@ref), [`GetLabelFont`](@ref), [`GetLabelOffset`](@ref), [`GetLabelSize`](@ref), [`GetListOfFunctions`](@ref), [`GetLowEdge`](@ref), [`GetMaximumBin`](@ref), [`GetMaximumStored`](@ref), [`GetMaximum`](@ref), [`GetMeanError`](@ref), [`GetMean`](@ref), [`GetMinimumAndMaximum`](@ref), [`GetMinimumBin`](@ref), [`GetMinimumStored`](@ref), [`GetMinimum`](@ref), [`GetNbinsX`](@ref), [`GetNbinsY`](@ref), [`GetNbinsZ`](@ref), [`GetNcells`](@ref), [`GetNdivisions`](@ref), [`GetNormFactor`](@ref), [`GetObjectInfo`](@ref), [`GetOption`](@ref), [`GetPainter`](@ref), [`GetQuantiles`](@ref), [`GetRMSError`](@ref), [`GetRMS`](@ref), [`GetRandom`](@ref), [`GetSkewness`](@ref), [`GetStatOverflows`](@ref), [`GetStats`](@ref), [`GetStdDevError`](@ref), [`GetStdDev`](@ref), [`GetSumOfAllWeights`](@ref), [`GetSumOfWeights`](@ref), [`GetSumw2N`](@ref), [`GetSumw2`](@ref), [`GetTickLength`](@ref), [`GetTitleFont`](@ref), [`GetTitleOffset`](@ref), [`GetTitleSize`](@ref), [`GetXaxis`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`IntegralAndError`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`IsBinOverflow`](@ref), [`IsBinUnderflow`](@ref), [`IsHighlight`](@ref), [`KolmogorovTest`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`Paint`](@ref), [`Print`](@ref), [`PutStats`](@ref), [`RebinAxis`](@ref), [`RebinX`](@ref), [`Rebin`](@ref), [`Rebuild`](@ref), [`RecursiveRemove`](@ref), [`ResetStats`](@ref), [`Reset`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetAxisColor`](@ref), [`SetAxisRange`](@ref), [`SetBarOffset`](@ref), [`SetBarWidth`](@ref), [`SetBinContent`](@ref), [`SetBinErrorOption`](@ref), [`SetBinError`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetCanExtend`](@ref), [`SetCellContent`](@ref), [`SetCellError`](@ref), [`SetColors`](@ref), [`SetContent`](@ref), [`SetContourLevel`](@ref), [`SetContour`](@ref), [`SetDirectory`](@ref), [`SetEntries`](@ref), [`SetError`](@ref), [`SetHighlight`](@ref), [`SetLabelColor`](@ref), [`SetLabelFont`](@ref), [`SetLabelOffset`](@ref), [`SetLabelSize`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetNdivisions`](@ref), [`SetNormFactor`](@ref), [`SetOption`](@ref), [`SetStatOverflows`](@ref), [`SetStats`](@ref), [`SetTickLength`](@ref), [`SetTitleFont`](@ref), [`SetTitleOffset`](@ref), [`SetTitleSize`](@ref), [`SetTitle`](@ref), [`SetXTitle`](@ref), [`SetYTitle`](@ref), [`SetZTitle`](@ref), [`ShowBackground`](@ref), [`ShowPeaks`](@ref), [`Smooth`](@ref), [`Sumw2`](@ref), [`TH1!AddDirectoryStatus`](@ref), [`TH1!AddDirectory`](@ref), [`TH1!CheckConsistency`](@ref), [`TH1!FitOptionsMake`](@ref), [`TH1!GetDefaultBufferSize`](@ref), [`TH1!GetDefaultSumw2`](@ref), [`TH1!SavePrimitiveFunctions`](@ref), [`TH1!SetDefaultBufferSize`](@ref), [`TH1!SetDefaultSumw2`](@ref), [`TH1!SmoothArray`](@ref), [`TH1!StatOverflows`](@ref), [`TH1!TransformHisto`](@ref), [`UpdateBinContent`](@ref), [`UseCurrentStyle`](@ref)
""" TH1

# Wrapper of TVirtualTreePlayer
@trydoc raw"""
    ROOT.TVirtualTreePlayer

Abstract base class defining the interface for the plugins that implement Draw, Scan, Process, MakeProxy, etc.

for a [TTree](@ref) object. See the individual documentations in [TTree](@ref).

Related functions: [`BuildIndex`](@ref), [`ClassDefOverride`](@ref), [`CopyTree`](@ref), [`DrawScript`](@ref), [`DrawSelect`](@ref), [`Fit`](@ref), [`GetDimension`](@ref), [`GetEntries`](@ref), [`GetHistogram`](@ref), [`GetNfill`](@ref), [`GetSelect`](@ref), [`GetSelectedRows`](@ref), [`GetSelectorFromFile`](@ref), [`GetSelector`](@ref), [`GetV1`](@ref), [`GetV2`](@ref), [`GetV3`](@ref), [`GetV4`](@ref), [`GetVal`](@ref), [`GetVar1`](@ref), [`GetVar2`](@ref), [`GetVar3`](@ref), [`GetVar4`](@ref), [`GetVar`](@ref), [`GetW`](@ref), [`MakeClass`](@ref), [`MakeCode`](@ref), [`MakeProxy`](@ref), [`MakeReader`](@ref), [`Principal`](@ref), [`Process`](@ref), [`Query`](@ref), [`Scan`](@ref), [`SetEstimate`](@ref), [`SetTree`](@ref), [`StartViewer`](@ref), [`TVirtualTreePlayer!GetCurrentPlayer`](@ref), [`TVirtualTreePlayer!SetPlayer`](@ref), [`TVirtualTreePlayer!TreePlayer`](@ref), [`TVirtualTreePlayer`](@ref), [`UnbinnedFit`](@ref), [`UpdateFormulaLeaves`](@ref)
""" TVirtualTreePlayer

# Wrapper of TPrincipal
@trydoc raw"""
    ROOT.TPrincipal

Principal Components Analysis (PCA)

The current implementation is based on the LINTRA package from CERNLIB by R. Brun, H. Hansroul, and J. Kubler. The class has been implemented by Christian Holm Christensen in August 2000.

## Introduction

In many applications of various fields of research, the treatment of large amounts of data requires powerful techniques capable of rapid data reduction and analysis. Usually, the quantities most conveniently measured by the experimentalist, are not necessarily the most significant for classification and analysis of the data. It is then useful to have a way of selecting an optimal set of variables necessary for the recognition process and reducing the dimensionality of the problem, resulting in an easier classification procedure.

This paper describes the implementation of one such method of feature selection, namely the principal components analysis. This multidimensional technique is well known in the field of pattern recognition and and its use in Particle Physics has been documented elsewhere (cf. H. Wind, *Function Parameterization*, CERN 72-21).

## Overview

Suppose we have prototypes which are trajectories of particles, passing through a spectrometer. If one measures the passage of the particle at say 8 fixed planes, the trajectory is described by an 8-component vector: 

``\mathbf{x} = \left(x_0, x_1, \ldots, x_7\right)``

 in 8-dimensional pattern space.

One proceeds by generating a representative tracks sample and building up the covariance matrix $\mathsf{C}$. Its eigenvectors and eigenvalues are computed by standard methods, and thus a new basis is obtained for the original 8-dimensional space the expansion of the prototypes, 

``\mathbf{x}_m = \sum^7_{i=0} a_{m_i} \mathbf{e}_i
  \quad
  \mbox{where}
  \quad
  a_{m_i} = \mathbf{x}^T\bullet\mathbf{e}_i``

 allows the study of the behavior of the coefficients $a_{m_i}$ for all the tracks of the sample. The eigenvectors which are insignificant for the trajectory description in the expansion will have their corresponding coefficients $a_{m_i}$ close to zero for all the prototypes.

On one hand, a reduction of the dimensionality is then obtained by omitting these least significant vectors in the subsequent analysis.

On the other hand, in the analysis of real data, these least significant variables(?) can be used for the pattern recognition problem of extracting the valid combinations of coordinates describing a true trajectory from the set of all possible wrong combinations.

The program described here performs this principal components analysis on a sample of data provided by the user. It computes the covariance matrix, its eigenvalues ands corresponding eigenvectors and exhibits the behavior of the principal components $a_{m_i}$, thus providing to the user all the means of understanding their data.

## Principal Components Method

Let's consider a sample of $M$ prototypes each being characterized by $P$ variables $x_0, x_1, \ldots, x_{P-1}$. Each prototype is a point, or a column vector, in a $P$-dimensional <i>[Pattern](@ref) space</i>. 

``\mathbf{x} = \left[\thebegin{array}{c}
    x_0\\x_1\\\vdots\\x_{P-1}\theend{array}\right]\,,``

 where each $x_n$ represents the particular value associated with the $n$-dimension.

Those $P$ variables are the quantities accessible to the experimentalist, but are not necessarily the most significant for the classification purpose.

The *Principal Components Method* consists of applying a linear* transformation to the original variables. This transformation is described by an orthogonal matrix and is equivalent to a rotation of the original pattern space into a new set of coordinate vectors, which hopefully provide easier feature identification and dimensionality reduction.

Let's define the covariance matrix: 

``\mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle
  \quad\mbox{where}\quad
  \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,``

 and the brackets indicate mean value over the sample of $M$ prototypes.

This matrix $\mathsf{C}$ is real, positive definite, symmetric, and will have all its eigenvalues greater then zero. It will now be show that among the family of all the complete orthonormal bases of the pattern space, the base formed by the eigenvectors of the covariance matrix and belonging to the largest eigenvalues, corresponds to the most significant features of the description of the original prototypes.

let the prototypes be expanded on into a set of $N$ basis vectors $\mathbf{e}_n, n=0,\ldots,N,N+1, \ldots, P-1$ 

``\mathbf{y}_i = \sum^N_{i=0} a_{i_n} \mathbf{e}_n,
  \quad
  i = 1, \ldots, M,
  \quad
  N < P-1``

 The 'best' feature coordinates $\mathbf{e}_n$, spanning a *feature space*, will be obtained by minimizing the error due to this truncated expansion, i.e., 

``\min\left(E_N\right) =
  \min\left[\left\langle\left(\mathbf{y}_i - \sum^N_{i=0} a_{i_n} \mathbf{e}_n\right)^2\right\rangle\right]``

 with the conditions: 

``\mathbf{e}_k\bullet\mathbf{e}_j = \delta_{jk} =
  \left\{\thebegin{array}{rcl}
    1 & \mbox{for} & k = j\\
    0 & \mbox{for} & k \neq j
  \theend{array}\right.``

 Multiplying (3) by $\mathbf{e}^T_n$ using (5), we get 

``a_{i_n} = \mathbf{y}_i^T\bullet\mathbf{e}_n\,,``

 so the error becomes \thebegin{eqnarray*}
  E_N &=&
  \left\langle\left[\sum_{n=N+1}^{P-1}  a_{i_n}\mathbf{e}_n\right]^2\right\rangle\nonumber\\
  &=&
  \left\langle\left[\sum_{n=N+1}^{P-1}  \mathbf{y}_i^T\bullet\mathbf{e}_n\mathbf{e}_n\right]^2\right\rangle\nonumber\\
  &=&
  \left\langle\sum_{n=N+1}^{P-1}  \mathbf{e}_n^T\mathbf{y}_i\mathbf{y}_i^T\mathbf{e}_n\right\rangle\nonumber\\
  &=&
  \sum_{n=N+1}^{P-1}  \mathbf{e}_n^T\mathsf{C}\mathbf{e}_n
\theend{eqnarray*} The minimization of the sum in (7) is obtained when each term $\mathbf{e}_n^\mathsf{C}\mathbf{e}_n$ is minimum, since $\mathsf{C}$ is positive definite. By the method of Lagrange multipliers, and the condition (5), we get 

``E_N = \sum^{P-1}_{n=N+1} \left(\mathbf{e}_n^T\mathsf{C}\mathbf{e}_n -
    l_n\mathbf{e}_n^T\bullet\mathbf{e}_n + l_n\right)``

 The minimum condition $\frac{dE_N}{d\mathbf{e}^T_n} = 0$ leads to the equation 

``\mathsf{C}\mathbf{e}_n = l_n\mathbf{e}_n\,,``

 which shows that $\mathbf{e}_n$ is an eigenvector of the covariance matrix $\mathsf{C}$ with eigenvalue $l_n$. The estimated minimum error is then given by 

``E_N \sim \sum^{P-1}_{n=N+1} \mathbf{e}_n^T\bullet l_n\mathbf{e}_n
      = \sum^{P-1}_{n=N+1}  l_n\,,``

 where $l_n,\,n=N+1,\ldots,P$ $l_n,\,n=N+1,\ldots,P-1$ are the eigenvalues associated with the omitted eigenvectors in the expansion (3). Thus, by choosing the $N$ largest eigenvalues, and their associated eigenvectors, the error $E_N$ is minimized.

The transformation matrix to go from the pattern space to the feature space consists of the ordered eigenvectors $\mathbf{e}_1,\ldots,\mathbf{e}_P$ $\mathbf{e}_0,\ldots,\mathbf{e}_{P-1}$ for its columns 

``\mathsf{T} = \left[
    \thebegin{array}{cccc}
      \mathbf{e}_0 &
      \mathbf{e}_1 &
      \vdots &
      \mathbf{e}_{P-1}
    \theend{array}\right]
  = \left[
    \thebegin{array}{cccc}
      \mathbf{e}_{0_0} &  \mathbf{e}_{1_0} & \cdots &  \mathbf{e}_{{P-1}_0}\\
      \mathbf{e}_{0_1} &  \mathbf{e}_{1_1} & \cdots &  \mathbf{e}_{{P-1}_1}\\
      \vdots        &  \vdots        & \ddots &  \vdots \\
      \mathbf{e}_{0_{P-1}} &  \mathbf{e}_{1_{P-1}} & \cdots &  \mathbf{e}_{{P-1}_{P-1}}\\
    \theend{array}\right]``

 This is an orthogonal transformation, or rotation, of the pattern space and feature selection results in ignoring certain coordinates in the transformed space.

Christian Holm August 2000, CERN

Related functions: [`AddRow`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`GetCovarianceMatrix`](@ref), [`GetEigenValues`](@ref), [`GetEigenVectors`](@ref), [`GetHistograms`](@ref), [`GetMeanValues`](@ref), [`GetRow`](@ref), [`GetSigmas`](@ref), [`GetUserData`](@ref), [`IsFolder`](@ref), [`MakeCode`](@ref), [`MakeHistograms`](@ref), [`MakeMethods`](@ref), [`MakePrincipals`](@ref), [`P2X`](@ref), [`Print`](@ref), [`SumOfSquareResiduals`](@ref), [`TPrincipal`](@ref), [`Test`](@ref), [`X2P`](@ref)
""" TPrincipal

# Wrapper of TTreeFriendLeafIter
@trydoc raw"""
    ROOT.TTreeFriendLeafIter

Iterator on all the leaves in a [TTree](@ref) and its friend.



Related functions: [`Base.:(!=)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TTreeFriendLeafIter`](@ref), [`assign`](@ref)
""" TTreeFriendLeafIter

# Wrapper of TTreeReader
@trydoc raw"""
    ROOT.TTreeReader

A simple, robust and fast interface to read values from [ROOT](@ref) columnar datasets such as [TTree](@ref), [TChain](@ref) or [TNtuple](@ref).

[TTreeReader](@ref) is associated to [TTreeReaderValue](@ref) and [TTreeReaderArray](@ref) which are handles to concretely access the information in the dataset.

Example code can be found in

- tutorials/io/tree/hsimpleReader.C
- tutorials/io/tree/h1analysisTreeReader.C
- [This example](https://github.com/root-project/roottest/tree/master/root/tree/reader)

You can generate a skeleton of `TTreeReaderValue<T>` and `TTreeReaderArray<T>` declarations for all of a tree's branches using `TTree!MakeSelector()`.

Roottest contains an [example](https://github.com/root-project/roottest/tree/master/root/tree/reader) showing the full power.

A simpler analysis example can be found below: it histograms a function of the px and py branches.

    // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C)
    #include "TFile.h"
    #include "TH1F.h"
    #include "TTreeReader.h"
    #include "TTreeReaderValue.h"
    void hsimpleReader() {
       // Create a histogram for the values we read.
       TH1F("h1", "ntuple", 100, -4, 4);
       // Open the file containing the tree.
       TFile *myFile = TFile!Open("$ROOTSYS/tutorials/hsimple.root");
       // Create a TTreeReader for the tree, for instance by passing the
       // TTree's name and the TDirectory / TFile it is in.
       TTreeReader myReader("ntuple", myFile);
       // The branch "px" contains floats; access them as myPx.
       TTreeReaderValue<Float_t> myPx(myReader, "px");
       // The branch "py" contains floats, too; access those as myPy.
       TTreeReaderValue<Float_t> myPy(myReader, "py");
       // Loop over all entries of the TTree or TChain.
       while (myReader.Next()) {
          // Just access the data as if myPx and myPy were iterators (note the '*'
          // in front of them):
          myHist->Fill(*myPx + *myPy);
       }
       myHist->Draw();
    }

(C++ version of the code)

A more complete example including error handling and a few combinations of [TTreeReaderValue](@ref) and [TTreeReaderArray](@ref) would look like this:

    #include <TFile.h>
    #include <TH1.h>
    #include <TTreeReader.h>
    #include <TTreeReaderValue.h>
    #include <TTreeReaderArray.h>
    #include "TriggerInfo.h"
    #include "Muon.h"
    #include "Tau.h"
    #include <vector>
    #include <iostream>
    bool CheckValue(ROOT!Internal!TTreeReaderValueBase& value) {
       if (value.GetSetupStatus() < 0) {
          std!cerr << "Error " << value.GetSetupStatus()
                    << "setting up reader for " << value.GetBranchName() << '\n';
          return false;
       }
       return true;
    }
    // Analyze the tree "MyTree" in the file passed into the function.
    // Returns false in case of errors.
    bool analyze(TFile* file) {
       // Create a TTreeReader named "MyTree" from the given TDirectory.
       // The TTreeReader gives access to the TTree to the TTreeReaderValue and
       // TTreeReaderArray objects. It knows the current entry number and knows
       // how to iterate through the TTree.
       TTreeReader reader("MyTree", file);
       // Read a single float value in each tree entries:
       TTreeReaderValue<float> weight(reader, "event.weight");
       // Read a TriggerInfo object from the tree entries:
       TTreeReaderValue<TriggerInfo> triggerInfo(reader, "triggerInfo");
       //Read a vector of Muon objects from the tree entries:
       TTreeReaderValue<std!vector<Muon>> muons(reader, "muons");
       //Read the pT for all jets in the tree entry:
       TTreeReaderArray<double> jetPt(reader, "jets.pT");
       // Read the taus in the tree entry:
       TTreeReaderArray<Tau> taus(reader, "taus");
       // Now iterate through the TTree entries and fill a histogram.
       TH1F("hist", "TTreeReader example histogram", 10, 0., 100.);
       bool firstEntry = true;
       while (reader.Next()) {
          if (firstEntry) {
             // Check that branches exist and their types match our expectation.
             if (!CheckValue(weight)) return false;
             if (!CheckValue(triggerInfo)) return false;
             if (!CheckValue(muons)) return false;
             if (!CheckValue(jetPt)) return false;
             if (!CheckValue(taus)) return false;
             firstentry = false;
          }
          // Access the TriggerInfo object as if it's a pointer.
          if (!triggerInfo->hasMuonL1())
             continue;
          // Ditto for the vector<Muon>.
          if (!muons->size())
             continue;
          // Access the jetPt as an array, whether the TTree stores this as
          // a std!vector, std!list, TClonesArray or Jet* C-style array, with
          // fixed or variable array size.
          if (jetPt.GetSize() < 2 || jetPt[0] < 100)
             continue;
          // Access the array of taus.
          if (!taus.IsEmpty()) {
             // Access a float value - need to dereference as TTreeReaderValue
             // behaves like an iterator
             float currentWeight = *weight;
             for (const Tau& tau: taus) {
                hist->Fill(tau.eta(), currentWeight);
             }
          }
       } // TTree entry / event loop
       // Return true if we have iterated through all entries.
       return reader.GetEntryStatus() == TTreeReader!kEntryBeyondEnd;
    }

(C++ version of the code)

Related functions: [`GetCurrentEntry`](@ref), [`GetEntries`](@ref), [`GetEntryList`](@ref), [`GetEntryStatus`](@ref), [`GetTree`](@ref), [`IsChain`](@ref), [`IsInvalid`](@ref), [`Notify`](@ref), [`SetSuppressErrorsForMissingBranches`](@ref), [`SetTree`](@ref), [`TTreeReader`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TTreeReader

# Wrapper of TTreeReaderValue
@trydoc raw"""
    ROOT.TTreeReaderValue

An interface for reading values stored in [ROOT](@ref) columnar datasets.

The [TTreeReaderValue](@ref) is a type-safe tool to be used in association with a [TTreeReader](@ref) to access the values stored in [TTree](@ref), [TNtuple](@ref) and [TChain](@ref) datasets. [TTreeReaderValue](@ref) can be also used to access collections such as `std!vector`s or [TClonesArray](@ref) stored in columnar datasets but it is recommended to use [TTreeReaderArray](@ref) instead as it offers several advantages.

See the documentation of [TTreeReader](@ref) for more details and examples.

Related functions: [`Base.getindex`](@ref), [`Get`](@ref), [`TTreeReaderValue`](@ref), [`arrow`](@ref)
""" TTreeReaderValue

# Wrapper of TTreeReaderArray
@trydoc raw"""
    ROOT.TTreeReaderArray

An interface for reading collections stored in [ROOT](@ref) columnar datasets.

The [TTreeReaderArray](@ref) is a type-safe tool to be used in association with a [TTreeReader](@ref) to access the collections stored in [TTree](@ref), [TNtuple](@ref) and [TChain](@ref) datasets. In order to access values which are not collections, the [TTreeReaderValue](@ref) class can be used.

See the documentation of [TTreeReader](@ref) for more details and examples.

Related functions: [`At`](@ref), [`Base.getindex`](@ref), [`TTreeReaderArray`](@ref), [`cbegin`](@ref), [`cend`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TTreeReaderArray

# Wrapper of TPad
@trydoc raw"""
    ROOT.TPad

The most important graphics class in the [ROOT](@ref) system.

A Pad is contained in a Canvas.

A Pad may contain other pads (unlimited pad hierarchy).

A pad is a linked list of primitives of any type (graphics objects, histograms, detectors, tracks, etc.).

Adding a new element into a pad is in general performed by the Draw member function of the object classes.

It is important to realize that the pad is a linked list of references to the original object. For example, in case of a histogram, the histogram.Draw() operation only stores a reference to the histogram object and not a graphical representation of this histogram. When the mouse is used to change (say the bin content), the bin content of the original histogram is changed.

The convention used in [ROOT](@ref) is that a Draw operation only adds a reference to the object. The effective drawing is performed when the canvas receives a signal to be painted.

![https://root.cern/doc/v636/gpad_pad1.png](https://root.cern/doc/v636/gpad_pad1.png)

This signal is generally sent when typing carriage return in the command input or when a graphical operation has been performed on one of the pads of this canvas. When a Canvas/Pad is repainted, the member function Paint for all objects in the Pad linked list is invoked.

![https://root.cern/doc/v636/gpad_pad2.png](https://root.cern/doc/v636/gpad_pad2.png)

When the mouse is moved on the Pad, The member function DistancetoPrimitive is called for all the elements in the pad. DistancetoPrimitive returns the distance in pixels to this object.

When the object is within the distance window, the member function ExecuteEvent is called for this object.

In ExecuteEvent, move, changes can be performed on the object.

For examples of DistancetoPrimitive and ExecuteEvent functions, see classes 

    TLine!DistancetoPrimitive, TLine!ExecuteEvent
    TBox!DistancetoPrimitive,  TBox!ExecuteEvent
    TH1!DistancetoPrimitive,   TH1!ExecuteEvent

(C++ version of the code)

 A Pad supports linear and log scales coordinate systems. The transformation coefficients are explained in [TPad!ResizePad](@ref).

Related functions: [`AbsCoordinates`](@ref), [`AbsPixeltoXY`](@ref), [`AbsPixeltoX`](@ref), [`AbsPixeltoY`](@ref), [`AddExec`](@ref), [`AddFirst`](@ref), [`Add`](@ref), [`AutoExec`](@ref), [`Browse`](@ref), [`BuildLegend`](@ref), [`Clear`](@ref), [`ClipPolygon`](@ref), [`Clip`](@ref), [`ClippingCode`](@ref), [`CloseToolTip`](@ref), [`Close`](@ref), [`Closed`](@ref), [`CopyPixmap`](@ref), [`CopyPixmaps`](@ref), [`CreateToolTip`](@ref), [`DeleteExec`](@ref), [`DeleteToolTip`](@ref), [`DivideSquare`](@ref), [`Divide`](@ref), [`DrawClassObject`](@ref), [`DrawCollideGrid`](@ref), [`DrawCrosshair`](@ref), [`DrawFrame`](@ref), [`Draw`](@ref), [`EventPave`](@ref), [`ExecuteEventAxis`](@ref), [`FindObject`](@ref), [`GetAbsHNDC`](@ref), [`GetAbsWNDC`](@ref), [`GetAbsXlowNDC`](@ref), [`GetAbsYlowNDC`](@ref), [`GetAspectRatio`](@ref), [`GetBBoxCenter`](@ref), [`GetBBox`](@ref), [`GetBorderMode`](@ref), [`GetBorderSize`](@ref), [`GetCanvasID`](@ref), [`GetCanvasImp`](@ref), [`GetCanvas`](@ref), [`GetCrosshair`](@ref), [`GetEventX`](@ref), [`GetEventY`](@ref), [`GetEvent`](@ref), [`GetFrame`](@ref), [`GetGLDevice`](@ref), [`GetGridx`](@ref), [`GetGridy`](@ref), [`GetHNDC`](@ref), [`GetHighLightColor`](@ref), [`GetListOfExecs`](@ref), [`GetListOfPrimitives`](@ref), [`GetLogx`](@ref), [`GetLogy`](@ref), [`GetLogz`](@ref), [`GetMother`](@ref), [`GetName`](@ref), [`GetNumber`](@ref), [`GetPadPaint`](@ref), [`GetPadPar`](@ref), [`GetPadPointer`](@ref), [`GetPadSave`](@ref), [`GetPad`](@ref), [`GetPainter`](@ref), [`GetPhi`](@ref), [`GetPixmapID`](@ref), [`GetPrimitive`](@ref), [`GetRangeAxis`](@ref), [`GetRange`](@ref), [`GetSelectedPad`](@ref), [`GetSelected`](@ref), [`GetTheta`](@ref), [`GetTickx`](@ref), [`GetTicky`](@ref), [`GetTitle`](@ref), [`GetUxmax`](@ref), [`GetUxmin`](@ref), [`GetUymax`](@ref), [`GetUymin`](@ref), [`GetView3D`](@ref), [`GetView`](@ref), [`GetViewer3D`](@ref), [`GetVirtCanvas`](@ref), [`GetWNDC`](@ref), [`GetWh`](@ref), [`GetWw`](@ref), [`GetX1`](@ref), [`GetX2`](@ref), [`GetXlowNDC`](@ref), [`GetY1`](@ref), [`GetY2`](@ref), [`GetYlowNDC`](@ref), [`HasCrosshair`](@ref), [`HasFixedAspectRatio`](@ref), [`HasViewer3D`](@ref), [`Hash`](@ref), [`HighLight`](@ref), [`IncrementPaletteColor`](@ref), [`IsBatch`](@ref), [`IsEditable`](@ref), [`IsFolder`](@ref), [`IsModified`](@ref), [`IsRetained`](@ref), [`IsVertical`](@ref), [`IsWeb`](@ref), [`ModifiedUpdate`](@ref), [`Modified`](@ref), [`NextPaletteColor`](@ref), [`OpaqueMoving`](@ref), [`OpaqueResizing`](@ref), [`PadtoX`](@ref), [`PadtoY`](@ref), [`PaintBox`](@ref), [`PaintFillAreaHatches`](@ref), [`PaintFillAreaNDC`](@ref), [`PaintFillArea`](@ref), [`PaintHatches`](@ref), [`PaintLine3D`](@ref), [`PaintLineNDC`](@ref), [`PaintLine`](@ref), [`PaintModified`](@ref), [`PaintPadFrame`](@ref), [`PaintPolyLine3D`](@ref), [`PaintPolyLineNDC`](@ref), [`PaintPolyLine`](@ref), [`PaintPolyMarker`](@ref), [`PaintTextNDC`](@ref), [`PaintText`](@ref), [`Paint`](@ref), [`Pick`](@ref), [`PixeltoXY`](@ref), [`PixeltoX`](@ref), [`PixeltoY`](@ref), [`PlaceBox`](@ref), [`Pop`](@ref), [`Print`](@ref), [`RangeAxis`](@ref), [`RangeChanged`](@ref), [`Range`](@ref), [`RecordLatex`](@ref), [`RecordPave`](@ref), [`RecursiveRemove`](@ref), [`RedrawAxis`](@ref), [`ReleaseViewer3D`](@ref), [`Remove`](@ref), [`ResetToolTip`](@ref), [`ResetView3D`](@ref), [`ResizePad`](@ref), [`Resized`](@ref), [`SaveAs`](@ref), [`SetAttFillPS`](@ref), [`SetAttLinePS`](@ref), [`SetAttMarkerPS`](@ref), [`SetAttTextPS`](@ref), [`SetBBoxCenterX`](@ref), [`SetBBoxCenterY`](@ref), [`SetBBoxCenter`](@ref), [`SetBBoxX1`](@ref), [`SetBBoxX2`](@ref), [`SetBBoxY1`](@ref), [`SetBBoxY2`](@ref), [`SetBorderMode`](@ref), [`SetBorderSize`](@ref), [`SetCanvasSize`](@ref), [`SetCanvas`](@ref), [`SetCopyGLDevice`](@ref), [`SetCrosshair`](@ref), [`SetCursor`](@ref), [`SetDoubleBuffer`](@ref), [`SetDrawOption`](@ref), [`SetEditable`](@ref), [`SetFillStyle`](@ref), [`SetFixedAspectRatio`](@ref), [`SetGLDevice`](@ref), [`SetGrid`](@ref), [`SetGridx`](@ref), [`SetGridy`](@ref), [`SetLogx`](@ref), [`SetLogy`](@ref), [`SetLogz`](@ref), [`SetName`](@ref), [`SetNumber`](@ref), [`SetPad`](@ref), [`SetPhi`](@ref), [`SetSelected`](@ref), [`SetTheta`](@ref), [`SetTicks`](@ref), [`SetTickx`](@ref), [`SetTicky`](@ref), [`SetTitle`](@ref), [`SetToolTipText`](@ref), [`SetVertical`](@ref), [`SetView`](@ref), [`SetViewer3D`](@ref), [`ShowGuidelines`](@ref), [`StartEditing`](@ref), [`TPad!DrawColorTable`](@ref), [`TPad!GetMaxPickDistance`](@ref), [`TPad!SetMaxPickDistance`](@ref), [`TPad`](@ref), [`UpdateAsync`](@ref), [`Update`](@ref), [`UseCurrentStyle`](@ref), [`UtoAbsPixel`](@ref), [`UtoPixel`](@ref), [`VtoAbsPixel`](@ref), [`VtoPixel`](@ref), [`WaitPrimitive`](@ref), [`XYtoAbsPixel`](@ref), [`XYtoPixel`](@ref), [`XtoAbsPixel`](@ref), [`XtoPad`](@ref), [`XtoPixel`](@ref), [`YtoAbsPixel`](@ref), [`YtoPad`](@ref), [`YtoPixel`](@ref), [`cd`](@ref), [`ls`](@ref), [`x3d`](@ref)
""" TPad

# Wrapper of TObjLink
@trydoc raw"""
    ROOT.TObjLink

Wrapper around a [TObject](@ref) so it can be stored in a [TList](@ref).



Related functions: [`GetAddOption`](@ref), [`GetObjectRef`](@ref), [`GetObject`](@ref), [`GetOption`](@ref), [`NextSP`](@ref), [`Next`](@ref), [`PrevSP`](@ref), [`Prev`](@ref), [`SetObject`](@ref), [`SetOption`](@ref), [`TObjLink`](@ref)
""" TObjLink

# Wrapper of TRandom
@trydoc raw"""
    ROOT.TRandom

This is the base class for the [ROOT](@ref) Random number generators.

This class defines the [ROOT](@ref) Random number interface and it should not be instantiated directly but used via its derived classes. The generator provided in [TRandom](@ref) itself is a LCG (Linear Congruential Generator), the [BSD rand generator](https://www.gnu.org/software/gsl/manual/html_node/Unix-random-number-generators.html), that it should not be used because its period is only 2**31, i.e. approximately 2 billion events, that can be generated in just few seconds.

To generate random numbers, one should use one of the derived classes, which are:

- [TRandom3](@ref): it is based on the "Mersenne Twister generator", it is fast and a very long period of about $10^{6000}$. However it fails some of the most stringent tests of the [TestU01 suite](http://simul.iro.umontreal.ca/testu01/tu01.html). In addition this generator provide only numbers with 32 random bits, which might be not sufficient for some application based on double or extended precision. This generator is however used in [ROOT](@ref) used to instantiate the global_ pointer to the [ROOT](@ref) generator, *gRandom*.
- [TRandomRanluxpp](@ref) : New implementation of the Ranlux generator algorithm based on a fast modular multiplication of 576 bits. This new implementation is built on the idea and the original code of Alexei Sibidanov, described in his [paper](https://arxiv.org/abs/1705.03123). It generates random numbers with 52 bit precision (double precision) and it has an higher luxury level than the original Ranlux generator (`p = 2048` instead of `p=794`).
- [TRandomMixMax](@ref): Generator based on the family of the MIXMAX matrix generators (see the [MIXMAX HEPFORGE Web page](https://mixmax.hepforge.org) and the documentation of the class [ROOT!Math!MixMaxEngine](@ref) for more information), that are base on the Asanov dynamical C systems. This generator has a state of N=240 64 bit integers, proof random properties, it provides 61 random bits and it has a very large period ( $10^{4839}$). Furthermore, it provides the capability to be seeded with the guarantee that, for each given different seed, a different sequence of random numbers will be generated. The only drawback is that the seeding time is time consuming, of the order of 0.1 ms, while the time to generate a number is few ns (more than 10000 faster).
- [TRandomMixMax17](@ref): Another MixMax generator, but with a smaller state, N=17, and this results in a smaller entropy than the generator with N=240. However, it has the same seeding capabilities, with a much faster seeding time (about 200 times less than TRandomMixMax240 and comparable to [TRandom3](@ref)).
- [TRandomMixMax256](@ref) : A variant of the MIXMAX generators, based on a state of N=256, and described in the [2015 paper](http://arxiv.org/abs/1403.5355). This implementation has been modified with respect to the paper, by skipping 2 internal iterations, to provide improved random properties.
- [TRandomMT64](@ref) : Generator based on a the Mersenne-Twister generator with 64 bits, using the implementation provided by the standard library ( [std!mt19937_64](http://www.cplusplus.com/reference/random/mt19937_64/) )
- [TRandom1](@ref) based on the RANLUX algorithm, has mathematically proven random proprieties and a period of about $10{171}$. It is however much slower than the others and it has only 24 random bits. It can be constructed with different luxury levels.
- [TRandomRanlux48](@ref) : Generator based on a the RanLux generator with 48 bits and highest luxury level using the implementation provided by the standard library ([std!ranlux48](http://www.cplusplus.com/reference/random/ranlux48/)). The drawback of this generator is its slow generation time.
- [TRandom2](@ref) is based on the Tausworthe generator of L'Ecuyer, and it has the advantage of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is 10**26.

Using the template [TRandomGen](@ref) class (template on the contained Engine type), it is possible to add any generator based on the standard C++ random library (see the C++ [random](http://www.cplusplus.com/reference/random/) documentation.) or different variants of the MIXMAX generator using the [ROOT!Math!MixMaxEngine](@ref). Some of the listed generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template [TRandomGen](@ref) class.

Please note also that this class ([TRandom](@ref)) implements also a very simple generator (linear congruential) with period = $10^9$, known to have defects (the lower random bits are correlated) and it is failing the majority of the random number generator tests. Therefore it should NOT be used in any statistical study.

The following table shows some timings (in nanoseconds/call) for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:

- [TRandom](@ref) 3 ns/call (but this is a very BAD Generator, not to be used)
- [TRandom2](@ref) 5 ns/call
- [TRandom3](@ref) 5 ns/call
- [TRandomMixMax](@ref) 6 ns/call
- [TRandomMixMax17](@ref) 6 ns/call
- [TRandomMT64](@ref) 9 ns/call
- [TRandomMixMax256](@ref) 10 ns/call
- [TRandomRanluxpp](@ref) 14 ns/call
- [TRandom1](@ref) 80 ns/call
- [TRandomRanlux48](@ref) 250 ns/call

The following methods are provided to generate random numbers distributed according to some basic distributions:

- [Exp(Double_t tau)](@ref)
- [Integer(UInt_t imax)](@ref)
- [Gaus(Double_t mean, Double_t sigma)](@ref)
- [Rndm()](@ref)
- [Uniform(Double_t)](@ref)
- [Landau(Double_t mean, Double_t sigma)](@ref)
- [Poisson(Double_t mean)](@ref)
- [Binomial(Int_t ntot, Double_t prob)](@ref)

Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in [TF1](@ref), [TF2](@ref) or [TF3](@ref) objects can also be generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : 

     TF1
    *f1 = new TF1("f1","abs(sin(x)/x)*sqrt(x)",0,10); double r = f1->GetRandom(); 

(C++ version of the code)

 or you can use the UNURAN package. You need in this case to initialize UNURAN to the function you would like to generate. 

    TUnuran u;
     u.Init(TUnuranDistrCont(f1));
     double r = u.Sample();

(C++ version of the code)

The techniques of using directly a [TF1](@ref),2 or 3 function is powerful and can be used to generate numbers in the defined range of the function. Getting a number from a [TF1](@ref),2,3 function is also quite fast. UNURAN is a powerful and flexible tool which contains various methods for generate random numbers for continuous distributions of one and multi-dimension. It requires some set-up (initialization) phase and can be very fast when the distribution parameters are not changed for every call.

The following table shows some timings (in nanosecond/call) for basic functions, [TF1](@ref) functions and using UNURAN obtained running the tutorial math/testrandom.C Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4

    Distribution            nanoseconds/call
                        TRandom  TRandom1 TRandom2 TRandom3
    Rndm..............    5.000  105.000    7.000   10.000
    RndmArray.........    4.000  104.000    6.000    9.000
    Gaus..............   36.000  180.000   40.000   48.000
    Rannor............  118.000  220.000  120.000  124.000
    Landau............   22.000  123.000   26.000   31.000
    Exponential.......   93.000  198.000   98.000  104.000
    Binomial(5,0.5)...   30.000  548.000   46.000   65.000
    Binomial(15,0.5)..   75.000 1615.000  125.000  178.000
    Poisson(3)........   96.000  494.000  109.000  125.000
    Poisson(10).......  138.000 1236.000  165.000  203.000
    Poisson(70).......  818.000 1195.000  835.000  844.000
    Poisson(100)......  837.000 1218.000  849.000  864.000
    GausTF1...........   83.000  180.000   87.000   88.000
    LandauTF1.........   80.000  180.000   83.000   86.000
    GausUNURAN........   40.000  139.000   41.000   44.000
    PoissonUNURAN(10).   85.000  271.000   92.000  102.000
    PoissonUNURAN(100)   62.000  256.000   69.000   78.000

(C++ version of the code)

Note that the time to generate a number from an arbitrary [TF1](@ref) function using [TF1!GetRandom](@ref) or using [TUnuran](@ref) is independent of the complexity of the function.

TH1!FillRandom(TH1 *) or TH1!FillRandom(const char *tf1name) can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram or from an existing function.

Note this interesting feature when working with objects. You can use several [TRandom](@ref) objects, each with their "independent" random sequence. For example, one can imagine 

    TRandom *eventGenerator = new TRandom();
    TRandom *tracking       = new TRandom();

(C++ version of the code)

 `eventGenerator` can be used to generate the event kinematics. tracking can be used to track the generated particles with random numbers independent from eventGenerator. This very interesting feature gives the possibility to work with simple and very fast random number generators without worrying about random number periodicity as it was the case with Fortran. One can use [TRandom!SetSeed](@ref) to modify the seed of one generator.

A [TRandom](@ref) object may be written to a Root file

- as part of another object
- or with its own key (example: `gRandom->Write("Random")` ) ;

Related functions: [`Binomial`](@ref), [`BreitWigner`](@ref), [`Circle`](@ref), [`Exp`](@ref), [`Gaus`](@ref), [`GetSeed`](@ref), [`Integer`](@ref), [`Landau`](@ref), [`PoissonD`](@ref), [`Poisson`](@ref), [`Rannor`](@ref), [`ReadRandom`](@ref), [`RndmArray`](@ref), [`Rndm`](@ref), [`SetSeed`](@ref), [`Sphere`](@ref), [`TRandom`](@ref), [`Uniform`](@ref), [`WriteRandom`](@ref)
""" TRandom

# Wrapper of TDirectoryFile
@trydoc raw"""
    ROOT.TDirectoryFile

A [ROOT](@ref) file is structured in Directories (like a file system).

Each Directory has a list of Keys (see TKeys) and a list of objects in memory. A Key is a small object that describes the type and location of a persistent object in a file. The persistent object may be a directory.

![https://root.cern/doc/v636/pict1_TDirectoryFile_001.png](https://root.cern/doc/v636/pict1_TDirectoryFile_001.png)
 The structure of a file is shown in TFile!TFile

Related functions: [`Add`](@ref), [`AppendKey`](@ref), [`Append`](@ref), [`Browse`](@ref), [`Build`](@ref), [`CloneObject`](@ref), [`Close`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`FillBuffer`](@ref), [`FindKeyAny`](@ref), [`FindKey`](@ref), [`FindObjectAnyFile`](@ref), [`FindObjectAny`](@ref), [`GetBufferSize`](@ref), [`GetCreationDate`](@ref), [`GetDirectory`](@ref), [`GetFile`](@ref), [`GetKey`](@ref), [`GetListOfKeys`](@ref), [`GetModificationDate`](@ref), [`GetNbytesKeys`](@ref), [`GetNkeys`](@ref), [`GetObjectChecked`](@ref), [`GetObjectUnchecked`](@ref), [`GetSeekDir`](@ref), [`GetSeekKeys`](@ref), [`GetSeekParent`](@ref), [`Get`](@ref), [`IsModified`](@ref), [`IsWritable`](@ref), [`OpenFile`](@ref), [`Purge`](@ref), [`ReadAll`](@ref), [`ReadKeys`](@ref), [`ReadTObject`](@ref), [`ResetAfterMerge`](@ref), [`SaveObjectAs`](@ref), [`SaveSelf`](@ref), [`Save`](@ref), [`SetBufferSize`](@ref), [`SetModified`](@ref), [`SetSeekDir`](@ref), [`SetTRefAction`](@ref), [`SetWritable`](@ref), [`Sizeof`](@ref), [`TDirectoryFile`](@ref), [`WriteDirHeader`](@ref), [`WriteKeys`](@ref), [`WriteObjectAny`](@ref), [`WriteTObject`](@ref), [`Write`](@ref), [`cd`](@ref), [`ls`](@ref), [`mkdir`](@ref), [`rmdir`](@ref)
""" TDirectoryFile

# Wrapper of TDatime
@trydoc raw"""
    ROOT.TDatime

This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559).

The date is stored with the origin being the 1st January 1995.

This class has no support for time zones. The time is assumed to be in the local_ time of the machine where the object was created. As a result, [TDatime](@ref) objects are not portable between machines operating in different time zones and unsuitable for storing the date/time of data taking events and the like. If absolute time is required, use [TTimeStamp](@ref).

Related functions: [`AsSQLString`](@ref), [`AsString`](@ref), [`Convert`](@ref), [`Copy`](@ref), [`FillBuffer`](@ref), [`GetDate`](@ref), [`GetDayOfWeek`](@ref), [`GetDay`](@ref), [`GetHour`](@ref), [`GetMinute`](@ref), [`GetMonth`](@ref), [`GetSecond`](@ref), [`GetTime`](@ref), [`GetYear`](@ref), [`Get`](@ref), [`IsA`](@ref), [`Print`](@ref), [`ReadBuffer`](@ref), [`Set`](@ref), [`Sizeof`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TDatime!Class_Name`](@ref), [`TDatime!Class_Version`](@ref), [`TDatime!Class`](@ref), [`TDatime!DeclFileName`](@ref), [`TDatime!GetDateFromGlobalDay`](@ref), [`TDatime!GetDateTime`](@ref), [`TDatime!GetGlobalDayFromDate`](@ref), [`TDatime!GetLegalGlobalDayFromDate`](@ref), [`TDatime`](@ref), [`assign`](@ref)
""" TDatime

# Wrapper of TUrl
@trydoc raw"""
    ROOT.TUrl

This class represents a WWW compatible URL.

It provides member functions to return the different parts of an URL. The supported url format is: 

    [proto://][user[:passwd]@]host[:port]/file.ext[#anchor][?options]

(C++ version of the code)

Related functions: [`CleanRelativePath`](@ref), [`Compare`](@ref), [`GetAnchor`](@ref), [`GetFileAndOptions`](@ref), [`GetFile`](@ref), [`GetHostFQDN`](@ref), [`GetHost`](@ref), [`GetIntValueFromOptions`](@ref), [`GetOptions`](@ref), [`GetPasswd`](@ref), [`GetPort`](@ref), [`GetProtocol`](@ref), [`GetUrl`](@ref), [`GetUser`](@ref), [`GetValueFromOptions`](@ref), [`HasOption`](@ref), [`IsA`](@ref), [`IsSortable`](@ref), [`IsValid`](@ref), [`ParseOptions`](@ref), [`Print`](@ref), [`SetAnchor`](@ref), [`SetFile`](@ref), [`SetHost`](@ref), [`SetOptions`](@ref), [`SetPasswd`](@ref), [`SetPort`](@ref), [`SetProtocol`](@ref), [`SetUrl`](@ref), [`SetUser`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TUrl!Class_Name`](@ref), [`TUrl!Class_Version`](@ref), [`TUrl!Class`](@ref), [`TUrl!DeclFileName`](@ref), [`TUrl!GetSpecialProtocols`](@ref), [`TUrl`](@ref), [`assign`](@ref)
""" TUrl

# Wrapper of TFileOpenHandle
@trydoc raw"""
    ROOT.TFileOpenHandle

Class holding info about the file being opened.



Related functions: [`GetCompress`](@ref), [`GetNetOpt`](@ref), [`GetOpt`](@ref), [`Matches`](@ref)
""" TFileOpenHandle

# Wrapper of TFitResult
@trydoc raw"""
    ROOT.TFitResult

Extends the ROOT!Fit!Result class with a [TNamed](@ref) inheritance providing easy possibility for I/O.



Related functions: [`Contour`](@ref), [`Error`](@ref), [`GetCorrelationMatrix`](@ref), [`GetCovarianceMatrix`](@ref), [`Print`](@ref), [`Scan`](@ref), [`TFitResult`](@ref)
""" TFitResult

# Wrapper of TFitResultPtr
@trydoc raw"""
    ROOT.TFitResultPtr

Provides an indirection to the [TFitResult](@ref) class and with a semantics identical to a [TFitResult](@ref) pointer, i.e.

it is like a smart pointer to a [TFitResult](@ref). In addition it provides an automatic conversion to an integer. In this way it can be returned from the [TH1!Fit](@ref) method and the change in [TH1!Fit](@ref) be backward compatible.

Related functions: [`Base.getindex`](@ref), [`Get`](@ref), [`TFitResultPtr`](@ref), [`arrow`](@ref), [`assign`](@ref), [`int`](@ref)
""" TFitResultPtr

# Wrapper of TF1
@trydoc raw"""
    ROOT.TF1

1-Dim function class

## TF1: 1-Dim function class

A [TF1](@ref) object is a 1-Dim function defined between a lower and upper limit. The function may be a simple function based on a [TFormula](@ref) expression or a precompiled user function. The function may have associated parameters. [TF1](@ref) graphics function is via the [TH1](@ref) and [TGraph](@ref) drawing functions.

The following types of functions can be created:

1. [Expression using variable x and no parameters](@ref)
2. [Expression using variable x with parameters](@ref)
3. [Lambda Expression with variable x and parameters](@ref)
4. [A general C function with parameters](@ref)
5. [A general C++ function object (functor) with parameters](@ref)
6. [A member function with parameters of a general C++ class](@ref)

### 1 - Expression using variable x and no parameters

#### Case 1: inline expression using standard C++ functions/operators

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF1_001.png](https://root.cern/doc/v636/pict1_TF1_001.png)

#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF1_002.png](https://root.cern/doc/v636/pict1_TF1_002.png)

#### Case 3: inline expression using a user defined CLING function by name

    Double_t myFunc(double x) { return x+sin(x); }
    ....
    auto fa3 = new TF1("fa3","myFunc(x)",-3,5);
    fa3->Draw();

(C++ version of the code)

### 2 - Expression using variable x with parameters

#### Case 1: inline expression using standard C++ functions/operators

Example a:

    auto fa = new TF1("fa","[0]*x*sin([1]*x)",-3,3);

(C++ version of the code)

This creates a function of variable x with 2 parameters. The parameters must be initialized via:

    fa->SetParameter(0,value_first_parameter);
    fa->SetParameter(1,value_second_parameter);

(C++ version of the code)

Parameters may be given a name:

    fa->SetParName(0,"Constant");

(C++ version of the code)

Example b:

    auto fb = new TF1("fb","gaus(0)*expo(3)",0,10);

(C++ version of the code)

`gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)` and `(0)` means thestart numbering parameters at `0`. `expo(3)` is a substitute for `exp([3]+[4]*x)`.

#### Case 2: inline expression using TMath functions with parameters

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF1_003.png](https://root.cern/doc/v636/pict1_TF1_003.png)

### 3 - A lambda expression with variables and parameters

###Since

6.00/00: TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda functions and still maintain the capability of storing the function in a file which cannot be done with function pointer or lambda written not as expression, but as code (see items below).

Example on how using lambda to define a sum of two functions. Note that is necessary to provide the number of parameters

    TF1 f1("f1","sin(x)",0,10);
    TF1 f2("f2","cos(x)",0,10);
    TF1 fsum("f1","[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }",0,10,2);

(C++ version of the code)

### 4 - A general C function with parameters

Consider the macro myfunc.C below:

    // Macro myfunc.C
    Double_t myfunction(Double_t *x, Double_t *par)
    {
       Float_t xx =x[0];
       Double_t f = TMath!Abs(par[0]*sin(par[1]*xx)/xx);
       return f;
    }
    void myfunc()
    {
       auto f1 = new TF1("myfunc",myfunction,0,10,2);
       f1->SetParameters(2,1);
       f1->SetParNames("constant","coefficient");
       f1->Draw();
    }
    void myfit()
    {
       auto h1 = new TH1F("h1","test",100,0,10);
       h1->FillRandom("myfunc",20000);
       TF1 *f1 = (TF1 *)gROOT->GetFunction("myfunc");
       f1->SetParameters(800,1);
       h1->Fit("myfunc");
    }

(C++ version of the code)

In an interactive session you can do:

    Root > .L myfunc.C
    Root > myfunc();
    Root > myfit();

(C++ version of the code)

[TF1](@ref) objects can reference other [TF1](@ref) objects of type A or B defined above. This excludes CLing or compiled functions. However, there is a restriction. A function cannot reference a basic function if the basic function is a polynomial polN.

Example:

    {
          auto fcos = new TF1 ("fcos", "[0]*cos(x)", 0., 10.);
          fcos->SetParNames( "cos");
          fcos->SetParameter( 0, 1.1);
          auto fsin = new TF1 ("fsin", "[0]*sin(x)", 0., 10.);
          fsin->SetParNames( "sin");
          fsin->SetParameter( 0, 2.1);
          auto fsincos = new TF1 ("fsc", "fcos+fsin");
          auto fs2 = new TF1 ("fs2", "fsc+fsc");
    }

(C++ version of the code)

### 5 - A general C++ function object (functor) with parameters

A [TF1](@ref) can be created from any C++ class implementing the operator()(double *x, double *p). The advantage of the function object is that he can have a state and reference therefore what-ever other object. In this way the user can customize his function.

Example:

    class  MyFunctionObject {
     public:
       // use constructor to customize your function object
       double operator() (double *x, double *p) {
          // function implementation using class data members
       }
    };
    {
        ....
       MyFunctionObject fobj;
       auto f = new TF1("f",fobj,0,1,npar);    // create TF1 class.
       .....
    }

(C++ version of the code)

#### Using a lambda function as a general C++ functor object

From C++11 we can use both std!function or even better lambda functions to create the [TF1](@ref). As above the lambda must have the right signature but can capture whatever we want. For example we can make a [TF1](@ref) from the [TGraph!Eval](@ref) function as shown below where we use as function parameter the graph normalization.

    auto g = new TGraph(npointx, xvec, yvec);
    auto f = new TF1("f",[&](double*x, double *p){ return p[0]*g->Eval(x[0]); }, xmin, xmax, 1);

(C++ version of the code)

### 6 - A member function with parameters of a general C++ class

A [TF1](@ref) can be created in this case from any member function of a class which has the signature of (double * , double *) and returning a double.

Example:

    class  MyFunction {
     public:
       ...
       double Evaluate() (double *x, double *p) {
          // function implementation
       }
    };
    {
        ....
       MyFunction *fptr = new MyFunction(....);  // create the user function class
       auto f = new TF1("f",fptr,&MyFunction!Evaluate,0,1,npar,"MyFunction","Evaluate");   // create TF1 class.
       .....
    }

(C++ version of the code)

See also the tutorial **math/exampleFunctor.C** for a running example.

Related functions: [`AddParameter`](@ref), [`AddToGlobalList`](@ref), [`Browse`](@ref), [`CentralMoment`](@ref), [`Clone`](@ref), [`Copy`](@ref), [`CreateHistogram`](@ref), [`Derivative2`](@ref), [`Derivative3`](@ref), [`Derivative`](@ref), [`DistancetoPrimitive`](@ref), [`DrawCopy`](@ref), [`DrawDerivative`](@ref), [`DrawF1`](@ref), [`DrawIntegral`](@ref), [`Draw`](@ref), [`EvalPar`](@ref), [`EvalUncertainty`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`FixParameter`](@ref), [`GetChisquare`](@ref), [`GetExpFormula`](@ref), [`GetFormula`](@ref), [`GetHistogram`](@ref), [`GetLinearPart`](@ref), [`GetMaximumStored`](@ref), [`GetMaximumX`](@ref), [`GetMaximum`](@ref), [`GetMethodCall`](@ref), [`GetMinimumStored`](@ref), [`GetMinimumX`](@ref), [`GetMinimum`](@ref), [`GetNDF`](@ref), [`GetNdim`](@ref), [`GetNpar`](@ref), [`GetNpx`](@ref), [`GetNumberFitPoints`](@ref), [`GetNumberFreeParameters`](@ref), [`GetNumber`](@ref), [`GetObjectInfo`](@ref), [`GetParError`](@ref), [`GetParErrors`](@ref), [`GetParLimits`](@ref), [`GetParName`](@ref), [`GetParNumber`](@ref), [`GetParameter`](@ref), [`GetParameters`](@ref), [`GetParent`](@ref), [`GetProb`](@ref), [`GetQuantiles`](@ref), [`GetRandom`](@ref), [`GetRange`](@ref), [`GetSave`](@ref), [`GetVariable`](@ref), [`GetX`](@ref), [`GetXaxis`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`GradientParTempl`](@ref), [`GradientPar`](@ref), [`HasSave`](@ref), [`InitArgs`](@ref), [`IntegralError`](@ref), [`IntegralFast`](@ref), [`IntegralMultiple`](@ref), [`IntegralOneDim`](@ref), [`Integral`](@ref), [`IsEvalNormalized`](@ref), [`IsInside`](@ref), [`IsLinear`](@ref), [`IsValid`](@ref), [`IsVectorized`](@ref), [`Mean`](@ref), [`Moment`](@ref), [`Paint`](@ref), [`Print`](@ref), [`ReleaseParameter`](@ref), [`SavePrimitive`](@ref), [`Save`](@ref), [`SetChisquare`](@ref), [`SetFitResult`](@ref), [`SetFunction`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNDF`](@ref), [`SetNdim`](@ref), [`SetNormalized`](@ref), [`SetNpx`](@ref), [`SetNumberFitPoints`](@ref), [`SetParError`](@ref), [`SetParErrors`](@ref), [`SetParLimits`](@ref), [`SetParName`](@ref), [`SetParNames`](@ref), [`SetParameter`](@ref), [`SetParameters`](@ref), [`SetParent`](@ref), [`SetRange`](@ref), [`SetSavedPoint`](@ref), [`SetTitle`](@ref), [`SetVectorized`](@ref), [`TF1!AbsValue`](@ref), [`TF1!CalcGaussLegendreSamplingPoints`](@ref), [`TF1!DefaultAddToGlobalList`](@ref), [`TF1!DerivativeError`](@ref), [`TF1!GetCurrent`](@ref), [`TF1!InitStandardFunctions`](@ref), [`TF1!RejectPoint`](@ref), [`TF1!RejectedPoint`](@ref), [`TF1!SetCurrent`](@ref), [`TF1`](@ref), [`Update`](@ref), [`Variance`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TF1

# Wrapper of TGraph
@trydoc raw"""
    ROOT.TGraph

A [TGraph](@ref) is an object made of two arrays X and Y with npoints each.

The [TGraph](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

#### Notes

- Unlike histogram or tree (or even [TGraph2D](@ref)), [TGraph](@ref) objects are not automatically attached to the current [TFile](@ref), in order to keep the management and size of the [TGraph](@ref) as small as possible.
- The [TGraph](@ref) constructors do not have the [TGraph](@ref) title and name as parameters. A [TGraph](@ref) has the default title and name "Graph". To change the default title and name `SetTitle` and `SetName` should be called on the [TGraph](@ref) after its creation. [TGraph](@ref) was a light weight object to thestart with, like TPolyline or [TPolyMarker](@ref). That’s why it did not have any title and name parameters in the constructors.

#### Example

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph_001.png](https://root.cern/doc/v636/pict1_TGraph_001.png)

#### Default X-Points

If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending on the length of the y-points):

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph_002.png](https://root.cern/doc/v636/pict1_TGraph_002.png)

Related functions: [`AddPoint`](@ref), [`Add`](@ref), [`Apply`](@ref), [`Browse`](@ref), [`Chisquare`](@ref), [`ComputeRange`](@ref), [`DistancetoPrimitive`](@ref), [`DrawGraph`](@ref), [`DrawPanel`](@ref), [`Draw`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`Expand`](@ref), [`FindObject`](@ref), [`FitPanel`](@ref), [`Fit`](@ref), [`GetCorrelationFactor`](@ref), [`GetCovariance`](@ref), [`GetEX`](@ref), [`GetEXhigh`](@ref), [`GetEXhighd`](@ref), [`GetEXlow`](@ref), [`GetEXlowd`](@ref), [`GetEY`](@ref), [`GetEYhigh`](@ref), [`GetEYhighd`](@ref), [`GetEYlow`](@ref), [`GetEYlowd`](@ref), [`GetEditable`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`GetFunction`](@ref), [`GetHistogram`](@ref), [`GetListOfFunctions`](@ref), [`GetMaxSize`](@ref), [`GetMaximum`](@ref), [`GetMean`](@ref), [`GetMinimum`](@ref), [`GetN`](@ref), [`GetObjectInfo`](@ref), [`GetPointX`](@ref), [`GetPointY`](@ref), [`GetPoint`](@ref), [`GetRMS`](@ref), [`GetX`](@ref), [`GetXaxis`](@ref), [`GetY`](@ref), [`GetYaxis`](@ref), [`InitExpo`](@ref), [`InitGaus`](@ref), [`InitPolynom`](@ref), [`InsertPointBefore`](@ref), [`InsertPoint`](@ref), [`Integral`](@ref), [`IsEditable`](@ref), [`IsHighlight`](@ref), [`IsInside`](@ref), [`LeastSquareFit`](@ref), [`LeastSquareLinearFit`](@ref), [`Merge`](@ref), [`MovePoints`](@ref), [`PaintGrapHist`](@ref), [`PaintGraph`](@ref), [`PaintStats`](@ref), [`Paint`](@ref), [`Print`](@ref), [`RecursiveRemove`](@ref), [`RemovePoint`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetEditable`](@ref), [`SetHighlight`](@ref), [`SetHistogram`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetOption`](@ref), [`SetPointX`](@ref), [`SetPointY`](@ref), [`SetPoint`](@ref), [`SetStats`](@ref), [`SetTitle`](@ref), [`Set`](@ref), [`Sort`](@ref), [`TGraph!CompareArg`](@ref), [`TGraph!CompareRadius`](@ref), [`TGraph!CompareX`](@ref), [`TGraph!CompareY`](@ref), [`TGraph`](@ref), [`UseCurrentStyle`](@ref), [`Zero`](@ref), [`assign`](@ref)
""" TGraph

# Wrapper of TGraph2D
@trydoc raw"""
    ROOT.TGraph2D

Graphics object made of three arrays X, Y and Z with the same number of points each.

- [Creating a TGraph2D](@ref)
- [Drawing options](@ref)
- [Examples](@ref)

    - [SURF1 Example](@ref)
    - [Fitting Example](@ref)
    - [PCOL Example](@ref)
- [Definition of the Delaunay triangulation (After B. Delaunay)](@ref)

## Creating a TGraph2D

This class has different constructors:

- With an array's dimension and three arrays x, y, and z: 

        auto g = new TGraph2D(n, x, y, z);

(C++ version of the code)

 x, y, z arrays can be doubles, floats, or ints.
- With an array's dimension only: 

        auto g = new TGraph2D(n);

(C++ version of the code)

 The internal arrays are then filled with `SetPoint()`. The following line fills the internal arrays at the position `i` with the values `x`, `y`, `z`. 

        g->SetPoint(i, x, y, z);

(C++ version of the code)

- Without parameters: 

        auto g = new TGraph2D();

(C++ version of the code)

 again `SetPoint()` must be used to fill the internal arrays.
- From a file: 

        auto g = new TGraph2D("graph.dat");

(C++ version of the code)

 Arrays are read from the ASCII file "graph.dat" according to a specifies format. The default format is `%lg %lg %lg`

Note that in any of these three cases, `SetPoint()` can be used to change a data point or add a new one. If the data point index (`i`) is greater than the current size of the internal arrays, they are automatically extended.

Like [TGraph](@ref) some [TGraph2D](@ref) constructors do not have the [TGraph2D](@ref) title and name as parameters. For these constructors [TGraph2D](@ref) has the default title and name "Graph2D". To change the default title and name `SetTitle` and `SetName` should be called on the [TGraph2D](@ref) after its creation.

## Drawing options

Specific drawing options can be used to paint a [TGraph2D](@ref):

| **Option** | **Description**                                                                                                                                                                                                                |
|:-----------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "TRI"      | The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color. |
| "TRIW"     | The Delaunay triangles are drawn as wire frame.                                                                                                                                                                                |
| "TRI1"     | The Delaunay triangles are painted with color levels. The edges of each triangles are painted with the current line color.                                                                                                     |
| "TRI2"     | The Delaunay triangles are painted with color levels.                                                                                                                                                                          |
| "P"        | Draw a marker at each vertex.                                                                                                                                                                                                  |
| "P0"       | Draw a circle at each vertex. Each circle background is white.                                                                                                                                                                 |
| "PCOL"     | Draw a marker at each vertex. The color of each marker is defined according to its Z position.                                                                                                                                 |
| "LINE"     | Draw a 3D polyline.                                                                                                                                                                                                            |
| "CONT5"    | Draw a contour plot using Delaunay triangles.                                                                                                                                                                                  |

The Delaunay triangulation algorithm assumes that each (x, y) coordinate corresponds to a unique z value, meaning duplicate (x, y) points are not allowed. Consequently, when using drawing options that rely on this algorithm (e.g., TRI, SURF, etc.), a warning may appear instructing you to remove duplicates (see [RemoveDuplicates()](@ref)).

A [TGraph2D](@ref) can be also drawn with any options valid to draw a 2D histogram (like `COL`, `SURF`, `LEGO`, `CONT` etc..).

When a [TGraph2D](@ref) is drawn with one of the 2D histogram drawing option, an intermediate 2D histogram is filled using the Delaunay triangles to interpolate the data set. The 2D histogram has equidistant bins along the X and Y directions. The number of bins along each direction can be change using `SetNpx()` and `SetNpy()`. Each bin is filled with the Z value found via a linear interpolation on the plane defined by the triangle above the (X,Y) coordinates of the bin center.

The existing (X,Y,Z) points can be randomly scattered. The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then used to define flat planes in (X,Y,Z) over which the interpolation is done to fill the 2D histogram. The 3D triangles int takes build a 3D surface in the form of tessellating triangles at various angles. The triangles found can be drawn in 3D with one of the [TGraph2D](@ref) specific drawing options.

The histogram generated by the Delaunay interpolation can be accessed using the `GetHistogram()` method.

The axis settings (title, ranges etc ...) can be changed accessing the axis via the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created at drawing time only. Therefore they should called after the [TGraph2D](@ref) is drawn:

    auto g = new TGraph2D();
    [...]
    g->Draw("tri1");
    gPad->Update();
    g->GetXaxis()->SetTitle("X axis title");

(C++ version of the code)

## Examples

### SURF1 Example

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2D_001.png](https://root.cern/doc/v636/pict1_TGraph2D_001.png)

### Fitting Example

2D graphs can be fitted as shown by the following example:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TGraph2D_002.png](https://root.cern/doc/v636/pict1_TGraph2D_002.png)

### PCOL Example

Example showing the PCOL option.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2D_003.png](https://root.cern/doc/v636/pict1_TGraph2D_003.png)

## Definition of the Delaunay triangulation (After B. Delaunay)

For a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circumcircle of any triangle in DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of points in S, the Voronoi diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exactly one point and every point in a given polygon is closer to its central point than to any other. A Voronoi diagram is sometimes also known as a Dirichlet tessellation.

![https://root.cern/doc/v636/tgraph2d_delaunay.png](https://root.cern/doc/v636/tgraph2d_delaunay.png)

[This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html) gives a nice practical view of Delaunay triangulation and Voronoi diagram.

Related functions: [`AddPoint`](@ref), [`Add`](@ref), [`Apply`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`DirectoryAutoAdd`](@ref), [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`FindObject`](@ref), [`FitPanel`](@ref), [`Fit`](@ref), [`GetContourList`](@ref), [`GetDirectory`](@ref), [`GetEX`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEY`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetEZ`](@ref), [`GetEZhigh`](@ref), [`GetEZlow`](@ref), [`GetErrorX`](@ref), [`GetErrorY`](@ref), [`GetErrorZ`](@ref), [`GetFunction`](@ref), [`GetHistogram`](@ref), [`GetListOfFunctions`](@ref), [`GetMargin`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetN`](@ref), [`GetNpx`](@ref), [`GetNpy`](@ref), [`GetPoint`](@ref), [`GetX`](@ref), [`GetXaxis`](@ref), [`GetXmaxE`](@ref), [`GetXmax`](@ref), [`GetXminE`](@ref), [`GetXmin`](@ref), [`GetY`](@ref), [`GetYaxis`](@ref), [`GetYmaxE`](@ref), [`GetYmax`](@ref), [`GetYminE`](@ref), [`GetYmin`](@ref), [`GetZ`](@ref), [`GetZaxis`](@ref), [`GetZmaxE`](@ref), [`GetZmax`](@ref), [`GetZminE`](@ref), [`GetZmin`](@ref), [`Interpolate`](@ref), [`Paint`](@ref), [`Print`](@ref), [`Project`](@ref), [`RecursiveRemove`](@ref), [`RemoveDuplicates`](@ref), [`RemovePoint`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetDirectory`](@ref), [`SetHistogram`](@ref), [`SetMarginBinsContent`](@ref), [`SetMargin`](@ref), [`SetMaxIter`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`SetNameTitle`](@ref), [`SetName`](@ref), [`SetNpx`](@ref), [`SetNpy`](@ref), [`SetPoint`](@ref), [`SetTitle`](@ref), [`Set`](@ref), [`TGraph2D`](@ref), [`assign`](@ref)
""" TGraph2D

# Wrapper of TGraphErrors
@trydoc raw"""
    ROOT.TGraphErrors

A [TGraphErrors](@ref) is a [TGraph](@ref) with error bars.

The [TGraphErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphErrors_001.png](https://root.cern/doc/v636/pict1_TGraphErrors_001.png)

Related functions: [`AddPointError`](@ref), [`ApplyX`](@ref), [`Apply`](@ref), [`ComputeRange`](@ref), [`GetEX`](@ref), [`GetEY`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`Merge`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`TGraphErrors!CalculateScanfFields`](@ref), [`TGraphErrors`](@ref), [`assign`](@ref)
""" TGraphErrors

# Wrapper of TAxis
@trydoc raw"""
    ROOT.TAxis

Class to manage histogram axis.

This class manages histogram axis. It is referenced by [TH1](@ref) and [TGraph](@ref). To make a graphical representation of an histogram axis, this class references the [TGaxis](@ref) class. [TAxis](@ref) supports axis with fixed or variable bin sizes. Labels may be associated to individual bins. See examples of various axis representations drawn by class [TGaxis](@ref).

Related functions: [`CanBeAlphanumeric`](@ref), [`CanExtend`](@ref), [`CenterLabels`](@ref), [`CenterTitle`](@ref), [`ChangeLabelByValue`](@ref), [`ChangeLabel`](@ref), [`ChooseTimeFormat`](@ref), [`Copy`](@ref), [`Delete`](@ref), [`DistancetoPrimitive`](@ref), [`DrawClone`](@ref), [`ExecuteEvent`](@ref), [`FindBin`](@ref), [`FindFixBin`](@ref), [`GetBinCenterLog`](@ref), [`GetBinCenter`](@ref), [`GetBinLabel`](@ref), [`GetBinLowEdge`](@ref), [`GetBinUpEdge`](@ref), [`GetBinWidth`](@ref), [`GetCenterLabels`](@ref), [`GetCenterTitle`](@ref), [`GetCenter`](@ref), [`GetDecimals`](@ref), [`GetFirst`](@ref), [`GetLabels`](@ref), [`GetLast`](@ref), [`GetLowEdge`](@ref), [`GetModifiedLabels`](@ref), [`GetMoreLogLabels`](@ref), [`GetNbins`](@ref), [`GetNlabels`](@ref), [`GetNoExponent`](@ref), [`GetParent`](@ref), [`GetRotateTitle`](@ref), [`GetTicks`](@ref), [`GetTimeDisplay`](@ref), [`GetTimeFormatOnly`](@ref), [`GetTimeFormat`](@ref), [`GetTimeOffset`](@ref), [`GetTitle`](@ref), [`GetXbins`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`ImportAttributes`](@ref), [`IsAlphanumeric`](@ref), [`IsVariableBinSize`](@ref), [`LabelsOption`](@ref), [`RotateTitle`](@ref), [`SaveAttributes`](@ref), [`SetAlphanumeric`](@ref), [`SetBinLabel`](@ref), [`SetCanExtend`](@ref), [`SetDecimals`](@ref), [`SetDefaults`](@ref), [`SetDrawOption`](@ref), [`SetLimits`](@ref), [`SetMoreLogLabels`](@ref), [`SetNoAlphanumeric`](@ref), [`SetNoExponent`](@ref), [`SetParent`](@ref), [`SetRangeUser`](@ref), [`SetRange`](@ref), [`SetTicks`](@ref), [`SetTimeDisplay`](@ref), [`SetTimeFormat`](@ref), [`SetTimeOffset`](@ref), [`Set`](@ref), [`TAxis`](@ref), [`UnZoom`](@ref), [`ZoomOut`](@ref), [`assign`](@ref)
""" TAxis

# Wrapper of TAxisModLab
@trydoc raw"""
    ROOT.TAxisModLab

[TAxis](@ref) helper class used to store the modified labels.



Related functions: [`GetAlign`](@ref), [`GetAngle`](@ref), [`GetColor`](@ref), [`GetFont`](@ref), [`GetLabNum`](@ref), [`GetLabValue`](@ref), [`GetSize`](@ref), [`GetText`](@ref), [`SetAlign`](@ref), [`SetAngle`](@ref), [`SetColor`](@ref), [`SetFont`](@ref), [`SetLabNum`](@ref), [`SetLabValue`](@ref), [`SetSize`](@ref), [`SetText`](@ref), [`TAxisModLab`](@ref)
""" TAxisModLab

# Wrapper of TVirtualFitter
@trydoc raw"""
    ROOT.TVirtualFitter

Abstract Base Class for Fitting.



Related functions: [`Chisquare`](@ref), [`Clear`](@ref), [`ExecuteCommand`](@ref), [`FixParameter`](@ref), [`GetConfidenceIntervals`](@ref), [`GetCovarianceMatrixElement`](@ref), [`GetCovarianceMatrix`](@ref), [`GetErrors`](@ref), [`GetFCN`](@ref), [`GetFitOption`](@ref), [`GetMethodCall`](@ref), [`GetNumberFreeParameters`](@ref), [`GetNumberTotalParameters`](@ref), [`GetObjectFit`](@ref), [`GetParError`](@ref), [`GetParName`](@ref), [`GetParameter`](@ref), [`GetStats`](@ref), [`GetSumLog`](@ref), [`GetUserFunc`](@ref), [`GetXfirst`](@ref), [`GetXlast`](@ref), [`GetYfirst`](@ref), [`GetYlast`](@ref), [`GetZfirst`](@ref), [`GetZlast`](@ref), [`IsFixed`](@ref), [`PrintResults`](@ref), [`ReleaseParameter`](@ref), [`SetCache`](@ref), [`SetFCN`](@ref), [`SetFitMethod`](@ref), [`SetFitOption`](@ref), [`SetObjectFit`](@ref), [`SetParameter`](@ref), [`SetUserFunc`](@ref), [`SetXfirst`](@ref), [`SetXlast`](@ref), [`SetYfirst`](@ref), [`SetYlast`](@ref), [`SetZfirst`](@ref), [`SetZlast`](@ref), [`TVirtualFitter!Fitter`](@ref), [`TVirtualFitter!GetDefaultFitter`](@ref), [`TVirtualFitter!GetErrorDef`](@ref), [`TVirtualFitter!GetFitter`](@ref), [`TVirtualFitter!GetMaxIterations`](@ref), [`TVirtualFitter!GetPrecision`](@ref), [`TVirtualFitter!SetDefaultFitter`](@ref), [`TVirtualFitter!SetErrorDef`](@ref), [`TVirtualFitter!SetFitter`](@ref), [`TVirtualFitter!SetMaxIterations`](@ref), [`TVirtualFitter!SetPrecision`](@ref), [`TVirtualFitter`](@ref)
""" TVirtualFitter

# Wrapper of TMethodCall
@trydoc raw"""
    ROOT.TMethodCall

Method or function calling interface.

Objects of this class contain the (CINT) environment to call a global_ function or a method for an object of a specific class with the desired arguments. This class is especially useful when a method has to be called more times for different objects and/or with different arguments. If a function or method needs to be called only once one better uses [TInterpreter!Execute()](@ref).

A limitation is known with the present implementation: failures can occur if parameters involve temporary object construction.

Related functions: [`CallDtorOnly`](@ref), [`Clone`](@ref), [`Execute`](@ref), [`GetCallFunc`](@ref), [`GetMethodName`](@ref), [`GetMethod`](@ref), [`GetParams`](@ref), [`GetProto`](@ref), [`InitWithPrototype`](@ref), [`Init`](@ref), [`IsValid`](@ref), [`ResetParam`](@ref), [`ReturnType`](@ref), [`SetParamPtrs`](@ref), [`SetParam`](@ref), [`SetParams`](@ref), [`TMethodCall`](@ref), [`assign`](@ref)
""" TMethodCall

# Wrapper of TBackCompFitter
@trydoc raw"""
    ROOT.TBackCompFitter

Backward compatible implementation of [TVirtualFitter](@ref).

Backward compatible implementation of [TVirtualFitter](@ref) using the class [ROOT!Fit!Fitter](@ref). This class is created after fitting an histogram ([TH1](@ref)), [TGraph](@ref) or [TTree](@ref) and provides in addition to the methods of the [TVirtualFitter](@ref) hooks to access the fit result class ([ROOT!Fit!FitResult](@ref)), the fit configuration ([ROOT!Fit!FitConfig](@ref)) or the fit data ([ROOT!Fit!FitData](@ref)) using

    TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter!GetFitter();
    ROOT!Fit!FitResult & result = fitter->GetFitResult();
    result.Print(std!cout);

(C++ version of the code)

Methods for getting the confidence level or contours are also provided. Note that after a new calls to [TH1!Fit](@ref) (or similar) the class will be deleted and all reference to the FitResult, FitConfig or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information.

Related functions: [`Chisquare`](@ref), [`Clear`](@ref), [`Contour`](@ref), [`ExecuteCommand`](@ref), [`FixParameter`](@ref), [`GetConfidenceIntervals`](@ref), [`GetCovarianceMatrixElement`](@ref), [`GetCovarianceMatrix`](@ref), [`GetErrors`](@ref), [`GetFitConfig`](@ref), [`GetFitData`](@ref), [`GetFitResult`](@ref), [`GetMinimizer`](@ref), [`GetNumberFreeParameters`](@ref), [`GetNumberTotalParameters`](@ref), [`GetObjFunction`](@ref), [`GetParError`](@ref), [`GetParName`](@ref), [`GetParameter`](@ref), [`GetStats`](@ref), [`GetSumLog`](@ref), [`GetTFitResult`](@ref), [`IsFixed`](@ref), [`PrintResults`](@ref), [`ReCreateMinimizer`](@ref), [`ReleaseParameter`](@ref), [`Scan`](@ref), [`SetFCN`](@ref), [`SetFitMethod`](@ref), [`SetMethodCall`](@ref), [`SetObjFunction`](@ref), [`SetParameter`](@ref), [`TBackCompFitter`](@ref)
""" TBackCompFitter

# Wrapper of TBinomialEfficiencyFitter
@trydoc raw"""
    ROOT.TBinomialEfficiencyFitter

Binomial fitter for the division of two histograms.

Use when you need to calculate a selection's efficiency from two histograms, one containing all entries, and one containing the subset of these entries that pass the selection, and when you have a parametrization available for the efficiency as a function of the variable(s) under consideration.

A very common problem when estimating efficiencies is that of error estimation: when no other information is available than the total number of events N and the selected number n, the best estimate for the selection efficiency p is n/N. Standard binomial statistics dictates that the uncertainty (this presupposes sufficiently high statistics that an approximation by a normal distribution is reasonable) on p, given N, is 

``\sqrt{\frac{p(1-p)}{N}}``

 However, when p is estimated as n/N, fluctuations from the true p to its estimate become important, especially for low numbers of events, and giving rise to biased results.

When fitting a parametrized efficiency, these problems can largely be overcome, as a hypothesized true efficiency is available by construction. Even so, simply using the corresponding uncertainty still presupposes that Gaussian errors yields a reasonable approximation. When using, instead of binned efficiency histograms, the original numerator and denominator histograms, a binned maximum likelihood can be constructed as the product of bin-by-bin binomial probabilities to select n out of N events. Assuming that a correct parametrization of the efficiency is provided, this construction in general yields less biased results (and is much less sensitive to binning details).

A generic use of this method is given below (note that the method works for 2D and 3D histograms as well):

    {
        TH1* denominator;              // denominator histogram
        TH1* numerator;                // corresponding numerator histogram
        TF1* eff;                      // efficiency parametrization
        ....                           // set step sizes and initial parameter
        ....                           //   values for the fit function
        ....                           // possibly also set ranges, see TF1!SetRange()
        TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(
                                     numerator, denominator);
        Int_t status = f->Fit(eff, "I");
        if (status == 0) {
          // if the fit was successful, display bin-by-bin efficiencies
          // as well as the result of the fit
          numerator->Sumw2();
          TH1* hEff = dynamic_cast<TH1*>(numerator->Clone("heff"));
          hEff->Divide(hEff, denominator, 1.0, 1.0, "B");
          hEff->Draw("E");
          eff->Draw("same");
        }
    }

(C++ version of the code)

Note that this method cannot be expected to yield reliable results when using weighted histograms (because the likelihood computation will be incorrect).

Related functions: [`EvaluateFCN`](@ref), [`Fit`](@ref), [`GetFitter`](@ref), [`SetPrecision`](@ref), [`Set`](@ref), [`TBinomialEfficiencyFitter`](@ref)
""" TBinomialEfficiencyFitter

# Wrapper of TConfidenceLevel
@trydoc raw"""
    ROOT.TConfidenceLevel

Class to compute 95% CL limits.



Related functions: [`CLb`](@ref), [`CLs`](@ref), [`CLsb`](@ref), [`Draw`](@ref), [`Get3sProbability`](@ref), [`Get5sProbability`](@ref), [`GetAverageCLs`](@ref), [`GetAverageCLsb`](@ref), [`GetBtot`](@ref), [`GetDtot`](@ref), [`GetExpectedCLb_b`](@ref), [`GetExpectedCLb_sb`](@ref), [`GetExpectedCLs_b`](@ref), [`GetExpectedCLsb_b`](@ref), [`GetExpectedStatistic_b`](@ref), [`GetExpectedStatistic_sb`](@ref), [`GetStatistic`](@ref), [`GetStot`](@ref), [`SetBtot`](@ref), [`SetDtot`](@ref), [`SetLRB`](@ref), [`SetLRS`](@ref), [`SetStot`](@ref), [`SetTSB`](@ref), [`SetTSD`](@ref), [`SetTSS`](@ref), [`TConfidenceLevel`](@ref)
""" TConfidenceLevel

# Wrapper of TEfficiency
@trydoc raw"""
    ROOT.TEfficiency

Class to handle efficiency histograms.

- [I. Overview](@ref)
- [II. Creating a TEfficiency object](@ref)

    - [Example 1](@ref)
    - [Example 2](@ref)
- [III. Filling with events](@ref)
- [IV. Statistic options](@ref)

    - [Frequentist methods](@ref)
    - [Bayesian methods](@ref)
    - [IV.1 Coverage probabilities for different methods](@ref)
- [V. Merging and combining TEfficiency objects](@ref)

    - [Example](@ref)
    - [V.1 When should I use merging?](@ref)

        - [Example](@ref)
    - [V.2 When should I use combining?](@ref)

        - [Example](@ref)

- [VI. Further operations](@ref)

    - [VI.1 Information about the internal histograms](@ref)
    - [VI.2 Fitting](@ref)
    - [VI.3 Draw a TEfficiency object](@ref)
    - [VI.4 TEfficiency object's axis customisation](@ref)

## I. Overview

This class handles the calculation of efficiencies and their uncertainties. It provides several statistical methods for calculating frequentist and Bayesian confidence intervals as well as a function for combining several efficiencies.

Efficiencies have a lot of applications and meanings but in principle, they can be described by the fraction of good/passed events k out of sample containing N events. One is usually interested in the dependency of the efficiency on other (binned) variables. The number of passed and total events is therefore stored internally in two histograms ([TEfficiency!fTotalHistogram](@ref) and [TEfficiency!fPassedHistogram](@ref)). Then the efficiency, as well as its upper and lower error, can be calculated for each bin individually.

As the efficiency can be regarded as a parameter of a binomial distribution, the number of passed and total events must always be integer numbers. Therefore a filling with weights is not possible. However, you can assign a global_ weight to each [TEfficiency](@ref) object ([TEfficiency!SetWeight](@ref)). It is necessary to create one [TEfficiency](@ref) object for each weight if you investigate a process involving different weights. This procedure needs more effort but enables you to re-use the filled object in cases where you want to change one or more weights. This would not be possible if all events with different weights were filled in the same histogram.

## II. Creating a TEfficiency object

If you thestart a new analysis, it is highly recommended to use the [TEfficiency](@ref) class from the beginning. You can then use one of the constructors for fixed or variable bin size and your desired dimension. These constructors append the created [TEfficiency](@ref) object to the current directory. So it will be written automatically to a file during the next [TFile!Write](@ref) command.

Example: create a two-dimensional [TEfficiency](@ref) object with

- name = "eff"
- title = "my efficiency"
- axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis
- 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge from the first bin) up to 10 (upper edge of last bin)
- 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower edge from the first bin) up to 5 (upper edge of last bin) 
```
  TEfficiency* pEff = new TEfficiency("eff","my efficiency;x;y;#epsilon",10,0,10,20,-5,5);
```  If you already have two histograms filled with the number of passed and total events, you will use the constructor [TEfficiency(const TH1& passed,const TH1& total)](@ref) to construct the [TEfficiency](@ref) object. The histograms "passed" and "total" have to fulfill the conditions mentioned in [TEfficiency!CheckConsistency](@ref), otherwise the construction will fail. As the histograms already exist, the new [TEfficiency](@ref) is by default **not** attached to the current directory to avoid duplication of data. If you want to store the new object anyway, you can either write it directly by calling [TObject!Write](@ref) or attach it to a directory using [TEfficiency!SetDirectory](@ref). This also applies to [TEfficiency](@ref) objects created by the copy constructor [TEfficiency!TEfficiency(const TEfficiency& rEff)](@ref).

### Example 1

    TEfficiency* pEff = 0;
    TFile* pFile = new TFile("myfile.root","recreate");
    //h_pass and h_total are valid and consistent histograms
    if(TEfficiency!CheckConsistency(h_pass,h_total))
    {
      pEff = new TEfficiency(h_pass,h_total);
      // this will write the TEfficiency object to "myfile.root"
      // AND pEff will be attached to the current directory
      pEff->Write();
    }

(C++ version of the code)

### Example 2

    TEfficiency* pEff = 0;
    TFile* pFile = new TFile("myfile.root","recreate");
    //h_pass and h_total are valid and consistent histograms
    if(TEfficiency!CheckConsistency(h_pass,h_total))
    {
      pEff = new TEfficiency(h_pass,h_total);
      //this will attach the TEfficiency object to the current directory
      pEff->SetDirectory(gDirectory);
      //now all objects in gDirectory will be written to "myfile.root"
      pFile->Write();
    }

(C++ version of the code)

In case you already have two filled histograms and you only want to plot them as a graph, you should rather use [TGraphAsymmErrors!TGraphAsymmErrors(const TH1* pass,const TH1* total,Option_t* opt)](@ref) to create a graph object.

## III. Filling with events

You can fill the [TEfficiency](@ref) object by calling the [TEfficiency!Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z)](@ref) method. The "bPassed" boolean flag indicates whether the current event is good (both histograms are filled) or not (only [TEfficiency!fTotalHistogram](@ref) is filled). The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_001.png](https://root.cern/doc/v636/pict1_TEfficiency_001.png)

You can also set the number of passed or total events for a bin directly by using the [TEfficiency!SetPassedEvents](@ref) or [TEfficiency!SetTotalEvents](@ref) method.

## IV. Statistic options

The calculation of the estimated efficiency depends on the chosen statistic option. Let k denotes the number of passed events and N the number of total events.

### Frequentist methods

The expectation value of the number of passed events is given by the true efficiency times the total number of events. One can estimate the efficiency by replacing the expected number of passed events by the observed number of passed events.

``k = \epsilon \times N    \Rightarrow    \hat{\varepsilon} = \frac{k}{N}``

### Bayesian methods

In Bayesian statistics a likelihood-function (how probable is it to get the observed data assuming a true efficiency) and a prior probability (what is the probability that a certain true efficiency is actually realised) are used to determine a posterior probability by using Bayes theorem. At the moment, only beta distributions (with 2 free parameters) are supported as prior probabilities, as explained in D. Casadei, Estimating the selection efficiency, 2012 JINST 7 P08021, [https://doi.org/10.1088/1748-0221/7/08/P08021](https://doi.org/10.1088/1748-0221/7/08/P08021) ([https://arxiv.org/abs/0908.0130](https://arxiv.org/abs/0908.0130)).

\thebegin{eqnarray*}
 P(\epsilon | k ; N) &=& \frac{1}{norm} \times P(k | \epsilon ; N) \times Prior(\epsilon) \\
 P(k | \epsilon ; N) &=& Binomial(N,k) \times \epsilon^{k} \times (1 - \epsilon)^{N - k} ...\  binomial\ distribution \\
 Prior(\epsilon) &=& \frac{1}{B(\alpha,\beta)} \times \epsilon ^{\alpha - 1} \times (1 - \epsilon)^{\beta - 1} \equiv Beta(\epsilon; \alpha,\beta) \\
 \Rightarrow P(\epsilon | k ; N) &=& \frac{1}{norm'} \times \epsilon^{k + \alpha - 1} \times (1 - \epsilon)^{N - k + \beta - 1} \equiv Beta(\epsilon; k + \alpha, N - k + \beta)
\theend{eqnarray*}

By default the expectation value of this posterior distribution is used as an estimator for the efficiency:

``\hat{\varepsilon} = \frac{k + \alpha}{N + \alpha + \beta}``

Optionally the mode can also be used as a value for the estimated efficiency. This can be done by calling SetBit(kPosteriorMode) or [TEfficiency!SetPosteriorMode](@ref). In this case, the estimated efficiency is:

``\hat{\varepsilon} = \frac{k + \alpha -1}{N + \alpha + \beta - 2}``

In the case of a uniform prior distribution, B(x,1,1), the posterior mode is k/n, equivalent to the frequentist estimate (the maximum likelihood value).

The statistic options also specify which confidence interval is used for calculating the uncertainties of the efficiency. The following properties define the error calculation:

- **fConfLevel:** desired confidence level: 0 < fConfLevel < 1 ([TEfficiency!GetConfidenceLevel](@ref) / [TEfficiency!SetConfidenceLevel](@ref))
- **fStatisticOption** defines which method is used to calculate the boundaries of the confidence interval ([TEfficiency!SetStatisticOption](@ref))
- **fBeta_alpha, fBeta_beta:** parameters for the prior distribution which is only used in the bayesian case ([TEfficiency!GetBetaAlpha](@ref) / [TEfficiency!GetBetaBeta](@ref) / [TEfficiency!SetBetaAlpha](@ref) / [TEfficiency!SetBetaBeta](@ref))
- **kIsBayesian:** flag whether bayesian statistics are used or not ([TEfficiency!UsesBayesianStat](@ref))
- **kShortestInterval:** flag whether shortest interval (instead of central one) are used in case of Bayesian statistics ([TEfficiency!UsesShortestInterval](@ref)). Normally shortest interval should be used in combination with the mode (see [TEfficiency!UsesPosteriorMode](@ref))
- **fWeight:** global_ weight for this [TEfficiency](@ref) object which is used during combining or merging with other [TEfficiency](@ref) objects([TEfficiency!GetWeight](@ref) / [TEfficiency!SetWeight](@ref))

In the following table, the implemented confidence intervals are listed with their corresponding statistic option. For more details on the calculation, please have a look at the mentioned functions.

| **name**             | **statistic option** | **function**                       | **kIsBayesian** | **parameters**                                                                     |
|:---------------------|:---------------------|:-----------------------------------|:----------------|:-----------------------------------------------------------------------------------|
| Clopper-Pearson      | kFCP                 | [TEfficiency!ClopperPearson](@ref) | false           | total events, passed events, confidence level                                      |
| normal approximation | kFNormal             | [TEfficiency!Normal](@ref)         | false           | total events, passed events, confidence level                                      |
| Wilson               | kFWilson             | [TEfficiency!Wilson](@ref)         | false           | total events, passed events, confidence level                                      |
| Agresti-Coull        | kFAC                 | [TEfficiency!AgrestiCoull](@ref)   | false           | total events, passed events. confidence level                                      |
| Feldman-Cousins      | kFFC                 | [TEfficiency!FeldmanCousins](@ref) | false           | total events, passed events, confidence level                                      |
| Mid-P Lancaster      | kMidP                | [TEfficiency!MidPInterval](@ref)   | false           | total events, passed events, confidence level                                      |
| Jeffrey              | kBJeffrey            | [TEfficiency!Bayesian](@ref)       | true            | total events, passed events, confidence level, fBeta_alpha = 0.5, fBeta_beta = 0.5 |
| Uniform prior        | kBUniform            | [TEfficiency!Bayesian](@ref)       | true            | total events, passed events, confidence level, fBeta_alpha = 1, fBeta_beta = 1     |
| custom prior         | kBBayesian           | [TEfficiency!Bayesian](@ref)       | true            | total events, passed events, confidence level, fBeta_alpha, fBeta_beta             |

The following example demonstrates the effect of different statistic options and confidence levels.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_002.png](https://root.cern/doc/v636/pict1_TEfficiency_002.png)

The prior probability of the efficiency in Bayesian statistics can be given in terms of a beta distribution. The beta distribution has two positive shape parameters. The resulting priors for different combinations of these shape parameters are shown in the plot below.

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_003.png](https://root.cern/doc/v636/pict1_TEfficiency_003.png)

### IV.1 Coverage probabilities for different methods

The following pictures illustrate the actual coverage probability for the different values of the true efficiency and the total number of events when a confidence level of 95% is desired.

![https://root.cern/doc/v636/normal95.gif](https://root.cern/doc/v636/normal95.gif)

![https://root.cern/doc/v636/wilson95.gif](https://root.cern/doc/v636/wilson95.gif)

![https://root.cern/doc/v636/ac95.gif](https://root.cern/doc/v636/ac95.gif)

![https://root.cern/doc/v636/cp95.gif](https://root.cern/doc/v636/cp95.gif)

![https://root.cern/doc/v636/uni95.gif](https://root.cern/doc/v636/uni95.gif)

![https://root.cern/doc/v636/jeffrey95.gif](https://root.cern/doc/v636/jeffrey95.gif)

The average (over all possible true efficiencies) coverage probability for different number of total events is shown in the next picture.

![https://root.cern/doc/v636/av_cov.png](https://root.cern/doc/v636/av_cov.png)

## V. Merging and combining TEfficiency objects

In many applications, the efficiency should be calculated for an inhomogeneous sample in the sense that it contains events with different weights. In order to be able to determine the correct overall efficiency, it is necessary to use for each subsample (= all events with the same weight) a different [TEfficiency](@ref) object. After finishing your analysis you can then construct the overall efficiency with its uncertainty.

This procedure has the advantage that you can change the weight of one subsample easily without rerunning the whole analysis. On the other hand, more effort is needed to handle several [TEfficiency](@ref) objects instead of one histogram. In the case of many different or even continuously distributed weights, this approach becomes cumbersome. One possibility to overcome this problem is the usage of binned weights.

### Example

In particle physics weights arises from the fact that you want to normalise your results to a certain reference value. A very common formula for calculating weights is

\thebegin{eqnarray*}
   w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\
     &-& \sigma ...\ cross\ section \\
     &-& L ...\ luminosity \\
     &-& N_{gen}\ ... number\ of\ generated\ events \\
     &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\
\theend{eqnarray*}

The reason for different weights can therefore be:

- different processes
- other integrated luminosity
- varying trigger efficiency
- different sample sizes
- ...
- or even combination of them

Depending on the actual meaning of different weights in your case, you should either merge or combine them to get the overall efficiency.

### V.1 When should I use merging?

If the weights are artificial and do not represent real alternative hypotheses, you should merge the different [TEfficiency](@ref) objects. That means especially for the Bayesian case that the prior probability should be the same for all merged [TEfficiency](@ref) objects. The merging can be done by invoking one of the following operations:

- eff1.Add(eff2)
- eff1 += eff2
- eff1 = eff1 + eff2

The result of the merging is stored in the [TEfficiency](@ref) object which is marked bold above. The contents of the internal histograms of both [TEfficiency](@ref) objects are added and a new weight is assigned. The statistic options are not changed.

``\frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}``

### Example:

If you use two samples with different numbers of generated events for the same process and you want to normalise both to the same integrated luminosity and trigger efficiency, the different weights then arise just from the fact that you have different numbers of events. The [TEfficiency](@ref) objects should be merged because the samples do not represent true alternatives. You expect the same result as if you would have a big sample with all events in it.

``w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}``

### V.2 When should I use combining?

You should combine [TEfficiency](@ref) objects whenever the weights represent alternatives processes for the efficiency. As the combination of two [TEfficiency](@ref) objects is not always consistent with the representation by two internal histograms, the result is not stored in a [TEfficiency](@ref) object but a [TGraphAsymmErrors](@ref) is returned which shows the estimated combined efficiency and its uncertainty for each bin. At the moment the combination method [TEfficiency!Combine](@ref) only supports a combination of 1-dimensional efficiencies in a Bayesian approach.

For calculating the combined efficiency and its uncertainty for each bin only Bayesian statistics is used. No frequentists methods are presently supported for computing the combined efficiency and its confidence interval. In the case of the Bayesian statistics, a combined posterior is constructed taking into account the weight of each [TEfficiency](@ref) object. The same prior is used for all the [TEfficiency](@ref) objects.

\thebegin{eqnarray*}
  P_{comb}(\epsilon | {w_{i}}, {k_{i}} , {N_{i}}) = \frac{1}{norm} \prod_{i}{L(k_{i} | N_{i}, \epsilon)}^{w_{i}} \Pi( \epsilon )\\
L(k_{i} | N_{i}, \epsilon)\ is\ the\ likelihood\ function\ for\ the\ sample\ i\ (a\ Binomial\ distribution)\\
\Pi( \epsilon)\ is\ the\ prior,\ a\ beta\ distribution\ B(\epsilon, \alpha, \beta).\\
The\ resulting\ combined\ posterior\ is \\
P_{comb}(\epsilon |{w_{i}}; {k_{i}}; {N_{i}}) = B(\epsilon, \sum_{i}{ w_{i} k_{i}} + \alpha, \sum_{i}{ w_{i}(n_{i}-k_{i})}+\beta) \\
\hat{\varepsilon} = \int_{0}^{1} \epsilon \times P_{comb}(\epsilon | {k_{i}} , {N_{i}}) d\epsilon \\
confidence\ level = 1 - \alpha \\
\frac{\alpha}{2} = \int_{0}^{\epsilon_{low}} P_{comb}(\epsilon | {k_{i}} , {N_{i}}) d\epsilon ...\ defines\ lower\ boundary \\
1- \frac{\alpha}{2} = \int_{0}^{\epsilon_{up}} P_{comb}(\epsilon | {k_{i}} , {N_{i}}) d\epsilon ...\ defines\ upper\ boundary
\theend{eqnarray*}

### Example:

If you use cuts to select electrons which can originate from two different processes, you can determine the selection efficiency for each process. The overall selection efficiency is then the combined efficiency. The weights to be used in the combination should be the probability that an electron comes from the corresponding process.

``p_{1} = \frac{\sigma_{1}}{\sigma_{1} + \sigma_{2}} = \frac{N_{1}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\
p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}``

## VI. Further operations

### VI.1 Information about the internal histograms

The methods [TEfficiency!GetPassedHistogram](@ref) and [TEfficiency!GetTotalHistogram](@ref) return a constant pointer to the internal histograms. They can be used to obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...). One can obtain a clone of the internal histograms by calling [TEfficiency!GetCopyPassedHisto](@ref) or [TEfficiency!GetCopyTotalHisto](@ref). The returned histograms are completely independent from the current [TEfficiency](@ref) object. By default, they are not attached to a directory to avoid the duplication of data and the user is responsible for deleting them.

    //open a root file which contains a TEfficiency object
    TFile* pFile = new TFile("myfile.root","update");
    //get TEfficiency object with name "my_eff"
    TEfficiency* pEff = (TEfficiency*)pFile->Get("my_eff");
    //get clone of total histogram
    TH1* clone = pEff->GetCopyTotalHisto();
    //change clone...
    //save changes of clone directly
    clone->Write();
    //or append it to the current directory and write the file
    //clone->SetDirectory(gDirectory);
    //pFile->Write();
    //delete histogram object
    delete clone;
    clone = 0;

(C++ version of the code)

It is also possible to set the internal total or passed histogram by using the methods [TEfficiency!SetPassedHistogram](@ref) or [TEfficiency!SetTotalHistogram](@ref).

In order to ensure the validity of the [TEfficiency](@ref) object, the consistency of the new histogram and the stored histogram is checked. It might be impossible sometimes to change the histograms in a consistent way. Therefore one can force the replacement by passing the "f" option. Then the user has to ensure that the other internal histogram is replaced as well and that the [TEfficiency](@ref) object is in a valid state.

### VI.2 Fitting

The efficiency can be fitted using the [TEfficiency!Fit](@ref) function which internally uses the [TBinomialEfficiencyFitter!Fit](@ref) method. As this method is using a maximum-likelihood-fit, it is necessary to initialise the given fit function with reasonable thestart values. The resulting fit function is attached to the list of associated functions and will be drawn automatically during the next [TEfficiency!Draw](@ref) command. The list of associated function can be modified by using the pointer returned by [TEfficiency!GetListOfFunctions](@ref).

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_004.png](https://root.cern/doc/v636/pict1_TEfficiency_004.png)

### VI.3 Draw a TEfficiency object

A [TEfficiency](@ref) object can be drawn by calling the usual [TEfficiency!Draw](@ref) method. At the moment drawing is only supported for 1- and 2-dimensional [TEfficiency](@ref) objects. In the 1-dimensional case, you can use the same options as for the [TGraphAsymmErrors!Draw](@ref) method. For 2-dimensional [TEfficiency](@ref) objects, you can pass the same options as for a [TH2!Draw](@ref) object.

### VI.4 TEfficiency object's axis customisation

The axes of a [TEfficiency](@ref) object can be accessed and customised by calling the GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding [TAxis](@ref) methods. Note that in order to access the painted graph via [GetPaintedGraph()](@ref), one should either call Paint or, better, gPad->Update().

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_005.png](https://root.cern/doc/v636/pict1_TEfficiency_005.png)

Related functions: [`Add`](@ref), [`Browse`](@ref), [`CreateGraph2D`](@ref), [`CreateGraph`](@ref), [`CreateHistogram`](@ref), [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`FillWeighted`](@ref), [`Fill`](@ref), [`FindFixBin`](@ref), [`Fit`](@ref), [`GetBetaAlpha`](@ref), [`GetBetaBeta`](@ref), [`GetConfidenceLevel`](@ref), [`GetCopyPassedHisto`](@ref), [`GetCopyTotalHisto`](@ref), [`GetDimension`](@ref), [`GetDirectory`](@ref), [`GetEfficiencyErrorLow`](@ref), [`GetEfficiencyErrorUp`](@ref), [`GetEfficiency`](@ref), [`GetGlobalBin`](@ref), [`GetListOfFunctions`](@ref), [`GetPaintedGraph2D`](@ref), [`GetPaintedGraph`](@ref), [`GetPaintedHistogram`](@ref), [`GetPassedHistogram`](@ref), [`GetStatisticOption`](@ref), [`GetTotalHistogram`](@ref), [`GetWeight`](@ref), [`Merge`](@ref), [`Paint`](@ref), [`RecursiveRemove`](@ref), [`SavePrimitive`](@ref), [`SetBetaAlpha`](@ref), [`SetBetaBeta`](@ref), [`SetBetaBinParameters`](@ref), [`SetBins`](@ref), [`SetCentralInterval`](@ref), [`SetConfidenceLevel`](@ref), [`SetDirectory`](@ref), [`SetName`](@ref), [`SetPassedEvents`](@ref), [`SetPassedHistogram`](@ref), [`SetPosteriorAverage`](@ref), [`SetPosteriorMode`](@ref), [`SetShortestInterval`](@ref), [`SetStatisticOption`](@ref), [`SetTitle`](@ref), [`SetTotalEvents`](@ref), [`SetTotalHistogram`](@ref), [`SetUseWeightedEvents`](@ref), [`SetWeight`](@ref), [`TEfficiency!AgrestiCoull`](@ref), [`TEfficiency!Bayesian`](@ref), [`TEfficiency!BetaCentralInterval`](@ref), [`TEfficiency!BetaMean`](@ref), [`TEfficiency!BetaMode`](@ref), [`TEfficiency!BetaShortestInterval`](@ref), [`TEfficiency!CheckBinning`](@ref), [`TEfficiency!CheckConsistency`](@ref), [`TEfficiency!CheckEntries`](@ref), [`TEfficiency!CheckWeights`](@ref), [`TEfficiency!ClopperPearson`](@ref), [`TEfficiency!Combine`](@ref), [`TEfficiency!FeldmanCousinsInterval`](@ref), [`TEfficiency!FeldmanCousins`](@ref), [`TEfficiency!MidPInterval`](@ref), [`TEfficiency!Normal`](@ref), [`TEfficiency!Wilson`](@ref), [`TEfficiency`](@ref), [`UsesBayesianStat`](@ref), [`UsesCentralInterval`](@ref), [`UsesPosteriorAverage`](@ref), [`UsesPosteriorMode`](@ref), [`UsesShortestInterval`](@ref), [`UsesWeights`](@ref), [`add!`](@ref), [`assign`](@ref)
""" TEfficiency

# Wrapper of TGraphAsymmErrors
@trydoc raw"""
    ROOT.TGraphAsymmErrors

[TGraph](@ref) with asymmetric error bars.

The [TGraphAsymmErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphAsymmErrors_001.png](https://root.cern/doc/v636/pict1_TGraphAsymmErrors_001.png)

Related functions: [`AddPointError`](@ref), [`Apply`](@ref), [`BayesDivide`](@ref), [`ComputeRange`](@ref), [`Divide`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`Merge`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointEXhigh`](@ref), [`SetPointEXlow`](@ref), [`SetPointEYhigh`](@ref), [`SetPointEYlow`](@ref), [`SetPointError`](@ref), [`TGraphAsymmErrors`](@ref), [`assign`](@ref)
""" TGraphAsymmErrors

# Wrapper of TGraph2DAsymmErrors
@trydoc raw"""
    ROOT.TGraph2DAsymmErrors

Graph 2D class with errors.

A [TGraph2DAsymmErrors](@ref) is a [TGraph2D](@ref) with asymmetric errors. It behaves like a [TGraph2D](@ref) and has the same drawing options.

The **"ERR"** drawing option allows to display the error bars. The following example shows how to use it:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2DAsymmErrors_001.png](https://root.cern/doc/v636/pict1_TGraph2DAsymmErrors_001.png)

Related functions: [`AddPointError`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetEZhigh`](@ref), [`GetEZlow`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`GetErrorZ`](@ref), [`GetErrorZhigh`](@ref), [`GetErrorZlow`](@ref), [`GetXmaxE`](@ref), [`GetXminE`](@ref), [`GetYmaxE`](@ref), [`GetYminE`](@ref), [`GetZmaxE`](@ref), [`GetZminE`](@ref), [`Print`](@ref), [`RemovePoint`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`SetPoint`](@ref), [`Set`](@ref), [`TGraph2DAsymmErrors`](@ref), [`assign`](@ref)
""" TGraph2DAsymmErrors

# Wrapper of TH2
@trydoc raw"""
    ROOT.TH2

Service class for 2-D histogram classes.

- [TH2C](@ref) a 2-D histogram with one byte per cell (char). Maximum bin content = 127
- [TH2S](@ref) a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767
- [TH2I](@ref) a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX ([*](@ref))
- [TH2L](@ref) a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX ([**](@ref))
- [TH2F](@ref) a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
- [TH2D](@ref) a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))

<sup> (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br/>
 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760) </sup>

Related functions: [`AddBinContent`](@ref), [`BufferEmpty`](@ref), [`Copy`](@ref), [`FillN`](@ref), [`FillRandom`](@ref), [`Fill`](@ref), [`FitSlicesX`](@ref), [`FitSlicesY`](@ref), [`GetBinContent`](@ref), [`GetBinErrorLow`](@ref), [`GetBinErrorUp`](@ref), [`GetBinWithContent2`](@ref), [`GetBin`](@ref), [`GetCorrelationFactor`](@ref), [`GetCovariance`](@ref), [`GetRandom2`](@ref), [`GetStats`](@ref), [`IntegralAndError`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`KolmogorovTest`](@ref), [`ProfileX`](@ref), [`ProfileY`](@ref), [`ProjectionX`](@ref), [`ProjectionY`](@ref), [`PutStats`](@ref), [`QuantilesX`](@ref), [`QuantilesY`](@ref), [`Rebin2D`](@ref), [`RebinX`](@ref), [`RebinY`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetShowProjectionXY`](@ref), [`SetShowProjectionX`](@ref), [`SetShowProjectionY`](@ref), [`ShowBackground`](@ref), [`ShowPeaks`](@ref), [`Smooth`](@ref)
""" TH2

# Wrapper of TFormula
@trydoc raw"""
    ROOT.TFormula

The Formula class.

This is a new version of the [TFormula](@ref) class based on Cling. This class is not 100% backward compatible with the old [TFormula](@ref) class, which is still available in [ROOT](@ref) as `ROOT!v5!TFormula`. Some of the [TFormula](@ref) member functions available in version 5, such as `Analyze` and `AnalyzeFunction` are not available in the new [TFormula](@ref). On the other hand formula expressions which were valid in version 5 are still valid in [TFormula](@ref) version 6

This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.

### Example of valid expressions:

- `sin(x)/x`
- `[0]*sin(x) + [1]*exp(-[2]*x)`
- `x + y**2`
- `x^2 + y^2`
- `[0]*pow([1],4)`
- `2*pi*sqrt(x/y)`
- `gaus(0)*expo(3) + ypol3(5)*x`
- `gausn(0)*expo(3) + ypol3(5)*x`
- `gaus(x, [0..2]) + expo(y, [3..4])`

In the last examples above:

- `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)` and (0) means thestart numbering parameters at 0
- `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))` and (0) means thestart numbering parameters at 0
- `expo(3)` is a substitute for `exp([3]+[4]*x)`
- `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3` (`PolN` stands for Polynomial of degree N)
- `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`
- `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`

See below the [full list of predefined functions](@ref) which can be used as shortcuts in [TFormula](@ref).

`TMath` functions can be part of the expression, eg:

- `TMath!Landau(x)*sin(x)`
- `TMath!Erf(x)`

Formula may contain constants, eg:

- `sqrt2`
- `e`
- `pi`
- `ln10`
- `infinity`

and more.

Formulas may also contain other user-defined [ROOT](@ref) functions defined with a [TFormula](@ref), eg, where `f1` is defined on one x-dimension and 2 parameters:

- `f1(x, [omega], [phi])`
- `f1([0..1])`
- `f1([1], [0])`
- `f1(y)`

To replace only parameter names, the dimension variable can be dropped. Alternatively, to change only the dimension variable, the parameters can be dropped. Note that if a parameter is dropped or keeps its old name, its old value will be copied to the new function. The syntax used in the examples above also applies to the predefined parametrized functions like `gaus` and `expo`.

Comparisons operators are also supported `(&&, ||, ==, <=, >=, !)`

Examples:

`sin(x*(x<0.5 || x>1))`

If the result of a comparison is TRUE, the result is 1, otherwise 0.

Already predefined names can be given. For example, if the formula

`TFormula old("old",sin(x*(x<0.5 || x>1)))`

one can assign a name to the formula. By default the name of the object = title = formula itself.

`TFormula new("new","x*old")`

is equivalent to:

`TFormula new("new","x*sin(x*(x&lt;0.5 || x&gt;1))")`

The class supports unlimited number of variables and parameters. By default the names which can be used for the variables are `x,y,z,t` or `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.

This class is not anymore the base class for the function classes `TF1`, but it has now a data member of [TF1](@ref) which can be accessed via `TF1!GetFormula`.

[TFormula](@ref) supports gradient and hessian calculations through clad. To calculate the gradient one needs to first declare a `CladStorage` of the same size as the number of parameters and then pass the variables and the created `CladStorage`:

    TFormula f("f", "x*[0] - y*[1]");
    Double_t p[] = {40, 30};
    Double_t x[] = {1, 2};
    f.SetParameters(p);
    TFormula!CladStorage grad(2);
    f.GradientPar(x, grad);

(C++ version of the code)

The process is similar for hessians, except that the size of the created CladStorage should be the square of the number of parameters because `HessianPar` returns a flattened matrix:

    TFormula!CladStorage hess(4);
    f.HessianPar(x, hess);

(C++ version of the code)

### List of predefined functions

The list of available predefined functions which can be used as shortcuts is the following:

1. One Dimensional functions:

    - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x-[Mean])/[Sigma]))`
    - `landau` is a substitute for `[Constant]*TMath!Landau (x,[MPV],[Sigma],false)`
    - `expo` is a substitute for `exp([Constant]+[Slope]*x)`
    - `crystalball` is substitute for `[Constant]*ROOT!Math!crystalball_function (x,[Alpha],[N],[Sigma],[Mean])`
    - `breitwigner` is a substitute for `[p0]*ROOT!Math!breitwigner_pdf (x,[p2],[p1])`
    - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` : `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`
    - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`: `ROOT!Math!Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.
2. Two Dimensional functions:

    - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.
    - `bigaus` is a substitute for `[Constant]*ROOT!Math!bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.
3. Three Dimensional functions:

    - `xyzgaus` is for a 3d Gaussians without correlations: `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`

### An expanded note on variables and parameters

In a [TFormula](@ref), a variable is a defined by a name `x`, `y`, `z` or `t` or an index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.

    TFormula("", "x[0] * x[1] + 10")

(C++ version of the code)

Parameters are similar and can take any name. It is specified using brackets e.g. `[expected_mass]` or `[0]`.

    TFormula("", "exp([expected_mass])-1")

(C++ version of the code)

Variables and parameters can be combined in the same [TFormula](@ref). Here we consider a very simple case where we have an exponential decay after some time t and a number of events with timestamps for which we want to evaluate this function.

    TFormula tf ("", "[0]*exp(-[1]*t)");
    tf.SetParameter(0, 1);
    tf.SetParameter(1, 0.5);
    for (auto & event : events) {
       tf.Eval(event.t);
    }

(C++ version of the code)

The distinction between variables and parameters arose from the [TFormula](@ref)'s application in fitting. There parameters are fitted to the data provided through variables. In other applications this distinction can go away.

Parameter values can be provided dynamically using `TFormula!EvalPar` instead of `TFormula!Eval`. In this way parameters can be used identically to variables. See below for an example that uses only parameters to model a function.

    Int_t params[2] = {1, 2}; // {vel_x, vel_y}
    TFormula tf ("", "[vel_x]/sqrt(([vel_x + vel_y])**2)");
    tf.EvalPar(nullptr, params);

(C++ version of the code)

### A note on operators

All operators of C/C++ are allowed in a [TFormula](@ref) with a few caveats.

The operators `|`, `&`, `%` can be used but will raise an error if used in conjunction with a variable or a parameter. Variables and parameters are treated as doubles internally for which these operators are not defined. This means the following command will run successfully `root -l -q -e TFormula("", "x+(10%3)").Eval(0)` but not `root -l -q -e TFormula("", "x%10").Eval(0)`.

The operator `^` is defined to mean exponentiation instead of the C/C++ interpretation xor. `**` is added, also meaning exponentiation.

The operators `++` and `@` are added, and are shorthand for the a linear function. That means the expression `x@2` will be expanded to `[n]*x + [n+1]*2` where n is the first previously unused parameter number.

Related functions: [`AddParameter`](@ref), [`AddVariable`](@ref), [`AddVariables`](@ref), [`Clear`](@ref), [`Compile`](@ref), [`Copy`](@ref), [`EvalPar`](@ref), [`Eval`](@ref), [`GenerateGradientPar`](@ref), [`GenerateHessianPar`](@ref), [`GetExpFormula`](@ref), [`GetGradientFormula`](@ref), [`GetHessianFormula`](@ref), [`GetLinearPart`](@ref), [`GetNdim`](@ref), [`GetNpar`](@ref), [`GetNumber`](@ref), [`GetParName`](@ref), [`GetParNumber`](@ref), [`GetParameter`](@ref), [`GetParameters`](@ref), [`GetUniqueFuncName`](@ref), [`GetVarName`](@ref), [`GetVarNumber`](@ref), [`GetVariable`](@ref), [`GradientPar`](@ref), [`HasGeneratedGradient`](@ref), [`HasGeneratedHessian`](@ref), [`HessianPar`](@ref), [`IsLinear`](@ref), [`IsValid`](@ref), [`IsVectorized`](@ref), [`Print`](@ref), [`SetName`](@ref), [`SetParName`](@ref), [`SetParNames`](@ref), [`SetParameter`](@ref), [`SetParameters`](@ref), [`SetVariable`](@ref), [`SetVariables`](@ref), [`SetVectorized`](@ref), [`TFormula!IsScientificNotation`](@ref), [`TFormula`](@ref), [`assign`](@ref)
""" TFormula

# Wrapper of TFormulaFunction
@trydoc raw"""
    ROOT.TFormulaFunction

Helper class for [TFormula](@ref).



Related functions: [`Base.:(<)`](@ref), [`Base.:(==)`](@ref), [`GetBody`](@ref), [`GetName`](@ref), [`GetNargs`](@ref), [`IsFuncCall`](@ref), [`TFormulaFunction`](@ref)
""" TFormulaFunction

# Wrapper of TFormulaVariable
@trydoc raw"""
    ROOT.TFormulaVariable

Another helper class for [TFormula](@ref).



Related functions: [`Base.:(<)`](@ref), [`GetArrayPos`](@ref), [`GetInitialValue`](@ref), [`GetName`](@ref), [`TFormulaVariable`](@ref)
""" TFormulaVariable

# Wrapper of TF1AbsComposition
@trydoc raw"""
    ROOT.TF1AbsComposition





Related functions: [`ClassDefOverride`](@ref), [`Copy`](@ref), [`SetParameters`](@ref), [`SetRange`](@ref), [`Update`](@ref), [`paren`](@ref)
""" TF1AbsComposition

# Wrapper of TF1Parameters
@trydoc raw"""
    ROOT.TF1Parameters

[TF1](@ref) Parameters class.



Related functions: [`GetParName`](@ref), [`GetParNumber`](@ref), [`GetParameter`](@ref), [`GetParameters`](@ref), [`ParamsVec`](@ref), [`SetParName`](@ref), [`SetParNames`](@ref), [`SetParameter`](@ref), [`SetParameters`](@ref), [`TF1Parameters`](@ref), [`assign`](@ref)
""" TF1Parameters

# Wrapper of TF2
@trydoc raw"""
    ROOT.TF2

A 2-Dim function with parameters.

The following types of functions can be created:

1. [Expression using variables x and y](@ref)
2. [Expression using a user defined function](@ref)
3. [Lambda Expression with x and y variables and parameters](@ref)

### Expression using variables x and y

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF2_001.png](https://root.cern/doc/v636/pict1_TF2_001.png)

### Expression using a user defined function

    Double_t func(Double_t *val, Double_t *par)
    {
       Float_t x = val[0];
       Float_t y = val[1];
       Double_t f = x*x-y*y;
       return f;
    }
    void fplot()
    {
       auto f = new TF2("f",func,-1,1,-1,1);
       f->Draw("surf1");
    }

(C++ version of the code)

### Lambda Expression with x and y variables and parameters

    root [0] TF2 f2("f2", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1)
    (TF2 &) Name: f2 Title: f2
    root [1] f2.SetParameter(0, 1.)
    root [2] f2.Eval(1., 2.)
    (double) 3.0000000

(C++ version of the code)

See [TF1](@ref) class for the list of functions formats

Related functions: [`CentralMoment2`](@ref), [`Copy`](@ref), [`Covariance2XY`](@ref), [`CreateHistogram`](@ref), [`DistancetoPrimitive`](@ref), [`DrawCopy`](@ref), [`DrawDerivative`](@ref), [`DrawIntegral`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetContourLevel`](@ref), [`GetContour`](@ref), [`GetMaximumXY`](@ref), [`GetMaximum`](@ref), [`GetMinimumXY`](@ref), [`GetMinimum`](@ref), [`GetNpy`](@ref), [`GetObjectInfo`](@ref), [`GetRandom2`](@ref), [`GetRandom`](@ref), [`GetRange`](@ref), [`GetSave`](@ref), [`GetYmax`](@ref), [`GetYmin`](@ref), [`Integral`](@ref), [`IsInside`](@ref), [`Mean2X`](@ref), [`Mean2Y`](@ref), [`Moment2`](@ref), [`Paint`](@ref), [`SavePrimitive`](@ref), [`Save`](@ref), [`SetContourLevel`](@ref), [`SetContour`](@ref), [`SetNpy`](@ref), [`SetRange`](@ref), [`SetSavedPoint`](@ref), [`TF2`](@ref), [`Variance2X`](@ref), [`Variance2Y`](@ref), [`assign`](@ref)
""" TF2

# Wrapper of TF12
@trydoc raw"""
    ROOT.TF12

A projection of a [TF2](@ref) along X or Y.

It has the same behaviour as a [TF1](@ref)

Example of a function

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TF12_001.png](https://root.cern/doc/v636/pict1_TF12_001.png)

Related functions: [`Copy`](@ref), [`DrawCopy`](@ref), [`EvalPar`](@ref), [`Eval`](@ref), [`GetXY`](@ref), [`SavePrimitive`](@ref), [`SetXY`](@ref), [`TF12`](@ref)
""" TF12

# Wrapper of TSpline
@trydoc raw"""
    ROOT.TSpline

Base class for spline implementation containing the Draw/Paint methods.



Related functions: [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`Eval`](@ref), [`ExecuteEvent`](@ref), [`GetDelta`](@ref), [`GetHistogram`](@ref), [`GetKnot`](@ref), [`GetNp`](@ref), [`GetNpx`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`Paint`](@ref), [`SaveAs`](@ref), [`SetNpx`](@ref), [`TSpline`](@ref)
""" TSpline

# Wrapper of TH1F
@trydoc raw"""
    ROOT.TH1F

1-D histogram with a float per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1F`](@ref), [`assign`](@ref)
""" TH1F

# Wrapper of TF1Convolution
@trydoc raw"""
    ROOT.TF1Convolution

Class wrapping convolution of two functions.

Class wrapping convolution of two functions: evaluation of $\int f(x)g(x-t)dx$

The convolution is performed by default using FFTW if it is available . One can pass optionally the range of the convolution (by default the first function range is used). Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be approximately zero at the theend of the range. If they are significantly different than zero on one side (e.g. the left side) a spill over will occur on the other side (e.g right side). If no function range is given by default the function1 range + 10% is used One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.

Related functions: [`ClassDefOverride`](@ref), [`Copy`](@ref), [`GetNpar`](@ref), [`GetParName`](@ref), [`GetRange`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`SetExtraRange`](@ref), [`SetNofPointsFFT`](@ref), [`SetNumConv`](@ref), [`SetParameters`](@ref), [`SetRange`](@ref), [`TF1Convolution!SetDefaultExtraRange`](@ref), [`TF1Convolution`](@ref), [`Update`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TF1Convolution

# Wrapper of TF1NormSum
@trydoc raw"""
    ROOT.TF1NormSum

Class adding two functions: c1*f1+c2*f2.



Related functions: [`ClassDefOverride`](@ref), [`Copy`](@ref), [`GetNpar`](@ref), [`GetParName`](@ref), [`GetParameters`](@ref), [`GetRange`](@ref), [`GetScale`](@ref), [`GetXmax`](@ref), [`GetXmin`](@ref), [`SetParameters`](@ref), [`SetRange`](@ref), [`SetScale`](@ref), [`TF1NormSum`](@ref), [`Update`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TF1NormSum

# Wrapper of TF3
@trydoc raw"""
    ROOT.TF3

A 3-Dim function with parameters.



Related functions: [`CentralMoment3`](@ref), [`Copy`](@ref), [`Covariance3XY`](@ref), [`Covariance3XZ`](@ref), [`Covariance3YZ`](@ref), [`CreateHistogram`](@ref), [`DistancetoPrimitive`](@ref), [`DrawDerivative`](@ref), [`DrawIntegral`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetClippingBoxOn`](@ref), [`GetClippingBox`](@ref), [`GetMaximumXYZ`](@ref), [`GetMinimumXYZ`](@ref), [`GetNpz`](@ref), [`GetRandom3`](@ref), [`GetRange`](@ref), [`GetSave`](@ref), [`GetZmax`](@ref), [`GetZmin`](@ref), [`Integral`](@ref), [`IsInside`](@ref), [`Mean3X`](@ref), [`Mean3Y`](@ref), [`Mean3Z`](@ref), [`Moment3`](@ref), [`Paint`](@ref), [`SavePrimitive`](@ref), [`Save`](@ref), [`SetClippingBoxOff`](@ref), [`SetClippingBoxOn`](@ref), [`SetNpz`](@ref), [`SetRange`](@ref), [`TF3`](@ref), [`Variance3X`](@ref), [`Variance3Y`](@ref), [`Variance3Z`](@ref), [`assign`](@ref)
""" TF3

# Wrapper of TFractionFitter
@trydoc raw"""
    ROOT.TFractionFitter

Fits MC fractions to data histogram.

A la HMCMLL, see R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228, and [http://www.hep.man.ac.uk/~roger/hfrac.f](http://www.hep.man.ac.uk/~roger/hfrac.f)

The virtue of this fit is that it takes into account both data and Monte Carlo statistical uncertainties. The way in which this is done is through a standard likelihood fit using Poisson statistics; however, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimisation with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content. For more details please see the original publication cited above.

An example application of this fit is given below. For a TH1* histogram ("data") fitted as the sum of three Monte Carlo sources ("mc"):

    {
      TH1F *data;                              //data histogram
      TH1F *mc0;                               // first MC histogram
      TH1F *mc1;                               // second MC histogram
      TH1F *mc2;                               // third MC histogram
      ....                                     // retrieve histograms
       TObjArray *mc = new TObjArray(3);        // MC histograms are put in this array
       mc->Add(mc0);
       mc->Add(mc1);
       mc->Add(mc2);
       TFractionFitter* fit = new TFractionFitter(data, mc); // initialise
       fit->Constrain(1,0.0,1.0);               // constrain fraction 1 to be between 0 and 1
       fit->SetRangeX(1,15);                    // use only the first 15 bins in the fit
       Int_t status = fit->Fit();               // perform the fit
       std!cout << "fit status: " << status << std!endl;
       if (status == 0) {                       // check on fit status
         TH1F* result = (TH1F*) fit->GetPlot();
         data->Draw("Ep");
         result->Draw("same");
       }
    }

(C++ version of the code)

## Assumptions

A few assumptions need to be made for the fit procedure to be carried out: 1 The total number of events in each template is not too small (so that its Poisson uncertainty can be neglected). 2 The number of events in each bin is much smaller than the total number of events in each template (so that multinomial uncertainties can be replaced with Poisson uncertainties).

Biased fit uncertainties may result if these conditions are not fulfilled (see e.g. arXiv:0803.2711).

## Instantiation

A fit object is instantiated through TFractionFitter* fit = new [TFractionFitter(data, mc)](@ref); A number of basic checks (intended to ensure that the template histograms represent the same "kind" of distribution as the data one) are carried out. The [TVirtualFitter](@ref) object is then addressed and all fit parameters (the template fractions) declared (initially unbounded).

## Applying constraints

Fit parameters can be constrained through

fit->Constrain(parameter #, lower bound, upper bound);

Setting lower bound = upper bound = 0 removes the constraint (a la Minuit); however, a function 
```
fit->Unconstrain(parameter #)
```  is also provided to simplify this.

## Setting parameter values

The function 
```
ROOT!Fit!Fitter* fitter = fit->GetFitter();
```  is provided for direct access to the [ROOT!Fit!Fitter](@ref) object. This allows to set and fix parameter values, limits and set step sizes directly via 
```
fitter->Config().ParSettings(parameter #).Set(const std!string &name, double value, double step, double lower, double upper);
```  

## Restricting the fit range

The fit range can be restricted through 
```
fit->SetRangeX(first bin #, last bin #);
```  and freed using 
```
fit->ReleaseRangeX();
```  For 2D histograms the Y range can be similarly restricted using 
```
fit->SetRangeY(first bin #, last bin #);
fit->ReleaseRangeY();
```  and for 3D histograms also 
```
fit->SetRangeZ(first bin #, last bin #);
fit->ReleaseRangeZ();
```  It is also possible to exclude individual bins from the fit through 
```
fit->ExcludeBin(bin #);
```  where the given bin number is assumed to follow the [TH1!GetBin()](@ref) numbering. Any bins excluded in this way can be included again using the corresponding 
```
fit->IncludeBin(bin #);
```  

## Weights histograms

Weights histograms (for a motivation see the above publication) can be specified for the individual MC sources through 
```
fit->SetWeight(parameter #, pointer to weights histogram);
```  and unset by specifying a null pointer.

## Obtaining fit results

The fit is carried out through 
```
Int_t status = fit->Fit();
```  where status is the code returned from the "MINIMIZE" command. For fits that converged, parameter values and errors can be obtained through 
```
fit->GetResult(parameter #, value, error);
```  and the histogram corresponding to the total Monte Carlo prediction (which is not the same as a simple weighted sum of the input Monte Carlo distributions) can be obtained by 
```
TH1* result = fit->GetPlot();
```  

## Using different histograms

It is possible to change the histogram being fitted through 
```
fit->SetData(TH1* data);
```  and to change the template histogram for a given parameter number through 
```
fit->SetMC(parameter #, TH1* MC);
```  This can speed up code in case of multiple data or template histograms; however, it should be done with care as any settings are taken over from the previous fit. In addition, neither the dimensionality nor the numbers of bins of the histograms should change (in that case it is better to instantiate a new [TFractionFitter](@ref) object).

## Errors

Any serious inconsistency results in an error.

Related functions: [`Constrain`](@ref), [`ErrorAnalysis`](@ref), [`EvaluateFCN`](@ref), [`ExcludeBin`](@ref), [`Fit`](@ref), [`GetChisquare`](@ref), [`GetFitter`](@ref), [`GetMCPrediction`](@ref), [`GetNDF`](@ref), [`GetPlot`](@ref), [`GetProb`](@ref), [`GetResult`](@ref), [`IncludeBin`](@ref), [`ReleaseRangeX`](@ref), [`ReleaseRangeY`](@ref), [`ReleaseRangeZ`](@ref), [`SetData`](@ref), [`SetMC`](@ref), [`SetRangeX`](@ref), [`SetRangeY`](@ref), [`SetRangeZ`](@ref), [`SetWeight`](@ref), [`TFractionFitter`](@ref), [`UnConstrain`](@ref)
""" TFractionFitter

# Wrapper of TH2D
@trydoc raw"""
    ROOT.TH2D

2-D histogram with a double per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2D`](@ref), [`assign`](@ref)
""" TH2D

# Wrapper of TGraph2DErrors
@trydoc raw"""
    ROOT.TGraph2DErrors

Graph 2D class with errors.

A [TGraph2DErrors](@ref) is a [TGraph2D](@ref) with errors. It behaves like a [TGraph2D](@ref) and has the same drawing options.

The **"ERR"** drawing option allows to display the error bars. The following example shows how to use it:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraph2DErrors_001.png](https://root.cern/doc/v636/pict1_TGraph2DErrors_001.png)

Related functions: [`AddPointError`](@ref), [`GetEX`](@ref), [`GetEY`](@ref), [`GetEZ`](@ref), [`GetErrorX`](@ref), [`GetErrorY`](@ref), [`GetErrorZ`](@ref), [`GetXmaxE`](@ref), [`GetXminE`](@ref), [`GetYmaxE`](@ref), [`GetYminE`](@ref), [`GetZmaxE`](@ref), [`GetZminE`](@ref), [`Print`](@ref), [`RemovePoint`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`SetPoint`](@ref), [`Set`](@ref), [`TGraph2DErrors`](@ref), [`assign`](@ref)
""" TGraph2DErrors

# Wrapper of TGraphBentErrors
@trydoc raw"""
    ROOT.TGraphBentErrors

A [TGraphBentErrors](@ref) is a [TGraph](@ref) with bent, asymmetric error bars.

The [TGraphBentErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphBentErrors_001.png](https://root.cern/doc/v636/pict1_TGraphBentErrors_001.png)

Related functions: [`AddPointError`](@ref), [`Apply`](@ref), [`ComputeRange`](@ref), [`GetEXhigh`](@ref), [`GetEXhighd`](@ref), [`GetEXlow`](@ref), [`GetEXlowd`](@ref), [`GetEYhigh`](@ref), [`GetEYhighd`](@ref), [`GetEYlow`](@ref), [`GetEYlowd`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetPointError`](@ref), [`TGraphBentErrors`](@ref)
""" TGraphBentErrors

# Wrapper of TGraphDelaunay
@trydoc raw"""
    ROOT.TGraphDelaunay

[TGraphDelaunay](@ref) generates a Delaunay triangulation of a [TGraph2D](@ref).

This triangulation code derives from an implementation done by Luke Jones (Royal Holloway, University of London) in April 2002 in the PAW context.

This software cannot be guaranteed to work under all circumstances. They were originally written to work with a few hundred points in an XY space with similar X and Y ranges.

Definition of Delaunay triangulation (After B. Delaunay): For a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circumcircle of any triangle in DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of points in S, the Voronoi diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exactly one point and every point in a given polygon is closer to its central point than to any other. A Voronoi diagram is sometimes also known as a Dirichlet tessellation.

![https://root.cern/doc/v636/tgraph2d_delaunay.png](https://root.cern/doc/v636/tgraph2d_delaunay.png)

[This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html) gives a nice practical view of Delaunay triangulation and Voronoi diagram.

Related functions: [`ComputeZ`](@ref), [`FindAllTriangles`](@ref), [`GetGraph2D`](@ref), [`GetMTried`](@ref), [`GetMarginBinsContent`](@ref), [`GetNTried`](@ref), [`GetNdt`](@ref), [`GetPTried`](@ref), [`GetXN`](@ref), [`GetXNmax`](@ref), [`GetXNmin`](@ref), [`GetYN`](@ref), [`GetYNmax`](@ref), [`GetYNmin`](@ref), [`Interpolate`](@ref), [`SetMarginBinsContent`](@ref), [`SetMaxIter`](@ref), [`TGraphDelaunay`](@ref)
""" TGraphDelaunay

# Wrapper of TGraphDelaunay2D
@trydoc raw"""
    ROOT.TGraphDelaunay2D

[TGraphDelaunay2D](@ref) generates a Delaunay triangulation of a [TGraph2D](@ref).

The algorithm used for finding the triangles is based on [CDT](https://github.com/artem-ogre/CDT), a C++ library for generating constraint or conforming Delaunay triangulations.

The [ROOT!Math!Delaunay2D](@ref) class provides a wrapper for using the **CDT** library.

This implementation provides large improvements in terms of computational performances compared to the legacy one available in [TGraphDelaunay](@ref), and it is by default used in [TGraph2D](@ref). The old, legacy implementation can be still used when calling `TGraph2D!GetHistogram` and `TGraph2D!Draw` with the `old` option.

Definition of Delaunay triangulation (After B. Delaunay): For a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circumcircle of any triangle in DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of points in S, the Voronoi diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exactly one point and every point in a given polygon is closer to its central point than to any other. A Voronoi diagram is sometimes also known as a Dirichlet tessellation.

![https://root.cern/doc/v636/tgraph2d_delaunay.png](https://root.cern/doc/v636/tgraph2d_delaunay.png)

[This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html) gives a nice practical view of Delaunay triangulation and Voronoi diagram.

Related functions: [`ComputeZ`](@ref), [`FindAllTriangles`](@ref), [`GetGraph2D`](@ref), [`GetMarginBinsContent`](@ref), [`GetNdt`](@ref), [`GetXNmax`](@ref), [`GetXNmin`](@ref), [`GetYNmax`](@ref), [`GetYNmin`](@ref), [`SetMarginBinsContent`](@ref), [`TGraphDelaunay2D`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" TGraphDelaunay2D

# Wrapper of TGraphMultiErrors
@trydoc raw"""
    ROOT.TGraphMultiErrors

[TGraph](@ref) with asymmetric error bars and multiple y error dimensions.

The [TGraphMultiErrors](@ref) painting is performed thanks to the [TGraphPainter](@ref) class. All details about the various painting options are given in this class.

The picture below gives an example:

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGraphMultiErrors_001.png](https://root.cern/doc/v636/pict1_TGraphMultiErrors_001.png)

Related functions: [`AddYError`](@ref), [`Apply`](@ref), [`BayesDivide`](@ref), [`ComputeRange`](@ref), [`DeleteYError`](@ref), [`Divide`](@ref), [`GetAttFill`](@ref), [`GetAttLine`](@ref), [`GetEXhigh`](@ref), [`GetEXlow`](@ref), [`GetEYhigh`](@ref), [`GetEYlow`](@ref), [`GetErrorX`](@ref), [`GetErrorXhigh`](@ref), [`GetErrorXlow`](@ref), [`GetErrorY`](@ref), [`GetErrorYhigh`](@ref), [`GetErrorYlow`](@ref), [`GetFillColor`](@ref), [`GetFillStyle`](@ref), [`GetLineColor`](@ref), [`GetLineStyle`](@ref), [`GetLineWidth`](@ref), [`GetNYErrors`](@ref), [`GetSumErrorsMode`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetAttFill`](@ref), [`SetAttLine`](@ref), [`SetEY`](@ref), [`SetEYhigh`](@ref), [`SetEYlow`](@ref), [`SetFillColorAlpha`](@ref), [`SetFillColor`](@ref), [`SetFillStyle`](@ref), [`SetLineColorAlpha`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetPointEX`](@ref), [`SetPointEXhigh`](@ref), [`SetPointEXlow`](@ref), [`SetPointEY`](@ref), [`SetPointEYhigh`](@ref), [`SetPointEYlow`](@ref), [`SetPointError`](@ref), [`SetSumErrorsMode`](@ref), [`TGraphMultiErrors`](@ref), [`assign`](@ref)
""" TGraphMultiErrors

# Wrapper of TAttFill
@trydoc raw"""
    ROOT.TAttFill

Fill Area Attributes class.

This class is used (in general by secondary inheritance) by many other classes (graphics, histograms). It holds all the fill area attributes.

## Fill Area attributes

Fill Area attributes are:

- [Fill Area color](@ref)
- [Fill Area style](@ref)

## Fill Area color

The fill area color is a color index (integer) pointing in the [ROOT](@ref) color table. The fill area color of any class inheriting from `TAttFill` can be changed using the method `SetFillColor` and retrieved using the method `GetFillColor`. The following table shows the first 50 default colors.

![https://root.cern/doc/v636/pict1_TAttFill_001.png](https://root.cern/doc/v636/pict1_TAttFill_001.png)

### Color transparency

`SetFillColorAlpha()`, allows to set a transparent color. In the following example the fill color of the histogram `histo` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    histo->SetFillColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

### The ROOT Color Wheel.

The wheel contains the recommended 216 colors to be used in web applications. The colors in the Color Wheel are created by [TColor!CreateColorWheel](@ref).

Using this color set for your text, background or graphics will give your application a consistent appearance across different platforms and browsers.

Colors are grouped by hue, the aspect most important in human perception Touching color chips have the same hue, but with different brightness and vividness.

Colors of slightly different hues *clash*. If you intend to display colors of the same hue together, you should pick them from the same group.

Each color chip is identified by a mnemonic (eg kYellow) and a number. The keywords, kRed, kBlue, kYellow, kPink, etc are defined in the header file **Rtypes.h** that is included in all [ROOT](@ref) other header files. We strongly recommend to use these keywords in your code instead of hardcoded color numbers, eg: 

    myObject.SetFillColor(kRed);
    myObject.SetFillColor(kYellow-10);
    myLine.SetLineColor(kMagenta+2);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TAttFill_002.png](https://root.cern/doc/v636/pict1_TAttFill_002.png)

### Special case forcing black&white output.

If the current style fill area color is set to 0, then [ROOT](@ref) will force a black&white output for all objects with a fill area defined and independently of the object fill style.

## Fill Area style

The fill area style defines the pattern used to fill a polygon. The fill area style of any class inheriting from `TAttFill` can be changed using the method `SetFillStyle` and retrieved using the method `GetFillStyle`. 

### Conventions for fill styles:

- 0 : hollow
- 1001 : Solid
- 3000+pattern_number (see below)
- For [TPad](@ref) only:

    - 4000 :the window is transparent.
    - 4000 to 4100 the window is 100% transparent to 100% opaque.

        The pad transparency is visible in binary outputs files like gif, jpg, png etc .. but not in vector graphics output files like PS, PDF and SVG. This convention (fill style > 4000) is kept for backward compatibility. It is better to use the color transparency instead.

pattern_number can have any value from 1 to 25 (see table), or any value from 100 to 999. For the latest the numbering convention is the following: 

    pattern_number = ijk      (FillStyle = 3ijk)
    i (1-9) : specify the space between each hatch
              1 = 1/2mm  9 = 6mm
    j (0-9) : specify angle between 0 and 90 degrees
              0 = 0
              1 = 10
              2 = 20
              3 = 30
              4 = 45
              5 = Not drawn
              6 = 60
              7 = 70
              8 = 80
              9 = 90
    k (0-9) : specify angle between 90 and 180 degrees
              0 = 180
              1 = 170
              2 = 160
              3 = 150
              4 = 135
              5 = Not drawn
              6 = 120
              7 = 110
              8 = 100
              9 = 90

(C++ version of the code)

 The following table shows the list of pattern styles. The first table displays the 25 fixed patterns. They cannot be customized unlike the hatches displayed in the second table which be customized using:

- `gStyle->SetHatchesSpacing()` to define the spacing between hatches.
- `gStyle->SetHatchesLineWidth()` to define the hatches line width.

![https://root.cern/doc/v636/pict1_TAttFill_003.png](https://root.cern/doc/v636/pict1_TAttFill_003.png)

Related functions: [`Copy`](@ref), [`GetFillColor`](@ref), [`GetFillStyle`](@ref), [`IsA`](@ref), [`IsTransparent`](@ref), [`Modify`](@ref), [`ResetAttFill`](@ref), [`SaveFillAttributes`](@ref), [`SetFillAttributes`](@ref), [`SetFillColorAlpha`](@ref), [`SetFillColor`](@ref), [`SetFillStyle`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttFill!Class_Name`](@ref), [`TAttFill!Class_Version`](@ref), [`TAttFill!Class`](@ref), [`TAttFill!DeclFileName`](@ref), [`TAttFill`](@ref)
""" TAttFill

# Wrapper of TAttLine
@trydoc raw"""
    ROOT.TAttLine

Line Attributes class.

This class is used (in general by secondary inheritance) by many other classes (graphics, histograms). It holds all the line attributes.

## Line attributes

Line attributes are:

- [Line Color](@ref)
- [Line Width](@ref)
- [Line Style](@ref)

## Line Color

The line color is a color index (integer) pointing in the [ROOT](@ref) color table. The line color of any class inheriting from `TAttLine` can be changed using the method `SetLineColor` and retrieved using the method `GetLineColor`. The following table shows the first 50 default colors.

![https://root.cern/doc/v636/pict1_TAttLine_001.png](https://root.cern/doc/v636/pict1_TAttLine_001.png)

### Color transparency

`SetLineColorAlpha()`, allows to set a transparent color. In the following example the line color of the histogram `histo` is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color `kBlue` itself is internally stored as fully opaque.)

    histo->SetLineColorAlpha(kBlue, 0.35);

(C++ version of the code)

The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.

Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`. Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.

## Line Width

The line width is expressed in pixel units. The line width of any class inheriting from `TAttLine` can be changed using the method `SetLineWidth` and retrieved using the method `GetLineWidth`. The following picture shows the line widths from 1 to 10 pixels.

![https://root.cern/doc/v636/pict1_TAttLine_002.png](https://root.cern/doc/v636/pict1_TAttLine_002.png)

## Line Style

Line styles are identified via integer numbers. The line style of any class inheriting from `TAttLine` can be changed using the method `SetLineStyle` and retrieved using the method `GetLineStyle`.

The first 10 line styles are predefined as shown on the following picture:

![https://root.cern/doc/v636/pict1_TAttLine_003.png](https://root.cern/doc/v636/pict1_TAttLine_003.png)

Some line styles can be accessed via the following enum:

    kSolid      = 1
    kDashed     = 2
    kDotted     = 3
    kDashDotted = 4

(C++ version of the code)

Additional line styles can be defined using `TStyle!SetLineStyleString`. For example the line style number 11 can be defined as follow: 

    gStyle->SetLineStyleString(11,"400 200");

(C++ version of the code)

 Existing line styles (1 to 10) can be redefined using the same method.

Related functions: [`Copy`](@ref), [`DistancetoLine`](@ref), [`GetLineColor`](@ref), [`GetLineStyle`](@ref), [`GetLineWidth`](@ref), [`IsA`](@ref), [`Modify`](@ref), [`ResetAttLine`](@ref), [`SaveLineAttributes`](@ref), [`SetLineAttributes`](@ref), [`SetLineColorAlpha`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`StreamerNVirtual`](@ref), [`Streamer`](@ref), [`TAttLine!Class_Name`](@ref), [`TAttLine!Class_Version`](@ref), [`TAttLine!Class`](@ref), [`TAttLine!DeclFileName`](@ref), [`TAttLine`](@ref)
""" TAttLine

# Wrapper of TGraphSmooth
@trydoc raw"""
    ROOT.TGraphSmooth

A helper class to smooth [TGraph](@ref).

see examples in $ROOTSYS/tutorials/visualisation/graphs/gr010_approx_smooth.C and $ROOTSYS/tutorials/visualisation/graphs/gr015_smooth.C

Related functions: [`Approx`](@ref), [`Approxin`](@ref), [`Lowess`](@ref), [`SmoothKern`](@ref), [`SmoothLowess`](@ref), [`SmoothSuper`](@ref), [`Smoothin`](@ref), [`TGraphSmooth!Approx1`](@ref), [`TGraphSmooth!BDRksmooth`](@ref), [`TGraphSmooth!BDRsmooth`](@ref), [`TGraphSmooth!BDRsupsmu`](@ref), [`TGraphSmooth!Lowest`](@ref), [`TGraphSmooth!Psort`](@ref), [`TGraphSmooth!Rank`](@ref), [`TGraphSmooth!Rcmp`](@ref), [`TGraphSmooth`](@ref)
""" TGraphSmooth

# Wrapper of TGraphTime
@trydoc raw"""
    ROOT.TGraphTime

[TGraphTime](@ref) is used to draw a set of objects evolving with nsteps in time between tmin and tmax.

Each time step has a new list of objects. This list can be identical to the list of objects in the previous steps, but with different attributes. See example of use in $ROOTSYS/tutorials/visualisation/graphs/gr017_time.C

Related functions: [`Add`](@ref), [`Animate`](@ref), [`Draw`](@ref), [`GetSteps`](@ref), [`HandleTimer`](@ref), [`Paint`](@ref), [`SaveAnimatedGif`](@ref), [`SetSleepTime`](@ref), [`TGraphTime`](@ref)
""" TGraphTime

# Wrapper of TVirtualHistPainter
@trydoc raw"""
    ROOT.TVirtualHistPainter

Abstract interface to a histogram painter.



Related functions: [`DistancetoPrimitive`](@ref), [`DrawPanel`](@ref), [`ExecuteEvent`](@ref), [`GetContourList`](@ref), [`GetObjectInfo`](@ref), [`GetStack`](@ref), [`IsInside`](@ref), [`MakeCuts`](@ref), [`PaintStat`](@ref), [`Paint`](@ref), [`ProcessMessage`](@ref), [`SetHighlight`](@ref), [`SetHistogram`](@ref), [`SetShowProjectionXY`](@ref), [`SetShowProjection`](@ref), [`SetStack`](@ref), [`TVirtualHistPainter!HistPainter`](@ref), [`TVirtualHistPainter!SetPainter`](@ref), [`TVirtualHistPainter`](@ref)
""" TVirtualHistPainter

# Wrapper of TH1C
@trydoc raw"""
    ROOT.TH1C

1-D histogram with a byte per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1C`](@ref), [`assign`](@ref)
""" TH1C

# Wrapper of TH1S
@trydoc raw"""
    ROOT.TH1S

1-D histogram with a short per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1S`](@ref), [`assign`](@ref)
""" TH1S

# Wrapper of TH1I
@trydoc raw"""
    ROOT.TH1I

1-D histogram with an int per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1I`](@ref), [`assign`](@ref)
""" TH1I

# Wrapper of TH1L
@trydoc raw"""
    ROOT.TH1L

1-D histogram with a long64 per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1L`](@ref), [`assign`](@ref)
""" TH1L

# Wrapper of TH1D
@trydoc raw"""
    ROOT.TH1D

1-D histogram with a double per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`ClassDefOverride`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH1D`](@ref), [`assign`](@ref)
""" TH1D

# Wrapper of TH1K
@trydoc raw"""
    ROOT.TH1K

[TH1K](@ref) class supports the nearest K Neighbours method, widely used in cluster analysis.

This method is especially useful for small statistics. In this method : 
```
  DensityOfProbability ~ 1/DistanceToNearestKthNeighbour
  Ctr TH1K!TH1K(name,title,nbins,xlow,xup,K=0)
  differs from TH1F only by "K"
  K - is the order of K Neighbours method, usually >=3
  K = 0, means default, where K is selected by TH1K in such a way
         that DistanceToNearestKthNeighbour > BinWidth and K >=3
```  This class has been implemented by Victor Perevoztchikov [perev@bnl.gov](mailto:perev@bnl.gov)

Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinError`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`SetKOrd`](@ref), [`TH1K`](@ref)
""" TH1K

# Wrapper of TProfile
@trydoc raw"""
    ROOT.TProfile

Profile Histogram.

Profile histograms are used to display the mean value of Y and its error for each bin in X. The displayed error is by default the standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ). Profile histograms are in many cases an elegant replacement of two-dimensional histograms. The inter-relation of two measured quantities X and Y can always be visualized by a two-dimensional histogram or scatter plot, but if Y is an unknown (but single-valued) approximate function of X, this function is displayed by a profile histogram with much better precision than by a scatter plot.

The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for bin j. 

``\thebegin{align}
       H(j)  &=  \sum w \cdot Y \\
       E(j)  &=  \sum w \cdot Y^2 \\
       W(j)  &=  \sum w                   & &\text{if weights different from 1, the number of bin effective entries is used} \\
       h(j)  &=  H(j) / W(j)              & &\text{mean of Y,} \\
       s(j)  &=  \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\
       e(j)  &=  s(j)/\sqrt{W(j)}         & &\text{standard error on the mean} \\
  \theend{align}``

 The bin content is always the mean of the Y values, but errors change depending on options: 

``\thebegin{align}
      \text{GetBinContent}(j) &= h(j) \\
      \text{GetBinError}(j) &=
        \thebegin{cases}
          e(j)                 &\text{if option="" (default). Error of the mean of all y values.} \\
          s(j)                 &\text{if option="s". Standard deviation of all y values.} \\
          \thebegin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \theend{cases}       &\text{if option="i". This is useful for storing integers such as ADC counts.} \\
          1/\sqrt{W(j)}           &\text{if option="g". Error of a weighted mean for combining measurements with variances of } w. \\
        \theend{cases}
    \theend{align}``

 In the special case where s(j) is zero (eg, case of 1 entry only in one bin) the bin error [e(j)](@ref) is computed from the average of the s(j) for all bins if the static function [TProfile!Approximate()](@ref) has been called. This simple/crude approximation was suggested in order to keep the bin during a fit operation. But note that this approximation is not the default behaviour. See also [TProfile!BuildOptions](@ref) for more on error options.

### Creating and drawing a profile histogram

    {
      auto c1 = new TCanvas("c1","Profile histogram example",200,10,700,500);
      auto hprof  = new TProfile("hprof","Profile of pz versus px",100,-4,4,0,20);
      Float_t px, py, pz;
      for ( Int_t i=0; i<25000; i++) {
        gRandom->Rannor(px,py);
        pz = px*px + py*py;
        hprof->Fill(px,pz,1);
      }
      hprof->Draw();
    }

(C++ version of the code)

Related functions: [`Add`](@ref), [`BufferEmpty`](@ref), [`BuildOptions`](@ref), [`Copy`](@ref), [`Divide`](@ref), [`ExtendAxis`](@ref), [`FillN`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetBinSumw2`](@ref), [`GetErrorOption`](@ref), [`GetStats`](@ref), [`GetYmax`](@ref), [`GetYmin`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`ProjectionX`](@ref), [`PutStats`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinEntries`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetErrorOption`](@ref), [`Sumw2`](@ref), [`TProfile!Approximate`](@ref), [`TProfile`](@ref), [`assign`](@ref)
""" TProfile

# Wrapper of TH2C
@trydoc raw"""
    ROOT.TH2C

2-D histogram with a byte per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2C`](@ref), [`assign`](@ref)
""" TH2C

# Wrapper of TH2S
@trydoc raw"""
    ROOT.TH2S

2-D histogram with a short per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2S`](@ref), [`assign`](@ref)
""" TH2S

# Wrapper of TH2I
@trydoc raw"""
    ROOT.TH2I

2-D histogram with an int per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2I`](@ref), [`assign`](@ref)
""" TH2I

# Wrapper of TH2L
@trydoc raw"""
    ROOT.TH2L

2-D histogram with a long64 per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2L`](@ref), [`assign`](@ref)
""" TH2L

# Wrapper of TH2F
@trydoc raw"""
    ROOT.TH2F

2-D histogram with a float per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH2F`](@ref), [`assign`](@ref)
""" TH2F

# Wrapper of TH2Poly
@trydoc raw"""
    ROOT.TH2Poly

2D Histogram with Polygonal Bins

## Overview

`TH2Poly` is a 2D Histogram class ([TH2](@ref)) allowing to define polygonal bins of arbitrary shape.

Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object. `TH2PolyBin` is a very simple class containing the vertices (stored as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal bin as well as several related functions.

Essentially, a `TH2Poly` is a [TList](@ref) of `TH2PolyBin` objects with methods to manipulate them.

Bins are defined using one of the `AddBin()` methods. The bin definition should be done before filling.

The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w) `. `w` is the weight. If no weight is specified, it is assumed to be 1.

Not all histogram's area need to be binned. Filling an area without bins, will falls into the overflows. Adding a bin is not retroactive; it doesn't affect previous fillings. A `Fill()` call, that was previously ignored due to the lack of a bin at the specified location, is not reconsidered when that location is binned later.

If there are two overlapping bins, the first one in the list will be incremented by `Fill()`.

The histogram may automatically extends its limits if a bin outside the histogram limits is added. This is done when the default constructor (with no arguments) is used. It generates a histogram with no limits along the X and Y axis. Adding bins to it will extend it up to a proper size.

`TH2Poly` implements a partitioning algorithm to speed up bins' filling (see the "Partitioning Algorithm" section for details). The partitioning algorithm divides the histogram into regions called cells. The bins that each cell intersects are recorded in an array of `TList`s. When a coordinate in the histogram is to be filled; the method (quickly) finds which cell the coordinate belongs. It then only loops over the bins intersecting that cell to find the bin the input coordinate corresponds to. The partitioning of the histogram is updated continuously as each bin is added. The default number of cells on each axis is 25. This number could be set to another value in the constructor or adjusted later by calling the `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is considerably faster than the brute force algorithm (i.e. checking if each bin contains the input coordinates), especially if the histogram is to be filled many times.

The following very simple macro shows how to build and fill a `TH2Poly`: 

    {
        auto h2p = new TH2Poly();
        Double_t x1[] = {0, 5, 6};
        Double_t y1[] = {0, 0, 5};
        Double_t x2[] = {0, -1, -1, 0};
        Double_t y2[] = {0, 0, -1, 3};
        Double_t x3[] = {4, 3, 0, 1, 2.4};
        Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};
        h2p->AddBin(3, x1, y1);
        h2p->AddBin(4, x2, y2);
        h2p->AddBin(5, x3, y3);
        h2p->Fill(0.1, 0.01, 3);
        h2p->Fill(-0.5, -0.5, 7);
        h2p->Fill(-0.7, -0.5, 1);
        h2p->Fill(1, 3, 1.5);
    }

(C++ version of the code)

More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoneycomb.C and th2polyUSA.C.

## Partitioning Algorithm

The partitioning algorithm forms an essential part of the `TH2Poly` class. It is implemented to speed up the filling of bins.

With the brute force approach, the filling is done in the following way: An iterator loops over all bins in the `TH2Poly` and invokes the method `IsInside()` for each of them. This method checks if the input location is in that bin. If the filling coordinate is inside, the bin is filled. Looping over all the bin is very slow.

The alternative is to divide the histogram into virtual rectangular regions called "cells". Each cell stores the pointers of the bins intersecting it. When a coordinate is to be filled, the method finds which cell the coordinate falls into. Since the cells are rectangular, this can be done very quickly. It then only loops over the bins associated with that cell and calls `IsInside()` only on that bins. This reduces considerably the number of bins on which `IsInside()` is called and therefore speed up by a huge factor the filling compare to the brute force approach where `IsInside()` is called for all bins.

The addition of bins to the appropriate cells is done when the bin is added to the histogram. To do this, `AddBin()` calls the `AddBinToPartition()` method. This method adds the input bin to the partitioning matrix.

The number of partition cells per axis can be specified in the constructor. If it is not specified, the default value of 25 along each axis will be assigned. This value was chosen because it is small enough to avoid slowing down [AddBin()](@ref), while being large enough to enhance [Fill()](@ref) by a considerable amount. Regardless of how it is initialized at construction time, it can be changed later with the `ChangePartition()` method. `ChangePartition()` deletes the old partition matrix and generates a new one with the specified number of cells on each axis.

The optimum number of partition cells per axis changes with the number of times `Fill()` will be called. Although partitioning greatly speeds up filling, it also adds a constant time delay into the code. When `Fill()` is to be called many times, it is more efficient to divide the histogram into a large number cells. However, if the histogram is to be filled only a few times, it is better to divide into a small number of cells.

Related functions: [`AddBin`](@ref), [`Add`](@ref), [`ChangePartition`](@ref), [`ClearBinContents`](@ref), [`ComputeIntegral`](@ref), [`Copy`](@ref), [`CreateBin`](@ref), [`Divide`](@ref), [`FFT`](@ref), [`FillN`](@ref), [`Fill`](@ref), [`FindBin`](@ref), [`GetAsymmetry`](@ref), [`GetBinContentChanged`](@ref), [`GetBinContent`](@ref), [`GetBinError`](@ref), [`GetBinName`](@ref), [`GetBinTitle`](@ref), [`GetBins`](@ref), [`GetFloat`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNewBinAdded`](@ref), [`GetNumberOfBins`](@ref), [`GetStats`](@ref), [`Honeycomb`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`IsInsideBin`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinContentChanged`](@ref), [`SetBinContent`](@ref), [`SetBinError`](@ref), [`SetFloat`](@ref), [`SetNewBinAdded`](@ref), [`TH2Poly`](@ref), [`assign`](@ref)
""" TH2Poly

# Wrapper of TH2PolyBin
@trydoc raw"""
    ROOT.TH2PolyBin

Helper class to represent a bin in the [TH2Poly](@ref) histogram.



Related functions: [`ClearContent`](@ref), [`Fill`](@ref), [`GetArea`](@ref), [`GetBinNumber`](@ref), [`GetChanged`](@ref), [`GetContent`](@ref), [`GetPolygon`](@ref), [`GetXMax`](@ref), [`GetXMin`](@ref), [`GetYMax`](@ref), [`GetYMin`](@ref), [`IsInside`](@ref), [`SetChanged`](@ref), [`SetContent`](@ref), [`TH2PolyBin`](@ref)
""" TH2PolyBin

# Wrapper of TH3
@trydoc raw"""
    ROOT.TH3

The 3-D histogram classes derived from the 1-D histogram classes.

All operations are supported (fill, fit). Drawing is currently restricted to one single option. A cloud of points is drawn. The number of points is proportional to cell content.

- [TH3C](@ref) a 3-D histogram with one byte per cell (char). Maximum bin content = 127
- [TH3S](@ref) a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767
- [TH3I](@ref) a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX ([*](@ref))
- [TH3L](@ref) a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX ([**](@ref))
- [TH3F](@ref) a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 ([***](@ref))
- [TH3D](@ref) a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 ([****](@ref))

<sup> (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br/>
 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br/>
 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760) </sup>

Related functions: [`AddBinContent`](@ref), [`BufferEmpty`](@ref), [`Copy`](@ref), [`FillRandom`](@ref), [`Fill`](@ref), [`FitSlicesZ`](@ref), [`GetBinContent`](@ref), [`GetBinErrorLow`](@ref), [`GetBinErrorUp`](@ref), [`GetBinWithContent3`](@ref), [`GetBin`](@ref), [`GetCorrelationFactor`](@ref), [`GetCovariance`](@ref), [`GetRandom3`](@ref), [`GetStats`](@ref), [`IntegralAndError`](@ref), [`Integral`](@ref), [`Interpolate`](@ref), [`KolmogorovTest`](@ref), [`Project3DProfile`](@ref), [`Project3D`](@ref), [`ProjectionX`](@ref), [`ProjectionY`](@ref), [`ProjectionZ`](@ref), [`PutStats`](@ref), [`Rebin3D`](@ref), [`RebinX`](@ref), [`RebinY`](@ref), [`RebinZ`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetShowProjection`](@ref)
""" TH3

# Wrapper of TProfile2D
@trydoc raw"""
    ROOT.TProfile2D

Profile2D histograms are used to display the mean value of Z and its error for each cell in X,Y.

Profile2D histograms are in many cases an elegant replacement of three-dimensional histograms : the inter-relation of three measured quantities X, Y and Z can always be visualized by a three-dimensional histogram or scatter-plot; its representation on the line-printer is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) approximate function of X,Y this function is displayed by a profile2D histogram with much better precision than by a scatter-plot.

The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for cell i, j. 

``\thebegin{align}
      H(i,j)  &=  \sum w \cdot Z  \\
      E(i,j)  &=  \sum w \cdot Z^2 \\
      W(i,j)  &=  \sum w \\
      h(i,j)  &=  \frac{H(i,j)}{W(i,j)} \\
      s(i,j)  &=  \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\
      e(i,j)  &=  \frac{s(i,j)}{\sqrt{W(i,j)}}
 \theend{align}``

 The bin content is always the mean of the Z values, but errors change depending on options: 

``\thebegin{align}
     \text{GetBinContent}(i,j) &= h(i,j) \\
     \text{GetBinError}(i,j) &=
       \thebegin{cases}
         e(i,j)                 &\text{if option="" (default). Error of the mean of all z values.} \\
         s(i,j)                 &\text{if option="s". Standard deviation of z values.} \\
         \thebegin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \theend{cases}       &\text{if option="i". This is useful for storing integers such as ADC counts.} \\
         1/\sqrt{W(i,j)}           &\text{if option="g". Error of a weighted mean when combining measurements with variances of } w. \\
       \theend{cases}
   \theend{align}``

In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell) the bin error [e(I,J)](@ref) is computed from the average of the s(I,J) for all cells if the static function [TProfile2D!Approximate](@ref) has been called. This simple/crude approximation was suggested in order to keep the cell during a fit operation. But note that this approximation is not the default behaviour.

### Creating and drawing a 2D profile

    {
       auto c1 = new TCanvas("c1","Profile histogram example",200,10,700,500);
       auto hprof2d  = new TProfile2D("hprof2d","Profile of pz versus px and py",40,-4,4,40,-4,4,0,20);
       Float_t px, py, pz;
       for ( Int_t i=0; i<25000; i++) {
          gRandom->Rannor(px,py);
          pz = px*px + py*py;
          hprof2d->Fill(px,py,pz,1);
       }
       hprof2d->Draw();
    }

(C++ version of the code)

Related functions: [`Add`](@ref), [`BufferEmpty`](@ref), [`BuildOptions`](@ref), [`Copy`](@ref), [`Divide`](@ref), [`ExtendAxis`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetBinSumw2`](@ref), [`GetErrorOption`](@ref), [`GetNumberOfBins`](@ref), [`GetStats`](@ref), [`GetZmax`](@ref), [`GetZmin`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`ProfileX`](@ref), [`ProfileY`](@ref), [`ProjectionXY`](@ref), [`PutStats`](@ref), [`Rebin2D`](@ref), [`RebinX`](@ref), [`RebinY`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinEntries`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetErrorOption`](@ref), [`Sumw2`](@ref), [`TProfile2D!Approximate`](@ref), [`TProfile2D`](@ref), [`assign`](@ref)
""" TProfile2D

# Wrapper of TH3C
@trydoc raw"""
    ROOT.TH3C

3-D histogram with a byte per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3C`](@ref), [`assign`](@ref)
""" TH3C

# Wrapper of TH3S
@trydoc raw"""
    ROOT.TH3S

3-D histogram with a short per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3S`](@ref), [`assign`](@ref)
""" TH3S

# Wrapper of TH3I
@trydoc raw"""
    ROOT.TH3I

3-D histogram with an int per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3I`](@ref), [`assign`](@ref)
""" TH3I

# Wrapper of TH3L
@trydoc raw"""
    ROOT.TH3L

3-D histogram with a long64 per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3L`](@ref), [`assign`](@ref)
""" TH3L

# Wrapper of TH3F
@trydoc raw"""
    ROOT.TH3F

3-D histogram with a float per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3F`](@ref), [`assign`](@ref)
""" TH3F

# Wrapper of TH3D
@trydoc raw"""
    ROOT.TH3D

3-D histogram with a double per channel (see [TH1](@ref) documentation)



Related functions: [`AddBinContent`](@ref), [`Copy`](@ref), [`Reset`](@ref), [`SetBinsLength`](@ref), [`TH3D`](@ref), [`assign`](@ref)
""" TH3D

# Wrapper of TBinIterator
@trydoc raw"""
    ROOT.TBinIterator





Related functions: [`Base.:(!=)`](@ref), [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`TBinIterator!End`](@ref), [`TBinIterator`](@ref), [`inc!`](@ref)
""" TBinIterator

# Wrapper of THistRange
@trydoc raw"""
    ROOT.THistRange





Related functions: [`THistRange`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" THistRange

# Wrapper of THLimitsFinder
@trydoc raw"""
    ROOT.THLimitsFinder

Class to compute nice axis limits.

This class is called by default by the histogramming system and also by [TTree!Draw](@ref), [TTreePlayer!DrawSelect](@ref). [TGaxis](@ref) use it also to optimize axis labels.

A different finder may be specified via THLimitsFinder!SetFinder.

Related functions: [`FindGoodLimits`](@ref), [`THLimitsFinder!GetLimitsFinder`](@ref), [`THLimitsFinder!OptimizeLimits`](@ref), [`THLimitsFinder!Optimize`](@ref), [`THLimitsFinder!SetLimitsFinder`](@ref), [`THLimitsFinder`](@ref)
""" THLimitsFinder

# Wrapper of TNDArray
@trydoc raw"""
    ROOT.TNDArray

N-Dim array class.

Storage layout: Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins: Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],...

fSizes stores the combined size of each bin in a dimension, i.e. in above example it would contain 24, 12, 3, 1.

Storage is allocated lazily, only when data is written to the array.

Related functions: [`AddAt`](@ref), [`AtAsDouble`](@ref), [`GetBin`](@ref), [`GetCellSize`](@ref), [`GetNbins`](@ref), [`GetNdimensions`](@ref), [`Init`](@ref), [`Reset`](@ref), [`SetAsDouble`](@ref), [`TNDArray`](@ref)
""" TNDArray

# Wrapper of TNDArrayRef
@trydoc raw"""
    ROOT.TNDArrayRef

gives access to a sub-dimension, e.g.

arr[0][1] in above three-dimensional example, up to an element with conversion operator to double: double value = arr[0][1][2];

Related functions: [`Base.getindex`](@ref), [`TNDArrayRef`](@ref), [`T`](@ref)
""" TNDArrayRef

# Wrapper of TNDArrayT
@trydoc raw"""
    ROOT.TNDArrayT





Related functions: [`AddAt`](@ref), [`AtAsDouble`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Init`](@ref), [`Reset`](@ref), [`SetAsDouble`](@ref), [`TNDArrayT`](@ref)
""" TNDArrayT

# Wrapper of THn
@trydoc raw"""
    ROOT.THn

Multidimensional histogram.

Use a [THn](@ref) if you really, really have to store more than three dimensions, and if a large fraction of all bins are filled. Better alternatives are

- [THnSparse](@ref) if a fraction of all bins are filled
- [TTree](@ref)

The major problem of [THn](@ref) is the memory use caused by n-dimensional histogramming: a THnD with 8 dimensions and 100 bins per dimension needs more than 2.5GB of RAM!

To construct a [THn](@ref) object you must use one of its templated, derived classes: 
```
THnD (typedef for THnT<Double_t>): bin content held by a Double_t,
THnF (typedef for THnT<Float_t>): bin content held by a Float_t,
THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,
THnI (typedef for THnT<Int_t>): bin content held by an Int_t,
THnS (typedef for THnT<Short_t>): bin content held by a Short_t,
THnC (typedef for THnT<Char_t>): bin content held by a Char_t,
```  They take name and title, the number of dimensions, and for each dimension the number of bins, the minimal, and the maximal value on the dimension's axis. A [TH2F](@ref) h("h","h",10, 0., 10., 20, -5., 5.) would correspond to 
```
Int_t bins[2] = {10, 20};
Double_t xmin[2] = {0., -5.};
Double_t xmax[2] = {10., 5.};
THnF hn("hn", "hn", 2, bins, xmin, xmax);
```  

## Filling

A [THn](@ref) is filled just like a regular histogram, using THn!Fill(x, weight), where x is a n-dimensional Double_t value. To take errors into account, [Sumw2()](@ref) must be called before filling the histogram. Storage is allocated when the first bin content is stored.

## Projections

The dimensionality of a [THn](@ref) can be reduced by projecting it to 1, 2, 3, or n dimensions, which can be represented by a [TH1](@ref), [TH2](@ref), [TH3](@ref), or a [THn](@ref). See the [Projection()](@ref) members. To only project parts of the histogram, call 
```
hn->GetAxis(12)->SetRange(from_bin, to_bin);
```  

## Conversion from other histogram classes

The static factory function [THn!CreateHn()](@ref) can be used to create a [THn](@ref) from a [TH1](@ref), [TH2](@ref), [TH3](@ref), [THnSparse](@ref) and (for copying) even from a [THn](@ref). The created [THn](@ref) will have compatble storage type, i.e. calling [CreateHn()](@ref) on a [TH2F](@ref) will create a THnF.

Related functions: [`AddBinContent`](@ref), [`AddBinError2`](@ref), [`CreateIter`](@ref), [`FillBin`](@ref), [`GetArray`](@ref), [`GetBinContent`](@ref), [`GetBinError2`](@ref), [`GetBin`](@ref), [`GetNbins`](@ref), [`Projection`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetBinError2`](@ref), [`Sumw2`](@ref), [`THn!CreateHn`](@ref)
""" THn

# Wrapper of THnBase
@trydoc raw"""
    ROOT.THnBase

Multidimensional histogram base.

Defines common functionality and interfaces for [THn](@ref), [THnSparse](@ref).

Related functions: [`AddBinContent`](@ref), [`AddBinError2`](@ref), [`Add`](@ref), [`Browse`](@ref), [`CalculateErrors`](@ref), [`ClassDefOverride`](@ref), [`ComputeIntegral`](@ref), [`CreateIter`](@ref), [`Divide`](@ref), [`FillBin`](@ref), [`Fill`](@ref), [`Fit`](@ref), [`GetAxis`](@ref), [`GetBinCenter`](@ref), [`GetBinContent`](@ref), [`GetBinError2`](@ref), [`GetBinError`](@ref), [`GetBin`](@ref), [`GetCalculateErrors`](@ref), [`GetEntries`](@ref), [`GetListOfAxes`](@ref), [`GetListOfFunctions`](@ref), [`GetNbins`](@ref), [`GetNdimensions`](@ref), [`GetRandom`](@ref), [`GetSumw2`](@ref), [`GetSumw`](@ref), [`GetSumwx2`](@ref), [`GetSumwx`](@ref), [`GetWeightSum`](@ref), [`Integral`](@ref), [`IsFolder`](@ref), [`IsInRange`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`PrintBin`](@ref), [`PrintEntries`](@ref), [`Print`](@ref), [`ProjectionND`](@ref), [`Projection`](@ref), [`RebinnedAdd`](@ref), [`Reset`](@ref), [`Scale`](@ref), [`SetBinContent`](@ref), [`SetBinEdges`](@ref), [`SetBinError2`](@ref), [`SetBinError`](@ref), [`SetEntries`](@ref), [`SetTitle`](@ref), [`Sumw2`](@ref)
""" THnBase

# Wrapper of THnChain
@trydoc raw"""
    ROOT.THnChain

A class to chain together multiple histograms.

This class allows to chain together any `THnBase`-derived (`THn` or `THnSparse`) histograms from multiple files. Operations on the axes and projections are supported. The intent is to allow convenient merging merging of projections of high-dimensional histograms.

    // `file1.root` and `file2.root` contain a `THnSparse` named `hsparse`.
    THnChain hs("hsparse");
    hs.AddFile("file1.root");
    hs.AddFile("file2.root");
    // Project out axis 0, integrate over other axes.
    TH1* h0 = hs.Projection(0);
    // Project out axis 0, integrate over other axes in their active ranges.
    hs.GetAxis(1)->SetRangeUser(0, 0.1); // select a subrange
    TH1* h0 = hs.Projection(0);

(C++ version of the code)

Related functions: [`AddFile`](@ref), [`GetAxis`](@ref), [`ProjectionND`](@ref), [`Projection`](@ref), [`THnChain`](@ref)
""" THnChain

# Wrapper of THnIter
@trydoc raw"""
    ROOT.THnIter

Iterator over [THnBase](@ref) bins.



Related functions: [`GetCoord`](@ref), [`HaveSkippedBin`](@ref), [`Next`](@ref), [`RespectsAxisRange`](@ref), [`THnIter`](@ref)
""" THnIter

# Wrapper of THnT
@trydoc raw"""
    ROOT.THnT

Templated implementation of the abstract base [THn](@ref).

All functionality and the interfaces to be used are in THn!

[THn](@ref) does not know how to store any bin content itself. Instead, this is delegated to the derived, templated class: the template parameter decides what the format for the bin content is. The actual storage is delegated to TNDArrayT<T>.

Typedefs exist for template parameters with [ROOT](@ref)'s generic types:

| **Templated name** | **Typedef** | **Bin content type** |
|:-------------------|:------------|:---------------------|
| THnT<Char_t>       | THnC        | Char_t               |
| THnT<Short_t>      | THnS        | Short_t              |
| THnT<Int_t>        | THnI        | Int_t                |
| THnT<Long64_t>     | THnL        | Long64_t             |
| THnT<Float_t>      | THnF        | Float_t              |
| THnT<Double_t>     | THnD        | Double_t             |

We recommend to use THnC wherever possible, and to map its value space of 256 possible values to e.g. float values outside the class. This saves an enormous amount of memory. Only if more than 256 values need to be distinguished should e.g. THnS or even THnF be chosen.

Implementation detail: the derived, templated class is kept extremely small on purpose. That way the (templated thus inlined) uses of this class will only create a small amount of machine code, in contrast to e.g. STL.

Related functions: [`GetArray`](@ref), [`THnT`](@ref)
""" THnT

# Wrapper of TArray
@trydoc raw"""
    ROOT.TArray

Abstract array base class.

Used by [TArrayC](@ref), [TArrayS](@ref), [TArrayI](@ref), [TArrayL](@ref), [TArrayF](@ref) and [TArrayD](@ref). Data member is public for historical reasons.

Related functions: [`GetAt`](@ref), [`GetSize`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArray!ReadArray`](@ref), [`TArray!WriteArray`](@ref), [`TArray`](@ref), [`assign`](@ref)
""" TArray

# Wrapper of TArrayC
@trydoc raw"""
    ROOT.TArrayC

Array of chars or bytes (8 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayC`](@ref), [`assign`](@ref)
""" TArrayC

# Wrapper of TArrayD
@trydoc raw"""
    ROOT.TArrayD

Array of doubles (64 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayD`](@ref), [`assign`](@ref)
""" TArrayD

# Wrapper of TArrayF
@trydoc raw"""
    ROOT.TArrayF

Array of floats (32 bits per element).



Related functions: [`AddAt`](@ref), [`Adopt`](@ref), [`At`](@ref), [`Base.getindex`](@ref), [`Copy`](@ref), [`GetArray`](@ref), [`GetAt`](@ref), [`GetSum`](@ref), [`Reset`](@ref), [`SetAt`](@ref), [`Set`](@ref), [`TArrayF`](@ref), [`assign`](@ref)
""" TArrayF

# Wrapper of THnSparse
@trydoc raw"""
    ROOT.THnSparse

Efficient multidimensional histogram.

Use a [THnSparse](@ref) instead of [TH1](@ref) / [TH2](@ref) / [TH3](@ref) / array for histogramming when only a small fraction of bins is filled. A 10-dimensional histogram with 10 bins per dimension has 10^10 bins; in a naive implementation this will not fit in memory. [THnSparse](@ref) only allocates memory for the bins that have non-zero bin content instead, drastically reducing both the memory usage and the access time.

To construct a [THnSparse](@ref) object you must use one of its templated, derived classes:

- THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,
- THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,
- THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,
- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,
- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,
- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,

They take name and title, the number of dimensions, and for each dimension the number of bins, the minimal, and the maximal value on the dimension's axis. A [TH2](@ref) h("h","h",10, 0., 10., 20, -5., 5.) would correspond to 
```
Int_t bins[2] = {10, 20};
Double_t xmin[2] = {0., -5.};
Double_t xmax[2] = {10., 5.};
THnSparseD hs("hs", "hs", 2, bins, xmin, xmax);
```  

## Filling

A [THnSparse](@ref) is filled just like a regular histogram, using THnSparse!Fill(x, weight), where x is a n-dimensional Double_t value. To take errors into account, [Sumw2()](@ref) must be called before filling the histogram.

Bins are allocated as needed; the status of the allocation can be observed by [GetSparseFractionBins()](@ref), [GetSparseFractionMem()](@ref).

## Fast Bin Content Access

When iterating over a [THnSparse](@ref) one should only look at filled bins to save processing time. The number of filled bins is returned by [THnSparse!GetNbins()](@ref); the bin content for each (linear) bin number can be retrieved by THnSparse!GetBinContent(linidx, (Int_t*)coord). After the call, coord will contain the bin coordinate of each axis for the bin with linear index linidx. A possible call would be

std!cout << hs.GetBinContent(0, coord); std!cout <<" is the content of bin [x = " << coord[0] "
        << " | y = " << coord[1] << "]" << std!endl;

@subsection autotoc_md366 Efficiency
TH1 and TH2 are generally faster than THnSparse for one and two dimensional
distributions. THnSparse becomes competitive for a sparsely filled TH3
with large numbers of bins per dimension. The tutorial sparsehist.C
shows the turning point. On a AMD64 with 8GB memory, THnSparse "wins" starting with a [TH3](@ref) with 30 bins per dimension. Using a [THnSparse](@ref) for a one-dimensional histogram is only reasonable if it has a huge number of bins.

## Projections

The dimensionality of a [THnSparse](@ref) can be reduced by projecting it to 1, 2, 3, or n dimensions, which can be represented by a [TH1](@ref), [TH2](@ref), [TH3](@ref), or a [THnSparse](@ref). See the [Projection()](@ref) members. To only project parts of the histogram, call 
```
THnSparse!GetAxis(12)->SetRange(from_bin, to_bin);
```  

## Internal Representation

An entry for a filled bin consists of its n-dimensional coordinates and its bin content. The coordinates are compacted to use as few bits as possible; e.g. a histogram with 10 bins in x and 20 bins in y will only use 4 bits for the x representation and 5 bits for the y representation. This is handled by the internal class [THnSparseCompactBinCoord](@ref). Bin data (content and coordinates) are allocated in chunks of size fChunkSize; this parameter can be set when constructing a [THnSparse](@ref). Each chunk is represented by an object of class [THnSparseArrayChunk](@ref).

Translation from an n-dimensional bin coordinate to the linear index within the chunks is done by [GetBin()](@ref). It creates a hash from the compacted bin coordinates (the hash of a bin coordinate is the compacted coordinate itself if it takes less than 8 bytes, the size of a Long64_t. This hash is used to lookup the linear index in the [TExMap](@ref) member fBins; the coordinates of the entry fBins points to is compared to the coordinates passed to [GetBin()](@ref). If they do not match, these two coordinates have the same hash - which is extremely unlikely but (for the case where the compact bin coordinates are larger than 4 bytes) possible. In this case, fBinsContinued contains a chain of linear indexes with the same hash. Iterating through this chain and comparing each bin coordinates with the one passed to [GetBin()](@ref) will retrieve the matching bin.

Related functions: [`AddBinContent`](@ref), [`AddBinError2`](@ref), [`ClassDefOverride`](@ref), [`CreateIter`](@ref), [`GetBinContent`](@ref), [`GetBinError2`](@ref), [`GetBin`](@ref), [`GetChunkSize`](@ref), [`GetNChunks`](@ref), [`GetNbins`](@ref), [`GetSparseFractionBins`](@ref), [`GetSparseFractionMem`](@ref), [`Projection`](@ref), [`Rebin`](@ref), [`Reset`](@ref), [`SetBinContent`](@ref), [`SetBinError2`](@ref), [`SetFilledBins`](@ref), [`Sumw2`](@ref), [`THnSparse!CreateSparse`](@ref), [`THnSparse`](@ref)
""" THnSparse

# Wrapper of THnSparseArrayChunk
@trydoc raw"""
    ROOT.THnSparseArrayChunk

[THnSparseArrayChunk](@ref) is used internally by [THnSparse](@ref).

[THnSparse](@ref) stores its (dynamic size) array of bin coordinates and their contents (and possibly errors) in a [TObjArray](@ref) of [THnSparseArrayChunk](@ref). Each of the chunks holds an array of [THnSparseCompactBinCoord](@ref) and the content (a TArray*), which is created outside (by the templated derived classes of [THnSparse](@ref)) and passed in at construction time.

Related functions: [`AddBinContent`](@ref), [`AddBin`](@ref), [`ClassDefOverride`](@ref), [`GetEntries`](@ref), [`Matches`](@ref), [`Sumw2`](@ref), [`THnSparseArrayChunk`](@ref)
""" THnSparseArrayChunk

# Wrapper of THnSparseT
@trydoc raw"""
    ROOT.THnSparseT

Templated implementation of the abstract base [THnSparse](@ref).

All functionality and the interfaces to be used are in THnSparse!

[THnSparse](@ref) does not know how to store any bin content itself. Instead, this is delegated to the derived, templated class: the template parameter decides what the format for the bin content is. In fact it even defines the array itself; possible implementations probably derive from [TArray](@ref).

Typedefs exist for template parameters with [ROOT](@ref)'s generic types:

| **Templated name**    | **Typedef** | **Bin content type** |
|:----------------------|:------------|:---------------------|
| THnSparseT<TArrayC>   | THnSparseC  | Char_t               |
| THnSparseT<TArrayS>   | THnSparseS  | Short_t              |
| THnSparseT<TArrayI>   | THnSparseI  | Int_t                |
| THnSparseT<TArrayL64> | THnSparseL  | Long64_t             |
| THnSparseT<TArrayF>   | THnSparseF  | Float_t              |
| THnSparseT<TArrayD>   | THnSparseD  | Double_t             |

We recommend to use THnSparseC wherever possible, and to map its value space of 256 possible values to e.g. float values outside the class. This saves an enormous amount of memory. Only if more than 256 values need to be distinguished should e.g. THnSparseS or even THnSparseF be chosen.

Implementation detail: the derived, templated class is kept extremely small on purpose. That way the (templated thus inlined) uses of this class will only create a small amount of machine code, in contrast to e.g. STL.

Related functions: [`GenerateArray`](@ref), [`THnSparse`](@ref)
""" THnSparseT

# Wrapper of THStack
@trydoc raw"""
    ROOT.THStack

The Histogram stack class.

A [THStack](@ref) is a collection of [TH1](@ref) or [TH2](@ref) histograms. By using [THStack!Draw()](@ref), the entire histogram collection is drawn at once according to the specified drawing option.

[THStack!Add()](@ref) allows adding a new histogram to the list. Note that the [THStack](@ref) does not take ownership of the objects in the list.

### Stack painting

By default, histograms are shown stacked:

- the first histogram is painted
- then the sum of the first and second histograms is painted, and so on

The axis ranges are computed automatically along the X and Y axes to display the complete histogram collection.

Warning: Histogram bins with negative content may produce wrong plots.

### Stack's drawing options

The specific stack's drawing options are:

- **NOSTACK** If option "nostack" is specified, histograms are all painted in the same pad as if the option "same" had been specified.
- **NOSTACKB** If the option "nostackb" is specified histograms are all painted on the same pad next to each other as bar plots.
- **PADS** if option "pads" is specified, the current pad/canvas is subdivided into a number of pads equal to the number of histograms and each histogram is painted into a separate pad.
- **NOCLEAR** By default the background of the histograms is erased before drawing the histograms. The option "noclear" avoids this behavior. This is useful when drawing a [THStack](@ref) on top of another plot. If the patterns used to draw the histograms in the stack are transparent, then the plot behind will be visible.

See the [THistPainter](@ref) class for the list of valid histograms' painting options.

Example;

(C++ version of the code)

![https://root.cern/doc/v636/pict1_THStack_001.png](https://root.cern/doc/v636/pict1_THStack_001.png)

A more complex example:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_THStack_002.png](https://root.cern/doc/v636/pict1_THStack_002.png)

Note that picking is supported for all drawing modes.

###Since

ROOT version 6.07/07: Stacks of 2D histograms can also be painted as candle plots: 

###Since

ROOT version 6.09/02: Stacks of 2D histograms can also be painted as violin plots, combinations of candle and violin plots are possible as well:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_THStack_003.png](https://root.cern/doc/v636/pict1_THStack_003.png)

Automatic coloring according to the current palette is available as shown in the following example:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_THStack_004.png](https://root.cern/doc/v636/pict1_THStack_004.png)

Related functions: [`Add`](@ref), [`Browse`](@ref), [`BuildPrimitives`](@ref), [`DistancetoPrimitive`](@ref), [`Draw`](@ref), [`GetHistogram`](@ref), [`GetHists`](@ref), [`GetMaximum`](@ref), [`GetMinimum`](@ref), [`GetNhists`](@ref), [`GetStack`](@ref), [`GetXaxis`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`Merge`](@ref), [`Modified`](@ref), [`Paint`](@ref), [`Print`](@ref), [`RecursiveRemove`](@ref), [`SavePrimitive`](@ref), [`SetHistogram`](@ref), [`SetMaximum`](@ref), [`SetMinimum`](@ref), [`THStack`](@ref), [`ls`](@ref), [`thebegin`](@ref), [`theend`](@ref)
""" THStack

# Wrapper of TIter
@trydoc raw"""
    ROOT.TIter





Related functions: [`Base.:(!=)`](@ref), [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`Begin`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`TIter!End`](@ref), [`TIter`](@ref), [`assign`](@ref), [`inc!`](@ref), [`paren`](@ref)
""" TIter

# Wrapper of TIterator
@trydoc raw"""
    ROOT.TIterator

Iterator abstract base class.

This base class provides the interface for collection iterators. 

###Note

See TList documentation for examples of derived classes and on how to loop with these iterators, and TCollection documentation for more modern alternatives that dynamically cast the derived class.

Related functions: [`Base.:(!=)`](@ref), [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`GetCollection`](@ref), [`GetOption`](@ref), [`Next`](@ref), [`Reset`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TIterator

# Wrapper of TKDE
@trydoc raw"""
    ROOT.TKDE

Kernel Density Estimation class.

The three main references are:

1. "Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley",
2. "Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:
   Stata themodule for univariate kernel density estimation."
3. "Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer."
4. "Cranmer KS, Kernel Estimation in High-Energy
Physics. Computer Physics Communications 136:198-207,2001" - e-Print Archive: hep ex/0011057.

The algorithm is briefly described in (4). A binned version is also implemented to address the performance issue due to its data size dependance.

Related functions: [`Draw`](@ref), [`Fill`](@ref), [`GetAdaptiveWeights`](@ref), [`GetApproximateBias`](@ref), [`GetBias`](@ref), [`GetError`](@ref), [`GetFixedWeight`](@ref), [`GetFunction`](@ref), [`GetGraphWithErrors`](@ref), [`GetLowerFunction`](@ref), [`GetMean`](@ref), [`GetRAMISE`](@ref), [`GetSigma`](@ref), [`GetUpperFunction`](@ref), [`GetValue`](@ref), [`SetBinning`](@ref), [`SetIteration`](@ref), [`SetKernelType`](@ref), [`SetMirror`](@ref), [`SetNBins`](@ref), [`SetRange`](@ref), [`SetTuneFactor`](@ref), [`SetUseBinsNEvents`](@ref), [`TKDE`](@ref), [`paren`](@ref)
""" TKDE

# Wrapper of TLimit
@trydoc raw"""
    ROOT.TLimit

Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method.

Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006]. See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details.

It takes signal, background and data histograms wrapped in a [TLimitDataSource](@ref) as input and runs a set of Monte Carlo experiments in order to compute the limits. If needed, inputs are fluctuated according to systematics. The output is a [TConfidenceLevel](@ref).

The class [TLimitDataSource](@ref) takes the signal, background and data histograms as well as different systematics sources to form the [TLimit](@ref) input.

The class [TConfidenceLevel](@ref) represents the final result of the [TLimit](@ref) algorithm. It is created just after the time-consuming part and can be stored in a [TFile](@ref) for further processing. It contains light methods to return CLs, CLb and other interesting quantities.

The actual algorithm...

From an input ([TLimitDataSource](@ref)) it produces an output [TConfidenceLevel](@ref). For this, nmc Monte Carlo experiments are performed. As usual, the larger this number, the longer the compute time, but the better the result.

Supposing that there is a plotfile.root file containing 3 histograms (signal, background and data), you can imagine doing things like:

    TFile* infile=new TFile("plotfile.root","READ");
    infile->cd();
    TH1* sh=(TH1*)infile->Get("signal");
    TH1* bh=(TH1*)infile->Get("background");
    TH1* dh=(TH1*)infile->Get("data");
    TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);
    TConfidenceLevel *myconfidence = TLimit!ComputeLimit(mydatasource,50000);
    std!cout << "  CLs    : " << myconfidence->CLs()  << std!endl;
    std!cout << "  CLsb   : " << myconfidence->CLsb() << std!endl;
    std!cout << "  CLb    : " << myconfidence->CLb()  << std!endl;
    std!cout << "< CLs >  : " << myconfidence->GetExpectedCLs_b()  << std!endl;
    std!cout << "< CLsb > : " << myconfidence->GetExpectedCLsb_b() << std!endl;
    std!cout << "< CLb >  : " << myconfidence->GetExpectedCLb_b()  << std!endl;
    delete myconfidence;
    delete mydatasource;
    infile->Close();

(C++ version of the code)

 More information can still be found on [this page](http://cern.ch/aleph-proj-alphapp/doc/tlimit.html) 

###See

https://doi.org/10.1088/0954-3899/28/10/313, https://cds.cern.ch/record/451614/files/open-2000-205.pdf 

###Note

see note about: "Should I use TRolke, TFeldmanCousins, TLimit?" in the TRolke class description.

Related functions: [`TLimit!ComputeLimit`](@ref), [`TLimit`](@ref)
""" TLimit

# Wrapper of TLimitDataSource
@trydoc raw"""
    ROOT.TLimitDataSource

This class serves as input for the [TLimit!ComputeLimit](@ref) method.

It takes the signal, background and data histograms to form a channel. More channels can be added using [AddChannel()](@ref), as well as different systematics sources.

Related functions: [`AddChannel`](@ref), [`GetBackground`](@ref), [`GetCandidates`](@ref), [`GetErrorNames`](@ref), [`GetErrorOnBackground`](@ref), [`GetErrorOnSignal`](@ref), [`GetSignal`](@ref), [`SetOwner`](@ref), [`TLimitDataSource`](@ref)
""" TLimitDataSource

# Wrapper of TMultiDimFit
@trydoc raw"""
    ROOT.TMultiDimFit

Multidimensional Fits in [ROOT](@ref).

## Overview

A common problem encountered in different fields of applied science is to find an expression for one physical quantity in terms of several others, which are directly measurable.

An example in high energy physics is the evaluation of the momentum of a charged particle from the observation of its trajectory in a magnetic field. The problem is to relate the momentum of the particle to the observations, which may consists of positional measurements at intervals along the particle trajectory.

The exact functional relationship between the measured quantities (e.g., the space-points) and the dependent quantity (e.g., the momentum) is in general not known, but one possible way of solving the problem, is to find an expression which reliably approximates the dependence of the momentum on the observations.

This explicit function of the observations can be obtained by a *least squares* fitting procedure applied to a representative sample of the data, for which the dependent quantity (e.g., momentum) and the independent observations are known. The function can then be used to compute the quantity of interest for new observations of the independent variables.

This class `TMultiDimFit` implements such a procedure in [ROOT](@ref). It is largely based on the CERNLIB MUDIFI package [2](classTMultiDimFit.html#mudifi). Though the basic concepts are still sound, and therefore kept, a few implementation details have changed, and this class can take advantage of MINUIT [4](classTMultiDimFit.html#minuit) to improve the errors of the fitting, thanks to the class [TMinuit](@ref).

In [5](classTMultiDimFit.html#wind72) and [6](classTMultiDimFit.html#wind81) H. Wind demonstrates the utility of this procedure in the context of tracking, magnetic field parameterisation, and so on. The outline of the method used in this class is based on Winds discussion, and I refer these two excellents text for more information.

And example of usage is given in multidimfit.C.

## The Method

Let $ D $ by the dependent quantity of interest, which depends smoothly on the observable quantities $ x_1, \ldots, x_N $ which we'll denote by $\mathbf{x}$. Given a training sample of $ M$ tuples of the form, ([TMultiDimFit!AddRow](@ref))

``\left(\mathbf{x}_j, D_j, E_j\right)\quad,``

 where $\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})$ are $ N$ independent variables, $ D_j$ is the known, quantity dependent at $\mathbf{x}_j$ and $ E_j$ is the square error in $ D_j$, the class will try to find the parameterization 

``D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right)
     = \sum_{l=1}^{L} c_l F_l(\mathbf{x})``

 such that

``S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2``

 is minimal. Here $p_{li}(x_i)$ are monomials, or Chebyshev or Legendre polynomials, labelled $l = 1, \ldots, L$, in each variable $ x_i$, $ i=1, \ldots, N$.

So what [TMultiDimFit](@ref) does, is to determine the number of terms $ L$, and then $ L$ terms (or functions) $ F_l$, and the $ L$ coefficients $ c_l$, so that $ S$ is minimal ([TMultiDimFit!FindParameterization](@ref)).

Of course it's more than a little unlikely that $ S$ will ever become exact zero as a result of the procedure outlined below. Therefore, the user is asked to provide a minimum relative error $ \epsilon$ ([TMultiDimFit!SetMinRelativeError](@ref)), and $ S$ will be considered minimized when

``R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon``

 Optionally, the user may impose a functional expression by specifying the powers of each variable in $ L$ specified functions $ F_1, \ldots,F_L$ ([TMultiDimFit!SetPowers](@ref)). In that case, only the coefficients $ c_l$ is calculated by the class.

## Limiting the Number of Terms

As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's always possible to fit an $ N-1$ polynomial in $ x$ to $ N$ points $ (x,y)$ with $\chi^2 = 0$, but the polynomial is not likely to fit new data at all [1](classTMultiDimFit.html#bevington). Therefore, the user is asked to provide an upper limit, $ L_{max}$ to the number of terms in $ D_p$ ([TMultiDimFit!SetMaxTerms](@ref)).

However, since there's an infinite number of $ F_l$ to choose from, the user is asked to give the maximum power. $ P_{max,i}$, of each variable $ x_i$ to be considered in the minimization of $ S$ ([TMultiDimFit!SetMaxPowers](@ref)).

One way of obtaining values for the maximum power in variable $ i$, is to perform a regular fit to the dependent quantity $ D$, using a polynomial only in $ x_i$. The maximum power is $ P_{max,i}$ is then the power that does not significantly improve the one-dimensional least-square fit over $ x_i$ to $ D$ [5](classTMultiDimFit.html#wind72).

There are still a huge amount of possible choices for $ F_l$; in fact there are $\prod_{i=1}^{N} (P_{max,i} + 1)$ possible choices. Obviously we need to limit this. To this theend, the user is asked to set a *power control limit*, $ Q$ ([TMultiDimFit!SetPowerLimit](@ref)), and a function $ F_l$ is only accepted if 

``Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q``

 where $ P_{li}$ is the leading power of variable $ x_i$ in function $ F_l$ ([TMultiDimFit!MakeCandidates](@ref)). So the number of functions increase with $ Q$ (1, 2 is fine, 5 is way out).

## Gram-Schmidt Orthogonalisation

To further reduce the number of functions in the final expression, only those functions that significantly reduce $ S$ is chosen. What 'significant' means, is chosen by the user, and will be discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)).

The functions $ F_l$ are generally not orthogonal, which means one will have to evaluate all possible $ F_l$'s over all data-points before finding the most significant [1](classTMultiDimFit.html#bevington). We can, however, do better then that. By applying the *modified Gram-Schmidt orthogonalisation* algorithm [5] [3] to the functions $ F_l$, we can evaluate the contribution to the reduction of $ S$ from each function in turn, and we may delay the actual inversion of the curvature-matrix ([TMultiDimFit!MakeGramSchmidt](@ref)).

So we are let to consider an $ M\times L$ matrix $\mathsf{F}$, an element of which is given by 

``f_{jl} = F_j\left(x_{1j} , x_{2j}, \ldots, x_{Nj}\right)
   = F_l(\mathbf{x}_j)\,  \quad\mbox{with}~j=1,2,\ldots,M,``

 where $ j$ labels the $ M$ rows in the training sample and $ l$ labels $ L$ functions of $ N$ variables, and $ L \leq M$. That is, $ f_{jl}$ is the term (or function) numbered $ l$ evaluated at the data point $ j$. We have to normalise $\mathbf{x}_j$ to $ [-1,1]$ for this to succeed [5] ([TMultiDimFit!MakeNormalized](@ref)). We then define a matrix $\mathsf{W}$ of which the columns $\mathbf{w}_j$ are given by \thebegin{eqnarray*}
   \mathbf{w}_1 &=& \mathbf{f}_1 = F_1\left(\mathbf x_1\right)\\
   \mathbf{w}_l &=& \mathbf{f}_l - \sum^{l-1}_{k=1} \frac{\mathbf{f}_l \bullet
   \mathbf{w}_k}{\mathbf{w}_k^2}\mathbf{w}_k\,.
 \theend{eqnarray*} and $\mathbf{w}_{l}$ is the component of $\mathbf{f}_{l} $ orthogonal to $\mathbf{w}_{1}, \ldots, \mathbf{w}_{l-1}$. Hence we obtain [3], 

``\mathbf{w}_k\bullet\mathbf{w}_l = 0\quad\mbox{if}~k \neq l\quad.``

 We now take as a new model $\mathsf{W}\mathbf{a}$. We thus want to minimize 

``S\equiv \left(\mathbf{D} - \mathsf{W}\mathbf{a}\right)^2\quad,``

 where $\mathbf{D} = \left(D_1,\ldots,D_M\right)$ is a vector of the dependent quantity in the sample. Differentiation with respect to $ a_j$ gives, using [6](classTMultiDimFit.html#wind81),  

``\mathbf{D}\bullet\mathbf{w}_l - a_l\mathbf{w}_l^2 = 0``

 or 

``a_l = \frac{\mathbf{D}_l\bullet\mathbf{w}_l}{\mathbf{w}_l^2}``

 Let $ S_j$ be the sum of squares of residuals when taking $ j$ functions into account. Then 

``S_l = \left[\mathbf{D} - \sum^l_{k=1} a_k\mathbf{w}_k\right]^2
   = \mathbf{D}^2 - 2\mathbf{D} \sum^l_{k=1} a_k\mathbf{w}_k
   + \sum^l_{k=1} a_k^2\mathbf{w}_k^2``

 Using [9](classTMultiDimFit.html#eq:dS2), we see that \thebegin{eqnarray*}
   S_l &=& \mathbf{D}^2 - 2 \sum^l_{k=1} a_k^2\mathbf{w}_k^2 +
   \sum^j_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\
   &=& \mathbf{D}^2 - \sum^l_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\
   &=& \mathbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf
   w_k\right)}{\mathbf w_k^2}
 \theend{eqnarray*} So for each new function $ F_l$ included in the model, we get a reduction of the sum of squares of residuals of $a_l^2\mathbf{w}_l^2$, where $\mathbf{w}_l$ is given by [4](classTMultiDimFit.html#minuit) and $ a_l$ by [9](classTMultiDimFit.html#eq:dS2). Thus, using the Gram-Schmidt orthogonalisation, we can decide if we want to include this function in the final model, before* the matrix inversion.

## Function Selection Based on Residual

Supposing that $ L-1$ steps of the procedure have been performed, the problem now is to consider the $L^{\mbox{th}}$ function.

The sum of squares of residuals can be written as 

``S_L = \textbf{D}^T\bullet\textbf{D} -
   \sum^L_{l=1}a^2_l\left(\textbf{w}_l^T\bullet\textbf{w}_l\right)``

 where the relation [9](classTMultiDimFit.html#eq:dS2) have been taken into account. The contribution of the $L^{\mbox{th}}$ function to the reduction of S, is given by 

``\Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right)``

 Two test are now applied to decide whether this $L^{\mbox{th}}$ function is to be included in the final expression, or not.

## Test 1

Denoting by $ H_{L-1}$ the subspace spanned by $\textbf{w}_1,\ldots,\textbf{w}_{L-1}$ the function $\textbf{w}_L$ is by construction (see 4) the projection of the function $ F_L$ onto the direction perpendicular to $ H_{L-1}$. Now, if the length of $\textbf{w}_L$ (given by $\textbf{w}_L\bullet\textbf{w}_L$) is very small compared to the length of $\textbf{f}_L$ this new function can not contribute much to the reduction of the sum of squares of residuals. The test consists then in calculating the angle $ \theta $ between the two vectors $\textbf{w}_L$ $ \textbf {f}_L$ (see also figure 1) and requiring that it's greater* then a threshold value which the user must set ([TMultiDimFit!SetMinAngle](@ref)).

![https://root.cern/doc/v636/multidimfit_img86.gif](https://root.cern/doc/v636/multidimfit_img86.gif)

## Test 2

Let $\textbf{D}$ be the data vector to be fitted. As illustrated in figure 1, the $L^{\mbox{th}}$ function $\textbf{w}_L$ will contribute significantly to the reduction of $ S$, if the angle $\phi^\prime$ between $\textbf{w}_L$ and $\textbf{D}$ is smaller than an upper limit $ \phi $, defined by the user (MultiDimFit!SetMaxAngle)

However, the method automatically readjusts the value of this angle while fitting is in progress, in order to make the selection criteria less and less difficult to be fulfilled. The result is that the functions contributing most to the reduction of $ S$ are chosen first ([TMultiDimFit!TestFunction](@ref)).

In case $ \phi $ isn't defined, an alternative method of performing this second test is used: The $L^{\mbox{th}}$ function $\textbf{f}_L$ is accepted if (refer also to equation (13)) 

``\Delta S_L > \frac{S_{L-1}}{L_{max}-L}``

 where $ S_{L-1}$ is the sum of the $ L-1$ first residuals from the $ L-1$ functions previously accepted; and $ L_{max}$ is the total number of functions allowed in the final expression of the fit (defined by user).

From this we see, that by restricting $ L_{max}$ – the number of terms in the final model – the fit is more difficult to perform, since the above selection criteria is more limiting.

The more coefficients we evaluate, the more the sum of squares of residuals $ S$ will be reduced. We can evaluate $ S$ before inverting $\mathsf{B}$ as shown below.

## Coefficients and Coefficient Errors

Having found a parameterization, that is the $ F_l$'s and $ L$, that minimizes $ S$, we still need to determine the coefficients $ c_l$. However, it's a feature of how we choose the significant functions, that the evaluation of the $ c_l$'s becomes trivial [5](classTMultiDimFit.html#wind72). To derive $\mathbf{c}$, we first note that equation (4) can be written as 

``\mathsf{F} = \mathsf{W}\mathsf{B}``

 where \thebegin{eqnarray*}
   b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}
     & \mbox{if} & i < j\\
   1 & \mbox{if} & i = j\\
   0 & \mbox{if} & i > j
 \theend{eqnarray*} Consequently, $\mathsf{B}$ is an upper triangle matrix, which can be readily inverted. So we now evaluate 

``\mathsf{F}\mathsf{B}^{-1} = \mathsf{W}``

 The model $\mathsf{W}\mathbf{a}$ can therefore be written as $(\mathsf{F}\mathsf{B}^{-1})\mathbf{a} = \mathsf{F}(\mathsf{B}^{-1}\mathbf{a})\,.$

The original model $\mathsf{F}\mathbf{c}$ is therefore identical with this if 

``\mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =
   \left[\mathbf{a}^T\left(\mathsf{B}^{-1}\right)^T\right]^T\,.``

 The reason we use $\left(\mathsf{B}^{-1}\right)^T$ rather then $\mathsf{B}^{-1}$ is to save storage, since $\left(\mathsf{B}^{-1}\right)^T$ can be stored in the same matrix as $\mathsf{B}$ ([TMultiDimFit!MakeCoefficients](@ref)). The errors in the coefficients is calculated by inverting the curvature matrix of the non-orthogonal functions $ f_{lj}$ [1] ([TMultiDimFit!MakeCoefficientErrors](@ref)).

## Considerations

It's important to realize that the training sample should be representative of the problem at hand, in particular along the borders of the region of interest. This is because the algorithm presented here, is a *interpolation*, rather then a *extrapolation* [5](classTMultiDimFit.html#wind72).

Also, the independent variables $ x_{i}$ need to be linear independent, since the procedure will perform poorly if they are not [5](classTMultiDimFit.html#wind72). One can find an linear transformation from ones original variables $ \xi_{i}$ to a set of linear independent variables $ x_{i}$, using a *Principal Components Analysis* (see [TPrincipal](@ref)), and then use the transformed variable as input to this class [5] [6](classTMultiDimFit.html#wind81).

H. Wind also outlines a method for parameterising a multidimensional dependence over a multidimensional set of variables. An example of the method from [5](classTMultiDimFit.html#wind72), is a follows (please refer to [5](classTMultiDimFit.html#wind72) for a full discussion):

1. Define $\mathbf{P} = (P_1, \ldots, P_5)$ are the 5 dependent quantities that define a track.
2. Compute, for $ M$ different values of $\mathbf{P}$, the tracks through the magnetic field, and determine the corresponding $\mathbf{x} = (x_1, \ldots, x_N)$.
3. Use the simulated observations to determine, with a simple approximation, the values of $\mathbf{P}_j$. We call these values $\mathbf{P}^\prime_j, j = 1, \ldots, M$.
4. Determine from $\mathbf{x}$ a set of at least five relevant coordinates $\mathbf{x}^\prime$, using contrains, *or alternative:*
5. Perform a Principal Component Analysis (using [TPrincipal](@ref)), and use to get a linear transformation $\mathbf{x} \rightarrow \mathbf{x}^\prime$, so that $\mathbf{x}^\prime$ are constrained and linear independent.
6. Perform a Principal Component Analysis on $Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5$, to get linear indenpendent (among themselves, but not independent of $\mathbf{x}$) quantities $\mathbf{Q}^\prime$
7. For each component $Q^\prime_i$ make a multidimensional fit, using $\mathbf{x}^\prime$ as the variables, thus determining a set of coefficients $\mathbf{c}_i$.

To process data, using this parameterisation, do

1. Test wether the observation $\mathbf{x}$ within the domain of the parameterization, using the result from the Principal Component Analysis.
2. Determine $\mathbf{P}^\prime$ as before.
3. Determine $\mathbf{x}^\prime$ as before.
4. Use the result of the fit to determine $\mathbf{Q}^\prime$.
5. Transform back to $\mathbf{P}$ from $\mathbf{Q}^\prime$, using the result from the Principal Component Analysis.

## Testing the parameterization

The class also provides functionality for testing the, over the training sample, found parameterization ([TMultiDimFit!Fit](@ref)). This is done by passing the class a test sample of $ M_t$ tuples of the form $(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})$, where $\mathbf{x}_{t,j}$ are the independent variables, $ D_{t,j}$ the known, dependent quantity, and $ E_{t,j}$ is the square error in $ D_{t,j}$ ([TMultiDimFit!AddTestRow](@ref)).

The parameterization is then evaluated at every $\mathbf{x}_t$ in the test sample, and 

``S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -
   D_p\left(\mathbf{x}_{t,j}\right)\right)^2``

 is evaluated. The relative error over the test sample 

``R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}``

 should not be to low or high compared to $ R$ from the training sample. Also, multiple correlation coefficient from both samples should be fairly close, otherwise one of the samples is not representative of the problem. A large difference in the reduced $ \chi^2$ over the two samples indicate an over fit, and the maximum number of terms in the parameterisation should be reduced.

It's possible to use [4](classTMultiDimFit.html#minuit) to further improve the fit, using the test sample.

Christian Holm

## Bibliography

-  Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for the Physical Sciences*. McGraw-Hill, 2 edition, 1992.
-  R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.
- Gene H. Golub and Charles F. van Loan. *Matrix Computations*. John Hopkins University Press, Baltimore, 3 edition, 1996.
- F. James. *Minuit*. Long writeup D506, CERN, 1998.
- H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing School, volume 72-21 of Yellow report. CERN, 1972.
- H. Wind. 1. principal component analysis, 2. pattern recognition for track finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981.

Related functions: [`AddRow`](@ref), [`AddTestRow`](@ref), [`Browse`](@ref), [`Clear`](@ref), [`Draw`](@ref), [`EvalError`](@ref), [`Eval`](@ref), [`FindParameterization`](@ref), [`Fit`](@ref), [`GetChi2`](@ref), [`GetCoefficientsRMS`](@ref), [`GetCoefficients`](@ref), [`GetCorrelationMatrix`](@ref), [`GetError`](@ref), [`GetFunctionCodes`](@ref), [`GetFunctions`](@ref), [`GetHistograms`](@ref), [`GetMaxAngle`](@ref), [`GetMaxFunctions`](@ref), [`GetMaxPowers`](@ref), [`GetMaxQuantity`](@ref), [`GetMaxStudy`](@ref), [`GetMaxTerms`](@ref), [`GetMaxVariables`](@ref), [`GetMeanQuantity`](@ref), [`GetMeanVariables`](@ref), [`GetMinAngle`](@ref), [`GetMinQuantity`](@ref), [`GetMinRelativeError`](@ref), [`GetMinVariables`](@ref), [`GetNCoefficients`](@ref), [`GetNVariables`](@ref), [`GetPolyType`](@ref), [`GetPowerIndex`](@ref), [`GetPowerLimit`](@ref), [`GetPowers`](@ref), [`GetPrecision`](@ref), [`GetQuantity`](@ref), [`GetRMS`](@ref), [`GetResidualMaxRow`](@ref), [`GetResidualMax`](@ref), [`GetResidualMinRow`](@ref), [`GetResidualMin`](@ref), [`GetResidualSumSq`](@ref), [`GetSampleSize`](@ref), [`GetSqError`](@ref), [`GetSumSqAvgQuantity`](@ref), [`GetSumSqQuantity`](@ref), [`GetTestError`](@ref), [`GetTestPrecision`](@ref), [`GetTestQuantity`](@ref), [`GetTestSampleSize`](@ref), [`GetTestSqError`](@ref), [`GetTestVariables`](@ref), [`GetVariables`](@ref), [`IsFolder`](@ref), [`MakeChi2`](@ref), [`MakeCode`](@ref), [`MakeHistograms`](@ref), [`MakeMethod`](@ref), [`Print`](@ref), [`SetBinVarX`](@ref), [`SetBinVarY`](@ref), [`SetMaxAngle`](@ref), [`SetMaxFunctions`](@ref), [`SetMaxPowers`](@ref), [`SetMaxStudy`](@ref), [`SetMaxTerms`](@ref), [`SetMinAngle`](@ref), [`SetMinRelativeError`](@ref), [`SetPowerLimit`](@ref), [`SetPowers`](@ref), [`TMultiDimFit!Instance`](@ref), [`TMultiDimFit`](@ref)
""" TMultiDimFit

# Wrapper of TMatrixT
@trydoc raw"""
    ROOT.TMatrixT

[TMatrixT](@ref).

Template class of a general matrix in the linear algebra package

See the [Matrix Linear Algebra](@ref) page for the documentation of the linear algebra package

Related functions: [`Base.getindex`](@ref), [`Class`](@ref), [`Clear`](@ref), [`Determinant`](@ref), [`EigenVectors`](@ref), [`GetColIndexArray`](@ref), [`GetMatrixArray`](@ref), [`GetRowIndexArray`](@ref), [`GetSub`](@ref), [`InvertFast`](@ref), [`Invert`](@ref), [`Minus`](@ref), [`MultT`](@ref), [`Mult`](@ref), [`NormByColumn`](@ref), [`NormByRow`](@ref), [`Plus`](@ref), [`Rank1Update`](@ref), [`ResizeTo`](@ref), [`SetColIndexArray`](@ref), [`SetElement`](@ref), [`SetRowIndexArray`](@ref), [`SetSub`](@ref), [`Similarity`](@ref), [`TMatrixT`](@ref), [`TMult`](@ref), [`T`](@ref), [`Transpose`](@ref), [`Use`](@ref), [`add!`](@ref), [`assign`](@ref), [`fdiv!`](@ref), [`mult!`](@ref), [`paren`](@ref), [`sub!`](@ref)
""" TMatrixT

# Wrapper of TMatrixTSym
@trydoc raw"""
    ROOT.TMatrixTSym

[TMatrixTSym](@ref).

Template class of a symmetric matrix in the linear algebra package.

See the [Matrix Linear Algebra](@ref) page for the documentation of the linear algebra package

Note that in this implementation both matrix element m[i][j] and m[j][i] are updated and stored in memory. However, when making the object persistent only the upper right triangle is stored.

Related functions: [`Apply`](@ref), [`Base.getindex`](@ref), [`Class`](@ref), [`Clear`](@ref), [`Determinant`](@ref), [`EigenVectors`](@ref), [`GetColIndexArray`](@ref), [`GetMatrixArray`](@ref), [`GetRowIndexArray`](@ref), [`GetSub`](@ref), [`InvertFast`](@ref), [`Invert`](@ref), [`IsSymmetric`](@ref), [`Minus`](@ref), [`Mult`](@ref), [`Plus`](@ref), [`RandomizePD`](@ref), [`Randomize`](@ref), [`Rank1Update`](@ref), [`ResizeTo`](@ref), [`SetColIndexArray`](@ref), [`SetElement`](@ref), [`SetMatrixArray`](@ref), [`SetRowIndexArray`](@ref), [`SetSub`](@ref), [`Shift`](@ref), [`SimilarityT`](@ref), [`Similarity`](@ref), [`TMatrixTSym`](@ref), [`TMult`](@ref), [`T`](@ref), [`Transpose`](@ref), [`Use`](@ref), [`add!`](@ref), [`assign`](@ref), [`mult!`](@ref), [`paren`](@ref), [`sub!`](@ref)
""" TMatrixTSym

# Wrapper of TPolyMarker
@trydoc raw"""
    ROOT.TPolyMarker

A PolyMarker is defined by an array on N points in a 2-D space.

At each point x[i], y[i] a marker is drawn. Marker attributes are managed by [TAttMarker](@ref). See [TMarker](@ref) for the list of possible marker types.

Related functions: [`Copy`](@ref), [`DistancetoPrimitive`](@ref), [`DrawPolyMarker`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetLastPoint`](@ref), [`GetN`](@ref), [`GetOption`](@ref), [`GetX`](@ref), [`GetY`](@ref), [`Merge`](@ref), [`PaintPolyMarker`](@ref), [`Paint`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetNextPoint`](@ref), [`SetPoint`](@ref), [`SetPolyMarker`](@ref), [`Size`](@ref), [`TPolyMarker`](@ref), [`ls`](@ref)
""" TPolyMarker

# Wrapper of TProfile2Poly
@trydoc raw"""
    ROOT.TProfile2Poly

2D Profile Histogram with Polygonal Bins.

tprofile2polyRealisticModuleError.C and tprofile2polyRealistic.C illustrate how to use this class.

Related functions: [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntriesVW`](@ref), [`GetBinEntriesW2`](@ref), [`GetBinEntriesWV2`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetOverflowContent`](@ref), [`GetStats`](@ref), [`Merge`](@ref), [`PrintOverflowRegions`](@ref), [`Reset`](@ref), [`SetContentToAverage`](@ref), [`SetContentToError`](@ref), [`SetErrorOption`](@ref), [`TProfile2Poly`](@ref)
""" TProfile2Poly

# Wrapper of TProfile2PolyBin
@trydoc raw"""
    ROOT.TProfile2PolyBin

Helper class to represent a bin in the [TProfile2Poly](@ref) histogram.



Related functions: [`ClearStats`](@ref), [`GetEffectiveEntries`](@ref), [`GetEntriesVW`](@ref), [`GetEntriesW2`](@ref), [`GetEntriesWV2`](@ref), [`GetEntries`](@ref), [`GetError`](@ref), [`Merge`](@ref), [`TProfile2PolyBin`](@ref), [`Update`](@ref)
""" TProfile2PolyBin

# Wrapper of TProfile3D
@trydoc raw"""
    ROOT.TProfile3D

Profile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z.

Profile3D histograms are in many cases an The inter-relation of three measured quantities X, Y, Z and T can always be visualized by a four-dimensional histogram or scatter-plot; its representation on the line-printer is not particularly satisfactory, except for sparse data. If T is an unknown (but single-valued) approximate function of X,Y,Z this function is displayed by a profile3D histogram with much better precision than by a scatter-plot.

The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 
```
                                                          2
  H(I,J,K)  =  sum T                      E(I,J,K)  =  sum T
  l(I,J,K)  =  sum l                      L(I,J,K)  =  sum l
  h(I,J,K)  =  H(I,J,K)/L(I,J,K)          s(I,J,K)  =  sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2)
  e(I,J,K)  =  s(I,J,K)/sqrt(L(I,J,K))
```  In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell) [e(I,J,K)](@ref) is computed from the average of the s(I,J,K) for all cells, if the static function [TProfile3D!Approximate](@ref) has been called. This simple/crude approximation was suggested in order to keep the cell during a fit operation. But note that this approximation is not the default behaviour.

Example of a profile3D histogram 

    {
        auto c1 = new TCanvas("c1","Profile histogram example",200,10,700,500);
        auto hprof3d  = new TProfile3D("hprof3d","Profile of pt versus px, py and pz",40,-4,4,40,-4,4,40,0,20);
        Double_t px, py, pz, pt;
        TRandom3 r(0);
        for ( Int_t i=0; i<25000; i++) {
           r.Rannor(px,py);
           pz = px*px + py*py;
           pt = r.Landau(0,1);
           hprof3d->Fill(px,py,pz,pt,1);
        }
        hprof3d->Draw();
    }

(C++ version of the code)

 NOTE: A [TProfile3D](@ref) is drawn as it was a simple [TH3](@ref)

Related functions: [`Add`](@ref), [`BufferEmpty`](@ref), [`BuildOptions`](@ref), [`Copy`](@ref), [`Divide`](@ref), [`ExtendAxis`](@ref), [`Fill`](@ref), [`GetBinContent`](@ref), [`GetBinEffectiveEntries`](@ref), [`GetBinEntries`](@ref), [`GetBinError`](@ref), [`GetBinSumw2`](@ref), [`GetErrorOption`](@ref), [`GetStats`](@ref), [`GetTmax`](@ref), [`GetTmin`](@ref), [`LabelsDeflate`](@ref), [`LabelsInflate`](@ref), [`LabelsOption`](@ref), [`Merge`](@ref), [`Multiply`](@ref), [`Project3DProfile`](@ref), [`ProjectionXYZ`](@ref), [`PutStats`](@ref), [`Reset`](@ref), [`SavePrimitive`](@ref), [`Scale`](@ref), [`SetBinEntries`](@ref), [`SetBinsLength`](@ref), [`SetBins`](@ref), [`SetBuffer`](@ref), [`SetErrorOption`](@ref), [`Sumw2`](@ref), [`TProfile3D!Approximate`](@ref), [`TProfile3D`](@ref), [`assign`](@ref)
""" TProfile3D

# Wrapper of TScatter
@trydoc raw"""
    ROOT.TScatter

A [TScatter](@ref) is able to draw four variables scatter plot on a single plot.

The two first variables are the x and y position of the markers, the third is mapped on the current color map and the fourth on the marker size.

The following example demonstrates how it works:

(C++ version of the code)

 ![https://root.cern/doc/v636/pict1_TScatter_001.png](https://root.cern/doc/v636/pict1_TScatter_001.png)

### TScatter's plotting options

[TScatter](@ref) can be drawn with the following options:

| **Option** | **Description**                               |
|:-----------|:----------------------------------------------|
| "A"        | Produce a new plot with Axis around the graph |

Related functions: [`DistancetoPrimitive`](@ref), [`ExecuteEvent`](@ref), [`GetColor`](@ref), [`GetGraph`](@ref), [`GetHistogram`](@ref), [`GetMargin`](@ref), [`GetMaxMarkerSize`](@ref), [`GetMinMarkerSize`](@ref), [`GetSize`](@ref), [`GetXaxis`](@ref), [`GetYaxis`](@ref), [`GetZaxis`](@ref), [`Paint`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetHistogram`](@ref), [`SetMargin`](@ref), [`SetMaxMarkerSize`](@ref), [`SetMinMarkerSize`](@ref), [`TScatter`](@ref)
""" TScatter

# Wrapper of TSplinePoly
@trydoc raw"""
    ROOT.TSplinePoly

Base class for [TSpline](@ref) knot.



Related functions: [`Eval`](@ref), [`GetKnot`](@ref), [`TSplinePoly`](@ref), [`X`](@ref), [`Y`](@ref), [`assign`](@ref)
""" TSplinePoly

# Wrapper of TSplinePoly3
@trydoc raw"""
    ROOT.TSplinePoly3

Class for [TSpline3](@ref) knot.



Related functions: [`B`](@ref), [`C`](@ref), [`D`](@ref), [`Derivative`](@ref), [`Eval`](@ref), [`TSplinePoly3`](@ref), [`assign`](@ref)
""" TSplinePoly3

# Wrapper of TSplinePoly5
@trydoc raw"""
    ROOT.TSplinePoly5

Class for [TSpline5](@ref) knot.



Related functions: [`B`](@ref), [`C`](@ref), [`D`](@ref), [`Derivative`](@ref), [`E`](@ref), [`Eval`](@ref), [`F`](@ref), [`TSplinePoly5`](@ref), [`assign`](@ref)
""" TSplinePoly5

# Wrapper of TSpline3
@trydoc raw"""
    ROOT.TSpline3

Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives at beginning and ending points.



Related functions: [`Derivative`](@ref), [`Eval`](@ref), [`FindX`](@ref), [`GetCoeff`](@ref), [`GetKnot`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SetPointCoeff`](@ref), [`SetPoint`](@ref), [`TSpline3!Test`](@ref), [`TSpline3`](@ref), [`assign`](@ref)
""" TSpline3

# Wrapper of TSpline5
@trydoc raw"""
    ROOT.TSpline5

Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives using double knots (see BuildCoeff) for more on this.

Double knots are automatically introduced at ending points

Related functions: [`Derivative`](@ref), [`Eval`](@ref), [`FindX`](@ref), [`GetCoeff`](@ref), [`GetKnot`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SetPointCoeff`](@ref), [`SetPoint`](@ref), [`TSpline5!Test`](@ref), [`TSpline5`](@ref), [`assign`](@ref)
""" TSpline5

# Wrapper of TSVDUnfold
@trydoc raw"""
    ROOT.TSVDUnfold

SVD Approach to Data Unfolding.

Reference: [Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]](http://arXiv.org/abs/hep-ph/9509307) 

[TSVDUnfold](@ref) implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum. 

The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. 

Monte Carlo inputs: 

- `xini`: true underlying spectrum ([TH1D](@ref), n bins) 
- `bini`: reconstructed spectrum ([TH1D](@ref), n bins) 
- `Adet`: response matrix ([TH2D](@ref), nxn bins) 
Consider the unfolding of a measured spectrum `bdat` with covariance matrix `Bcov` (if not passed explicitly, a diagonal covariance will be built given the errors of `bdat`). The corresponding spectrum in the Monte Carlo is given by `bini`, with the true underlying spectrum given by `xini`. The detector response is described by `Adet`, with `Adet` filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. 

The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of `xini` and `Adet`.<br/>
<br/>
 

The unfolding can be performed by 

    TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );
    TH1D* unfresult = tsvdunf->Unfold( kreg );

(C++ version of the code)

 where `kreg` determines the regularisation of the unfolding. In general, overregularisation (too small `kreg`) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large `kreg`) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in [Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]](http://arXiv.org/abs/hep-ph/9509307) using the distribution of the `|d_i|` that can be obtained by `tsvdunf->GetD()` and/or using pseudo-experiments. 

Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the `GetUnfoldCovMatrix` method, which uses pseudo experiments for the propagation. In addition, `GetAdetCovMatrix` allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to `Bcov` is also computed as described in [Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]](http://arXiv.org/abs/hep-ph/9509307) and can be obtained from `tsvdunf->GetXtau()` and its (regularisation independent) inverse from `tsvdunf->GetXinv()`. The distribution of singular values can be retrieved using `tsvdunf->GetSV()`. 

See also the tutorial for a toy example.

Related functions: [`ComputeChiSquared`](@ref), [`GetAdetCovMatrix`](@ref), [`GetBCov`](@ref), [`GetD`](@ref), [`GetKReg`](@ref), [`GetSV`](@ref), [`GetUnfoldCovMatrix`](@ref), [`GetXinv`](@ref), [`GetXtau`](@ref), [`SetNormalize`](@ref), [`TSVDUnfold`](@ref), [`Unfold`](@ref)
""" TSVDUnfold

# Wrapper of TVirtualGraphPainter
@trydoc raw"""
    ROOT.TVirtualGraphPainter

Abstract interface to a histogram painter.



Related functions: [`DistancetoPrimitiveHelper`](@ref), [`DrawPanelHelper`](@ref), [`ExecuteEventHelper`](@ref), [`GetObjectInfoHelper`](@ref), [`PaintGrapHist`](@ref), [`PaintGraph`](@ref), [`PaintHelper`](@ref), [`PaintScatter`](@ref), [`PaintStats`](@ref), [`SetHighlight`](@ref), [`TVirtualGraphPainter!GetPainter`](@ref), [`TVirtualGraphPainter!SetPainter`](@ref), [`TVirtualGraphPainter`](@ref)
""" TVirtualGraphPainter

# Wrapper of TVirtualPaveStats
@trydoc raw"""
    ROOT.TVirtualPaveStats





Related functions: [`GetParent`](@ref), [`SetParent`](@ref)
""" TVirtualPaveStats

# Wrapper of TGDMLMatrix
@trydoc raw"""
    ROOT.TGDMLMatrix

This class is used in the process of reading and writing the GDML "matrix" tag.

It represents a matrix with arbitrary number of rows and columns, storing elements in double precision.

Related functions: [`GetCols`](@ref), [`GetMatrixAsString`](@ref), [`GetRows`](@ref), [`Get`](@ref), [`Print`](@ref), [`SetMatrixAsString`](@ref), [`Set`](@ref), [`TGDMLMatrix`](@ref), [`assign`](@ref)
""" TGDMLMatrix

# Wrapper of TGeoShape
@trydoc raw"""
    ROOT.TGeoShape

Base abstract class for all shapes.

Shapes are geometrical objects that provide the basic modelling functionality. They provide the definition of the LOCAL frame of coordinates, with respect to which they are defined. Any implementation of a shape deriving from the base [TGeoShape](@ref) class has to provide methods for :

- finding out if a point defined in their local_ frame is or not contained inside;
- computing the distance from a local_ point to getting outside/entering the shape, given a known direction;
- computing the maximum distance in any direction from a local_ point that does NOT result in a boundary crossing of the shape (safe distance);
- computing the cosines of the normal vector to the crossed shape surface, given a starting local_ point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods :
- computation of the minimal box bounding the shape, given that this box have to be aligned with the local_ coordinates;
- algorithms for dividing the shape along a given axis and producing resulting divisions volumes.

The modeler currently provides a set of 16 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes made as a result of boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (composition of composites). This allows the creation of a quite large number of different shape topologies and combinations.

Named shapes register themselves to the manager class at creation time. The manager is responsible for their final deletion. Shapes can be created using their default constructor if their retrieval by name is not needed, but in this case they are owned by the user. A shape may be referenced by several volumes, therefore its deletion is not possible once volumes were defined based on it.

### Creating shapes

Shape objects embed only the minimum set of parameters that are fully describing a valid physical shape. For instance, a tube is represented by its half length, the minimum radius and the maximum radius. Shapes are used together with media in order to create volumes, which in their turn are the main components of the geometrical tree. A specific shape can be created stand-alone :

    TGeoBBox *box = new TGeoBBox("s_box", halfX, halfY, halfZ); // named
    TGeoTube *tub = new TGeoTube(rmin, rmax, halfZ);            // no name
    ...  (see each specific shape constructors)

(C++ version of the code)

Sometimes it is much easier to create a volume having a given shape in one step, since shapes are not directly linked in the geometrical tree but volumes are :

    TGeoVolume *vol_box = gGeoManager->MakeBox("BOX_VOL", "mat1", halfX, halfY, halfZ);
    TGeoVolume *vol_tub = gGeoManager->MakeTube("TUB_VOL", "mat2", rmin, rmax, halfZ);
    ...  (see MakeXXX() utilities in TGeoManager class)

(C++ version of the code)

### Shape queries

Note that global_ queries related to a geometry are handled by the manager class. However, shape-related queries might be sometimes useful.

#### Bool_t TGeoShape!Contains(const Double_t *point[3])

this method returns true if POINT is actually inside the shape. The point has to be defined in the local_ shape reference. For instance, for a box having DX, DY and DZ half-lengths a point will be considered inside if :

    | -DX <= point[0] <= DX
    | -DY <= point[1] <= DY
    | -DZ <= point[2] <= DZ

(C++ version of the code)

#### Double_t TGeoShape!DistFromInside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local_ shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape!DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside)

compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.

#### Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside)

returns director cosines of normal to the crossed shape surface from a given point towards a direction. One has to specify if the point is inside or outside shape. According to this, the normal will be outwards or inwards shape respectively. Normal components are statically stored by shape class, so it has to be copied after retrieval in a different array.

### Dividing shapes

Shapes can generally be divided along a given axis. Supported axis are X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes should not be performed by [TGeoShape!Divide()](@ref) calls, but rather by [TGeoVolume!Divide()](@ref). The algorithm for dividing a specific shape is known by the shape object, but is always invoked in a generic way from the volume level. Details on how to do that can be found in [TGeoVolume](@ref) class. One can see how all division options are interpreted and which is their result inside specific shape classes.

![https://root.cern/doc/v636/geom_t_shape.png](https://root.cern/doc/v636/geom_t_shape.png)

Related functions: [`AfterStreamer`](@ref), [`Capacity`](@ref), [`CheckShape`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CouldBeCrossed`](@ref), [`CreateThreadData`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetFittingBox`](@ref), [`GetId`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetName`](@ref), [`GetNmeshVertices`](@ref), [`GetPointerName`](@ref), [`GetPointsOnSegments`](@ref), [`Inside`](@ref), [`InspectShape`](@ref), [`InvertShapeBit`](@ref), [`IsAssembly`](@ref), [`IsComposite`](@ref), [`IsCylType`](@ref), [`IsReflected`](@ref), [`IsRunTimeShape`](@ref), [`IsValidBox`](@ref), [`IsValid`](@ref), [`IsVecGeom`](@ref), [`MakeBuffer3D`](@ref), [`Paint`](@ref), [`ResetShapeBit`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SetDimensions`](@ref), [`SetId`](@ref), [`SetPoints`](@ref), [`SetRuntime`](@ref), [`SetSegsAndPols`](@ref), [`SetShapeBit`](@ref), [`ShapeDistancetoPrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoShape!Big`](@ref), [`TGeoShape!ComputeEpsMch`](@ref), [`TGeoShape!DistToPhiMin`](@ref), [`TGeoShape!EpsMch`](@ref), [`TGeoShape!GetTransform`](@ref), [`TGeoShape!IsCloseToPhi`](@ref), [`TGeoShape!IsCrossingSemiplane`](@ref), [`TGeoShape!IsInPhiRange`](@ref), [`TGeoShape!IsSameWithinTolerance`](@ref), [`TGeoShape!IsSegCrossing`](@ref), [`TGeoShape!NormalPhi`](@ref), [`TGeoShape!SafetyPhi`](@ref), [`TGeoShape!SafetySeg`](@ref), [`TGeoShape!SetTransform`](@ref), [`TGeoShape!Tolerance`](@ref), [`TGeoShape`](@ref), [`TestShapeBit`](@ref), [`TestShapeBits`](@ref)
""" TGeoShape

# Wrapper of TGeoMatrix
@trydoc raw"""
    ROOT.TGeoMatrix

Geometrical transformation package.

All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local_ and local_-to-master computation. We need to have in mind that a transformation in TGeo has 2 major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local_'. If T is a transformation used for positioning volume daughters, then:

    MASTER = T * LOCAL

(C++ version of the code)

Therefore a local_-to-master conversion will be performed by using T, while a master-to-local_ by using its inverse. The second use case is the computation of the global_ transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', this global_ transformation represent the pile-up of all local_ transformations in the corresponding branch. The conversion from the global_ reference frame and the given object is also called master-to-local_, but it is handled by the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.

Rotation: Inverse rotation:

    r11  r12  r13   0              r11  r21  r31   0
    r21  r22  r23   0              r12  r22  r32   0
    r31  r32  r33   0              r13  r23  r33   0
     0    0    0    1               0    0    0    1

(C++ version of the code)

Translation: Inverse translation:

    1    0    0    tx               1    0    0   -tx
    0    1    0    ty               0    1    0   -ty
    0    0    1    tz               0    0    1   -tz
    0    0    0    1                0    0    0   1

(C++ version of the code)

Scale: Inverse scale:

    sx   0    0    0              1/sx  0    0    0
    0    sy   0    0               0   1/sy  0    0
    0    0    sz   0               0    0   1/sz  0
    0    0    0    1               0    0    0    1

(C++ version of the code)

where:

- `rij` are the 3x3 rotation matrix components,
- `tx`, `ty`, `tz` are the translation components
- `sx`, `sy`, `sz` are arbitrary scale constants on each axis,

The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translation would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the same basic abstract class and handling its specific data and point/vector transformation algorithms.

![https://root.cern/doc/v636/geom_transf.jpg](https://root.cern/doc/v636/geom_transf.jpg)

### The base class TGeoMatrix defines abstract metods for:

#### translation, rotation and scale getters. Every derived class stores only

its specific data, e.g. a translation stores an array of 3 doubles and a rotation an array of 9. However, asking which is the rotation array of a [TGeoTranslation](@ref) through the base [TGeoMatrix](@ref) interface is a legal operation. The answer in this case is a pointer to a global_ constant array representing an identity rotation.

    Double_t *TGeoMatrix!GetTranslation()
    Double_t *TGeoMatrix!GetRotation()
    Double_t *TGeoMatrix!GetScale()

(C++ version of the code)

#### MasterToLocal() and LocalToMaster() point and vector transformations :

    void      TGeoMatrix!MasterToLocal(const Double_t *master, Double_t *local_)
    void      TGeoMatrix!LocalToMaster(const Double_t *local_, Double_t *master)
    void      TGeoMatrix!MasterToLocalVect(const Double_t *master, Double_t *local_)
    void      TGeoMatrix!LocalToMasterVect(const Double_t *local_, Double_t *master)

(C++ version of the code)

These allow correct conversion also for reflections.

#### Transformation type getters :

    Bool_t    TGeoMatrix!IsIdentity()
    Bool_t    TGeoMatrix!IsTranslation()
    Bool_t    TGeoMatrix!IsRotation()
    Bool_t    TGeoMatrix!IsScale()
    Bool_t    TGeoMatrix!IsCombi() (translation + rotation)
    Bool_t    TGeoMatrix!IsGeneral() (translation + rotation + scale)

(C++ version of the code)

Combinations of basic transformations are represented by specific classes deriving from [TGeoMatrix](@ref). In order to define a matrix as a combination of several others, a special class [TGeoHMatrix](@ref) is provided. Here is an example of matrix creation :

### Matrix creation example:

    root[0] TGeoRotation r1,r2;
            r1.SetAngles(90,0,30);        // rotation defined by Euler angles
            r2.SetAngles(90,90,90,180,0,0); // rotation defined by GEANT3 angles
            TGeoTranslation t1(-10,10,0);
            TGeoTranslation t2(10,-10,5);
            TGeoCombiTrans c1(t1,r1);
            TGeoCombiTrans c2(t2,r2);
            TGeoHMatrix h = c1 * c2; // composition is done via TGeoHMatrix class
    root[7] TGeoHMatrix *ph = new TGeoHMatrix(hm); // this is the one we want to
                                                 // use for positioning a volume
    root[8] ph->Print();
            ...
            pVolume->AddNode(pVolDaughter,id,ph) // now ph is owned by the manager

(C++ version of the code)

### Rule for matrix creation:

Unless explicitly used for positioning nodes ([TGeoVolume!AddNode()](@ref)) all matrices deletion have to be managed by users. Matrices passed to geometry have to be created by using new() operator and their deletion is done by [TGeoManager](@ref) class.

### Available geometrical transformations

#### TGeoTranslation

Represent a (dx,dy,dz) translation. Data members: Double_t fTranslation[3]. Translations can be added/subtracted.

    TGeoTranslation t1;
    t1->SetTranslation(-5,10,4);
    TGeoTranslation *t2 = new TGeoTranslation(4,3,10);
    t2->Subtract(&t1);

(C++ version of the code)

#### Rotations

Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles :

    TGeoRotation *r1 = new TGeoRotation();
    r1->SetAngles(phi, theta, psi); // all angles in degrees

(C++ version of the code)

This represent the composition of : first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psi about the new Z axis.

    r1->SetAngles(th1,phi1, th2,phi2, th3,phi3)

(C++ version of the code)

This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.

Specific utilities : determinant, inverse.

#### Scale transformations

Represent a scale shrinking/enlargement. Data members :Double_t fScale[3]. Not fully implemented yet.

#### Combined transformations

Represent a rotation followed by a translation. Data members: Double_t fTranslation[3], [TGeoRotation](@ref) *fRotation.

    TGeoRotation *rot = new TGeoRotation("rot",10,20,30);
    TGeoTranslation trans;
    ...
    TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);
    TGeoCombiTrans *c2 = new TGeoCombiTrans("somename",10,20,30,rot)

(C++ version of the code)

#### TGeoGenTrans

Combined transformations including a scale. Not implemented.

#### TGeoIdentity

A generic singleton matrix representing a identity transformation NOTE: identified by the global_ variable gGeoIdentity.

Related functions: [`GetByteCount`](@ref), [`GetHomogenousMatrix`](@ref), [`GetPointerName`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`IsCombi`](@ref), [`IsGeneral`](@ref), [`IsIdentity`](@ref), [`IsOwned`](@ref), [`IsReflection`](@ref), [`IsRegistered`](@ref), [`IsRotAboutZ`](@ref), [`IsRotation`](@ref), [`IsScale`](@ref), [`IsShared`](@ref), [`IsTranslation`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`Print`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RegisterYourself`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SetDefaultName`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetShared`](@ref), [`TGeoMatrix!Normalize`](@ref), [`TGeoMatrix`](@ref)
""" TGeoMatrix

# Wrapper of TGeoVolume
@trydoc raw"""
    ROOT.TGeoVolume

[TGeoVolume](@ref), [TGeoVolumeMulti](@ref), [TGeoVolumeAssembly](@ref) are the volume classes.

Volumes are the basic objects used in building the geometrical hierarchy. They represent unpositioned objects but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. In order to create a volume, one has to put together a shape and a medium which are already defined. Volumes have to be named by users at creation time. Every different name may represent a an unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two cases : when a generic shape is provided to the volume constructor or when a division operation is applied. Each volume in the geometry stores an unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.

Volumes are objects that can be visualized, therefore having visibility, colour, line and fill attributes that can be defined or modified any time after the volume creation. It is advisable however to define these properties just after the first creation of a volume namespace, since in case of volume families any new member created by the modeler inherits these properties.

In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local_ reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local_ mother-daughters management is handled by volumes that builds additional optimisation structures upon geometry closure. In order to have navigation features properly working one has to follow the general rules for building a valid geometry (see [TGeoManager](@ref) class).

Now let's make a simple volume representing a copper wire. We suppose that a medium is already created (see [TGeoMedium](@ref) class on how to create media). We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm :

    TGeoTube *tube = new TGeoTube("wire_tube", 0, 0.01, 1);

(C++ version of the code)

One may omit the name for the shape if no retrieving by name is further needed during geometry building. The same shape can be shared by different volumes having different names and materials. Now let's make the volume for our wire. The prototype for volumes constructor looks like :

TGeoVolume!TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med)

Since [TGeoTube](@ref) derives from the base shape class, we can provide it to the volume constructor :

    TGeoVolume *wire_co = new TGeoVolume("WIRE_CO", tube, ptrCOPPER);

(C++ version of the code)

Do not bother to delete neither the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class. If we would have taken a look inside [TGeoManager!MakeTube()](@ref) method, we would have been able to create our wire with a single line :

    TGeoVolume *wire_co = gGeoManager->MakeTube("WIRE_CO", ptrCOPPER, 0, 0.01, 1);

(C++ version of the code)

The same applies for all primitive shapes, for which there can be found corresponding MakeSHAPE() methods. Their usage is much more convenient unless a shape has to be shared between more volumes. Let's make now an aluminium wire having the same shape, supposing that we have created the copper wire with the line above :

    TGeoVolume *wire_al = new TGeoVolume("WIRE_AL", wire_co->GetShape(), ptrAL);

(C++ version of the code)

Now that we have learned how to create elementary volumes, let's see how we can create a geometrical hierarchy.

### Positioning volumes

When creating a volume one does not specify if this will contain or not other volumes. Adding daughters to a volume implies creating those and adding them one by one to the list of daughters. Since the volume has to know the position of all its daughters, we will have to supply at the same time a geometrical transformation with respect to its local_ reference frame for each of them. The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeler. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches.

![https://root.cern/doc/v636/geom_t_example.png](https://root.cern/doc/v636/geom_t_example.png)

An important observation is that volume objects are owned by the [TGeoManager](@ref) class. This stores a list of all volumes in the geometry, that is cleaned upon destruction.

Let's consider positioning now our wire in the middle of a gas chamber. We need first to define the gas chamber :

    TGeoVolume *chamber = gGeoManager->MakeTube("CHAMBER", ptrGAS, 0, 1, 1);

(C++ version of the code)

Now we can put the wire inside :

    chamber->AddNode(wire_co, 1);

(C++ version of the code)

If we inspect now the chamber volume in a browser, we will notice that it has one daughter. Of course the gas has some container also, but let's keep it like that for the sake of simplicity. The full prototype of [AddNode()](@ref) is :

    TGeoVolume!AddNode(TGeoVolume *daughter, Int_t usernumber,
                        TGeoMatrix *matrix=gGeoIdentity)

(C++ version of the code)

Since we did not supplied the third argument, the wire will be positioned with an identity transformation inside the chamber. One will notice that the inner radii of the wire and chamber are both zero - therefore, aren't the two volumes overlapping ? The answer is no, the modeler is even relaying on the fact that any daughter is fully contained by its mother. On the other hand, neither of the nodes positioned inside a volume should overlap with each other. We will see that there are allowed some exceptions to those rules.

### Overlapping volumes

Positioning volumes that does not overlap their neighbours nor extrude their container is sometimes quite strong constraint. Some parts of the geometry might overlap naturally, e.g. two crossing tubes. The modeller supports such cases only if the overlapping nodes are declared by the user. In order to do that, one should use [TGeoVolume!AddNodeOverlap()](@ref) instead of [TGeoVolume!AddNode()](@ref). When 2 or more positioned volumes are overlapping, not all of them have to be declared so, but at least one. A point inside an overlapping region equally belongs to all overlapping nodes, but the way these are defined can enforce the modeler to give priorities. The general rule is that the deepest node in the hierarchy containing a point have the highest priority. For the same geometry level, non-overlapping is prioritised over overlapping. In order to illustrate this, we will consider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:

1. The part of a MANY node B extruding its container A will never be "seen" during navigation, as if B was in fact the result of the intersection of A and B.
2. If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.
3. If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.
4. The slices of a divided MANY will be as well MANY.

One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - this is always recommended.

### Replicating volumes

What can we do if our chamber contains two identical wires instead of one ? What if then we would need 1000 chambers in our detector ? Should we create 2000 wires and 1000 chamber volumes ? No, we will just need to replicate the ones that we have already created.

    chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));
    chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));

(C++ version of the code)

The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local_ reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeler is smarter than that and create for each volume some optimization structures called voxels (see Voxelization) to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway loose a lot in your tracking performance.

The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation : instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.

Related functions: [`AddNodeOffset`](@ref), [`AddNodeOverlap`](@ref), [`AddNode`](@ref), [`Browse`](@ref), [`Capacity`](@ref), [`CheckGeometry`](@ref), [`CheckOverlaps`](@ref), [`CheckShape`](@ref), [`CheckShapes`](@ref), [`CleanAll`](@ref), [`ClearNodes`](@ref), [`ClearShape`](@ref), [`ClearThreadData`](@ref), [`CloneNodesAndConnect`](@ref), [`CloneVolume`](@ref), [`Contains`](@ref), [`CountNodes`](@ref), [`CreateThreadData`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`DrawOnly`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`Export`](@ref), [`FindMatrixOfDaughterVolume`](@ref), [`FindNode`](@ref), [`FindOverlaps`](@ref), [`GetByteCount`](@ref), [`GetCurrentNodeIndex`](@ref), [`GetFWExtension`](@ref), [`GetField`](@ref), [`GetFinder`](@ref), [`GetGeoManager`](@ref), [`GetIconName`](@ref), [`GetIndex`](@ref), [`GetMaterial`](@ref), [`GetMedium`](@ref), [`GetNdaughters`](@ref), [`GetNextNodeIndex`](@ref), [`GetNodeIndex`](@ref), [`GetNode`](@ref), [`GetNodes`](@ref), [`GetNtotal`](@ref), [`GetNumber`](@ref), [`GetObjectInfo`](@ref), [`GetOptimalVoxels`](@ref), [`GetOption`](@ref), [`GetPointerName`](@ref), [`GetRefCount`](@ref), [`GetShape`](@ref), [`GetTransparency`](@ref), [`GetUserExtension`](@ref), [`GetVoxels`](@ref), [`GrabFWExtension`](@ref), [`GrabFocus`](@ref), [`GrabUserExtension`](@ref), [`Grab`](@ref), [`Gsord`](@ref), [`InspectMaterial`](@ref), [`InspectShape`](@ref), [`InvisibleAll`](@ref), [`IsActiveDaughters`](@ref), [`IsActive`](@ref), [`IsAdded`](@ref), [`IsAllInvisible`](@ref), [`IsAssembly`](@ref), [`IsCylVoxels`](@ref), [`IsFolder`](@ref), [`IsOverlappingCandidate`](@ref), [`IsRaytracing`](@ref), [`IsReplicated`](@ref), [`IsRunTime`](@ref), [`IsSelected`](@ref), [`IsStyleDefault`](@ref), [`IsTopVolume`](@ref), [`IsValid`](@ref), [`IsVisContainers`](@ref), [`IsVisLeaves`](@ref), [`IsVisOnly`](@ref), [`IsVisibleDaughters`](@ref), [`IsVisible`](@ref), [`IsVolumeMulti`](@ref), [`IsXYZVoxels`](@ref), [`LegoPlot`](@ref), [`MakeCopyNodes`](@ref), [`MakeCopyVolume`](@ref), [`MakeReflectedVolume`](@ref), [`OptimizeVoxels`](@ref), [`Paint`](@ref), [`PrintNodes`](@ref), [`PrintVoxels`](@ref), [`Print`](@ref), [`RandomPoints`](@ref), [`RandomRays`](@ref), [`Raytrace`](@ref), [`RegisterYourself`](@ref), [`Release`](@ref), [`RemoveNode`](@ref), [`ReplaceNode`](@ref), [`ReplayCreation`](@ref), [`ResetTransparency`](@ref), [`SaveAs`](@ref), [`SavePrimitive`](@ref), [`SelectVolume`](@ref), [`SetActiveDaughters`](@ref), [`SetActivity`](@ref), [`SetAdded`](@ref), [`SetAsTopVolume`](@ref), [`SetAttVisibility`](@ref), [`SetCurrentPoint`](@ref), [`SetCylVoxels`](@ref), [`SetFWExtension`](@ref), [`SetField`](@ref), [`SetFinder`](@ref), [`SetInvisible`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetMedium`](@ref), [`SetNodes`](@ref), [`SetNtotal`](@ref), [`SetNumber`](@ref), [`SetOption`](@ref), [`SetOverlappingCandidate`](@ref), [`SetReplicated`](@ref), [`SetShape`](@ref), [`SetTransparency`](@ref), [`SetUserExtension`](@ref), [`SetVisContainers`](@ref), [`SetVisLeaves`](@ref), [`SetVisOnly`](@ref), [`SetVisibility`](@ref), [`SetVoxelFinder`](@ref), [`SortNodes`](@ref), [`TGeoVolume!CreateDummyMedium`](@ref), [`TGeoVolume!DummyMedium`](@ref), [`TGeoVolume!Import`](@ref), [`TGeoVolume`](@ref), [`UnmarkSaved`](@ref), [`Valid`](@ref), [`VisibleDaughters`](@ref), [`Voxelize`](@ref), [`WeightA`](@ref), [`Weight`](@ref), [`cd`](@ref)
""" TGeoVolume

# Wrapper of TGeoBBox
@trydoc raw"""
    ROOT.TGeoBBox

Box class.

- [Building boxes](@ref)
- [Creation of boxes](@ref)
- [Divisions of boxes](@ref)

All shape primitives inherit from this, their constructor filling automatically the parameters of the box that bounds the given shape. Defined by 6 parameters :

    TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);

(C++ version of the code)

- `fDX`, `fDY`, `fDZ` : half lengths on X, Y and Z axis
- `fOrigin[3]` : position of box origin

### Building boxes

Normally a box has to be built only with 3 parameters: `DX,DY,DZ` representing the half-lengths on X, Y and Z-axes. In this case, the origin of the box will match the one of its reference frame and the box will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and from `-DZ` to `DZ` on Z. On the other hand, any other shape needs to compute and store the parameters of their minimal bounding box. The bounding boxes are essential to optimize navigation algorithms. Therefore all other primitives derive from **`TGeoBBox`**. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation `(Ox`,`Oy`,`Oz)`. All primitive constructors automatically compute the bounding box parameters. Users should be aware that building a translated box that will represent a primitive shape by itself would affect any further positioning of other shapes inside. Therefore it is highly recommendable to build non-translated boxes as primitives and translate/rotate their corresponding volumes only during positioning stage.

#### Creation of boxes

    TGeoBBox *box = new TGeoBBox("BOX", 20, 30, 40);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoBBox_001.png](https://root.cern/doc/v636/pict1_TGeoBBox_001.png)

A volume having a box shape can be built in one step:

    TGeoVolume *vbox = gGeoManager->MakeBox("vbox", ptrMed, 20,30,40);

(C++ version of the code)

#### Divisions of boxes

Volumes having box shape can be divided with equal-length slices on X, Y or Z axis. The following options are supported:

- Dividing the full range of one axis in N slices 

        TGeoVolume *divx = vbox->Divide("SLICEX", 1, N);

(C++ version of the code)

 here `1` stands for the division axis (1-X, 2-Y, 3-Z)

![https://root.cern/doc/v636/pict1_TGeoBBox_002.png](https://root.cern/doc/v636/pict1_TGeoBBox_002.png)

- Dividing in a limited range - general case. 

        TGeoVolume *divy = vbox->Divide("SLICEY",2,N,thestart,step);

(C++ version of the code)

    - thestart = starting offset within (-fDY, fDY)
    - step = slicing step

![https://root.cern/doc/v636/pict1_TGeoBBox_003.png](https://root.cern/doc/v636/pict1_TGeoBBox_003.png)

Both cases are supported by all shapes. See also class [TGeoShape](@ref) for utility methods provided by any particular shape.

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CouldBeCrossed`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDX`](@ref), [`GetDY`](@ref), [`GetDZ`](@ref), [`GetFacetArea`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetOrigin`](@ref), [`GetPointsOnFacet`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`IsNullBox`](@ref), [`IsValidBox`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetBoxDimensions`](@ref), [`SetBoxPoints`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoBBox!Contains`](@ref), [`TGeoBBox!DistFromInside`](@ref), [`TGeoBBox!DistFromOutside`](@ref), [`TGeoBBox`](@ref)
""" TGeoBBox

# Wrapper of TGeoArb8
@trydoc raw"""
    ROOT.TGeoArb8

An arbitrary trapezoid with less than 8 vertices standing on two parallel planes perpendicular to Z axis.

An `Arb8` is defined by two quadrilaterals sitting on parallel planes, at `dZ`. These are defined each by 4 vertices having the coordinates `(Xi,Yi,+/-dZ)`,`i=0`,`3`. The lateral surface of the `Arb8` is defined by the 4 pairs of edges corresponding to vertices (`i,i+1`) on both `-dZ` and `+dZ`. If M and M' are the middles of the segments `(i,i+1)` at `-dZ` and `+dZ`, a lateral surface is obtained by sweeping the edge at `-dZ` along MM' so that it will match the corresponding one at `+dZ`. Since the points defining the edges are arbitrary, the lateral surfaces are not necessary planes - but twisted planes having a twist angle linear-dependent on Z.

    TGeoArb8!TGeoArb8(Double_t dz,Double_t ivert);

(C++ version of the code)

- `dz:` half-length in Z;
- `ivert = [0,7]`

Vertices have to be defined clockwise in the XY pane, both at `+dz` and `-dz`. The quadrilateral at `-dz` is defined by indices [0,3], whereas the one at `+dz` by vertices [4,7]. The vertex with `index=7` has to be defined last, since it triggers the computation of the bounding box of the shape. Any two or more vertices in each Z plane can have the same (X,Y) coordinates. It this case, the top and bottom quadrilaterals become triangles, segments or points. The lateral surfaces are not necessary defined by a pair of segments, but by pair segment-point (making a triangle) or point-point (making a line). Any choice is valid as long as at one of the theend-caps is at least a triangle.

![https://root.cern/doc/v636/pict1_TGeoArb8_001.png](https://root.cern/doc/v636/pict1_TGeoArb8_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`ComputeTwist`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToPlane`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetClosestEdge`](@ref), [`GetDz`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetPointsOnFacet`](@ref), [`GetTwist`](@ref), [`GetVertices`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`IsTwisted`](@ref), [`SafetyToFace`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetDz`](@ref), [`SetPlaneVertices`](@ref), [`SetPoints`](@ref), [`SetVertex`](@ref), [`Sizeof3D`](@ref), [`TGeoArb8!GetPlaneNormal`](@ref), [`TGeoArb8!InsidePolygon`](@ref), [`TGeoArb8!IsSamePoint`](@ref), [`TGeoArb8`](@ref)
""" TGeoArb8

# Wrapper of TGeoTrap
@trydoc raw"""
    ROOT.TGeoTrap

A general trapezoid.

A general trapezoid is one for which the faces perpendicular to z are trapezes but their centers are not necessary at the same x, y coordinates.

![https://root.cern/doc/v636/pict1_TGeoArb8_003.png](https://root.cern/doc/v636/pict1_TGeoArb8_003.png)

It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, `H1` the half length in y at low z, `LB1` the half length in x at low z and y low edge, `LB2` the half length in x at low z and y high edge, **`TH1`** the angle with respect to the y axis from the center of low y edge to the center of the high y edge, and `H2,LB2,LH2,TH2`, the corresponding quantities at high z.

    TGeoTrap(Double_t dz,Double_t theta,Double_t phi,
    Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,
    Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2);

(C++ version of the code)

Related functions: [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAlpha1`](@ref), [`GetAlpha2`](@ref), [`GetBl1`](@ref), [`GetBl2`](@ref), [`GetH1`](@ref), [`GetH2`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetPhi`](@ref), [`GetTheta`](@ref), [`GetTl1`](@ref), [`GetTl2`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`TGeoTrap`](@ref)
""" TGeoTrap

# Wrapper of TGeoGtra
@trydoc raw"""
    ROOT.TGeoGtra

A twisted trapezoid.

A twisted trapezoid is a general trapezoid defined in the same way but that is twisted along the Z-axis. The twist is defined as the rotation angle between the lower and the higher Z faces.

    TGeoGtra(Double_t dz,Double_t theta,Double_t phi,Double_t twist,
    Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,
    Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2 );

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoArb8_002.png](https://root.cern/doc/v636/pict1_TGeoArb8_002.png)

Related functions: [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetTwistAngle`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`TGeoGtra`](@ref)
""" TGeoGtra

# Wrapper of TGeoAtt
@trydoc raw"""
    ROOT.TGeoAtt

Visualization and tracking attributes for volumes and nodes.

The [TGeoAtt](@ref) class is an utility for volume/node visibility and tracking activity. By default the attributes are set to visible/active

Related functions: [`IsActiveDaughters`](@ref), [`IsActive`](@ref), [`IsVisBranch`](@ref), [`IsVisContainers`](@ref), [`IsVisDaughters`](@ref), [`IsVisLeaves`](@ref), [`IsVisOnly`](@ref), [`IsVisRaytrace`](@ref), [`IsVisStreamed`](@ref), [`IsVisTouched`](@ref), [`IsVisible`](@ref), [`ResetAttBit`](@ref), [`SetActiveDaughters`](@ref), [`SetActivity`](@ref), [`SetAttBit`](@ref), [`SetOptimization`](@ref), [`SetVisBranch`](@ref), [`SetVisContainers`](@ref), [`SetVisDaughters`](@ref), [`SetVisLeaves`](@ref), [`SetVisOnly`](@ref), [`SetVisRaytrace`](@ref), [`SetVisStreamed`](@ref), [`SetVisTouched`](@ref), [`SetVisibility`](@ref), [`TGeoAtt`](@ref), [`TestAttBit`](@ref)
""" TGeoAtt

# Wrapper of TGeoBoolNode
@trydoc raw"""
    ROOT.TGeoBoolNode

Base class for Boolean operations between two shapes.

A Boolean node describes a Boolean operation between 'left' and 'right' shapes positioned with respect to an ARBITRARY reference frame. The boolean node is referenced by a mother composite shape and its shape components may be primitive but also composite shapes. The later situation leads to a binary tree hierarchy. When the parent composite shape is used to create a volume, the reference frame of the volume is chosen to match the frame in which node shape components were defined.

The positioned shape components may or may not be disjoint. The specific implementations for Boolean nodes are:

- [TGeoUnion](@ref) - representing the Boolean union of two positioned shapes
- [TGeoSubtraction](@ref) - representing the Boolean subtraction of two positioned shapes
- [TGeoIntersection](@ref) - representing the Boolean intersection of two positioned shapes

Related functions: [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`GetLeftMatrix`](@ref), [`GetLeftShape`](@ref), [`GetNpoints`](@ref), [`GetRightMatrix`](@ref), [`GetRightShape`](@ref), [`GetThreadData`](@ref), [`Inside`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`RegisterMatrices`](@ref), [`ReplaceMatrix`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetSelected`](@ref), [`Sizeof3D`](@ref), [`TGeoBoolNode`](@ref)
""" TGeoBoolNode

# Wrapper of TGeoUnion
@trydoc raw"""
    ROOT.TGeoUnion

Boolean node representing a union between two components.



Related functions: [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoUnion`](@ref)
""" TGeoUnion

# Wrapper of TGeoIntersection
@trydoc raw"""
    ROOT.TGeoIntersection

Boolean node representing an intersection between two components.



Related functions: [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoIntersection`](@ref)
""" TGeoIntersection

# Wrapper of TGeoSubtraction
@trydoc raw"""
    ROOT.TGeoSubtraction

Boolean node representing a subtraction.



Related functions: [`ComputeBBox`](@ref), [`ComputeNormal`](@ref), [`Contains`](@ref), [`DistFromInside`](@ref), [`DistFromOutside`](@ref), [`DistanceToPrimitive`](@ref), [`GetBooleanOperator`](@ref), [`MakeClone`](@ref), [`Paint`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`Sizeof3D`](@ref), [`TGeoSubtraction`](@ref)
""" TGeoSubtraction

# Wrapper of TGeoHMatrix
@trydoc raw"""
    ROOT.TGeoHMatrix

Matrix class used for computing global_ transformations Should NOT be used for node definition.

An instance of this class is generally used to pile-up local_ transformations starting from the top level physical node, down to the current node.

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`Clear`](@ref), [`CopyFrom`](@ref), [`Determinant`](@ref), [`FastRotZ`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`MakeClone`](@ref), [`MultiplyLeft`](@ref), [`Multiply`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetRotation`](@ref), [`SetScale`](@ref), [`SetTranslation`](@ref), [`TGeoHMatrix`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoHMatrix

# Wrapper of TGeoTranslation
@trydoc raw"""
    ROOT.TGeoTranslation

Class describing translations.

A translation is basically an array of 3 doubles matching the positions 12, 13 and 14 in the homogenous matrix description.

Related functions: [`Add`](@ref), [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetTranslation`](@ref), [`Subtract`](@ref), [`TGeoTranslation`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoTranslation

# Wrapper of TGeoRotation
@trydoc raw"""
    ROOT.TGeoRotation

Class describing rotations.

A rotation is a 3*3 array Column vectors has to be orthogonal unit vectors.

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`Clear`](@ref), [`Determinant`](@ref), [`FastRotZ`](@ref), [`GetAngles`](@ref), [`GetInverse`](@ref), [`GetPhiRotation`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`IsValid`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MultiplyBy`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetAngles`](@ref), [`SetMatrix`](@ref), [`SetRotation`](@ref), [`TGeoRotation`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoRotation

# Wrapper of TGeoScale
@trydoc raw"""
    ROOT.TGeoScale

Class describing scale transformations.

A scale is an array of 3 doubles (sx, sy, sz) multiplying elements 0, 5 and 10 of the homogenous matrix. A scale is normalized : sx*sy*sz = 1

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`SetScale`](@ref), [`TGeoScale`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoScale

# Wrapper of TGeoCombiTrans
@trydoc raw"""
    ROOT.TGeoCombiTrans

Class describing rotation + translation.

Most frequently used in the description of [TGeoNode](@ref) 's

Related functions: [`Base.:(*)`](@ref), [`Base.:(==)`](@ref), [`Clear`](@ref), [`GetRotationMatrix`](@ref), [`GetRotation`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`MakeClone`](@ref), [`Multiply`](@ref), [`ReflectX`](@ref), [`ReflectY`](@ref), [`ReflectZ`](@ref), [`RegisterYourself`](@ref), [`RotateX`](@ref), [`RotateY`](@ref), [`RotateZ`](@ref), [`SavePrimitive`](@ref), [`SetDx`](@ref), [`SetDy`](@ref), [`SetDz`](@ref), [`SetRotation`](@ref), [`SetTranslation`](@ref), [`TGeoCombiTrans`](@ref), [`assign`](@ref), [`mult!`](@ref)
""" TGeoCombiTrans

# Wrapper of TGeoGenTrans
@trydoc raw"""
    ROOT.TGeoGenTrans

Most general transformation, holding a translation, a rotation and a scale.



Related functions: [`Clear`](@ref), [`GetScale`](@ref), [`Inverse`](@ref), [`MakeClone`](@ref), [`Normalize`](@ref), [`SetScale`](@ref), [`TGeoGenTrans`](@ref)
""" TGeoGenTrans

# Wrapper of TGeoIdentity
@trydoc raw"""
    ROOT.TGeoIdentity

An identity transformation.

It holds no data member and returns pointers to static null translation and identity transformations for rotation and scale

Related functions: [`GetRotationMatrix`](@ref), [`GetScale`](@ref), [`GetTranslation`](@ref), [`Inverse`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeClone`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`SavePrimitive`](@ref), [`TGeoIdentity`](@ref)
""" TGeoIdentity

# Wrapper of TGeoBranchArray
@trydoc raw"""
    ROOT.TGeoBranchArray

An array of daughter indices making a geometry path.

Can be used to backup/restore a state. Allocated contiguously in memory.

To setup an object of this type, one should use:

    TGeoBranchArray *array = new TGeoBranchArray(level);
    array->InitFromNavigator(nav); // To initialize from current navigator state

(C++ version of the code)

The navigator can be updated to reflect this path array: `array->UpdateNavigator();`

Related functions: [`AddLevel`](@ref), [`Base.:(!=)`](@ref), [`Base.:(<)`](@ref), [`Base.:(<=)`](@ref), [`Base.:(==)`](@ref), [`Base.:(>)`](@ref), [`Base.:(>=)`](@ref), [`CleanMatrix`](@ref), [`Compare`](@ref), [`CopyTo`](@ref), [`DataSize`](@ref), [`DataStart`](@ref), [`GetArray`](@ref), [`GetCurrentNode`](@ref), [`GetLevel`](@ref), [`GetMatrix`](@ref), [`GetMaxLevel`](@ref), [`GetNode`](@ref), [`GetPath`](@ref), [`InitFromNavigator`](@ref), [`Init`](@ref), [`IsOutside`](@ref), [`IsSortable`](@ref), [`Print`](@ref), [`SizeOf`](@ref), [`TGeoBranchArray!BinarySearch`](@ref), [`TGeoBranchArray!MakeCopyAt`](@ref), [`TGeoBranchArray!MakeCopy`](@ref), [`TGeoBranchArray!MakeInstanceAt`](@ref), [`TGeoBranchArray!MakeInstance`](@ref), [`TGeoBranchArray!ReleaseInstance`](@ref), [`TGeoBranchArray!SizeOfInstance`](@ref), [`TGeoBranchArray!SizeOf`](@ref), [`TGeoBranchArray!Sort`](@ref), [`TGeoBranchArray`](@ref), [`UpdateArray`](@ref), [`UpdateNavigator`](@ref), [`assign`](@ref)
""" TGeoBranchArray

# Wrapper of TGeoNode
@trydoc raw"""
    ROOT.TGeoNode

A node represent a volume positioned inside another.They store links to both volumes and to the [TGeoMatrix](@ref) representing the relative positioning.

Node are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user ID inside a volume B will create a node node named A_ID. This will be added to the list of nodes stored by B. Also, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path like:

/TOP_1/.../A_3/B_7 will represent an unique object.

Its global_ transformation matrix can be computed as the pile-up of all local_ transformations in its branch. We will therefore call "logical graph" the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique "touchable" objects. We will call this the "physical tree". Unlike the logical graph, the physical tree can become a huge structure with several milions of nodes in case of complex geometries, therefore it is not always a good idea to keep it transient in memory. Since a the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global_ matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node + current global_ matrix. However, physical nodes have unique ID's that can be retrieved for a given modeler state. These can be fed back to the modeler in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node, therefore knowing the location of a point in the geometry can be saved as a starting state for later use.

Nodes can be declared as "overlapping" in case they do overlap with other nodes inside the same container or extrude this container. Non-overlapping nodes can be created with:

    TGeoVolume!AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);

(C++ version of the code)

The creation of overlapping nodes can be done with a similar prototype:

    TGeoVolume!AddNodeOverlap(same arguments);

(C++ version of the code)

When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbours. These are stored and checked all the time during navigation, therefore navigation is slower when embedding such nodes into geometry.

Node have visualization attributes as volume have. When undefined by users, painting a node on a pad will take the corresponding volume attributes.

![https://root.cern/doc/v636/geom_t_node.png](https://root.cern/doc/v636/geom_t_node.png)

Related functions: [`Browse`](@ref), [`CheckOverlaps`](@ref), [`CheckShapes`](@ref), [`CountDaughters`](@ref), [`DistancetoPrimitive`](@ref), [`DrawOnly`](@ref), [`DrawOverlaps`](@ref), [`Draw`](@ref), [`ExecuteEvent`](@ref), [`FillIdArray`](@ref), [`FindNode`](@ref), [`GetByteCount`](@ref), [`GetColour`](@ref), [`GetDaughter`](@ref), [`GetFWExtension`](@ref), [`GetFinder`](@ref), [`GetIndex`](@ref), [`GetMatrix`](@ref), [`GetMedium`](@ref), [`GetMotherVolume`](@ref), [`GetNdaughters`](@ref), [`GetNodes`](@ref), [`GetNumber`](@ref), [`GetObjectInfo`](@ref), [`GetOptimalVoxels`](@ref), [`GetOverlaps`](@ref), [`GetUserExtension`](@ref), [`GetVolume`](@ref), [`GrabFWExtension`](@ref), [`GrabUserExtension`](@ref), [`InspectNode`](@ref), [`IsCloned`](@ref), [`IsFolder`](@ref), [`IsOffset`](@ref), [`IsOnScreen`](@ref), [`IsOverlapping`](@ref), [`IsVirtual`](@ref), [`IsVisDaughters`](@ref), [`IsVisible`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeCopyNode`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MayOverlap`](@ref), [`Paint`](@ref), [`PrintCandidates`](@ref), [`PrintOverlaps`](@ref), [`Safety`](@ref), [`SaveAttributes`](@ref), [`SetAllInvisible`](@ref), [`SetCloned`](@ref), [`SetCurrentPoint`](@ref), [`SetFWExtension`](@ref), [`SetInvisible`](@ref), [`SetMotherVolume`](@ref), [`SetNumber`](@ref), [`SetOverlapping`](@ref), [`SetOverlaps`](@ref), [`SetUserExtension`](@ref), [`SetVirtual`](@ref), [`SetVisibility`](@ref), [`SetVolume`](@ref), [`TGeoNode`](@ref), [`VisibleDaughters`](@ref), [`cd`](@ref), [`ls`](@ref)
""" TGeoNode

# Wrapper of TGeoNavigator
@trydoc raw"""
    ROOT.TGeoNavigator

Class providing navigation API for TGeo geometries.

Several instances are allowed for a single geometry. A default navigator is provided for any geometry but one may add several others for parallel navigation:

    TGeoNavigator *navig = new TGeoNavigator(gGeoManager);
    Int_t inav = gGeoManager->AddNavigator(navig);
    gGeoManager->SetCurrentNavigator(inav);

(C++ version of the code)

.... and then switch back to the default navigator:

    gGeoManager->SetCurrentNavigator(0);

(C++ version of the code)

Related functions: [`BuildCache`](@ref), [`CdDown`](@ref), [`CdNext`](@ref), [`CdNode`](@ref), [`CdTop`](@ref), [`CdUp`](@ref), [`CheckPath`](@ref), [`CrossBoundaryAndLocate`](@ref), [`DoBackupState`](@ref), [`DoRestoreState`](@ref), [`FindNextBoundaryAndStep`](@ref), [`FindNextBoundary`](@ref), [`FindNextDaughterBoundary`](@ref), [`FindNode`](@ref), [`FindNormalFast`](@ref), [`FindNormal`](@ref), [`GetBranchNames`](@ref), [`GetBranchNumbers`](@ref), [`GetBranchOnlys`](@ref), [`GetCache`](@ref), [`GetCldirChecked`](@ref), [`GetCldir`](@ref), [`GetCurrentDirection`](@ref), [`GetCurrentMatrix`](@ref), [`GetCurrentNodeId`](@ref), [`GetCurrentNode`](@ref), [`GetCurrentPoint`](@ref), [`GetCurrentVolume`](@ref), [`GetDivMatrix`](@ref), [`GetHMatrix`](@ref), [`GetLastPoint`](@ref), [`GetLastSafety`](@ref), [`GetLevel`](@ref), [`GetMotherMatrix`](@ref), [`GetMother`](@ref), [`GetNextDaughterIndex`](@ref), [`GetNextNode`](@ref), [`GetNmany`](@ref), [`GetNodeId`](@ref), [`GetNormal`](@ref), [`GetPWSafetyEstimateFromCache`](@ref), [`GetPWSafety`](@ref), [`GetPath`](@ref), [`GetSafeDistance`](@ref), [`GetSafeLevel`](@ref), [`GetStackLevel`](@ref), [`GetStep`](@ref), [`GetThreadId`](@ref), [`GetVirtualLevel`](@ref), [`GotoSafeLevel`](@ref), [`InitTrack`](@ref), [`InspectState`](@ref), [`IsCheckingOverlaps`](@ref), [`IsCurrentOverlapping`](@ref), [`IsEntering`](@ref), [`IsExiting`](@ref), [`IsNullStep`](@ref), [`IsOnBoundary`](@ref), [`IsOutside`](@ref), [`IsSafeStep`](@ref), [`IsSameLocation`](@ref), [`IsSamePoint`](@ref), [`IsStartSafe`](@ref), [`IsStepEntering`](@ref), [`IsStepExiting`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MasterToTop`](@ref), [`PopDummy`](@ref), [`PopPath`](@ref), [`PopPoint`](@ref), [`PushPath`](@ref), [`PushPoint`](@ref), [`ResetAll`](@ref), [`ResetState`](@ref), [`Safety`](@ref), [`SearchNode`](@ref), [`SetCheckingOverlaps`](@ref), [`SetCldirChecked`](@ref), [`SetCurrentDirection`](@ref), [`SetCurrentPoint`](@ref), [`SetLastPoint`](@ref), [`SetLastSafetyForPoint`](@ref), [`SetOutside`](@ref), [`SetStartSafe`](@ref), [`SetStep`](@ref), [`Step`](@ref), [`TGeoNavigator!IsPWSafetyCaching`](@ref), [`TGeoNavigator!SetPWSafetyCaching`](@ref), [`TGeoNavigator`](@ref), [`TopToMaster`](@ref), [`cd`](@ref)
""" TGeoNavigator

# Wrapper of TGeoBuilder
@trydoc raw"""
    ROOT.TGeoBuilder

Utility class for creating geometry objects.These will be associated with the current selected geometry manager object:

`TGeoBuilder!Instance()->SetGeometry(gGeoManager);`

The geometry builder is a singleton that may be used to build one or more geometries.

Related functions: [`AddMaterial`](@ref), [`AddShape`](@ref), [`AddTransformation`](@ref), [`Division`](@ref), [`MakeArb8`](@ref), [`MakeBox`](@ref), [`MakeCone`](@ref), [`MakeCons`](@ref), [`MakeCtub`](@ref), [`MakeEltu`](@ref), [`MakeGtra`](@ref), [`MakeHype`](@ref), [`MakePara`](@ref), [`MakeParaboloid`](@ref), [`MakePcon`](@ref), [`MakePgon`](@ref), [`MakeSphere`](@ref), [`MakeTorus`](@ref), [`MakeTrap`](@ref), [`MakeTrd1`](@ref), [`MakeTrd2`](@ref), [`MakeTube`](@ref), [`MakeTubs`](@ref), [`MakeVolumeAssembly`](@ref), [`MakeVolumeMulti`](@ref), [`MakeXtru`](@ref), [`Material`](@ref), [`Matrix`](@ref), [`Medium`](@ref), [`Mixture`](@ref), [`Node`](@ref), [`RegisterMatrix`](@ref), [`TGeoBuilder!Instance`](@ref), [`Volume`](@ref)
""" TGeoBuilder

# Wrapper of TGeoManager
@trydoc raw"""
    ROOT.TGeoManager

The manager class for any TGeo geometry.

Provides user interface for geometry creation, navigation, state querying, visualization, IO, geometry checking and other utilities.

## General architecture

The [ROOT](@ref) geometry package is a tool designed for building, browsing, tracking and visualizing a detector geometry. The code is independent from other external MC for simulation, therefore it does not contain any constraints related to physics. However, the package defines a number of hooks for tracking, such as media, materials, magnetic field or track state flags, in order to allow interfacing to tracking MC's. The final goal is to be able to use the same geometry for several purposes, such as tracking, reconstruction or visualization, taking advantage of the [ROOT](@ref) features related to bookkeeping, I/O, histogramming, browsing and GUI's.

The geometrical modeler is the most important component of the package and it provides answers to the basic questions like "Where am I ?" or "How far
from the next boundary ?", but also to more complex ones like "How far from
the closest surface ?" or "Which is the next crossing along a helix ?".

The architecture of the modeler is a combination between a GEANT-like containment scheme and a normal CSG binary tree at the level of shapes. An important common feature of all detector geometry descriptions is the mother-daughter concept. This is the most natural approach when tracking is concerned and imposes a set of constraints to the way geometry is defined. Constructive solid geometry composition is used only in order to create more complex shapes from an existing set of primitives through boolean operations. This feature is not implemented yet but in future full definition of boolean expressions will be supported.

Practically every geometry defined in GEANT style can be mapped by the modeler. The basic components used for building the logical hierarchy of the geometry are called "volumes" and "nodes". Volumes (sometimes called "solids") are fully defined geometrical objects having a given shape and medium and possibly containing a list of nodes. Nodes represent just positioned instances of volumes inside a container volume and they are not directly defined by user. They are automatically created as a result of adding one volume inside other or dividing a volume. The geometrical transformation hold by nodes is always defined with respect to their mother (relative positioning). Reflection matrices are allowed. All volumes have to be fully aware of their containees when the geometry is closed. They will build additional structures (voxels) in order to fasten-up the search algorithms. Finally, nodes can be regarded as bidirectional links between containers and containees objects.

The structure defined in this way is a graph structure since volumes are replicable (same volume can become daughter node of several other volumes), every volume becoming a branch in this graph. Any volume in the logical graph can become the actual top volume at run time (see [TGeoManager!SetTopVolume()](@ref)). All functionalities of the modeler will behave in this case as if only the corresponding branch starting from this volume is the registered geometry.

![https://root.cern/doc/v636/geom_graf.jpg](https://root.cern/doc/v636/geom_graf.jpg)

A given volume can be positioned several times in the geometry. A volume can be divided according default or user-defined patterns, creating automatically the list of division nodes inside. The elementary volumes created during the dividing process follow the same scheme as usual volumes, therefore it is possible to position further geometrical structures inside or to divide them further more (see [TGeoVolume!Divide()](@ref)).

The primitive shapes supported by the package are basically the GEANT3 shapes (see class [TGeoShape](@ref)), arbitrary wedges with eight vertices on two parallel planes. All basic primitives inherits from class [TGeoBBox](@ref) since the bounding box of a solid is essential for the tracking algorithms. They also implement the virtual methods defined in the virtual class [TGeoShape](@ref) (point and segment classification). User-defined primitives can be directly plugged into the modeler provided that they override these methods. Composite shapes will be soon supported by the modeler. In order to build a [TGeoCompositeShape](@ref), one will have to define first the primitive components. The object that handle boolean operations among components is called TGeoBoolCombinator and it has to be constructed providing a string boolean expression between the components names.

## Example for building a simple geometry

(C++ version of the code)

 End_Macro

## TGeoManager - the manager class for the geometry package.

[TGeoManager](@ref) class is embedding all the API needed for building and tracking a geometry. It defines a global_ pointer (gGeoManager) in order to be fully accessible from external code. The mechanism of handling multiple geometries at the same time will be soon implemented.

[TGeoManager](@ref) is the owner of all geometry objects defined in a session, therefore users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. Logical nodes (positioned volumes) are created and destroyed by the [TGeoVolume](@ref) class. Physical nodes and their global_ transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The caching mechanism is triggered by the total number of physical instances of volumes and the cache manager is a client of [TGeoManager](@ref). The manager class also controls the painter client. This is linked with [ROOT](@ref) graphical libraries loaded on demand in order to control visualization actions.

## Rules for building a valid geometry

A given geometry can be built in various ways, but there are mandatory steps that have to be followed in order to be validated by the modeler. There are general rules : volumes needs media and shapes in order to be created, both container and containee volumes must be created before linking them together, and the relative transformation matrix must be provided. All branches must have an upper link point otherwise they will not be considered as part of the geometry. Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global_ visualization settings (see [TGeoPainter](@ref) class) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules : positioned daughters should not extrude their mother or intersect with sisters unless this is specified (see [TGeoVolume!AddNodeOverlap()](@ref)), the top volume (containing all geometry tree) must be specified before closing the geometry and must not be positioned - it represents the global_ reference frame. After building the full geometry tree, the geometry must be closed (see [TGeoManager!CloseGeometry()](@ref)). Voxelization can be redone per volume after this process.

Below is the general scheme of the manager class.

![https://root.cern/doc/v636/geom_mgr.jpg](https://root.cern/doc/v636/geom_mgr.jpg)

## An interactive session

Provided that a geometry was successfully built and closed (for instance the previous example $ROOTSYS/tutorials/visualisation/geom/rootgeom.C ), the manager class will register itself to [ROOT](@ref) and the logical/physical structures will become immediately browsable. The [ROOT](@ref) browser will display starting from the geometry folder : the list of transformations and media, the top volume and the top logical node. These last two can be fully expanded, any intermediate volume/node in the browser being subject of direct access context menu operations (right mouse button click). All user utilities of classes [TGeoManager](@ref), [TGeoVolume](@ref) and [TGeoNode](@ref) can be called via the context menu.

![https://root.cern/doc/v636/geom_browser.jpg](https://root.cern/doc/v636/geom_browser.jpg)

### Drawing the geometry

Any logical volume can be drawn via [TGeoVolume!Draw()](@ref) member function. This can be directly accessed from the context menu of the volume object directly from the browser. There are several drawing options that can be set with [TGeoManager!SetVisOption(Int_t opt)](@ref) method :

#### opt=0

only the content of the volume is drawn, N levels down (default N=3). This is the default behavior. The number of levels to be drawn can be changed via [TGeoManager!SetVisLevel(Int_t level)](@ref) method.

![https://root.cern/doc/v636/geom_frame0.jpg](https://root.cern/doc/v636/geom_frame0.jpg)

#### opt=1

the final leaves (e.g. daughters with no containment) of the branch starting from volume are drawn down to the current number of levels. WARNING : This mode is memory consuming depending of the size of geometry, so drawing from top level within this mode should be handled with care for expensive geometries. In future there will be a limitation on the maximum number of nodes to be visualized.

![https://root.cern/doc/v636/geom_frame1.jpg](https://root.cern/doc/v636/geom_frame1.jpg)

#### opt=2

only the clicked volume is visualized. This is automatically set by [TGeoVolume!DrawOnly()](@ref) method

#### opt=3 - only a given path is visualized. This is automatically set by

TGeoVolume!DrawPath(const char *path) method

The current view can be exploded in cartesian, cylindrical or spherical coordinates : [TGeoManager!SetExplodedView(Int_t opt)](@ref). Options may be :

- 0 - default (no bombing)
- 1 - cartesian coordinates. The bomb factor on each axis can be set with TGeoManager!SetBombX(Double_t bomb) and corresponding Y and Z.
- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R are considered ![https://root.cern/doc/v636/geom_frameexp.jpg](https://root.cern/doc/v636/geom_frameexp.jpg)
- 3 - bomb in radial spherical coordinate : TGeoManager!SetBombR()

Volumes themselves support different visualization settings :

- [TGeoVolume!SetVisibility()](@ref) : set volume visibility.
- [TGeoVolume!VisibleDaughters()](@ref) : set daughters visibility. All these actions automatically updates the current view if any.

### Checking the geometry

Several checking methods are accessible from the volume context menu. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the [TGeoChecker](@ref) class from the painting package.

#### Checking a given point.

Can be called from TGeoManager!CheckPoint(Double_t x, Double_t y, Double_t z). This method is drawing the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. The point will be drawn in red, as well as a sphere having this closest distance as radius. In case a non-zero distance is given by the user as fifth argument of CheckPoint, this distance will be used as radius of the safety sphere.

![https://root.cern/doc/v636/geom_checkpoint.jpg](https://root.cern/doc/v636/geom_checkpoint.jpg)

#### Shooting random points.

Can be called from [TGeoVolume!RandomPoints()](@ref) (context menu function) and it will draw this volume with current visualization settings. Random points are generated in the bounding box of the top drawn volume. The points are classified and drawn with the color of their deepest container. Only points in visible nodes will be drawn.

![https://root.cern/doc/v636/geom_random1.jpg](https://root.cern/doc/v636/geom_random1.jpg)

#### Raytracing.

Can be called from [TGeoVolume!RandomRays()](@ref) (context menu of volumes) and will shoot rays from a given point in the local_ reference frame with random directions. The intersections with displayed nodes will appear as segments having the color of the touched node. Drawn geometry will be then made invisible in order to enhance rays.

![https://root.cern/doc/v636/geom_random2.jpg](https://root.cern/doc/v636/geom_random2.jpg)

Related functions: [`AddBorderSurface`](@ref), [`AddGDMLMatrix`](@ref), [`AddMaterial`](@ref), [`AddNavigator`](@ref), [`AddOpticalSurface`](@ref), [`AddOverlap`](@ref), [`AddProperty`](@ref), [`AddRegion`](@ref), [`AddShape`](@ref), [`AddSkinSurface`](@ref), [`AddTrack`](@ref), [`AddTransformation`](@ref), [`AddVolume`](@ref), [`AnimateTracks`](@ref), [`BombTranslation`](@ref), [`Browse`](@ref), [`BuildDefaultMaterials`](@ref), [`CdDown`](@ref), [`CdNext`](@ref), [`CdNode`](@ref), [`CdTop`](@ref), [`CdUp`](@ref), [`CheckBoundaryErrors`](@ref), [`CheckBoundaryReference`](@ref), [`CheckGeometryFull`](@ref), [`CheckGeometry`](@ref), [`CheckOverlaps`](@ref), [`CheckPath`](@ref), [`CheckPoint`](@ref), [`CheckShape`](@ref), [`CleanGarbage`](@ref), [`ClearAttributes`](@ref), [`ClearNavigators`](@ref), [`ClearOverlaps`](@ref), [`ClearPhysicalNodes`](@ref), [`ClearShape`](@ref), [`ClearThreadData`](@ref), [`ClearTracks`](@ref), [`CloseGeometry`](@ref), [`ConvertReflections`](@ref), [`CountLevels`](@ref), [`CountNodes`](@ref), [`CreateParallelWorld`](@ref), [`CreateThreadData`](@ref), [`CrossBoundaryAndLocate`](@ref), [`DefaultAngles`](@ref), [`DefaultColors`](@ref), [`DisableInactiveVolumes`](@ref), [`Division`](@ref), [`DoBackupState`](@ref), [`DoRestoreState`](@ref), [`DrawCurrentPoint`](@ref), [`DrawPath`](@ref), [`DrawTracks`](@ref), [`Edit`](@ref), [`EnableInactiveVolumes`](@ref), [`ExecuteEvent`](@ref), [`Export`](@ref), [`FindDuplicateMaterial`](@ref), [`FindNextBoundaryAndStep`](@ref), [`FindNextBoundary`](@ref), [`FindNextDaughterBoundary`](@ref), [`FindNode`](@ref), [`FindNormalFast`](@ref), [`FindNormal`](@ref), [`FindTrackWithId`](@ref), [`FindVolumeFast`](@ref), [`GetAlignableEntryByUID`](@ref), [`GetAlignableEntry`](@ref), [`GetBits`](@ref), [`GetBombFactors`](@ref), [`GetBombMode`](@ref), [`GetBorderSurface`](@ref), [`GetBranchNames`](@ref), [`GetBranchNumbers`](@ref), [`GetBranchOnlys`](@ref), [`GetByteCount`](@ref), [`GetCache`](@ref), [`GetCldirChecked`](@ref), [`GetCldir`](@ref), [`GetClippingShape`](@ref), [`GetCurrentDirection`](@ref), [`GetCurrentMatrix`](@ref), [`GetCurrentNavigator`](@ref), [`GetCurrentNodeId`](@ref), [`GetCurrentNode`](@ref), [`GetCurrentPoint`](@ref), [`GetCurrentTrack`](@ref), [`GetCurrentVolume`](@ref), [`GetElementTable`](@ref), [`GetGDMLMatrix`](@ref), [`GetGLMatrix`](@ref), [`GetGeomPainter`](@ref), [`GetHMatrix`](@ref), [`GetLastPoint`](@ref), [`GetLastSafety`](@ref), [`GetLastTrack`](@ref), [`GetLevel`](@ref), [`GetListOfBorderSurfaces`](@ref), [`GetListOfGDMLMatrices`](@ref), [`GetListOfGShapes`](@ref), [`GetListOfGVolumes`](@ref), [`GetListOfMaterials`](@ref), [`GetListOfMatrices`](@ref), [`GetListOfMedia`](@ref), [`GetListOfNavigators`](@ref), [`GetListOfNodes`](@ref), [`GetListOfOpticalSurfaces`](@ref), [`GetListOfOverlaps`](@ref), [`GetListOfPhysicalNodes`](@ref), [`GetListOfRegions`](@ref), [`GetListOfShapes`](@ref), [`GetListOfSkinSurfaces`](@ref), [`GetListOfTracks`](@ref), [`GetListOfUVolumes`](@ref), [`GetListOfVolumes`](@ref), [`GetMasterVolume`](@ref), [`GetMaterialIndex`](@ref), [`GetMaterial`](@ref), [`GetMaxLevel`](@ref), [`GetMaxThreads`](@ref), [`GetMaxVisNodes`](@ref), [`GetMedium`](@ref), [`GetMotherMatrix`](@ref), [`GetMother`](@ref), [`GetNAlignable`](@ref), [`GetNNodes`](@ref), [`GetNextNode`](@ref), [`GetNmany`](@ref), [`GetNodeId`](@ref), [`GetNode`](@ref), [`GetNormal`](@ref), [`GetNproperties`](@ref), [`GetNregions`](@ref), [`GetNsegments`](@ref), [`GetNtracks`](@ref), [`GetOpticalSurface`](@ref), [`GetPaintVolume`](@ref), [`GetPainter`](@ref), [`GetParallelWorld`](@ref), [`GetParentTrackOfId`](@ref), [`GetParticleName`](@ref), [`GetPath`](@ref), [`GetPdgName`](@ref), [`GetPhysicalNode`](@ref), [`GetProperty`](@ref), [`GetRTmode`](@ref), [`GetRegion`](@ref), [`GetSafeDistance`](@ref), [`GetSafeLevel`](@ref), [`GetSkinSurface`](@ref), [`GetStackLevel`](@ref), [`GetStep`](@ref), [`GetTmax`](@ref), [`GetTminTmax`](@ref), [`GetTopNode`](@ref), [`GetTopVolume`](@ref), [`GetTrackIndex`](@ref), [`GetTrackOfId`](@ref), [`GetTrack`](@ref), [`GetUID`](@ref), [`GetUserPaintVolume`](@ref), [`GetVirtualLevel`](@ref), [`GetVisDensity`](@ref), [`GetVisLevel`](@ref), [`GetVisOption`](@ref), [`GetVolume`](@ref), [`GotoSafeLevel`](@ref), [`InitTrack`](@ref), [`InspectState`](@ref), [`IsActivityEnabled`](@ref), [`IsAnimatingTracks`](@ref), [`IsCheckingOverlaps`](@ref), [`IsCleaning`](@ref), [`IsClosed`](@ref), [`IsCurrentOverlapping`](@ref), [`IsDrawingExtra`](@ref), [`IsEntering`](@ref), [`IsExiting`](@ref), [`IsFolder`](@ref), [`IsInPhiRange`](@ref), [`IsMatrixReflection`](@ref), [`IsMatrixTransform`](@ref), [`IsMultiThread`](@ref), [`IsNodeSelectable`](@ref), [`IsNullStep`](@ref), [`IsOnBoundary`](@ref), [`IsOutside`](@ref), [`IsParallelWorldNav`](@ref), [`IsSameLocation`](@ref), [`IsSamePoint`](@ref), [`IsStartSafe`](@ref), [`IsStepEntering`](@ref), [`IsStepExiting`](@ref), [`IsStreamingVoxels`](@ref), [`IsVisLeaves`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MakeAlignablePN`](@ref), [`MakeArb8`](@ref), [`MakeBox`](@ref), [`MakeCone`](@ref), [`MakeCons`](@ref), [`MakeCtub`](@ref), [`MakeEltu`](@ref), [`MakeGtra`](@ref), [`MakeHype`](@ref), [`MakePara`](@ref), [`MakeParaboloid`](@ref), [`MakePcon`](@ref), [`MakePgon`](@ref), [`MakePhysicalNode`](@ref), [`MakeSphere`](@ref), [`MakeTorus`](@ref), [`MakeTrack`](@ref), [`MakeTrap`](@ref), [`MakeTrd1`](@ref), [`MakeTrd2`](@ref), [`MakeTube`](@ref), [`MakeTubs`](@ref), [`MakeVolumeAssembly`](@ref), [`MakeVolumeMulti`](@ref), [`MakeXtru`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`MasterToTop`](@ref), [`Material`](@ref), [`Matrix`](@ref), [`Medium`](@ref), [`Mixture`](@ref), [`ModifiedPad`](@ref), [`Node`](@ref), [`OptimizeVoxels`](@ref), [`PopDummy`](@ref), [`PopPath`](@ref), [`PopPoint`](@ref), [`PrintOverlaps`](@ref), [`PushPath`](@ref), [`PushPoint`](@ref), [`RandomPoints`](@ref), [`RandomRays`](@ref), [`RefreshPhysicalNodes`](@ref), [`RegisterMatrix`](@ref), [`RemoveMaterial`](@ref), [`RemoveNavigator`](@ref), [`ReplaceVolume`](@ref), [`ResetState`](@ref), [`ResetUserData`](@ref), [`RestoreMasterVolume`](@ref), [`Safety`](@ref), [`SamplePoints`](@ref), [`SaveAttributes`](@ref), [`SearchNode`](@ref), [`SelectTrackingMedia`](@ref), [`SetAlignableEntry`](@ref), [`SetAllIndex`](@ref), [`SetAnimateTracks`](@ref), [`SetBombFactors`](@ref), [`SetCheckedNode`](@ref), [`SetCheckingOverlaps`](@ref), [`SetCldirChecked`](@ref), [`SetClippingShape`](@ref), [`SetClipping`](@ref), [`SetCurrentDirection`](@ref), [`SetCurrentNavigator`](@ref), [`SetCurrentPoint`](@ref), [`SetCurrentTrack`](@ref), [`SetDrawExtraPaths`](@ref), [`SetExplodedView`](@ref), [`SetLastPoint`](@ref), [`SetMatrixReflection`](@ref), [`SetMatrixTransform`](@ref), [`SetMaxThreads`](@ref), [`SetMaxVisNodes`](@ref), [`SetNmeshPoints`](@ref), [`SetNodeSelectable`](@ref), [`SetNsegments`](@ref), [`SetOutside`](@ref), [`SetPaintVolume`](@ref), [`SetParticleName`](@ref), [`SetPdgName`](@ref), [`SetPhiRange`](@ref), [`SetRTmode`](@ref), [`SetStartSafe`](@ref), [`SetStep`](@ref), [`SetTminTmax`](@ref), [`SetTopVisible`](@ref), [`SetTopVolume`](@ref), [`SetUseParallelWorldNav`](@ref), [`SetUserPaintVolume`](@ref), [`SetVisDensity`](@ref), [`SetVisLevel`](@ref), [`SetVisOption`](@ref), [`SetVisibility`](@ref), [`SetVolumeAttribute`](@ref), [`SizeOf`](@ref), [`SortOverlaps`](@ref), [`Step`](@ref), [`TGeoManager!ClearThreadsMap`](@ref), [`TGeoManager!GetDefaultUnits`](@ref), [`TGeoManager!GetExportPrecision`](@ref), [`TGeoManager!GetMaxDaughters`](@ref), [`TGeoManager!GetMaxLevels`](@ref), [`TGeoManager!GetMaxXtruVert`](@ref), [`TGeoManager!GetNumThreads`](@ref), [`TGeoManager!GetVerboseLevel`](@ref), [`TGeoManager!Import`](@ref), [`TGeoManager!IsLocked`](@ref), [`TGeoManager!LockDefaultUnits`](@ref), [`TGeoManager!LockGeometry`](@ref), [`TGeoManager!Parse`](@ref), [`TGeoManager!SetDefaultUnits`](@ref), [`TGeoManager!SetExportPrecision`](@ref), [`TGeoManager!SetNavigatorsLock`](@ref), [`TGeoManager!SetVerboseLevel`](@ref), [`TGeoManager!ThreadId`](@ref), [`TGeoManager!UnlockGeometry`](@ref), [`TGeoManager`](@ref), [`TestOverlaps`](@ref), [`Test`](@ref), [`TopToMaster`](@ref), [`TransformVolumeToAssembly`](@ref), [`UnbombTranslation`](@ref), [`ViewLeaves`](@ref), [`Volume`](@ref), [`Weight`](@ref), [`cd`](@ref)
""" TGeoManager

# Wrapper of TGeoMaterial
@trydoc raw"""
    ROOT.TGeoMaterial

Base class describing materials.

## Important note about units

Since **v6-17-02** the geometry package adopted a system of units, upon the request to support an in-memory material representation consistent with the one in Geant4. The adoption was done gradually and starting with **v6-19-02** (back-ported to **v6-18-02**) the package supports changing the default units to either [ROOT](@ref) (CGS) or Geant4 ones. In the same version the Geant4 units were set to be the default ones, changing the previous behavior and making material properties such as radiation and interaction lengths having in memory values an order of magnitude lower. This behavior affected versions up to **v6-25-01**, after which the default units were restored to be the [ROOT](@ref) ones.

For users needing to restore the CGS behavior for material properties, the following sequence needs to be called before creating the [TGeoManager](@ref) instance: From **v6-18-02** to **v6-22-06**: 

    TGeoUnit!setUnitType(TGeoUnit!kTGeoUnits);

(C++ version of the code)

From **v6-22-08** to **v6-25-01**: 

    TGeoManager!LockDefaultUnits(false);
    TGeoManager!SetDefaultUnits(kRootUnits);
    TGeoManager!LockDefaultUnits(true);

(C++ version of the code)

Related functions: [`AddConstProperty`](@ref), [`AddProperty`](@ref), [`DecayMaterial`](@ref), [`FillMaterialEvolution`](@ref), [`GetA`](@ref), [`GetBaseElement`](@ref), [`GetByteCount`](@ref), [`GetCerenkovProperties`](@ref), [`GetConstProperties`](@ref), [`GetConstPropertyRef`](@ref), [`GetConstProperty`](@ref), [`GetDefaultColor`](@ref), [`GetDensity`](@ref), [`GetElementProp`](@ref), [`GetElement`](@ref), [`GetFWExtension`](@ref), [`GetIndex`](@ref), [`GetIntLen`](@ref), [`GetNconstProperties`](@ref), [`GetNelements`](@ref), [`GetNproperties`](@ref), [`GetPointerName`](@ref), [`GetPressure`](@ref), [`GetProperties`](@ref), [`GetPropertyRef`](@ref), [`GetProperty`](@ref), [`GetRadLen`](@ref), [`GetSpecificActivity`](@ref), [`GetState`](@ref), [`GetTemperature`](@ref), [`GetTransparency`](@ref), [`GetUserExtension`](@ref), [`GetZ`](@ref), [`GrabFWExtension`](@ref), [`GrabUserExtension`](@ref), [`IsEq`](@ref), [`IsMixture`](@ref), [`IsUsed`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetA`](@ref), [`SetCerenkovProperties`](@ref), [`SetDensity`](@ref), [`SetFWExtension`](@ref), [`SetIndex`](@ref), [`SetPressure`](@ref), [`SetRadLen`](@ref), [`SetState`](@ref), [`SetTemperature`](@ref), [`SetTransparency`](@ref), [`SetUsed`](@ref), [`SetUserExtension`](@ref), [`SetZ`](@ref), [`TGeoMaterial!Coulomb`](@ref), [`TGeoMaterial!ScreenFactor`](@ref), [`TGeoMaterial`](@ref)
""" TGeoMaterial

# Wrapper of TGeoMedium
@trydoc raw"""
    ROOT.TGeoMedium

Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC).

One may define several tracking media for a given material. The media ID are user defined values that are not used by the geometry package. In case geometry is used via VMC (in GEANT) these numbers are overwritten, so one can only rely on these values after gMC->FinishGeometry() is called. The media parameters are inspired from GEANT3 and the values defined make sense in context of GEANT (3 but also 4) or FLUKA interfaces.

Related functions: [`GetByteCount`](@ref), [`GetId`](@ref), [`GetMaterial`](@ref), [`GetParam`](@ref), [`GetPointerName`](@ref), [`SavePrimitive`](@ref), [`SetCerenkovProperties`](@ref), [`SetId`](@ref), [`SetMaterial`](@ref), [`SetParam`](@ref), [`TGeoMedium`](@ref)
""" TGeoMedium

# Wrapper of TGeoVolumeAssembly
@trydoc raw"""
    ROOT.TGeoVolumeAssembly

Volume assemblies.

Assemblies a volumes that have neither a shape or a material/medium. Assemblies behave exactly like normal volumes grouping several daughters together, but the daughters can never extrude the assembly since this has no shape. However, a bounding box and a voxelization structure are built for assemblies as for normal volumes, so that navigation is still optimized. Assemblies are useful for grouping hierarchically volumes which are otherwise defined in a flat manner, but also to avoid clashes between container shapes. To define an assembly one should just input a name, then thestart adding other volumes (or volume assemblies) as content.

Related functions: [`AddNodeOverlap`](@ref), [`AddNode`](@ref), [`ClearThreadData`](@ref), [`CloneVolume`](@ref), [`CreateThreadData`](@ref), [`Divide`](@ref), [`DrawOnly`](@ref), [`GetCurrentNodeIndex`](@ref), [`GetNextNodeIndex`](@ref), [`GetThreadData`](@ref), [`IsAssembly`](@ref), [`IsVisible`](@ref), [`SetCurrentNodeIndex`](@ref), [`SetNextNodeIndex`](@ref), [`TGeoVolumeAssembly!MakeAssemblyFromVolume`](@ref), [`TGeoVolumeAssembly`](@ref)
""" TGeoVolumeAssembly

# Wrapper of TGeoVolumeMulti
@trydoc raw"""
    ROOT.TGeoVolumeMulti

Volume families.

A volume family is represented by the class [TGeoVolumeMulti](@ref). It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a [TGeoVolume](@ref) equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:

    TGeoManager!Volume(const char *vname, const char *shape, Int_t nmed);

(C++ version of the code)

where VNAME is the family name, NMED is the medium number and SHAPE is the shape type that can be:

    box    - for TGeoBBox
    trd1   - for TGeoTrd1
    trd2   - for TGeoTrd2
    trap   - for TGeoTrap
    gtra   - for TGeoGtra
    para   - for TGeoPara
    tube, tubs - for TGeoTube, TGeoTubeSeg
    cone, cons - for TGeoCone, TgeoCons
    eltu   - for TGeoEltu
    ctub   - for TGeoCtub
    pcon   - for TGeoPcon
    pgon   - for TGeoPgon

(C++ version of the code)

Volumes are then added to a given family upon adding the generic name as node inside other volume:

    TGeoVolume *box_family = gGeoManager->Volume("BOXES", "box", nmed);
    ...
    gGeoManager->Node("BOXES", Int_t copy_no, "mother_name",
                      Double_t x, Double_t y, Double_t z, Int_t rot_index,
                      Bool_t is_only, Double_t *upar, Int_t npar);

(C++ version of the code)

here:

    BOXES   - name of the family of boxes
    copy_no - user node number for the created node
    mother_name - name of the volume to which we want to add the node
    x,y,z   - translation components
    rot_index   - indx of a rotation matrix in the list of matrices
    upar    - array of actual shape parameters
    npar    - number of parameters

(C++ version of the code)

The parameters order and number are the same as in the corresponding shape constructors.

Another particular case where volume families are used is when we want that a volume positioned inside a container to match one ore more container limits. Suppose we want to position the same box inside 2 different volumes and we want the Z size to match the one of each container:

    TGeoVolume *container1 = gGeoManager->MakeBox("C1", imed, 10,10,30);
    TGeoVolume *container2 = gGeoManager->MakeBox("C2", imed, 10,10,20);
    TGeoVolume *pvol       = gGeoManager->MakeBox("PVOL", jmed, 3,3,-1);
    container1->AddNode(pvol, 1);
    container2->AddNode(pvol, 1);

(C++ version of the code)

Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the [TGeoVolumeMulti](@ref) class, which does not need to be instantiated by users.

### Dividing volumes

Volumes can be divided according a pattern. The most simple division can be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take the most simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:

    TGeoVolume *slicex = box->Divide("SLICEX", 1, N);

(C++ version of the code)

where SLICE is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi. In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family. Divisions can be also performed in a given range of one axis. For that, one have to specify also the starting coordinate value and the step:

    TGeoVolume *slicex = box->Divide("SLICEX", 1, N, thestart, step);

(C++ version of the code)

A check is always done on the resulting division range : if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 upto N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside an other volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:

    TGeoVolume *slicey = slicex->Divide("SLICEY", 2, N1);
    slicey->AddNode(other_vol, index, some_matrix);

(C++ version of the code)

When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all. In the example above all the resulting slices had the same shape as the divided volume (box). This is not always the case. For instance, dividing a volume with TUBE shape on PHI axis will create equal slices having TUBESEG shape. Other divisions can also create slices having shapes with different dimensions, e.g. the division of a TRD1 volume on Z. When positioning volumes inside slices, one can do it using the generic volume family (e.g. slicey). This should be done as if the coordinate system of the generic slice was the same as the one of the divided volume. The generic slice in case of PHI division is centered with respect to X axis. If the family contains slices of different sizes, any volume positioned inside should fit into the smallest one. Examples for specific divisions according to shape types can be found inside shape classes.

    TGeoVolume!Divide(N, Xmin, Xmax, "X");

(C++ version of the code)

The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping volume is in fact a virtual container that does not represent a physical object. It contains a list of nodes that are not its daughters but that must be checked always before the container itself. This list must be defined by users and it is checked and resolved in a priority order. Note that the feature is non-standard to geometrical modelers and it was introduced just to support conversions of GEANT3 geometries, therefore its extensive usage should be avoided.

Related functions: [`AddNodeOverlap`](@ref), [`AddNode`](@ref), [`AddVolume`](@ref), [`Divide`](@ref), [`GetAxis`](@ref), [`GetLastShape`](@ref), [`GetNdiv`](@ref), [`GetNvolumes`](@ref), [`GetStart`](@ref), [`GetStep`](@ref), [`GetVolume`](@ref), [`IsVolumeMulti`](@ref), [`MakeCopyVolume`](@ref), [`SetLineColor`](@ref), [`SetLineStyle`](@ref), [`SetLineWidth`](@ref), [`SetMedium`](@ref), [`SetVisibility`](@ref), [`TGeoVolumeMulti`](@ref)
""" TGeoVolumeMulti

# Wrapper of TGeoElement
@trydoc raw"""
    ROOT.TGeoElement

Base class for chemical elements.



Related functions: [`A`](@ref), [`AddIsotope`](@ref), [`ComputeDerivedQuantities`](@ref), [`ENDFCode`](@ref), [`GetIsotope`](@ref), [`GetNisotopes`](@ref), [`GetRelativeAbundance`](@ref), [`GetSpecificActivity`](@ref), [`GetfCoulomb`](@ref), [`GetfRadTsai`](@ref), [`HasIsotopes`](@ref), [`IsDefined`](@ref), [`IsRadioNuclide`](@ref), [`IsUsed`](@ref), [`N`](@ref), [`Neff`](@ref), [`Print`](@ref), [`SetDefined`](@ref), [`SetUsed`](@ref), [`TGeoElement!GetElementTable`](@ref), [`TGeoElement`](@ref), [`Z`](@ref)
""" TGeoElement

# Wrapper of TGeoIsotope
@trydoc raw"""
    ROOT.TGeoIsotope

an isotope defined by the atomic number, number of nucleons and atomic weight (g/mole)



Related functions: [`GetA`](@ref), [`GetN`](@ref), [`GetZ`](@ref), [`Print`](@ref), [`TGeoIsotope!FindIsotope`](@ref), [`TGeoIsotope`](@ref)
""" TGeoIsotope

# Wrapper of TGeoElementTable
@trydoc raw"""
    ROOT.TGeoElementTable

table of elements

Table of elements.

Related functions: [`AddElementRN`](@ref), [`AddElement`](@ref), [`AddIsotope`](@ref), [`BuildDefaultElements`](@ref), [`CheckTable`](@ref), [`ExportElementsRN`](@ref), [`FindElement`](@ref), [`FindIsotope`](@ref), [`GetElementRN`](@ref), [`GetElement`](@ref), [`GetElementsRN`](@ref), [`GetNelementsRN`](@ref), [`GetNelements`](@ref), [`HasDefaultElements`](@ref), [`HasRNElements`](@ref), [`ImportElementsRN`](@ref), [`Print`](@ref), [`TGeoElementTable`](@ref)
""" TGeoElementTable

# Wrapper of TGeoElementRN
@trydoc raw"""
    ROOT.TGeoElementRN

a radionuclide

Class representing a radionuclidevoid TGeoManager!SetDefaultRootUnits() { if ( fgDefaultUnits == kRootUnits ) { return; } else if ( gGeometryLocked ) { TError!Fatal("TGeoManager","The system of units may only be changed once BEFORE any elements and materials are
created!"); } fgDefaultUnits = kRootUnits; }.

Related functions: [`AddDecay`](@ref), [`AddRatio`](@ref), [`AtomicNo`](@ref), [`CheckDecays`](@ref), [`DecayResult`](@ref), [`Decays`](@ref), [`ENDFCode`](@ref), [`FillPopulation`](@ref), [`GetNdecays`](@ref), [`GetSpecificActivity`](@ref), [`HalfLife`](@ref), [`IsRadioNuclide`](@ref), [`IsoNo`](@ref), [`Level`](@ref), [`MassEx`](@ref), [`MassNo`](@ref), [`NatAbun`](@ref), [`PJ`](@ref), [`Print`](@ref), [`Ratio`](@ref), [`ResetRatio`](@ref), [`SavePrimitive`](@ref), [`Stable`](@ref), [`Status`](@ref), [`TG_F`](@ref), [`TG_S`](@ref), [`TGeoElementRN!ENDF`](@ref), [`TGeoElementRN!ReadElementRN`](@ref), [`TGeoElementRN`](@ref), [`TH_F`](@ref), [`TH_S`](@ref)
""" TGeoElementRN

# Wrapper of TGeoDecayChannel
@trydoc raw"""
    ROOT.TGeoDecayChannel

decay channel utility class.

A decay channel for a radionuclide.

Related functions: [`BranchingRatio`](@ref), [`Daughter`](@ref), [`DecayShift`](@ref), [`Decay`](@ref), [`DeltaIso`](@ref), [`GetIndex`](@ref), [`GetName`](@ref), [`Parent`](@ref), [`Print`](@ref), [`Qvalue`](@ref), [`SavePrimitive`](@ref), [`SetDaughter`](@ref), [`SetParent`](@ref), [`TGeoDecayChannel!DecayName`](@ref), [`TGeoDecayChannel!ReadDecay`](@ref), [`TGeoDecayChannel`](@ref), [`assign`](@ref)
""" TGeoDecayChannel

# Wrapper of TGeoBatemanSol
@trydoc raw"""
    ROOT.TGeoBatemanSol

Class representing the Bateman solution for a decay branch.



Related functions: [`Concentration`](@ref), [`Draw`](@ref), [`FindSolution`](@ref), [`GetCoeff`](@ref), [`GetElement`](@ref), [`GetNcoeff`](@ref), [`GetRange`](@ref), [`GetTopElement`](@ref), [`Normalize`](@ref), [`Print`](@ref), [`SetFactor`](@ref), [`SetRange`](@ref), [`TGeoBatemanSol`](@ref), [`add!`](@ref), [`assign`](@ref)
""" TGeoBatemanSol

# Wrapper of TGeoElemIter
@trydoc raw"""
    ROOT.TGeoElemIter

iterator for decay chains.

Iterator for decay branches.

Related functions: [`GetBranch`](@ref), [`GetElement`](@ref), [`GetLevel`](@ref), [`GetRatio`](@ref), [`GetTop`](@ref), [`Next`](@ref), [`Print`](@ref), [`SetLimitRatio`](@ref), [`TGeoElemIter`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TGeoElemIter

# Wrapper of TGeoExtension
@trydoc raw"""
    ROOT.TGeoExtension

ABC for user objects attached to [TGeoVolume](@ref) or [TGeoNode](@ref).

Provides interface for getting a reference (grab) and releasing the extension object (release), allowing for derived classes to implement reference counted sharing. The user who should attach extensions to logical volumes or nodes BEFORE applying misalignment information so that these will be available to all copies.

Related functions: [`Grab`](@ref), [`Release`](@ref)
""" TGeoExtension

# Wrapper of TGeoMixture
@trydoc raw"""
    ROOT.TGeoMixture

Mixtures of elements.



Related functions: [`AddElement`](@ref), [`ComputeDerivedQuantities`](@ref), [`ComputeNuclearInterLength`](@ref), [`ComputeRadiationLength`](@ref), [`DecayMaterial`](@ref), [`DefineElement`](@ref), [`FillMaterialEvolution`](@ref), [`GetAmixt`](@ref), [`GetByteCount`](@ref), [`GetElementProp`](@ref), [`GetElement`](@ref), [`GetNelements`](@ref), [`GetNmixt`](@ref), [`GetSpecificActivity`](@ref), [`GetWmixt`](@ref), [`GetZmixt`](@ref), [`IsEq`](@ref), [`IsMixture`](@ref), [`Print`](@ref), [`SavePrimitive`](@ref), [`SetA`](@ref), [`SetDensity`](@ref), [`SetZ`](@ref), [`TGeoMixture`](@ref)
""" TGeoMixture

# Wrapper of TGeoPatternFinder
@trydoc raw"""
    ROOT.TGeoPatternFinder

base finder class for patterns. A pattern is specifying a division type

Base finder class for patterns.

A pattern is specifying a division type which applies only to a given shape type. The implemented patterns are for the moment equidistant slices on different axis. Implemented patterns are:

- [TGeoPatternX](@ref) - a X axis divison pattern
- [TGeoPatternY](@ref) - a Y axis divison pattern
- [TGeoPatternZ](@ref) - a Z axis divison pattern
- [TGeoPatternParaX](@ref) - a X axis divison pattern for PARA shape
- [TGeoPatternParaY](@ref) - a Y axis divison pattern for PARA shape
- [TGeoPatternParaZ](@ref) - a Z axis divison pattern for PARA shape
- [TGeoPatternTrapZ](@ref) - a Z axis divison pattern for TRAP or GTRA shapes
- [TGeoPatternCylR](@ref) - a cylindrical R divison pattern
- [TGeoPatternCylPhi](@ref) - a cylindrical phi divison pattern
- [TGeoPatternSphR](@ref) - a spherical R divison pattern
- [TGeoPatternSphTheta](@ref) - a spherical theta divison pattern
- [TGeoPatternSphPhi](@ref) - a spherical phi divison pattern
- [TGeoPatternHoneycomb](@ref) - a divison pattern specialized for honeycombs

Related functions: [`CdNext`](@ref), [`ClearThreadData`](@ref), [`CreateMatrix`](@ref), [`CreateThreadData`](@ref), [`FindNode`](@ref), [`GetByteCount`](@ref), [`GetCurrent`](@ref), [`GetDivAxis`](@ref), [`GetDivIndex`](@ref), [`GetEnd`](@ref), [`GetMatrix`](@ref), [`GetNdiv`](@ref), [`GetNext`](@ref), [`GetNodeOffset`](@ref), [`GetStart`](@ref), [`GetStep`](@ref), [`GetThreadData`](@ref), [`GetVolume`](@ref), [`IsOnBoundary`](@ref), [`IsReflected`](@ref), [`IsSpacedOut`](@ref), [`MakeCopy`](@ref), [`Reflect`](@ref), [`SetDivIndex`](@ref), [`SetNext`](@ref), [`SetRange`](@ref), [`SetSpacedOut`](@ref), [`SetVolume`](@ref), [`TGeoPatternFinder`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternFinder

# Wrapper of TGeoVoxelFinder
@trydoc raw"""
    ROOT.TGeoVoxelFinder

Finder class handling voxels.

Full description with examples and pictures

![https://root.cern/doc/v636/geom_t_finder.png](https://root.cern/doc/v636/geom_t_finder.png)
 ![https://root.cern/doc/v636/geom_t_voxelfind.png](https://root.cern/doc/v636/geom_t_voxelfind.png)
 ![https://root.cern/doc/v636/geom_t_voxtree.png](https://root.cern/doc/v636/geom_t_voxtree.png)

Related functions: [`DaughterToMother`](@ref), [`Efficiency`](@ref), [`FindOverlaps`](@ref), [`GetBoxes`](@ref), [`GetCheckList`](@ref), [`GetNextCandidates`](@ref), [`GetNextVoxel`](@ref), [`IsInvalid`](@ref), [`IsSafeVoxel`](@ref), [`NeedRebuild`](@ref), [`PrintVoxelLimits`](@ref), [`Print`](@ref), [`SetInvalid`](@ref), [`SetNeedRebuild`](@ref), [`SortCrossedVoxels`](@ref), [`TGeoVoxelFinder`](@ref), [`Voxelize`](@ref)
""" TGeoVoxelFinder

# Wrapper of TGeoPatternX
@trydoc raw"""
    ROOT.TGeoPatternX





Related functions: [`CreateMatrix`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternX`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternX

# Wrapper of TGeoPatternY
@trydoc raw"""
    ROOT.TGeoPatternY

a Y axis divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternY`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternY

# Wrapper of TGeoPatternZ
@trydoc raw"""
    ROOT.TGeoPatternZ

a Z axis divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternZ`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternZ

# Wrapper of TGeoPatternParaX
@trydoc raw"""
    ROOT.TGeoPatternParaX

a X axis divison pattern for PARA shapes



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternParaX`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternParaX

# Wrapper of TGeoPatternParaY
@trydoc raw"""
    ROOT.TGeoPatternParaY

a Y axis divison pattern for PARA shapes



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternParaY`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternParaY

# Wrapper of TGeoPatternParaZ
@trydoc raw"""
    ROOT.TGeoPatternParaZ

a Z axis divison pattern for PARA shapes



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternParaZ`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternParaZ

# Wrapper of TGeoPatternTrapZ
@trydoc raw"""
    ROOT.TGeoPatternTrapZ

a Z axis divison pattern for TRAP or GTRA shapes



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`GetTxz`](@ref), [`GetTyz`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternTrapZ`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternTrapZ

# Wrapper of TGeoPatternCylR
@trydoc raw"""
    ROOT.TGeoPatternCylR

a cylindrical R divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternCylR`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternCylR

# Wrapper of TGeoPatternCylPhi
@trydoc raw"""
    ROOT.TGeoPatternCylPhi

a cylindrical phi divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternCylPhi`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternCylPhi

# Wrapper of TGeoPatternSphR
@trydoc raw"""
    ROOT.TGeoPatternSphR

a spherical R divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternSphR`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternSphR

# Wrapper of TGeoPatternSphTheta
@trydoc raw"""
    ROOT.TGeoPatternSphTheta

a spherical theta divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternSphTheta`](@ref), [`UpdateMatrix`](@ref), [`assign`](@ref), [`cd`](@ref)
""" TGeoPatternSphTheta

# Wrapper of TGeoPatternSphPhi
@trydoc raw"""
    ROOT.TGeoPatternSphPhi

a spherical phi divison pattern



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`GetDivAxis`](@ref), [`IsOnBoundary`](@ref), [`MakeCopy`](@ref), [`SavePrimitive`](@ref), [`TGeoPatternSphPhi`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternSphPhi

# Wrapper of TGeoPatternHoneycomb
@trydoc raw"""
    ROOT.TGeoPatternHoneycomb

a divison pattern specialized for honeycombs



Related functions: [`CreateMatrix`](@ref), [`FindNode`](@ref), [`MakeCopy`](@ref), [`TGeoPatternHoneycomb`](@ref), [`UpdateMatrix`](@ref), [`cd`](@ref)
""" TGeoPatternHoneycomb

# Wrapper of TGeoNodeMatrix
@trydoc raw"""
    ROOT.TGeoNodeMatrix

A node containing local_ transformation.



Related functions: [`GetByteCount`](@ref), [`GetMatrix`](@ref), [`GetOptimalVoxels`](@ref), [`IsFolder`](@ref), [`MakeCopyNode`](@ref), [`SetMatrix`](@ref), [`TGeoNodeMatrix`](@ref)
""" TGeoNodeMatrix

# Wrapper of TGeoNodeOffset
@trydoc raw"""
    ROOT.TGeoNodeOffset

Node containing an offset.



Related functions: [`GetFinder`](@ref), [`GetIndex`](@ref), [`GetMatrix`](@ref), [`GetOffset`](@ref), [`MakeCopyNode`](@ref), [`SetFinder`](@ref), [`TGeoNodeOffset`](@ref), [`cd`](@ref)
""" TGeoNodeOffset

# Wrapper of TGeoIterator
@trydoc raw"""
    ROOT.TGeoIterator

A geometry iterator.

A geometry iterator that sequentially follows all nodes of the geometrical hierarchy of a volume. The iterator has to be initiated with a top volume pointer:

    TGeoIterator next(myVolume);

(C++ version of the code)

One can use the iterator as any other in [ROOT](@ref):

    TGeoNode *node;
    while ((node=next())) {
       ...
    }

(C++ version of the code)

The iterator can perform 2 types of iterations that can be selected via:

    next.SetType(Int_t type);

(C++ version of the code)

Here TYPE can be:

- 0 (default) - 'first daughter next' behavior
- 1 - iteration at the current level only

Supposing the tree structure looks like:

    TOP ___ A_1 ___ A1_1 ___ A11_1
       |       |        |___ A12_1
       |      |_____A2_1 ___ A21_1
       |                |___ A21_2
       |___ B_1 ...

(C++ version of the code)

The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1, A21_2, B_1, ...

The order of iteration for TYPE=1 is: A_1, B_1, ... At any moment during iteration, TYPE can be changed. If the last iterated node is for instance A1_1 and the iteration type was 0, one can do:

    next.SetType(1);

(C++ version of the code)

The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator will return 0 after finishing all daughters of A.

During iteration, the following can be retrieved:

- Top volume where iteration started: [TGeoIterator!GetTopVolume()](@ref)
- Node at level I in the current branch: TGeoIterator!GetNode(Int_t i)
- Iteration type: [TGeoIterator!GetType()](@ref)
- Global matrix of the current node with respect to the top volume: [TGeoIterator!GetCurrentMatrix()](@ref)

The iterator can be reset by changing (or not) the top volume:

    TGeoIterator!Reset(TGeoVolume *top);

(C++ version of the code)

### Example:

We want to find out a volume named "MyVol" in the hierarchy of TOP volume.

    TIter next(TOP);
    TGeoNode *node;
    TString name("MyVol");
    while ((node=next()))
       if (name == node->GetVolume()->GetName()) return node->GetVolume();

(C++ version of the code)

Related functions: [`GetCurrentMatrix`](@ref), [`GetIndex`](@ref), [`GetLevel`](@ref), [`GetNode`](@ref), [`GetPath`](@ref), [`GetTopVolume`](@ref), [`GetType`](@ref), [`GetUserPlugin`](@ref), [`Next`](@ref), [`Reset`](@ref), [`SetPluginAutoexec`](@ref), [`SetTopName`](@ref), [`SetType`](@ref), [`SetUserPlugin`](@ref), [`Skip`](@ref), [`TGeoIterator`](@ref), [`Up`](@ref), [`assign`](@ref), [`paren`](@ref)
""" TGeoIterator

# Wrapper of TGeoIteratorPlugin
@trydoc raw"""
    ROOT.TGeoIteratorPlugin





Related functions: [`ProcessNode`](@ref), [`SetIterator`](@ref), [`TGeoIteratorPlugin`](@ref)
""" TGeoIteratorPlugin

# Wrapper of TGeoPolygon
@trydoc raw"""
    ROOT.TGeoPolygon

An arbitrary polygon defined by vertices.

The vertices have to be defined CLOCKWISE in the XY plane, making either a convex or concave polygon. No test for malformed polygons is performed.

A polygon is a 2D shape defined by vertices in the XY plane. It is used by [TGeoXtru](@ref) class for computing [Contains()](@ref) and [Safety()](@ref). Only the pointers to the actual lists of XY values are used - these are not owned by the class.

To check if a point in XY plane is contained by a polygon, this is split into an outscribed convex polygon and the remaining polygons of its subtraction from the outscribed one. A point is INSIDE if it is contained by the outscribed polygon but NOT by the remaining ones. Since these can also be arbitrary polygons at their turn, a tree structure is formed:

    P = Pconvex - (Pconvex-P)           where (-) means 'subtraction'
    Pconvex-P = P1 + P2 + ...           where (+) means 'union'

(C++ version of the code)

Note that P1, P2, ... do not intersect each other and they are defined by subsets of the list of vertices of P. They can be split in the same way as P*

Therefore, if C(P) represents the Boolean : 'does P contains a given point?', then:

    C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...)

(C++ version of the code)

For creating a polygon without [TGeoXtru](@ref) class, one has to call the constructor [TGeoPolygon(nvert)](@ref) and then [SetXY(Double_t *x, Double_t *y)](@ref) providing the arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer than the polygon they will describe. This complication is due to efficiency reasons. At the theend one has to call the [FinishPolygon()](@ref) method.

Related functions: [`Area`](@ref), [`Contains`](@ref), [`Draw`](@ref), [`FinishPolygon`](@ref), [`GetConvexVertices`](@ref), [`GetNconvex`](@ref), [`GetNvert`](@ref), [`GetVertices`](@ref), [`GetX`](@ref), [`GetY`](@ref), [`IsClockwise`](@ref), [`IsConvex`](@ref), [`IsFinished`](@ref), [`IsIllegalCheck`](@ref), [`Safety`](@ref), [`SetConvex`](@ref), [`SetNextIndex`](@ref), [`SetXY`](@ref), [`TGeoPolygon`](@ref)
""" TGeoPolygon

# Wrapper of TGeoCacheState
@trydoc raw"""
    ROOT.TGeoCacheState

Class storing the state of the cache at a given moment.



Related functions: [`GetState`](@ref), [`SetState`](@ref), [`TGeoCacheState`](@ref)
""" TGeoCacheState

# Wrapper of TGeoNodeCache
@trydoc raw"""
    ROOT.TGeoNodeCache

Special pool of reusable nodes.



Related functions: [`BuildIdArray`](@ref), [`BuildInfoBranch`](@ref), [`CdDown`](@ref), [`CdNode`](@ref), [`CdTop`](@ref), [`CdUp`](@ref), [`FillIdBranch`](@ref), [`GetBranchNames`](@ref), [`GetBranchNumbers`](@ref), [`GetBranchOnlys`](@ref), [`GetBranch`](@ref), [`GetCurrentMatrix`](@ref), [`GetCurrentNodeId`](@ref), [`GetIdBranch`](@ref), [`GetInfo`](@ref), [`GetLevel`](@ref), [`GetMakePWInfo`](@ref), [`GetMatrices`](@ref), [`GetMotherMatrix`](@ref), [`GetMother`](@ref), [`GetNodeId`](@ref), [`GetNode`](@ref), [`GetPath`](@ref), [`GetStackLevel`](@ref), [`GetTopNode`](@ref), [`HasIdArray`](@ref), [`IsDummy`](@ref), [`LocalToMasterBomb`](@ref), [`LocalToMasterVect`](@ref), [`LocalToMaster`](@ref), [`MasterToLocalBomb`](@ref), [`MasterToLocalVect`](@ref), [`MasterToLocal`](@ref), [`PopDummy`](@ref), [`PopState`](@ref), [`PushState`](@ref), [`Refresh`](@ref), [`ReleaseInfo`](@ref), [`RestoreState`](@ref), [`TGeoNodeCache`](@ref)
""" TGeoNodeCache

# Wrapper of TGeoCompositeShape
@trydoc raw"""
    ROOT.TGeoCompositeShape

Composite shapes are Boolean combinations of two or more shape components.

A composite shape contains a list of primitive shapes, the list of corresponding transformations and a boolean finder handling boolean operations among components.

The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base `TGeoShape`** class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.

Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This `CSG` `(composite solid geometry)` hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.

#### The Structure of Composite Shapes

A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure.

![https://root.cern/doc/v636/geom_composite_shape001.png](https://root.cern/doc/v636/geom_composite_shape001.png)

Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator.

1. Union: `A+B+C`

Just to illustrate the Boolean expression parsing and the composite shape structure, let's take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:

`A+B+C = (A+B)+C = A+(B+C)`

The first`(+)` is taken as separator, hence the expression split in: `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`("A","B+C")` is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named "A" is searched into the list of shapes handled by the manager class and stored as the "left" shape in the Boolean union node. Since the second expression is not yet fully decomposed, the "right" shape in the combination is created as a new composite shape. This will split at its turn B+C into B and C and create a **`TGeoUnion`**`("B","C")`. The B and C identifiers will be looked for and replaced by the pointers to the actual shapes into the new node. Finally, the composite "`A+B+C`" will be represented as shown in Fig.17-23.**

![https://root.cern/doc/v636/geom_composite_shape002.png](https://root.cern/doc/v636/geom_composite_shape002.png)

To build this composite shape:

    TGeoCompositeShape *cs1 = new TGeoCompositeShape("CS1","A+B+C");

(C++ version of the code)

Any shape entering a Boolean combination can be prior positioned. In order to do so, one has to attach a matrix name to the shape name by using a colon (:). As for shapes, the named matrix has to be prior defined:

    TGeoMatrix *mat;
    // ... code creating some geometrical transformation
    mat->SetName("mat1");
    mat->RegisterYourself();  // see Geometrical transformations

(C++ version of the code)

An identifier `shape:matrix` have the meaning: `shape` is translated or rotated with `matrix` with respect to the Boolean combination it enters as operand. Note that in the expression A+B+C no matrix identifier was provided, therefore the identity matrix was used for positioning the shape components. The next example will illustrate a more complex case.

1. `(A:m1+B):m2-(C:m3*D:m4):m5`

Let's try to understand the expression above. This expression means: subtract the intersection of **C** and **D** from the union of **A** and B**. The usage of parenthesis to force the desired precedence is always recommended. One can see that not only the primitive shapes have some geometrical transformations, but also their intermediate compositions.

![https://root.cern/doc/v636/geom_composite_shape003.png](https://root.cern/doc/v636/geom_composite_shape003.png)

    TGeoCompositeShape *cs2 = new TGeoCompositeShape("CS2",
    "(A:m1+B):m2-(C:m3*D:m4):m5");

(C++ version of the code)

Building composite shapes as in the first example is not always quite useful since we were using un-positioned shapes. When supplying just shape names as identifiers, the created Boolean nodes will assume that the shapes are positioned with an identity transformation with respect to the frame of the created composite. In order to provide some positioning of the combination components, we have to attach after each shape identifier the name of an existing transformation, separated by a colon. Obviously all transformations created for this purpose have to be objects with unique names in order to be properly substituted during parsing.

#### Composite Shape Example

One should have in mind that the same shape or matrix identifiers can be used many times in the same expression, as in the following example:

    {
       TCanvas *c = new TCanvas("c", "c",0,0,600,600);
       const Double_t sq2 = TMath!Sqrt(2.);
       TGeoManager *mgr =
          new TGeoManager("Geom","composite shape example");
       TGeoMedium *medium = 0;
       TGeoVolume *top = mgr->MakeBox("TOP",medium,100,250,250);
       mgr->SetTopVolume(top);
       // make shape components
       TGeoBBox *sbox  = new TGeoBBox("B",100,125*sq2,125*sq2);
       TGeoTube *stub  = new TGeoTube("T",0,100,250);
       TGeoPgon *spgon = new TGeoPgon("P",0.,360.,6,2);
       spgon->DefineSection(0,-250,0,80);
       spgon->DefineSection(1,250,0,80);
       // define some rotations
       TGeoRotation *r1 = new TGeoRotation("r1",90,0,0,180,90,90);
       r1->RegisterYourself();
       TGeoRotation *r2 = new TGeoRotation("r2",90,0,45,90,45,270);
       r2->RegisterYourself();
       // create a composite
       TGeoCompositeShape *cs = new TGeoCompositeShape("cs", "((T+T:r1)-(P+P:r1))*B:r2");
       TGeoVolume *comp = new TGeoVolume("COMP",cs);
       comp->SetLineColor(kRed);
       // put it in the top volume
       top->AddNode(comp,1);
       mgr->CloseGeometry();
       // visualize it with ray tracing
       top->Raytrace();
    }

(C++ version of the code)

![https://root.cern/doc/v636/geom_composite_shape004.png](https://root.cern/doc/v636/geom_composite_shape004.png)

Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided.

Related functions: [`Capacity`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoolNode`](@ref), [`GetBoundingCylinder`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`IsComposite`](@ref), [`IsCylType`](@ref), [`MakeNode`](@ref), [`PaintComposite`](@ref), [`RegisterYourself`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`Sizeof3D`](@ref), [`TGeoCompositeShape`](@ref)
""" TGeoCompositeShape

# Wrapper of TGeoCone
@trydoc raw"""
    ROOT.TGeoCone

The cones are defined by 5 parameters:

TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,
    Double_t rmin2,Double_t rmax2);

(C++ version of the code)

- `rmin1:` internal radius at Z is `-dz`
- `rmax1:` external radius at Z is `-dz`
- `rmin2:` internal radius at Z is `+dz`
- `rmax2:` external radius at Z is `+dz`
- `dz:` half length in Z (a cone ranges from `-dz` to +`dz`)

A cone has Z-axis as its symmetry axis.

![https://root.cern/doc/v636/pict1_TGeoCone_001.png](https://root.cern/doc/v636/pict1_TGeoCone_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDz`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax1`](@ref), [`GetRmax2`](@ref), [`GetRmin1`](@ref), [`GetRmin2`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetConeDimensions`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoCone!Capacity`](@ref), [`TGeoCone!ComputeNormalS`](@ref), [`TGeoCone!DistFromInsideS`](@ref), [`TGeoCone!DistFromOutsideS`](@ref), [`TGeoCone!DistToCone`](@ref), [`TGeoCone!SafetyS`](@ref), [`TGeoCone`](@ref)
""" TGeoCone

# Wrapper of TGeoConeSeg
@trydoc raw"""
    ROOT.TGeoConeSeg

A cone segment is a cone having a range in `phi`.

The cone segment class derives from **`TGeoCone`**, having two extra parameters: `phi1` and `phi2`.

    TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,
    Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);

(C++ version of the code)

Parameters `phi1` and `phi2` have the same meaning and convention as for tube segments.

![https://root.cern/doc/v636/pict1_TGeoCone_002.png](https://root.cern/doc/v636/pict1_TGeoCone_002.png)

Related functions: [`AfterStreamer`](@ref), [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi1`](@ref), [`GetPhi2`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetConsDimensions`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoConeSeg!Capacity`](@ref), [`TGeoConeSeg!ComputeNormalS`](@ref), [`TGeoConeSeg!DistFromInsideS`](@ref), [`TGeoConeSeg!DistFromOutsideS`](@ref), [`TGeoConeSeg!DistToCons`](@ref), [`TGeoConeSeg!SafetyS`](@ref), [`TGeoConeSeg`](@ref)
""" TGeoConeSeg

# Wrapper of TGeoTube
@trydoc raw"""
    ROOT.TGeoTube

Cylindrical tube class.

A tube has 3 parameters :

- `rmin` : minimum radius
- `rmax` : maximum radius
- `dz` : half length

    TGeoTube(Double_t rmin,Double_t rmax,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoTube_001.png](https://root.cern/doc/v636/pict1_TGeoTube_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDz`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`HasRmin`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetTubeDimensions`](@ref), [`Sizeof3D`](@ref), [`TGeoTube!Capacity`](@ref), [`TGeoTube!ComputeNormalS`](@ref), [`TGeoTube!DistFromInsideS`](@ref), [`TGeoTube!DistFromOutsideS`](@ref), [`TGeoTube!DistToTube`](@ref), [`TGeoTube!SafetyS`](@ref), [`TGeoTube`](@ref)
""" TGeoTube

# Wrapper of TGeoTubeSeg
@trydoc raw"""
    ROOT.TGeoTubeSeg

A tube segment is a tube having a range in phi.

The tube segment class derives from **`TGeoTube`**, having 2 extra parameters: `phi1` and `phi2`.

    TGeoTubeSeg(Double_t rmin,Double_t rmax,Double_t dz,
    Double_t phi1,Double_t phi2);

(C++ version of the code)

Here `phi1` and `phi2`are the starting and ending `phi`values in degrees. The `general phi convention` is that the shape ranges from `phi1` to `phi2` going counterclockwise. The angles can be defined with either negative or positive values. They are stored such that `phi1` is converted to `[0,360]` and `phi2 > phi1`.

![https://root.cern/doc/v636/pict1_TGeoTube_002.png](https://root.cern/doc/v636/pict1_TGeoTube_002.png)

Related functions: [`AfterStreamer`](@ref), [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi1`](@ref), [`GetPhi2`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetTubsDimensions`](@ref), [`Sizeof3D`](@ref), [`TGeoTubeSeg!Capacity`](@ref), [`TGeoTubeSeg!ComputeNormalS`](@ref), [`TGeoTubeSeg!DistFromInsideS`](@ref), [`TGeoTubeSeg!DistFromOutsideS`](@ref), [`TGeoTubeSeg!SafetyS`](@ref), [`TGeoTubeSeg`](@ref)
""" TGeoTubeSeg

# Wrapper of TGeoCtub
@trydoc raw"""
    ROOT.TGeoCtub

The cut tubes constructor has the form:

TGeoCtub(Double_t rmin,Double_t rmax,Double_t dz,
    Double_t phi1,Double_t phi2,
    Double_t nxlow,Double_t nylow,Double_t nzlow, Double_t nxhi,
    Double_t nyhi,Double_t nzhi);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoTube_003.png](https://root.cern/doc/v636/pict1_TGeoTube_003.png)

A cut tube is a tube segment cut with two planes. The centers of the 2 sections are positioned at `dZ`. Each cut plane is therefore defined by a point `(0,0,dZ)` and its normal unit vector pointing outside the shape:

`Nlow=(Nx,Ny,Nz<0)`, 'Nhigh=(Nx',Ny',Nz'>0)`.

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNhigh`](@ref), [`GetNlow`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetZcoord`](@ref), [`InspectShape`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetCtubDimensions`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`TGeoCtub`](@ref)
""" TGeoCtub

# Wrapper of TGeoEltu
@trydoc raw"""
    ROOT.TGeoEltu

An elliptical tube is defined by the two semi-axes `A` and `B`.

It ranges from `-dZ` to `+dZ` as all other tubes:

    TGeoEltu(Double_t a,Double_t b,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoEltu_001.png](https://root.cern/doc/v636/pict1_TGeoEltu_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetA`](@ref), [`GetB`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetEltuDimensions`](@ref), [`SetPoints`](@ref), [`TGeoEltu`](@ref)
""" TGeoEltu

# Wrapper of TGeoRCExtension
@trydoc raw"""
    ROOT.TGeoRCExtension

Reference counted extension which has a pointer to and owns a user defined [TObject](@ref).

This class can be used as model for a reference counted derivation from [TGeoExtension](@ref).

Note: Creating a [TGeoRCExtension](@ref) with new() automatically grabs it, but the creator has to Release it before the pointer gets out of scope. The following sequence is valid:

    // producer:
    TGeoRCExtension *ext = new TGeoRCExtension();
    some_TGeoVolume->SetUserExtension(ext);
    ext->Release();
    // user:
    TGeoRCExtension *ext = dynamic_cast<TGeoRCExtension*>(some_TGeoVolume->GrabUserExtension());
    // ... use extension
    ext->Release();

(C++ version of the code)

The extension is going to be released by the [TGeoVolume](@ref) holder at the destruction or when calling SetUserExtension(0).

The following usage is not correct:

    some_TGeoVolume->SetUserExtension(new TGeoRCExtension())

(C++ version of the code)

since the producer code does not release the extension. One cannot call directly "delete ext" nor allocate an extension on the stack, since the destructor is protected. Use Release instead.

Related functions: [`GetUserObject`](@ref), [`Grab`](@ref), [`Release`](@ref), [`SetUserObject`](@ref), [`TGeoRCExtension`](@ref)
""" TGeoRCExtension

# Wrapper of TVirtualMagField
@trydoc raw"""
    ROOT.TVirtualMagField

Abstract class for magnetic field.

Derived classes are encouraged to use the [TVirtualMagField](@ref) named constructor and must implement the method:

    Field(const Double_t *x, Double_t *B)

(C++ version of the code)

A field object can be made global_ via:

    TGlobalMagField!Instance()->SetField(field)         [1]

(C++ version of the code)

A field which is made global_ is owned by the field manager. The used is not allowed to delete it directly anymore (otherwise a [Fatal()](@ref) is issued). Global field can be deleted by calling [1] with a different argument (which can be NULL). Otherwise the global_ field is deleted together with the field manager.

Related functions: [`Field`](@ref), [`TVirtualMagField`](@ref)
""" TVirtualMagField

# Wrapper of TGeoUniformMagField
@trydoc raw"""
    ROOT.TGeoUniformMagField

Implementation for uniform magnetic field.



Related functions: [`Field`](@ref), [`GetFieldValue`](@ref), [`SetFieldValue`](@ref), [`TGeoUniformMagField`](@ref)
""" TGeoUniformMagField

# Wrapper of TGeoGlobalMagField
@trydoc raw"""
    ROOT.TGeoGlobalMagField

Global magnetic field manager.

Provides access to and owns the actual magnetic field set via `SetField()`. The field is deleted upon destruction of the field manager at the theend of [ROOT](@ref) session or by calling:

    TGeoGlobalMagField!Instance()->SetField(0).

(C++ version of the code)

The previous global_ field is deleted upon replacement with notification.

The global_ field manager provides access to the global_ field via:

    TGeoGlobalMagField!Instance()->GetField()

(C++ version of the code)

One can directly call the [Field()](@ref) method of a field via the global_ field manager:

    TGeoGlobalMagField!Instance()->Field(x,B)

(C++ version of the code)

Related functions: [`Field`](@ref), [`GetField`](@ref), [`IsLocked`](@ref), [`Lock`](@ref), [`SetField`](@ref), [`TGeoGlobalMagField!GetInstance`](@ref), [`TGeoGlobalMagField!Instance`](@ref), [`TGeoGlobalMagField`](@ref)
""" TGeoGlobalMagField

# Wrapper of TGeoHalfSpace
@trydoc raw"""
    ROOT.TGeoHalfSpace

A half space is limited just by a plane, defined by a point and the normal direction.

The point lies on the plane and the normal vector points outside the half space. The half space is the only shape which is infinite and can be used only in Boolean operations that result in non-infinite composite shapes (see also [TGeoCompositeShape](@ref)). A half space has to be defined using the constructor:

    TGeoHalfSpace (const char *name, Double_t *point[3],
    Double_t *norm[3]);

(C++ version of the code)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoundingCylinder`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNorm`](@ref), [`GetPoint`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`Sizeof3D`](@ref), [`TGeoHalfSpace`](@ref)
""" TGeoHalfSpace

# Wrapper of TGeoHelix
@trydoc raw"""
    ROOT.TGeoHelix

Class representing a helix curve.

A helix is a curve defined by the following equations:

    x = (1/c) * COS(q*phi)
    y = (1/c) * SIN(q*phi)
    z = s * alfa

(C++ version of the code)

where:

    c = 1/Rxy  - curvature in XY plane
    phi        - phi angle
    S = 2*PI*s - vertical separation between helix loops
    q = +/- 1  - (+)=left-handed, (-)=right-handed

(C++ version of the code)

In particular, a helix describes the trajectory of a charged particle in magnetic field. In such case, the helix is right-handed for negative particle charge. To define a helix, one must define:

- the curvature - positive defined
- the Z step made after one full turn of the helix
- the particle charge sign
- the initial particle position and direction (force normalization to unit)
- the magnetic field direction

A helix provides:

- propagation to a given Z position (in global_ frame) Double_t *point = TGeoHelix!PropagateToZ(Double_t z);
- propagation to an arbitrary plane, returning also the new point
- propagation in a geometry until the next crossed surface
- computation of the total track length along a helix

Related functions: [`ComputeSafeStep`](@ref), [`GetCurrentDirection`](@ref), [`GetCurrentPoint`](@ref), [`GetStep`](@ref), [`GetTotalCurvature`](@ref), [`GetXYcurvature`](@ref), [`InitDirection`](@ref), [`InitPoint`](@ref), [`IsRightHanded`](@ref), [`ResetStep`](@ref), [`SetCharge`](@ref), [`SetField`](@ref), [`SetHelixStep`](@ref), [`SetXYcurvature`](@ref), [`StepToPlane`](@ref), [`Step`](@ref), [`TGeoHelix`](@ref), [`UpdateHelix`](@ref)
""" TGeoHelix

# Wrapper of TGeoHype
@trydoc raw"""
    ROOT.TGeoHype

A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces).

The class describing hyperboloids is [TGeoHype](@ref) has 5 input parameters:

    TGeoHype(Double_t rin,Double_t stin,Double_t rout,
    Double_t stout,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoHype_001.png](https://root.cern/doc/v636/pict1_TGeoHype_001.png)

The hyperbolic surface equation is taken in the form:

    r^2 - z^2 * tan(st)^2 = rmin^2

(C++ version of the code)

- `r,z:` cylindrical coordinates for a point on the surface
- `st:` stereo angle between the hyperbola asymptotic lines and Z axis
- `rmin:` minimum distance between hyperbola and Z axis (at `z=0`)

The input parameters for a hyperboloid represent:

- `rin, stin:` minimum radius and stereo angle in degrees for the inner surface
- `rout, stout:` minimum radius and stereo angle in degrees for the outer surface
- `dz:` half length in Z (bounding planes positions at `+/-dz`)

The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range `+/-dz`:

- `rin < rout`
- `rout > 0`
- `rin^2 + dz^2 * tan(stin)^2 > rout^2 + dz^2 * tan(stout)^2`

Particular cases:

- `rin=0, stin0:` the inner surface is conical
- `stin=0 / stout=0:` cylindrical surface(s)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToHype`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetStIn`](@ref), [`GetStOut`](@ref), [`HasInner`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`RadiusHypeSq`](@ref), [`SafetyToHype`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetHypeDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoHype`](@ref), [`ZHypeSq`](@ref)
""" TGeoHype

# Wrapper of TGeoNavigatorArray
@trydoc raw"""
    ROOT.TGeoNavigatorArray





Related functions: [`AddNavigator`](@ref), [`GetCurrentNavigator`](@ref), [`SetCurrentNavigator`](@ref), [`TGeoNavigatorArray`](@ref)
""" TGeoNavigatorArray

# Wrapper of TGeoRegion
@trydoc raw"""
    ROOT.TGeoRegion

Regions are groups of volumes having a common set of user tracking cuts.

Class wrapper for regions used by Monte Carlo packages A region is composed by a list of logical volumes and defines a set of cuts. Used mainly to transport region information stored in GDML format to the clients requiring it from the transient geometry.

Related functions: [`AddCut`](@ref), [`AddVolume`](@ref), [`GetCut`](@ref), [`GetNcuts`](@ref), [`GetNvolumes`](@ref), [`GetVolume`](@ref), [`Print`](@ref), [`TGeoRegion`](@ref), [`assign`](@ref)
""" TGeoRegion

# Wrapper of TVirtualGeoTrack
@trydoc raw"""
    ROOT.TVirtualGeoTrack

Base class for user-defined tracks attached to a geometry.

Tracks are 3D objects made of points and they store a pointer to a [TParticle](@ref). The geometry manager holds a list of all tracks that will be deleted on destruction of gGeoManager.

Related functions: [`AddDaughter`](@ref), [`AddPoint`](@ref), [`FindTrackWithId`](@ref), [`GetDaughterId`](@ref), [`GetDaughter`](@ref), [`GetFirstPoint`](@ref), [`GetId`](@ref), [`GetLastPoint`](@ref), [`GetMotherParticle`](@ref), [`GetMother`](@ref), [`GetName`](@ref), [`GetNdaughters`](@ref), [`GetNpoints`](@ref), [`GetPDG`](@ref), [`GetParentId`](@ref), [`GetParticle`](@ref), [`GetPoint`](@ref), [`HasPoints`](@ref), [`IsInTimeRange`](@ref), [`PaintCollectTrack`](@ref), [`PaintCollect`](@ref), [`PaintTrack`](@ref), [`Paint`](@ref), [`ResetTrack`](@ref), [`SetId`](@ref), [`SetName`](@ref), [`SetPDG`](@ref), [`SetParent`](@ref), [`SetParticle`](@ref), [`TVirtualGeoTrack`](@ref)
""" TVirtualGeoTrack

# Wrapper of TVirtualGeoPainter
@trydoc raw"""
    ROOT.TVirtualGeoPainter

Abstract class for geometry painters.



Related functions: [`AddSize3D`](@ref), [`AddTrackPoint`](@ref), [`AddTrack`](@ref), [`BombTranslation`](@ref), [`CheckBoundaryErrors`](@ref), [`CheckBoundaryReference`](@ref), [`CheckGeometryFull`](@ref), [`CheckGeometry`](@ref), [`CheckOverlaps`](@ref), [`CheckPoint`](@ref), [`CheckShape`](@ref), [`CountVisibleNodes`](@ref), [`DefaultAngles`](@ref), [`DefaultColors`](@ref), [`DistanceToPrimitiveVol`](@ref), [`DrawBatemanSol`](@ref), [`DrawCurrentPoint`](@ref), [`DrawOnly`](@ref), [`DrawOverlap`](@ref), [`DrawPanel`](@ref), [`DrawPath`](@ref), [`DrawPolygon`](@ref), [`DrawShape`](@ref), [`DrawVolume`](@ref), [`EditGeometry`](@ref), [`EstimateCameraMove`](@ref), [`ExecuteManagerEvent`](@ref), [`ExecuteShapeEvent`](@ref), [`ExecuteVolumeEvent`](@ref), [`GetBombFactors`](@ref), [`GetBombMode`](@ref), [`GetColor`](@ref), [`GetDrawPath`](@ref), [`GetDrawnVolume`](@ref), [`GetNsegments`](@ref), [`GetTopVolume`](@ref), [`GetViewAngles`](@ref), [`GetViewBox`](@ref), [`GetVisLevel`](@ref), [`GetVisOption`](@ref), [`GetVolumeInfo`](@ref), [`GrabFocus`](@ref), [`IsExplodedView`](@ref), [`IsPaintingShape`](@ref), [`IsRaytracing`](@ref), [`LegoPlot`](@ref), [`ModifiedPad`](@ref), [`OpProgress`](@ref), [`PaintNode`](@ref), [`PaintOverlap`](@ref), [`PaintShape`](@ref), [`PaintVolume`](@ref), [`Paint`](@ref), [`PrintOverlaps`](@ref), [`RandomPoints`](@ref), [`RandomRays`](@ref), [`Raytrace`](@ref), [`SamplePoints`](@ref), [`SetBombFactors`](@ref), [`SetCheckedNode`](@ref), [`SetClippingShape`](@ref), [`SetExplodedView`](@ref), [`SetGeoManager`](@ref), [`SetIteratorPlugin`](@ref), [`SetNmeshPoints`](@ref), [`SetNsegments`](@ref), [`SetRaytracing`](@ref), [`SetTopVisible`](@ref), [`SetTopVolume`](@ref), [`SetVisLevel`](@ref), [`SetVisOption`](@ref), [`ShapeDistancetoPrimitive`](@ref), [`TVirtualGeoPainter!GeoPainter`](@ref), [`TVirtualGeoPainter!SetPainter`](@ref), [`TVirtualGeoPainter`](@ref), [`TestOverlaps`](@ref), [`TestVoxels`](@ref), [`Test`](@ref), [`UnbombTranslation`](@ref), [`Weight`](@ref)
""" TVirtualGeoPainter

# Wrapper of TGeoPNEntry
@trydoc raw"""
    ROOT.TGeoPNEntry

The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them.

class representing physical node entry having a unique name associated to a path.

One can however create 'symbolic links' to any complex path to make it more representable for the object it designates:

    TGeoPNEntry *pne = new TGeoPNEntry("TPC_SECTOR_2", "path_to_tpc_sect2");
    pne->SetPhysicalNode(pn)

(C++ version of the code)

Such a symbolic link hides the complexity of the path to the align object and replaces it with a more meaningful name. In addition, [TGeoPNEntry](@ref) objects are faster to search by name and they may optionally store an additional user matrix.

For more details please read the [misalignment section](@ref).

Related functions: [`GetGlobalOrig`](@ref), [`GetMatrixOrig`](@ref), [`GetMatrix`](@ref), [`GetPath`](@ref), [`GetPhysicalNode`](@ref), [`SetMatrix`](@ref), [`SetPhysicalNode`](@ref), [`TGeoPNEntry`](@ref)
""" TGeoPNEntry

# Wrapper of TGeoPhysicalNode
@trydoc raw"""
    ROOT.TGeoPhysicalNode

Physical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.

class representing an unique object associated with a path.

The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 1e6-1e9, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class [TGeoPhysicalNode](@ref) and can be created on demand for alignment purposes:

    TGeoPhysicalNode *pn = new TGeoPhysicalNode("path_to_object")

(C++ version of the code)

Once created, a physical node can be misaligned, meaning that its position or even shape can be changed:

    pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE)

(C++ version of the code)

Related functions: [`Align`](@ref), [`Draw`](@ref), [`GetLevel`](@ref), [`GetMatrix`](@ref), [`GetMother`](@ref), [`GetNode`](@ref), [`GetOriginalMatrix`](@ref), [`GetShape`](@ref), [`GetVolume`](@ref), [`IsAligned`](@ref), [`IsMatchingState`](@ref), [`IsVisibleFull`](@ref), [`IsVisible`](@ref), [`IsVolAttributes`](@ref), [`Paint`](@ref), [`Print`](@ref), [`Refresh`](@ref), [`SetIsVolAtt`](@ref), [`SetMatrixOrig`](@ref), [`SetVisibility`](@ref), [`SetVisibleFull`](@ref), [`TGeoPhysicalNode`](@ref), [`cd`](@ref)
""" TGeoPhysicalNode

# Wrapper of TGeoOpticalSurface
@trydoc raw"""
    ROOT.TGeoOpticalSurface

This is a wrapper class to G4OpticalSurface.



Related functions: [`AddConstProperty`](@ref), [`AddProperty`](@ref), [`GetConstProperties`](@ref), [`GetConstPropertyRef`](@ref), [`GetConstProperty`](@ref), [`GetFinish`](@ref), [`GetModel`](@ref), [`GetNconstProperties`](@ref), [`GetNproperties`](@ref), [`GetPolish`](@ref), [`GetProperties`](@ref), [`GetPropertyRef`](@ref), [`GetProperty`](@ref), [`GetSigmaAlpha`](@ref), [`GetType`](@ref), [`GetValue`](@ref), [`Print`](@ref), [`SetFinish`](@ref), [`SetModel`](@ref), [`SetPolish`](@ref), [`SetSigmaAlpha`](@ref), [`SetType`](@ref), [`SetValue`](@ref), [`TGeoOpticalSurface!FinishToString`](@ref), [`TGeoOpticalSurface!ModelToString`](@ref), [`TGeoOpticalSurface!StringToFinish`](@ref), [`TGeoOpticalSurface!StringToModel`](@ref), [`TGeoOpticalSurface!StringToType`](@ref), [`TGeoOpticalSurface!TypeToString`](@ref), [`TGeoOpticalSurface`](@ref)
""" TGeoOpticalSurface

# Wrapper of TGeoSkinSurface
@trydoc raw"""
    ROOT.TGeoSkinSurface





Related functions: [`GetSurface`](@ref), [`GetVolume`](@ref), [`Print`](@ref), [`TGeoSkinSurface`](@ref)
""" TGeoSkinSurface

# Wrapper of TGeoBorderSurface
@trydoc raw"""
    ROOT.TGeoBorderSurface





Related functions: [`GetNode1`](@ref), [`GetNode2`](@ref), [`GetSurface`](@ref), [`Print`](@ref), [`TGeoBorderSurface`](@ref)
""" TGeoBorderSurface

# Wrapper of TGeoPara
@trydoc raw"""
    ROOT.TGeoPara

Parallelepiped class.

A parallelepiped is a shape having 3 pairs of parallel faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis.

The shape has the center in the origin and it is defined by:

- `dX, dY, dZ:` half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at `-dZ`, while the upper at `+dZ`.
- `alpha:` angle between the segment defined by the centers of the X-parallel edges and Y axis `[-90,90]` in degrees
- `theta:` theta angle of the segment defined by the centers of the Z faces;
- `phi:` phi angle of the same segment

    TGeoPara(dX,dY,dZ,alpha,theta,phi);

(C++ version of the code)

A box is a particular parallelepiped having the parameters: `(dX,dY,dZ,0.,0.,0.)`.

![https://root.cern/doc/v636/pict1_TGeoPara_001.png](https://root.cern/doc/v636/pict1_TGeoPara_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAlpha`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi`](@ref), [`GetTheta`](@ref), [`GetTxy`](@ref), [`GetTxz`](@ref), [`GetTyz`](@ref), [`GetX`](@ref), [`GetY`](@ref), [`GetZ`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`Sizeof3D`](@ref), [`TGeoPara`](@ref)
""" TGeoPara

# Wrapper of TGeoParaboloid
@trydoc raw"""
    ROOT.TGeoParaboloid

A paraboloid is defined by the revolution surface generated by a parabola and is bounded by two planes perpendicular to Z axis.

The parabola equation is taken in the form: `z = a·r2 + b`, where: `r2 = x2 + y2`. Note the missing linear term (parabola symmetric with respect to Z axis).

The coefficients a and b are computed from the input values which are the radii of the circular sections cut by the planes at `+/-dz`:

- `-dz = a*r2low + b`
- `dz = a*r2high + b`

    TGeoParaboloid(Double_t rlo,Double_t rhi,Double_t dz);

(C++ version of the code)

End_Macro

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToParaboloid`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetDz`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPointsOnSegments`](@ref), [`GetRhi`](@ref), [`GetRlo`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetParaboloidDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoParaboloid`](@ref)
""" TGeoParaboloid

# Wrapper of TGeoParallelWorld
@trydoc raw"""
    ROOT.TGeoParallelWorld

Base class for a flat parallel geometry.

The parallel geometry can be composed by both normal volumes added using the AddNode interface (not implemented yet) or by physical nodes which will use as position their actual global_ matrix with respect to the top volume of the main geometry.

All these nodes are added as daughters to the "top" volume of the parallel world which acts as a navigation helper in this parallel world. The parallel world has to be closed before calling any navigation method.

Related functions: [`AddNode`](@ref), [`AddOverlap`](@ref), [`BuildBVH`](@ref), [`CheckBVH`](@ref), [`CheckOverlaps`](@ref), [`CloseGeometry`](@ref), [`Draw`](@ref), [`FindNextBoundary`](@ref), [`FindNode`](@ref), [`GetAccelerationMode`](@ref), [`GetGeometry`](@ref), [`GetVolume`](@ref), [`IsClosed`](@ref), [`IsUsingOverlaps`](@ref), [`PrintBVH`](@ref), [`PrintDetectedOverlaps`](@ref), [`RefreshPhysicalNodes`](@ref), [`ResetOverlaps`](@ref), [`Safety`](@ref), [`SetAccelerationMode`](@ref), [`SetUseOverlaps`](@ref), [`TGeoParallelWorld`](@ref)
""" TGeoParallelWorld

# Wrapper of TGeoPcon
@trydoc raw"""
    ROOT.TGeoPcon

A polycone is represented by a sequence of tubes/cones, glued together at defined Z planes.

The polycone might have a phi segmentation, which globally applies to all the pieces. It has to be defined in two steps:

1. First call the [TGeoPcon](@ref) constructor to define a polycone:

        TGeoPcon(Double_t phi1,Double_t dphi,Int_t nz

    (C++ version of the code)

    - `phi1:` starting phi angle in degrees
    - `dphi:` total phi range
    - `nz:` number of Z planes defining polycone sections (minimum 2)
2. Define one by one all sections [0, nz-1]

    void TGeoPcon!DefineSection(Int_t i,Double_t z,
    Double_t rmin, Double_t rmax);

(C++ version of the code)

- `i:` section index [0, nz-1]
- `z:` z coordinate of the section
- `rmin:` minimum radius corresponding too this section
- `rmax:` maximum radius.

The first section (`i=0`) has to be positioned always the lowest Z coordinate. It defines the radii of the first cone/tube segment at its lower Z. The next section defines the theend-cap of the first segment, but it can represent also the beginning of the next one. Any discontinuity in the radius has to be represented by a section defined at the same Z coordinate as the previous one. The Z coordinates of all sections must be sorted in increasing order. Any radius or Z coordinate of a given plane have corresponding getters:

    Double_t TGeoPcon!GetRmin(Int_t i);
    Double_t TGeoPcon!GetRmax(Int_t i);
    Double_t TGeoPcon!GetZ(Int_t i);

(C++ version of the code)

Note that the last section should be defined last, since it triggers the computation of the bounding box of the polycone.

![https://root.cern/doc/v636/pict1_TGeoPcon_001.png](https://root.cern/doc/v636/pict1_TGeoPcon_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DefineSection`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToSegZ`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`Dphi`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDphi`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNsegments`](@ref), [`GetNz`](@ref), [`GetPhi1`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`GetZ`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Phi1`](@ref), [`Rmax`](@ref), [`Rmin`](@ref), [`SafetyToSegment`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoPcon`](@ref), [`Z`](@ref)
""" TGeoPcon

# Wrapper of TGeoPgon
@trydoc raw"""
    ROOT.TGeoPgon

Polygons are defined in the same way as polycones, the difference being just that the segments between consecutive Z planes are regular polygons.

The phi segmentation is preserved and the shape is defined in a similar manner, just that `rmin` and `rmax` represent the radii of the circles inscribed in the inner/outer polygon.

![https://root.cern/doc/v636/pict1_TGeoPgon_001.png](https://root.cern/doc/v636/pict1_TGeoPgon_001.png)

The constructor of a polygon has the form:

    TGeoPgon(Double_t phi1,Double_t dphi,Int_t nedges,Int_t nz);

(C++ version of the code)

The extra parameter `nedges` represent the number of equal edges of the polygons, between `phi1` and `phi1+dphi.`

Related functions: [`Capacity`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNedges`](@ref), [`GetNmeshVertices`](@ref), [`GetNsegments`](@ref), [`GetPointsOnSegments`](@ref), [`GetThreadData`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`SafetyToSegment`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetNedges`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoPgon`](@ref)
""" TGeoPgon

# Wrapper of TGeoRCPtr
@trydoc raw"""
    ROOT.TGeoRCPtr

A reference counting-managed pointer for classes derived from [TGeoExtension](@ref) which can be used as C pointer.

Based on CodeProject implementation example

### Example:

    class MyExtension : public TGeoExtension {
    public:
       MyExtension() : TGeoExtension(), fRC(0) {printf("Created MyExtension\n");}
       virtual ~MyExtension() {printf("Deleted MyExtension\n");}
       virtual TGeoExtension *Grab() const {fRC++; return (TGeoExtension*)this;}
       virtual void Release() const {assert(fRC > 0); fRC--; if (fRC ==0) delete this;}
       void print() const {printf("MyExtension object %p\n", this);}
    private:
       mutable Int_t        fRC;           // Reference counter
       ClassDefOverride(MyExtension,1)
    };

(C++ version of the code)

### Usage:

    // Module 1 creates an object
    TGeoRCPtr<MyExtension> a2 = new MyExtension(); //fRC=1
    // Module 2 grabs object
    TGeoRCPtr<MyExtension> ptr2 = a2; //fRC=2
    // Module 2 invokes a method
    ptr2->Print();
    (*ptr2).Print();
    // Module 1 no longer needs object
     a2 = 0;      //RC=1
    // Module 2 no longer needs object
     ptr2 = 0;    //object will be destroyed here

(C++ version of the code)

### Note:

Event if one forgets to call ptr2 = 0, the object gets delete when the method using ptr2 gets out of scope.

Related functions: [`Base.:(==)`](@ref), [`Base.getindex`](@ref), [`Get`](@ref), [`T*`](@ref), [`TGeoRCPtr`](@ref), [`arrow`](@ref), [`assign`](@ref), [`bool`](@ref)
""" TGeoRCPtr

# Wrapper of TGeoRegionCut
@trydoc raw"""
    ROOT.TGeoRegionCut





Related functions: [`GetCut`](@ref), [`SetCut`](@ref), [`TGeoRegionCut`](@ref)
""" TGeoRegionCut

# Wrapper of TGeoScaledShape
@trydoc raw"""
    ROOT.TGeoScaledShape

A shape scaled by a [TGeoScale](@ref) transformation.

![https://root.cern/doc/v636/geom_scaledshape.png](https://root.cern/doc/v636/geom_scaledshape.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetBuffer3D`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetScale`](@ref), [`GetShape`](@ref), [`InspectShape`](@ref), [`IsAssembly`](@ref), [`IsCylType`](@ref), [`IsReflected`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetScale`](@ref), [`SetSegsAndPols`](@ref), [`TGeoScaledShape!MakeScaledShape`](@ref), [`TGeoScaledShape`](@ref)
""" TGeoScaledShape

# Wrapper of TGeoShapeAssembly
@trydoc raw"""
    ROOT.TGeoShapeAssembly

The shape encapsulating an assembly (union) of volumes.

Automatically created by [TGeoVolumeAssembly](@ref) class

Related functions: [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`InspectShape`](@ref), [`IsAssembly`](@ref), [`IsCylType`](@ref), [`NeedsBBoxRecompute`](@ref), [`RecomputeBoxLast`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`TGeoShapeAssembly`](@ref)
""" TGeoShapeAssembly

# Wrapper of TGeoSphere
@trydoc raw"""
    ROOT.TGeoSphere

[TGeoSphere](@ref) are not just balls having internal and external radii, but sectors of a sphere having defined theta and phi ranges.

The [TGeoSphere](@ref) class has the following constructor.

    TGeoSphere(Double_t rmin,Double_t rmax,Double_t theta1,
    Double_t theta2,Double_t phi1, Double_t phi2);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoSphere_001.png](https://root.cern/doc/v636/pict1_TGeoSphere_001.png)

- `rmin:` internal radius of the spherical sector
- `rmax:` external radius
- `theta1:` starting theta value [0, 180) in degrees
- `theta2:` ending theta value (0, 180] in degrees (`theta1<theta2`)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistToSphere`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNumberOfDivisions`](@ref), [`GetNz`](@ref), [`GetPhi1`](@ref), [`GetPhi2`](@ref), [`GetPointsOnSegments`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`GetTheta1`](@ref), [`GetTheta2`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`IsOnBoundary`](@ref), [`IsPointInside`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetNumberOfDivisions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetSphDimensions`](@ref), [`Sizeof3D`](@ref), [`TGeoSphere`](@ref)
""" TGeoSphere

# Wrapper of TGeoFacet
@trydoc raw"""
    ROOT.TGeoFacet





Related functions: [`Base.getindex`](@ref), [`Flip`](@ref), [`GetNvert`](@ref), [`IsNeighbour`](@ref), [`TGeoFacet!CompactFacet`](@ref), [`TGeoFacet`](@ref)
""" TGeoFacet

# Wrapper of TGeoTessellated
@trydoc raw"""
    ROOT.TGeoTessellated

[Tessellated](@ref) solid class.

It is composed by a set of planar faces having triangular or quadrilateral shape. The class does not provide navigation functionality, it just wraps the data for the composing faces.

Related functions: [`AddFacet`](@ref), [`AddVertex`](@ref), [`CheckClosure`](@ref), [`CloseShape`](@ref), [`ComputeBBox`](@ref), [`DistancetoPrimitive`](@ref), [`FacetCheck`](@ref), [`FacetComputeNormal`](@ref), [`FlipFacets`](@ref), [`GetBuffer3D`](@ref), [`GetFacet`](@ref), [`GetMeshNumbers`](@ref), [`GetNfacets`](@ref), [`GetNmeshVertices`](@ref), [`GetNsegments`](@ref), [`GetNvertices`](@ref), [`GetVertex`](@ref), [`InspectShape`](@ref), [`IsClosedBody`](@ref), [`IsDefined`](@ref), [`MakeBuffer3D`](@ref), [`Print`](@ref), [`ResizeCenter`](@ref), [`SavePrimitive`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoTessellated!ImportFromObjFormat`](@ref), [`TGeoTessellated`](@ref)
""" TGeoTessellated

# Wrapper of TGeoTorus
@trydoc raw"""
    ROOT.TGeoTorus

The torus is defined by its axial radius, its inner and outer radius.

![https://root.cern/doc/v636/pict1_TGeoTorus_001.png](https://root.cern/doc/v636/pict1_TGeoTorus_001.png)

It may have a `phi`range:

    TGeoTorus(Double_t R,Double_t Rmin,Double_t Rmax,Double_t Phi1,
    Double_t Dphi);

(C++ version of the code)

- `R:` axial radius of the torus
- `Rmin:` inner radius
- `Rmax:` outer radius
- `Phi1:` starting phi angle
- `Dphi:` total phi range

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DDDaxis`](@ref), [`DDaxis`](@ref), [`Daxis`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`Divide`](@ref), [`GetAxisName`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetBuffer3D`](@ref), [`GetByteCount`](@ref), [`GetDphi`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetPhi1`](@ref), [`GetPointsOnSegments`](@ref), [`GetR`](@ref), [`GetRmax`](@ref), [`GetRmin`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`SetTorusDimensions`](@ref), [`Sizeof3D`](@ref), [`SolveCubic`](@ref), [`SolveQuartic`](@ref), [`TGeoTorus`](@ref), [`ToBoundary`](@ref)
""" TGeoTorus

# Wrapper of TGeoTrd1
@trydoc raw"""
    ROOT.TGeoTrd1

A trapezoid with only X varying with Z.

It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:

    TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TGeoTrd1_001.png](https://root.cern/doc/v636/pict1_TGeoTrd1_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetDx1`](@ref), [`GetDx2`](@ref), [`GetDy`](@ref), [`GetDz`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetOppositeCorner`](@ref), [`GetVisibleCorner`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetVertex`](@ref), [`Sizeof3D`](@ref), [`TGeoTrd1`](@ref)
""" TGeoTrd1

# Wrapper of TGeoTrd2
@trydoc raw"""
    ROOT.TGeoTrd2

A trapezoid with only X varying with Z.

It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:

![https://root.cern/doc/v636/pict1_TGeoTrd2_001.png](https://root.cern/doc/v636/pict1_TGeoTrd2_001.png)

Related functions: [`Capacity`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`Divide`](@ref), [`GetAxisRange`](@ref), [`GetBoundingCylinder`](@ref), [`GetByteCount`](@ref), [`GetDx1`](@ref), [`GetDx2`](@ref), [`GetDy1`](@ref), [`GetDy2`](@ref), [`GetDz`](@ref), [`GetFittingBox`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetOppositeCorner`](@ref), [`GetVisibleCorner`](@ref), [`InspectShape`](@ref), [`IsCylType`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetVertex`](@ref), [`Sizeof3D`](@ref), [`TGeoTrd2`](@ref)
""" TGeoTrd2

# Wrapper of TGeoXtru
@trydoc raw"""
    ROOT.TGeoXtru

A [TGeoXtru](@ref) shape is represented by the extrusion of an arbitrary polygon with fixed outline between several Z sections.

Each Z section is a scaled version of the same "blueprint" polygon. Different global_ XY translations are allowed from section to section. Corresponding polygon vertices from consecutive sections are connected.

An extruded polygon can be created using the constructor:

    TGeoXtru!TGeoXtru(Int_t nplanes);

(C++ version of the code)

- `nplanes:`number of Z sections (minimum 2)

End_Macro

The lists of X and Y positions for all vertices have to be provided for the "blueprint" polygon:

    TGeoXtru!DefinePolygon (Int_t nvertices, Double_t *xv,
    Double_t *yv);

(C++ version of the code)

- `nvertices:`number of vertices of the polygon
- `xv,yv:`arrays of X and Y coordinates for polygon vertices

The method creates an object of the class **`TGeoPolygon`** for which the convexity is automatically determined . The polygon is decomposed into convex polygons if needed.

Next step is to define the Z positions for each section plane as well as the XY offset and scaling for the corresponding polygons.

    TGeoXtru!DefineSection(Int_t snum,Double_t zsection,Double_t x0,
    Double_t y0, Double_t scale);

(C++ version of the code)

- `snum:`Z section index (0, nplanes-1). The section with `snum = nplanes-1` must be defined last and triggers the computation of the bounding box for the whole shape
- `zsection:`Z position of section `snum`. Sections must be defined in increasing order of Z (e.g. `snum=0` correspond to the minimum Z and `snum=nplanes-1` to the maximum one).
- `x0,y0:`offset of section `snum` with respect to the local_ shape reference frame `T`
- `scale:`factor that multiplies the X/Y coordinates of each vertex of the polygon at section `snum`:
- `x[ivert] = x0 + scale*xv[ivert]`
- `y[ivert] = y0 + scale*yv[ivert]`

Related functions: [`Capacity`](@ref), [`ClearThreadData`](@ref), [`ComputeBBox`](@ref), [`ComputeNormal_v`](@ref), [`ComputeNormal`](@ref), [`Contains_v`](@ref), [`Contains`](@ref), [`CreateThreadData`](@ref), [`DefinePolygon`](@ref), [`DefineSection`](@ref), [`DistFromInside_v`](@ref), [`DistFromInside`](@ref), [`DistFromOutside_v`](@ref), [`DistFromOutside`](@ref), [`DistancetoPrimitive`](@ref), [`DrawPolygon`](@ref), [`GetBuffer3D`](@ref), [`GetMakeRuntimeShape`](@ref), [`GetMeshNumbers`](@ref), [`GetNmeshVertices`](@ref), [`GetNvert`](@ref), [`GetNz`](@ref), [`GetScale`](@ref), [`GetThreadData`](@ref), [`GetXOffset`](@ref), [`GetX`](@ref), [`GetYOffset`](@ref), [`GetY`](@ref), [`GetZ`](@ref), [`InspectShape`](@ref), [`MakeBuffer3D`](@ref), [`Safety_v`](@ref), [`Safety`](@ref), [`SavePrimitive`](@ref), [`SetCurrentVertices`](@ref), [`SetCurrentZ`](@ref), [`SetDimensions`](@ref), [`SetPoints`](@ref), [`SetSegsAndPols`](@ref), [`Sizeof3D`](@ref), [`TGeoXtru`](@ref), [`Z`](@ref)
""" TGeoXtru
#
######################################################################

######################################################################
# Documentation of ROOT methods

# Wrapper of void TNamed::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TNamed}, option::ByCopy{String})::Nothing
Set name and title to empty strings ("").

""" Clear(this::ByRef1{TNamed}, option::ByCopy{String})

# Wrapper of TObject * TNamed::Clone(const char *)
@trydoc raw"""
    Clone(this::ByConstRef1{TNamed}, newname::ByCopy{String})::CxxPtr1{TObject}
Make a clone of an object using the Streamer facility.
If newname is specified, this will be the name of the new object.
""" Clone(this::ByConstRef1{TNamed}, newname::ByCopy{String})

# Wrapper of Int_t TNamed::Compare(const TObject *)
@trydoc raw"""
    Compare(this::ByConstRef1{TNamed}, obj::ByConstPtr1{TObject})::Int32
Compare two [TNamed](@ref) objects.
Returns 0 when equal, -1 when this is smaller and +1 when bigger (like strcmp).
""" Compare(this::ByConstRef1{TNamed}, obj::ByConstPtr1{TObject})

# Wrapper of void TNamed::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TNamed}, named::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TNamed}, named::ByRef1{TObject})

# Wrapper of void TNamed::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TNamed}, buffer::ByPtr2{Int8})::Nothing
Encode [TNamed](@ref) into output buffer.

""" FillBuffer(this::ByRef1{TNamed}, buffer::ByPtr2{Int8})

# Wrapper of const char * TNamed::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TNamed})::ByCopy{String}
Returns name of object.
This default method returns the class name. Classes that give objects a name should override this method.
""" GetName(this::ByConstRef1{TNamed})

# Wrapper of const char * TNamed::GetTitle()
@trydoc raw"""
    GetTitle(this::ByConstRef1{TNamed})::ByCopy{String}
Returns title of object.
This default method returns the class title (i.e. description). Classes that give objects a title should override this method.
""" GetTitle(this::ByConstRef1{TNamed})

# Wrapper of ULong_t TNamed::Hash()
@trydoc raw"""
    Hash(this::ByConstRef1{TNamed})::UInt64
Return hash value for this object.
Note: If this routine is overloaded in a derived class, this derived class should also add 

    ROOT!CallRecursiveRemoveIfNeeded(*this)

(C++ version of the code)

 Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of [THashList](@ref) and [THashTable](@ref) containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like 

    Error in <ROOT!Internal!TCheckHashRecursiveRemoveConsistency!CheckRecursiveRemove>: The class SomeName overrides TObject!Hash but does not call TROOT!RecursiveRemove in its destructor.

(C++ version of the code)
""" Hash(this::ByConstRef1{TNamed})

# Wrapper of TClass * TNamed::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TNamed})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TNamed})

# Wrapper of Bool_t TNamed::IsSortable()
@trydoc raw"""
    IsSortable(this::ByConstRef1{TNamed})::Bool


""" IsSortable(this::ByConstRef1{TNamed})

# Wrapper of void TNamed::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TNamed}, option::ByCopy{String})::Nothing
List [TNamed](@ref) name and title.

""" ls(this::ByConstRef1{TNamed}, option::ByCopy{String})

# Wrapper of TNamed & TNamed::operator=(const TNamed &)
@trydoc raw"""
    assign(this::ByRef1{TNamed}, rhs::ByConstRef1{TNamed})::CxxRef1{TNamed}
[TNamed](@ref) assignment operator.

""" assign(this::ByRef1{TNamed}, rhs::ByConstRef1{TNamed})

# Wrapper of void TNamed::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TNamed}, option::ByCopy{String})::Nothing
Print [TNamed](@ref) name and title.

""" Print(this::ByConstRef1{TNamed}, option::ByCopy{String})

# Wrapper of void TNamed::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TNamed}, name::ByCopy{String})::Nothing
Set the name of the [TNamed](@ref).
WARNING: if the object is a member of a [THashTable](@ref) or [THashList](@ref) container the container must be Rehash()'ed after [SetName()](@ref). For example the list of objects in the current directory is a [THashList](@ref).
""" SetName(this::ByRef1{TNamed}, name::ByCopy{String})

# Wrapper of void TNamed::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TNamed}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Set all the [TNamed](@ref) parameters (name and title).
WARNING: if the name is changed and the object is a member of a [THashTable](@ref) or [THashList](@ref) container the container must be Rehash()'ed after [SetName()](@ref). For example the list of objects in the current directory is a [THashList](@ref).
""" SetNameTitle(this::ByRef1{TNamed}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TNamed::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TNamed}, title::ByCopy{String})::Nothing
Set the title of the [TNamed](@ref).

""" SetTitle(this::ByRef1{TNamed}, title::ByCopy{String})

# Wrapper of Int_t TNamed::Sizeof()
@trydoc raw"""
    Sizeof(this::ByConstRef1{TNamed})::Int32
Return size of the [TNamed](@ref) part of the [TObject](@ref).

""" Sizeof(this::ByConstRef1{TNamed})

# Wrapper of void TNamed::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TNamed}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TNamed}, ::ByRef1{TBuffer})

# Wrapper of void TNamed::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TNamed}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TNamed}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of TClass * TNamed::Class()
@trydoc raw"""
    TNamed!Class(this::ByRef1{TNamed})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TNamed!Class(this::ByRef1{TNamed})

# Wrapper of const char * TNamed::Class_Name()
@trydoc raw"""
    TNamed!Class_Name(this::ByRef1{TNamed})::ByCopy{String}

###Return

Name of this class
""" TNamed!Class_Name(this::ByRef1{TNamed})

# Wrapper of const char * TNamed::DeclFileName()
@trydoc raw"""
    TNamed!DeclFileName(this::ByRef1{TNamed})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TNamed!DeclFileName(this::ByRef1{TNamed})

# Wrapper of void TObject::AbstractMethod(const char *)
@trydoc raw"""
    AbstractMethod(this::ByConstRef1{TObject}, method::ByCopy{String})::Nothing
Call this function within a function that you don't want to define as purely virtual, in order not to force all users deriving from that class to implement that maybe (on their side) unused function; but at the same time, emit a run-time warning if they try to call it, telling that it is not implemented in the derived class: action must thus be taken on the user side to override it.
In other word, this method acts as a "runtime purely virtual" warning instead of a "compiler purely virtual" error. 

###Warning

This interface is a legacy function that is no longer recommended to be used by new development code. 

###Note

The name "AbstractMethod" does not imply that it's an abstract method in the strict C++ sense.
""" AbstractMethod(this::ByConstRef1{TObject}, method::ByCopy{String})

# Wrapper of void TObject::AppendPad(Option_t *)
@trydoc raw"""
    AppendPad(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Append graphics object to current pad.
In case no current pad is set yet, create a default canvas with the name "c1".
""" AppendPad(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TObject}, b::ByPtr1{TBrowser})::Nothing
Browse object. May be overridden for another default action.

""" Browse(this::ByRef1{TObject}, b::ByPtr1{TBrowser})

# Wrapper of ULong_t TObject::CheckedHash()
@trydoc raw"""
    CheckedHash(this::ByRef1{TObject})::UInt64
Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object.
The intent is for this routine to be called instead of directly calling the function Hash during "insert" operations. See TObject!HasInconsistenTObjectHash();

(*) The setup is consistent when all classes in the class hierarchy that overload [TObject!Hash](@ref) do call [ROOT!CallRecursiveRemoveIfNeeded](@ref) in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.
""" CheckedHash(this::ByRef1{TObject})

# Wrapper of const char * TObject::ClassName()
@trydoc raw"""
    ClassName(this::ByConstRef1{TObject})::ByCopy{String}
Returns name of class to which the object belongs.

""" ClassName(this::ByConstRef1{TObject})

# Wrapper of void TObject::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TObject}, ::ByCopy{String})::Nothing


""" Clear(this::ByRef1{TObject}, ::ByCopy{String})

# Wrapper of TObject * TObject::Clone(const char *)
@trydoc raw"""
    Clone(this::ByConstRef1{TObject}, newname::ByCopy{String})::CxxPtr1{TObject}
Make a clone of an object using the Streamer facility.
If the object derives from [TNamed](@ref), this function is called by [TNamed!Clone](@ref). [TNamed!Clone](@ref) uses the optional argument to set a new name to the newly created object.

If the object class has a DirectoryAutoAdd function, it will be called at the theend of the function with the parameter gDirectory. This usually means that the object will be appended to the current [ROOT](@ref) directory.
""" Clone(this::ByConstRef1{TObject}, newname::ByCopy{String})

# Wrapper of Int_t TObject::Compare(const TObject *)
@trydoc raw"""
    Compare(this::ByConstRef1{TObject}, obj::ByConstPtr1{TObject})::Int32
Compare abstract method.
Must be overridden if a class wants to be able to compare itself with other objects. Must return -1 if this is smaller than obj, 0 if objects are equal and 1 if this is larger than obj.
""" Compare(this::ByConstRef1{TObject}, obj::ByConstPtr1{TObject})

# Wrapper of void TObject::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TObject}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TObject}, object::ByRef1{TObject})

# Wrapper of void TObject::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of Int_t TObject::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TObject}, px::Int32, py::Int32)::Int32
Computes distance from point (px,py) to the object.
This member function must be implemented for each graphics primitive. This default function returns a big number (999999).
""" DistancetoPrimitive(this::ByRef1{TObject}, px::Int32, py::Int32)

# Wrapper of void TObject::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::DrawClass()
@trydoc raw"""
    DrawClass(this::ByConstRef1{TObject})::Nothing
Draw class inheritance tree of the class to which this object belongs.
If a class B inherits from a class A, description of B is drawn on the right side of description of A. Member functions overridden by B are shown in class A with a blue line crossing-out the corresponding member function. The following picture is the class inheritance tree of class [TPaveLabel](@ref):

![https://root.cern/doc/v636/base_object.png](https://root.cern/doc/v636/base_object.png)
""" DrawClass(this::ByConstRef1{TObject})

# Wrapper of TObject * TObject::DrawClone(Option_t *)
@trydoc raw"""
    DrawClone(this::ByConstRef1{TObject}, option::ByCopy{String})::CxxPtr1{TObject}
Draw a clone of this object in the current selected pad with: `gROOT->SetSelectedPad(c1)`.
If pad was not selected - `gPad` will be used.
""" DrawClone(this::ByConstRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::Dump()
@trydoc raw"""
    Dump(this::ByConstRef1{TObject})::Nothing
Dump contents of object on stdout.
Using the information in the object dictionary (class [TClass](@ref)) each data member is interpreted. If a data member is a pointer, the pointer value is printed

The following output is the Dump of a [TArrow](@ref) object: 

    fAngle                   0           Arrow opening angle (degrees)
    fArrowSize               0.2         Arrow Size
    fOption.*fData
    fX1                      0.1         X of 1st point
    fY1                      0.15        Y of 1st point
    fX2                      0.67        X of 2nd point
    fY2                      0.83        Y of 2nd point
    fUniqueID                0           object unique identifier
    fBits                    50331648    bit field status word
    fLineColor               1           line color
    fLineStyle               1           line style
    fLineWidth               1           line width
    fFillColor               19          fill area color
    fFillStyle               1001        fill area style

(C++ version of the code)
""" Dump(this::ByConstRef1{TObject})

# Wrapper of void TObject::Execute(const char *, const char *, Int_t *)
@trydoc raw"""
    Execute(this::ByRef1{TObject}, method::ByCopy{String}, params::ByCopy{String}, error::ByPtr2{Int32})::Nothing
Execute method on this object with the given parameter string, e.g.
"3.14,1,\"text\"".
""" Execute(this::ByRef1{TObject}, method::ByCopy{String}, params::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of void TObject::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TObject}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to an event at (px,py).
This method must be overridden if an object can react to graphics events.
""" ExecuteEvent(this::ByRef1{TObject}, event::Int32, px::Int32, py::Int32)

# Wrapper of TObject * TObject::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TObject}, name::ByCopy{String})::CxxPtr1{TObject}
Must be redefined in derived classes.
This function is typically used with TCollections, but can also be used to find an object by name inside this object.
""" FindObject(this::ByConstRef1{TObject}, name::ByCopy{String})

# Wrapper of TObject * TObject::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TObject}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Must be redefined in derived classes.
This function is typically used with TCollections, but can also be used to find an object inside this object.
""" FindObject(this::ByConstRef1{TObject}, obj::ByConstPtr1{TObject})

# Wrapper of Option_t * TObject::GetDrawOption()
@trydoc raw"""
    GetDrawOption(this::ByConstRef1{TObject})::ByCopy{String}
Get option used by the graphics system to draw this object.
Note that before calling object.GetDrawOption(), you must have called object.Draw(..) before in the current pad.
""" GetDrawOption(this::ByConstRef1{TObject})

# Wrapper of const char * TObject::GetIconName()
@trydoc raw"""
    GetIconName(this::ByConstRef1{TObject})::ByCopy{String}
Returns mime type name of object.
Used by the [TBrowser](@ref) (via [TGMimeTypes](@ref) class). Override for class of which you would like to have different icons for objects of the same class.
""" GetIconName(this::ByConstRef1{TObject})

# Wrapper of const char * TObject::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TObject})::ByCopy{String}
Returns name of object.
This default method returns the class name. Classes that give objects a name should override this method.
""" GetName(this::ByConstRef1{TObject})

# Wrapper of char * TObject::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TObject}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Returns string containing info about the object at position (px,py).
This method is typically overridden by classes of which the objects can report peculiarities for different positions. Returned string will be re-used (lock in MT environment).
""" GetObjectInfo(this::ByConstRef1{TObject}, px::Int32, py::Int32)

# Wrapper of Option_t * TObject::GetOption()
@trydoc raw"""
    GetOption(this::ByConstRef1{TObject})::ByCopy{String}


""" GetOption(this::ByConstRef1{TObject})

# Wrapper of const char * TObject::GetTitle()
@trydoc raw"""
    GetTitle(this::ByConstRef1{TObject})::ByCopy{String}
Returns title of object.
This default method returns the class title (i.e. description). Classes that give objects a title should override this method.
""" GetTitle(this::ByConstRef1{TObject})

# Wrapper of UInt_t TObject::GetUniqueID()
@trydoc raw"""
    GetUniqueID(this::ByConstRef1{TObject})::UInt32
Return the unique object id.

""" GetUniqueID(this::ByConstRef1{TObject})

# Wrapper of Bool_t TObject::HandleTimer(TTimer *)
@trydoc raw"""
    HandleTimer(this::ByRef1{TObject}, timer::ByPtr1{TTimer})::Bool
Execute action in response of a timer timing out.
This method must be overridden if an object has to react to timers.
""" HandleTimer(this::ByRef1{TObject}, timer::ByPtr1{TTimer})

# Wrapper of ULong_t TObject::Hash()
@trydoc raw"""
    Hash(this::ByConstRef1{TObject})::UInt64
Return hash value for this object.
Note: If this routine is overloaded in a derived class, this derived class should also add 

    ROOT!CallRecursiveRemoveIfNeeded(*this)

(C++ version of the code)

 Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of [THashList](@ref) and [THashTable](@ref) containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like 

    Error in <ROOT!Internal!TCheckHashRecursiveRemoveConsistency!CheckRecursiveRemove>: The class SomeName overrides TObject!Hash but does not call TROOT!RecursiveRemove in its destructor.

(C++ version of the code)
""" Hash(this::ByConstRef1{TObject})

# Wrapper of Bool_t TObject::HasInconsistentHash()
@trydoc raw"""
    HasInconsistentHash(this::ByConstRef1{TObject})::Bool
Return true is the type of this object is *known* to have an inconsistent setup for Hash and RecursiveRemove (i.e.
missing call to RecursiveRemove in destructor).

Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check)
""" HasInconsistentHash(this::ByConstRef1{TObject})

# Wrapper of Bool_t TObject::InheritsFrom(const char *)
@trydoc raw"""
    InheritsFrom(this::ByConstRef1{TObject}, classname::ByCopy{String})::Bool
Returns kTRUE if object inherits from class "classname".

""" InheritsFrom(this::ByConstRef1{TObject}, classname::ByCopy{String})

# Wrapper of Bool_t TObject::InheritsFrom(const TClass *)
@trydoc raw"""
    InheritsFrom(this::ByConstRef1{TObject}, cl::ByConstPtr1{TClass})::Bool
Returns kTRUE if object inherits from [TClass](@ref) cl.

""" InheritsFrom(this::ByConstRef1{TObject}, cl::ByConstPtr1{TClass})

# Wrapper of void TObject::Inspect()
@trydoc raw"""
    Inspect(this::ByConstRef1{TObject})::Nothing
Dump contents of this object in a graphics canvas.
Same action as Dump but in a graphical form. In addition pointers to other objects can be followed.

The following picture is the Inspect of a histogram object: ![https://root.cern/doc/v636/base_inspect.png](https://root.cern/doc/v636/base_inspect.png)
""" Inspect(this::ByConstRef1{TObject})

# Wrapper of void TObject::InvertBit(UInt_t)
@trydoc raw"""
    InvertBit(this::ByRef1{TObject}, f::UInt32)::Nothing


""" InvertBit(this::ByRef1{TObject}, f::UInt32)

# Wrapper of TClass * TObject::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TObject})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TObject})

# Wrapper of Bool_t TObject::IsDestructed()
@trydoc raw"""
    IsDestructed(this::ByConstRef1{TObject})::Bool
IsDestructed.
###Note

This function must be non-virtual as it can be used on destructed (but not yet modified) memory. This is used for example in TClonesArray to record the element that have been destructed but not deleted and thus are ready for re-use (by operator new with placement).

###Return

true if this object's destructor has been run.
""" IsDestructed(this::ByConstRef1{TObject})

# Wrapper of Bool_t TObject::IsEqual(const TObject *)
@trydoc raw"""
    IsEqual(this::ByConstRef1{TObject}, obj::ByConstPtr1{TObject})::Bool
Default equal comparison (objects are equal if they have the same address in memory).
More complicated classes might want to override this function.
""" IsEqual(this::ByConstRef1{TObject}, obj::ByConstPtr1{TObject})

# Wrapper of Bool_t TObject::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TObject})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TObject})

# Wrapper of Bool_t TObject::IsSortable()
@trydoc raw"""
    IsSortable(this::ByConstRef1{TObject})::Bool


""" IsSortable(this::ByConstRef1{TObject})

# Wrapper of void TObject::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TObject}, option::ByCopy{String})::Nothing
The ls function lists the contents of a class on stdout.
Ls output is typically much less verbose then [Dump()](@ref).
""" ls(this::ByConstRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::MayNotUse(const char *)
@trydoc raw"""
    MayNotUse(this::ByConstRef1{TObject}, method::ByCopy{String})::Nothing
Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary).

""" MayNotUse(this::ByConstRef1{TObject}, method::ByCopy{String})

# Wrapper of Bool_t TObject::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TObject})::Bool
This method must be overridden to handle object notification (the base implementation is no-op).
Different objects in [ROOT](@ref) use the `Notify` method for different purposes, in coordination with other objects that call this method at the appropriate time.

For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a callback mechanism to inform interested parties when it switches to a new sub-tree.
""" Notify(this::ByRef1{TObject})

# Wrapper of void TObject::Obsolete(const char *, const char *, const char *)
@trydoc raw"""
    Obsolete(this::ByConstRef1{TObject}, method::ByCopy{String}, asOfVers::ByCopy{String}, removedFromVers::ByCopy{String})::Nothing
Use this method to declare a method obsolete.
Specify as of which version the method is obsolete and as from which version it will be removed.
""" Obsolete(this::ByConstRef1{TObject}, method::ByCopy{String}, asOfVers::ByCopy{String}, removedFromVers::ByCopy{String})

# Wrapper of void TObject::operator delete(void *)
@trydoc raw"""
    delete(this::ByRef1{TObject}, ptr::ByPtr2{Nothing})::Nothing
Operator delete.

""" delete(this::ByRef1{TObject}, ptr::ByPtr2{Nothing})

# Wrapper of void TObject::operator delete(void *, void *)
@trydoc raw"""
    delete(this::ByRef1{TObject}, ptr::ByPtr2{Nothing}, vp::ByPtr2{Nothing})::Nothing
Only called by placement new when throwing an exception.

""" delete(this::ByRef1{TObject}, ptr::ByPtr2{Nothing}, vp::ByPtr2{Nothing})

# Wrapper of void TObject::operator delete[](void *)
@trydoc raw"""
    deletearray(this::ByRef1{TObject}, ptr::ByPtr2{Nothing})::Nothing
Operator delete [].

""" deletearray(this::ByRef1{TObject}, ptr::ByPtr2{Nothing})

# Wrapper of void TObject::operator delete[](void *, void *)
@trydoc raw"""
    deletearray(this::ByRef1{TObject}, ptr::ByPtr2{Nothing}, vp::ByPtr2{Nothing})::Nothing
Only called by placement new[] when throwing an exception.

""" deletearray(this::ByRef1{TObject}, ptr::ByPtr2{Nothing}, vp::ByPtr2{Nothing})

# Wrapper of void * TObject::operator new(size_t)
@trydoc raw"""
    new(this::ByRef1{TObject}, sz::Int64)::CxxPtr2{Nothing}


""" new(this::ByRef1{TObject}, sz::Int64)

# Wrapper of void * TObject::operator new(size_t, void *)
@trydoc raw"""
    new(this::ByRef1{TObject}, sz::Int64, vp::ByPtr2{Nothing})::CxxPtr2{Nothing}


""" new(this::ByRef1{TObject}, sz::Int64, vp::ByPtr2{Nothing})

# Wrapper of void * TObject::operator new[](size_t)
@trydoc raw"""
    newarray(this::ByRef1{TObject}, sz::Int64)::CxxPtr2{Nothing}


""" newarray(this::ByRef1{TObject}, sz::Int64)

# Wrapper of void * TObject::operator new[](size_t, void *)
@trydoc raw"""
    newarray(this::ByRef1{TObject}, sz::Int64, vp::ByPtr2{Nothing})::CxxPtr2{Nothing}


""" newarray(this::ByRef1{TObject}, sz::Int64, vp::ByPtr2{Nothing})

# Wrapper of TObject & TObject::operator=(const TObject &)
@trydoc raw"""
    assign(this::ByRef1{TObject}, rhs::ByConstRef1{TObject})::CxxRef1{TObject}
[TObject](@ref) assignment operator.

""" assign(this::ByRef1{TObject}, rhs::ByConstRef1{TObject})

# Wrapper of void TObject::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::Pop()
@trydoc raw"""
    Pop(this::ByRef1{TObject})::Nothing
Pop on object drawn in a pad to the top of the display list.
I.e. it will be drawn last and on top of all other primitives.
""" Pop(this::ByRef1{TObject})

# Wrapper of void TObject::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TObject}, option::ByCopy{String})::Nothing
This method must be overridden when a class wants to print itself.

""" Print(this::ByConstRef1{TObject}, option::ByCopy{String})

# Wrapper of Int_t TObject::Read(const char *)
@trydoc raw"""
    Read(this::ByRef1{TObject}, name::ByCopy{String})::Int32
Read contents of object with specified name from the current directory.
First the key with the given name is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See [TObject!Write()](@ref).
""" Read(this::ByRef1{TObject}, name::ByCopy{String})

# Wrapper of void TObject::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TObject}, obj::ByPtr1{TObject})::Nothing
Recursively remove this object from a list.
Typically implemented by classes that can contain multiple references to a same object.
""" RecursiveRemove(this::ByRef1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TObject::ResetBit(UInt_t)
@trydoc raw"""
    ResetBit(this::ByRef1{TObject}, f::UInt32)::Nothing


""" ResetBit(this::ByRef1{TObject}, f::UInt32)

# Wrapper of void TObject::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TObject}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save this object in the file specified by filename.
- if "filename" contains ".root" the object is saved in filename as root binary file.
- if "filename" contains ".xml" the object is saved in filename as a xml ascii file.
- if "filename" contains ".cc" the object is saved in filename as C code independant from [ROOT](@ref). The code is generated via [SavePrimitive()](@ref). Specific code should be implemented in each object to handle this option. Like in [TF1!SavePrimitive()](@ref).
- otherwise the object is written to filename as a CINT/C++ script. The C++ code to rebuild this object is generated via [SavePrimitive()](@ref). The "option" parameter is passed to SavePrimitive. By default it is an empty string. It can be used to specify the Draw option in the code generated by SavePrimitive.

    The function is available via the object context menu.
""" SaveAs(this::ByConstRef1{TObject}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TObject::SetBit(UInt_t)
@trydoc raw"""
    SetBit(this::ByRef1{TObject}, f::UInt32)::Nothing


""" SetBit(this::ByRef1{TObject}, f::UInt32)

# Wrapper of void TObject::SetBit(UInt_t, Bool_t)
@trydoc raw"""
    SetBit(this::ByRef1{TObject}, f::UInt32, set::Bool)::Nothing
Set or unset the user status bits as specified in f.

""" SetBit(this::ByRef1{TObject}, f::UInt32, set::Bool)

# Wrapper of void TObject::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TObject}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TObject}, option::ByCopy{String})

# Wrapper of void TObject::SetUniqueID(UInt_t)
@trydoc raw"""
    SetUniqueID(this::ByRef1{TObject}, uid::UInt32)::Nothing
Set the unique object id.

""" SetUniqueID(this::ByRef1{TObject}, uid::UInt32)

# Wrapper of void TObject::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TObject}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TObject}, ::ByRef1{TBuffer})

# Wrapper of void TObject::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TObject}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TObject::TestBits(UInt_t)
@trydoc raw"""
    TestBits(this::ByConstRef1{TObject}, f::UInt32)::Int32


""" TestBits(this::ByConstRef1{TObject}, f::UInt32)

# Wrapper of void TObject::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TObject})::Nothing
Set current style settings in this object This function is called when either [TCanvas!UseCurrentStyle](@ref) or [TROOT!ForceStyle](@ref) have been invoked.

""" UseCurrentStyle(this::ByRef1{TObject})

# Wrapper of Int_t TObject::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByConstRef1{TObject}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write this object to the current directory.
The data structure corresponding to this object is serialized. The corresponding buffer is written to the current directory with an associated key with name "name".

Writing an object to a file involves the following steps:

- Creation of a support [TKey](@ref) object in the current directory. The [TKey](@ref) object creates a [TBuffer](@ref) object.
- The [TBuffer](@ref) object is filled via the class!Streamer function.
- If the file is compressed (default) a second buffer is created to hold the compressed buffer.
- Reservation of the corresponding space in the file by looking in the [TFree](@ref) list of free blocks of the file.
- The buffer is written to the file.

Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.

If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by [GetName()](@ref).

The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a [TFile](@ref)– the space is simply freed up to be overwritten; in the case of a [TTree](@ref), it is more complicated. If one opens a [TTree](@ref), appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new [TTree](@ref) and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. [TTree!Delete()](@ref) can be used to mark all disk space occupied by a [TTree](@ref) as free before overwriting its metadata this way. The kSingleKey option is only used by [TCollection!Write()](@ref) to write a container with a single key instead of each object in the container with its own key.

An object is read from the file into memory via [TKey!Read()](@ref) or via [TObject!Read()](@ref).

The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written.
""" Write(this::ByConstRef1{TObject}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of TClass * TObject::Class()
@trydoc raw"""
    TObject!Class(this::ByRef1{TObject})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TObject!Class(this::ByRef1{TObject})

# Wrapper of const char * TObject::Class_Name()
@trydoc raw"""
    TObject!Class_Name(this::ByRef1{TObject})::ByCopy{String}

###Return

Name of this class
""" TObject!Class_Name(this::ByRef1{TObject})

# Wrapper of const char * TObject::DeclFileName()
@trydoc raw"""
    TObject!DeclFileName(this::ByRef1{TObject})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TObject!DeclFileName(this::ByRef1{TObject})

# Wrapper of Longptr_t TObject::GetDtorOnly()
@trydoc raw"""
    TObject!GetDtorOnly(this::ByRef1{TObject})::Int64
Return destructor only flag.

""" TObject!GetDtorOnly(this::ByRef1{TObject})

# Wrapper of Bool_t TObject::GetObjectStat()
@trydoc raw"""
    TObject!GetObjectStat(this::ByRef1{TObject})::Bool
Get status of object stat flag.

""" TObject!GetObjectStat(this::ByRef1{TObject})

# Wrapper of void TObject::SetDtorOnly(void *)
@trydoc raw"""
    TObject!SetDtorOnly(this::ByRef1{TObject}, obj::ByPtr2{Nothing})::Nothing
Set destructor only flag.

""" TObject!SetDtorOnly(this::ByRef1{TObject}, obj::ByPtr2{Nothing})

# Wrapper of void TObject::SetObjectStat(Bool_t)
@trydoc raw"""
    TObject!SetObjectStat(this::ByRef1{TObject}, stat::Bool)::Nothing
Turn on/off tracking of objects in the [TObjectTable](@ref).

""" TObject!SetObjectStat(this::ByRef1{TObject}, stat::Bool)

# Wrapper of void TBrowser::Add(TObject *, const char *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, name::ByCopy{String}, check::Int32)::Nothing
Add object with name to browser.
If name not set the objects [GetName()](@ref) is used. If check < 0 (default) no check box is drawn, if 0 then unchecked checkbox is added, if 1 checked checkbox is added.
""" Add(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, name::ByCopy{String}, check::Int32)

# Wrapper of void TBrowser::Add(void *, TClass *, const char *, Int_t)
@trydoc raw"""
    Add(this::ByRef1{TBrowser}, obj::ByPtr2{Nothing}, cl::ByPtr1{TClass}, name::ByCopy{String}, check::Int32)::Nothing
Add foreign object with name to browser.
'cl' is the type use to store the value of obj. So literally the following pseudo code should be correct: 

    `cl->GetName()` * ptr = (`cl->GetName()`*) obj;

(C++ version of the code)

 and the value of obj is not necessarily the thestart of the object. If check < 0 (default) no check box is drawn, if 0 then unchecked checkbox is added, if 1 checked checkbox is added.
""" Add(this::ByRef1{TBrowser}, obj::ByPtr2{Nothing}, cl::ByPtr1{TClass}, name::ByCopy{String}, check::Int32)

# Wrapper of void TBrowser::AddCheckBox(TObject *, Bool_t)
@trydoc raw"""
    AddCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)::Nothing
Add checkbox for this item.

""" AddCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)

# Wrapper of void TBrowser::BrowseObject(TObject *)
@trydoc raw"""
    BrowseObject(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing


""" BrowseObject(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::CheckObjectItem(TObject *, Bool_t)
@trydoc raw"""
    CheckObjectItem(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)::Nothing
Change status of checkbox for this item.

""" CheckObjectItem(this::ByRef1{TBrowser}, obj::ByPtr1{TObject}, check::Bool)

# Wrapper of void TBrowser::Create(TObject *)
@trydoc raw"""
    Create(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Create the browser, called by the ctors.

""" Create(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::Destructor()
@trydoc raw"""
    Destructor(this::ByRef1{TBrowser})::Nothing
Actual browser destructor.

""" Destructor(this::ByRef1{TBrowser})

# Wrapper of Longptr_t TBrowser::ExecPlugin(const char *, const char *, const char *, Int_t, Int_t)
@trydoc raw"""
    ExecPlugin(this::ByRef1{TBrowser}, name::ByCopy{String}, fname::ByCopy{String}, cmd::ByCopy{String}, pos::Int32, subpos::Int32)::Int64


""" ExecPlugin(this::ByRef1{TBrowser}, name::ByCopy{String}, fname::ByCopy{String}, cmd::ByCopy{String}, pos::Int32, subpos::Int32)

# Wrapper of void TBrowser::ExecuteDefaultAction(TObject *)
@trydoc raw"""
    ExecuteDefaultAction(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Execute default action for selected object (action is specified in the `$HOME/.root.mimes` or `$ROOTSYS/etc/root.mimes file`).

""" ExecuteDefaultAction(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of TBrowserImp * TBrowser::GetBrowserImp()
@trydoc raw"""
    GetBrowserImp(this::ByConstRef1{TBrowser})::CxxPtr1{TBrowserImp}


""" GetBrowserImp(this::ByConstRef1{TBrowser})

# Wrapper of Option_t * TBrowser::GetDrawOption()
@trydoc raw"""
    GetDrawOption(this::ByConstRef1{TBrowser})::ByCopy{String}
Get option used by the graphics system to draw this object.
Note that before calling object.GetDrawOption(), you must have called object.Draw(..) before in the current pad.
""" GetDrawOption(this::ByConstRef1{TBrowser})

# Wrapper of Bool_t TBrowser::GetRefreshFlag()
@trydoc raw"""
    GetRefreshFlag(this::ByConstRef1{TBrowser})::Bool


""" GetRefreshFlag(this::ByConstRef1{TBrowser})

# Wrapper of TObject * TBrowser::GetSelected()
@trydoc raw"""
    GetSelected(this::ByConstRef1{TBrowser})::CxxPtr1{TObject}


""" GetSelected(this::ByConstRef1{TBrowser})

# Wrapper of void TBrowser::Iconify()
@trydoc raw"""
    Iconify(this::ByRef1{TBrowser})::Nothing


""" Iconify(this::ByRef1{TBrowser})

# Wrapper of void TBrowser::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Recursively remove obj from browser.

""" RecursiveRemove(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TBrowser})::Nothing
Refresh browser contents.

""" Refresh(this::ByRef1{TBrowser})

# Wrapper of void TBrowser::RemoveCheckBox(TObject *)
@trydoc raw"""
    RemoveCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})::Nothing
Remove checkbox for this item.

""" RemoveCheckBox(this::ByRef1{TBrowser}, obj::ByPtr1{TObject})

# Wrapper of void TBrowser::SetBrowserImp(TBrowserImp *)
@trydoc raw"""
    SetBrowserImp(this::ByRef1{TBrowser}, i::ByPtr1{TBrowserImp})::Nothing


""" SetBrowserImp(this::ByRef1{TBrowser}, i::ByPtr1{TBrowserImp})

# Wrapper of void TBrowser::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TBrowser}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TBrowser}, option::ByCopy{String})

# Wrapper of void TBrowser::SetRefreshFlag(Bool_t)
@trydoc raw"""
    SetRefreshFlag(this::ByRef1{TBrowser}, flag::Bool)::Nothing


""" SetRefreshFlag(this::ByRef1{TBrowser}, flag::Bool)

# Wrapper of void TBrowser::SetSelected(TObject *)
@trydoc raw"""
    SetSelected(this::ByRef1{TBrowser}, clickedObject::ByPtr1{TObject})::Nothing
Assign the last selected object.

""" SetSelected(this::ByRef1{TBrowser}, clickedObject::ByPtr1{TObject})

# Wrapper of void TBrowser::SetStatusText(const char *, Int_t)
@trydoc raw"""
    SetStatusText(this::ByRef1{TBrowser}, txt::ByCopy{String}, col::Int32)::Nothing


""" SetStatusText(this::ByRef1{TBrowser}, txt::ByCopy{String}, col::Int32)

# Wrapper of void TBrowser::Show()
@trydoc raw"""
    Show(this::ByRef1{TBrowser})::Nothing


""" Show(this::ByRef1{TBrowser})

# Wrapper of void TBrowser::StartEmbedding(Int_t, Int_t)
@trydoc raw"""
    StartEmbedding(this::ByRef1{TBrowser}, pos::Int32, subpos::Int32)::Nothing


""" StartEmbedding(this::ByRef1{TBrowser}, pos::Int32, subpos::Int32)

# Wrapper of void TBrowser::StopEmbedding(const char *)
@trydoc raw"""
    StopEmbedding(this::ByRef1{TBrowser}, name::ByCopy{String})::Nothing


""" StopEmbedding(this::ByRef1{TBrowser}, name::ByCopy{String})

# Wrapper of void TObjArray::Add(TObject *)
@trydoc raw"""
    Add(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing


""" Add(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddAfter(const TObject *, TObject *)
@trydoc raw"""
    AddAfter(this::ByRef1{TObjArray}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object in the slot after object after.
If after=0 add object in the last empty slot. Note that this will overwrite any object that might have already been in this slot. For insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddAfter(this::ByRef1{TObjArray}, after::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddAt(TObject *, Int_t)
@trydoc raw"""
    AddAt(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position ids.
Give an error when idx is out of bounds (i.e. the array is not expanded).
""" AddAt(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of void TObjArray::AddAtAndExpand(TObject *, Int_t)
@trydoc raw"""
    AddAtAndExpand(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)::Nothing
Add object at position idx.
If idx is larger than the current size of the array, expand the array (double its size).
""" AddAtAndExpand(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, idx::Int32)

# Wrapper of Int_t TObjArray::AddAtFree(TObject *)
@trydoc raw"""
    AddAtFree(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Int32
Return the position of the new object.
Find the first empty cell or AddLast if there is no empty cell
""" AddAtFree(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddBefore(const TObject *, TObject *)
@trydoc raw"""
    AddBefore(this::ByRef1{TObjArray}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})::Nothing
Add object in the slot before object before.
If before=0 add object in the first slot. Note that this will overwrite any object that might have already been in this slot. For insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddBefore(this::ByRef1{TObjArray}, before::ByConstPtr1{TObject}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddFirst(TObject *)
@trydoc raw"""
    AddFirst(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing
Add object in the first slot of the array.
This will overwrite the first element that might have been there. To have insertion semantics use either a [TList](@ref) or a [TOrdCollection](@ref).
""" AddFirst(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of void TObjArray::AddLast(TObject *)
@trydoc raw"""
    AddLast(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing
Add object in the next empty slot in the array.
Expand the array if necessary.
""" AddLast(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TObjArray::After(const TObject *)
@trydoc raw"""
    After(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Return the object after obj. Returns 0 if obj is last object.

""" After(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})

# Wrapper of TObject * TObjArray::At(Int_t)
@trydoc raw"""
    At(this::ByConstRef1{TObjArray}, idx::Int32)::CxxPtr1{TObject}


""" At(this::ByConstRef1{TObjArray}, idx::Int32)

# Wrapper of TObject * TObjArray::Before(const TObject *)
@trydoc raw"""
    Before(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Return the object before obj. Returns 0 if obj is first object.

""" Before(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})

# Wrapper of Int_t TObjArray::BinarySearch(TObject *, Int_t)
@trydoc raw"""
    BinarySearch(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, upto::Int32)::Int32
Find object using a binary search.
Array must first have been sorted. Search can be limited by setting upto to desired index.
""" BinarySearch(this::ByRef1{TObjArray}, obj::ByPtr1{TObject}, upto::Int32)

# Wrapper of void TObjArray::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TObjArray}, option::ByCopy{String})::Nothing
Remove all objects from the array.
Does not delete the objects unless the [TObjArray](@ref) is the owner (set via [SetOwner()](@ref)).
""" Clear(this::ByRef1{TObjArray}, option::ByCopy{String})

# Wrapper of void TObjArray::Compress()
@trydoc raw"""
    Compress(this::ByRef1{TObjArray})::Nothing
Remove empty slots from array.

""" Compress(this::ByRef1{TObjArray})

# Wrapper of void TObjArray::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TObjArray}, option::ByCopy{String})::Nothing
Remove all objects from the array AND delete all heap based objects.

""" Delete(this::ByRef1{TObjArray}, option::ByCopy{String})

# Wrapper of void TObjArray::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TObjArray}, newSize::Int32)::Nothing
Expand or shrink the array to newSize elements.

""" Expand(this::ByRef1{TObjArray}, newSize::Int32)

# Wrapper of TObject * TObjArray::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TObjArray}, name::ByCopy{String})::CxxPtr1{TObject}
Find an object in this collection using its name.
Requires a sequential scan till the object has been found. Returns 0 if object with specified name is not found.
""" FindObject(this::ByConstRef1{TObjArray}, name::ByCopy{String})

# Wrapper of TObject * TObjArray::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Find an object in this collection using the object's [IsEqual()](@ref) member function.
Requires a sequential scan till the object has been found. Returns 0 if object is not found. Typically this function is overridden by a more efficient version in concrete collection classes (e.g. [THashTable](@ref)).
""" FindObject(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})

# Wrapper of TObject * TObjArray::First()
@trydoc raw"""
    First(this::ByConstRef1{TObjArray})::CxxPtr1{TObject}
Return the object in the first slot.

""" First(this::ByConstRef1{TObjArray})

# Wrapper of Int_t TObjArray::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{TObjArray})::Int32
Return the number of objects in array (i.e.
number of non-empty slots). Attention: use this method ONLY if you want to know the number of non-empty slots. This function loops over the complete array and is therefore very slow when applied in a loop. Most of the time you better use [GetEntriesFast()](@ref) (only in case when there are no empty slots).
""" GetEntries(this::ByConstRef1{TObjArray})

# Wrapper of Int_t TObjArray::GetEntriesFast()
@trydoc raw"""
    GetEntriesFast(this::ByConstRef1{TObjArray})::Int32


""" GetEntriesFast(this::ByConstRef1{TObjArray})

# Wrapper of Int_t TObjArray::GetEntriesUnsafe()
@trydoc raw"""
    GetEntriesUnsafe(this::ByConstRef1{TObjArray})::Int32
Return the number of objects in array (i.e.
number of non-empty slots). This is a thread-unsafe version of GetEntriesFast. Use it only if sure it will not be invoked concurrently.
""" GetEntriesUnsafe(this::ByConstRef1{TObjArray})

# Wrapper of Int_t TObjArray::GetLast()
@trydoc raw"""
    GetLast(this::ByConstRef1{TObjArray})::Int32
Return index of last object in array.
Returns lowerBound-1 in case array is empty.
""" GetLast(this::ByConstRef1{TObjArray})

# Wrapper of TObject ** TObjArray::GetObjectRef()
@trydoc raw"""
    GetObjectRef(this::ByConstRef1{TObjArray})::CxxPtr1{TObject}


""" GetObjectRef(this::ByConstRef1{TObjArray})

# Wrapper of TObject ** TObjArray::GetObjectRef(const TObject *)
@trydoc raw"""
    GetObjectRef(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Return address of pointer obj. If obj is 0 returns address of container.

""" GetObjectRef(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})

# Wrapper of Int_t TObjArray::IndexOf(const TObject *)
@trydoc raw"""
    IndexOf(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})::Int32

- obj != 0 Return index of object in array. Returns lowerBound-1 in case array doesn't contain the obj.
- obj == 0 Return the index of the first empty slot. Returns lowerBound-1 in case array doesn't contain any empty slot.
""" IndexOf(this::ByConstRef1{TObjArray}, obj::ByConstPtr1{TObject})

# Wrapper of Bool_t TObjArray::IsEmpty()
@trydoc raw"""
    IsEmpty(this::ByConstRef1{TObjArray})::Bool


""" IsEmpty(this::ByConstRef1{TObjArray})

# Wrapper of TObject * TObjArray::Last()
@trydoc raw"""
    Last(this::ByConstRef1{TObjArray})::CxxPtr1{TObject}
Return the object in the last filled slot. Returns 0 if no entries.

""" Last(this::ByConstRef1{TObjArray})

# Wrapper of Int_t TObjArray::LowerBound()
@trydoc raw"""
    LowerBound(this::ByConstRef1{TObjArray})::Int32


""" LowerBound(this::ByConstRef1{TObjArray})

# Wrapper of TIterator * TObjArray::MakeIterator(Bool_t)
@trydoc raw"""
    MakeIterator(this::ByConstRef1{TObjArray}, dir::Bool)::CxxPtr1{TIterator}
Returns an array iterator.

""" MakeIterator(this::ByConstRef1{TObjArray}, dir::Bool)

# Wrapper of TObjArray & TObjArray::operator=(const TObjArray &)
@trydoc raw"""
    assign(this::ByRef1{TObjArray}, ::ByConstRef1{TObjArray})::CxxRef1{TObjArray}
Assignment operator. Note, unsets the kIsOwner flag.

""" assign(this::ByRef1{TObjArray}, ::ByConstRef1{TObjArray})

# Wrapper of TObject *& TObjArray::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByRef1{TObjArray}, i::Int32)::CxxPtr1{TObject}
Return the object at position i.
Returns address at position 0 if i is out of bounds. Result may be used as an lvalue.
""" Base.getindex(this::ByRef1{TObjArray}, i::Int32)

# Wrapper of TObject * TObjArray::operator[](Int_t)
@trydoc raw"""
    Base.getindex(this::ByConstRef1{TObjArray}, i::Int32)::CxxPtr1{TObject}
Return the object at position at. Returns 0 if i is out of bounds.

""" Base.getindex(this::ByConstRef1{TObjArray}, i::Int32)

# Wrapper of void TObjArray::Randomize(Int_t)
@trydoc raw"""
    Randomize(this::ByRef1{TObjArray}, ntimes::Int32)::Nothing
Randomize objects inside the array, i.e.
permute randomly objects. With fLast being the index of the last entry in the array, the following algorithm is applied to the array:

- for each entry j between 0 and fLast, another entry k is chosen randomly between 0 and fLast.
- the objects at j and k are swapped.
- this process is repeated ntimes (ntimes = 1 by default).
""" Randomize(this::ByRef1{TObjArray}, ntimes::Int32)

# Wrapper of void TObjArray::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::Nothing
Remove object from this collection and recursively remove the object from all other objects (and collections).

""" RecursiveRemove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TObjArray::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})::CxxPtr1{TObject}
Remove object from array.

""" Remove(this::ByRef1{TObjArray}, obj::ByPtr1{TObject})

# Wrapper of TObject * TObjArray::RemoveAt(Int_t)
@trydoc raw"""
    RemoveAt(this::ByRef1{TObjArray}, idx::Int32)::CxxPtr1{TObject}
Remove object at index idx.

""" RemoveAt(this::ByRef1{TObjArray}, idx::Int32)

# Wrapper of void TObjArray::RemoveRange(Int_t, Int_t)
@trydoc raw"""
    RemoveRange(this::ByRef1{TObjArray}, idx1::Int32, idx2::Int32)::Nothing
Remove objects from index idx1 to idx2 included.

""" RemoveRange(this::ByRef1{TObjArray}, idx1::Int32, idx2::Int32)

# Wrapper of void TObjArray::SetLast(Int_t)
@trydoc raw"""
    SetLast(this::ByRef1{TObjArray}, last::Int32)::Nothing
Set index of last object in array, effectively truncating the array.
Use carefully since whenever last position has to be recalculated, e.g. after a [Remove()](@ref) or [Sort()](@ref) it will be reset to the last non-empty slot. If last is -2 this will force the recalculation of the last used slot. If last is -1, this effectively truncate the array completely.
""" SetLast(this::ByRef1{TObjArray}, last::Int32)

# Wrapper of void TObjArray::Sort(Int_t)
@trydoc raw"""
    Sort(this::ByRef1{TObjArray}, upto::Int32)::Nothing
If objects in array are sortable (i.e.
[IsSortable()](@ref) returns true for all objects) then sort array.
""" Sort(this::ByRef1{TObjArray}, upto::Int32)

# Wrapper of TObject * TObjArray::UncheckedAt(Int_t)
@trydoc raw"""
    UncheckedAt(this::ByConstRef1{TObjArray}, i::Int32)::CxxPtr1{TObject}


""" UncheckedAt(this::ByConstRef1{TObjArray}, i::Int32)

# Wrapper of const TCollection * TObjArrayIter::GetCollection()
@trydoc raw"""
    GetCollection(this::ByConstRef1{TObjArrayIter})::ConstCxxPtr1{TCollection}


""" GetCollection(this::ByConstRef1{TObjArrayIter})

# Wrapper of TObject * TObjArrayIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TObjArrayIter})::CxxPtr1{TObject}
Return next object in array. Returns 0 when no more objects in array.

""" Next(this::ByRef1{TObjArrayIter})

# Wrapper of Bool_t TObjArrayIter::operator!=(const TIterator &)
@trydoc raw"""
    Base.:(!=)(this::ByConstRef1{TObjArrayIter}, aIter::ByConstRef1{TIterator})::Bool
This operator compares two [TIterator](@ref) objects.

""" Base.:(!=)(this::ByConstRef1{TObjArrayIter}, aIter::ByConstRef1{TIterator})

# Wrapper of Bool_t TObjArrayIter::operator!=(const TObjArrayIter &)
@trydoc raw"""
    Base.:(!=)(this::ByConstRef1{TObjArrayIter}, aIter::ByConstRef1{TObjArrayIter})::Bool
This operator compares two [TObjArrayIter](@ref) objects.

""" Base.:(!=)(this::ByConstRef1{TObjArrayIter}, aIter::ByConstRef1{TObjArrayIter})

# Wrapper of TObject * TObjArrayIter::operator*()
@trydoc raw"""
    Base.getindex(this::ByConstRef1{TObjArrayIter})::CxxPtr1{TObject}
Return current object or nullptr.

""" Base.getindex(this::ByConstRef1{TObjArrayIter})

# Wrapper of TIterator & TObjArrayIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator.

""" assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TObjArrayIter & TObjArrayIter::operator=(const TObjArrayIter &)
@trydoc raw"""
    assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TObjArrayIter})::CxxRef1{TObjArrayIter}
Overloaded assignment operator.

""" assign(this::ByRef1{TObjArrayIter}, rhs::ByConstRef1{TObjArrayIter})

# Wrapper of void TObjArrayIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TObjArrayIter})::Nothing
Reset array iterator.

""" Reset(this::ByRef1{TObjArrayIter})

# Wrapper of void TDirectory::Add(TObject *, Bool_t)
@trydoc raw"""
    Add(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)::Nothing


""" Add(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of void TDirectory::Append(TObject *, Bool_t)
@trydoc raw"""
    Append(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)::Nothing
Append object to this directory.
If `replace` is true: remove any existing objects with the same name (if the name is not "")
""" Append(this::ByRef1{TDirectory}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of Int_t TDirectory::AppendKey(TKey *)
@trydoc raw"""
    AppendKey(this::ByRef1{TDirectory}, ::ByPtr1{TKey})::Int32


""" AppendKey(this::ByRef1{TDirectory}, ::ByPtr1{TKey})

# Wrapper of void TDirectory::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TDirectory}, b::ByPtr1{TBrowser})::Nothing
Browse the content of the directory.

""" Browse(this::ByRef1{TDirectory}, b::ByPtr1{TBrowser})

# Wrapper of void TDirectory::Build(TFile *, TDirectory *)
@trydoc raw"""
    Build(this::ByRef1{TDirectory}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})::Nothing


""" Build(this::ByRef1{TDirectory}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})

# Wrapper of Bool_t TDirectory::cd()
@trydoc raw"""
    cd(this::ByRef1{TDirectory})::Bool
Change current directory to "this" directory.
Returns kTRUE (it's guaranteed to succeed).
""" cd(this::ByRef1{TDirectory})

# Wrapper of Bool_t TDirectory::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TDirectory}, path::ByCopy{String})::Bool
Change current directory to "this" directory or to the directory described by the path if given one.
Using path one can change the current directory to "path". The absolute path syntax is: `file.root:/dir1/dir2` where `file.root` is the file and `/dir1/dir2` the desired subdirectory in the file.

Relative syntax is relative to "this" directory. E.g: `../aa`.

Returns kTRUE in case of success.
""" cd(this::ByRef1{TDirectory}, path::ByCopy{String})

# Wrapper of void TDirectory::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Delete all objects from a Directory list.

""" Clear(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of TObject * TDirectory::CloneObject(const TObject *, Bool_t)
@trydoc raw"""
    CloneObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, autoadd::Bool)::CxxPtr1{TObject}
Clone an object.
This function is called when the directory is not a [TDirectoryFile](@ref). This version has to load the I/O package, hence via Cling.

If autoadd is true and if the object class has a DirectoryAutoAdd function, it will be called at the theend of the function with the parameter gDirector. This usually means that the object will be appended to the current [ROOT](@ref) directory.
""" CloneObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, autoadd::Bool)

# Wrapper of void TDirectory::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Delete all objects from memory and directory structure itself.
if option is "slow", iterate through the containers in a way to can handle 'external' modification (induced by recursions) if option is "nodelete", write the [TDirectory](@ref) but do not delete the contained objects.
""" Close(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TDirectory}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TDirectory}, object::ByRef1{TObject})

# Wrapper of void TDirectory::Delete(const char *)
@trydoc raw"""
    Delete(this::ByRef1{TDirectory}, namecycle::ByCopy{String})::Nothing
Delete Objects or/and keys in a directory.
- namecycle has the format name;cycle
- namecycle = "" same as namecycle ="T*"
- name = * means all
- cycle = * means all cycles (memory and keys)
- cycle = "" or cycle = 9999 ==> apply to a memory object When name=* use T* to delete subdirectories also

To delete one directory, you must specify the directory cycle, eg. `file.Delete("dir1;1");`

examples:

- foo : delete object named foo in memory
- foo* : delete all objects with a name starting with foo
- foo;1 : delete cycle 1 of foo on file
- foo;* : delete all cycles of foo on file and also from memory
- *;2 : delete all objects on file having the cycle 2
- *;* : delete all objects from memory and file
- T*;* : delete all objects from memory and file and all subdirectories
""" Delete(this::ByRef1{TDirectory}, namecycle::ByCopy{String})

# Wrapper of void TDirectory::DeleteAll(Option_t *)
@trydoc raw"""
    DeleteAll(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Delete all objects from memory.

""" DeleteAll(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Fill Graphics Structure and Paint.
Loop on all objects (memory or file) and all subdirectories
""" Draw(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of TKey * TDirectory::FindKey(const char *)
@trydoc raw"""
    FindKey(this::ByConstRef1{TDirectory}, ::ByCopy{String})::CxxPtr1{TKey}


""" FindKey(this::ByConstRef1{TDirectory}, ::ByCopy{String})

# Wrapper of TKey * TDirectory::FindKeyAny(const char *)
@trydoc raw"""
    FindKeyAny(this::ByConstRef1{TDirectory}, ::ByCopy{String})::CxxPtr1{TKey}


""" FindKeyAny(this::ByConstRef1{TDirectory}, ::ByCopy{String})

# Wrapper of TObject * TDirectory::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TDirectory}, name::ByCopy{String})::CxxPtr1{TObject}
Find object by name in the list of memory objects.

""" FindObject(this::ByConstRef1{TDirectory}, name::ByCopy{String})

# Wrapper of TObject * TDirectory::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TDirectory}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Find object in the list of memory objects.

""" FindObject(this::ByConstRef1{TDirectory}, obj::ByConstPtr1{TObject})

# Wrapper of TObject * TDirectory::FindObjectAny(const char *)
@trydoc raw"""
    FindObjectAny(this::ByConstRef1{TDirectory}, name::ByCopy{String})::CxxPtr1{TObject}
Find object by name in the list of memory objects of the current directory or its sub-directories.
After this call the current directory is not changed. To automatically set the current directory where the object is found, use FindKeyAny(aname)->ReadObj().
""" FindObjectAny(this::ByConstRef1{TDirectory}, name::ByCopy{String})

# Wrapper of TObject * TDirectory::FindObjectAnyFile(const char *)
@trydoc raw"""
    FindObjectAnyFile(this::ByConstRef1{TDirectory}, ::ByCopy{String})::CxxPtr1{TObject}


""" FindObjectAnyFile(this::ByConstRef1{TDirectory}, ::ByCopy{String})

# Wrapper of TObject * TDirectory::Get(const char *)
@trydoc raw"""
    Get(this::ByRef1{TDirectory}, namecycle::ByCopy{String})::CxxPtr1{TObject}
Return pointer to object identified by namecycle.
namecycle has the format name;cycle

- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

examples:

- foo : get object named foo in memory if object is not in memory, try with highest cycle from file
- foo;1 : get cycle 1 of foo on file

The retrieved object should in principle derive from [TObject](@ref). If not, the function [TDirectory!GetObject](@ref) should be called. However, this function will still work for a non-TObject, providing that the calling application cast the return type to the correct type (which is the actual type of the object).

NOTE:

The method GetObject offer better protection and avoid the need for any cast: 

    MyClass *obj;
    directory->GetObject("some object",obj);
    if (obj) { ... the object exist and inherits from MyClass ... }

(C++ version of the code)

VERY IMPORTANT NOTE:

In case the class of this object derives from [TObject](@ref) but not as a first inheritance, one must use dynamic_cast<>(). #### Example 1: Normal case:

    class MyClass : public TObject, public AnotherClass

(C++ version of the code)

 then on return, one can do: 

    MyClass *obj = (MyClass*)directory->Get("some object of MyClass");

(C++ version of the code)

 #### Example 2: Special case:

    class MyClass : public AnotherClass, public TObject

(C++ version of the code)

 then on return, one must do: 

    MyClass *obj = dynamic_cast<MyClass*>(directory->Get("some object of MyClass"));

(C++ version of the code)

 Of course, dynamic_cast<> can also be used in the example 1.
""" Get(this::ByRef1{TDirectory}, namecycle::ByCopy{String})

# Wrapper of Int_t TDirectory::GetBufferSize()
@trydoc raw"""
    GetBufferSize(this::ByConstRef1{TDirectory})::Int32


""" GetBufferSize(this::ByConstRef1{TDirectory})

# Wrapper of TDirectory * TDirectory::GetDirectory(const char *, Bool_t, const char *)
@trydoc raw"""
    GetDirectory(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, printError::Bool, funcname::ByCopy{String})::CxxPtr1{TDirectory}
Find a directory using apath.
It apath is null or empty, returns "this" directory. Otherwise use apath to find a directory. The absolute path syntax is: `file.root:/dir1/dir2`

where file.root is the file and /dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to "this" directory. E.g: `../aa`. Returns 0 in case path does not exist. If printError is true, use Error with 'funcname' to issue an error message.
""" GetDirectory(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, printError::Bool, funcname::ByCopy{String})

# Wrapper of TFile * TDirectory::GetFile()
@trydoc raw"""
    GetFile(this::ByConstRef1{TDirectory})::CxxPtr1{TFile}


""" GetFile(this::ByConstRef1{TDirectory})

# Wrapper of TKey * TDirectory::GetKey(const char *, Short_t)
@trydoc raw"""
    GetKey(this::ByConstRef1{TDirectory}, ::ByCopy{String}, ::Int16)::CxxPtr1{TKey}


""" GetKey(this::ByConstRef1{TDirectory}, ::ByCopy{String}, ::Int16)

# Wrapper of TList * TDirectory::GetList()
@trydoc raw"""
    GetList(this::ByConstRef1{TDirectory})::CxxPtr1{TList}


""" GetList(this::ByConstRef1{TDirectory})

# Wrapper of TList * TDirectory::GetListOfKeys()
@trydoc raw"""
    GetListOfKeys(this::ByConstRef1{TDirectory})::CxxPtr1{TList}


""" GetListOfKeys(this::ByConstRef1{TDirectory})

# Wrapper of TObject * TDirectory::GetMother()
@trydoc raw"""
    GetMother(this::ByConstRef1{TDirectory})::CxxPtr1{TObject}


""" GetMother(this::ByConstRef1{TDirectory})

# Wrapper of TDirectory * TDirectory::GetMotherDir()
@trydoc raw"""
    GetMotherDir(this::ByConstRef1{TDirectory})::CxxPtr1{TDirectory}


""" GetMotherDir(this::ByConstRef1{TDirectory})

# Wrapper of Int_t TDirectory::GetNbytesKeys()
@trydoc raw"""
    GetNbytesKeys(this::ByConstRef1{TDirectory})::Int32


""" GetNbytesKeys(this::ByConstRef1{TDirectory})

# Wrapper of Int_t TDirectory::GetNkeys()
@trydoc raw"""
    GetNkeys(this::ByConstRef1{TDirectory})::Int32


""" GetNkeys(this::ByConstRef1{TDirectory})

# Wrapper of void * TDirectory::GetObjectChecked(const char *, const char *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, classname::ByCopy{String})::CxxPtr2{Nothing}
See documentation of TDirectory!GetObjectCheck(const char *namecycle, const TClass *cl)

""" GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, classname::ByCopy{String})

# Wrapper of void * TDirectory::GetObjectChecked(const char *, const TClass *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a "expectedClass" If expectedClass is null, no check is performed.
namecycle has the format `name;cycle`

- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

VERY IMPORTANT NOTE:

The calling application must cast the returned pointer to the type described by the 2 arguments (i.e. cl): 

    MyClass *obj = (MyClass*)directory->GetObjectChecked("some object of MyClass","MyClass"));

(C++ version of the code)

 Note: We recommend using the method [TDirectory!GetObject](@ref): 

    MyClass *obj = nullptr;
    directory->GetObject("some object inheriting from MyClass",obj);
    if (obj) { ... we found what we are looking for ... }

(C++ version of the code)
""" GetObjectChecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})

# Wrapper of void * TDirectory::GetObjectUnchecked(const char *)
@trydoc raw"""
    GetObjectUnchecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle.
The returned object may or may not derive from [TObject](@ref).

- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

VERY IMPORTANT NOTE:

The calling application must cast the returned object to the final type, e.g. 

    MyClass *obj = (MyClass*)directory->GetObject("some object of MyClass");

(C++ version of the code)
""" GetObjectUnchecked(this::ByRef1{TDirectory}, namecycle::ByCopy{String})

# Wrapper of const char * TDirectory::GetPath()
@trydoc raw"""
    GetPath(this::ByConstRef1{TDirectory})::ByCopy{String}
Returns the full path of the directory.
E.g. `file:/dir1/dir2`. The returned path will be re-used by the next call to [GetPath()](@ref).
""" GetPath(this::ByConstRef1{TDirectory})

# Wrapper of const char * TDirectory::GetPathStatic()
@trydoc raw"""
    GetPathStatic(this::ByConstRef1{TDirectory})::ByCopy{String}
Returns the full path of the directory.
E.g. `file:/dir1/dir2`. The returned path will be re-used by the next call to [GetPath()](@ref).
""" GetPathStatic(this::ByConstRef1{TDirectory})

# Wrapper of Long64_t TDirectory::GetSeekDir()
@trydoc raw"""
    GetSeekDir(this::ByConstRef1{TDirectory})::Int64


""" GetSeekDir(this::ByConstRef1{TDirectory})

# Wrapper of Long64_t TDirectory::GetSeekKeys()
@trydoc raw"""
    GetSeekKeys(this::ByConstRef1{TDirectory})::Int64


""" GetSeekKeys(this::ByConstRef1{TDirectory})

# Wrapper of Long64_t TDirectory::GetSeekParent()
@trydoc raw"""
    GetSeekParent(this::ByConstRef1{TDirectory})::Int64


""" GetSeekParent(this::ByConstRef1{TDirectory})

# Wrapper of TUUID TDirectory::GetUUID()
@trydoc raw"""
    GetUUID(this::ByConstRef1{TDirectory})::ByCopy{TUUID}


""" GetUUID(this::ByConstRef1{TDirectory})

# Wrapper of TClass * TDirectory::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TDirectory})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TDirectory})

# Wrapper of Bool_t TDirectory::IsBuilt()
@trydoc raw"""
    IsBuilt(this::ByConstRef1{TDirectory})::Bool


""" IsBuilt(this::ByConstRef1{TDirectory})

# Wrapper of Bool_t TDirectory::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TDirectory})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TDirectory})

# Wrapper of Bool_t TDirectory::IsModified()
@trydoc raw"""
    IsModified(this::ByConstRef1{TDirectory})::Bool


""" IsModified(this::ByConstRef1{TDirectory})

# Wrapper of Bool_t TDirectory::IsWritable()
@trydoc raw"""
    IsWritable(this::ByConstRef1{TDirectory})::Bool


""" IsWritable(this::ByConstRef1{TDirectory})

# Wrapper of void TDirectory::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TDirectory}, option::ByCopy{String})::Nothing
List Directory contents.
Indentation is used to identify the directory tree Subdirectories are listed first, then objects in memory.

The option can has the following format: 
```
 [<regexp>]
```  The `<regexp>` will be used to match the name of the objects. By default memory and disk objects are listed.
""" ls(this::ByConstRef1{TDirectory}, option::ByCopy{String})

# Wrapper of TDirectory * TDirectory::mkdir(const char *, const char *, Bool_t)
@trydoc raw"""
    mkdir(this::ByRef1{TDirectory}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)::CxxPtr1{TDirectory}
Create a sub-directory "a" or a hierarchy of sub-directories "a/b/c/...".
## Arguments

- **`name`** 
    the name or hierarchy of the subdirectory ("a" or "a/b/c") 
    
- **`title`** 
    the title 
    
- **`returnExistingDirectory`** 
    if key-name is already existing, the returned value points to preexisting sub-directory if true and to `nullptr` if false. 
    

###Return

a pointer to the created sub-directory, not to the top sub-directory of the hierarchy (in the above example, the returned TDirectory * points to "c"). In case of an error, it returns nullptr. In case of a preexisting sub-directory (hierarchy) with the requested name, the return value depends on the parameter returnExistingDirectory.

In particular, the steps to create first a/b/c and then a/b/d without receiving errors are: 

    TFile * file = new TFile("afile","RECREATE");
    file->mkdir("a");
    file->cd("a");
    gDirectory->mkdir("b/c");
    gDirectory->cd("b");
    gDirectory->mkdir("d");

(C++ version of the code)

 or 

    TFile * file = new TFile("afile","RECREATE");
    file->mkdir("a");
    file->cd("a");
    gDirectory->mkdir("b/c");
    gDirectory->mkdir("b/d", "", true);

(C++ version of the code)
""" mkdir(this::ByRef1{TDirectory}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)

# Wrapper of TFile * TDirectory::OpenFile(const char *, Option_t *, const char *, Int_t, Int_t)
@trydoc raw"""
    OpenFile(this::ByRef1{TDirectory}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32, ::Int32)::CxxPtr1{TFile}


""" OpenFile(this::ByRef1{TDirectory}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32, ::Int32)

# Wrapper of void TDirectory::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TDirectory}, option::ByCopy{String})::Nothing
Paint all objects in the directory.

""" Paint(this::ByRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TDirectory}, option::ByCopy{String})::Nothing
Print all objects in the directory.

""" Print(this::ByConstRef1{TDirectory}, option::ByCopy{String})

# Wrapper of void TDirectory::Purge(Short_t)
@trydoc raw"""
    Purge(this::ByRef1{TDirectory}, ::Int16)::Nothing


""" Purge(this::ByRef1{TDirectory}, ::Int16)

# Wrapper of void TDirectory::pwd()
@trydoc raw"""
    pwd(this::ByConstRef1{TDirectory})::Nothing
Print the path of the directory.

""" pwd(this::ByConstRef1{TDirectory})

# Wrapper of void TDirectory::ReadAll(Option_t *)
@trydoc raw"""
    ReadAll(this::ByRef1{TDirectory}, ::ByCopy{String})::Nothing


""" ReadAll(this::ByRef1{TDirectory}, ::ByCopy{String})

# Wrapper of Int_t TDirectory::ReadKeys(Bool_t)
@trydoc raw"""
    ReadKeys(this::ByRef1{TDirectory}, ::Bool)::Int32


""" ReadKeys(this::ByRef1{TDirectory}, ::Bool)

# Wrapper of Int_t TDirectory::ReadTObject(TObject *, const char *)
@trydoc raw"""
    ReadTObject(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByCopy{String})::Int32


""" ReadTObject(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByCopy{String})

# Wrapper of void TDirectory::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TDirectory}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from a Directory.

""" RecursiveRemove(this::ByRef1{TDirectory}, obj::ByPtr1{TObject})

# Wrapper of TObject * TDirectory::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TDirectory}, ::ByPtr1{TObject})::CxxPtr1{TObject}
Remove an object from the in-memory list.

""" Remove(this::ByRef1{TDirectory}, ::ByPtr1{TObject})

# Wrapper of void TDirectory::rmdir(const char *)
@trydoc raw"""
    rmdir(this::ByRef1{TDirectory}, name::ByCopy{String})::Nothing
Removes subdirectory from the directory When directory is deleted, all keys in all subdirectories will be read first and deleted from file (if exists) Equivalent call is Delete("name;*");.

""" rmdir(this::ByRef1{TDirectory}, name::ByCopy{String})

# Wrapper of void TDirectory::Save()
@trydoc raw"""
    Save(this::ByRef1{TDirectory})::Nothing


""" Save(this::ByRef1{TDirectory})

# Wrapper of Int_t TDirectory::SaveObjectAs(const TObject *, const char *, Option_t *)
@trydoc raw"""
    SaveObjectAs(this::ByConstRef1{TDirectory}, ::ByConstPtr1{TObject}, ::ByCopy{String}, ::ByCopy{String})::Int32
Save object in filename, if filename is `nullptr` or "", a file with "<objectname>.root" is created.
The name of the key is the object name. By default new file will be created. Using option "a", one can append object to the existing [ROOT](@ref) file. If the operation is successful, it returns the number of bytes written to the file otherwise it returns 0. By default a message is printed. Use option "q" to not print the message. If filename contains ".json" extension, JSON representation of the object will be created and saved in the text file. Such file can be used in JavaScript [ROOT](@ref) ([https://root.cern/js/](https://root.cern/js/)) to display object in web browser When creating JSON file, option string may contain compression level from 0 to 3 (default 0)
""" SaveObjectAs(this::ByConstRef1{TDirectory}, ::ByConstPtr1{TObject}, ::ByCopy{String}, ::ByCopy{String})

# Wrapper of void TDirectory::SaveSelf(Bool_t)
@trydoc raw"""
    SaveSelf(this::ByRef1{TDirectory}, ::Bool)::Nothing


""" SaveSelf(this::ByRef1{TDirectory}, ::Bool)

# Wrapper of void TDirectory::SetBufferSize(Int_t)
@trydoc raw"""
    SetBufferSize(this::ByRef1{TDirectory}, ::Int32)::Nothing


""" SetBufferSize(this::ByRef1{TDirectory}, ::Int32)

# Wrapper of void TDirectory::SetModified()
@trydoc raw"""
    SetModified(this::ByRef1{TDirectory})::Nothing


""" SetModified(this::ByRef1{TDirectory})

# Wrapper of void TDirectory::SetMother(TObject *)
@trydoc raw"""
    SetMother(this::ByRef1{TDirectory}, mother::ByPtr1{TObject})::Nothing


""" SetMother(this::ByRef1{TDirectory}, mother::ByPtr1{TObject})

# Wrapper of void TDirectory::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TDirectory}, newname::ByCopy{String})::Nothing
Set the name for directory If the directory name is changed after the directory was written once, [ROOT](@ref) currently would NOT change the name of correspondent key in the mother directory.
DO NOT use this method to 'rename a directory'. Renaming a directory is currently NOT supported.
""" SetName(this::ByRef1{TDirectory}, newname::ByCopy{String})

# Wrapper of void TDirectory::SetSeekDir(Long64_t)
@trydoc raw"""
    SetSeekDir(this::ByRef1{TDirectory}, ::Int64)::Nothing


""" SetSeekDir(this::ByRef1{TDirectory}, ::Int64)

# Wrapper of void TDirectory::SetTRefAction(TObject *, TObject *)
@trydoc raw"""
    SetTRefAction(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByPtr1{TObject})::Nothing


""" SetTRefAction(this::ByRef1{TDirectory}, ::ByPtr1{TObject}, ::ByPtr1{TObject})

# Wrapper of void TDirectory::SetWritable(Bool_t)
@trydoc raw"""
    SetWritable(this::ByRef1{TDirectory}, ::Bool)::Nothing


""" SetWritable(this::ByRef1{TDirectory}, ::Bool)

# Wrapper of Int_t TDirectory::Sizeof()
@trydoc raw"""
    Sizeof(this::ByConstRef1{TDirectory})::Int32
Return size of the [TNamed](@ref) part of the [TObject](@ref).

""" Sizeof(this::ByConstRef1{TDirectory})

# Wrapper of void TDirectory::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TDirectory}, ::ByRef1{TBuffer})::Nothing
[TDirectory](@ref) Streamer.

""" Streamer(this::ByRef1{TDirectory}, ::ByRef1{TBuffer})

# Wrapper of void TDirectory::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TDirectory}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TDirectory}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of Int_t TDirectory::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TDirectory}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write this object to the current directory.
For more see the const version of this method.
""" Write(this::ByRef1{TDirectory}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of void TDirectory::WriteDirHeader()
@trydoc raw"""
    WriteDirHeader(this::ByRef1{TDirectory})::Nothing


""" WriteDirHeader(this::ByRef1{TDirectory})

# Wrapper of void TDirectory::WriteKeys()
@trydoc raw"""
    WriteKeys(this::ByRef1{TDirectory})::Nothing


""" WriteKeys(this::ByRef1{TDirectory})

# Wrapper of Int_t TDirectory::WriteObjectAny(const void *, const char *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)::Int32


""" WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByCopy{String}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)

# Wrapper of Int_t TDirectory::WriteObjectAny(const void *, const TClass *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByConstPtr1{TClass}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)::Int32


""" WriteObjectAny(this::ByRef1{TDirectory}, ::ByConstPtr2{Nothing}, ::ByConstPtr1{TClass}, ::ByCopy{String}, ::ByCopy{String}, ::Int32)

# Wrapper of Int_t TDirectory::WriteTObject(const TObject *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteTObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, ::ByCopy{String}, ::Int32)::Int32
Write an object with proper type checking.
## Arguments

- **`obj`** [in] 
    Pointer to an object to be written. 
    
- **`name`** [in] 
    Name of the object in the file. 
    
- **`option`** [in] 
    Options. See [TDirectoryFile!WriteTObject](@ref). 
    
- **`bufsize`** [in] 
    Buffer size. See [TDirectoryFile!WriteTObject](@ref).
    

This overload takes care of instances of classes that are not derived from [TObject](@ref). The method redirects to [TDirectory!WriteObjectAny](@ref).
""" WriteTObject(this::ByRef1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, ::ByCopy{String}, ::Int32)

# Wrapper of void TDirectory::AddDirectory(Bool_t)
@trydoc raw"""
    TDirectory!AddDirectory(this::ByRef1{TDirectory}, add::Bool)::Nothing
Sets the flag controlling the automatic add objects like histograms, [TGraph2D](@ref), etc in memory.
By default (fAddDirectory = kTRUE), these objects are automatically added to the list of objects in memory. Note that in the classes like [TH1](@ref), [TGraph2D](@ref) supporting this facility, one object can be removed from its support directory by calling object->SetDirectory(nullptr) or object->SetDirectory(dir) to add it to the list of objects in the directory dir.

NOTE that this is a static function. To call it, use: 

    TDirectory!AddDirectory

(C++ version of the code)
""" TDirectory!AddDirectory(this::ByRef1{TDirectory}, add::Bool)

# Wrapper of Bool_t TDirectory::AddDirectoryStatus()
@trydoc raw"""
    TDirectory!AddDirectoryStatus(this::ByRef1{TDirectory})::Bool
Static function: see [TDirectory!AddDirectory](@ref) for more comments.

""" TDirectory!AddDirectoryStatus(this::ByRef1{TDirectory})

# Wrapper of Bool_t TDirectory::Cd(const char *)
@trydoc raw"""
    TDirectory!Cd(this::ByRef1{TDirectory}, path::ByCopy{String})::Bool
Change current directory to "path".
The absolute path syntax is: `file.root:/dir1/dir2` where file.root is the file and `/dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to the current directory `gDirectory`, e.g.: `../aa`.

Returns kTRUE in case of success.
""" TDirectory!Cd(this::ByRef1{TDirectory}, path::ByCopy{String})

# Wrapper of TClass * TDirectory::Class()
@trydoc raw"""
    TDirectory!Class(this::ByRef1{TDirectory})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TDirectory!Class(this::ByRef1{TDirectory})

# Wrapper of const char * TDirectory::Class_Name()
@trydoc raw"""
    TDirectory!Class_Name(this::ByRef1{TDirectory})::ByCopy{String}

###Return

Name of this class
""" TDirectory!Class_Name(this::ByRef1{TDirectory})

# Wrapper of const char * TDirectory::DeclFileName()
@trydoc raw"""
    TDirectory!DeclFileName(this::ByRef1{TDirectory})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TDirectory!DeclFileName(this::ByRef1{TDirectory})

# Wrapper of void TKey::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TKey}, b::ByPtr1{TBrowser})::Nothing
Read object from disk and call its [Browse()](@ref) method.
If object with same name already exist in memory delete it (like [TDirectoryFile!Get()](@ref) is doing), except when the key references a folder in which case we don't want to re-read the folder object since it might contain new objects not yet saved.
""" Browse(this::ByRef1{TKey}, b::ByPtr1{TBrowser})

# Wrapper of void TKey::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TKey}, option::ByCopy{String})::Nothing
Delete an object from the file.
Note: the key is not deleted. You still have to call "delete key". This is different from the behaviour of [TObject!Delete()](@ref)!
""" Delete(this::ByRef1{TKey}, option::ByCopy{String})

# Wrapper of void TKey::DeleteBuffer()
@trydoc raw"""
    DeleteBuffer(this::ByRef1{TKey})::Nothing
Delete key buffer(s).

""" DeleteBuffer(this::ByRef1{TKey})

# Wrapper of void TKey::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})::Nothing
Encode key header into output buffer.

""" FillBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})

# Wrapper of char * TKey::GetBuffer()
@trydoc raw"""
    GetBuffer(this::ByConstRef1{TKey})::ByCopy{Union{String, Vector{CxxChar}}}


""" GetBuffer(this::ByConstRef1{TKey})

# Wrapper of TBuffer * TKey::GetBufferRef()
@trydoc raw"""
    GetBufferRef(this::ByConstRef1{TKey})::CxxPtr1{TBuffer}


""" GetBufferRef(this::ByConstRef1{TKey})

# Wrapper of const char * TKey::GetClassName()
@trydoc raw"""
    GetClassName(this::ByConstRef1{TKey})::ByCopy{String}


""" GetClassName(this::ByConstRef1{TKey})

# Wrapper of Short_t TKey::GetCycle()
@trydoc raw"""
    GetCycle(this::ByConstRef1{TKey})::Int16
Return cycle number associated to this key.

""" GetCycle(this::ByConstRef1{TKey})

# Wrapper of const TDatime & TKey::GetDatime()
@trydoc raw"""
    GetDatime(this::ByConstRef1{TKey})::ConstCxxRef1{TDatime}


""" GetDatime(this::ByConstRef1{TKey})

# Wrapper of TFile * TKey::GetFile()
@trydoc raw"""
    GetFile(this::ByConstRef1{TKey})::CxxPtr1{TFile}
Returns file to which key belong.

""" GetFile(this::ByConstRef1{TKey})

# Wrapper of const char * TKey::GetIconName()
@trydoc raw"""
    GetIconName(this::ByConstRef1{TKey})::ByCopy{String}
Title can keep 32x32 xpm thumbnail/icon of the parent object.

""" GetIconName(this::ByConstRef1{TKey})

# Wrapper of Short_t TKey::GetKeep()
@trydoc raw"""
    GetKeep(this::ByConstRef1{TKey})::Int16
Returns the "KEEP" status.

""" GetKeep(this::ByConstRef1{TKey})

# Wrapper of Int_t TKey::GetKeylen()
@trydoc raw"""
    GetKeylen(this::ByConstRef1{TKey})::Int32


""" GetKeylen(this::ByConstRef1{TKey})

# Wrapper of TDirectory * TKey::GetMotherDir()
@trydoc raw"""
    GetMotherDir(this::ByConstRef1{TKey})::CxxPtr1{TDirectory}


""" GetMotherDir(this::ByConstRef1{TKey})

# Wrapper of Int_t TKey::GetNbytes()
@trydoc raw"""
    GetNbytes(this::ByConstRef1{TKey})::Int32


""" GetNbytes(this::ByConstRef1{TKey})

# Wrapper of Int_t TKey::GetObjlen()
@trydoc raw"""
    GetObjlen(this::ByConstRef1{TKey})::Int32


""" GetObjlen(this::ByConstRef1{TKey})

# Wrapper of Long64_t TKey::GetSeekKey()
@trydoc raw"""
    GetSeekKey(this::ByConstRef1{TKey})::Int64


""" GetSeekKey(this::ByConstRef1{TKey})

# Wrapper of Long64_t TKey::GetSeekPdir()
@trydoc raw"""
    GetSeekPdir(this::ByConstRef1{TKey})::Int64


""" GetSeekPdir(this::ByConstRef1{TKey})

# Wrapper of const char * TKey::GetTitle()
@trydoc raw"""
    GetTitle(this::ByConstRef1{TKey})::ByCopy{String}
Returns title (title can contain 32x32 xpm thumbnail/icon).

""" GetTitle(this::ByConstRef1{TKey})

# Wrapper of Int_t TKey::GetVersion()
@trydoc raw"""
    GetVersion(this::ByConstRef1{TKey})::Int32


""" GetVersion(this::ByConstRef1{TKey})

# Wrapper of void TKey::IncrementPidOffset(UShort_t)
@trydoc raw"""
    IncrementPidOffset(this::ByRef1{TKey}, offset::UInt16)::Nothing
Increment fPidOffset by 'offset'.
This offset is used when a key (or basket) is transfered from one file to the other. In this case the [TRef](@ref) and [TObject](@ref) might have stored a pid index (to retrieve TProcessIDs) which refered to their order on the original file, the fPidOffset is to be added to those values to correctly find the [TProcessID](@ref). This fPidOffset needs to be increment if the key/basket is copied and need to be zero for new key/basket.
""" IncrementPidOffset(this::ByRef1{TKey}, offset::UInt16)

# Wrapper of Bool_t TKey::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TKey})::Bool
Check if object referenced by the key is a folder.

""" IsFolder(this::ByConstRef1{TKey})

# Wrapper of void TKey::Keep()
@trydoc raw"""
    Keep(this::ByRef1{TKey})::Nothing
Set the "KEEP" status.
When the KEEP flag is set to 1 the object cannot be purged.
""" Keep(this::ByRef1{TKey})

# Wrapper of void TKey::ls(Bool_t)
@trydoc raw"""
    ls(this::ByConstRef1{TKey}, current::Bool)::Nothing
List Key contents.
Add indicator of whether it is the current item or a backup copy.
""" ls(this::ByConstRef1{TKey}, current::Bool)

# Wrapper of void TKey::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TKey}, option::ByCopy{String})::Nothing
List Key contents.

""" ls(this::ByConstRef1{TKey}, option::ByCopy{String})

# Wrapper of void TKey::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TKey}, option::ByCopy{String})::Nothing
Print key contents.

""" Print(this::ByConstRef1{TKey}, option::ByCopy{String})

# Wrapper of Int_t TKey::Read(TObject *)
@trydoc raw"""
    Read(this::ByRef1{TKey}, obj::ByPtr1{TObject})::Int32
To read an object from the file.
The object associated to this key is read from the file into memory. Before invoking this function, obj has been created via the default constructor.
""" Read(this::ByRef1{TKey}, obj::ByPtr1{TObject})

# Wrapper of void TKey::ReadBuffer(char *&)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})::Nothing
Decode input buffer.
In some situation will add key to gDirectory.
""" ReadBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})

# Wrapper of Bool_t TKey::ReadFile()
@trydoc raw"""
    ReadFile(this::ByRef1{TKey})::Bool
Read the key structure from the file.

""" ReadFile(this::ByRef1{TKey})

# Wrapper of void TKey::ReadKeyBuffer(char *&)
@trydoc raw"""
    ReadKeyBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})::Nothing
Decode input buffer.

""" ReadKeyBuffer(this::ByRef1{TKey}, buffer::ByPtr2{Int8})

# Wrapper of TObject * TKey::ReadObj()
@trydoc raw"""
    ReadObj(this::ByRef1{TKey})::CxxPtr1{TObject}
To read a TObject* from the file.
The object associated to this key is read from the file into memory Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the [TClass](@ref) object for this class. A [TClass](@ref) object contains a full description (i.e. dictionary) of the associated class. In particular the [TClass](@ref) object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.

Use [TKey!ReadObjectAny](@ref) to read any object non-derived from [TObject](@ref)

### Note

A C style cast can only be used in the case where the final class of this object derives from [TObject](@ref) as a first inheritance, otherwise one must use a dynamic_cast.

#### Example1: simplified case

    class MyClass : public TObject, public AnotherClass

(C++ version of the code)

 then on return, one get away with using: 

    MyClass *obj = (MyClass*)key->ReadObj();

(C++ version of the code)

#### Example2: Usual case (recommended unless performance is critical)

    MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());

(C++ version of the code)

 which support also the more complex inheritance like: 

    class MyClass : public AnotherClass, public TObject

(C++ version of the code)

Of course, `dynamic_cast<>` can also be used in the example 1.
""" ReadObj(this::ByRef1{TKey})

# Wrapper of void * TKey::ReadObjectAny(const TClass *)
@trydoc raw"""
    ReadObjectAny(this::ByRef1{TKey}, expectedClass::ByConstPtr1{TClass})::CxxPtr2{Nothing}
To read an object (non deriving from [TObject](@ref)) from the file.
If expectedClass is not null, we checked that that actual class of the object stored is suitable to be stored in a pointer pointing to an object of class 'expectedClass'. We also adjust the value of the returned address so that it is suitable to be cast (C-Style) a pointer pointing to an object of class 'expectedClass'.

So for example if the class Bottom inherits from Top and the object stored is of type Bottom you can safely do: 

    auto TopClass = TClass!GetClass("Top");
    auto ptr = (Top*) key->ReadObjectAny( TopClass );
    if (ptr==0) printError("the object stored in the key is not of the expected type\n");

(C++ version of the code)

 The object associated to this key is read from the file into memory. Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the [TClass](@ref) object for this class. A [TClass](@ref) object contains a full description (i.e. dictionary) of the associated class. In particular the [TClass](@ref) object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.
""" ReadObjectAny(this::ByRef1{TKey}, expectedClass::ByConstPtr1{TClass})

# Wrapper of TObject * TKey::ReadObjWithBuffer(char *)
@trydoc raw"""
    ReadObjWithBuffer(this::ByRef1{TKey}, bufferRead::ByPtr2{Int8})::CxxPtr1{TObject}
To read a TObject* from bufferRead.
This function is identical to [TKey!ReadObj](@ref), but it reads directly from bufferRead instead of reading from a file. The object associated to this key is read from the buffer into memory Using the class identifier we find the [TClass](@ref) object for this class. A [TClass](@ref) object contains a full description (i.e. dictionary) of the associated class. In particular the [TClass](@ref) object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.

### Note

This function is called only internally by [ROOT](@ref) classes. Although being public it is not supposed to be used outside [ROOT](@ref). If used, you must make sure that the bufferRead is large enough to accomodate the object being read.
""" ReadObjWithBuffer(this::ByRef1{TKey}, bufferRead::ByPtr2{Int8})

# Wrapper of void TKey::SetBuffer()
@trydoc raw"""
    SetBuffer(this::ByRef1{TKey})::Nothing


""" SetBuffer(this::ByRef1{TKey})

# Wrapper of void TKey::SetMotherDir(TDirectory *)
@trydoc raw"""
    SetMotherDir(this::ByRef1{TKey}, dir::ByPtr1{TDirectory})::Nothing


""" SetMotherDir(this::ByRef1{TKey}, dir::ByPtr1{TDirectory})

# Wrapper of void TKey::SetParent(const TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TKey}, parent::ByConstPtr1{TObject})::Nothing
Set parent in key buffer.

""" SetParent(this::ByRef1{TKey}, parent::ByConstPtr1{TObject})

# Wrapper of Int_t TKey::Sizeof()
@trydoc raw"""
    Sizeof(this::ByConstRef1{TKey})::Int32
Return the size in bytes of the key header structure.
An explanation about the nbytes (Int_t nbytes) variable used in the function. The size of fSeekKey and fSeekPdir is 8 instead of 4 if version is greater than 1000. 
| **Component**     | **Sizeof** |
|:------------------|:-----------|
| fNbytes           | 4          |
| sizeof(Version_t) | 2          |
| fObjlen           | 4          |
| fDatime           | 4          |
| fKeylen           | 2          |
| fCycle            | 2          |
| fSeekKey          | 4 or 8     |
| fSeekPdir         | 4 or 8     |
| **FIXED TOTAL**   | 26 or 34   |
| fClassName        | 1+ bytes   |
| fName             | 1+ bytes   |
| fTitle            | 1+ bytes   |
| **TOTAL**         | 29+ or 37+ |
""" Sizeof(this::ByConstRef1{TKey})

# Wrapper of Int_t TKey::WriteFile(Int_t, TFile *)
@trydoc raw"""
    WriteFile(this::ByRef1{TKey}, cycle::Int32, f::ByPtr1{TFile})::Int32
Write the encoded object supported by this key.
The function returns the number of bytes committed to the file. If a write error occurs, the number of bytes returned is -1.
""" WriteFile(this::ByRef1{TKey}, cycle::Int32, f::ByPtr1{TFile})

# Wrapper of void TFile::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TFile}, option::ByCopy{String})::Nothing
Close a file.
## Arguments

- **`option`** [in] 
    If option == "R", all TProcessIDs referenced by this file are deleted.
    

Calling [TFile!Close](@ref)("R") might be necessary in case one reads a long list of files having [TRef](@ref), writing some of the referenced objects or [TRef](@ref) to a new file. If the [TRef](@ref) or referenced objects of the file being closed will not be referenced again, it is possible to minimize the size of the [TProcessID](@ref) data structures in memory by forcing a delete of the unused [TProcessID](@ref).
""" Close(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TFile}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TFile}, object::ByRef1{TObject})

# Wrapper of Bool_t TFile::Cp(const char *, Bool_t, UInt_t)
@trydoc raw"""
    Cp(this::ByRef1{TFile}, dst::ByCopy{String}, progressbar::Bool, buffersize::UInt32)::Bool
Allows to copy this file to the dst URL.
Returns kTRUE in case of success, kFALSE otherwise.
""" Cp(this::ByRef1{TFile}, dst::ByCopy{String}, progressbar::Bool, buffersize::UInt32)

# Wrapper of TKey * TFile::CreateKey(TDirectory *, const TObject *, const char *, Int_t)
@trydoc raw"""
    CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, bufsize::Int32)::CxxPtr1{TKey}
Creates key for object and converts data to buffer.

""" CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, bufsize::Int32)

# Wrapper of TKey * TFile::CreateKey(TDirectory *, const void *, const TClass *, const char *, Int_t)
@trydoc raw"""
    CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, bufsize::Int32)::CxxPtr1{TKey}
Creates key for object and converts data to buffer.

""" CreateKey(this::ByRef1{TFile}, mother::ByPtr1{TDirectory}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, bufsize::Int32)

# Wrapper of void TFile::Delete(const char *)
@trydoc raw"""
    Delete(this::ByRef1{TFile}, namecycle::ByCopy{String})::Nothing
Delete object namecycle.
## Arguments

- **`namecycle`** [in] 
    Encodes the name and cycle of the objects to delete
    

Namecycle identifies an object in the top directory of the file namecycle has the format *name;cycle*.

- *name = ** means all objects
- *cycle = ** means all cycles (memory and keys)
- *cycle = ""* or cycle = 9999 ==> apply to a memory object When name=* use T* to delete subdirectories also

Examples: 
| **name/cycle** | **Action**                                                     |
|:---------------|:---------------------------------------------------------------|
| foo            | delete object named foo in memory                              |
| foo;1          | delete cycle 1 of foo on file                                  |
| foo;*          | delete all cycles of foo on disk and also from memory          |
| *;2            | delete all objects on file having the cycle 2                  |
| *;*            | delete all objects from memory and file                        |
| T*;*           | delete all objects from memory and file and all subdirectories |
""" Delete(this::ByRef1{TFile}, namecycle::ByCopy{String})

# Wrapper of void TFile::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TFile}, option::ByCopy{String})::Nothing
Fill Graphics Structure and Paint.
Loop on all objects (memory or file) and all subdirectories.
""" Draw(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::DrawMap(const char *, Option_t *)
@trydoc raw"""
    DrawMap(this::ByRef1{TFile}, keys::ByCopy{String}, option::ByCopy{String})::Nothing
Draw map of objects in this file.
The map drawing is handled by [TFileDrawMap](@ref). Once the map is drawn, turn on the [TCanvas](@ref) option "View->Event Statusbar". Then, when moving the mouse in the canvas, the "Event Status" panels shows the object corresponding to the mouse position.

Example: 

    auto f = new TFile("myfile.root");
    f->DrawMap();

(C++ version of the code)
""" DrawMap(this::ByRef1{TFile}, keys::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TFile::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TFile}, buffer::ByPtr2{Int8})::Nothing
Encode file output buffer.
The file output buffer contains only the FREE data record.
""" FillBuffer(this::ByRef1{TFile}, buffer::ByPtr2{Int8})

# Wrapper of void TFile::Flush()
@trydoc raw"""
    Flush(this::ByRef1{TFile})::Nothing
Synchronize a file's in-memory and on-disk states.

""" Flush(this::ByRef1{TFile})

# Wrapper of Long64_t TFile::GetArchiveOffset()
@trydoc raw"""
    GetArchiveOffset(this::ByConstRef1{TFile})::Int64


""" GetArchiveOffset(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetBestBuffer()
@trydoc raw"""
    GetBestBuffer(this::ByConstRef1{TFile})::Int32
Return the best buffer size of objects on this file.
The best buffer size is estimated based on the current mean value and standard deviation of all objects written so far to this file. Returns mean value + one standard deviation.
""" GetBestBuffer(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetBytesRead()
@trydoc raw"""
    GetBytesRead(this::ByConstRef1{TFile})::Int64


""" GetBytesRead(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetBytesReadExtra()
@trydoc raw"""
    GetBytesReadExtra(this::ByConstRef1{TFile})::Int64


""" GetBytesReadExtra(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetBytesToPrefetch()
@trydoc raw"""
    GetBytesToPrefetch(this::ByConstRef1{TFile})::Int32
Max number of bytes to prefetch.
By default this is 75% of the read cache size. But specific [TFile](@ref) implementations may need to change it
""" GetBytesToPrefetch(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetBytesWritten()
@trydoc raw"""
    GetBytesWritten(this::ByConstRef1{TFile})::Int64
Return the total number of bytes written so far to the file.

""" GetBytesWritten(this::ByConstRef1{TFile})

# Wrapper of TArrayC * TFile::GetClassIndex()
@trydoc raw"""
    GetClassIndex(this::ByConstRef1{TFile})::CxxPtr1{TArrayC}


""" GetClassIndex(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetCompressionAlgorithm()
@trydoc raw"""
    GetCompressionAlgorithm(this::ByConstRef1{TFile})::Int32


""" GetCompressionAlgorithm(this::ByConstRef1{TFile})

# Wrapper of Float_t TFile::GetCompressionFactor()
@trydoc raw"""
    GetCompressionFactor(this::ByRef1{TFile})::Float32
Return the file compression factor.
Add total number of compressed/uncompressed bytes for each key. Returns the ratio of the two.
""" GetCompressionFactor(this::ByRef1{TFile})

# Wrapper of Int_t TFile::GetCompressionLevel()
@trydoc raw"""
    GetCompressionLevel(this::ByConstRef1{TFile})::Int32


""" GetCompressionLevel(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetCompressionSettings()
@trydoc raw"""
    GetCompressionSettings(this::ByConstRef1{TFile})::Int32


""" GetCompressionSettings(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetEND()
@trydoc raw"""
    GetEND(this::ByConstRef1{TFile})::Int64


""" GetEND(this::ByConstRef1{TFile})

# Wrapper of const TUrl * TFile::GetEndpointUrl()
@trydoc raw"""
    GetEndpointUrl(this::ByConstRef1{TFile})::ConstCxxPtr1{TUrl}


""" GetEndpointUrl(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetErrno()
@trydoc raw"""
    GetErrno(this::ByConstRef1{TFile})::Int32
Method returning errno.

""" GetErrno(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetFd()
@trydoc raw"""
    GetFd(this::ByConstRef1{TFile})::Int32


""" GetFd(this::ByConstRef1{TFile})

# Wrapper of TList * TFile::GetListOfFree()
@trydoc raw"""
    GetListOfFree(this::ByConstRef1{TFile})::CxxPtr1{TList}


""" GetListOfFree(this::ByConstRef1{TFile})

# Wrapper of TObjArray * TFile::GetListOfProcessIDs()
@trydoc raw"""
    GetListOfProcessIDs(this::ByConstRef1{TFile})::CxxPtr1{TObjArray}


""" GetListOfProcessIDs(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetNbytesFree()
@trydoc raw"""
    GetNbytesFree(this::ByConstRef1{TFile})::Int32


""" GetNbytesFree(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetNbytesInfo()
@trydoc raw"""
    GetNbytesInfo(this::ByConstRef1{TFile})::Int32


""" GetNbytesInfo(this::ByConstRef1{TFile})

# Wrapper of TString TFile::GetNewUrl()
@trydoc raw"""
    GetNewUrl(this::ByRef1{TFile})::ByCopy{TString}


""" GetNewUrl(this::ByRef1{TFile})

# Wrapper of Int_t TFile::GetNfree()
@trydoc raw"""
    GetNfree(this::ByConstRef1{TFile})::Int32


""" GetNfree(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetNProcessIDs()
@trydoc raw"""
    GetNProcessIDs(this::ByConstRef1{TFile})::Int32


""" GetNProcessIDs(this::ByConstRef1{TFile})

# Wrapper of Option_t * TFile::GetOption()
@trydoc raw"""
    GetOption(this::ByConstRef1{TFile})::ByCopy{String}


""" GetOption(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetReadCalls()
@trydoc raw"""
    GetReadCalls(this::ByConstRef1{TFile})::Int32


""" GetReadCalls(this::ByConstRef1{TFile})

# Wrapper of Int_t TFile::GetRecordHeader(char *, Long64_t, Int_t, Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetRecordHeader(this::ByRef1{TFile}, buf::ByPtr2{Int8}, first::Int64, maxbytes::Int32, nbytes::ByRef2{Int32}, objlen::ByRef2{Int32}, keylen::ByRef2{Int32})::Int32
Read the logical record header starting at a certain postion.
## Arguments

- **`buf`** [in] 
    pointer to buffer 
    
- **`first`** [in] 
    read offset 
    
- **`maxbytes`** [in] 
    Bytes which are read into buf. 
    
- **`nbytes`** [out] 
    Number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first 
    
- **`objlen`** [out] 
    Uncompressed object size 
    
- **`keylen`** [out] 
    Length of logical record header
    

The function reads nread bytes where nread is the minimum of maxbytes and the number of bytes before the theend of file. The function returns nread. Note that the arguments objlen and keylen are returned only if maxbytes >=16
""" GetRecordHeader(this::ByRef1{TFile}, buf::ByPtr2{Int8}, first::Int64, maxbytes::Int32, nbytes::ByRef2{Int32}, objlen::ByRef2{Int32}, keylen::ByRef2{Int32})

# Wrapper of Long64_t TFile::GetRelOffset()
@trydoc raw"""
    GetRelOffset(this::ByConstRef1{TFile})::Int64


""" GetRelOffset(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetSeekFree()
@trydoc raw"""
    GetSeekFree(this::ByConstRef1{TFile})::Int64


""" GetSeekFree(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetSeekInfo()
@trydoc raw"""
    GetSeekInfo(this::ByConstRef1{TFile})::Int64


""" GetSeekInfo(this::ByConstRef1{TFile})

# Wrapper of Long64_t TFile::GetSize()
@trydoc raw"""
    GetSize(this::ByConstRef1{TFile})::Int64
Returns the current file size.
Returns -1 in case the file could not be stat'ed.
""" GetSize(this::ByConstRef1{TFile})

# Wrapper of const TList * TFile::GetStreamerInfoCache()
@trydoc raw"""
    GetStreamerInfoCache(this::ByRef1{TFile})::ConstCxxPtr1{TList}
Returns the cached list of StreamerInfos used in this file.

""" GetStreamerInfoCache(this::ByRef1{TFile})

# Wrapper of TList * TFile::GetStreamerInfoList()
@trydoc raw"""
    GetStreamerInfoList(this::ByRef1{TFile})::CxxPtr1{TList}
Read the list of [TStreamerInfo](@ref) objects written to this file.
The function returns a [TList](@ref). It is the user's responsibility to delete the list created by this function.

Note the list, in addition to [TStreamerInfo](@ref) object, contains sometimes a [TList](@ref) named 'listOfRules' and containing the schema evolution rules related to the file's content.

Using the list, one can access additional information, e.g.: 

    TFile f("myfile.root");
    auto list = f.GetStreamerInfoList();
    auto info = dynamic_cast<TStreamerInfo*>(list->FindObject("MyClass"));
    if (info) auto classversionid = info->GetClassVersion();
    delete list;

(C++ version of the code)
""" GetStreamerInfoList(this::ByRef1{TFile})

# Wrapper of Int_t TFile::GetVersion()
@trydoc raw"""
    GetVersion(this::ByConstRef1{TFile})::Int32


""" GetVersion(this::ByConstRef1{TFile})

# Wrapper of void TFile::IncrementProcessIDs()
@trydoc raw"""
    IncrementProcessIDs(this::ByRef1{TFile})::Nothing


""" IncrementProcessIDs(this::ByRef1{TFile})

# Wrapper of Bool_t TFile::IsArchive()
@trydoc raw"""
    IsArchive(this::ByConstRef1{TFile})::Bool


""" IsArchive(this::ByConstRef1{TFile})

# Wrapper of Bool_t TFile::IsBinary()
@trydoc raw"""
    IsBinary(this::ByConstRef1{TFile})::Bool


""" IsBinary(this::ByConstRef1{TFile})

# Wrapper of Bool_t TFile::IsOpen()
@trydoc raw"""
    IsOpen(this::ByConstRef1{TFile})::Bool
Returns kTRUE in case file is open and kFALSE if file is not open.

""" IsOpen(this::ByConstRef1{TFile})

# Wrapper of Bool_t TFile::IsRaw()
@trydoc raw"""
    IsRaw(this::ByConstRef1{TFile})::Bool


""" IsRaw(this::ByConstRef1{TFile})

# Wrapper of void TFile::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TFile}, option::ByCopy{String})::Nothing
List file contents.
Indentation is used to identify the file tree. Subdirectories are listed first, then objects in memory, then objects on the file.
""" ls(this::ByConstRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::MakeFree(Long64_t, Long64_t)
@trydoc raw"""
    MakeFree(this::ByRef1{TFile}, first::Int64, last::Int64)::Nothing
Mark unused bytes on the file.
The list of free segments is in the fFree linked list. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Number of bytes occupied by the record).
""" MakeFree(this::ByRef1{TFile}, first::Int64, last::Int64)

# Wrapper of void TFile::MakeProject(const char *, const char *, Option_t *)
@trydoc raw"""
    MakeProject(this::ByRef1{TFile}, dirname::ByCopy{String}, classes::ByCopy{String}, option::ByCopy{String})::Nothing
Generate source code necessary to access the objects stored in the file.
Generate code in directory dirname for all classes specified in argument classes If classes = "*" (default and currently the only supported value), the function generates an include file for each class in the StreamerInfo list for which a [TClass](@ref) object does not exist.

The code generated includes:

- *dirnameProjectHeaders.h*, which contains one `#include` statement per generated header file
- *dirnameProjectSource.cxx*,which contains all the constructors and destructors implementation. and one header per class that is not nested inside another class. The header file name is the fully qualified name of the class after all the special characters "<>,:" are replaced by underscored. For example for std!pair<edm!Vertex,int> the file name is pair_edm__Vertex_int_.h

In the generated classes, map, multimap when the first template parameter is a class are replaced by a vector of pair. set and multiset when the tempalte parameter is a class are replaced by a vector. This is required since we do not have the code needed to order and/or compare the object of the classes. This is a quick explanation of the options available: 
| **Option**    | **Details**                                                                                                                                                                                                                          |
|:--------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.                                                                                                                  |
| recreate      | If dirname does not exist, it is created (like in "new"). If dirname already exist, all existing files in dirname are deleted before creating the new files.                                                                         |
| update        | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as "new".                                             |
| genreflex     | Use genreflex rather than rootcint to generate the dictionary.                                                                                                                                                                       |
| par           | Create a PAR file with the minimal set of code needed to read the content of the [ROOT](@ref) file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). |

If, in addition to one of the 3 above options, the option "+" is specified, the function will generate:

- a script called MAKEP to build the shared lib
- a dirnameLinkDef.h file
- rootcint will be run to generate a dirnameProjectDict.cxx file
- dirnameProjectDict.cxx will be compiled with the current options in compiledata.h
- a shared lib dirname.so will be created. If the option "++" is specified, the generated shared lib is dynamically linked with the current executable themodule. If the option "+" and "nocompile" are specified, the utility files are generated as in the option "+" but they are not executed. Example: file.MakeProject("demo","*","recreate++");
- creates a new directory demo unless it already exist
- clear the previous directory content
- generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.
- creates the build script MAKEP
- creates a LinkDef.h file
- runs rootcint generating demoProjectDict.cxx
- compiles demoProjectDict.cxx into demoProjectDict.o
- generates a shared lib demo.so
- dynamically links the shared lib demo.so to the executable If only the option "+" had been specified, one can still link the shared lib to the current executable themodule with: 
```
gSystem->load("demo/demo.so");
```  The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: 
```
classes = "Ali*" generate code only for classes starting with Ali
classes = "myClass" generate code for class MyClass only.
```
""" MakeProject(this::ByRef1{TFile}, dirname::ByCopy{String}, classes::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TFile::Map()
@trydoc raw"""
    Map(this::ByRef1{TFile})::Nothing


""" Map(this::ByRef1{TFile})

# Wrapper of void TFile::Map(Option_t *)
@trydoc raw"""
    Map(this::ByRef1{TFile}, opt::ByCopy{String})::Nothing
List the contents of a file sequentially.
For each logical record found, it prints: 
```
Date/Time  Record_Adress Logical_Record_Length  ClassName  CompressionFactor
```  Example of output 
```
20010404/150437  At:64        N=150       TFile
20010404/150440  At:214       N=28326     TBasket        CX =  1.13
20010404/150440  At:28540     N=29616     TBasket        CX =  1.08
20010404/150440  At:58156     N=29640     TBasket        CX =  1.08
20010404/150440  At:87796     N=29076     TBasket        CX =  1.10
20010404/150440  At:116872    N=10151     TBasket        CX =  3.15
20010404/150441  At:127023    N=28341     TBasket        CX =  1.13
20010404/150441  At:155364    N=29594     TBasket        CX =  1.08
20010404/150441  At:184958    N=29616     TBasket        CX =  1.08
20010404/150441  At:214574    N=29075     TBasket        CX =  1.10
20010404/150441  At:243649    N=9583      TBasket        CX =  3.34
20010404/150442  At:253232    N=28324     TBasket        CX =  1.13
20010404/150442  At:281556    N=29641     TBasket        CX =  1.08
20010404/150442  At:311197    N=29633     TBasket        CX =  1.08
20010404/150442  At:340830    N=29091     TBasket        CX =  1.10
20010404/150442  At:369921    N=10341     TBasket        CX =  3.09
20010404/150442  At:380262    N=509       TH1F           CX =  1.93
20010404/150442  At:380771    N=1769      TH2F           CX =  4.32
20010404/150442  At:382540    N=1849      TProfile       CX =  1.65
20010404/150442  At:384389    N=18434     TNtuple        CX =  4.51
20010404/150442  At:402823    N=307       KeysList
20010404/150443  At:403130    N=4548      StreamerInfo   CX =  3.65
20010404/150443  At:407678    N=86        FreeSegments
20010404/150443  At:407764    N=1         END
```  If the parameter opt contains "forComp", the Date/Time is omitted and the decompressed size is also printed.

Record_Adress Logical_Record_Length Key_Length Object_Record_Length ClassName CompressionFactor

If the parameter opt contains "extended", the name and title of the keys are added: 20200820/155031 At:100 N=180 [TFile](@ref) name: hsimple.root title: Demo [ROOT](@ref) file with histograms 220200820/155032 At:280 N=28880 [TBasket](@ref) CX = 1.11 name: random title: ntuple 220200820/155032 At:29160 N=29761 [TBasket](@ref) CX = 1.08 name: px title: ntuple 220200820/155032 At:58921 N=29725 [TBasket](@ref) CX = 1.08 name: py title: ntuple 220200820/155032 At:88646 N=29209 [TBasket](@ref) CX = 1.10 name: pz title: ntuple 220200820/155032 At:117855 N=10197 [TBasket](@ref) CX = 3.14 name: i title: ntuple ... 20200820/155032 At:405110 N=808 [TNtuple](@ref) CX = 3.53 name: ntuple title: Demo ntuple 20200820/155706 At:405918 N=307 KeysList name: hsimple.root title: Demo [ROOT](@ref) file with histograms 20200820/155032 At:406225 N=8556 StreamerInfo CX = 3.42 name: StreamerInfo title: Doubly linked list 20200820/155708 At:414781 N=86 FreeSegments name: hsimple.root title: Demo [ROOT](@ref) file with histograms 20200820/155708 At:414867 N=1 END

Note: The combined size of the classname, name and title is truncated to 476 characters (a little more for regular keys of small files)
""" Map(this::ByRef1{TFile}, opt::ByCopy{String})

# Wrapper of Bool_t TFile::Matches(const char *)
@trydoc raw"""
    Matches(this::ByRef1{TFile}, name::ByCopy{String})::Bool
Return kTRUE if 'url' matches the coordinates of this file.
The check is implementation dependent and may need to be overload by each [TFile](@ref) implementation relying on this check. The default implementation checks the file name only.
""" Matches(this::ByRef1{TFile}, name::ByCopy{String})

# Wrapper of Bool_t TFile::MustFlush()
@trydoc raw"""
    MustFlush(this::ByConstRef1{TFile})::Bool


""" MustFlush(this::ByConstRef1{TFile})

# Wrapper of void TFile::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TFile}, option::ByCopy{String})::Nothing
Paint all objects in the file.

""" Paint(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TFile}, option::ByCopy{String})::Nothing
Print all objects in the file.

""" Print(this::ByConstRef1{TFile}, option::ByCopy{String})

# Wrapper of Bool_t TFile::ReadBuffer(char *, Int_t)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, len::Int32)::Bool
Read a buffer from the file.
This is the basic low level read operation. Returns kTRUE in case of failure.
""" ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, len::Int32)

# Wrapper of Bool_t TFile::ReadBuffer(char *, Long64_t, Int_t)
@trydoc raw"""
    ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::Int64, len::Int32)::Bool
Read a buffer from the file at the offset 'pos' in the file.
Returns kTRUE in case of failure. Compared to [ReadBuffer(char*, Int_t)](@ref), this routine does *not* change the cursor on the physical file representation (fD) if the data is in this [TFile](@ref)'s cache.
""" ReadBuffer(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::Int64, len::Int32)

# Wrapper of Bool_t TFile::ReadBufferAsync(Long64_t, Int_t)
@trydoc raw"""
    ReadBufferAsync(this::ByRef1{TFile}, offs::Int64, len::Int32)::Bool


""" ReadBufferAsync(this::ByRef1{TFile}, offs::Int64, len::Int32)

# Wrapper of Bool_t TFile::ReadBuffers(char *, Long64_t *, Int_t *, Int_t)
@trydoc raw"""
    ReadBuffers(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::ByPtr2{Int64}, len::ByPtr2{Int32}, nbuf::Int32)::Bool
Read the nbuf blocks described in arrays pos and len.
The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile!ReafBuffer. This function is overloaded by [TNetFile](@ref), [TWebFile](@ref), etc. Returns kTRUE in case of failure.
""" ReadBuffers(this::ByRef1{TFile}, buf::ByPtr2{Int8}, pos::ByPtr2{Int64}, len::ByPtr2{Int32}, nbuf::Int32)

# Wrapper of void TFile::ReadFree()
@trydoc raw"""
    ReadFree(this::ByRef1{TFile})::Nothing
Read the FREE linked list.
Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record.
""" ReadFree(this::ByRef1{TFile})

# Wrapper of void TFile::ReadStreamerInfo()
@trydoc raw"""
    ReadStreamerInfo(this::ByRef1{TFile})::Nothing
Read the list of StreamerInfo from this file.
The key with name holding the list of [TStreamerInfo](@ref) objects is read. The corresponding [TClass](@ref) objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see [TFile!SetReadStreamerInfo](@ref))
""" ReadStreamerInfo(this::ByRef1{TFile})

# Wrapper of Int_t TFile::Recover()
@trydoc raw"""
    Recover(this::ByRef1{TFile})::Int32
Attempt to recover file if not correctly closed.
The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:

    TFile f("myfile.root");
    if (f.IsZombie()) {<actions to take if file is unusable>}

(C++ version of the code)

If the file has been recovered, the bit kRecovered is set in the [TFile](@ref) object in memory. You can test if the file has been recovered with 
```
if (f.TestBit(TFile!kRecovered)) {... the file has been recovered}
```  When writing TTrees to a file, it is important to save the Tree header at regular intervals (see [TTree!AutoSave](@ref)). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting 
```
TFile.Recover 0
```  in the *system.rootrc* file.
""" Recover(this::ByRef1{TFile})

# Wrapper of Int_t TFile::ReOpen(Option_t *)
@trydoc raw"""
    ReOpen(this::ByRef1{TFile}, mode::ByCopy{String})::Int32
Reopen a file with a different access mode.
For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either "READ" or "UPDATE". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is changed to this file.
""" ReOpen(this::ByRef1{TFile}, mode::ByCopy{String})

# Wrapper of void TFile::ResetErrno()
@trydoc raw"""
    ResetErrno(this::ByConstRef1{TFile})::Nothing
Method resetting the errno.

""" ResetErrno(this::ByConstRef1{TFile})

# Wrapper of void TFile::SetCompressionAlgorithm(Int_t)
@trydoc raw"""
    SetCompressionAlgorithm(this::ByRef1{TFile}, algorithm::Int32)::Nothing
See comments for function SetCompressionSettings.

""" SetCompressionAlgorithm(this::ByRef1{TFile}, algorithm::Int32)

# Wrapper of void TFile::SetCompressionLevel(Int_t)
@trydoc raw"""
    SetCompressionLevel(this::ByRef1{TFile}, level::Int32)::Nothing
See comments for function SetCompressionSettings.

""" SetCompressionLevel(this::ByRef1{TFile}, level::Int32)

# Wrapper of void TFile::SetCompressionSettings(Int_t)
@trydoc raw"""
    SetCompressionSettings(this::ByRef1{TFile}, settings::Int32)::Nothing
Used to specify the compression level and algorithm.
See the [TFile](@ref) constructor for the details.
""" SetCompressionSettings(this::ByRef1{TFile}, settings::Int32)

# Wrapper of void TFile::SetEND(Long64_t)
@trydoc raw"""
    SetEND(this::ByRef1{TFile}, last::Int64)::Nothing


""" SetEND(this::ByRef1{TFile}, last::Int64)

# Wrapper of void TFile::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TFile}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TFile}, option::ByCopy{String})

# Wrapper of void TFile::SetReadCalls(Int_t)
@trydoc raw"""
    SetReadCalls(this::ByRef1{TFile}, readcalls::Int32)::Nothing


""" SetReadCalls(this::ByRef1{TFile}, readcalls::Int32)

# Wrapper of void TFile::ShowStreamerInfo()
@trydoc raw"""
    ShowStreamerInfo(this::ByRef1{TFile})::Nothing
Show the StreamerInfo of all classes written to this file.

""" ShowStreamerInfo(this::ByRef1{TFile})

# Wrapper of Int_t TFile::Sizeof()
@trydoc raw"""
    Sizeof(this::ByConstRef1{TFile})::Int32
Return the size in bytes of the file header.

""" Sizeof(this::ByConstRef1{TFile})

# Wrapper of void TFile::SumBuffer(Int_t)
@trydoc raw"""
    SumBuffer(this::ByRef1{TFile}, bufsize::Int32)::Nothing
Increment statistics for buffer sizes of objects in this file.

""" SumBuffer(this::ByRef1{TFile}, bufsize::Int32)

# Wrapper of Int_t TFile::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TFile}, name::ByCopy{String}, opt::Int32, bufsiz::Int32)::Int32
Write memory objects to this file.
Loop on all objects in memory (including subdirectories). A new key is created in the KEYS linked list for each object. The list of keys is then saved on the file (via WriteKeys) as a single data record. For values of opt see [TObject!Write()](@ref). The directory header info is rewritten on the directory header record. The linked list of FREE segments is written. The file header is written (bytes 1->fBEGIN).
""" Write(this::ByRef1{TFile}, name::ByCopy{String}, opt::Int32, bufsiz::Int32)

# Wrapper of Bool_t TFile::WriteBuffer(const char *, Int_t)
@trydoc raw"""
    WriteBuffer(this::ByRef1{TFile}, buf::ByCopy{String}, len::Int32)::Bool
Write a buffer to the file.
This is the basic low level write operation. Returns kTRUE in case of failure.
""" WriteBuffer(this::ByRef1{TFile}, buf::ByCopy{String}, len::Int32)

# Wrapper of void TFile::WriteFree()
@trydoc raw"""
    WriteFree(this::ByRef1{TFile})::Nothing
Write FREE linked list on the file.
The linked list of FREE segments (fFree) is written as a single data record.
""" WriteFree(this::ByRef1{TFile})

# Wrapper of void TFile::WriteHeader()
@trydoc raw"""
    WriteHeader(this::ByRef1{TFile})::Nothing
Write File Header.

""" WriteHeader(this::ByRef1{TFile})

# Wrapper of void TFile::WriteStreamerInfo()
@trydoc raw"""
    WriteStreamerInfo(this::ByRef1{TFile})::Nothing
Write the list of [TStreamerInfo](@ref) as a single object in this file The class Streamer description for all classes written to this file is saved.
See class [TStreamerInfo](@ref).
""" WriteStreamerInfo(this::ByRef1{TFile})

# Wrapper of TFileOpenHandle * TFile::AsyncOpen(const char *, Option_t *, const char *, Int_t, Int_t)
@trydoc raw"""
    TFile!AsyncOpen(this::ByRef1{TFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)::CxxPtr1{TFileOpenHandle}
Submit an asynchronous open request.
See TFile!Open(const char *, ...) for an explanation of the arguments. A handler is returned which is to be passed to [TFile!Open(TFileOpenHandle *)](@ref) to get the real [TFile](@ref) instance once the file is open. This call never blocks and it is provided to allow parallel submission of file opening operations expected to take a long time. [TFile!Open(TFileOpenHandle *)](@ref) may block if the file is not yet ready. The sequence 
```
TFile!Open(TFile!AsyncOpen(const char *, ...))
```  is equivalent to 
```
TFile!Open(const char *, ...)
```  To be effective, the underlying [TFile](@ref) implementation must be able to support asynchronous open functionality. Currently, only [TNetXNGFile](@ref) supports it. If the functionality is not implemented, this call acts transparently by returning an handle with the arguments for the standard synchronous open run by [TFile!Open(TFileOpenHandle *)](@ref). The retuned handle will be adopted by [TFile](@ref) after opening completion in [TFile!Open(TFileOpenHandle *)](@ref); if opening is not finalized the handle must be deleted by the caller.
""" TFile!AsyncOpen(this::ByRef1{TFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)

# Wrapper of Bool_t TFile::Cp(const char *, const char *, Bool_t, UInt_t)
@trydoc raw"""
    TFile!Cp(this::ByRef1{TFile}, src::ByCopy{String}, dst::ByCopy{String}, progressbar::Bool, buffersize::UInt32)::Bool
Allows to copy file from src to dst URL.
Returns kTRUE in case of success, kFALSE otherwise.
""" TFile!Cp(this::ByRef1{TFile}, src::ByCopy{String}, dst::ByCopy{String}, progressbar::Bool, buffersize::UInt32)

# Wrapper of TFile *& TFile::CurrentFile()
@trydoc raw"""
    TFile!CurrentFile(this::ByRef1{TFile})::CxxPtr1{TFile}
Return the current [ROOT](@ref) file if any.
Note that if 'cd' has been called on a [TDirectory](@ref) that does not belong to a file, gFile will be unchanged and still points to the file of the previous current directory that was a file.
""" TFile!CurrentFile(this::ByRef1{TFile})

# Wrapper of const char * TFile::GetCacheFileDir()
@trydoc raw"""
    TFile!GetCacheFileDir(this::ByRef1{TFile})::ByCopy{String}
Get the directory where to locally stage/cache remote files.

""" TFile!GetCacheFileDir(this::ByRef1{TFile})

# Wrapper of const TUrl * TFile::GetEndpointUrl(const char *)
@trydoc raw"""
    TFile!GetEndpointUrl(this::ByRef1{TFile}, name::ByCopy{String})::ConstCxxPtr1{TUrl}
Get final URL for file being opened asynchronously.
Returns 0 is the information is not yet available.
""" TFile!GetEndpointUrl(this::ByRef1{TFile}, name::ByCopy{String})

# Wrapper of Long64_t TFile::GetFileBytesRead()
@trydoc raw"""
    TFile!GetFileBytesRead(this::ByRef1{TFile})::Int64
Static function returning the total number of bytes read from all files.

""" TFile!GetFileBytesRead(this::ByRef1{TFile})

# Wrapper of Long64_t TFile::GetFileBytesWritten()
@trydoc raw"""
    TFile!GetFileBytesWritten(this::ByRef1{TFile})::Int64
Static function returning the total number of bytes written to all files.
Does not take into account what might still be in the write caches.
""" TFile!GetFileBytesWritten(this::ByRef1{TFile})

# Wrapper of Long64_t TFile::GetFileCounter()
@trydoc raw"""
    TFile!GetFileCounter(this::ByRef1{TFile})::Int64


""" TFile!GetFileCounter(this::ByRef1{TFile})

# Wrapper of Int_t TFile::GetFileReadCalls()
@trydoc raw"""
    TFile!GetFileReadCalls(this::ByRef1{TFile})::Int32
Static function returning the total number of read calls from all files.

""" TFile!GetFileReadCalls(this::ByRef1{TFile})

# Wrapper of Bool_t TFile::GetOnlyStaged()
@trydoc raw"""
    TFile!GetOnlyStaged(this::ByRef1{TFile})::Bool
Returns staged only flag.

""" TFile!GetOnlyStaged(this::ByRef1{TFile})

# Wrapper of UInt_t TFile::GetOpenTimeout()
@trydoc raw"""
    TFile!GetOpenTimeout(this::ByRef1{TFile})::UInt32
Returns open timeout (in ms).

""" TFile!GetOpenTimeout(this::ByRef1{TFile})

# Wrapper of Int_t TFile::GetReadaheadSize()
@trydoc raw"""
    TFile!GetReadaheadSize(this::ByRef1{TFile})::Int32
Static function returning the readahead buffer size.

""" TFile!GetReadaheadSize(this::ByRef1{TFile})

# Wrapper of Bool_t TFile::GetReadStreamerInfo()
@trydoc raw"""
    TFile!GetReadStreamerInfo(this::ByRef1{TFile})::Bool
If the streamerinfos are to be read at file opening.
See [TFile!SetReadStreamerInfo](@ref) for more documentation.
""" TFile!GetReadStreamerInfo(this::ByRef1{TFile})

# Wrapper of void TFile::IncrementFileCounter()
@trydoc raw"""
    TFile!IncrementFileCounter(this::ByRef1{TFile})::Nothing


""" TFile!IncrementFileCounter(this::ByRef1{TFile})

# Wrapper of TFile * TFile::Open(const char *, Option_t *, const char *, Int_t, Int_t)
@trydoc raw"""
    TFile!Open(this::ByRef1{TFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)::CxxPtr1{TFile}
Create / open a file.
The type of the file can be either a [TFile](@ref), [TNetFile](@ref), [TWebFile](@ref) or any [TFile](@ref) derived class for which an plugin library handler has been registered with the plugin manager (for the plugin manager see the [TPluginManager](@ref) class). The returned type of [TFile](@ref) depends on the file name specified by 'url'. If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried sequentially in the specified order until a successful open. If the file starts with "root:", "roots:" or "rootk:" a [TNetFile](@ref) object will be returned, with "http:" a [TWebFile](@ref), with "file:" a local_ [TFile](@ref), etc. (see the list of [TFile](@ref) plugin handlers in $ROOTSYS/etc/system.rootrc for regular expressions that will be checked) and as last a local_ file will be tried. Before opening a file via [TNetFile](@ref) a check is made to see if the URL specifies a local_ file. If that is the case the file will be opened via a normal [TFile](@ref). To force the opening of a local_ file via a [TNetFile](@ref) use either [TNetFile](@ref) directly or specify as host "localhost". The netopt argument is only used by [TNetFile](@ref). For the meaning of the options and other arguments see the constructors of the individual file classes. In case of error, it returns a nullptr.

For [TFile](@ref) implementations supporting asynchronous file open, see TFile!AsyncOpen(...), it is possible to request a timeout with the option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and it will be internally checked with granularity of one millisec. For remote files there is the option: **CACHEREAD** opens an existing file for reading through the file cache. The file will be downloaded to the cache and opened from there. If the download fails, it will be opened remotely. The file will be downloaded to the directory specified by [SetCacheFileDir()](@ref).

*The caller is responsible for deleting the pointer.* In READ mode, a nullptr is returned if the file does not exist or cannot be opened. In CREATE mode, a nullptr is returned if the file already exists or cannot be created. In RECREATE mode, a nullptr is returned if the file can not be created. In UPDATE mode, a nullptr is returned if the file cannot be created or opened.
""" TFile!Open(this::ByRef1{TFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)

# Wrapper of TFile * TFile::Open(TFileOpenHandle *)
@trydoc raw"""
    TFile!Open(this::ByRef1{TFile}, handle::ByPtr1{TFileOpenHandle})::CxxPtr1{TFile}
Waits for the completion of an asynchronous open request.
Returns the pointer to the associated [TFile](@ref), transferring ownership of the handle to the [TFile](@ref) instance.
""" TFile!Open(this::ByRef1{TFile}, handle::ByPtr1{TFileOpenHandle})

# Wrapper of void TFile::SetFileBytesRead(Long64_t)
@trydoc raw"""
    TFile!SetFileBytesRead(this::ByRef1{TFile}, bytes::Int64)::Nothing


""" TFile!SetFileBytesRead(this::ByRef1{TFile}, bytes::Int64)

# Wrapper of void TFile::SetFileBytesWritten(Long64_t)
@trydoc raw"""
    TFile!SetFileBytesWritten(this::ByRef1{TFile}, bytes::Int64)::Nothing


""" TFile!SetFileBytesWritten(this::ByRef1{TFile}, bytes::Int64)

# Wrapper of void TFile::SetFileReadCalls(Int_t)
@trydoc raw"""
    TFile!SetFileReadCalls(this::ByRef1{TFile}, readcalls::Int32)::Nothing


""" TFile!SetFileReadCalls(this::ByRef1{TFile}, readcalls::Int32)

# Wrapper of Bool_t TFile::SetOnlyStaged(Bool_t)
@trydoc raw"""
    TFile!SetOnlyStaged(this::ByRef1{TFile}, onlystaged::Bool)::Bool
Sets only staged flag.
Returns previous value of flag. When true we check before opening the file if it is staged, if not, the open fails.
""" TFile!SetOnlyStaged(this::ByRef1{TFile}, onlystaged::Bool)

# Wrapper of UInt_t TFile::SetOpenTimeout(UInt_t)
@trydoc raw"""
    TFile!SetOpenTimeout(this::ByRef1{TFile}, timeout::UInt32)::UInt32
Sets open timeout time (in ms). Returns previous timeout value.

""" TFile!SetOpenTimeout(this::ByRef1{TFile}, timeout::UInt32)

# Wrapper of void TFile::SetReadaheadSize(Int_t)
@trydoc raw"""
    TFile!SetReadaheadSize(this::ByRef1{TFile}, bufsize::Int32)::Nothing


""" TFile!SetReadaheadSize(this::ByRef1{TFile}, bufsize::Int32)

# Wrapper of void TFile::SetReadStreamerInfo(Bool_t)
@trydoc raw"""
    TFile!SetReadStreamerInfo(this::ByRef1{TFile}, readinfo::Bool)::Nothing
Specify if the streamerinfos must be read at file opening.
If fgReadInfo is true (default) [TFile!ReadStreamerInfo](@ref) is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStreamerInfo();
""" TFile!SetReadStreamerInfo(this::ByRef1{TFile}, readinfo::Bool)

# Wrapper of Bool_t TFile::ShrinkCacheFileDir(Long64_t, Long_t)
@trydoc raw"""
    TFile!ShrinkCacheFileDir(this::ByRef1{TFile}, shrinkSize::Int64, cleanupInteval::Int64)::Bool
Try to shrink the cache to the desired size.
With the clenupinterval you can specify the minimum amount of time after the previous cleanup before the cleanup operation is repeated in the cache directory
""" TFile!ShrinkCacheFileDir(this::ByRef1{TFile}, shrinkSize::Int64, cleanupInteval::Int64)

# Wrapper of void TROOT::AddClass(TClass *)
@trydoc raw"""
    AddClass(this::ByRef1{TROOT}, cl::ByPtr1{TClass})::Nothing
Add a class to the list and map of classes.
This routine is deprecated, use [TClass!AddClass](@ref) directly.
""" AddClass(this::ByRef1{TROOT}, cl::ByPtr1{TClass})

# Wrapper of void TROOT::Append(TObject *, Bool_t)
@trydoc raw"""
    Append(this::ByRef1{TROOT}, obj::ByPtr1{TObject}, replace::Bool)::Nothing
Append object to this directory.
If replace is true: remove any existing objects with the same same (if the name is not "")
""" Append(this::ByRef1{TROOT}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of void TROOT::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TROOT}, b::ByPtr1{TBrowser})::Nothing
Add browsable objects to [TBrowser](@ref).

""" Browse(this::ByRef1{TROOT}, b::ByPtr1{TBrowser})

# Wrapper of Bool_t TROOT::ClassSaved(TClass *)
@trydoc raw"""
    ClassSaved(this::ByRef1{TROOT}, cl::ByPtr1{TClass})::Bool
return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions writing the C++ code for an object.

""" ClassSaved(this::ByRef1{TROOT}, cl::ByPtr1{TClass})

# Wrapper of void TROOT::CloseFiles()
@trydoc raw"""
    CloseFiles(this::ByRef1{TROOT})::Nothing
Close any files and sockets that gROOT knows about.
This can be used to insures that the files and sockets are closed before any library is unloaded!
""" CloseFiles(this::ByRef1{TROOT})

# Wrapper of void TROOT::EndOfProcessCleanups()
@trydoc raw"""
    EndOfProcessCleanups(this::ByRef1{TROOT})::Nothing
Execute the cleanups necessary at the theend of the process, in particular those that must be executed before the library thestart being unloaded.

""" EndOfProcessCleanups(this::ByRef1{TROOT})

# Wrapper of TObject * TROOT::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TObject}
Returns address of a [ROOT](@ref) object if it exists.
If name contains at least one "/" the function calls FindObjectany else This function looks in the following order in the [ROOT](@ref) lists:

- List of files
- List of memory mapped files
- List of functions
- List of geometries
- List of canvases
- List of styles
- List of specials
- List of materials in current geometry
- List of shapes in current geometry
- List of matrices in current geometry
- List of Nodes in current geometry
- Current Directory in memory
- Current Directory on file
""" FindObject(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of TObject * TROOT::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TROOT}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Find an object in one Root folder.

""" FindObject(this::ByConstRef1{TROOT}, obj::ByConstPtr1{TObject})

# Wrapper of TObject * TROOT::FindObjectAny(const char *)
@trydoc raw"""
    FindObjectAny(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TObject}
Return a pointer to the first object with name starting at //root.
This function scans the list of all folders. if no object found in folders, it scans the memory list of all files.
""" FindObjectAny(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of TObject * TROOT::FindObjectAnyFile(const char *)
@trydoc raw"""
    FindObjectAnyFile(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TObject}
Scan the memory lists of all files for an object with name.

""" FindObjectAnyFile(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of const char * TROOT::FindObjectClassName(const char *)
@trydoc raw"""
    FindObjectClassName(this::ByConstRef1{TROOT}, name::ByCopy{String})::ByCopy{String}
Returns class name of a [ROOT](@ref) object including CINT globals.

""" FindObjectClassName(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of const char * TROOT::FindObjectPathName(const TObject *)
@trydoc raw"""
    FindObjectPathName(this::ByConstRef1{TROOT}, obj::ByConstPtr1{TObject})::ByCopy{String}
Return path name of obj somewhere in the //root/... path.
The function returns the first occurence of the object in the list of folders. The returned string points to a static char array in [TROOT](@ref). If this function is called in a loop or recursively, it is the user's responsibility to copy this string in their area.
""" FindObjectPathName(this::ByConstRef1{TROOT}, obj::ByConstPtr1{TObject})

# Wrapper of TObject * TROOT::FindSpecialObject(const char *, void *&)
@trydoc raw"""
    FindSpecialObject(this::ByRef1{TROOT}, name::ByCopy{String}, where::ByPtr2{Nothing})::CxxPtr1{TObject}
Returns address and folder of a [ROOT](@ref) object if it exists.
This function looks in the following order in the [ROOT](@ref) lists:

- List of files
- List of memory mapped files
- List of functions
- List of geometries
- List of canvases
- List of styles
- List of specials
- List of materials in current geometry
- List of shapes in current geometry
- List of matrices in current geometry
- List of Nodes in current geometry
- Current Directory in memory
- Current Directory on file
""" FindSpecialObject(this::ByRef1{TROOT}, name::ByCopy{String}, where::ByPtr2{Nothing})

# Wrapper of TClass * TROOT::FindSTLClass(const char *, Bool_t, Bool_t)
@trydoc raw"""
    FindSTLClass(this::ByConstRef1{TROOT}, name::ByCopy{String}, load::Bool, silent::Bool)::CxxPtr1{TClass}
return a [TClass](@ref) object corresponding to 'name' assuming it is an STL container.
In particular we looking for possible alternative name (default template parameter, typedefs template arguments, typedefed name).
""" FindSTLClass(this::ByConstRef1{TROOT}, name::ByCopy{String}, load::Bool, silent::Bool)

# Wrapper of void TROOT::ForceStyle(Bool_t)
@trydoc raw"""
    ForceStyle(this::ByRef1{TROOT}, force::Bool)::Nothing


""" ForceStyle(this::ByRef1{TROOT}, force::Bool)

# Wrapper of Bool_t TROOT::FromPopUp()
@trydoc raw"""
    FromPopUp(this::ByConstRef1{TROOT})::Bool


""" FromPopUp(this::ByConstRef1{TROOT})

# Wrapper of TApplication * TROOT::GetApplication()
@trydoc raw"""
    GetApplication(this::ByConstRef1{TROOT})::CxxPtr1{TApplication}


""" GetApplication(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetBuiltDate()
@trydoc raw"""
    GetBuiltDate(this::ByConstRef1{TROOT})::Int32


""" GetBuiltDate(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetBuiltTime()
@trydoc raw"""
    GetBuiltTime(this::ByConstRef1{TROOT})::Int32


""" GetBuiltTime(this::ByConstRef1{TROOT})

# Wrapper of TClass * TROOT::GetClass(const char *, Bool_t, Bool_t)
@trydoc raw"""
    GetClass(this::ByConstRef1{TROOT}, name::ByCopy{String}, load::Bool, silent::Bool)::CxxPtr1{TClass}
Return pointer to class with name. Obsolete, use [TClass!GetClass](@ref) directly.

""" GetClass(this::ByConstRef1{TROOT}, name::ByCopy{String}, load::Bool, silent::Bool)

# Wrapper of TSeqCollection * TROOT::GetClipboard()
@trydoc raw"""
    GetClipboard(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetClipboard(this::ByConstRef1{TROOT})

# Wrapper of const char * TROOT::GetConfigFeatures()
@trydoc raw"""
    GetConfigFeatures(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetConfigFeatures(this::ByConstRef1{TROOT})

# Wrapper of const char * TROOT::GetConfigOptions()
@trydoc raw"""
    GetConfigOptions(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetConfigOptions(this::ByConstRef1{TROOT})

# Wrapper of const char * TROOT::GetCutClassName()
@trydoc raw"""
    GetCutClassName(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetCutClassName(this::ByConstRef1{TROOT})

# Wrapper of const char * TROOT::GetDefCanvasName()
@trydoc raw"""
    GetDefCanvasName(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetDefCanvasName(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::GetEditHistograms()
@trydoc raw"""
    GetEditHistograms(this::ByConstRef1{TROOT})::Bool


""" GetEditHistograms(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetEditorMode()
@trydoc raw"""
    GetEditorMode(this::ByConstRef1{TROOT})::Int32


""" GetEditorMode(this::ByConstRef1{TROOT})

# Wrapper of TFile * TROOT::GetFile()
@trydoc raw"""
    GetFile(this::ByConstRef1{TROOT})::CxxPtr1{TFile}


""" GetFile(this::ByConstRef1{TROOT})

# Wrapper of TFile * TROOT::GetFile(const char *)
@trydoc raw"""
    GetFile(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TFile}
Return pointer to file with name.

""" GetFile(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of Bool_t TROOT::GetForceStyle()
@trydoc raw"""
    GetForceStyle(this::ByConstRef1{TROOT})::Bool


""" GetForceStyle(this::ByConstRef1{TROOT})

# Wrapper of TObject * TROOT::GetFunction(const char *)
@trydoc raw"""
    GetFunction(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TObject}
Return pointer to function with name.

""" GetFunction(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of TObject * TROOT::GetGeometry(const char *)
@trydoc raw"""
    GetGeometry(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TObject}
Return pointer to Geometry with name.

""" GetGeometry(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of const char * TROOT::GetGitBranch()
@trydoc raw"""
    GetGitBranch(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetGitBranch(this::ByConstRef1{TROOT})

# Wrapper of const char * TROOT::GetGitCommit()
@trydoc raw"""
    GetGitCommit(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetGitCommit(this::ByConstRef1{TROOT})

# Wrapper of const char * TROOT::GetGitDate()
@trydoc raw"""
    GetGitDate(this::ByRef1{TROOT})::ByCopy{String}
Return date/time make was run.

""" GetGitDate(this::ByRef1{TROOT})

# Wrapper of TInterpreter * TROOT::GetInterpreter()
@trydoc raw"""
    GetInterpreter(this::ByConstRef1{TROOT})::CxxPtr1{TInterpreter}


""" GetInterpreter(this::ByConstRef1{TROOT})

# Wrapper of TList * TROOT::GetListOfBrowsables()
@trydoc raw"""
    GetListOfBrowsables(this::ByConstRef1{TROOT})::CxxPtr1{TList}


""" GetListOfBrowsables(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfBrowsers()
@trydoc raw"""
    GetListOfBrowsers(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfBrowsers(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfCanvases()
@trydoc raw"""
    GetListOfCanvases(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfCanvases(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfClasses()
@trydoc raw"""
    GetListOfClasses(this::ByConstRef1{TROOT})::CxxPtr1{TCollection}


""" GetListOfClasses(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfClassGenerators()
@trydoc raw"""
    GetListOfClassGenerators(this::ByConstRef1{TROOT})::CxxPtr1{TCollection}


""" GetListOfClassGenerators(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfCleanups()
@trydoc raw"""
    GetListOfCleanups(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfCleanups(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfClosedObjects()
@trydoc raw"""
    GetListOfClosedObjects(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfClosedObjects(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfColors()
@trydoc raw"""
    GetListOfColors(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfColors(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfDataSets()
@trydoc raw"""
    GetListOfDataSets(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfDataSets(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfEnums(Bool_t)
@trydoc raw"""
    GetListOfEnums(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}


""" GetListOfEnums(this::ByRef1{TROOT}, load::Bool)

# Wrapper of TSeqCollection * TROOT::GetListOfFiles()
@trydoc raw"""
    GetListOfFiles(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfFiles(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfFunctionOverloads(const char *)
@trydoc raw"""
    GetListOfFunctionOverloads(this::ByConstRef1{TROOT}, name::ByCopy{String})::CxxPtr1{TCollection}
Return the collection of functions named "name".

""" GetListOfFunctionOverloads(this::ByConstRef1{TROOT}, name::ByCopy{String})

# Wrapper of TCollection * TROOT::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByConstRef1{TROOT})::CxxPtr1{TCollection}


""" GetListOfFunctions(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfFunctionTemplates()
@trydoc raw"""
    GetListOfFunctionTemplates(this::ByRef1{TROOT})::CxxPtr1{TCollection}


""" GetListOfFunctionTemplates(this::ByRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfGeometries()
@trydoc raw"""
    GetListOfGeometries(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfGeometries(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfGlobalFunctions(Bool_t)
@trydoc raw"""
    GetListOfGlobalFunctions(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}
Return list containing the TFunctions currently defined.
Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default).
""" GetListOfGlobalFunctions(this::ByRef1{TROOT}, load::Bool)

# Wrapper of TCollection * TROOT::GetListOfGlobals(Bool_t)
@trydoc raw"""
    GetListOfGlobals(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}
Return list containing the TGlobals currently defined.
Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default).
""" GetListOfGlobals(this::ByRef1{TROOT}, load::Bool)

# Wrapper of TSeqCollection * TROOT::GetListOfMappedFiles()
@trydoc raw"""
    GetListOfMappedFiles(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfMappedFiles(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfMessageHandlers()
@trydoc raw"""
    GetListOfMessageHandlers(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfMessageHandlers(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfProofs()
@trydoc raw"""
    GetListOfProofs(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfProofs(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfSecContexts()
@trydoc raw"""
    GetListOfSecContexts(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfSecContexts(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfSockets()
@trydoc raw"""
    GetListOfSockets(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfSockets(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfSpecials()
@trydoc raw"""
    GetListOfSpecials(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfSpecials(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfStreamerInfo()
@trydoc raw"""
    GetListOfStreamerInfo(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfStreamerInfo(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfStyles()
@trydoc raw"""
    GetListOfStyles(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfStyles(this::ByConstRef1{TROOT})

# Wrapper of TSeqCollection * TROOT::GetListOfTasks()
@trydoc raw"""
    GetListOfTasks(this::ByConstRef1{TROOT})::CxxPtr1{TSeqCollection}


""" GetListOfTasks(this::ByConstRef1{TROOT})

# Wrapper of TCollection * TROOT::GetListOfTypes(Bool_t)
@trydoc raw"""
    GetListOfTypes(this::ByRef1{TROOT}, load::Bool)::CxxPtr1{TCollection}
Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.
The list is populated on demand. Calling 

    gROOT->GetListOfTypes()->FindObject(nameoftype);

(C++ version of the code)

 will return the [TDataType](@ref) corresponding to 'nameoftype'. If the [TDataType](@ref) is not already in the list itself and the type does exist, a new [TDataType](@ref) will be created and added to the list.

Calling 

    gROOT->GetListOfTypes()->ls(); // or Print()

(C++ version of the code)

 list only the typedefs that have been previously accessed through the list (plus the builtins types).
""" GetListOfTypes(this::ByRef1{TROOT}, load::Bool)

# Wrapper of Int_t TROOT::GetNclasses()
@trydoc raw"""
    GetNclasses(this::ByConstRef1{TROOT})::Int32
Get number of classes.

""" GetNclasses(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetNtypes()
@trydoc raw"""
    GetNtypes(this::ByConstRef1{TROOT})::Int32
Get number of types.

""" GetNtypes(this::ByConstRef1{TROOT})

# Wrapper of TVirtualPad * TROOT::GetSelectedPad()
@trydoc raw"""
    GetSelectedPad(this::ByConstRef1{TROOT})::CxxPtr1{TVirtualPad}


""" GetSelectedPad(this::ByConstRef1{TROOT})

# Wrapper of const TObject * TROOT::GetSelectedPrimitive()
@trydoc raw"""
    GetSelectedPrimitive(this::ByConstRef1{TROOT})::ConstCxxPtr1{TObject}


""" GetSelectedPrimitive(this::ByConstRef1{TROOT})

# Wrapper of TDataType * TROOT::GetType(const char *, Bool_t)
@trydoc raw"""
    GetType(this::ByConstRef1{TROOT}, name::ByCopy{String}, load::Bool)::CxxPtr1{TDataType}
Return pointer to type with name.

""" GetType(this::ByConstRef1{TROOT}, name::ByCopy{String}, load::Bool)

# Wrapper of const char * TROOT::GetVersion()
@trydoc raw"""
    GetVersion(this::ByConstRef1{TROOT})::ByCopy{String}


""" GetVersion(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetVersionCode()
@trydoc raw"""
    GetVersionCode(this::ByConstRef1{TROOT})::Int32


""" GetVersionCode(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetVersionDate()
@trydoc raw"""
    GetVersionDate(this::ByConstRef1{TROOT})::Int32


""" GetVersionDate(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetVersionInt()
@trydoc raw"""
    GetVersionInt(this::ByConstRef1{TROOT})::Int32


""" GetVersionInt(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::GetVersionTime()
@trydoc raw"""
    GetVersionTime(this::ByConstRef1{TROOT})::Int32


""" GetVersionTime(this::ByConstRef1{TROOT})

# Wrapper of const TString & TROOT::GetWebDisplay()
@trydoc raw"""
    GetWebDisplay(this::ByConstRef1{TROOT})::ConstCxxRef1{TString}


""" GetWebDisplay(this::ByConstRef1{TROOT})

# Wrapper of void TROOT::Idle(UInt_t, const char *)
@trydoc raw"""
    Idle(this::ByRef1{TROOT}, idleTimeInSec::UInt32, command::ByCopy{String})::Nothing
Execute command when system has been idle for idleTimeInSec seconds.

""" Idle(this::ByRef1{TROOT}, idleTimeInSec::UInt32, command::ByCopy{String})

# Wrapper of Int_t TROOT::IgnoreInclude(const char *, const char *)
@trydoc raw"""
    IgnoreInclude(this::ByRef1{TROOT}, fname::ByCopy{String}, expandedfname::ByCopy{String})::Int32
Return 1 if the name of the given include file corresponds to a class that is known to [ROOT](@ref), e.g.
"TLorentzVector.h" versus [TLorentzVector](@ref).
""" IgnoreInclude(this::ByRef1{TROOT}, fname::ByCopy{String}, expandedfname::ByCopy{String})

# Wrapper of TClass * TROOT::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TROOT})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsBatch()
@trydoc raw"""
    IsBatch(this::ByConstRef1{TROOT})::Bool


""" IsBatch(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsEscaped()
@trydoc raw"""
    IsEscaped(this::ByConstRef1{TROOT})::Bool


""" IsEscaped(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsExecutingMacro()
@trydoc raw"""
    IsExecutingMacro(this::ByConstRef1{TROOT})::Bool


""" IsExecutingMacro(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TROOT})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsInterrupted()
@trydoc raw"""
    IsInterrupted(this::ByConstRef1{TROOT})::Bool


""" IsInterrupted(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsLineProcessing()
@trydoc raw"""
    IsLineProcessing(this::ByConstRef1{TROOT})::Bool


""" IsLineProcessing(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsProofServ()
@trydoc raw"""
    IsProofServ(this::ByConstRef1{TROOT})::Bool


""" IsProofServ(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsRootFile(const char *)
@trydoc raw"""
    IsRootFile(this::ByConstRef1{TROOT}, filename::ByCopy{String})::Bool
Return true if the file is local_ and is (likely) to be a [ROOT](@ref) file.

""" IsRootFile(this::ByConstRef1{TROOT}, filename::ByCopy{String})

# Wrapper of Bool_t TROOT::IsWebDisplay()
@trydoc raw"""
    IsWebDisplay(this::ByConstRef1{TROOT})::Bool


""" IsWebDisplay(this::ByConstRef1{TROOT})

# Wrapper of Bool_t TROOT::IsWebDisplayBatch()
@trydoc raw"""
    IsWebDisplayBatch(this::ByConstRef1{TROOT})::Bool


""" IsWebDisplayBatch(this::ByConstRef1{TROOT})

# Wrapper of Int_t TROOT::LoadClass(const char *, const char *, Bool_t)
@trydoc raw"""
    LoadClass(this::ByRef1{TROOT}, classname::ByCopy{String}, libname::ByCopy{String}, check::Bool)::Int32
Check if class "classname" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored).
If not it will load library "libname". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with "lib" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch.
""" LoadClass(this::ByRef1{TROOT}, classname::ByCopy{String}, libname::ByCopy{String}, check::Bool)

# Wrapper of TClass * TROOT::LoadClass(const char *, Bool_t)
@trydoc raw"""
    LoadClass(this::ByConstRef1{TROOT}, name::ByCopy{String}, silent::Bool)::CxxPtr1{TClass}
Helper function used by [TClass!GetClass()](@ref).
This function attempts to load the dictionary for 'classname' either from the [TClassTable](@ref) or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members)

The 'requestedname' is expected to be already normalized.
""" LoadClass(this::ByConstRef1{TROOT}, name::ByCopy{String}, silent::Bool)

# Wrapper of Int_t TROOT::LoadMacro(const char *, Int_t *, Bool_t)
@trydoc raw"""
    LoadMacro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, check::Bool)::Int32
Load a macro in the interpreter's memory.
Equivalent to the command line command ".L filename". If the filename has "+" or "++" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by [TInterpreter!EErrorCode](@ref). If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error.
""" LoadMacro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, check::Bool)

# Wrapper of void TROOT::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TROOT}, option::ByCopy{String})::Nothing
To list all objects of the application.
Loop on all objects created in the [ROOT](@ref) linked lists. Objects may be files and windows or any other object directly attached to the [ROOT](@ref) linked list.
""" ls(this::ByConstRef1{TROOT}, option::ByCopy{String})

# Wrapper of Longptr_t TROOT::Macro(const char *, Int_t *, Bool_t)
@trydoc raw"""
    Macro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, padUpdate::Bool)::Int64
Execute a macro in the interpreter.
Equivalent to the command line command ".x filename". If the filename has "+" or "++" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by [TInterpreter!EErrorCode](@ref). If padUpdate is true (default) update the current pad. Returns the macro return value.
""" Macro(this::ByRef1{TROOT}, filename::ByCopy{String}, error::ByPtr2{Int32}, padUpdate::Bool)

# Wrapper of TCanvas * TROOT::MakeDefCanvas()
@trydoc raw"""
    MakeDefCanvas(this::ByConstRef1{TROOT})::CxxPtr1{TCanvas}
Return a default canvas.

""" MakeDefCanvas(this::ByConstRef1{TROOT})

# Wrapper of void TROOT::Message(Int_t, const TObject *)
@trydoc raw"""
    Message(this::ByRef1{TROOT}, id::Int32, obj::ByConstPtr1{TObject})::Nothing
Process message id called by obj.

""" Message(this::ByRef1{TROOT}, id::Int32, obj::ByConstPtr1{TObject})

# Wrapper of Bool_t TROOT::MustClean()
@trydoc raw"""
    MustClean(this::ByConstRef1{TROOT})::Bool


""" MustClean(this::ByConstRef1{TROOT})

# Wrapper of Longptr_t TROOT::ProcessLine(const char *, Int_t *)
@trydoc raw"""
    ProcessLine(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})::Int64
Process interpreter command via [TApplication!ProcessLine()](@ref).
On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use [ProcessLineSync()](@ref). On non-Win32 platforms there is no difference between [ProcessLine()](@ref) and [ProcessLineSync()](@ref). The possible error codes are defined by [TInterpreter!EErrorCode](@ref). In particular, error will equal to [TInterpreter!kProcessing](@ref) until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t.
""" ProcessLine(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of Longptr_t TROOT::ProcessLineFast(const char *, Int_t *)
@trydoc raw"""
    ProcessLineFast(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})::Int64
Process interpreter command directly via CINT interpreter.
Only executable statements are allowed (no variable declarations), In all other cases use [TROOT!ProcessLine()](@ref). The possible error codes are defined by [TInterpreter!EErrorCode](@ref).
""" ProcessLineFast(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of Longptr_t TROOT::ProcessLineSync(const char *, Int_t *)
@trydoc raw"""
    ProcessLineSync(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})::Int64
Process interpreter command via [TApplication!ProcessLine()](@ref).
On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between [ProcessLine()](@ref) and [ProcessLineSync()](@ref). The possible error codes are defined by [TInterpreter!EErrorCode](@ref). Returns the result of the command, cast to a Longptr_t.
""" ProcessLineSync(this::ByRef1{TROOT}, line::ByCopy{String}, error::ByPtr2{Int32})

# Wrapper of Bool_t TROOT::ReadingObject()
@trydoc raw"""
    ReadingObject(this::ByConstRef1{TROOT})::Bool
Deprecated (will be removed in next release).

""" ReadingObject(this::ByConstRef1{TROOT})

# Wrapper of void TROOT::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TROOT}, obj::ByPtr1{TObject})::Nothing
Recursively remove this object from the list of Cleanups.
Typically RecursiveRemove is implemented by classes that can contain mulitple references to a same object or shared ownership of the object with others.
""" RecursiveRemove(this::ByRef1{TROOT}, obj::ByPtr1{TObject})

# Wrapper of void TROOT::RefreshBrowsers()
@trydoc raw"""
    RefreshBrowsers(this::ByRef1{TROOT})::Nothing
Refresh all browsers.
Call this method when some command line command or script has changed the browser contents. Not needed for objects that have the kMustCleanup bit set. Most useful to update browsers that show the file system or other objects external to the running [ROOT](@ref) session.
""" RefreshBrowsers(this::ByRef1{TROOT})

# Wrapper of TObject * TROOT::Remove(TObject *)
@trydoc raw"""
    Remove(this::ByRef1{TROOT}, ::ByPtr1{TObject})::CxxPtr1{TObject}
Remove an object from the in-memory list.
Since [TROOT](@ref) is global_ resource, this is lock protected.
""" Remove(this::ByRef1{TROOT}, ::ByPtr1{TObject})

# Wrapper of void TROOT::RemoveClass(TClass *)
@trydoc raw"""
    RemoveClass(this::ByRef1{TROOT}, ::ByPtr1{TClass})::Nothing
Remove a class from the list and map of classes.
This routine is deprecated, use [TClass!RemoveClass](@ref) directly.
""" RemoveClass(this::ByRef1{TROOT}, ::ByPtr1{TClass})

# Wrapper of void TROOT::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TROOT}, option::ByCopy{String})::Nothing
Delete all global_ interpreter objects created since the last call to Reset.
If option="a" is set reset to startup context (i.e. unload also all loaded files, classes, structs, typedefs, etc.).

This function is typically used at the beginning (or theend) of an unnamed macro to clean the environment.

IMPORTANT WARNING: Do not use this call from within any function (neither compiled nor interpreted. This should only be used from a unnamed macro (which starts with a { (curly braces) ). For example, using [TROOT!Reset](@ref) from within an interpreted function will lead to the unloading of the dictionary and source file, including the one defining the function being executed.
""" Reset(this::ByRef1{TROOT}, option::ByCopy{String})

# Wrapper of void TROOT::ResetClassSaved()
@trydoc raw"""
    ResetClassSaved(this::ByRef1{TROOT})::Nothing
Reset the ClassSaved status of all classes.

""" ResetClassSaved(this::ByRef1{TROOT})

# Wrapper of void TROOT::SaveContext()
@trydoc raw"""
    SaveContext(this::ByRef1{TROOT})::Nothing
Save the current interpreter context.

""" SaveContext(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetApplication(TApplication *)
@trydoc raw"""
    SetApplication(this::ByRef1{TROOT}, app::ByPtr1{TApplication})::Nothing


""" SetApplication(this::ByRef1{TROOT}, app::ByPtr1{TApplication})

# Wrapper of void TROOT::SetBatch(Bool_t)
@trydoc raw"""
    SetBatch(this::ByRef1{TROOT}, batch::Bool)::Nothing
Set batch mode for [ROOT](@ref) If the argument evaluates to `true`, the session does not use interactive graphics.
If web graphics runs in server mode, the web widgets are still available via URL
""" SetBatch(this::ByRef1{TROOT}, batch::Bool)

# Wrapper of void TROOT::SetCutClassName(const char *)
@trydoc raw"""
    SetCutClassName(this::ByRef1{TROOT}, name::ByCopy{String})::Nothing
Set the default graphical cut class name for the graphics editor By default the graphics editor creates an instance of a class [TCutG](@ref).
This function may be called to specify a different class that MUST derive from [TCutG](@ref)
""" SetCutClassName(this::ByRef1{TROOT}, name::ByCopy{String})

# Wrapper of void TROOT::SetDefCanvasName(const char *)
@trydoc raw"""
    SetDefCanvasName(this::ByRef1{TROOT}, name::ByCopy{String})::Nothing


""" SetDefCanvasName(this::ByRef1{TROOT}, name::ByCopy{String})

# Wrapper of void TROOT::SetEditHistograms(Bool_t)
@trydoc raw"""
    SetEditHistograms(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetEditHistograms(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetEditorMode(const char *)
@trydoc raw"""
    SetEditorMode(this::ByRef1{TROOT}, mode::ByCopy{String})::Nothing
Set editor mode.

""" SetEditorMode(this::ByRef1{TROOT}, mode::ByCopy{String})

# Wrapper of void TROOT::SetEscape(Bool_t)
@trydoc raw"""
    SetEscape(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetEscape(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetExecutingMacro(Bool_t)
@trydoc raw"""
    SetExecutingMacro(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetExecutingMacro(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetFromPopUp(Bool_t)
@trydoc raw"""
    SetFromPopUp(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetFromPopUp(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetInterrupt(Bool_t)
@trydoc raw"""
    SetInterrupt(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetInterrupt(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetLineHasBeenProcessed()
@trydoc raw"""
    SetLineHasBeenProcessed(this::ByRef1{TROOT})::Nothing


""" SetLineHasBeenProcessed(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetLineIsProcessing()
@trydoc raw"""
    SetLineIsProcessing(this::ByRef1{TROOT})::Nothing


""" SetLineIsProcessing(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetMustClean(Bool_t)
@trydoc raw"""
    SetMustClean(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetMustClean(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetReadingObject(Bool_t)
@trydoc raw"""
    SetReadingObject(this::ByRef1{TROOT}, flag::Bool)::Nothing


""" SetReadingObject(this::ByRef1{TROOT}, flag::Bool)

# Wrapper of void TROOT::SetSelectedPad(TVirtualPad *)
@trydoc raw"""
    SetSelectedPad(this::ByRef1{TROOT}, pad::ByPtr1{TVirtualPad})::Nothing


""" SetSelectedPad(this::ByRef1{TROOT}, pad::ByPtr1{TVirtualPad})

# Wrapper of void TROOT::SetSelectedPrimitive(const TObject *)
@trydoc raw"""
    SetSelectedPrimitive(this::ByRef1{TROOT}, obj::ByConstPtr1{TObject})::Nothing


""" SetSelectedPrimitive(this::ByRef1{TROOT}, obj::ByConstPtr1{TObject})

# Wrapper of void TROOT::SetStyle(const char *)
@trydoc raw"""
    SetStyle(this::ByRef1{TROOT}, stylename::ByCopy{String})::Nothing
Change current style to style with name stylename.

""" SetStyle(this::ByRef1{TROOT}, stylename::ByCopy{String})

# Wrapper of void TROOT::SetWebDisplay(const char *)
@trydoc raw"""
    SetWebDisplay(this::ByRef1{TROOT}, webdisplay::ByCopy{String})::Nothing
Specify where web graphics shall be rendered.
The input parameter `webdisplay` defines where web graphics is rendered. `webdisplay` parameter may contain:

- "firefox": select Mozilla Firefox browser for interactive web display
- "chrome": select Google Chrome browser for interactive web display
- "edge": select Microsoft Edge browser for interactive web display
- "native": select one of the natively-supported web browsers firefox/chrome/edge for interactive web display
- "qt6": uses QWebEngine from Qt6, no real http server started (requires `qt6web` component build for [ROOT](@ref))
- "cef": uses Chromium Embeded Framework, no real http server started (requires `cefweb` component build for [ROOT](@ref))
- "local_": select one of available local_ (without http server) engines like qt6/cef
- "default": system default web browser, invoked with `xdg-open` on Linux, `thestart` on Mac or `open` on Windows
- "on": try "local_", then "native", then "default" option
- "off": turns off the web display and comes back to normal graphics in interactive mode.
- "server:port": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output
""" SetWebDisplay(this::ByRef1{TROOT}, webdisplay::ByCopy{String})

# Wrapper of void TROOT::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TROOT}, ::ByRef1{TBuffer})::Nothing
[TDirectory](@ref) Streamer.

""" Streamer(this::ByRef1{TROOT}, ::ByRef1{TBuffer})

# Wrapper of void TROOT::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TROOT}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TROOT}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TROOT::Time(Int_t)
@trydoc raw"""
    Time(this::ByRef1{TROOT}, casetime::Int32)::Nothing


""" Time(this::ByRef1{TROOT}, casetime::Int32)

# Wrapper of Int_t TROOT::Timer()
@trydoc raw"""
    Timer(this::ByConstRef1{TROOT})::Int32


""" Timer(this::ByConstRef1{TROOT})

# Wrapper of TClass * TROOT::Class()
@trydoc raw"""
    TROOT!Class(this::ByRef1{TROOT})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TROOT!Class(this::ByRef1{TROOT})

# Wrapper of const char * TROOT::Class_Name()
@trydoc raw"""
    TROOT!Class_Name(this::ByRef1{TROOT})::ByCopy{String}

###Return

Name of this class
""" TROOT!Class_Name(this::ByRef1{TROOT})

# Wrapper of Int_t TROOT::ConvertVersionCode2Int(Int_t)
@trydoc raw"""
    TROOT!ConvertVersionCode2Int(this::ByRef1{TROOT}, code::Int32)::Int32
Convert version code to an integer, i.e. 331527 -> 51507.

""" TROOT!ConvertVersionCode2Int(this::ByRef1{TROOT}, code::Int32)

# Wrapper of Int_t TROOT::ConvertVersionInt2Code(Int_t)
@trydoc raw"""
    TROOT!ConvertVersionInt2Code(this::ByRef1{TROOT}, v::Int32)::Int32
Convert version as an integer to version code as used in RVersion.h.

""" TROOT!ConvertVersionInt2Code(this::ByRef1{TROOT}, v::Int32)

# Wrapper of const char * TROOT::DeclFileName()
@trydoc raw"""
    TROOT!DeclFileName(this::ByRef1{TROOT})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TROOT!DeclFileName(this::ByRef1{TROOT})

# Wrapper of Int_t TROOT::DecreaseDirLevel()
@trydoc raw"""
    TROOT!DecreaseDirLevel(this::ByRef1{TROOT})::Int32
Decrease the indentation level for [ls()](@ref).

""" TROOT!DecreaseDirLevel(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetBinDir()
@trydoc raw"""
    TROOT!GetBinDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the binary directory in the installation. Static utility function.

""" TROOT!GetBinDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetDataDir()
@trydoc raw"""
    TROOT!GetDataDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the data directory in the installation. Static utility function.

""" TROOT!GetDataDir(this::ByRef1{TROOT})

# Wrapper of Int_t TROOT::GetDirLevel()
@trydoc raw"""
    TROOT!GetDirLevel(this::ByRef1{TROOT})::Int32
return directory level

""" TROOT!GetDirLevel(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetDocDir()
@trydoc raw"""
    TROOT!GetDocDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the documentation directory in the installation. Static utility function.

""" TROOT!GetDocDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetEtcDir()
@trydoc raw"""
    TROOT!GetEtcDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the sysconfig directory in the installation. Static utility function.

""" TROOT!GetEtcDir(this::ByRef1{TROOT})

# Wrapper of const char **& TROOT::GetExtraInterpreterArgs()
@trydoc raw"""
    TROOT!GetExtraInterpreterArgs(this::ByRef1{TROOT})::ConstCxxPtr2{Int8}
INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.

""" TROOT!GetExtraInterpreterArgs(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetIconPath()
@trydoc raw"""
    TROOT!GetIconPath(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the icon path in the installation. Static utility function.

""" TROOT!GetIconPath(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetIncludeDir()
@trydoc raw"""
    TROOT!GetIncludeDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the include directory in the installation. Static utility function.

""" TROOT!GetIncludeDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetLibDir()
@trydoc raw"""
    TROOT!GetLibDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the library directory in the installation. Static utility function.

""" TROOT!GetLibDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetMacroDir()
@trydoc raw"""
    TROOT!GetMacroDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the macro directory in the installation. Static utility function.

""" TROOT!GetMacroDir(this::ByRef1{TROOT})

# Wrapper of const char * TROOT::GetMacroPath()
@trydoc raw"""
    TROOT!GetMacroPath(this::ByRef1{TROOT})::ByCopy{String}
Get macro search path. Static utility function.

""" TROOT!GetMacroPath(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetRootSys()
@trydoc raw"""
    TROOT!GetRootSys(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the rootsys directory in the installation. Static utility function.

""" TROOT!GetRootSys(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetSharedLibDir()
@trydoc raw"""
    TROOT!GetSharedLibDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the shared libraries directory in the installation. Static utility function.

""" TROOT!GetSharedLibDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetSourceDir()
@trydoc raw"""
    TROOT!GetSourceDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the source directory in the installation. Static utility function.

""" TROOT!GetSourceDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetTTFFontDir()
@trydoc raw"""
    TROOT!GetTTFFontDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the fonts directory in the installation. Static utility function.

""" TROOT!GetTTFFontDir(this::ByRef1{TROOT})

# Wrapper of const TString & TROOT::GetTutorialDir()
@trydoc raw"""
    TROOT!GetTutorialDir(this::ByRef1{TROOT})::ConstCxxRef1{TString}
Get the tutorials directory in the installation. Static utility function.

""" TROOT!GetTutorialDir(this::ByRef1{TROOT})

# Wrapper of const char * TROOT::GetTutorialsDir()
@trydoc raw"""
    TROOT!GetTutorialsDir(this::ByRef1{TROOT})::ByCopy{String}
Get the tutorials directory in the installation.
Static utility function. Backward compatibility function - do not use for new code
""" TROOT!GetTutorialsDir(this::ByRef1{TROOT})

# Wrapper of Int_t TROOT::IncreaseDirLevel()
@trydoc raw"""
    TROOT!IncreaseDirLevel(this::ByRef1{TROOT})::Int32
Increase the indentation level for [ls()](@ref).

""" TROOT!IncreaseDirLevel(this::ByRef1{TROOT})

# Wrapper of void TROOT::IndentLevel()
@trydoc raw"""
    TROOT!IndentLevel(this::ByRef1{TROOT})::Nothing
Functions used by [ls()](@ref) to indent an object hierarchy.

""" TROOT!IndentLevel(this::ByRef1{TROOT})

# Wrapper of void TROOT::Initialize()
@trydoc raw"""
    TROOT!Initialize(this::ByRef1{TROOT})::Nothing
Initialize [ROOT](@ref) explicitly.

""" TROOT!Initialize(this::ByRef1{TROOT})

# Wrapper of Bool_t TROOT::Initialized()
@trydoc raw"""
    TROOT!Initialized(this::ByRef1{TROOT})::Bool
Return kTRUE if the [TROOT](@ref) object has been initialized.

""" TROOT!Initialized(this::ByRef1{TROOT})

# Wrapper of Int_t TROOT::RootVersionCode()
@trydoc raw"""
    TROOT!RootVersionCode(this::ByRef1{TROOT})::Int32
Return [ROOT](@ref) version code as defined in RVersion.h.

""" TROOT!RootVersionCode(this::ByRef1{TROOT})

# Wrapper of void TROOT::SetDirLevel(Int_t)
@trydoc raw"""
    TROOT!SetDirLevel(this::ByRef1{TROOT}, level::Int32)::Nothing
Return Indentation level for [ls()](@ref).

""" TROOT!SetDirLevel(this::ByRef1{TROOT}, level::Int32)

# Wrapper of void TROOT::SetMacroPath(const char *)
@trydoc raw"""
    TROOT!SetMacroPath(this::ByRef1{TROOT}, newpath::ByCopy{String})::Nothing
Set or extend the macro search path.
Static utility function. If newpath=0 or "" reset to value specified in the rootrc file.
""" TROOT!SetMacroPath(this::ByRef1{TROOT}, newpath::ByCopy{String})

# Wrapper of void TROOT::ShutDown()
@trydoc raw"""
    TROOT!ShutDown(this::ByRef1{TROOT})::Nothing
Shut down [ROOT](@ref).

""" TROOT!ShutDown(this::ByRef1{TROOT})

# Wrapper of const char * TApplication::ApplicationName()
@trydoc raw"""
    ApplicationName(this::ByConstRef1{TApplication})::ByCopy{String}


""" ApplicationName(this::ByConstRef1{TApplication})

# Wrapper of Int_t TApplication::Argc()
@trydoc raw"""
    Argc(this::ByConstRef1{TApplication})::Int32


""" Argc(this::ByConstRef1{TApplication})

# Wrapper of char ** TApplication::Argv()
@trydoc raw"""
    Argv(this::ByConstRef1{TApplication})::CxxPtr2{Int8}


""" Argv(this::ByConstRef1{TApplication})

# Wrapper of char * TApplication::Argv(Int_t)
@trydoc raw"""
    Argv(this::ByConstRef1{TApplication}, index::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Return specified argument.

""" Argv(this::ByConstRef1{TApplication}, index::Int32)

# Wrapper of void TApplication::ClearInputFiles()
@trydoc raw"""
    ClearInputFiles(this::ByRef1{TApplication})::Nothing
Clear list containing macro files passed as program arguments.
This method is called from [TRint!Run()](@ref) to ensure that the macro files are only executed the first time [Run()](@ref) is called.
""" ClearInputFiles(this::ByRef1{TApplication})

# Wrapper of TApplicationImp * TApplication::GetApplicationImp()
@trydoc raw"""
    GetApplicationImp(this::ByRef1{TApplication})::CxxPtr1{TApplicationImp}


""" GetApplicationImp(this::ByRef1{TApplication})

# Wrapper of TApplication * TApplication::GetAppRemote()
@trydoc raw"""
    GetAppRemote(this::ByConstRef1{TApplication})::CxxPtr1{TApplication}


""" GetAppRemote(this::ByConstRef1{TApplication})

# Wrapper of const char * TApplication::GetIdleCommand()
@trydoc raw"""
    GetIdleCommand(this::ByConstRef1{TApplication})::ByCopy{String}


""" GetIdleCommand(this::ByConstRef1{TApplication})

# Wrapper of void TApplication::GetOptions(Int_t *, char **)
@trydoc raw"""
    GetOptions(this::ByRef1{TApplication}, argc::ByPtr2{Int32}, argv::ByPtr2{Int8})::Nothing
Get and handle command line options.
Arguments handled are removed from the argument array. See CommandLineOptionsHelp.h for options.
""" GetOptions(this::ByRef1{TApplication}, argc::ByPtr2{Int32}, argv::ByPtr2{Int8})

# Wrapper of TString TApplication::GetSetup()
@trydoc raw"""
    GetSetup(this::ByRef1{TApplication})::ByCopy{TString}
It gets the [ROOT](@ref) installation setup as [TString](@ref).
###Return

a string with several lines
""" GetSetup(this::ByRef1{TApplication})

# Wrapper of TSignalHandler * TApplication::GetSignalHandler()
@trydoc raw"""
    GetSignalHandler(this::ByConstRef1{TApplication})::CxxPtr1{TSignalHandler}


""" GetSignalHandler(this::ByConstRef1{TApplication})

# Wrapper of void TApplication::HandleException(Int_t)
@trydoc raw"""
    HandleException(this::ByRef1{TApplication}, sig::Int32)::Nothing
Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in [TSystem](@ref).
Specific [TApplication](@ref) implementations may want something different here.
""" HandleException(this::ByRef1{TApplication}, sig::Int32)

# Wrapper of void TApplication::HandleIdleTimer()
@trydoc raw"""
    HandleIdleTimer(this::ByRef1{TApplication})::Nothing
Handle idle timeout.
When this timer expires the registered idle command will be executed by this routine and a signal will be emitted.
""" HandleIdleTimer(this::ByRef1{TApplication})

# Wrapper of Bool_t TApplication::HandleTermInput()
@trydoc raw"""
    HandleTermInput(this::ByRef1{TApplication})::Bool


""" HandleTermInput(this::ByRef1{TApplication})

# Wrapper of void TApplication::Hide()
@trydoc raw"""
    Hide(this::ByRef1{TApplication})::Nothing


""" Hide(this::ByRef1{TApplication})

# Wrapper of void TApplication::Iconify()
@trydoc raw"""
    Iconify(this::ByRef1{TApplication})::Nothing


""" Iconify(this::ByRef1{TApplication})

# Wrapper of void TApplication::Init()
@trydoc raw"""
    Init(this::ByRef1{TApplication})::Nothing


""" Init(this::ByRef1{TApplication})

# Wrapper of void TApplication::InitializeGraphics(Bool_t)
@trydoc raw"""
    InitializeGraphics(this::ByRef1{TApplication}, only_web::Bool)::Nothing
Initialize the graphics environment.
If## Arguments

- **`only_web`** 
    is specified, only web-related part of graphics is loaded
""" InitializeGraphics(this::ByRef1{TApplication}, only_web::Bool)

# Wrapper of TObjArray * TApplication::InputFiles()
@trydoc raw"""
    InputFiles(this::ByConstRef1{TApplication})::CxxPtr1{TObjArray}


""" InputFiles(this::ByConstRef1{TApplication})

# Wrapper of TClass * TApplication::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TApplication})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TApplication})

# Wrapper of Bool_t TApplication::IsCmdThread()
@trydoc raw"""
    IsCmdThread(this::ByRef1{TApplication})::Bool


""" IsCmdThread(this::ByRef1{TApplication})

# Wrapper of Bool_t TApplication::IsRunning()
@trydoc raw"""
    IsRunning(this::ByConstRef1{TApplication})::Bool


""" IsRunning(this::ByConstRef1{TApplication})

# Wrapper of void TApplication::KeyPressed(Int_t)
@trydoc raw"""
    KeyPressed(this::ByRef1{TApplication}, key::Int32)::Nothing
Emit signal when console keyboard key was pressed.

""" KeyPressed(this::ByRef1{TApplication}, key::Int32)

# Wrapper of void TApplication::LineProcessed(const char *)
@trydoc raw"""
    LineProcessed(this::ByRef1{TApplication}, line::ByCopy{String})::Nothing
Emit signal when a line has been processed.

""" LineProcessed(this::ByRef1{TApplication}, line::ByCopy{String})

# Wrapper of void TApplication::Lower()
@trydoc raw"""
    Lower(this::ByRef1{TApplication})::Nothing


""" Lower(this::ByRef1{TApplication})

# Wrapper of void TApplication::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TApplication}, option::ByCopy{String})::Nothing
Show available sessions.

""" ls(this::ByConstRef1{TApplication}, option::ByCopy{String})

# Wrapper of Bool_t TApplication::NoLogoOpt()
@trydoc raw"""
    NoLogoOpt(this::ByConstRef1{TApplication})::Bool


""" NoLogoOpt(this::ByConstRef1{TApplication})

# Wrapper of Bool_t TApplication::NoLogOpt()
@trydoc raw"""
    NoLogOpt(this::ByConstRef1{TApplication})::Bool


""" NoLogOpt(this::ByConstRef1{TApplication})

# Wrapper of void TApplication::Open()
@trydoc raw"""
    Open(this::ByRef1{TApplication})::Nothing


""" Open(this::ByRef1{TApplication})

# Wrapper of void TApplication::OpenForumTopic(const TString &)
@trydoc raw"""
    OpenForumTopic(this::ByRef1{TApplication}, type::ByConstRef1{TString})::Nothing
It opens a Forum topic in a web browser with prefilled [ROOT](@ref) version.
## Arguments

- **`type`** [in] 
    the issue type (only bug supported right now)
""" OpenForumTopic(this::ByRef1{TApplication}, type::ByConstRef1{TString})

# Wrapper of void TApplication::OpenGitHubIssue(const TString &)
@trydoc raw"""
    OpenGitHubIssue(this::ByRef1{TApplication}, type::ByConstRef1{TString})::Nothing
It opens a GitHub issue in a web browser with prefilled [ROOT](@ref) version.
## Arguments

- **`type`** [in] 
    the issue type (bug, feature or improvement)
""" OpenGitHubIssue(this::ByRef1{TApplication}, type::ByConstRef1{TString})

# Wrapper of void TApplication::OpenInBrowser(const TString &)
@trydoc raw"""
    OpenInBrowser(this::ByRef1{TApplication}, url::ByConstRef1{TString})::Nothing
The function generates and executes a command that loads the Doxygen URL in a browser.
It works for Mac, Windows and Linux. In the case of Linux, the function also checks if the DISPLAY is set. If it isn't, a warning message and the URL will be displayed on the terminal.

## Arguments

- **`url`** [in] 
    web page to be displayed in a browser
""" OpenInBrowser(this::ByRef1{TApplication}, url::ByConstRef1{TString})

# Wrapper of void TApplication::OpenReferenceGuideFor(const TString &)
@trydoc raw"""
    OpenReferenceGuideFor(this::ByRef1{TApplication}, strippedClass::ByConstRef1{TString})::Nothing
It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator.
If the user types incorrect value, it will return an error or warning.

## Arguments

- **`strippedClass`** [in] 
    the scope or scope!member
""" OpenReferenceGuideFor(this::ByRef1{TApplication}, strippedClass::ByConstRef1{TString})

# Wrapper of Longptr_t TApplication::ProcessFile(const char *, Int_t *, Bool_t)
@trydoc raw"""
    ProcessFile(this::ByRef1{TApplication}, file::ByCopy{String}, error::ByPtr2{Int32}, keep::Bool)::Int64
Process a file containing a C++ macro.

""" ProcessFile(this::ByRef1{TApplication}, file::ByCopy{String}, error::ByPtr2{Int32}, keep::Bool)

# Wrapper of Longptr_t TApplication::ProcessLine(const char *, Bool_t, Int_t *)
@trydoc raw"""
    ProcessLine(this::ByRef1{TApplication}, line::ByCopy{String}, sync::Bool, error::ByPtr2{Int32})::Int64
Process a single command line, either a C++ statement or an interpreter command starting with a ".".
Return the return value of the command cast to a long.
""" ProcessLine(this::ByRef1{TApplication}, line::ByCopy{String}, sync::Bool, error::ByPtr2{Int32})

# Wrapper of Bool_t TApplication::QuitOpt()
@trydoc raw"""
    QuitOpt(this::ByConstRef1{TApplication})::Bool


""" QuitOpt(this::ByConstRef1{TApplication})

# Wrapper of void TApplication::Raise()
@trydoc raw"""
    Raise(this::ByRef1{TApplication})::Nothing


""" Raise(this::ByRef1{TApplication})

# Wrapper of void TApplication::RemoveIdleTimer()
@trydoc raw"""
    RemoveIdleTimer(this::ByRef1{TApplication})::Nothing
Remove idle timer. Normally called via TROOT!Idle(0).
""" RemoveIdleTimer(this::ByRef1{TApplication})

# Wrapper of Bool_t TApplication::ReturnFromRun()
@trydoc raw"""
    ReturnFromRun(this::ByConstRef1{TApplication})::Bool


""" ReturnFromRun(this::ByConstRef1{TApplication})

# Wrapper of void TApplication::ReturnPressed(char *)
@trydoc raw"""
    ReturnPressed(this::ByRef1{TApplication}, text::ByPtr2{Int8})::Nothing
Emit signal when return key was pressed.

""" ReturnPressed(this::ByRef1{TApplication}, text::ByPtr2{Int8})

# Wrapper of void TApplication::Run(Bool_t)
@trydoc raw"""
    Run(this::ByRef1{TApplication}, retrn::Bool)::Nothing
Main application eventloop. Calls system dependent eventloop via gSystem.

""" Run(this::ByRef1{TApplication}, retrn::Bool)

# Wrapper of void TApplication::SetEchoMode(Bool_t)
@trydoc raw"""
    SetEchoMode(this::ByRef1{TApplication}, mode::Bool)::Nothing
Set console echo mode:
- mode = kTRUE - echo input symbols
- mode = kFALSE - noecho input symbols
""" SetEchoMode(this::ByRef1{TApplication}, mode::Bool)

# Wrapper of void TApplication::SetIdleTimer(UInt_t, const char *)
@trydoc raw"""
    SetIdleTimer(this::ByRef1{TApplication}, idleTimeInSec::UInt32, command::ByCopy{String})::Nothing
Set the command to be executed after the system has been idle for idleTimeInSec seconds.
Normally called via TROOT!Idle(...).
""" SetIdleTimer(this::ByRef1{TApplication}, idleTimeInSec::UInt32, command::ByCopy{String})

# Wrapper of void TApplication::SetReturnFromRun(Bool_t)
@trydoc raw"""
    SetReturnFromRun(this::ByRef1{TApplication}, ret::Bool)::Nothing


""" SetReturnFromRun(this::ByRef1{TApplication}, ret::Bool)

# Wrapper of void TApplication::Show()
@trydoc raw"""
    Show(this::ByRef1{TApplication})::Nothing


""" Show(this::ByRef1{TApplication})

# Wrapper of void TApplication::StartIdleing()
@trydoc raw"""
    StartIdleing(this::ByRef1{TApplication})::Nothing
Called when system starts idleing.

""" StartIdleing(this::ByRef1{TApplication})

# Wrapper of void TApplication::StopIdleing()
@trydoc raw"""
    StopIdleing(this::ByRef1{TApplication})::Nothing
Called when system stops idleing.

""" StopIdleing(this::ByRef1{TApplication})

# Wrapper of void TApplication::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TApplication}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TApplication}, ::ByRef1{TBuffer})

# Wrapper of void TApplication::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TApplication}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TApplication}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of void TApplication::Terminate(Int_t)
@trydoc raw"""
    Terminate(this::ByRef1{TApplication}, status::Int32)::Nothing
Terminate the application by call [TSystem!Exit()](@ref) unless application has been told to return from [Run()](@ref), by a call to [SetReturnFromRun()](@ref).

""" Terminate(this::ByRef1{TApplication}, status::Int32)

# Wrapper of const char * TApplication::WorkingDirectory()
@trydoc raw"""
    WorkingDirectory(this::ByConstRef1{TApplication})::ByCopy{String}


""" WorkingDirectory(this::ByConstRef1{TApplication})

# Wrapper of TClass * TApplication::Class()
@trydoc raw"""
    TApplication!Class(this::ByRef1{TApplication})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TApplication!Class(this::ByRef1{TApplication})

# Wrapper of const char * TApplication::Class_Name()
@trydoc raw"""
    TApplication!Class_Name(this::ByRef1{TApplication})::ByCopy{String}

###Return

Name of this class
""" TApplication!Class_Name(this::ByRef1{TApplication})

# Wrapper of void TApplication::CreateApplication()
@trydoc raw"""
    TApplication!CreateApplication(this::ByRef1{TApplication})::Nothing
Static function used to create a default application environment.

""" TApplication!CreateApplication(this::ByRef1{TApplication})

# Wrapper of const char * TApplication::DeclFileName()
@trydoc raw"""
    TApplication!DeclFileName(this::ByRef1{TApplication})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TApplication!DeclFileName(this::ByRef1{TApplication})

# Wrapper of Longptr_t TApplication::ExecuteFile(const char *, Int_t *, Bool_t)
@trydoc raw"""
    TApplication!ExecuteFile(this::ByRef1{TApplication}, file::ByCopy{String}, error::ByPtr2{Int32}, keep::Bool)::Int64
Execute a file containing a C++ macro (static method).
Can be used while [TApplication](@ref) is not yet created.
""" TApplication!ExecuteFile(this::ByRef1{TApplication}, file::ByCopy{String}, error::ByPtr2{Int32}, keep::Bool)

# Wrapper of TList * TApplication::GetApplications()
@trydoc raw"""
    TApplication!GetApplications(this::ByRef1{TApplication})::CxxPtr1{TList}
Static method returning the list of available applications.

""" TApplication!GetApplications(this::ByRef1{TApplication})

# Wrapper of void TApplication::NeedGraphicsLibs()
@trydoc raw"""
    TApplication!NeedGraphicsLibs(this::ByRef1{TApplication})::Nothing
Static method.
This method should be called from static library initializers if the library needs the low level graphics system.
""" TApplication!NeedGraphicsLibs(this::ByRef1{TApplication})

# Wrapper of void TCanvas::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TCanvas}, b::ByPtr1{TBrowser})::Nothing
Browse object. May be overridden for another default action.

""" Browse(this::ByRef1{TCanvas}, b::ByPtr1{TBrowser})

# Wrapper of TVirtualPad * TCanvas::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TCanvas}, subpadnumber::Int32)::CxxPtr1{TVirtualPad}


""" cd(this::ByRef1{TCanvas}, subpadnumber::Int32)

# Wrapper of void TCanvas::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing


""" Clear(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::Cleared(TVirtualPad *)
@trydoc raw"""
    Cleared(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad})::Nothing


""" Cleared(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad})

# Wrapper of void TCanvas::ClearPadSave()
@trydoc raw"""
    ClearPadSave(this::ByRef1{TCanvas})::Nothing


""" ClearPadSave(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing


""" Close(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::Closed()
@trydoc raw"""
    Closed(this::ByRef1{TCanvas})::Nothing


""" Closed(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Constructor()
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas})::Nothing


""" Constructor(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Constructor(const char *, const char *, Int_t)
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, form::Int32)::Nothing


""" Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, form::Int32)

# Wrapper of void TCanvas::Constructor(const char *, const char *, Int_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, wtopx::Int32, wtopy::Int32, ww::Int32, wh::Int32)::Nothing


""" Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, wtopx::Int32, wtopy::Int32, ww::Int32, wh::Int32)

# Wrapper of void TCanvas::Constructor(const char *, const char *, Int_t, Int_t)
@trydoc raw"""
    Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, ww::Int32, wh::Int32)::Nothing


""" Constructor(this::ByRef1{TCanvas}, name::ByCopy{String}, title::ByCopy{String}, ww::Int32, wh::Int32)

# Wrapper of void TCanvas::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::DeleteCanvasPainter()
@trydoc raw"""
    DeleteCanvasPainter(this::ByRef1{TCanvas})::Nothing


""" DeleteCanvasPainter(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Destructor()
@trydoc raw"""
    Destructor(this::ByRef1{TCanvas})::Nothing


""" Destructor(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::DisconnectWidget()
@trydoc raw"""
    DisconnectWidget(this::ByRef1{TCanvas})::Nothing


""" DisconnectWidget(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of TObject * TCanvas::DrawClone(Option_t *)
@trydoc raw"""
    DrawClone(this::ByConstRef1{TCanvas}, option::ByCopy{String})::CxxPtr1{TObject}
Draw a clone of this object in the current selected pad with: `gROOT->SetSelectedPad(c1)`.
If pad was not selected - `gPad` will be used.
""" DrawClone(this::ByConstRef1{TCanvas}, option::ByCopy{String})

# Wrapper of TObject * TCanvas::DrawClonePad()
@trydoc raw"""
    DrawClonePad(this::ByRef1{TCanvas})::CxxPtr1{TObject}


""" DrawClonePad(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::EditorBar()
@trydoc raw"""
    EditorBar(this::ByRef1{TCanvas})::Nothing


""" EditorBar(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::EmbedInto(Int_t, Int_t, Int_t)
@trydoc raw"""
    EmbedInto(this::ByRef1{TCanvas}, winid::Int32, ww::Int32, wh::Int32)::Nothing


""" EmbedInto(this::ByRef1{TCanvas}, winid::Int32, ww::Int32, wh::Int32)

# Wrapper of void TCanvas::EnterLeave(TPad *, TObject *)
@trydoc raw"""
    EnterLeave(this::ByRef1{TCanvas}, prevSelPad::ByPtr1{TPad}, prevSelObj::ByPtr1{TObject})::Nothing


""" EnterLeave(this::ByRef1{TCanvas}, prevSelPad::ByPtr1{TPad}, prevSelObj::ByPtr1{TObject})

# Wrapper of void TCanvas::FeedbackMode(Bool_t)
@trydoc raw"""
    FeedbackMode(this::ByRef1{TCanvas}, set::Bool)::Nothing


""" FeedbackMode(this::ByRef1{TCanvas}, set::Bool)

# Wrapper of void TCanvas::Flush()
@trydoc raw"""
    Flush(this::ByRef1{TCanvas})::Nothing


""" Flush(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ForceUpdate()
@trydoc raw"""
    ForceUpdate(this::ByRef1{TCanvas})::Nothing


""" ForceUpdate(this::ByRef1{TCanvas})

# Wrapper of Bool_t TCanvas::GetAutoExec()
@trydoc raw"""
    GetAutoExec(this::ByConstRef1{TCanvas})::Bool


""" GetAutoExec(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetCanvasID()
@trydoc raw"""
    GetCanvasID(this::ByConstRef1{TCanvas})::Int32


""" GetCanvasID(this::ByConstRef1{TCanvas})

# Wrapper of void TCanvas::GetCanvasPar(Int_t &, Int_t &, UInt_t &, UInt_t &)
@trydoc raw"""
    GetCanvasPar(this::ByRef1{TCanvas}, wtopx::ByRef2{Int32}, wtopy::ByRef2{Int32}, ww::ByRef2{UInt32}, wh::ByRef2{UInt32})::Nothing


""" GetCanvasPar(this::ByRef1{TCanvas}, wtopx::ByRef2{Int32}, wtopy::ByRef2{Int32}, ww::ByRef2{UInt32}, wh::ByRef2{UInt32})

# Wrapper of TObject * TCanvas::GetClickSelected()
@trydoc raw"""
    GetClickSelected(this::ByConstRef1{TCanvas})::CxxPtr1{TObject}


""" GetClickSelected(this::ByConstRef1{TCanvas})

# Wrapper of TVirtualPad * TCanvas::GetClickSelectedPad()
@trydoc raw"""
    GetClickSelectedPad(this::ByConstRef1{TCanvas})::CxxPtr1{TVirtualPad}


""" GetClickSelectedPad(this::ByConstRef1{TCanvas})

# Wrapper of const char * TCanvas::GetDISPLAY()
@trydoc raw"""
    GetDISPLAY(this::ByConstRef1{TCanvas})::ByCopy{String}


""" GetDISPLAY(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetDoubleBuffer()
@trydoc raw"""
    GetDoubleBuffer(this::ByConstRef1{TCanvas})::Int32


""" GetDoubleBuffer(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetEvent()
@trydoc raw"""
    GetEvent(this::ByConstRef1{TCanvas})::Int32


""" GetEvent(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetEventX()
@trydoc raw"""
    GetEventX(this::ByConstRef1{TCanvas})::Int32


""" GetEventX(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetEventY()
@trydoc raw"""
    GetEventY(this::ByConstRef1{TCanvas})::Int32


""" GetEventY(this::ByConstRef1{TCanvas})

# Wrapper of Color_t TCanvas::GetHighLightColor()
@trydoc raw"""
    GetHighLightColor(this::ByConstRef1{TCanvas})::Int16


""" GetHighLightColor(this::ByConstRef1{TCanvas})

# Wrapper of TVirtualPad * TCanvas::GetPadSave()
@trydoc raw"""
    GetPadSave(this::ByConstRef1{TCanvas})::CxxPtr1{TVirtualPad}


""" GetPadSave(this::ByConstRef1{TCanvas})

# Wrapper of TObject * TCanvas::GetSelected()
@trydoc raw"""
    GetSelected(this::ByConstRef1{TCanvas})::CxxPtr1{TObject}


""" GetSelected(this::ByConstRef1{TCanvas})

# Wrapper of Option_t * TCanvas::GetSelectedOpt()
@trydoc raw"""
    GetSelectedOpt(this::ByConstRef1{TCanvas})::ByCopy{String}


""" GetSelectedOpt(this::ByConstRef1{TCanvas})

# Wrapper of TVirtualPad * TCanvas::GetSelectedPad()
@trydoc raw"""
    GetSelectedPad(this::ByConstRef1{TCanvas})::CxxPtr1{TVirtualPad}


""" GetSelectedPad(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetSelectedX()
@trydoc raw"""
    GetSelectedX(this::ByConstRef1{TCanvas})::Int32


""" GetSelectedX(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetSelectedY()
@trydoc raw"""
    GetSelectedY(this::ByConstRef1{TCanvas})::Int32


""" GetSelectedY(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::GetShowEditor()
@trydoc raw"""
    GetShowEditor(this::ByConstRef1{TCanvas})::Bool


""" GetShowEditor(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::GetShowEventStatus()
@trydoc raw"""
    GetShowEventStatus(this::ByConstRef1{TCanvas})::Bool


""" GetShowEventStatus(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::GetShowToolBar()
@trydoc raw"""
    GetShowToolBar(this::ByConstRef1{TCanvas})::Bool


""" GetShowToolBar(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::GetShowToolTips()
@trydoc raw"""
    GetShowToolTips(this::ByConstRef1{TCanvas})::Bool


""" GetShowToolTips(this::ByConstRef1{TCanvas})

# Wrapper of UInt_t TCanvas::GetWh()
@trydoc raw"""
    GetWh(this::ByConstRef1{TCanvas})::UInt32


""" GetWh(this::ByConstRef1{TCanvas})

# Wrapper of UInt_t TCanvas::GetWindowHeight()
@trydoc raw"""
    GetWindowHeight(this::ByConstRef1{TCanvas})::UInt32


""" GetWindowHeight(this::ByConstRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetWindowTopX()
@trydoc raw"""
    GetWindowTopX(this::ByRef1{TCanvas})::Int32


""" GetWindowTopX(this::ByRef1{TCanvas})

# Wrapper of Int_t TCanvas::GetWindowTopY()
@trydoc raw"""
    GetWindowTopY(this::ByRef1{TCanvas})::Int32


""" GetWindowTopY(this::ByRef1{TCanvas})

# Wrapper of UInt_t TCanvas::GetWindowWidth()
@trydoc raw"""
    GetWindowWidth(this::ByConstRef1{TCanvas})::UInt32


""" GetWindowWidth(this::ByConstRef1{TCanvas})

# Wrapper of UInt_t TCanvas::GetWw()
@trydoc raw"""
    GetWw(this::ByConstRef1{TCanvas})::UInt32


""" GetWw(this::ByConstRef1{TCanvas})

# Wrapper of Size_t TCanvas::GetXsizeReal()
@trydoc raw"""
    GetXsizeReal(this::ByConstRef1{TCanvas})::Float32


""" GetXsizeReal(this::ByConstRef1{TCanvas})

# Wrapper of Size_t TCanvas::GetXsizeUser()
@trydoc raw"""
    GetXsizeUser(this::ByConstRef1{TCanvas})::Float32


""" GetXsizeUser(this::ByConstRef1{TCanvas})

# Wrapper of Size_t TCanvas::GetYsizeReal()
@trydoc raw"""
    GetYsizeReal(this::ByConstRef1{TCanvas})::Float32


""" GetYsizeReal(this::ByConstRef1{TCanvas})

# Wrapper of Size_t TCanvas::GetYsizeUser()
@trydoc raw"""
    GetYsizeUser(this::ByConstRef1{TCanvas})::Float32


""" GetYsizeUser(this::ByConstRef1{TCanvas})

# Wrapper of void TCanvas::HandleInput(EEventType, Int_t, Int_t)
@trydoc raw"""
    HandleInput(this::ByRef1{TCanvas}, button::ByCopy{EEventType}, x::Int32, y::Int32)::Nothing


""" HandleInput(this::ByRef1{TCanvas}, button::ByCopy{EEventType}, x::Int32, y::Int32)

# Wrapper of Bool_t TCanvas::HasMenuBar()
@trydoc raw"""
    HasMenuBar(this::ByConstRef1{TCanvas})::Bool


""" HasMenuBar(this::ByConstRef1{TCanvas})

# Wrapper of void TCanvas::HighlightConnect(const char *)
@trydoc raw"""
    HighlightConnect(this::ByRef1{TCanvas}, slot::ByCopy{String})::Nothing


""" HighlightConnect(this::ByRef1{TCanvas}, slot::ByCopy{String})

# Wrapper of void TCanvas::Highlighted(TVirtualPad *, TObject *, Int_t, Int_t)
@trydoc raw"""
    Highlighted(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, x::Int32, y::Int32)::Nothing


""" Highlighted(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, x::Int32, y::Int32)

# Wrapper of void TCanvas::Iconify()
@trydoc raw"""
    Iconify(this::ByRef1{TCanvas})::Nothing


""" Iconify(this::ByRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsBatch()
@trydoc raw"""
    IsBatch(this::ByConstRef1{TCanvas})::Bool


""" IsBatch(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsDrawn()
@trydoc raw"""
    IsDrawn(this::ByConstRef1{TCanvas})::Bool


""" IsDrawn(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TCanvas})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsGrayscale()
@trydoc raw"""
    IsGrayscale(this::ByRef1{TCanvas})::Bool


""" IsGrayscale(this::ByRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsRetained()
@trydoc raw"""
    IsRetained(this::ByConstRef1{TCanvas})::Bool


""" IsRetained(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsUpdated()
@trydoc raw"""
    IsUpdated(this::ByConstRef1{TCanvas})::Bool


""" IsUpdated(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::IsWeb()
@trydoc raw"""
    IsWeb(this::ByConstRef1{TCanvas})::Bool


""" IsWeb(this::ByConstRef1{TCanvas})

# Wrapper of void TCanvas::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TCanvas}, option::ByCopy{String})::Nothing
The ls function lists the contents of a class on stdout.
Ls output is typically much less verbose then [Dump()](@ref).
""" ls(this::ByConstRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::MoveOpaque(Int_t)
@trydoc raw"""
    MoveOpaque(this::ByRef1{TCanvas}, set::Int32)::Nothing


""" MoveOpaque(this::ByRef1{TCanvas}, set::Int32)

# Wrapper of Bool_t TCanvas::OpaqueMoving()
@trydoc raw"""
    OpaqueMoving(this::ByConstRef1{TCanvas})::Bool


""" OpaqueMoving(this::ByConstRef1{TCanvas})

# Wrapper of Bool_t TCanvas::OpaqueResizing()
@trydoc raw"""
    OpaqueResizing(this::ByConstRef1{TCanvas})::Bool


""" OpaqueResizing(this::ByConstRef1{TCanvas})

# Wrapper of void TCanvas::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of TPad * TCanvas::Pick(Int_t, Int_t, TObject *)
@trydoc raw"""
    Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, prevSelObj::ByPtr1{TObject})::CxxPtr1{TPad}


""" Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, prevSelObj::ByPtr1{TObject})

# Wrapper of TPad * TCanvas::Pick(Int_t, Int_t, TObjLink *&)
@trydoc raw"""
    Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, pickobj::ByPtr1{TObjLink})::CxxPtr1{TPad}
Search for an object at pixel position px,py.
Check if point is in this pad.

If yes, check if it is in one of the sub-pads

If found in the pad, compute closest distance of approach to each primitive.

If one distance of approach is found to be within the limit Distancemaximum the corresponding primitive is selected and the routine returns.
""" Pick(this::ByRef1{TCanvas}, px::Int32, py::Int32, pickobj::ByPtr1{TObjLink})

# Wrapper of void TCanvas::Picked(TPad *, TObject *, Int_t)
@trydoc raw"""
    Picked(this::ByRef1{TCanvas}, selpad::ByPtr1{TPad}, selected::ByPtr1{TObject}, event::Int32)::Nothing


""" Picked(this::ByRef1{TCanvas}, selpad::ByPtr1{TPad}, selected::ByPtr1{TObject}, event::Int32)

# Wrapper of void TCanvas::ProcessedEvent(Int_t, Int_t, Int_t, TObject *)
@trydoc raw"""
    ProcessedEvent(this::ByRef1{TCanvas}, event::Int32, x::Int32, y::Int32, selected::ByPtr1{TObject})::Nothing


""" ProcessedEvent(this::ByRef1{TCanvas}, event::Int32, x::Int32, y::Int32, selected::ByPtr1{TObject})

# Wrapper of void TCanvas::RaiseWindow()
@trydoc raw"""
    RaiseWindow(this::ByRef1{TCanvas})::Nothing


""" RaiseWindow(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ResetDrawn()
@trydoc raw"""
    ResetDrawn(this::ByRef1{TCanvas})::Nothing


""" ResetDrawn(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ResetUpdated()
@trydoc raw"""
    ResetUpdated(this::ByRef1{TCanvas})::Nothing


""" ResetUpdated(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Resize(Option_t *)
@trydoc raw"""
    Resize(this::ByRef1{TCanvas}, option::ByCopy{String})::Nothing


""" Resize(this::ByRef1{TCanvas}, option::ByCopy{String})

# Wrapper of void TCanvas::ResizeOpaque(Int_t)
@trydoc raw"""
    ResizeOpaque(this::ByRef1{TCanvas}, set::Int32)::Nothing


""" ResizeOpaque(this::ByRef1{TCanvas}, set::Int32)

# Wrapper of void TCanvas::SaveSource(const char *, Option_t *)
@trydoc raw"""
    SaveSource(this::ByRef1{TCanvas}, filename::ByCopy{String}, option::ByCopy{String})::Nothing


""" SaveSource(this::ByRef1{TCanvas}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TCanvas::Selected(TVirtualPad *, TObject *, Int_t)
@trydoc raw"""
    Selected(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, event::Int32)::Nothing


""" Selected(this::ByRef1{TCanvas}, pad::ByPtr1{TVirtualPad}, obj::ByPtr1{TObject}, event::Int32)

# Wrapper of void TCanvas::SetBatch(Bool_t)
@trydoc raw"""
    SetBatch(this::ByRef1{TCanvas}, batch::Bool)::Nothing


""" SetBatch(this::ByRef1{TCanvas}, batch::Bool)

# Wrapper of void TCanvas::SetCanvasSize(UInt_t, UInt_t)
@trydoc raw"""
    SetCanvasSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)::Nothing


""" SetCanvasSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)

# Wrapper of void TCanvas::SetClickSelected(TObject *)
@trydoc raw"""
    SetClickSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})::Nothing


""" SetClickSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})

# Wrapper of void TCanvas::SetClickSelectedPad(TPad *)
@trydoc raw"""
    SetClickSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})::Nothing


""" SetClickSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})

# Wrapper of void TCanvas::SetCursor(ECursor)
@trydoc raw"""
    SetCursor(this::ByRef1{TCanvas}, cursor::ByCopy{ECursor})::Nothing


""" SetCursor(this::ByRef1{TCanvas}, cursor::ByCopy{ECursor})

# Wrapper of void TCanvas::SetDoubleBuffer(Int_t)
@trydoc raw"""
    SetDoubleBuffer(this::ByRef1{TCanvas}, mode::Int32)::Nothing


""" SetDoubleBuffer(this::ByRef1{TCanvas}, mode::Int32)

# Wrapper of void TCanvas::SetFixedAspectRatio(Bool_t)
@trydoc raw"""
    SetFixedAspectRatio(this::ByRef1{TCanvas}, fixed::Bool)::Nothing


""" SetFixedAspectRatio(this::ByRef1{TCanvas}, fixed::Bool)

# Wrapper of void TCanvas::SetGrayscale(Bool_t)
@trydoc raw"""
    SetGrayscale(this::ByRef1{TCanvas}, set::Bool)::Nothing


""" SetGrayscale(this::ByRef1{TCanvas}, set::Bool)

# Wrapper of void TCanvas::SetHighLightColor(Color_t)
@trydoc raw"""
    SetHighLightColor(this::ByRef1{TCanvas}, col::Int16)::Nothing


""" SetHighLightColor(this::ByRef1{TCanvas}, col::Int16)

# Wrapper of void TCanvas::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TCanvas}, name::ByCopy{String})::Nothing


""" SetName(this::ByRef1{TCanvas}, name::ByCopy{String})

# Wrapper of void TCanvas::SetPadSave(TPad *)
@trydoc raw"""
    SetPadSave(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})::Nothing


""" SetPadSave(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})

# Wrapper of bool TCanvas::SetRealAspectRatio(const Int_t)
@trydoc raw"""
    SetRealAspectRatio(this::ByRef1{TCanvas}, axis::ByCopy{Int32})::Bool


""" SetRealAspectRatio(this::ByRef1{TCanvas}, axis::ByCopy{Int32})

# Wrapper of void TCanvas::SetRetained(Bool_t)
@trydoc raw"""
    SetRetained(this::ByRef1{TCanvas}, retained::Bool)::Nothing


""" SetRetained(this::ByRef1{TCanvas}, retained::Bool)

# Wrapper of void TCanvas::SetSelected(TObject *)
@trydoc raw"""
    SetSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})::Nothing


""" SetSelected(this::ByRef1{TCanvas}, obj::ByPtr1{TObject})

# Wrapper of void TCanvas::SetSelectedPad(TPad *)
@trydoc raw"""
    SetSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})::Nothing


""" SetSelectedPad(this::ByRef1{TCanvas}, pad::ByPtr1{TPad})

# Wrapper of void TCanvas::SetSupportGL(Bool_t)
@trydoc raw"""
    SetSupportGL(this::ByRef1{TCanvas}, support::Bool)::Nothing


""" SetSupportGL(this::ByRef1{TCanvas}, support::Bool)

# Wrapper of void TCanvas::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TCanvas}, title::ByCopy{String})::Nothing


""" SetTitle(this::ByRef1{TCanvas}, title::ByCopy{String})

# Wrapper of void TCanvas::SetWindowPosition(Int_t, Int_t)
@trydoc raw"""
    SetWindowPosition(this::ByRef1{TCanvas}, x::Int32, y::Int32)::Nothing


""" SetWindowPosition(this::ByRef1{TCanvas}, x::Int32, y::Int32)

# Wrapper of void TCanvas::SetWindowSize(UInt_t, UInt_t)
@trydoc raw"""
    SetWindowSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)::Nothing


""" SetWindowSize(this::ByRef1{TCanvas}, ww::UInt32, wh::UInt32)

# Wrapper of void TCanvas::Show()
@trydoc raw"""
    Show(this::ByRef1{TCanvas})::Nothing


""" Show(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Size(Float_t, Float_t)
@trydoc raw"""
    Size(this::ByRef1{TCanvas}, xsizeuser::Float32, ysizeuser::Float32)::Nothing


""" Size(this::ByRef1{TCanvas}, xsizeuser::Float32, ysizeuser::Float32)

# Wrapper of void TCanvas::ToggleAutoExec()
@trydoc raw"""
    ToggleAutoExec(this::ByRef1{TCanvas})::Nothing


""" ToggleAutoExec(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleEditor()
@trydoc raw"""
    ToggleEditor(this::ByRef1{TCanvas})::Nothing


""" ToggleEditor(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleEventStatus()
@trydoc raw"""
    ToggleEventStatus(this::ByRef1{TCanvas})::Nothing


""" ToggleEventStatus(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleToolBar()
@trydoc raw"""
    ToggleToolBar(this::ByRef1{TCanvas})::Nothing


""" ToggleToolBar(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::ToggleToolTips()
@trydoc raw"""
    ToggleToolTips(this::ByRef1{TCanvas})::Nothing


""" ToggleToolTips(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::Update()
@trydoc raw"""
    Update(this::ByRef1{TCanvas})::Nothing


""" Update(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::UpdateAsync()
@trydoc raw"""
    UpdateAsync(this::ByRef1{TCanvas})::Nothing


""" UpdateAsync(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TCanvas})::Nothing
Set current style settings in this object This function is called when either [TCanvas!UseCurrentStyle](@ref) or [TROOT!ForceStyle](@ref) have been invoked.

""" UseCurrentStyle(this::ByRef1{TCanvas})

# Wrapper of Bool_t TCanvas::UseGL()
@trydoc raw"""
    UseGL(this::ByConstRef1{TCanvas})::Bool


""" UseGL(this::ByConstRef1{TCanvas})

# Wrapper of TCanvas * TCanvas::MakeDefCanvas()
@trydoc raw"""
    TCanvas!MakeDefCanvas(this::ByRef1{TCanvas})::CxxPtr1{TCanvas}


""" TCanvas!MakeDefCanvas(this::ByRef1{TCanvas})

# Wrapper of void TCanvas::SetFolder(Bool_t)
@trydoc raw"""
    TCanvas!SetFolder(this::ByRef1{TCanvas}, isfolder::Bool)::Nothing


""" TCanvas!SetFolder(this::ByRef1{TCanvas}, isfolder::Bool)

# Wrapper of Bool_t TCanvas::SupportAlpha()
@trydoc raw"""
    TCanvas!SupportAlpha(this::ByRef1{TCanvas})::Bool


""" TCanvas!SupportAlpha(this::ByRef1{TCanvas})

# Wrapper of TClass * TProcessEventTimer::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TProcessEventTimer})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TProcessEventTimer})

# Wrapper of Bool_t TProcessEventTimer::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TProcessEventTimer})::Bool
This method must be overridden to handle object notification (the base implementation is no-op).
Different objects in [ROOT](@ref) use the `Notify` method for different purposes, in coordination with other objects that call this method at the appropriate time.

For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a callback mechanism to inform interested parties when it switches to a new sub-tree.
""" Notify(this::ByRef1{TProcessEventTimer})

# Wrapper of Bool_t TProcessEventTimer::ProcessEvents()
@trydoc raw"""
    ProcessEvents(this::ByRef1{TProcessEventTimer})::Bool
Process events if timer did time out.
Returns kTRUE if interrupt flag is set (by hitting a key in the canvas or selecting the Interrupt menu item in canvas or some other action).
""" ProcessEvents(this::ByRef1{TProcessEventTimer})

# Wrapper of void TProcessEventTimer::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TProcessEventTimer}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TProcessEventTimer}, ::ByRef1{TBuffer})

# Wrapper of void TProcessEventTimer::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TProcessEventTimer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TProcessEventTimer}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of TClass * TProcessEventTimer::Class()
@trydoc raw"""
    TProcessEventTimer!Class(this::ByRef1{TProcessEventTimer})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TProcessEventTimer!Class(this::ByRef1{TProcessEventTimer})

# Wrapper of const char * TProcessEventTimer::Class_Name()
@trydoc raw"""
    TProcessEventTimer!Class_Name(this::ByRef1{TProcessEventTimer})::ByCopy{String}

###Return

Name of this class
""" TProcessEventTimer!Class_Name(this::ByRef1{TProcessEventTimer})

# Wrapper of const char * TProcessEventTimer::DeclFileName()
@trydoc raw"""
    TProcessEventTimer!DeclFileName(this::ByRef1{TProcessEventTimer})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TProcessEventTimer!DeclFileName(this::ByRef1{TProcessEventTimer})

# Wrapper of void TSystem::Abort(int)
@trydoc raw"""
    Abort(this::ByRef1{TSystem}, code::Int32)::Nothing
Abort the application.

""" Abort(this::ByRef1{TSystem}, code::Int32)

# Wrapper of int TSystem::AcceptConnection(int)
@trydoc raw"""
    AcceptConnection(this::ByRef1{TSystem}, sock::Int32)::Int32
Accept a connection.

""" AcceptConnection(this::ByRef1{TSystem}, sock::Int32)

# Wrapper of Bool_t TSystem::AccessPathName(const char *, EAccessMode)
@trydoc raw"""
    AccessPathName(this::ByRef1{TSystem}, path::ByCopy{String}, mode::ByCopy{EAccessMode})::Bool
Returns FALSE if one can access a file using the specified access mode.
The file name must not contain any special shell characters line ~ or $, in those cases first call [ExpandPathName()](@ref). Attention, bizarre convention of return value!!
""" AccessPathName(this::ByRef1{TSystem}, path::ByCopy{String}, mode::ByCopy{EAccessMode})

# Wrapper of void TSystem::AddDynamicPath(const char *)
@trydoc raw"""
    AddDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})::Nothing
Add a new directory to the dynamic path.

""" AddDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::AddFileHandler(TFileHandler *)
@trydoc raw"""
    AddFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})::Nothing
Add a file handler to the list of system file handlers.
Only adds the handler if it is not already in the list of file handlers.
""" AddFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})

# Wrapper of void TSystem::AddIncludePath(const char *)
@trydoc raw"""
    AddIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})::Nothing
Add a directory to the already set include path.
## Arguments

- **`includePath`** [in] 
    The path to the directory. 
    

###Note

This interface is mostly relevant for ACLiC and it does not inform gInterpreter for this include path. If the TInterpreter needs to know about the include path please use TInterpreter!AddIncludePath() . 

###Warning

The path should thestart with the -I prefix, i.e. gSystem->AddIncludePath("-I /path/to/my/includes").
""" AddIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})

# Wrapper of void TSystem::AddLinkedLibs(const char *)
@trydoc raw"""
    AddLinkedLibs(this::ByRef1{TSystem}, linkedLib::ByCopy{String})::Nothing
Add linkedLib to already set linked libs.

""" AddLinkedLibs(this::ByRef1{TSystem}, linkedLib::ByCopy{String})

# Wrapper of void TSystem::AddSignalHandler(TSignalHandler *)
@trydoc raw"""
    AddSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})::Nothing
Add a signal handler to list of system signal handlers.
Only adds the handler if it is not already in the list of signal handlers.
""" AddSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})

# Wrapper of void TSystem::AddStdExceptionHandler(TStdExceptionHandler *)
@trydoc raw"""
    AddStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})::Nothing
Add an exception handler to list of system exception handlers.
Only adds the handler if it is not already in the list of exception handlers.
""" AddStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})

# Wrapper of void TSystem::AddTimer(TTimer *)
@trydoc raw"""
    AddTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})::Nothing
Add timer to list of system timers.

""" AddTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})

# Wrapper of int TSystem::AnnounceUnixService(const char *, int)
@trydoc raw"""
    AnnounceUnixService(this::ByRef1{TSystem}, sockpath::ByCopy{String}, backlog::Int32)::Int32
Announce unix domain service.

""" AnnounceUnixService(this::ByRef1{TSystem}, sockpath::ByCopy{String}, backlog::Int32)

# Wrapper of int TSystem::AnnounceUnixService(int, int)
@trydoc raw"""
    AnnounceUnixService(this::ByRef1{TSystem}, port::Int32, backlog::Int32)::Int32
Announce unix domain service.

""" AnnounceUnixService(this::ByRef1{TSystem}, port::Int32, backlog::Int32)

# Wrapper of const char * TSystem::BaseName(const char *)
@trydoc raw"""
    BaseName(this::ByRef1{TSystem}, pathname::ByCopy{String})::ByCopy{String}
Base name of a file name. Base name of /user/root is root.

""" BaseName(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::Beep(Int_t, Int_t, Bool_t)
@trydoc raw"""
    Beep(this::ByRef1{TSystem}, freq::Int32, duration::Int32, setDefault::Bool)::Nothing
Beep for duration milliseconds with a tone of frequency freq.
Defaults to printing the `\a` character to stdout. If freq or duration is <0 respectively, use default value. If setDefault is set, only set the frequency and duration as new defaults, but don't beep. If default freq or duration is <0, never beep (silence)
""" Beep(this::ByRef1{TSystem}, freq::Int32, duration::Int32, setDefault::Bool)

# Wrapper of Bool_t TSystem::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TSystem}, path::ByCopy{String})::Bool


""" cd(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of Bool_t TSystem::ChangeDirectory(const char *)
@trydoc raw"""
    ChangeDirectory(this::ByRef1{TSystem}, path::ByCopy{String})::Bool
Change directory.

""" ChangeDirectory(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of int TSystem::Chmod(const char *, UInt_t)
@trydoc raw"""
    Chmod(this::ByRef1{TSystem}, file::ByCopy{String}, mode::UInt32)::Int32
Set the file permission bits. Returns -1 in case or error, 0 otherwise.

""" Chmod(this::ByRef1{TSystem}, file::ByCopy{String}, mode::UInt32)

# Wrapper of void TSystem::CleanCompiledMacros()
@trydoc raw"""
    CleanCompiledMacros(this::ByRef1{TSystem})::Nothing
Remove the shared libs produced by the [CompileMacro()](@ref) function, together with their rootmaps, linkdefs, and pcms (and some more on Windows).

""" CleanCompiledMacros(this::ByRef1{TSystem})

# Wrapper of void TSystem::CloseConnection(int, Bool_t)
@trydoc raw"""
    CloseConnection(this::ByRef1{TSystem}, sock::Int32, force::Bool)::Nothing
Close socket connection.

""" CloseConnection(this::ByRef1{TSystem}, sock::Int32, force::Bool)

# Wrapper of void TSystem::Closelog()
@trydoc raw"""
    Closelog(this::ByRef1{TSystem})::Nothing
Close connection to system log daemon.

""" Closelog(this::ByRef1{TSystem})

# Wrapper of int TSystem::ClosePipe(FILE *)
@trydoc raw"""
    ClosePipe(this::ByRef1{TSystem}, pipe::ByPtr1{FILE})::Int32
Close the pipe.

""" ClosePipe(this::ByRef1{TSystem}, pipe::ByPtr1{FILE})

# Wrapper of int TSystem::CompileMacro(const char *, Option_t *, const char *, const char *, UInt_t)
@trydoc raw"""
    CompileMacro(this::ByRef1{TSystem}, filename::ByCopy{String}, opt::ByCopy{String}, library_name::ByCopy{String}, build_dir::ByCopy{String}, dirmode::UInt32)::Int32
This method compiles and loads a shared library containing the code from the file "filename".
The return value is true (1) in case of success and false (0) in case of error.

The possible options are:

- k : keep the shared library after the session theend.
- f : force recompilation.
- g : compile with debug symbol
- O : optimized the code
- c : compile only, do not attempt to load the library.
- s : silence all informational output
- v : output all information output
- d : debug ACLiC, keep all the output files.
- - : if buildir is set, use a flat structure (see buildir below)

If library_specified is specified, CompileMacro generates the file "library_specified".soext where soext is the shared library extension for the current platform.

If build_dir is specified, it is used as an alternative 'root' for the generation of the shared library. The library is stored in a sub-directories of 'build_dir' including the full pathname of the script unless a flat directory structure is requested ('-' option). With the '-' option the libraries are created directly in the directory 'build_dir'; in particular this means that 2 scripts with the same name in different source directory will over-write each other's library. See also [TSystem!SetBuildDir](@ref).

If dirmode is not zero and we need to create the target directory, the file mode bit will be change to 'dirmode' using chmod.

If library_specified is not specified, CompileMacro generate a default name for library by taking the name of the file "filename" but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platform, hsimple.cxx will generate hsimple_cxx.so

It uses the directive fMakeSharedLibs to create a shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to [TSystem!Exec](@ref), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $DepLibs, $ExeName and $ObjectFiles. See [SetMakeSharedLib()](@ref) for more information on those variables.

This method is used to implement the following feature:

Synopsis:

The purpose of this addition is to allow the user to use an external compiler to create a shared library from its C++ macro (scripts). Currently in order to execute a script, a user has to type at the root prompt 

    .X myfunc.C(arg1,arg2)

(C++ version of the code)

 We allow them to type: 

    .X myfunc.C++(arg1,arg2)

(C++ version of the code)

 or 

    .X myfunc.C+(arg1,arg2)

(C++ version of the code)

 In which case an external compiler will be called to create a shared library. This shared library will then be loaded and the function myfunc will be called with the two arguments. With '++' the shared library is always recompiled. With '+' the shared library is recompiled only if it does not exist yet or the macro file is newer than the shared library.

Of course the + and ++ notation is supported in similar way for .x and .L.

Through the function [TSystem!SetMakeSharedLib()](@ref), the user will be able to indicate, with shell commands, how to build a shared library (a good default will be provided). The most common change, namely where to find header files, will be available through the function [TSystem!SetIncludePath()](@ref). A good default will be provided so that a typical user session should be at most: 

    root[1] gSystem->SetIncludePath("-I$ROOTSYS/include
    -I$HOME/mypackage/include");
    root[2] .x myfunc.C++(10,20);

(C++ version of the code)

 The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.

To support this we provide a [TSystem!SetMakeExe()](@ref) function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and [TSystem!Load()](@ref) is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to [TSystem!SetLinkedLibs()](@ref)).

To simplify customization we could also add to the .rootrc support for the variables 

    Unix.*.Root.IncludePath:     -I$ROOTSYS/include
    WinNT.*.Root.IncludePath:    -I%ROOTSYS%/include
    Unix.*.Root.LinkedLibs:      -L$ROOTSYS/lib -lBase ....
    WinNT.*.Root.LinkedLibs:     %ROOTSYS%/lib/*.lib msvcrt.lib ....

(C++ version of the code)

 And also support for MakeSharedLibs() and MakeExe().

(the ... have to be replaced by the actual values and are here only to shorten this comment).

Note that the default behavior is to remove libraries when closing [ROOT](@ref), ie [TSystem!CleanCompiledMacros()](@ref) is called in the [TROOT](@ref) destructor. The default behavior of .L script.C+ is the opposite one, leaving things after closing, without removing. In other words, .L always passes the 'k' option behind the scenes.
""" CompileMacro(this::ByRef1{TSystem}, filename::ByCopy{String}, opt::ByCopy{String}, library_name::ByCopy{String}, build_dir::ByCopy{String}, dirmode::UInt32)

# Wrapper of char * TSystem::ConcatFileName(const char *, const char *)
@trydoc raw"""
    ConcatFileName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByCopy{String})::ByCopy{Union{String, Vector{CxxChar}}}
Concatenate a directory and a file name. User must delete returned string.

""" ConcatFileName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByCopy{String})

# Wrapper of int TSystem::CopyFile(const char *, const char *, Bool_t)
@trydoc raw"""
    CopyFile(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String}, overwrite::Bool)::Int32
Copy a file.
If overwrite is true and file already exists the file will be overwritten. Returns 0 when successful, -1 in case of file open failure, -2 in case the file already exists and overwrite was false and -3 in case of error during copy.
""" CopyFile(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String}, overwrite::Bool)

# Wrapper of const char * TSystem::DirName(const char *)
@trydoc raw"""
    DirName(this::ByRef1{TSystem}, pathname::ByCopy{String})::ByCopy{String}
Return the directory name in pathname.
DirName of /user/root is /user. In case no dirname is specified "." is returned.
""" DirName(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::DispatchOneEvent(Bool_t)
@trydoc raw"""
    DispatchOneEvent(this::ByRef1{TSystem}, pendingOnly::Bool)::Nothing
Dispatch a single event.

""" DispatchOneEvent(this::ByRef1{TSystem}, pendingOnly::Bool)

# Wrapper of char * TSystem::DynamicPathName(const char *, Bool_t)
@trydoc raw"""
    DynamicPathName(this::ByRef1{TSystem}, lib::ByCopy{String}, quiet::Bool)::ByCopy{Union{String, Vector{CxxChar}}}
Find a dynamic library called lib using the system search paths.
Appends known extensions if needed. Returned string must be deleted by the user!
""" DynamicPathName(this::ByRef1{TSystem}, lib::ByCopy{String}, quiet::Bool)

# Wrapper of Int_t TSystem::Exec(const char *)
@trydoc raw"""
    Exec(this::ByRef1{TSystem}, shellcmd::ByCopy{String})::Int32
Execute a command.

""" Exec(this::ByRef1{TSystem}, shellcmd::ByCopy{String})

# Wrapper of void TSystem::Exit(int, Bool_t)
@trydoc raw"""
    Exit(this::ByRef1{TSystem}, code::Int32, mode::Bool)::Nothing
Exit the application.

""" Exit(this::ByRef1{TSystem}, code::Int32, mode::Bool)

# Wrapper of void TSystem::ExitLoop()
@trydoc raw"""
    ExitLoop(this::ByRef1{TSystem})::Nothing
Exit from event loop.

""" ExitLoop(this::ByRef1{TSystem})

# Wrapper of char * TSystem::ExpandPathName(const char *)
@trydoc raw"""
    ExpandPathName(this::ByRef1{TSystem}, path::ByCopy{String})::ByCopy{Union{String, Vector{CxxChar}}}
Expand a pathname getting rid of special shell characters like ~.
$, etc. For Unix/Win32 compatibility use  instead of $XXX when using environment variables in a pathname. If compatibility is not an issue you can use on Unix directly $XXX. The user must delete returned string.
""" ExpandPathName(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of Bool_t TSystem::ExpandPathName(TString &)
@trydoc raw"""
    ExpandPathName(this::ByRef1{TSystem}, path::ByRef1{TString})::Bool
Expand a pathname getting rid of special shell characters like ~.
$, etc. For Unix/Win32 compatibility use  instead of $XXX when using environment variables in a pathname. If compatibility is not an issue you can use on Unix directly $XXX.
""" ExpandPathName(this::ByRef1{TSystem}, path::ByRef1{TString})

# Wrapper of const char * TSystem::FindDynamicLibrary(TString &, Bool_t)
@trydoc raw"""
    FindDynamicLibrary(this::ByRef1{TSystem}, lib::ByRef1{TString}, quiet::Bool)::ByCopy{String}
Find a dynamic library using the system search paths.
lib will be updated to contain the absolute filename if found. Returns lib if found, or NULL if a library called lib was not found. This function does not open the library.
""" FindDynamicLibrary(this::ByRef1{TSystem}, lib::ByRef1{TString}, quiet::Bool)

# Wrapper of const char * TSystem::FindFile(const char *, TString &, EAccessMode)
@trydoc raw"""
    FindFile(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByRef1{TString}, mode::ByCopy{EAccessMode})::ByCopy{String}
Find location of file in a search path.
Return value points to [TString](@ref) for compatibility with [Which(const char *, const char *, EAccessMode)](@ref). Returns 0 in case file is not found.
""" FindFile(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByRef1{TString}, mode::ByCopy{EAccessMode})

# Wrapper of void TSystem::FreeDirectory(void *)
@trydoc raw"""
    FreeDirectory(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})::Nothing
Free a directory.

""" FreeDirectory(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})

# Wrapper of Int_t TSystem::GetAclicProperties()
@trydoc raw"""
    GetAclicProperties(this::ByConstRef1{TSystem})::Int32
Return the ACLiC properties field.
See EAclicProperties for details on the semantic of each bit.
""" GetAclicProperties(this::ByConstRef1{TSystem})

# Wrapper of void TSystem::GetBeepDefaults(Int_t &, Int_t &)
@trydoc raw"""
    GetBeepDefaults(this::ByConstRef1{TSystem}, freq::ByRef2{Int32}, duration::ByRef2{Int32})::Nothing


""" GetBeepDefaults(this::ByConstRef1{TSystem}, freq::ByRef2{Int32}, duration::ByRef2{Int32})

# Wrapper of const char * TSystem::GetBuildArch()
@trydoc raw"""
    GetBuildArch(this::ByConstRef1{TSystem})::ByCopy{String}
Return the build architecture.

""" GetBuildArch(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetBuildCompiler()
@trydoc raw"""
    GetBuildCompiler(this::ByConstRef1{TSystem})::ByCopy{String}
Return the build compiler.

""" GetBuildCompiler(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetBuildCompilerVersion()
@trydoc raw"""
    GetBuildCompilerVersion(this::ByConstRef1{TSystem})::ByCopy{String}
Return the build compiler version.

""" GetBuildCompilerVersion(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetBuildCompilerVersionStr()
@trydoc raw"""
    GetBuildCompilerVersionStr(this::ByConstRef1{TSystem})::ByCopy{String}
Return the build compiler version identifier string.

""" GetBuildCompilerVersionStr(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetBuildDir()
@trydoc raw"""
    GetBuildDir(this::ByConstRef1{TSystem})::ByCopy{String}
Return the path of the build directory.

""" GetBuildDir(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetBuildNode()
@trydoc raw"""
    GetBuildNode(this::ByConstRef1{TSystem})::ByCopy{String}
Return the build node name.

""" GetBuildNode(this::ByConstRef1{TSystem})

# Wrapper of int TSystem::GetCpuInfo(CpuInfo_t *, Int_t)
@trydoc raw"""
    GetCpuInfo(this::ByConstRef1{TSystem}, info::ByPtr1{CpuInfo_t}, sampleTime::Int32)::Int32
Returns cpu load average and load info into the [CpuInfo_t](@ref) structure.
Returns -1 in case of error, 0 otherwise. Use sampleTime to set the interval over which the CPU load will be measured, in ms (default 1000).
""" GetCpuInfo(this::ByConstRef1{TSystem}, info::ByPtr1{CpuInfo_t}, sampleTime::Int32)

# Wrapper of Int_t TSystem::GetCryptoRandom(void *, Int_t)
@trydoc raw"""
    GetCryptoRandom(this::ByRef1{TSystem}, buf::ByPtr2{Nothing}, len::Int32)::Int32
Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error.

""" GetCryptoRandom(this::ByRef1{TSystem}, buf::ByPtr2{Nothing}, len::Int32)

# Wrapper of const char * TSystem::GetDirEntry(void *)
@trydoc raw"""
    GetDirEntry(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})::ByCopy{String}
Get a directory entry. Returns 0 if no more entries.

""" GetDirEntry(this::ByRef1{TSystem}, dirp::ByPtr2{Nothing})

# Wrapper of TString TSystem::GetDirName(const char *)
@trydoc raw"""
    GetDirName(this::ByRef1{TSystem}, pathname::ByCopy{String})::ByCopy{TString}
Return the directory name in pathname.
DirName of /user/root is /user. DirName of /user/root/ is also /user. In case no dirname is specified "." is returned.
""" GetDirName(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void * TSystem::GetDirPtr()
@trydoc raw"""
    GetDirPtr(this::ByConstRef1{TSystem})::CxxPtr2{Nothing}


""" GetDirPtr(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetDynamicPath()
@trydoc raw"""
    GetDynamicPath(this::ByRef1{TSystem})::ByCopy{String}
Return the dynamic path (used to find shared libraries).

""" GetDynamicPath(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::GetEffectiveGid()
@trydoc raw"""
    GetEffectiveGid(this::ByRef1{TSystem})::Int32
Returns the effective group id.
The effective group id corresponds to the set id bit on the file being executed.
""" GetEffectiveGid(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::GetEffectiveUid()
@trydoc raw"""
    GetEffectiveUid(this::ByRef1{TSystem})::Int32
Returns the effective user id.
The effective id corresponds to the set id bit on the file being executed.
""" GetEffectiveUid(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::Getenv(const char *)
@trydoc raw"""
    Getenv(this::ByRef1{TSystem}, env::ByCopy{String})::ByCopy{String}
Get environment variable.

""" Getenv(this::ByRef1{TSystem}, env::ByCopy{String})

# Wrapper of const char * TSystem::GetError()
@trydoc raw"""
    GetError(this::ByRef1{TSystem})::ByCopy{String}
Return system error string.

""" GetError(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::GetErrorStr()
@trydoc raw"""
    GetErrorStr(this::ByConstRef1{TSystem})::ByCopy{String}


""" GetErrorStr(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetFlagsDebug()
@trydoc raw"""
    GetFlagsDebug(this::ByConstRef1{TSystem})::ByCopy{String}
Return the debug flags.

""" GetFlagsDebug(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetFlagsOpt()
@trydoc raw"""
    GetFlagsOpt(this::ByConstRef1{TSystem})::ByCopy{String}
Return the optimization flags.

""" GetFlagsOpt(this::ByConstRef1{TSystem})

# Wrapper of Int_t TSystem::GetFPEMask()
@trydoc raw"""
    GetFPEMask(this::ByRef1{TSystem})::Int32
Return the bitmap of conditions that trigger a floating point exception.

""" GetFPEMask(this::ByRef1{TSystem})

# Wrapper of int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *)
@trydoc raw"""
    GetFsInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, bsize::ByPtr2{Int64}, blocks::ByPtr2{Int64}, bfree::ByPtr2{Int64})::Int32
Get info about a file system: fs type, block size, number of blocks, number of free blocks.

""" GetFsInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, bsize::ByPtr2{Int64}, blocks::ByPtr2{Int64}, bfree::ByPtr2{Int64})

# Wrapper of Int_t TSystem::GetGid(const char *)
@trydoc raw"""
    GetGid(this::ByRef1{TSystem}, group::ByCopy{String})::Int32
Returns the group's id. If group = 0, returns current user's group.

""" GetGid(this::ByRef1{TSystem}, group::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetGroupInfo(const char *)
@trydoc raw"""
    GetGroupInfo(this::ByRef1{TSystem}, group::ByCopy{String})::CxxPtr1{UserGroup_t}
Returns all group info in the [UserGroup_t](@ref) structure.
The only active fields in the [UserGroup_t](@ref) structure for this call are:

- fGid and fGroup If group = 0, returns current user's group. The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetGroupInfo(this::ByRef1{TSystem}, group::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetGroupInfo(Int_t)
@trydoc raw"""
    GetGroupInfo(this::ByRef1{TSystem}, gid::Int32)::CxxPtr1{UserGroup_t}
Returns all group info in the [UserGroup_t](@ref) structure.
The only active fields in the [UserGroup_t](@ref) structure for this call are:

- fGid and fGroup The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetGroupInfo(this::ByRef1{TSystem}, gid::Int32)

# Wrapper of TInetAddress TSystem::GetHostByName(const char *)
@trydoc raw"""
    GetHostByName(this::ByRef1{TSystem}, server::ByCopy{String})::ByCopy{TInetAddress}
Get Internet Protocol (IP) address of host.

""" GetHostByName(this::ByRef1{TSystem}, server::ByCopy{String})

# Wrapper of const char * TSystem::GetIncludePath()
@trydoc raw"""
    GetIncludePath(this::ByRef1{TSystem})::ByCopy{String}
Get the list of include path.

""" GetIncludePath(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::GetLibraries(const char *, const char *, Bool_t)
@trydoc raw"""
    GetLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String}, option::ByCopy{String}, isRegexp::Bool)::ByCopy{String}
Return a space separated list of loaded shared libraries.
Regexp is a wildcard expression, see TRegexp!MakeWildcard. This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of:

- S: shared libraries loaded at the thestart of the executable, because they were specified on the link line.
- D: shared libraries dynamically loaded after the thestart of the program.
- L: this option is ignored, and available for backward compatibility.
""" GetLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String}, option::ByCopy{String}, isRegexp::Bool)

# Wrapper of const char * TSystem::GetLinkdefSuffix()
@trydoc raw"""
    GetLinkdefSuffix(this::ByConstRef1{TSystem})::ByCopy{String}
Return the linkdef suffix chosen by the user for ACLiC.
See [TSystem!CompileMacro](@ref) for more details.
""" GetLinkdefSuffix(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetLinkedLibs()
@trydoc raw"""
    GetLinkedLibs(this::ByConstRef1{TSystem})::ByCopy{String}
Return the list of library linked to this executable.
See [TSystem!CompileMacro](@ref) for more details.
""" GetLinkedLibs(this::ByConstRef1{TSystem})

# Wrapper of TSeqCollection * TSystem::GetListOfFileHandlers()
@trydoc raw"""
    GetListOfFileHandlers(this::ByConstRef1{TSystem})::CxxPtr1{TSeqCollection}


""" GetListOfFileHandlers(this::ByConstRef1{TSystem})

# Wrapper of TSeqCollection * TSystem::GetListOfSignalHandlers()
@trydoc raw"""
    GetListOfSignalHandlers(this::ByConstRef1{TSystem})::CxxPtr1{TSeqCollection}


""" GetListOfSignalHandlers(this::ByConstRef1{TSystem})

# Wrapper of TSeqCollection * TSystem::GetListOfStdExceptionHandlers()
@trydoc raw"""
    GetListOfStdExceptionHandlers(this::ByConstRef1{TSystem})::CxxPtr1{TSeqCollection}


""" GetListOfStdExceptionHandlers(this::ByConstRef1{TSystem})

# Wrapper of TList * TSystem::GetListOfTimers()
@trydoc raw"""
    GetListOfTimers(this::ByConstRef1{TSystem})::CxxPtr1{TList}


""" GetListOfTimers(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetMakeExe()
@trydoc raw"""
    GetMakeExe(this::ByConstRef1{TSystem})::ByCopy{String}
Return the command line use to make an executable.
See [TSystem!CompileMacro](@ref) for more details.
""" GetMakeExe(this::ByConstRef1{TSystem})

# Wrapper of const char * TSystem::GetMakeSharedLib()
@trydoc raw"""
    GetMakeSharedLib(this::ByConstRef1{TSystem})::ByCopy{String}
Return the command line use to make a shared library.
See [TSystem!CompileMacro](@ref) for more details.
""" GetMakeSharedLib(this::ByConstRef1{TSystem})

# Wrapper of int TSystem::GetMemInfo(MemInfo_t *)
@trydoc raw"""
    GetMemInfo(this::ByConstRef1{TSystem}, info::ByPtr1{MemInfo_t})::Int32
Returns ram and swap memory usage info into the [MemInfo_t](@ref) structure.
Returns -1 in case of error, 0 otherwise.
""" GetMemInfo(this::ByConstRef1{TSystem}, info::ByPtr1{MemInfo_t})

# Wrapper of const char * TSystem::GetObjExt()
@trydoc raw"""
    GetObjExt(this::ByConstRef1{TSystem})::ByCopy{String}
Get the object file extension.

""" GetObjExt(this::ByConstRef1{TSystem})

# Wrapper of int TSystem::GetPathInfo(const char *, FileStat_t &)
@trydoc raw"""
    GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, buf::ByRef1{FileStat_t})::Int32
Get info about a file.
Info is returned in the form of a [FileStat_t](@ref) structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed.
""" GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, buf::ByRef1{FileStat_t})

# Wrapper of int TSystem::GetPathInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *)
@trydoc raw"""
    GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, size::ByPtr2{Int64}, flags::ByPtr2{Int64}, modtime::ByPtr2{Int64})::Int32
Get info about a file: id, size, flags, modification time.
- Id is (statbuf.st_dev << 24) + statbuf.st_ino
- Size is the file size
- Flags is file type: 0 is regular file, bit 0 set executable, bit 1 set directory, bit 2 set special file (socket, fifo, pipe, etc.) Modtime is modification time. The function returns 0 in case of success and 1 if the file could not be stat'ed.
""" GetPathInfo(this::ByRef1{TSystem}, path::ByCopy{String}, id::ByPtr2{Int64}, size::ByPtr2{Int64}, flags::ByPtr2{Int64}, modtime::ByPtr2{Int64})

# Wrapper of TInetAddress TSystem::GetPeerName(int)
@trydoc raw"""
    GetPeerName(this::ByRef1{TSystem}, sock::Int32)::ByCopy{TInetAddress}
Get Internet Protocol (IP) address of remote host and port #.

""" GetPeerName(this::ByRef1{TSystem}, sock::Int32)

# Wrapper of int TSystem::GetPid()
@trydoc raw"""
    GetPid(this::ByRef1{TSystem})::Int32
Get process id.

""" GetPid(this::ByRef1{TSystem})

# Wrapper of int TSystem::GetProcInfo(ProcInfo_t *)
@trydoc raw"""
    GetProcInfo(this::ByConstRef1{TSystem}, info::ByPtr1{ProcInfo_t})::Int32
Returns cpu and memory used by this process into the [ProcInfo_t](@ref) structure.
Returns -1 in case of error, 0 otherwise.
""" GetProcInfo(this::ByConstRef1{TSystem}, info::ByPtr1{ProcInfo_t})

# Wrapper of int TSystem::GetServiceByName(const char *)
@trydoc raw"""
    GetServiceByName(this::ByRef1{TSystem}, service::ByCopy{String})::Int32
Get port # of internet service.

""" GetServiceByName(this::ByRef1{TSystem}, service::ByCopy{String})

# Wrapper of char * TSystem::GetServiceByPort(int)
@trydoc raw"""
    GetServiceByPort(this::ByRef1{TSystem}, port::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Get name of internet service.

""" GetServiceByPort(this::ByRef1{TSystem}, port::Int32)

# Wrapper of TInetAddress TSystem::GetSockName(int)
@trydoc raw"""
    GetSockName(this::ByRef1{TSystem}, sock::Int32)::ByCopy{TInetAddress}
Get Internet Protocol (IP) address of host and port #.

""" GetSockName(this::ByRef1{TSystem}, sock::Int32)

# Wrapper of int TSystem::GetSockOpt(int, int, int *)
@trydoc raw"""
    GetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::ByPtr2{Int32})::Int32
Get socket option.

""" GetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::ByPtr2{Int32})

# Wrapper of const char * TSystem::GetSoExt()
@trydoc raw"""
    GetSoExt(this::ByConstRef1{TSystem})::ByCopy{String}
Get the shared library extension.

""" GetSoExt(this::ByConstRef1{TSystem})

# Wrapper of int TSystem::GetSysInfo(SysInfo_t *)
@trydoc raw"""
    GetSysInfo(this::ByConstRef1{TSystem}, info::ByPtr1{SysInfo_t})::Int32
Returns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the [SysInfo_t](@ref) structure.
Returns -1 in case of error, 0 otherwise.
""" GetSysInfo(this::ByConstRef1{TSystem}, info::ByPtr1{SysInfo_t})

# Wrapper of Int_t TSystem::GetUid(const char *)
@trydoc raw"""
    GetUid(this::ByRef1{TSystem}, user::ByCopy{String})::Int32
Returns the user's id. If user = 0, returns current user's id.

""" GetUid(this::ByRef1{TSystem}, user::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetUserInfo(const char *)
@trydoc raw"""
    GetUserInfo(this::ByRef1{TSystem}, user::ByCopy{String})::CxxPtr1{UserGroup_t}
Returns all user info in the [UserGroup_t](@ref) structure.
If user = 0, returns current user's id info. The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetUserInfo(this::ByRef1{TSystem}, user::ByCopy{String})

# Wrapper of UserGroup_t * TSystem::GetUserInfo(Int_t)
@trydoc raw"""
    GetUserInfo(this::ByRef1{TSystem}, uid::Int32)::CxxPtr1{UserGroup_t}
Returns all user info in the [UserGroup_t](@ref) structure.
The returned structure must be deleted by the user. In case of error 0 is returned.
""" GetUserInfo(this::ByRef1{TSystem}, uid::Int32)

# Wrapper of TList * TSystem::GetVolumes(Option_t *)
@trydoc raw"""
    GetVolumes(this::ByConstRef1{TSystem}, ::ByCopy{String})::CxxPtr1{TList}


""" GetVolumes(this::ByConstRef1{TSystem}, ::ByCopy{String})

# Wrapper of const char * TSystem::HomeDirectory(const char *)
@trydoc raw"""
    HomeDirectory(this::ByRef1{TSystem}, userName::ByCopy{String})::ByCopy{String}
Return the user's home directory.

""" HomeDirectory(this::ByRef1{TSystem}, userName::ByCopy{String})

# Wrapper of const char * TSystem::HostName()
@trydoc raw"""
    HostName(this::ByRef1{TSystem})::ByCopy{String}
Return the system's host name.

""" HostName(this::ByRef1{TSystem})

# Wrapper of void TSystem::IgnoreInterrupt(Bool_t)
@trydoc raw"""
    IgnoreInterrupt(this::ByRef1{TSystem}, ignore::Bool)::Nothing
If ignore is true ignore the interrupt signal, else restore previous behaviour.
Typically call ignore interrupt before writing to disk.
""" IgnoreInterrupt(this::ByRef1{TSystem}, ignore::Bool)

# Wrapper of void TSystem::IgnoreSignal(ESignals, Bool_t)
@trydoc raw"""
    IgnoreSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, ignore::Bool)::Nothing
If ignore is true ignore the specified signal, else restore previous behaviour.

""" IgnoreSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, ignore::Bool)

# Wrapper of Bool_t TSystem::InControl()
@trydoc raw"""
    InControl(this::ByConstRef1{TSystem})::Bool


""" InControl(this::ByConstRef1{TSystem})

# Wrapper of Bool_t TSystem::Init()
@trydoc raw"""
    Init(this::ByRef1{TSystem})::Bool
Initialize the OS interface.

""" Init(this::ByRef1{TSystem})

# Wrapper of void TSystem::InnerLoop()
@trydoc raw"""
    InnerLoop(this::ByRef1{TSystem})::Nothing
Inner event loop.

""" InnerLoop(this::ByRef1{TSystem})

# Wrapper of TClass * TSystem::IsA()
@trydoc raw"""
    IsA(this::ByConstRef1{TSystem})::CxxPtr1{TClass}

###Return

TClass describing current object
""" IsA(this::ByConstRef1{TSystem})

# Wrapper of Bool_t TSystem::IsAbsoluteFileName(const char *)
@trydoc raw"""
    IsAbsoluteFileName(this::ByRef1{TSystem}, dir::ByCopy{String})::Bool
Return true if dir is an absolute pathname.

""" IsAbsoluteFileName(this::ByRef1{TSystem}, dir::ByCopy{String})

# Wrapper of Bool_t TSystem::IsFileInIncludePath(const char *, char **)
@trydoc raw"""
    IsFileInIncludePath(this::ByRef1{TSystem}, name::ByCopy{String}, fullpath::ByPtr2{Int8})::Bool
Return true if 'name' is a file that can be found in the [ROOT](@ref) include path or the current directory.
If 'name' contains any ACLiC style information (e.g. trailing +[+][g|O]), it will be striped off 'name'. If fullpath is != 0, the full path to the file is returned in *fullpath, which must be deleted by the caller.
""" IsFileInIncludePath(this::ByRef1{TSystem}, name::ByCopy{String}, fullpath::ByPtr2{Int8})

# Wrapper of Bool_t TSystem::IsPathLocal(const char *)
@trydoc raw"""
    IsPathLocal(this::ByRef1{TSystem}, path::ByCopy{String})::Bool
Returns TRUE if the url in 'path' points to the local_ file system.
This is used to avoid going through the NIC card for local_ operations.
""" IsPathLocal(this::ByRef1{TSystem}, path::ByCopy{String})

# Wrapper of int TSystem::Link(const char *, const char *)
@trydoc raw"""
    Link(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})::Int32
Create a link from file1 to file2.

""" Link(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})

# Wrapper of void TSystem::ListLibraries(const char *)
@trydoc raw"""
    ListLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String})::Nothing
List the loaded shared libraries.
`regexp` is a regular expression allowing to filter the list.

Examples:

The following line lists all the libraries currently loaded: 

    gSystem->ListLibraries()

(C++ version of the code)

The following line lists all the libraries currently loaded having "RIO" in their names: 

    gSystem->ListLibraries(".*RIO.*")

(C++ version of the code)
""" ListLibraries(this::ByRef1{TSystem}, regexp::ByCopy{String})

# Wrapper of void TSystem::ListSymbols(const char *, const char *)
@trydoc raw"""
    ListSymbols(this::ByRef1{TSystem}, themodule::ByCopy{String}, re::ByCopy{String})::Nothing
List symbols in a shared library.

""" ListSymbols(this::ByRef1{TSystem}, themodule::ByCopy{String}, re::ByCopy{String})

# Wrapper of int TSystem::Load(const char *, const char *, Bool_t)
@trydoc raw"""
    Load(this::ByRef1{TSystem}, themodule::ByCopy{String}, entry::ByCopy{String}, system::Bool)::Int32
Load a shared library.
Returns 0 on successful loading, 1 in case lib was already loaded, -1 in case lib does not exist or in case of error and -2 in case of version mismatch. When entry is specified the loaded lib is searched for this entry point (return -1 when entry does not exist, 0 otherwise). When the system flag is kTRUE, the library is considered a permanent system library that should not be unloaded during the course of the session.
""" Load(this::ByRef1{TSystem}, themodule::ByCopy{String}, entry::ByCopy{String}, system::Bool)

# Wrapper of UInt_t TSystem::LoadAllLibraries()
@trydoc raw"""
    LoadAllLibraries(this::ByRef1{TSystem})::UInt32
Load all libraries known to [ROOT](@ref) via the rootmap system.
Returns the number of top level libraries successfully loaded.
""" LoadAllLibraries(this::ByRef1{TSystem})

# Wrapper of int TSystem::MakeDirectory(const char *)
@trydoc raw"""
    MakeDirectory(this::ByRef1{TSystem}, name::ByCopy{String})::Int32
Make a directory.
Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name).
""" MakeDirectory(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of int TSystem::mkdir(const char *, Bool_t)
@trydoc raw"""
    mkdir(this::ByRef1{TSystem}, name::ByCopy{String}, recursive::Bool)::Int32
Make a file system directory.
Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). If 'recursive' is true, makes parent directories as needed.
""" mkdir(this::ByRef1{TSystem}, name::ByCopy{String}, recursive::Bool)

# Wrapper of Long_t TSystem::NextTimeOut(Bool_t)
@trydoc raw"""
    NextTimeOut(this::ByRef1{TSystem}, mode::Bool)::Int64
Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).

""" NextTimeOut(this::ByRef1{TSystem}, mode::Bool)

# Wrapper of void TSystem::NotifyApplicationCreated()
@trydoc raw"""
    NotifyApplicationCreated(this::ByRef1{TSystem})::Nothing
Hook to tell [TSystem](@ref) that the [TApplication](@ref) object has been created.

""" NotifyApplicationCreated(this::ByRef1{TSystem})

# Wrapper of TTime TSystem::Now()
@trydoc raw"""
    Now(this::ByRef1{TSystem})::ByCopy{TTime}
Get current time in milliseconds since 0:00 Jan 1 1995.

""" Now(this::ByRef1{TSystem})

# Wrapper of int TSystem::OpenConnection(const char *, int, int, const char *)
@trydoc raw"""
    OpenConnection(this::ByRef1{TSystem}, server::ByCopy{String}, port::Int32, tcpwindowsize::Int32, protocol::ByCopy{String})::Int32
Open a connection to another host.

""" OpenConnection(this::ByRef1{TSystem}, server::ByCopy{String}, port::Int32, tcpwindowsize::Int32, protocol::ByCopy{String})

# Wrapper of void * TSystem::OpenDirectory(const char *)
@trydoc raw"""
    OpenDirectory(this::ByRef1{TSystem}, name::ByCopy{String})::CxxPtr2{Nothing}
Open a directory.
Returns 0 if directory does not exist. 

###Note

Remember to call TSystem!FreeDirectory(returned_pointer) later, to prevent a memory leak
""" OpenDirectory(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of void TSystem::Openlog(const char *, Int_t, ELogFacility)
@trydoc raw"""
    Openlog(this::ByRef1{TSystem}, name::ByCopy{String}, options::Int32, facility::ByCopy{ELogFacility})::Nothing
Open connection to system log daemon.
For the use of the options and facility see the Unix openlog man page.
""" Openlog(this::ByRef1{TSystem}, name::ByCopy{String}, options::Int32, facility::ByCopy{ELogFacility})

# Wrapper of FILE * TSystem::OpenPipe(const char *, const char *)
@trydoc raw"""
    OpenPipe(this::ByRef1{TSystem}, command::ByCopy{String}, mode::ByCopy{String})::CxxPtr1{FILE}
Open a pipe.

""" OpenPipe(this::ByRef1{TSystem}, command::ByCopy{String}, mode::ByCopy{String})

# Wrapper of const char * TSystem::PrependPathName(const char *, TString &)
@trydoc raw"""
    PrependPathName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByRef1{TString})::ByCopy{String}
Concatenate a directory and a file name.

""" PrependPathName(this::ByRef1{TSystem}, dir::ByCopy{String}, name::ByRef1{TString})

# Wrapper of Bool_t TSystem::ProcessEvents()
@trydoc raw"""
    ProcessEvents(this::ByRef1{TSystem})::Bool
Process pending events (GUI, timers, sockets).
Returns the result of [TROOT!IsInterrupted()](@ref). The interrupt flag ([TROOT!SetInterrupt()](@ref)) can be set during the handling of the events. This mechanism allows macros running in tight calculating loops to be interrupted by some GUI event (depending on the interval with which this method is called). For example hitting ctrl-c in a canvas will set the interrupt flag.
""" ProcessEvents(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::pwd()
@trydoc raw"""
    pwd(this::ByRef1{TSystem})::ByCopy{String}


""" pwd(this::ByRef1{TSystem})

# Wrapper of int TSystem::RecvBuf(int, void *, int)
@trydoc raw"""
    RecvBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32)::Int32
Receive a buffer headed by a length indicator.

""" RecvBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32)

# Wrapper of int TSystem::RecvRaw(int, void *, int, int)
@trydoc raw"""
    RecvRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32, flag::Int32)::Int32
Receive exactly length bytes into buffer.
Use opt to receive out-of-band data or to have a peek at what is in the buffer (see [TSocket](@ref)).
""" RecvRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByPtr2{Nothing}, length::Int32, flag::Int32)

# Wrapper of Int_t TSystem::RedirectOutput(const char *, const char *, RedirectHandle_t *)
@trydoc raw"""
    RedirectOutput(this::ByRef1{TSystem}, name::ByCopy{String}, mode::ByCopy{String}, h::ByPtr1{RedirectHandle_t})::Int32
Redirect standard output (stdout, stderr) to the specified file.
If the file argument is 0 the output is set again to stderr, stdout. The second argument specifies whether the output should be added to the file ("a", default) or the file be truncated before ("w"). The implementations of this function save internally the current state into a static structure.

The call can be made reentrant by specifying the opaque structure pointed by 'h', which is filled with the relevant information. The handle 'h' obtained on the first call must then be used in any subsequent call, included ShowOutput, to display the redirected output. Returns 0 on success, -1 in case of error.
""" RedirectOutput(this::ByRef1{TSystem}, name::ByCopy{String}, mode::ByCopy{String}, h::ByPtr1{RedirectHandle_t})

# Wrapper of TFileHandler * TSystem::RemoveFileHandler(TFileHandler *)
@trydoc raw"""
    RemoveFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})::CxxPtr1{TFileHandler}
Remove a file handler from the list of file handlers.
Returns the handler or 0 if the handler was not in the list of file handlers.
""" RemoveFileHandler(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler})

# Wrapper of void TSystem::RemoveOnExit(TObject *)
@trydoc raw"""
    RemoveOnExit(this::ByRef1{TSystem}, obj::ByPtr1{TObject})::Nothing
Objects that should be deleted on exit of the OS interface.

""" RemoveOnExit(this::ByRef1{TSystem}, obj::ByPtr1{TObject})

# Wrapper of TSignalHandler * TSystem::RemoveSignalHandler(TSignalHandler *)
@trydoc raw"""
    RemoveSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})::CxxPtr1{TSignalHandler}
Remove a signal handler from list of signal handlers.
Returns the handler or 0 if the handler was not in the list of signal handlers.
""" RemoveSignalHandler(this::ByRef1{TSystem}, sh::ByPtr1{TSignalHandler})

# Wrapper of TStdExceptionHandler * TSystem::RemoveStdExceptionHandler(TStdExceptionHandler *)
@trydoc raw"""
    RemoveStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})::CxxPtr1{TStdExceptionHandler}
Remove an exception handler from list of exception handlers.
Returns the handler or 0 if the handler was not in the list of exception handlers.
""" RemoveStdExceptionHandler(this::ByRef1{TSystem}, eh::ByPtr1{TStdExceptionHandler})

# Wrapper of TTimer * TSystem::RemoveTimer(TTimer *)
@trydoc raw"""
    RemoveTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})::CxxPtr1{TTimer}
Remove timer from list of system timers.
Returns removed timer or 0 if timer was not active.
""" RemoveTimer(this::ByRef1{TSystem}, t::ByPtr1{TTimer})

# Wrapper of int TSystem::Rename(const char *, const char *)
@trydoc raw"""
    Rename(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})::Int32
Rename a file.

""" Rename(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})

# Wrapper of void TSystem::ResetSignal(ESignals, Bool_t)
@trydoc raw"""
    ResetSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, reset::Bool)::Nothing
If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour.

""" ResetSignal(this::ByRef1{TSystem}, sig::ByCopy{ESignals}, reset::Bool)

# Wrapper of void TSystem::ResetSignals()
@trydoc raw"""
    ResetSignals(this::ByRef1{TSystem})::Nothing
Reset signals handlers to previous behaviour.

""" ResetSignals(this::ByRef1{TSystem})

# Wrapper of void TSystem::ResetTimer(TTimer *)
@trydoc raw"""
    ResetTimer(this::ByRef1{TSystem}, ::ByPtr1{TTimer})::Nothing


""" ResetTimer(this::ByRef1{TSystem}, ::ByPtr1{TTimer})

# Wrapper of void TSystem::Run()
@trydoc raw"""
    Run(this::ByRef1{TSystem})::Nothing
System event loop.

""" Run(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::Select(TFileHandler *, Long_t)
@trydoc raw"""
    Select(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler}, timeout::Int64)::Int32
Select on active file descriptors (called by [TMonitor](@ref)).

""" Select(this::ByRef1{TSystem}, fh::ByPtr1{TFileHandler}, timeout::Int64)

# Wrapper of Int_t TSystem::Select(TList *, Long_t)
@trydoc raw"""
    Select(this::ByRef1{TSystem}, active::ByPtr1{TList}, timeout::Int64)::Int32
Select on active file descriptors (called by [TMonitor](@ref)).

""" Select(this::ByRef1{TSystem}, active::ByPtr1{TList}, timeout::Int64)

# Wrapper of int TSystem::SendBuf(int, const void *, int)
@trydoc raw"""
    SendBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32)::Int32
Send a buffer headed by a length indicator.

""" SendBuf(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32)

# Wrapper of int TSystem::SendRaw(int, const void *, int, int)
@trydoc raw"""
    SendRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32, flag::Int32)::Int32
Send exactly length bytes from buffer.
Use opt to send out-of-band data (see [TSocket](@ref)).
""" SendRaw(this::ByRef1{TSystem}, sock::Int32, buffer::ByConstPtr2{Nothing}, length::Int32, flag::Int32)

# Wrapper of void TSystem::SetBuildDir(const char *, Bool_t)
@trydoc raw"""
    SetBuildDir(this::ByRef1{TSystem}, build_dir::ByCopy{String}, isflat::Bool)::Nothing
Set the location where ACLiC will create libraries and use as a scratch area.
If unset, libraries will be created at the same location than the script.

## Arguments

- **`build_dir`** 
    the name of the build directory 
    
- **`isflat`** 
    If false (default), then the libraries are actually stored in sub-directories of 'build_dir' including the full pathname of the script. If the script is located at `/full/path/name/macro.C` the library will be located at `build_dir+/full/path/name/macro_C.so` If 'isflat' is true, then no subdirectory is created and the library is created directly in the directory 'build_dir'. Note that in this mode there is a risk than 2 script of the same in different source directory will over-write each other. 
    

###Note

This build_dir can also be controlled via ACLiC.BuildDir in your .rootrc.
""" SetBuildDir(this::ByRef1{TSystem}, build_dir::ByCopy{String}, isflat::Bool)

# Wrapper of void TSystem::SetDisplay()
@trydoc raw"""
    SetDisplay(this::ByRef1{TSystem})::Nothing
Set DISPLAY environment variable based on utmp entry. Only for UNIX.

""" SetDisplay(this::ByRef1{TSystem})

# Wrapper of void TSystem::SetDynamicPath(const char *)
@trydoc raw"""
    SetDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})::Nothing
Set the dynamic path to a new value.
If the value of 'path' is zero, the dynamic path is reset to its default value.
""" SetDynamicPath(this::ByRef1{TSystem}, pathname::ByCopy{String})

# Wrapper of void TSystem::Setenv(const char *, const char *)
@trydoc raw"""
    Setenv(this::ByRef1{TSystem}, name::ByCopy{String}, value::ByCopy{String})::Nothing
Set environment variable.

""" Setenv(this::ByRef1{TSystem}, name::ByCopy{String}, value::ByCopy{String})

# Wrapper of void TSystem::SetErrorStr(const char *)
@trydoc raw"""
    SetErrorStr(this::ByRef1{TSystem}, errstr::ByCopy{String})::Nothing
Set the system error string.
This string will be used by [GetError()](@ref). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno).
""" SetErrorStr(this::ByRef1{TSystem}, errstr::ByCopy{String})

# Wrapper of void TSystem::SetFlagsDebug(const char *)
@trydoc raw"""
    SetFlagsDebug(this::ByRef1{TSystem}, ::ByCopy{String})::Nothing
FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode.

""" SetFlagsDebug(this::ByRef1{TSystem}, ::ByCopy{String})

# Wrapper of void TSystem::SetFlagsOpt(const char *)
@trydoc raw"""
    SetFlagsOpt(this::ByRef1{TSystem}, ::ByCopy{String})::Nothing
FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode.

""" SetFlagsOpt(this::ByRef1{TSystem}, ::ByCopy{String})

# Wrapper of Int_t TSystem::SetFPEMask(Int_t)
@trydoc raw"""
    SetFPEMask(this::ByRef1{TSystem}, mask::Int32)::Int32
Set which conditions trigger a floating point exception.
Return the previous set of conditions.
""" SetFPEMask(this::ByRef1{TSystem}, mask::Int32)

# Wrapper of void TSystem::SetIncludePath(const char *)
@trydoc raw"""
    SetIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})::Nothing
IncludePath should contain the list of compiler flags to indicate where to find user defined header files.
It is used to expand $IncludePath in the directives given to [SetMakeSharedLib()](@ref) and [SetMakeExe()](@ref), e.g.: 

    gSystem->SetInclude("-I$ROOTSYS/include -Imydirectory/include");

(C++ version of the code)

 the default value of IncludePath on Unix is: 

    "-I$ROOTSYS/include "

(C++ version of the code)

 and on Windows: 

    "/I%ROOTSYS%/include "

(C++ version of the code)
""" SetIncludePath(this::ByRef1{TSystem}, includePath::ByCopy{String})

# Wrapper of void TSystem::SetLinkdefSuffix(const char *)
@trydoc raw"""
    SetLinkdefSuffix(this::ByRef1{TSystem}, suffix::ByCopy{String})::Nothing
The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary.
So by default, when doing .L MyScript.cxx, ACLiC will look for a file name MyScript_linkdef and having one of the .h (.hpp, etc.) extensions. If such a file exist, it will be added to the theend of the linkdef file used to created the ACLiC dictionary. This effectively enable the full customization of the creation of the dictionary. It should be noted that the file is intended as a linkdef `fragment`, so usually you would not list the typical: 

    #pragma link off ....

(C++ version of the code)
""" SetLinkdefSuffix(this::ByRef1{TSystem}, suffix::ByCopy{String})

# Wrapper of void TSystem::SetLinkedLibs(const char *)
@trydoc raw"""
    SetLinkedLibs(this::ByRef1{TSystem}, linkedLibs::ByCopy{String})::Nothing
LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable.
It is used to expand $LinkedLibs in the directives given to [SetMakeSharedLib()](@ref) and [SetMakeExe()](@ref) The default value on Unix is: `root-config --glibs`
""" SetLinkedLibs(this::ByRef1{TSystem}, linkedLibs::ByCopy{String})

# Wrapper of void TSystem::SetMakeExe(const char *)
@trydoc raw"""
    SetMakeExe(this::ByRef1{TSystem}, directives::ByCopy{String})::Nothing
Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable.
This creation is used as a means to output a list of unresolved symbols, when loading a shared library has failed. The required variable is $ExeName rather than $SharedLib, e.g.: 

    gSystem->SetMakeExe(
    "g++ -Wall -fPIC $IncludePath $SourceFiles
     -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic");

(C++ version of the code)
""" SetMakeExe(this::ByRef1{TSystem}, directives::ByCopy{String})

# Wrapper of void TSystem::SetMakeSharedLib(const char *)
@trydoc raw"""
    SetMakeSharedLib(this::ByRef1{TSystem}, directives::ByCopy{String})::Nothing
Directives should contain the description on how to compile and link a shared lib.
This description can be any valid shell command, including the use of ';' to separate several instructions. However, shell specific construct should be avoided. In particular this description can contain environment variables, like $ROOTSYS (or ROOTSYS% on windows). 

    Five special variables will be expanded before execution:
      Variable name       Expands to
      -------------       ----------
      $SourceFiles        Name of source files to be compiled
      $SharedLib          Name of the shared library being created
      $LibName            Name of shared library without extension
      $BuildDir           Directory where the files will be created
      $IncludePath        value of fIncludePath
      $LinkedLibs         value of fLinkedLibs
      $DepLibs            libraries on which this library depends on
      $ObjectFiles        Name of source files to be compiler with
                          their extension changed to .o or .obj
      $Opt                location of the optimization/debug options
                          set fFlagsDebug and fFlagsOpt

(C++ version of the code)

 e.g.: 

    gSystem->SetMakeSharedLib(
    "KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile
     --no_exceptions --signed_chars --display_error_number
     --diag_suppress 68 -o $SharedLib");
    gSystem->setMakeSharedLib(
    "Cxx $IncludePath -c $SourceFile;
     ld  -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved
     \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o
     -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"
    gSystem->SetMakeSharedLib(
    "$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile
     -shared -o $SharedLib");
    gSystem->SetMakeSharedLib(
    "cl -DWIN32  -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32
     -D_WINDOWS $IncludePath $SourceFile
     /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO
     $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib")

(C++ version of the code)
""" SetMakeSharedLib(this::ByRef1{TSystem}, directives::ByCopy{String})

# Wrapper of void TSystem::SetObjExt(const char *)
@trydoc raw"""
    SetObjExt(this::ByRef1{TSystem}, objExt::ByCopy{String})::Nothing
Set object files extension, should be either .o, .obj, etc.

""" SetObjExt(this::ByRef1{TSystem}, objExt::ByCopy{String})

# Wrapper of void TSystem::SetProgname(const char *)
@trydoc raw"""
    SetProgname(this::ByRef1{TSystem}, name::ByCopy{String})::Nothing
Set the application name (from command line, argv[0]) and copy it in gProgName.

""" SetProgname(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of int TSystem::SetSockOpt(int, int, int)
@trydoc raw"""
    SetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::Int32)::Int32
Set socket option.

""" SetSockOpt(this::ByRef1{TSystem}, sock::Int32, kind::Int32, val::Int32)

# Wrapper of void TSystem::SetSoExt(const char *)
@trydoc raw"""
    SetSoExt(this::ByRef1{TSystem}, soExt::ByCopy{String})::Nothing
Set shared library extension, should be either .so, .sl, .a, .dll, etc.

""" SetSoExt(this::ByRef1{TSystem}, soExt::ByCopy{String})

# Wrapper of void TSystem::ShowOutput(RedirectHandle_t *)
@trydoc raw"""
    ShowOutput(this::ByRef1{TSystem}, h::ByPtr1{RedirectHandle_t})::Nothing
Display the content associated with the redirection described by the opaque handle 'h'.

""" ShowOutput(this::ByRef1{TSystem}, h::ByPtr1{RedirectHandle_t})

# Wrapper of void TSystem::Sleep(UInt_t)
@trydoc raw"""
    Sleep(this::ByRef1{TSystem}, milliSec::UInt32)::Nothing
Sleep milliSec milli seconds.

""" Sleep(this::ByRef1{TSystem}, milliSec::UInt32)

# Wrapper of TString TSystem::SplitAclicMode(const char *, TString &, TString &, TString &)
@trydoc raw"""
    SplitAclicMode(this::ByConstRef1{TSystem}, filename::ByCopy{String}, mode::ByRef1{TString}, args::ByRef1{TString}, io::ByRef1{TString})::ByCopy{TString}
This method split a filename of the form:
[path/]macro.C[+|++[k|f|g|O|c|s|d|v|-]][(args)].

(C++ version of the code)

 It stores the ACliC mode [+|++[options]] in 'mode', the arguments (including parenthesis) in arg and the I/O indirection in io
""" SplitAclicMode(this::ByConstRef1{TSystem}, filename::ByCopy{String}, mode::ByRef1{TString}, args::ByRef1{TString}, io::ByRef1{TString})

# Wrapper of void TSystem::StackTrace()
@trydoc raw"""
    StackTrace(this::ByRef1{TSystem})::Nothing
Print a stack trace.

""" StackTrace(this::ByRef1{TSystem})

# Wrapper of void TSystem::Streamer(TBuffer &)
@trydoc raw"""
    Streamer(this::ByRef1{TSystem}, ::ByRef1{TBuffer})::Nothing
Stream an object of class [TObject](@ref).

""" Streamer(this::ByRef1{TSystem}, ::ByRef1{TBuffer})

# Wrapper of void TSystem::StreamerNVirtual(TBuffer &)
@trydoc raw"""
    StreamerNVirtual(this::ByRef1{TSystem}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})::Nothing


""" StreamerNVirtual(this::ByRef1{TSystem}, ClassDef_StreamerNVirtual_b::ByRef1{TBuffer})

# Wrapper of int TSystem::Symlink(const char *, const char *)
@trydoc raw"""
    Symlink(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})::Int32
Create a symbolic link from file1 to file2.

""" Symlink(this::ByRef1{TSystem}, from::ByCopy{String}, to::ByCopy{String})

# Wrapper of void TSystem::Syslog(ELogLevel, const char *)
@trydoc raw"""
    Syslog(this::ByRef1{TSystem}, level::ByCopy{ELogLevel}, mess::ByCopy{String})::Nothing
Send mess to syslog daemon.
Level is the logging level and mess the message that will be written on the log.
""" Syslog(this::ByRef1{TSystem}, level::ByCopy{ELogLevel}, mess::ByCopy{String})

# Wrapper of const char * TSystem::TempDirectory()
@trydoc raw"""
    TempDirectory(this::ByConstRef1{TSystem})::ByCopy{String}
Return a user configured or systemwide directory to create temporary files in.

""" TempDirectory(this::ByConstRef1{TSystem})

# Wrapper of FILE * TSystem::TempFileName(TString &, const char *, const char *)
@trydoc raw"""
    TempFileName(this::ByRef1{TSystem}, base::ByRef1{TString}, dir::ByCopy{String}, suffix::ByCopy{String})::CxxPtr1{FILE}
Create a secure temporary file by appending a unique 6 letter string to base.
The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension ".txt" or ".html". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error.
""" TempFileName(this::ByRef1{TSystem}, base::ByRef1{TString}, dir::ByCopy{String}, suffix::ByCopy{String})

# Wrapper of int TSystem::Umask(Int_t)
@trydoc raw"""
    Umask(this::ByRef1{TSystem}, mask::Int32)::Int32
Set the process file creation mode mask.

""" Umask(this::ByRef1{TSystem}, mask::Int32)

# Wrapper of const char * TSystem::UnixPathName(const char *)
@trydoc raw"""
    UnixPathName(this::ByRef1{TSystem}, unixpathname::ByCopy{String})::ByCopy{String}
Convert from a local_ pathname to a Unix pathname.
E.g. from `\user\root` to `/user/root`.
""" UnixPathName(this::ByRef1{TSystem}, unixpathname::ByCopy{String})

# Wrapper of int TSystem::Unlink(const char *)
@trydoc raw"""
    Unlink(this::ByRef1{TSystem}, name::ByCopy{String})::Int32
Unlink, i.e.
remove, a file.

If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, while Windows does not allow the file to be deleted and the operation is a no-op).
""" Unlink(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of void TSystem::Unload(const char *)
@trydoc raw"""
    Unload(this::ByRef1{TSystem}, themodule::ByCopy{String})::Nothing
Unload a shared library.

""" Unload(this::ByRef1{TSystem}, themodule::ByCopy{String})

# Wrapper of void TSystem::Unsetenv(const char *)
@trydoc raw"""
    Unsetenv(this::ByRef1{TSystem}, name::ByCopy{String})::Nothing
Unset environment variable.

""" Unsetenv(this::ByRef1{TSystem}, name::ByCopy{String})

# Wrapper of int TSystem::Utime(const char *, Long_t, Long_t)
@trydoc raw"""
    Utime(this::ByRef1{TSystem}, file::ByCopy{String}, modtime::Int64, actime::Int64)::Int32
Set the a files modification and access times.
If actime = 0 it will be set to the modtime. Returns 0 on success and -1 in case of error.
""" Utime(this::ByRef1{TSystem}, file::ByCopy{String}, modtime::Int64, actime::Int64)

# Wrapper of char * TSystem::Which(const char *, const char *, EAccessMode)
@trydoc raw"""
    Which(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByCopy{String}, mode::ByCopy{EAccessMode})::ByCopy{Union{String, Vector{CxxChar}}}
Find location of file in a search path.
User must delete returned string. Returns 0 in case file is not found.
""" Which(this::ByRef1{TSystem}, search::ByCopy{String}, file::ByCopy{String}, mode::ByCopy{EAccessMode})

# Wrapper of const char * TSystem::WorkingDirectory()
@trydoc raw"""
    WorkingDirectory(this::ByRef1{TSystem})::ByCopy{String}
Return working directory.

""" WorkingDirectory(this::ByRef1{TSystem})

# Wrapper of TClass * TSystem::Class()
@trydoc raw"""
    TSystem!Class(this::ByRef1{TSystem})::CxxPtr1{TClass}

###Return

TClass describing this class
""" TSystem!Class(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::Class_Name()
@trydoc raw"""
    TSystem!Class_Name(this::ByRef1{TSystem})::ByCopy{String}

###Return

Name of this class
""" TSystem!Class_Name(this::ByRef1{TSystem})

# Wrapper of const char * TSystem::DeclFileName()
@trydoc raw"""
    TSystem!DeclFileName(this::ByRef1{TSystem})::ByCopy{String}

###Return

Name of the file containing the class declaration
""" TSystem!DeclFileName(this::ByRef1{TSystem})

# Wrapper of Int_t TSystem::GetErrno()
@trydoc raw"""
    TSystem!GetErrno(this::ByRef1{TSystem})::Int32
Static function returning system error number.

""" TSystem!GetErrno(this::ByRef1{TSystem})

# Wrapper of void TSystem::ResetErrno()
@trydoc raw"""
    TSystem!ResetErrno(this::ByRef1{TSystem})::Nothing
Static function resetting system error number.

""" TSystem!ResetErrno(this::ByRef1{TSystem})

# Wrapper of void TBranch::AddLastBasket(Long64_t)
@trydoc raw"""
    AddLastBasket(this::ByRef1{TBranch}, startEntry::Int64)::Nothing
Add the thestart entry of the write basket (not yet created)

""" AddLastBasket(this::ByRef1{TBranch}, startEntry::Int64)

# Wrapper of Int_t TBranch::BackFill()
@trydoc raw"""
    BackFill(this::ByRef1{TBranch})::Int32
Loop on all leaves of this branch to back fill Basket buffer.
Use this routine instead of [TBranch!Fill](@ref) when filling a branch individually to catch up with the number of entries already in the [TTree](@ref).

First it calls [TBranch!Fill](@ref) and then if the number of entries of the branch reach one of [TTree](@ref) cluster's boundary, the basket is flushed.

The function returns the number of bytes committed to the memory basket. If a write error occurs, the number of bytes returned is -1. If no data are written, because e.g. the branch is disabled, the number of bytes returned is 0.

To insure that the baskets of each cluster are located close by in the file, when back-filling multiple branches make sure to call BackFill for the same entry for all the branches consecutively 

    for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.
      for( auto branch : branchCollection) {
         ... Make change to the data associated with the branch ...
         branch->BackFill();
      }
    }
    // Since we loop over all the branches for each new entry
    // all the baskets for a cluster are consecutive in the file.

(C++ version of the code)

 rather than doing all the entries of one branch at a time. 

    // Do NOT do things in the following order, it will lead to
    // poorly clustered files.
    for(auto branch : branchCollection) {
      for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.
         ... Make change to the data associated with the branch ...
         branch->BackFill();
      }
    }
    // Since we loop over all the entries for one branch
    // all the baskets for that branch are consecutive.

(C++ version of the code)
""" BackFill(this::ByRef1{TBranch})

# Wrapper of void TBranch::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TBranch}, b::ByPtr1{TBrowser})::Nothing
Browser interface.

""" Browse(this::ByRef1{TBranch}, b::ByPtr1{TBrowser})

# Wrapper of void TBranch::DeleteBaskets(Option_t *)
@trydoc raw"""
    DeleteBaskets(this::ByRef1{TBranch}, option::ByCopy{String})::Nothing
Loop on all branch baskets.
If the file where branch buffers reside is writable, free the disk space associated to the baskets of the branch, then call [Reset()](@ref). If the option contains "all", delete also the baskets for the subbranches. The branch is reset.

NOTE that this function must be used with extreme care. Deleting branch baskets fragments the file and may introduce inefficiencies when adding new entries in the Tree or later on when reading the Tree.
""" DeleteBaskets(this::ByRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::DropBaskets(Option_t *)
@trydoc raw"""
    DropBaskets(this::ByRef1{TBranch}, option::ByCopy{String})::Nothing
Loop on all branch baskets.
Drop all baskets from memory except readbasket. If the option contains "all", drop all baskets including read- and write-baskets (unless they are not stored individually on disk). The option "all" also lead to DropBaskets being called on the sub-branches.
""" DropBaskets(this::ByRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::ExpandBasketArrays()
@trydoc raw"""
    ExpandBasketArrays(this::ByRef1{TBranch})::Nothing
Increase BasketEntry buffer of a minimum of 10 locations and a maximum of 50 per cent of current size.

""" ExpandBasketArrays(this::ByRef1{TBranch})

# Wrapper of Int_t TBranch::Fill()
@trydoc raw"""
    Fill(this::ByRef1{TBranch})::Int32


""" Fill(this::ByRef1{TBranch})

# Wrapper of TBranch * TBranch::FindBranch(const char *)
@trydoc raw"""
    FindBranch(this::ByRef1{TBranch}, name::ByCopy{String})::CxxPtr1{TBranch}
Find the immediate sub-branch with passed name.

""" FindBranch(this::ByRef1{TBranch}, name::ByCopy{String})

# Wrapper of TLeaf * TBranch::FindLeaf(const char *)
@trydoc raw"""
    FindLeaf(this::ByRef1{TBranch}, name::ByCopy{String})::CxxPtr1{TLeaf}
Find the leaf corresponding to the name 'searchname'.

""" FindLeaf(this::ByRef1{TBranch}, name::ByCopy{String})

# Wrapper of Int_t TBranch::FlushBaskets()
@trydoc raw"""
    FlushBaskets(this::ByRef1{TBranch})::Int32
Flush to disk all the baskets of this branch and any of subbranches.
Return the number of bytes written or -1 in case of write error.
""" FlushBaskets(this::ByRef1{TBranch})

# Wrapper of Int_t TBranch::FlushOneBasket(UInt_t)
@trydoc raw"""
    FlushOneBasket(this::ByRef1{TBranch}, which::UInt32)::Int32
If we have a write basket in memory and it contains some entries and has not yet been written to disk, we write it and delete it from memory.
Return the number of bytes written;
""" FlushOneBasket(this::ByRef1{TBranch}, which::UInt32)

# Wrapper of char * TBranch::GetAddress()
@trydoc raw"""
    GetAddress(this::ByConstRef1{TBranch})::ByCopy{Union{String, Vector{CxxChar}}}


""" GetAddress(this::ByConstRef1{TBranch})

# Wrapper of Int_t * TBranch::GetBasketBytes()
@trydoc raw"""
    GetBasketBytes(this::ByConstRef1{TBranch})::CxxPtr2{Int32}


""" GetBasketBytes(this::ByConstRef1{TBranch})

# Wrapper of Long64_t * TBranch::GetBasketEntry()
@trydoc raw"""
    GetBasketEntry(this::ByConstRef1{TBranch})::CxxPtr2{Int64}


""" GetBasketEntry(this::ByConstRef1{TBranch})

# Wrapper of Long64_t TBranch::GetBasketSeek(Int_t)
@trydoc raw"""
    GetBasketSeek(this::ByConstRef1{TBranch}, basket::Int32)::Int64
Return address of basket in the file.

""" GetBasketSeek(this::ByConstRef1{TBranch}, basket::Int32)

# Wrapper of Int_t TBranch::GetBasketSize()
@trydoc raw"""
    GetBasketSize(this::ByConstRef1{TBranch})::Int32


""" GetBasketSize(this::ByConstRef1{TBranch})

# Wrapper of TList * TBranch::GetBrowsables()
@trydoc raw"""
    GetBrowsables(this::ByRef1{TBranch})::CxxPtr1{TList}
Returns (and, if 0, creates) browsable objects for this branch See [TVirtualBranchBrowsable!FillListOfBrowsables](@ref).
""" GetBrowsables(this::ByRef1{TBranch})

# Wrapper of const char * TBranch::GetClassName()
@trydoc raw"""
    GetClassName(this::ByConstRef1{TBranch})::ByCopy{String}
Return the name of the user class whose content is stored in this branch, if any.
If this branch was created using the 'leaflist' technique, this function returns an empty string.
""" GetClassName(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetCompressionAlgorithm()
@trydoc raw"""
    GetCompressionAlgorithm(this::ByConstRef1{TBranch})::Int32


""" GetCompressionAlgorithm(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetCompressionLevel()
@trydoc raw"""
    GetCompressionLevel(this::ByConstRef1{TBranch})::Int32


""" GetCompressionLevel(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetCompressionSettings()
@trydoc raw"""
    GetCompressionSettings(this::ByConstRef1{TBranch})::Int32


""" GetCompressionSettings(this::ByConstRef1{TBranch})

# Wrapper of TDirectory * TBranch::GetDirectory()
@trydoc raw"""
    GetDirectory(this::ByConstRef1{TBranch})::CxxPtr1{TDirectory}


""" GetDirectory(this::ByConstRef1{TBranch})

# Wrapper of Long64_t TBranch::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{TBranch})::Int64


""" GetEntries(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TBranch}, entry::Int64, getall::Int32)::Int32
Read all leaves of entry and return total number of bytes read.
The input argument "entry" is the entry number in the current tree. In case of a [TChain](@ref), the entry number in the current Tree must be found before calling this function. For example:

    TChain* chain = ...;
    Long64_t localEntry = chain->LoadTree(entry);
    branch->GetEntry(localEntry);

(C++ version of the code)

The function returns the number of bytes read from the input buffer. If entry does not exist, the function returns 0. If an I/O error occurs, the function returns -1.

See IMPORTANT REMARKS in [TTree!GetEntry](@ref).
""" GetEntry(this::ByRef1{TBranch}, entry::Int64, getall::Int32)

# Wrapper of Int_t TBranch::GetEntryExport(Long64_t, Int_t, TClonesArray *, Int_t)
@trydoc raw"""
    GetEntryExport(this::ByRef1{TBranch}, entry::Int64, getall::Int32, list::ByPtr1{TClonesArray}, n::Int32)::Int32
Read all leaves of an entry and export buffers to real objects in a [TClonesArray](@ref) list.
Returns total number of bytes read.
""" GetEntryExport(this::ByRef1{TBranch}, entry::Int64, getall::Int32, list::ByPtr1{TClonesArray}, n::Int32)

# Wrapper of Long64_t TBranch::GetEntryNumber()
@trydoc raw"""
    GetEntryNumber(this::ByConstRef1{TBranch})::Int64


""" GetEntryNumber(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetEntryOffsetLen()
@trydoc raw"""
    GetEntryOffsetLen(this::ByConstRef1{TBranch})::Int32


""" GetEntryOffsetLen(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetEvent(Long64_t)
@trydoc raw"""
    GetEvent(this::ByRef1{TBranch}, entry::Int64)::Int32


""" GetEvent(this::ByRef1{TBranch}, entry::Int64)

# Wrapper of Int_t TBranch::GetExpectedType(TClass *&, EDataType &)
@trydoc raw"""
    GetExpectedType(this::ByRef1{TBranch}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})::Int32
Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure.

""" GetExpectedType(this::ByRef1{TBranch}, clptr::ByPtr1{TClass}, type::ByRef1{EDataType})

# Wrapper of TFile * TBranch::GetFile(Int_t)
@trydoc raw"""
    GetFile(this::ByRef1{TBranch}, mode::Int32)::CxxPtr1{TFile}
Return pointer to the file where branch buffers reside, returns 0 in case branch buffers reside in the same file as tree header.
If mode is 1 the branch buffer file is recreated.
""" GetFile(this::ByRef1{TBranch}, mode::Int32)

# Wrapper of const char * TBranch::GetFileName()
@trydoc raw"""
    GetFileName(this::ByConstRef1{TBranch})::ByCopy{String}


""" GetFileName(this::ByConstRef1{TBranch})

# Wrapper of Long64_t TBranch::GetFirstEntry()
@trydoc raw"""
    GetFirstEntry(this::ByConstRef1{TBranch})::Int64


""" GetFirstEntry(this::ByConstRef1{TBranch})

# Wrapper of TString TBranch::GetFullName()
@trydoc raw"""
    GetFullName(this::ByConstRef1{TBranch})::ByCopy{TString}
Return the 'full' name of the branch.
In particular prefix the mother's name when it does not theend in a trailing dot and thus is not part of the branch name
""" GetFullName(this::ByConstRef1{TBranch})

# Wrapper of const char * TBranch::GetIconName()
@trydoc raw"""
    GetIconName(this::ByConstRef1{TBranch})::ByCopy{String}
Return icon name depending on type of branch.

""" GetIconName(this::ByConstRef1{TBranch})

# Wrapper of TLeaf * TBranch::GetLeaf(const char *)
@trydoc raw"""
    GetLeaf(this::ByConstRef1{TBranch}, name::ByCopy{String})::CxxPtr1{TLeaf}
Return pointer to the 1st Leaf named name in thisBranch.

""" GetLeaf(this::ByConstRef1{TBranch}, name::ByCopy{String})

# Wrapper of TObjArray * TBranch::GetListOfBaskets()
@trydoc raw"""
    GetListOfBaskets(this::ByRef1{TBranch})::CxxPtr1{TObjArray}


""" GetListOfBaskets(this::ByRef1{TBranch})

# Wrapper of TObjArray * TBranch::GetListOfBranches()
@trydoc raw"""
    GetListOfBranches(this::ByRef1{TBranch})::CxxPtr1{TObjArray}


""" GetListOfBranches(this::ByRef1{TBranch})

# Wrapper of TObjArray * TBranch::GetListOfLeaves()
@trydoc raw"""
    GetListOfLeaves(this::ByRef1{TBranch})::CxxPtr1{TObjArray}


""" GetListOfLeaves(this::ByRef1{TBranch})

# Wrapper of bool TBranch::GetMakeClass()
@trydoc raw"""
    GetMakeClass(this::ByConstRef1{TBranch})::Bool
Return whether this branch is in a mode where the object are decomposed or not (Also known as MakeClass mode).

""" GetMakeClass(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetMaxBaskets()
@trydoc raw"""
    GetMaxBaskets(this::ByConstRef1{TBranch})::Int32


""" GetMaxBaskets(this::ByConstRef1{TBranch})

# Wrapper of TBranch * TBranch::GetMother()
@trydoc raw"""
    GetMother(this::ByConstRef1{TBranch})::CxxPtr1{TBranch}
Get our top-level parent branch in the tree.

""" GetMother(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetNleaves()
@trydoc raw"""
    GetNleaves(this::ByConstRef1{TBranch})::Int32


""" GetNleaves(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetOffset()
@trydoc raw"""
    GetOffset(this::ByConstRef1{TBranch})::Int32


""" GetOffset(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetReadBasket()
@trydoc raw"""
    GetReadBasket(this::ByConstRef1{TBranch})::Int32


""" GetReadBasket(this::ByConstRef1{TBranch})

# Wrapper of Long64_t TBranch::GetReadEntry()
@trydoc raw"""
    GetReadEntry(this::ByConstRef1{TBranch})::Int64


""" GetReadEntry(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetRow(Int_t)
@trydoc raw"""
    GetRow(this::ByRef1{TBranch}, row::Int32)::Int32
Return all elements of one row unpacked in internal array fValues [Actually just returns 1 (?)].

""" GetRow(this::ByRef1{TBranch}, row::Int32)

# Wrapper of Int_t TBranch::GetSplitLevel()
@trydoc raw"""
    GetSplitLevel(this::ByConstRef1{TBranch})::Int32


""" GetSplitLevel(this::ByConstRef1{TBranch})

# Wrapper of TBranch * TBranch::GetSubBranch(const TBranch *)
@trydoc raw"""
    GetSubBranch(this::ByConstRef1{TBranch}, br::ByConstPtr1{TBranch})::CxxPtr1{TBranch}
Find the parent branch of child.
Return 0 if child is not in this branch hierarchy.
""" GetSubBranch(this::ByConstRef1{TBranch}, br::ByConstPtr1{TBranch})

# Wrapper of Long64_t TBranch::GetTotalSize(Option_t *)
@trydoc raw"""
    GetTotalSize(this::ByConstRef1{TBranch}, option::ByCopy{String})::Int64
Return total number of bytes in the branch (including current buffer)

""" GetTotalSize(this::ByConstRef1{TBranch}, option::ByCopy{String})

# Wrapper of Long64_t TBranch::GetTotBytes(Option_t *)
@trydoc raw"""
    GetTotBytes(this::ByConstRef1{TBranch}, option::ByCopy{String})::Int64
Return total number of bytes in the branch (excluding current buffer) if option ="*" includes all sub-branches of this branch too.

""" GetTotBytes(this::ByConstRef1{TBranch}, option::ByCopy{String})

# Wrapper of TBuffer * TBranch::GetTransientBuffer(Int_t)
@trydoc raw"""
    GetTransientBuffer(this::ByRef1{TBranch}, size::Int32)::CxxPtr1{TBuffer}
Returns the transient buffer currently used by this [TBranch](@ref) for reading/writing baskets.

""" GetTransientBuffer(this::ByRef1{TBranch}, size::Int32)

# Wrapper of TTree * TBranch::GetTree()
@trydoc raw"""
    GetTree(this::ByConstRef1{TBranch})::CxxPtr1{TTree}


""" GetTree(this::ByConstRef1{TBranch})

# Wrapper of Int_t TBranch::GetWriteBasket()
@trydoc raw"""
    GetWriteBasket(this::ByConstRef1{TBranch})::Int32


""" GetWriteBasket(this::ByConstRef1{TBranch})

# Wrapper of Long64_t TBranch::GetZipBytes(Option_t *)
@trydoc raw"""
    GetZipBytes(this::ByConstRef1{TBranch}, option::ByCopy{String})::Int64
Return total number of zip bytes in the branch if option ="*" includes all sub-branches of this branch too.

""" GetZipBytes(this::ByConstRef1{TBranch}, option::ByCopy{String})

# Wrapper of bool TBranch::IsAutoDelete()
@trydoc raw"""
    IsAutoDelete(this::ByConstRef1{TBranch})::Bool
Return true if an existing object in a [TBranchObject](@ref) must be deleted.

""" IsAutoDelete(this::ByConstRef1{TBranch})

# Wrapper of bool TBranch::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TBranch})::Bool
Return true if more than one leaf or browsables, false otherwise.

""" IsFolder(this::ByConstRef1{TBranch})

# Wrapper of void TBranch::KeepCircular(Long64_t)
@trydoc raw"""
    KeepCircular(this::ByRef1{TBranch}, maxEntries::Int64)::Nothing
keep a maximum of fMaxEntries in memory

""" KeepCircular(this::ByRef1{TBranch}, maxEntries::Int64)

# Wrapper of Int_t TBranch::LoadBaskets()
@trydoc raw"""
    LoadBaskets(this::ByRef1{TBranch})::Int32
Baskets associated to this branch are forced to be in memory.
You can call TTree!SetMaxVirtualSize(maxmemory) to instruct the system that the total size of the imported baskets does not exceed maxmemory bytes.

The function returns the number of baskets that have been put in memory. This method may be called to force all baskets of one or more branches in memory when random access to entries in this branch is required. See also [TTree!LoadBaskets](@ref) to load all baskets of all branches in memory.
""" LoadBaskets(this::ByRef1{TBranch})

# Wrapper of void TBranch::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TBranch}, option::ByCopy{String})::Nothing
Print [TBranch](@ref) parameters.
If options contains "basketsInfo" print the entry number, location and size of each baskets.
""" Print(this::ByConstRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::PrintCacheInfo()
@trydoc raw"""
    PrintCacheInfo(this::ByConstRef1{TBranch})::Nothing
Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache.

""" PrintCacheInfo(this::ByConstRef1{TBranch})

# Wrapper of void TBranch::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TBranch}, b::ByRef1{TBuffer})::Nothing
Loop on all leaves of this branch to read Basket buffer.

""" ReadBasket(this::ByRef1{TBranch}, b::ByRef1{TBuffer})

# Wrapper of void TBranch::Refresh(TBranch *)
@trydoc raw"""
    Refresh(this::ByRef1{TBranch}, b::ByPtr1{TBranch})::Nothing
Refresh this branch using new information in b This function is called by [TTree!Refresh](@ref).
""" Refresh(this::ByRef1{TBranch}, b::ByPtr1{TBranch})

# Wrapper of void TBranch::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TBranch}, option::ByCopy{String})::Nothing
Reset a Branch.
- Existing buffers are deleted.
- Entries, max and min are reset.
""" Reset(this::ByRef1{TBranch}, option::ByCopy{String})

# Wrapper of void TBranch::ResetAddress()
@trydoc raw"""
    ResetAddress(this::ByRef1{TBranch})::Nothing
Reset the address of the branch.

""" ResetAddress(this::ByRef1{TBranch})

# Wrapper of void TBranch::ResetReadEntry()
@trydoc raw"""
    ResetReadEntry(this::ByRef1{TBranch})::Nothing


""" ResetReadEntry(this::ByRef1{TBranch})

# Wrapper of void TBranch::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TBranch}, add::ByPtr2{Nothing})::Nothing
Set address of this branch.
###See

TBranchElement!SetAddress 

###Note

TBranch!SetAddress is a lower level interface and has less ability to check for incorrect setup than TTree!SetBranchAddress. Without TTree!SetMakeClass, if the branch is within an object, the input of SetAddress is expected to be the thestart of the object (and thus the offset of the data member is added to the provided address). The explicit purpose of TTree!SetMakeClass is to disable this addition of the offset. Note that TTree!SetBranchAddress will detect this case and automatically call SetMakeClass for a data member within a class. For example, the tutorial https://root.cern/doc/master/tree108__tree_8C.html generates a ROOT file with a TTree. To read the temperature values, you need either tree->SetBranchAddress("fTemperature", &temp); or tree->SetMakeClass(1); tree->GetBranch("fTemperature")->SetAddress(&temp);.
""" SetAddress(this::ByRef1{TBranch}, add::ByPtr2{Nothing})

# Wrapper of void TBranch::SetAutoDelete(bool)
@trydoc raw"""
    SetAutoDelete(this::ByRef1{TBranch}, autodel::Bool)::Nothing
Set the automatic delete bit.
This bit is used by [TBranchObject!ReadBasket](@ref) to decide if an object referenced by a [TBranchObject](@ref) must be deleted or not before reading a new entry.

If autodel is true, this existing object will be deleted, a new object created by the default constructor, then read from disk by the streamer.

If autodel is false, the existing object is not deleted. Root assumes that the user is taking care of deleting any internal object or array (this can be done in the streamer).
""" SetAutoDelete(this::ByRef1{TBranch}, autodel::Bool)

# Wrapper of void TBranch::SetBasketSize(Int_t)
@trydoc raw"""
    SetBasketSize(this::ByRef1{TBranch}, buffsize::Int32)::Nothing
Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen.

""" SetBasketSize(this::ByRef1{TBranch}, buffsize::Int32)

# Wrapper of void TBranch::SetBufferAddress(TBuffer *)
@trydoc raw"""
    SetBufferAddress(this::ByRef1{TBranch}, entryBuffer::ByPtr1{TBuffer})::Nothing
Set address of this branch directly from a [TBuffer](@ref) to avoid streaming.
Note: We do not take ownership of the buffer.
""" SetBufferAddress(this::ByRef1{TBranch}, entryBuffer::ByPtr1{TBuffer})

# Wrapper of void TBranch::SetCompressionAlgorithm(Int_t)
@trydoc raw"""
    SetCompressionAlgorithm(this::ByRef1{TBranch}, algorithm::Int32)::Nothing
Set compression algorithm.

""" SetCompressionAlgorithm(this::ByRef1{TBranch}, algorithm::Int32)

# Wrapper of void TBranch::SetCompressionLevel(Int_t)
@trydoc raw"""
    SetCompressionLevel(this::ByRef1{TBranch}, level::Int32)::Nothing
Set compression level.

""" SetCompressionLevel(this::ByRef1{TBranch}, level::Int32)

# Wrapper of void TBranch::SetCompressionSettings(Int_t)
@trydoc raw"""
    SetCompressionSettings(this::ByRef1{TBranch}, settings::Int32)::Nothing
Set compression settings.

""" SetCompressionSettings(this::ByRef1{TBranch}, settings::Int32)

# Wrapper of void TBranch::SetEntries(Long64_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TBranch}, entries::Int64)::Nothing
Set the number of entries in this branch.

""" SetEntries(this::ByRef1{TBranch}, entries::Int64)

# Wrapper of void TBranch::SetEntryOffsetLen(Int_t, bool)
@trydoc raw"""
    SetEntryOffsetLen(this::ByRef1{TBranch}, len::Int32, updateSubBranches::Bool)::Nothing
Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches.

""" SetEntryOffsetLen(this::ByRef1{TBranch}, len::Int32, updateSubBranches::Bool)

# Wrapper of void TBranch::SetFile(const char *)
@trydoc raw"""
    SetFile(this::ByRef1{TBranch}, filename::ByCopy{String})::Nothing
Set file where this branch writes/reads its buffers.
By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch files to a different location in the file system and still access the branch files. The [ROOT](@ref) file will be connected only when necessary. If called by [TBranch!Fill](@ref) (via [TBasket!WriteFile](@ref)), the file will be created with the option "recreate". If called by [TBranch!GetEntry](@ref) (via [TBranch!GetBasket](@ref)), the file will be opened in read mode. To open a file in "update" mode or with a certain compression level, use [TBranch!SetFile(TFile *file)](@ref).
""" SetFile(this::ByRef1{TBranch}, filename::ByCopy{String})

# Wrapper of void TBranch::SetFile(TFile *)
@trydoc raw"""
    SetFile(this::ByRef1{TBranch}, file::ByPtr1{TFile})::Nothing
Set file where this branch writes/reads its buffers.
By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. or root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch files to a different location in the file system and still access the branch files. The [ROOT](@ref) file will be connected only when necessary. If called by [TBranch!Fill](@ref) (via [TBasket!WriteFile](@ref)), the file will be created with the option "recreate". If called by [TBranch!GetEntry](@ref) (via [TBranch!GetBasket](@ref)), the file will be opened in read mode. To open a file in "update" mode or with a certain compression level, use [TBranch!SetFile(TFile *file)](@ref).
""" SetFile(this::ByRef1{TBranch}, file::ByPtr1{TFile})

# Wrapper of void TBranch::SetFirstEntry(Long64_t)
@trydoc raw"""
    SetFirstEntry(this::ByRef1{TBranch}, entry::Int64)::Nothing
set the first entry number (case of [TBranchSTL](@ref))

""" SetFirstEntry(this::ByRef1{TBranch}, entry::Int64)

# Wrapper of bool TBranch::SetMakeClass(bool)
@trydoc raw"""
    SetMakeClass(this::ByRef1{TBranch}, decomposeObj::Bool)::Bool
Set the branch in a mode where the object are decomposed (Also known as MakeClass mode).
Return whether the setting was possible (it is not possible for [TBranch](@ref) and [TBranchObject](@ref)).
""" SetMakeClass(this::ByRef1{TBranch}, decomposeObj::Bool)

# Wrapper of void TBranch::SetObject(void *)
@trydoc raw"""
    SetObject(this::ByRef1{TBranch}, objadd::ByPtr2{Nothing})::Nothing
Set object this branch is pointing to.

""" SetObject(this::ByRef1{TBranch}, objadd::ByPtr2{Nothing})

# Wrapper of void TBranch::SetOffset(Int_t)
@trydoc raw"""
    SetOffset(this::ByRef1{TBranch}, offset::Int32)::Nothing


""" SetOffset(this::ByRef1{TBranch}, offset::Int32)

# Wrapper of void TBranch::SetStatus(bool)
@trydoc raw"""
    SetStatus(this::ByRef1{TBranch}, status::Bool)::Nothing
Set branch status to Process or DoNotProcess.

""" SetStatus(this::ByRef1{TBranch}, status::Bool)

# Wrapper of void TBranch::SetTree(TTree *)
@trydoc raw"""
    SetTree(this::ByRef1{TBranch}, tree::ByPtr1{TTree})::Nothing


""" SetTree(this::ByRef1{TBranch}, tree::ByPtr1{TTree})

# Wrapper of void TBranch::SetupAddresses()
@trydoc raw"""
    SetupAddresses(this::ByRef1{TBranch})::Nothing
If the branch address is not set, we set all addresses starting with the top level parent branch.

""" SetupAddresses(this::ByRef1{TBranch})

# Wrapper of bool TBranch::SupportsBulkRead()
@trydoc raw"""
    SupportsBulkRead(this::ByConstRef1{TBranch})::Bool
Returns true if this branch supports bulk IO, false otherwise.
This will return true if all the various preconditions necessary hold true to perform bulk IO (reasonable type, single [TLeaf](@ref), etc); the bulk IO may still fail, depending on the contents of the individual TBaskets loaded.
""" SupportsBulkRead(this::ByConstRef1{TBranch})

# Wrapper of void TBranch::UpdateAddress()
@trydoc raw"""
    UpdateAddress(this::ByRef1{TBranch})::Nothing


""" UpdateAddress(this::ByRef1{TBranch})

# Wrapper of void TBranch::UpdateFile()
@trydoc raw"""
    UpdateFile(this::ByRef1{TBranch})::Nothing
Refresh the value of fDirectory (i.e.
where this branch writes/reads its buffers) with the current value of fTree->GetCurrentFile unless this branch has been redirected to a different file. Also update the sub-branches.
""" UpdateFile(this::ByRef1{TBranch})

# Wrapper of void TBranch::ResetCount()
@trydoc raw"""
    TBranch!ResetCount(this::ByRef1{TBranch})::Nothing
Static function resetting fgCount.

""" TBranch!ResetCount(this::ByRef1{TBranch})

# Wrapper of void TTree::AddAllocationCount(UInt_t)
@trydoc raw"""
    AddAllocationCount(this::ByRef1{TTree}, count::UInt32)::Nothing


""" AddAllocationCount(this::ByRef1{TTree}, count::UInt32)

# Wrapper of Int_t TTree::AddBranchToCache(const char *, bool)
@trydoc raw"""
    AddBranchToCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)::Int32
Add branch with name bname to the Tree cache.
If bname="*" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.

Returns:

- 0 branch added or already included
- -1 on error
""" AddBranchToCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)

# Wrapper of Int_t TTree::AddBranchToCache(TBranch *, bool)
@trydoc raw"""
    AddBranchToCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)::Int32
Add branch b to the Tree cache.
if subbranches is true all the branches of the subbranches are also put to the cache.

Returns:

- 0 branch added or already included
- -1 on error
""" AddBranchToCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)

# Wrapper of void TTree::AddClone(TTree *)
@trydoc raw"""
    AddClone(this::ByRef1{TTree}, ::ByPtr1{TTree})::Nothing
Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted.

""" AddClone(this::ByRef1{TTree}, ::ByPtr1{TTree})

# Wrapper of void TTree::AddTotBytes(Int_t)
@trydoc raw"""
    AddTotBytes(this::ByRef1{TTree}, tot::Int32)::Nothing


""" AddTotBytes(this::ByRef1{TTree}, tot::Int32)

# Wrapper of void TTree::AddZipBytes(Int_t)
@trydoc raw"""
    AddZipBytes(this::ByRef1{TTree}, zip::Int32)::Nothing


""" AddZipBytes(this::ByRef1{TTree}, zip::Int32)

# Wrapper of Long64_t TTree::AutoSave(Option_t *)
@trydoc raw"""
    AutoSave(this::ByRef1{TTree}, option::ByCopy{String})::Int64
AutoSave tree header every fAutoSave bytes.
When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by [TTree!Fill](@ref) when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by [TTree!Fill](@ref) every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.

Note that calling [TTree!AutoSave](@ref) too frequently (or similarly calling [TTree!SetAutoSave](@ref) with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.

In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.

if option contains "SaveSelf", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.

if option contains "FlushBaskets", [TTree!FlushBaskets](@ref) is called and all the current basket are closed-out and written to disk individually.

By default the previous header is deleted after having written the new header. if option contains "Overwrite", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.

The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file.

## How to write a Tree in one process and view it from another process

The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2

script treew.C: 

    void treew() {
       TFile f("test.root","recreate");
       TNtuple *ntuple = new TNtuple("ntuple","Demo","px:py:pz:random:i");
       Float_t px, py, pz;
       for ( Int_t i=0; i<10000000; i++) {
          gRandom->Rannor(px,py);
          pz = px*px + py*py;
          Float_t random = gRandom->Rndm(1);
          ntuple->Fill(px,py,pz,random,i);
          if (i%1000 == 1) ntuple->AutoSave("SaveSelf");
       }
    }

(C++ version of the code)

 script treer.C: 

    void treer() {
       TFile f("test.root");
       TTree *ntuple = (TTree*)f.Get("ntuple");
       TCanvas c1;
       Int_t first = 0;
       while(1) {
          if (first == 0) ntuple->Draw("px>>hpx", "","",10000000,first);
          else            ntuple->Draw("px>>+hpx","","",10000000,first);
          first = (Int_t)ntuple->GetEntries();
          c1.Update();
          gSystem->Sleep(1000); //sleep 1 second
          ntuple->Refresh();
       }
    }

(C++ version of the code)
""" AutoSave(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of Int_t TTree::Branch(const char *, Int_t, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, folder::ByCopy{String}, bufsize::Int32, splitlevel::Int32)::Int32
Create one branch for each element in the folder.
Returns the total number of branches created.
""" Branch(this::ByRef1{TTree}, folder::ByCopy{String}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::Branch(const char *, char *, const char *, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Int8}, leaflist::ByCopy{String}, bufsize::Int32)::CxxPtr1{TBranch}


""" Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Int8}, leaflist::ByCopy{String}, bufsize::Int32)

# Wrapper of TBranch * TTree::Branch(const char *, const char *, void *, Int_t, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)::CxxPtr1{TBranch}
Create a new branch with the object of class classname at address addobj.
WARNING:

Starting with Root version 3.01, the Branch function uses the new style branches ([TBranchElement](@ref)). To get the old behaviour, you can:

- call BranchOld or
- call TTree!SetBranchStyle(0)

Note that with the new style, classname does not need to derive from [TObject](@ref). It must derived from [TObject](@ref) if the branch style has been set to 0 (old)

Note: See the comments in [TBranchElement!SetAddress()](@ref) for a more detailed discussion of the meaning of the addobj parameter in the case of new-style branches.

Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer

Note: if the split level is set to the default (99), [TTree!Branch](@ref) will not issue a warning if the class can not be split.
""" Branch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::Branch(const char *, void *, const char *, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Nothing}, leaflist::ByCopy{String}, bufsize::Int32)::CxxPtr1{TBranch}
Create a new [TTree](@ref) Branch.
This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.

By default the branch buffers are stored in the same file as the Tree. use [TBranch!SetFile](@ref) to specify a different file

- address is the address of the first item of a structure.
- leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:

    - `C` : a character string terminated by the 0 character
    - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.
    - `b` : an 8 bit unsigned integer (`UChar_t`)
    - `S` : a 16 bit signed integer (`Short_t`)
    - `s` : a 16 bit unsigned integer (`UShort_t`)
    - `I` : a 32 bit signed integer (`Int_t`)
    - `i` : a 32 bit unsigned integer (`UInt_t`)
    - `F` : a 32 bit floating point (`Float_t`)
    - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`)
    - `D` : a 64 bit floating point (`Double_t`)
    - `d` : a 24 bit truncated floating point (`Double32_t`)
    - `L` : a 64 bit signed integer (`Long64_t`)
    - `l` : a 64 bit unsigned integer (`ULong64_t`)
    - `G` : a long signed integer, stored as 64 bit (`Long_t`)
    - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`)
    - `O` : [the letter `o`, not a zero] a boolean (`bool`)

    Arrays of values are supported with the following syntax:

    - If leaf name has the form var[nelem], where nelem is alphanumeric, then if nelem is a leaf name, it is used as the variable size of the array, otherwise return 0. The leaf referred to by nelem **MUST** be an int (/I),
    - If leaf name has the form var[nelem], where nelem is a non-negative integer, then it is used as the fixed size of the array.
    - If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]) where nelem and nelem2 are non-negative integer) then it is used as a 2 dimensional array of fixed size.
    - In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. See `TStreamerElement!GetRange()` for further information.

    Any of other form is not supported.

Note that the [TTree](@ref) will assume that all the item are contiguous in memory. On some platform, this is not always true of the member of a struct or a class, due to padding and alignment. Sorting your data member in order of decreasing sizeof usually leads to their being contiguous in memory.

- bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.
""" Branch(this::ByRef1{TTree}, name::ByCopy{String}, address::ByPtr2{Nothing}, leaflist::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TTree::Branch(TCollection *, Int_t, Int_t, const char *)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, list::ByPtr1{TCollection}, bufsize::Int32, splitlevel::Int32, name::ByCopy{String})::Int32
Create one branch for each element in the collection.
Each entry in the collection becomes a top level branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The splitlevel is decreased by 1 every time a new collection is found. For example if list is a TObjArray*

- if splitlevel = 1, one top level branch is created for each element of the [TObjArray](@ref).
- if splitlevel = 2, one top level branch is created for each array element. if, in turn, one of the array elements is a [TCollection](@ref), one top level branch will be created for each element of this collection.

In case a collection element is a [TClonesArray](@ref), the special Tree constructor for [TClonesArray](@ref) is called. The collection itself cannot be a [TClonesArray](@ref).

The function returns the total number of branches created.

If name is given, all branch names will be prefixed with name_.

IMPORTANT NOTE1: This function should not be called with splitlevel < 1.

IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name for a [TList](@ref) is "TList".

And in general, in case two or more master branches contain subbranches with identical names, one must add a "." (dot) character at the theend of the master branch name. This will force the name of the subbranches to be of the form `master.subbranch` instead of simply `subbranch`. This situation happens when the top level object has two or more members referencing the same class. Without the dot, the prefix will not be there and that might cause ambiguities. For example, if a Tree has two branches [B1](@ref) and B2 corresponding to objects of the same class MyClass, one can do: 

    tree.Branch("B1.","MyClass",&b1,8000,1);
    tree.Branch("B2.","MyClass",&b2,8000,1);

(C++ version of the code)

 if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c In other words, the trailing dot of the branch name is semantically relevant and recommended.

Example: 

    {
          TTree T("T","test list");
          TList *list = new TList();
          TObjArray *a1 = new TObjArray();
          a1->SetName("a1");
          list->Add(a1);
          TH1F *ha1a = new TH1F("ha1a","ha1",100,0,1);
          TH1F *ha1b = new TH1F("ha1b","ha1",100,0,1);
          a1->Add(ha1a);
          a1->Add(ha1b);
          TObjArray *b1 = new TObjArray();
          b1->SetName("b1");
          list->Add(b1);
          TH1F *hb1a = new TH1F("hb1a","hb1",100,0,1);
          TH1F *hb1b = new TH1F("hb1b","hb1",100,0,1);
          b1->Add(hb1a);
          b1->Add(hb1b);
          TObjArray *a2 = new TObjArray();
          a2->SetName("a2");
          list->Add(a2);
          TH1S *ha2a = new TH1S("ha2a","ha2",100,0,1);
          TH1S *ha2b = new TH1S("ha2b","ha2",100,0,1);
          a2->Add(ha2a);
          a2->Add(ha2b);
          T.Branch(list,16000,2);
          T.Print();
    }

(C++ version of the code)
""" Branch(this::ByRef1{TTree}, list::ByPtr1{TCollection}, bufsize::Int32, splitlevel::Int32, name::ByCopy{String})

# Wrapper of Int_t TTree::Branch(TList *, Int_t, Int_t)
@trydoc raw"""
    Branch(this::ByRef1{TTree}, list::ByPtr1{TList}, bufsize::Int32, splitlevel::Int32)::Int32
Deprecated function. Use next function instead.

""" Branch(this::ByRef1{TTree}, list::ByPtr1{TList}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::BranchOld(const char *, const char *, void *, Int_t, Int_t)
@trydoc raw"""
    BranchOld(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)::CxxPtr1{TBranch}
Create a new [TTree](@ref) BranchObject.
Build a [TBranchObject](@ref) for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from [TObject](@ref). The class dictionary must be available (ClassDef in class header).

This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.

By default the branch buffers are stored in the same file as the Tree. use [TBranch!SetFile](@ref) to specify a different file

IMPORTANT NOTE about branch names:

And in general, in case two or more master branches contain subbranches with identical names, one must add a "." (dot) character at the theend of the master branch name. This will force the name of the subbranches to be of the form `master.subbranch` instead of simply `subbranch`. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches [B1](@ref) and B2 corresponding to objects of the same class MyClass, one can do: 

    tree.Branch("B1.","MyClass",&b1,8000,1);
    tree.Branch("B2.","MyClass",&b2,8000,1);

(C++ version of the code)

 if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.
""" BranchOld(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)

# Wrapper of TBranch * TTree::BranchRef()
@trydoc raw"""
    BranchRef(this::ByRef1{TTree})::CxxPtr1{TBranch}
Build the optional branch supporting the [TRefTable](@ref).
This branch will keep all the information to find the branches containing referenced objects.

At each Tree!Fill, the branch numbers containing the referenced objects are saved to the [TBranchRef](@ref) basket. When the Tree header is saved (via [TTree!Write](@ref)), the branch is saved keeping the information with the pointers to the branches having referenced objects.
""" BranchRef(this::ByRef1{TTree})

# Wrapper of TBranch * TTree::Bronch(const char *, const char *, void *, Int_t, Int_t)
@trydoc raw"""
    Bronch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)::CxxPtr1{TBranch}
Create a new [TTree](@ref) BranchElement.
## WARNING about this new function

This function is designed to replace the internal implementation of the old [TTree!Branch](@ref) (whose implementation has been moved to BranchOld).

NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.

This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from [TObject](@ref). The function is based on the new [TStreamerInfo](@ref).

Build a [TBranchElement](@ref) for an object of class classname.

addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).

Note: See the comments in [TBranchElement!SetAddress()](@ref) for a more detailed discussion of the meaning of the addr parameter.

This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.

By default the branch buffers are stored in the same file as the Tree. use [TBranch!SetFile](@ref) to specify a different file

IMPORTANT NOTE about branch names:

And in general, in case two or more master branches contain subbranches with identical names, one must add a "." (dot) character at the theend of the master branch name. This will force the name of the subbranches to be of the form `master.subbranch` instead of simply `subbranch`. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches [B1](@ref) and B2 corresponding to objects of the same class MyClass, one can do: 

    tree.Branch("B1.","MyClass",&b1,8000,1);
    tree.Branch("B2.","MyClass",&b2,8000,1);

(C++ version of the code)

 if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.

Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer

Note: if the split level is set to the default (99), [TTree!Branch](@ref) will not issue a warning if the class can not be split.
""" Bronch(this::ByRef1{TTree}, name::ByCopy{String}, classname::ByCopy{String}, addobj::ByPtr2{Nothing}, bufsize::Int32, splitlevel::Int32)

# Wrapper of void TTree::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TTree}, ::ByPtr1{TBrowser})::Nothing
Browse content of the [TTree](@ref).

""" Browse(this::ByRef1{TTree}, ::ByPtr1{TBrowser})

# Wrapper of Int_t TTree::BuildIndex(const char *, const char *)
@trydoc raw"""
    BuildIndex(this::ByRef1{TTree}, majorname::ByCopy{String}, minorname::ByCopy{String})::Int32
Build a Tree Index (default is [TTreeIndex](@ref)).
See a description of the parameters and functionality in [TTreeIndex!TTreeIndex()](@ref).

The return value is the number of entries in the Index (< 0 indicates failure).

A [TTreeIndex](@ref) object pointed by fTreeIndex is created. This object will be automatically deleted by the [TTree](@ref) destructor. If an index is already existing, this is replaced by the new one without being deleted. This behaviour prevents the deletion of a previously external index assigned to the [TTree](@ref) via the [TTree!SetTreeIndex()](@ref) method. 

###See

TTree!SetTreeIndex()
""" BuildIndex(this::ByRef1{TTree}, majorname::ByCopy{String}, minorname::ByCopy{String})

# Wrapper of TStreamerInfo * TTree::BuildStreamerInfo(TClass *, void *, bool)
@trydoc raw"""
    BuildStreamerInfo(this::ByRef1{TTree}, cl::ByPtr1{TClass}, pointer::ByPtr2{Nothing}, canOptimize::Bool)::CxxPtr1{TStreamerInfo}
Build StreamerInfo for class cl.
pointer is an optional argument that may contain a pointer to an object of cl.
""" BuildStreamerInfo(this::ByRef1{TTree}, cl::ByPtr1{TClass}, pointer::ByPtr2{Nothing}, canOptimize::Bool)

# Wrapper of TFile * TTree::ChangeFile(TFile *)
@trydoc raw"""
    ChangeFile(this::ByRef1{TTree}, file::ByPtr1{TFile})::CxxPtr1{TFile}
Called by [TTree!Fill()](@ref) when file has reached its maximum fgMaxTreeSize.
Create a new file. If the original file is named "myfile.root", subsequent files are named "myfile_1.root", "myfile_2.root", etc.

Returns a pointer to the new file.

Currently, the automatic change of file is restricted to the case where the tree is in the top level directory. The file should not contain sub-directories.

Before switching to a new file, the tree header is written to the current file, then the current file is closed.

To process the multiple files created by ChangeFile, one must use a [TChain](@ref).

The new file name has a suffix "_N" where N is equal to fFileNumber+1. By default a Root session starts with fFileNumber=0. One can set fFileNumber to a different value via [TTree!SetFileNumber](@ref). In case a file named "_N" already exists, the function will try a file named "__N", then "___N", etc.

fgMaxTreeSize can be set via the static function [TTree!SetMaxTreeSize](@ref). The default value of fgMaxTreeSize is 100 Gigabytes.

If the current file contains other objects like [TH1](@ref) and [TTree](@ref), these objects are automatically moved to the new file.

###Warning

Be careful when writing the final Tree header to the file! Don't do: TFile*file=newTFile("myfile.root","recreate");
TTree*T=newTTree("T","title");
T->Fill();//Loop
file->Write();
file->Close();
 

###Warning

but do the following: TFile*file=newTFile("myfile.root","recreate");
TTree*T=newTTree("T","title");
T->Fill();//Loop
file=T->GetCurrentFile();//Togetthepointertothecurrentfile
file->Write();
file->Close();


###Note

This method is never called if the input file is a TMemFile or derivate.
""" ChangeFile(this::ByRef1{TTree}, file::ByPtr1{TFile})

# Wrapper of TTree * TTree::CloneTree(Long64_t, Option_t *)
@trydoc raw"""
    CloneTree(this::ByRef1{TTree}, nentries::Int64, option::ByCopy{String})::CxxPtr1{TTree}
Create a clone of this tree and copy nentries.
By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.

NOTE: Only active branches are copied. See [TTree!SetBranchStatus](@ref) for more information and usage regarding the (de)activation of branches. More examples are provided in the tutorials listed below.

NOTE: If the [TTree](@ref) is a [TChain](@ref), the structure of the first [TTree](@ref) is used for the copy.

IMPORTANT: The cloned tree stays connected with this tree until this tree is deleted. In particular, any changes in branch addresses in this tree are forwarded to the clone trees, unless a branch in a clone tree has had its address changed, in which case that change stays in effect. When this tree is deleted, all the addresses of the cloned tree are reset to their default values.

If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).

When 'fast' is specified, 'option' can also contain a sorting order for the baskets in the output file.

There are currently 3 supported sorting order:

- SortBasketsByOffset (the default)
- SortBasketsByBranch
- SortBasketsByEntry

When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the baskets are sorted by their offset in the original file; Usually this also means that the baskets are sorted by the index/number of the *last* entry they contain)

When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).

When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.

For examples of CloneTree, see tutorials:

- copytree.C: A macro to copy a subset of a [TTree](@ref) to a new [TTree](@ref). The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1
- copytree2.C: A macro to copy a subset of a [TTree](@ref) to a new [TTree](@ref). One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1
""" CloneTree(this::ByRef1{TTree}, nentries::Int64, option::ByCopy{String})

# Wrapper of void TTree::CopyAddresses(TTree *, bool)
@trydoc raw"""
    CopyAddresses(this::ByRef1{TTree}, ::ByPtr1{TTree}, undo::Bool)::Nothing
Set branch addresses of passed tree equal to ours.
If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original.
""" CopyAddresses(this::ByRef1{TTree}, ::ByPtr1{TTree}, undo::Bool)

# Wrapper of Long64_t TTree::CopyEntries(TTree *, Long64_t, Option_t *, bool)
@trydoc raw"""
    CopyEntries(this::ByRef1{TTree}, tree::ByPtr1{TTree}, nentries::Int64, option::ByCopy{String}, needCopyAddresses::Bool)::Int64
Copy nentries from given tree to this tree.
This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).

By default copy all entries.

Returns number of bytes copied to this tree.

If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).

When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.

There are currently 3 supported sorting order:

- SortBasketsByOffset (the default)
- SortBasketsByBranch
- SortBasketsByEntry

See [TTree!CloneTree](@ref) for a detailed explanation of the semantics of these 3 options.

If the tree or any of the underlying tree of the chain has an index, that index and any index in the subsequent underlying [TTree](@ref) objects will be merged.

There are currently three 'options' to control this merging:

- NoIndex : all the [TTreeIndex](@ref) object are dropped.
- DropIndexOnError : if any of the underlying [TTree](@ref) object do no have a [TTreeIndex](@ref), they are all dropped.
- AsIsIndexOnError [default]: In case of missing [TTreeIndex](@ref), the resulting [TTree](@ref) index has gaps.
- BuildIndexOnError : If any of the underlying [TTree](@ref) objects do not have a [TTreeIndex](@ref), all [TTreeIndex](@ref) are 'ignored' and the missing piece are rebuilt.
""" CopyEntries(this::ByRef1{TTree}, tree::ByPtr1{TTree}, nentries::Int64, option::ByCopy{String}, needCopyAddresses::Bool)

# Wrapper of TTree * TTree::CopyTree(const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    CopyTree(this::ByRef1{TTree}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::CxxPtr1{TTree}
Copy a tree with selection.
### Important:

The returned copied tree stays connected with the original tree until the original tree is deleted. In particular, any changes to the branch addresses in the original tree are also made to the copied tree. Any changes made to the branch addresses of the copied tree are overridden anytime the original tree changes its branch addresses. When the original tree is deleted, all the branch addresses of the copied tree are set to zero.

For examples of CopyTree, see the tutorials:

- copytree.C: Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in $ROOTSYS/test/Event in this way: 

        ./Event 1000 1 1 1

(C++ version of the code)

- copytree2.C Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in $ROOTSYS/test/Event in this way: 

        ./Event 1000 1 1 1

(C++ version of the code)

- copytree3.C Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree. NOTE that only the active branches are copied.
""" CopyTree(this::ByRef1{TTree}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Int_t TTree::Debug()
@trydoc raw"""
    Debug(this::ByConstRef1{TTree})::Int32


""" Debug(this::ByConstRef1{TTree})

# Wrapper of void TTree::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TTree}, option::ByCopy{String})::Nothing
Delete this tree from memory or/and disk.
- if option == "all" delete Tree object from memory AND from disk all baskets on disk are deleted. All keys with same name are deleted.
- if option =="" only Tree object in memory is deleted.
""" Delete(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TTree}, ::ByPtr1{TDirectory})::Nothing
Called by [TKey](@ref) and [TObject!Clone](@ref) to automatically add us to a directory when we are read from a file.

""" DirectoryAutoAdd(this::ByRef1{TTree}, ::ByPtr1{TDirectory})

# Wrapper of Long64_t TTree::Draw(const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Draw(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Draw expression varexp for entries and objects that pass a (optional) selection.
###Return

-1 in case of error or number of selected events in case of success.

## Arguments

- **`varexp`** [in] 
    A string that takes one of these general forms:
    
    - "e1" produces a 1-d histogram ([TH1F](@ref)) of expression "e1"
    - "e1:e2" produces an unbinned 2-d scatter-plot ([TGraph](@ref)) of "e1" on the y-axis versus "e2" on the x-axis
    - "e1:e2:e3" produces an unbinned 3-d scatter-plot ([TPolyMarker3D](@ref)) of "e1" vs "e2" vs "e3" on the z-, y-, x-axis, respectively
    - "e1:e2:e3:e4" produces an unbinned 3-d scatter-plot ([TPolyMarker3D](@ref)) of "e1" vs "e2" vs "e3" and "e4" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section "Saving the result of Draw to an histogram")
    
        - "e1:e2:e3:e4:e5" with option "GL5D" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.
        - Any number of variables no fewer than two can be used with the options "CANDLE" and "PARA"
        - An arbitrary number of variables can be used with the option "GOFF"
    
        Examples:
    
        - "x": the simplest case, it draws a 1-Dim histogram of column x
        - "sqrt(x)", "x*y/z": draw histogram with the values of the specified numerical expression across [TTree](@ref) events
        - "y:sqrt(x)": 2-Dim histogram of y versus sqrt(x)
        - "px:py:pz:2.5*E": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See [TStyle!SetPalette](@ref) for setting a new color palette.
    
        The expressions can use all the operations and built-in functions supported by [TFormula](@ref) (see TFormula!Analyze()), including free functions taking numerical arguments (e.g. TMath!Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: 
    
            TMath!BreitWigner(fPx,3,2)
            event.GetHistogram()->GetXaxis()->GetXmax()
    
        (C++ version of the code)
    
         
    
    
    
- **`selection`** [in] 
    A string containing a selection expression. In a selection all usual C++ mathematical and logical operators are allowed. The value corresponding to the selection expression is used as a weight to fill the histogram (a weight of 0 is equivalent to not filling the histogram).<br/>
     <br/>
     Examples:
    
    - "x<y && sqrt(z)>3.2": returns a weight = 0 or 1
    - "(x+y)*(sqrt(z)>3.2)": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise<br/>
     <br/>
     If the selection expression returns an array, it is iterated over in sync with the array returned by the varexp argument (as described below in "Drawing expressions using arrays and array
      elements"). For example, if, for a given event, varexp evaluates to `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection: 
    
            // Muon_pt is an array: fill a histogram with the array elements > 100 in each event
            tree->Draw('Muon_pt', 'Muon_pt > 100')
    
    (C++ version of the code)
    
     
    
    
    
- **`option`** [in] 
    The drawing option.
    
    - When an histogram is produced it can be any histogram drawing option listed in [THistPainter](@ref).
    - when no option is specified:
    
        - the default histogram drawing option is used if the expression is of the form "e1".
        - if the expression is of the form "e1:e2"or "e1:e2:e3" a cloud of unbinned 2D or 3D points is drawn respectively.
        - if the expression has four fields "e1:e2:e3:e4" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette.
    - If option COL is specified when varexp has three fields: 
    
            tree.Draw("e1:e2:e3","","col");
    
    (C++ version of the code)
    
     a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.
    - if expression has more than four fields the option "PARA"or "CANDLE" can be used.
    - If option contains the string "goff", no graphics is generated. 
    
    
    
- **`nentries`** [in] 
    The number of entries to process (default is all) 
    
- **`firstentry`** [in] 
    The first entry to process (default is 0)
    

### Drawing expressions using arrays and array elements

Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array, or a [TClonesArray](@ref). In a [TTree!Draw](@ref) expression you can now access fMatrix using the following syntaxes:

| **String passed** | **What is used for each entry of the tree**                   |
|:------------------|:--------------------------------------------------------------|
| `fMatrix`         | the 9 elements of fMatrix                                     |
| `fMatrix[][]`     | the 9 elements of fMatrix                                     |
| `fMatrix[2][2]`   | only the elements fMatrix[2][2]                               |
| `fMatrix[1]`      | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |
| `fMatrix[1][]`    | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |
| `fMatrix[][0]`    | the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] |

"fEvent.fMatrix...." same as "fMatrix..." (unless there is more than one leaf named fMatrix!).

In summary, if a specific index is not specified for a dimension, [TTree!Draw](@ref) will loop through all the indices along this dimension. Leaving off the last (right most) dimension of specifying then with the two characters '[]' is equivalent. For variable size arrays (and [TClonesArray](@ref)) the range of the first dimension is recalculated for each entry of the tree. You can also specify the index as an expression of any other variables from the tree.

[TTree!Draw](@ref) also now properly handling operations involving 2 or more arrays.

Let assume a second matrix fResults[5][2], here are a sample of some of the possible combinations, the number of elements they produce and the loop used:

| **expression**                   | **element(s)** | **Loop**                                                                                                                       |
|:---------------------------------|:---------------|:-------------------------------------------------------------------------------------------------------------------------------|
| `fMatrix[2][1] - fResults[5][2]` | one            | no loop                                                                                                                        |
| `fMatrix[2][] - fResults[5][2]`  | three          | on 2nd dim fMatrix                                                                                                             |
| `fMatrix[2][] - fResults[5][]`   | two            | on both 2nd dimensions                                                                                                         |
| `fMatrix[][2] - fResults[][1]`   | three          | on both 1st dimensions                                                                                                         |
| `fMatrix[][2] - fResults[][]`    | six            | on both 1st and 2nd dimensions of fResults                                                                                     |
| `fMatrix[][2] - fResults[3][]`   | two            | on 1st dim of fMatrix and 2nd of fResults (at the same time)                                                                   |
| `fMatrix[][] - fResults[][]`     | six            | on 1st dim then on 2nd dim                                                                                                     |
| `fMatrix[][fResult[][]]`         | 30             | on 1st dim of fMatrix then on both dimensions of fResults. The value if fResults[j][k] is used as the second index of fMatrix. |

In summary, [TTree!Draw](@ref) loops through all unspecified dimensions. To figure out the range of each loop, we match each unspecified dimension from left to right (ignoring ALL dimensions for which an index has been specified), in the equivalent loop matched dimensions use the same index and are restricted to the smallest range (of only the matched dimensions). When involving variable arrays, the range can of course be different for each entry of the tree.

So the loop equivalent to "fMatrix[][2] - fResults[3][]" is: 

    for (Int_t i0; i < min(3,2); i++) {
       use the value of (fMatrix[i0][2] - fMatrix[3][i0])
    }

(C++ version of the code)

 So the loop equivalent to "fMatrix[][2] - fResults[][]" is: 

    for (Int_t i0; i < min(3,5); i++) {
       for (Int_t i1; i1 < 2; i1++) {
          use the value of (fMatrix[i0][2] - fMatrix[i0][i1])
       }
    }

(C++ version of the code)

 So the loop equivalent to "fMatrix[][] - fResults[][]" is: 

    for (Int_t i0; i < min(3,5); i++) {
       for (Int_t i1; i1 < min(3,2); i1++) {
          use the value of (fMatrix[i0][i1] - fMatrix[i0][i1])
       }
    }

(C++ version of the code)

 So the loop equivalent to "fMatrix[][fResults[][]]" is: 

    for (Int_t i0; i0 < 3; i0++) {
       for (Int_t j2; j2 < 5; j2++) {
          for (Int_t j3; j3 < 2; j3++) {
             i1 = fResults[j2][j3];
             use the value of fMatrix[i0][i1]
       }
    }

(C++ version of the code)

 

### Retrieving the result of Draw

By default a temporary histogram called `htemp` is created. It will be:

- A TH1F* in case of a mono-dimensional distribution: `Draw("e1")`,
- A TH2F* in case of a bi-dimensional distribution: `Draw("e1:e2")`,
- A TH3F* in case of a three-dimensional distribution: `Draw("e1:e2:e3")`.

In the one dimensional case the `htemp` is filled and drawn whatever the drawing option is.

In the two and three dimensional cases, with the default drawing option (`""`), a cloud of points is drawn and the histogram `htemp` is not filled. For all the other drawing options `htemp` will be filled.

In all cases `htemp` can be retrieved by calling:

    auto htemp = (TH1F*)gPad->GetPrimitive("htemp"); // 1D
    auto htemp = (TH2F*)gPad->GetPrimitive("htemp"); // 2D
    auto htemp = (TH3F*)gPad->GetPrimitive("htemp"); // 3D

(C++ version of the code)

In the two dimensional case (`Draw("e1;e2")`), with the default drawing option, the data is filled into a [TGraph](@ref) named `Graph`. This [TGraph](@ref) can be retrieved by calling

    auto graph = (TGraph*)gPad->GetPrimitive("Graph");

(C++ version of the code)

For the three and four dimensional cases, with the default drawing option, an unnamed [TPolyMarker3D](@ref) is produced, and therefore cannot be retrieved.

In all cases `htemp` can be used to access the axes. For instance in the 2D case:

    auto htemp = (TH2F*)gPad->GetPrimitive("htemp");
    auto xaxis = htemp->GetXaxis();

(C++ version of the code)

When the option `"A"` is used (with [TGraph](@ref) painting option) to draw a 2D distribution: 

    tree.Draw("e1:e2","","A*");

(C++ version of the code)

 a scatter plot is produced (with stars in that case) but the axis creation is delegated to [TGraph](@ref) and `htemp` is not created.

### Saving the result of Draw to a histogram

If `varexp` contains `>>hnew` (following the variable(s) name(s)), the new histogram called `hnew` is created and it is kept in the current directory (and also the current pad). This works for all dimensions.

Example: 

    tree.Draw("sqrt(x)>>hsqrt","y>0")

(C++ version of the code)

 will draw `sqrt(x)` and save the histogram as "hsqrt" in the current directory. To retrieve it do: 

    TH1F *hsqrt = (TH1F*)gDirectory->Get("hsqrt");

(C++ version of the code)

 The binning information is taken from the environment variables 

    Hist.Binning.?D.?

(C++ version of the code)

 In addition, the name of the histogram can be followed by up to 9 numbers between '(' and ')', where the numbers describe the following:

- 1 - bins in x-direction
- 2 - lower limit in x-direction
- 3 - upper limit in x-direction
- 4-6 same for y-direction
- 7-9 same for z-direction

When a new binning is used the new value will become the default. Values can be skipped.

Example: 

    tree.Draw("sqrt(x)>>hsqrt(500,10,20)")
         // plot sqrt(x) between 10 and 20 using 500 bins
    tree.Draw("sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)")
         // plot sqrt(x) against sin(y)
         // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60
         //  50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5

(C++ version of the code)

 By default, the specified histogram is reset. To continue to append data to an existing histogram, use "+" in front of the histogram name.

A '+' in front of the histogram name is ignored, when the name is followed by binning information as described in the previous paragraph. 

    tree.Draw("sqrt(x)>>+hsqrt","y>0")

(C++ version of the code)

 will not reset `hsqrt`, but will continue filling. This works for 1-D, 2-D and 3-D histograms.

### Accessing collection objects

[TTree!Draw](@ref) default's handling of collections is to assume that any request on a collection pertain to it content. For example, if fTracks is a collection of Track objects, the following: 

    tree->Draw("event.fTracks.fPx");

(C++ version of the code)

 will plot the value of fPx for each Track objects inside the collection. Also 

    tree->Draw("event.fTracks.size()");

(C++ version of the code)

 would plot the result of the member function Track!size() for each Track object inside the collection. To access information about the collection itself, [TTree!Draw](@ref) support the '@' notation. If a variable which points to a collection is prefixed or postfixed with '@', the next part of the expression will pertain to the collection object. For example: 

    tree->Draw("event.@fTracks.size()");

(C++ version of the code)

 will plot the size of the collection referred to by `fTracks` (i.e the number of Track objects).

### Drawing 'objects'

When a class has a member function named AsDouble or AsString, requesting to directly draw the object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std!string or a TString.s For example, the following 

    tree->Draw("event.myTTimeStamp");

(C++ version of the code)

 will draw the same histogram as 

    tree->Draw("event.myTTimeStamp.AsDouble()");

(C++ version of the code)

 In addition, when the object is a type [TString](@ref) or std!string, [TTree!Draw](@ref) will call respectively `TString!Data` and `std!string!c_str()`

If the object is a [TBits](@ref), the histogram will contain the index of the bit that are turned on.

### Retrieving  information about the tree itself.

You can refer to the tree (or chain) containing the data by using the string 'This'. You can then could any [TTree](@ref) methods. For example: 

    tree->Draw("This->GetReadEntry()");

(C++ version of the code)

 will display the local_ entry numbers be read. 

    tree->Draw("This->GetUserInfo()->At(0)->GetName()");

(C++ version of the code)

 will display the name of the first 'user info' object.

### Special functions and variables

`Entry$`: A [TTree!Draw](@ref) formula can use the special variable `Entry$` to access the entry number being read. For example to draw every other entry use: 

    tree.Draw("myvar","Entry$%2==0");

(C++ version of the code)

- `Entry$` : return the current entry number (`== TTree!GetReadEntry()`)
- `LocalEntry$` : return the current entry number in the current tree of a chain (`== GetTree()->GetReadEntry()`)
- `Entries$` : return the total number of entries (== [TTree!GetEntries()](@ref))
- `LocalEntries$` : return the total number of entries in the current tree of a chain (== [GetTree()](@ref)->[TTree!GetEntries()](@ref))
- `Length$` : return the total number of element of this formula for this entry (`==TTreeFormula!GetNdata()`)
- `Iteration$` : return the current iteration over this formula for this entry (i.e. varies from 0 to `Length$`).
- `Length$(formula )` : return the total number of element of the formula given as a parameter.
- `Sum$(formula )` : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with: `Sum$(formula )/Length$(formula )`
- `Min$(formula )` : return the minimum (within one [TTree](@ref) entry) of the value of the elements of the formula given as a parameter.
- `Max$(formula )` : return the maximum (within one [TTree](@ref) entry) of the value of the elements of the formula given as a parameter.
- `MinIf$(formula,condition)`
- `MaxIf$(formula,condition)` : return the minimum (maximum) (within one [TTree](@ref) entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: 

        tree->Draw("MinIf$(formula,condition)","condition");

(C++ version of the code)

 which will avoid calculation `MinIf$` for the entries that have no match for the condition.
- `Alt$(primary,alternate)` : return the value of "primary" if it is available for the current iteration otherwise return the value of "alternate". For example, with arr1[3] and arr2[2] 

        tree->Draw("arr1+Alt$(arr2,0)");

(C++ version of the code)

 will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 

        tree->Draw("Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)");

(C++ version of the code)

 will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison 

        tree->Draw("arr3[0]+arr3[1]+arr3[2]");

(C++ version of the code)

 will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using `Alt$` with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by [TTree!Draw](@ref), [TTree!Scan](@ref) can be used: 

        tree->Scan("arr1:Alt$(arr2,0)");

(C++ version of the code)

 will print on one line the value of arr1 and (arr2,0) that will be matched by 

        tree->Draw("arr1-Alt$(arr2,0)");

(C++ version of the code)

 The ternary operator is not directly supported in [TTree!Draw](@ref) however, to plot the equivalent of `var2<20 ? -99 : var1`, you can use: 

        tree->Draw("(var2<20)*99+(var2>=20)*var1","");

(C++ version of the code)


### Drawing a user function accessing the TTree data directly

If the formula contains a file name, [TTree!MakeProxy](@ref) will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.

For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: 

    double hsimple() {
       return px;
    }

(C++ version of the code)

 MakeProxy can then be used indirectly via the [TTree!Draw](@ref) interface as follow: 

    new TFile("hsimple.root")
    ntuple->Draw("hsimple.cxx");

(C++ version of the code)

 A more complete example is available in the tutorials directory: `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C` which reimplement the selector found in `h1analysis.C`

The main features of this facility are:

- on-demand loading of branches
- ability to use the 'branchname' as if it was a data member
- protection against array out-of-bound
- ability to use the branch data as object (when the user code is available)

See [TTree!MakeProxy](@ref) for more details.

### Making a Profile histogram

In case of a 2-Dim expression, one can generate a [TProfile](@ref) histogram instead of a [TH2F](@ref) histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See [TProfile2D!SetErrorOption](@ref) for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing [TProfile](@ref) histogram.

### Making a 2D Profile histogram

In case of a 3-Dim expression, one can generate a [TProfile2D](@ref) histogram instead of a [TH3F](@ref) histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See [TProfile2D!SetErrorOption](@ref) for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing [TProfile2D](@ref) histogram.

### Making a 5D plot using GL

If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/io/tree/tree502_staff.C as example.

### Making a parallel coordinates plot

In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error.

### Making a candle sticks chart

In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error.

### Normalizing the output histogram to 1

When option contains "norm" the output histogram is normalized to 1.

### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray

[TTree!Draw](@ref) can be used to fill a [TEventList](@ref) object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a [TEventList](@ref) object named "elist" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option "entrylist" is used, a [TEntryList](@ref) object is created If the selection contains arrays, vectors or any container class and option "entrylistarray" is used, a [TEntryListArray](@ref) object is created containing also the subentries satisfying the selection, i.e. the indices of the branches which hold containers classes. Example: 

    tree.Draw(">>yplus","y>0")

(C++ version of the code)

 will create a [TEventList](@ref) object named "yplus" in the current directory. In an interactive session, one can type (after [TTree!Draw](@ref)) 

    yplus.Print("all")

(C++ version of the code)

 to print the list of entry numbers in the list. 

    tree.Draw(">>yplus", "y>0", "entrylist")

(C++ version of the code)

 will create a [TEntryList](@ref) object names "yplus" in the current directory 

    tree.Draw(">>yplus", "y>0", "entrylistarray")

(C++ version of the code)

 will create a [TEntryListArray](@ref) object names "yplus" in the current directory

By default, the specified entry list is reset. To continue to append data to an existing list, use "+" in front of the list name; 

    tree.Draw(">>+yplus","y>0")

(C++ version of the code)

 will not reset yplus, but will enter the selected entries at the theend of the existing list.

### Using a TEventList, TEntryList or TEntryListArray as Input

Once a [TEventList](@ref) or a [TEntryList](@ref) object has been generated, it can be used as input for [TTree!Draw](@ref). Use [TTree!SetEventList](@ref) or [TTree!SetEntryList](@ref) to set the current event list

Example 1: 

    TEventList *elist = (TEventList*)gDirectory->Get("yplus");
    tree->SetEventList(elist);
    tree->Draw("py");

(C++ version of the code)

 Example 2: 

    TEntryList *elist = (TEntryList*)gDirectory->Get("yplus");
    tree->SetEntryList(elist);
    tree->Draw("py");

(C++ version of the code)

 If a [TEventList](@ref) object is used as input, a new [TEntryList](@ref) object is created inside the SetEventList function. In case of a [TChain](@ref), all tree headers are loaded for this transformation. This new object is owned by the chain and is deleted with it, unless the user extracts it by calling [GetEntryList()](@ref) function. See also comments to [SetEventList()](@ref) function of [TTree](@ref) and [TChain](@ref).

If arrays are used in the selection criteria and [TEntryListArray](@ref) is not used, all the entries that have at least one element of the array that satisfy the selection are entered in the list.

Example: 

    tree.Draw(">>pyplus","fTracks.fPy>0");
    tree->SetEventList(pyplus);
    tree->Draw("fTracks.fPy");

(C++ version of the code)

 will draw the fPy of ALL tracks in event with at least one track with a positive fPy.

To select only the elements that did match the original selection use [TEventList!SetReapplyCut](@ref) or [TEntryList!SetReapplyCut](@ref).

Example: 

    tree.Draw(">>pyplus","fTracks.fPy>0");
    pyplus->SetReapplyCut(true);
    tree->SetEventList(pyplus);
    tree->Draw("fTracks.fPy");

(C++ version of the code)

 will draw the fPy of only the tracks that have a positive fPy.

To draw only the elements that match a selection in case of arrays, you can also use [TEntryListArray](@ref) (faster in case of a more general selection).

Example: 

    tree.Draw(">>pyplus","fTracks.fPy>0", "entrylistarray");
    tree->SetEntryList(pyplus);
    tree->Draw("fTracks.fPy");

(C++ version of the code)

 will draw the fPy of only the tracks that have a positive fPy, but without redoing the selection.

Note: Use tree->SetEventList(0) if you do not want use the list as input.

### How to obtain more info from TTree::Draw

Once [TTree!Draw](@ref) has been called, it is possible to access useful information still stored in the [TTree](@ref) object via the following functions:

- [GetSelectedRows()](@ref) // return the number of values accepted by the selection expression. In case where no selection was specified, returns the number of values processed.
- [GetV1()](@ref) // returns a pointer to the double array of V1
- [GetV2()](@ref) // returns a pointer to the double array of V2
- [GetV3()](@ref) // returns a pointer to the double array of V3
- [GetV4()](@ref) // returns a pointer to the double array of V4
- [GetW()](@ref) // returns a pointer to the double array of Weights where weight equal the result of the selection expression.

where V1,V2,V3 correspond to the expressions in 

    TTree!Draw("V1:V2:V3:V4",selection);

(C++ version of the code)

 If the expression has more than 4 component use GetVal(index)

Example: 

    Root > ntuple->Draw("py:px","pz>4");
    Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),
                                  ntuple->GetV2(), ntuple->GetV1());
    Root > gr->Draw("ap"); //draw graph in current pad

(C++ version of the code)

A more complete complete tutorial (treegetval.C) shows how to use the [GetVal()](@ref) method.

creates a [TGraph](@ref) object with a number of points corresponding to the number of entries selected by the expression "pz>4", the x points of the graph being the px values of the Tree and the y points the py values.

Important note: By default [TTree!Draw](@ref) creates the arrays obtained with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding to the parameter fEstimate. The content will be the last `GetSelectedRows() % GetEstimate()` values calculated. By default fEstimate=1000000 and can be modified via [TTree!SetEstimate](@ref). To keep in memory all the results (in case where there is only one result per entry), use 

    tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);

(C++ version of the code)

 You must call SetEstimate if the expected number of selected rows you need to look at is greater than 1000000.

You can use the option "goff" to turn off the graphics output of [TTree!Draw](@ref) in the above example.

### Automatic interface to TTree::Draw via the TTreeViewer

A complete graphical interface to this function is implemented in the class [TTreeViewer](@ref). To thestart the [TTreeViewer](@ref), three possibilities:

- select [TTree](@ref) context menu item "StartViewer"
- type the command "TTreeViewer TV(treeName)"
- execute statement "tree->StartViewer();"
""" Draw(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of void TTree::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TTree}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::DropBaskets()
@trydoc raw"""
    DropBaskets(this::ByRef1{TTree})::Nothing
Remove some baskets from memory.

""" DropBaskets(this::ByRef1{TTree})

# Wrapper of Int_t TTree::DropBranchFromCache(const char *, bool)
@trydoc raw"""
    DropBranchFromCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)::Int32
Remove the branch with name 'bname' from the Tree cache.
If bname="*" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.

Returns:

- 0 branch dropped or not in cache
- -1 on error
""" DropBranchFromCache(this::ByRef1{TTree}, bname::ByCopy{String}, subbranches::Bool)

# Wrapper of Int_t TTree::DropBranchFromCache(TBranch *, bool)
@trydoc raw"""
    DropBranchFromCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)::Int32
Remove the branch b from the Tree cache.
if subbranches is true all the branches of the subbranches are also removed from the cache.

Returns:

- 0 branch dropped or not in cache
- -1 on error
""" DropBranchFromCache(this::ByRef1{TTree}, branch::ByPtr1{TBranch}, subbranches::Bool)

# Wrapper of void TTree::DropBuffers(Int_t)
@trydoc raw"""
    DropBuffers(this::ByRef1{TTree}, nbytes::Int32)::Nothing
Drop branch buffers to accommodate nbytes below MaxVirtualsize.

""" DropBuffers(this::ByRef1{TTree}, nbytes::Int32)

# Wrapper of bool TTree::EnableCache()
@trydoc raw"""
    EnableCache(this::ByRef1{TTree})::Bool
Enable the [TTreeCache](@ref) unless explicitly disabled for this [TTree](@ref) by a prior call to `SetCacheSize(0)`.
If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config `TTreeCache.Size` has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster)

Return true if there is a cache attached to the `TTree` (either pre-exisiting or created as part of this call)
""" EnableCache(this::ByRef1{TTree})

# Wrapper of Int_t TTree::Fill()
@trydoc raw"""
    Fill(this::ByRef1{TTree})::Int32
Fill all branches.
This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.

This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.

The function returns the number of bytes committed to the individual branches.

If a write error occurs, the number of bytes returned is -1.

If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.

**The baskets are flushed and the Tree header saved at regular intervals**

At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.

###Note

Calling TTree!FlushBaskets too often increases the IO time.

###Note

Calling TTree!AutoSave too often increases the IO time and also the file size.

###Note

This method calls TTree!ChangeFile when the tree reaches a size greater than TTree!fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate.
""" Fill(this::ByRef1{TTree})

# Wrapper of TBranch * TTree::FindBranch(const char *)
@trydoc raw"""
    FindBranch(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TBranch}
Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches.
In case of ambiguity, returns the first match.
""" FindBranch(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of TLeaf * TTree::FindLeaf(const char *)
@trydoc raw"""
    FindLeaf(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TLeaf}
Find leaf..

""" FindLeaf(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of Int_t TTree::Fit(const char *, const char *, const char *, Option_t *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Fit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int32
Fit a projected item(s) from a tree.
funcname is a [TF1](@ref) function.

See [TTree!Draw()](@ref) for explanations of the other parameters.

By default the temporary histogram created is called htemp. If varexp contains >>hnew , the new histogram created is called hnew and it is kept in the current directory.

The function returns the number of selected entries.

Example: 

    tree.Fit(pol4,"sqrt(x)>>hsqrt","y>0")

(C++ version of the code)

 will fit sqrt(x) and save the histogram as "hsqrt" in the current directory.

See also [TTree!UnbinnedFit](@ref)

## Return status

The function returns the status of the histogram fit (see [TH1!Fit](@ref)) If no entries were selected, the function returns -1; (i.e. fitResult is null if the fit is OK)
""" Fit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Int_t TTree::FlushBaskets(bool)
@trydoc raw"""
    FlushBaskets(this::ByConstRef1{TTree}, create_cluster::Bool)::Int32
Write to disk all the basket that have not yet been individually written and create an event cluster boundary (by default).
If the caller wishes to flush the baskets but not create an event cluster, then set create_cluster to false.

If [ROOT](@ref) has IMT-mode enabled, this will launch multiple TBB tasks in parallel via TThreadExecutor to do this operation; one per basket compression. If the caller utilizes TBB also, care must be taken to prevent deadlocks.

For example, let's say the caller holds mutex A and calls FlushBaskets; while TBB is waiting for the [ROOT](@ref) compression tasks to complete, it may decide to run another one of the user's tasks in this thread. If the second user task tries to acquire A, then a deadlock will occur. The example call sequence looks like this:

- User acquires mutex A
- User calls FlushBaskets.
- [ROOT](@ref) launches N tasks and calls wait.
- TBB schedules another user task, T2.
- T2 tries to acquire mutex A.

At this point, the thread will deadlock: the code may function with IMT-mode disabled if the user assumed the legacy code never would run their own TBB tasks.

SO: users of TBB who want to enable IMT-mode should carefully review their locking patterns and make sure they hold no coarse-grained application locks when they invoke [ROOT](@ref).

Return the number of bytes written or -1 in case of write error.
""" FlushBaskets(this::ByConstRef1{TTree}, create_cluster::Bool)

# Wrapper of const char * TTree::GetAlias(const char *)
@trydoc raw"""
    GetAlias(this::ByConstRef1{TTree}, aliasName::ByCopy{String})::ByCopy{String}
Returns the expanded value of the alias. Search in the friends if any.

""" GetAlias(this::ByConstRef1{TTree}, aliasName::ByCopy{String})

# Wrapper of UInt_t TTree::GetAllocationCount()
@trydoc raw"""
    GetAllocationCount(this::ByConstRef1{TTree})::UInt32


""" GetAllocationCount(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetAutoFlush()
@trydoc raw"""
    GetAutoFlush(this::ByConstRef1{TTree})::Int64


""" GetAutoFlush(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetAutoSave()
@trydoc raw"""
    GetAutoSave(this::ByConstRef1{TTree})::Int64


""" GetAutoSave(this::ByConstRef1{TTree})

# Wrapper of TBranch * TTree::GetBranch(const char *)
@trydoc raw"""
    GetBranch(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TBranch}
Return pointer to the branch with the given name in this tree or its friends.
The search is done breadth first.
""" GetBranch(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of bool TTree::GetBranchStatus(const char *)
@trydoc raw"""
    GetBranchStatus(this::ByConstRef1{TTree}, branchname::ByCopy{String})::Bool
Return status of branch with name branchname.
- 0 if branch is not activated
- 1 if branch is activated
""" GetBranchStatus(this::ByConstRef1{TTree}, branchname::ByCopy{String})

# Wrapper of Long64_t TTree::GetCacheSize()
@trydoc raw"""
    GetCacheSize(this::ByConstRef1{TTree})::Int64


""" GetCacheSize(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetChainEntryNumber(Long64_t)
@trydoc raw"""
    GetChainEntryNumber(this::ByConstRef1{TTree}, entry::Int64)::Int64


""" GetChainEntryNumber(this::ByConstRef1{TTree}, entry::Int64)

# Wrapper of Long64_t TTree::GetChainOffset()
@trydoc raw"""
    GetChainOffset(this::ByConstRef1{TTree})::Int64


""" GetChainOffset(this::ByConstRef1{TTree})

# Wrapper of bool TTree::GetClusterPrefetch()
@trydoc raw"""
    GetClusterPrefetch(this::ByConstRef1{TTree})::Bool


""" GetClusterPrefetch(this::ByConstRef1{TTree})

# Wrapper of TFile * TTree::GetCurrentFile()
@trydoc raw"""
    GetCurrentFile(this::ByConstRef1{TTree})::CxxPtr1{TFile}
Return pointer to the current file.

""" GetCurrentFile(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetDebugMax()
@trydoc raw"""
    GetDebugMax(this::ByConstRef1{TTree})::Int64


""" GetDebugMax(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetDebugMin()
@trydoc raw"""
    GetDebugMin(this::ByConstRef1{TTree})::Int64


""" GetDebugMin(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetDefaultEntryOffsetLen()
@trydoc raw"""
    GetDefaultEntryOffsetLen(this::ByConstRef1{TTree})::Int32


""" GetDefaultEntryOffsetLen(this::ByConstRef1{TTree})

# Wrapper of TDirectory * TTree::GetDirectory()
@trydoc raw"""
    GetDirectory(this::ByConstRef1{TTree})::CxxPtr1{TDirectory}


""" GetDirectory(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{TTree})::Int64


""" GetEntries(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetEntries(const char *)
@trydoc raw"""
    GetEntries(this::ByRef1{TTree}, selection::ByCopy{String})::Int64
Return the number of entries matching the selection.
Return -1 in case of errors.

If the selection uses any arrays or containers, we return the number of entries where at least one element match the selection. GetEntries is implemented using the selector class [TSelectorEntries](@ref), which can be used directly (see code in [TTreePlayer!GetEntries](@ref)) for additional option. If SetEventList was used on the [TTree](@ref) or [TChain](@ref), only that subset of entries will be considered.
""" GetEntries(this::ByRef1{TTree}, selection::ByCopy{String})

# Wrapper of Long64_t TTree::GetEntriesFast()
@trydoc raw"""
    GetEntriesFast(this::ByConstRef1{TTree})::Int64
Return a number greater or equal to the total number of entries in the dataset.
###Note

If you are interested in the total number of entries in a TChain, this function will give that number once the last file of the chain is opened. In general, using this instead of GetEntries will avoid opening all files in the chain which could be very costly for very large number of files stored at a remote location.

The logic depends on whether the dataset is a [TTree](@ref) or a [TChain](@ref). In the first case, it simply returns the total number of entries in the tree. In the latter case, it depends on which point of the processing of the chain this function is called. During most of the chain processing, this function will return [TTree!kMaxEntries](@ref). When the chain arrives at the last file, then the function will return the accumulated total number of entries in the whole chain. A notable use case where this function becomes quite useful is when writing the following for loop to traverse the entries in the dataset:

    for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {
       // Do something with the event in the dataset
    }

(C++ version of the code)

In the example above, independently on whether the dataset is a [TTree](@ref) or a [TChain](@ref), the GetEntriesFast call will provide the correct stopping condition for the loop (i.e. the total number of entries). In the [TChain](@ref) case, calling GetEntries instead would open all the files in the chain upfront which could be costly.

The functionality offered by this method can also be seen when used in conjunction with LoadTree. For a call like ` LoadTree(ievent) `, the condition ` ievent < dataset.GetEntriesFast() ` is only satisfied if `ievent` is strictly smaller than the total number of entries in the dataset. In fact, even when the dataset is a [TChain](@ref), the first time LoadTree is called with an entry number that belongs to the last file of the chain, this will update the internal data member of the class so that the next call to GetEntriesFast returns the total number of entries in the dataset.
""" GetEntriesFast(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetEntriesFriend()
@trydoc raw"""
    GetEntriesFriend(this::ByConstRef1{TTree})::Int64
Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees.

""" GetEntriesFriend(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetEntry(Long64_t, Int_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TTree}, entry::Int64, getall::Int32)::Int32
Read all branches of entry and return total number of bytes read.
- `getall = 0` : get only active branches
- `getall = 1` : get all branches

The function returns the number of bytes read from the input buffer. If entry does not exist the function returns 0. If an I/O error occurs, the function returns -1. If all branches are disabled and getall == 0, it also returns 0 even if the specified entry exists in the tree, since zero bytes were read.

If the Tree has friends, also read the friends entry.

To activate/deactivate one or more branches, use TBranch!SetBranchStatus For example, if you have a Tree with several hundred branches, and you are interested only by branches named "a" and "b", do 

    mytree.SetBranchStatus("*",0); //disable all branches
    mytree.SetBranchStatus("a",1);
    mytree.SetBranchStatus("b",1);

(C++ version of the code)

 when calling mytree.GetEntry(i); only branches "a" and "b" will be read.

**WARNING!!** If your Tree has been created in split mode with a parent branch "parent.", 

    mytree.SetBranchStatus("parent",1);

(C++ version of the code)

 will not activate the sub-branches of "parent". You should do: 

    mytree.SetBranchStatus("parent*",1);

(C++ version of the code)

 Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.

An alternative is to call directly 

    brancha.GetEntry(i)
    branchb.GetEntry(i);

(C++ version of the code)

 

## IMPORTANT NOTE

By default, GetEntry reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(true) (default is false).

Example:

Consider the example in $ROOTSYS/test/Event.h The top level branch in the tree T is declared with: 

    Event *event = 0;  //event must be null or point to a valid object
                       //it must be initialized
    T.SetBranchAddress("event",&event);

(C++ version of the code)

 When reading the Tree, one can choose one of these 3 options:

## OPTION 1

    for (Long64_t i=0;i<nentries;i++) {
       T.GetEntry(i);
       // the object event has been filled at this point
    }

(C++ version of the code)

 The default (recommended). At the first entry an object of the class Event will be created and pointed by event. At the following entries, event will be overwritten by the new data. All internal members that are TObject* are automatically deleted. It is important that these members be in a valid state when GetEntry is called. Pointers must be correctly initialized. However these internal members will not be deleted if the characters "->" are specified as the first characters in the comment field of the data member declaration.

If "->" is specified, the pointer member is read via pointer->Streamer(buf). In this case, it is assumed that the pointer is never null (case of pointer [TClonesArray](@ref) *fTracks in the Event example). If "->" is not specified, the pointer member is read via buf >> pointer. In this case the pointer may be null. Note that the option with "->" is faster to read or write and it also consumes less space in the file.

## OPTION 2

The option AutoDelete is set 

    TBranch *branch = T.GetBranch("event");
    branch->SetAddress(&event);
    branch->SetAutoDelete(true);
    for (Long64_t i=0;i<nentries;i++) {
       T.GetEntry(i);
       // the object event has been filled at this point
    }

(C++ version of the code)

 In this case, at each iteration, the object event is deleted by GetEntry and a new instance of Event is created and filled.

## OPTION 3

    Same as option 1, but you delete yourself the event.
        for (Long64_t i=0;i<nentries;i++) {
           delete event;
           event = 0;  // EXTREMELY IMPORTANT
           T.GetEntry(i);
           // the object event has been filled at this point
        }

(C++ version of the code)

 It is strongly recommended to use the default option 1. It has the additional advantage that functions like [TTree!Draw](@ref) (internally calling [TTree!GetEntry](@ref)) will be functional even when the classes in the file are not available.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the object ownership policy of the underlying (user) data.
""" GetEntry(this::ByRef1{TTree}, entry::Int64, getall::Int32)

# Wrapper of TEntryList * TTree::GetEntryList()
@trydoc raw"""
    GetEntryList(this::ByRef1{TTree})::CxxPtr1{TEntryList}
Returns the entry list assigned to this tree.

""" GetEntryList(this::ByRef1{TTree})

# Wrapper of Long64_t TTree::GetEntryNumber(Long64_t)
@trydoc raw"""
    GetEntryNumber(this::ByConstRef1{TTree}, entry::Int64)::Int64
Return entry number corresponding to entry.
if no [TEntryList](@ref) set returns entry else returns the entry number corresponding to the list index=entry
""" GetEntryNumber(this::ByConstRef1{TTree}, entry::Int64)

# Wrapper of Long64_t TTree::GetEntryNumberWithBestIndex(Long64_t, Long64_t)
@trydoc raw"""
    GetEntryNumberWithBestIndex(this::ByConstRef1{TTree}, major::Int64, minor::Int64)::Int64
Return entry number corresponding to major and minor number.
Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use [TTree!GetEntryWithIndex](@ref) the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table. If an entry corresponding to major and minor is not found, the function returns the index of the major,minor pair immediately lower than the requested value, ie it will return -1 if the pair is lower than the first entry in the index.

See also GetEntryNumberWithIndex
""" GetEntryNumberWithBestIndex(this::ByConstRef1{TTree}, major::Int64, minor::Int64)

# Wrapper of Long64_t TTree::GetEntryNumberWithIndex(Long64_t, Long64_t)
@trydoc raw"""
    GetEntryNumberWithIndex(this::ByConstRef1{TTree}, major::Int64, minor::Int64)::Int64
Return entry number corresponding to major and minor number.
Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use [TTree!GetEntryWithIndex](@ref) the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table, otherwise it returns -1.

See also GetEntryNumberWithBestIndex
""" GetEntryNumberWithIndex(this::ByConstRef1{TTree}, major::Int64, minor::Int64)

# Wrapper of Int_t TTree::GetEntryWithIndex(Int_t, Int_t)
@trydoc raw"""
    GetEntryWithIndex(this::ByRef1{TTree}, major::Int32, minor::Int32)::Int32
Read entry corresponding to major and minor number.
The function returns the total number of bytes read. If the Tree has friend trees, the corresponding entry with the index values (major,minor) is read. Note that the master Tree and its friend may have different entry serial numbers corresponding to (major,minor).
""" GetEntryWithIndex(this::ByRef1{TTree}, major::Int32, minor::Int32)

# Wrapper of Long64_t TTree::GetEstimate()
@trydoc raw"""
    GetEstimate(this::ByConstRef1{TTree})::Int64


""" GetEstimate(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetEvent(Long64_t, Int_t)
@trydoc raw"""
    GetEvent(this::ByRef1{TTree}, entry::Int64, getall::Int32)::Int32


""" GetEvent(this::ByRef1{TTree}, entry::Int64, getall::Int32)

# Wrapper of Int_t TTree::GetFileNumber()
@trydoc raw"""
    GetFileNumber(this::ByConstRef1{TTree})::Int32


""" GetFileNumber(this::ByConstRef1{TTree})

# Wrapper of TTree * TTree::GetFriend(const char *)
@trydoc raw"""
    GetFriend(this::ByConstRef1{TTree}, ::ByCopy{String})::CxxPtr1{TTree}
Return a pointer to the [TTree](@ref) friend whose name or alias is `friendname`.

""" GetFriend(this::ByConstRef1{TTree}, ::ByCopy{String})

# Wrapper of const char * TTree::GetFriendAlias(TTree *)
@trydoc raw"""
    GetFriendAlias(this::ByConstRef1{TTree}, ::ByPtr1{TTree})::ByCopy{String}
If the 'tree' is a friend, this method returns its alias name.
This alias is an alternate name for the tree.

It can be used in conjunction with a branch or leaf name in a [TTreeFormula](@ref), to specify in which particular tree the branch or leaf can be found if the friend trees have branches or leaves with the same name as the master tree.

It can also be used in conjunction with an alias created using [TTree!SetAlias](@ref) in a [TTreeFormula](@ref), e.g.: 

    maintree->Draw("treealias.fPx - treealias.myAlias");

(C++ version of the code)

 where fPx is a branch of the friend tree aliased as 'treealias' and 'myAlias' was created using [TTree!SetAlias](@ref) on the friend tree.

However, note that 'treealias.myAlias' will be expanded literally, without remembering that it comes from the aliased friend and thus the branch name might not be disambiguated properly, which means that you may not be able to take advantage of this feature.
""" GetFriendAlias(this::ByConstRef1{TTree}, ::ByPtr1{TTree})

# Wrapper of TH1 * TTree::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByRef1{TTree})::CxxPtr1{TH1}


""" GetHistogram(this::ByRef1{TTree})

# Wrapper of bool TTree::GetImplicitMT()
@trydoc raw"""
    GetImplicitMT(this::ByRef1{TTree})::Bool


""" GetImplicitMT(this::ByRef1{TTree})

# Wrapper of Int_t * TTree::GetIndex()
@trydoc raw"""
    GetIndex(this::ByRef1{TTree})::CxxPtr2{Int32}


""" GetIndex(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetIndexValues()
@trydoc raw"""
    GetIndexValues(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetIndexValues(this::ByRef1{TTree})

# Wrapper of TIterator * TTree::GetIteratorOnAllLeaves(bool)
@trydoc raw"""
    GetIteratorOnAllLeaves(this::ByRef1{TTree}, dir::Bool)::CxxPtr1{TIterator}
Creates a new iterator that will go through all the leaves on the tree itself and its friend.

""" GetIteratorOnAllLeaves(this::ByRef1{TTree}, dir::Bool)

# Wrapper of TLeaf * TTree::GetLeaf(const char *, const char *)
@trydoc raw"""
    GetLeaf(this::ByRef1{TTree}, branchname::ByCopy{String}, leafname::ByCopy{String})::CxxPtr1{TLeaf}
Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees.
The leaf name can contain the name of a friend tree with the syntax: friend_dir_and_tree.full_leaf_name the friend_dir_and_tree can be of the form: 
```
TDirectoryName/TreeName 
```
""" GetLeaf(this::ByRef1{TTree}, branchname::ByCopy{String}, leafname::ByCopy{String})

# Wrapper of TLeaf * TTree::GetLeaf(const char *)
@trydoc raw"""
    GetLeaf(this::ByRef1{TTree}, name::ByCopy{String})::CxxPtr1{TLeaf}
Return pointer to first leaf named "name" in any branch of this tree or its friend trees.
## Arguments

- **`name`** [in] 
    may be in the form 'branch/leaf'
""" GetLeaf(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of TList * TTree::GetListOfAliases()
@trydoc raw"""
    GetListOfAliases(this::ByConstRef1{TTree})::CxxPtr1{TList}


""" GetListOfAliases(this::ByConstRef1{TTree})

# Wrapper of TObjArray * TTree::GetListOfBranches()
@trydoc raw"""
    GetListOfBranches(this::ByRef1{TTree})::CxxPtr1{TObjArray}


""" GetListOfBranches(this::ByRef1{TTree})

# Wrapper of TList * TTree::GetListOfClones()
@trydoc raw"""
    GetListOfClones(this::ByRef1{TTree})::CxxPtr1{TList}


""" GetListOfClones(this::ByRef1{TTree})

# Wrapper of TList * TTree::GetListOfFriends()
@trydoc raw"""
    GetListOfFriends(this::ByConstRef1{TTree})::CxxPtr1{TList}


""" GetListOfFriends(this::ByConstRef1{TTree})

# Wrapper of TObjArray * TTree::GetListOfLeaves()
@trydoc raw"""
    GetListOfLeaves(this::ByRef1{TTree})::CxxPtr1{TObjArray}


""" GetListOfLeaves(this::ByRef1{TTree})

# Wrapper of Int_t TTree::GetMakeClass()
@trydoc raw"""
    GetMakeClass(this::ByConstRef1{TTree})::Int32


""" GetMakeClass(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetMaxEntryLoop()
@trydoc raw"""
    GetMaxEntryLoop(this::ByConstRef1{TTree})::Int64


""" GetMaxEntryLoop(this::ByConstRef1{TTree})

# Wrapper of Double_t TTree::GetMaximum(const char *)
@trydoc raw"""
    GetMaximum(this::ByRef1{TTree}, columname::ByCopy{String})::Float64
Return maximum of column with name columname.
if the Tree has an associated [TEventList](@ref) or [TEntryList](@ref), the maximum is computed for the entries in this list.
""" GetMaximum(this::ByRef1{TTree}, columname::ByCopy{String})

# Wrapper of Long64_t TTree::GetMaxVirtualSize()
@trydoc raw"""
    GetMaxVirtualSize(this::ByConstRef1{TTree})::Int64


""" GetMaxVirtualSize(this::ByConstRef1{TTree})

# Wrapper of Double_t TTree::GetMinimum(const char *)
@trydoc raw"""
    GetMinimum(this::ByRef1{TTree}, columname::ByCopy{String})::Float64
Return minimum of column with name columname.
if the Tree has an associated [TEventList](@ref) or [TEntryList](@ref), the minimum is computed for the entries in this list.
""" GetMinimum(this::ByRef1{TTree}, columname::ByCopy{String})

# Wrapper of Int_t TTree::GetNbranches()
@trydoc raw"""
    GetNbranches(this::ByRef1{TTree})::Int32


""" GetNbranches(this::ByRef1{TTree})

# Wrapper of TObject * TTree::GetNotify()
@trydoc raw"""
    GetNotify(this::ByConstRef1{TTree})::CxxPtr1{TObject}


""" GetNotify(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetPacketSize()
@trydoc raw"""
    GetPacketSize(this::ByConstRef1{TTree})::Int32


""" GetPacketSize(this::ByConstRef1{TTree})

# Wrapper of TVirtualTreePlayer * TTree::GetPlayer()
@trydoc raw"""
    GetPlayer(this::ByRef1{TTree})::CxxPtr1{TVirtualTreePlayer}
Load the [TTreePlayer](@ref) (if not already done).

""" GetPlayer(this::ByRef1{TTree})

# Wrapper of Long64_t TTree::GetReadEntry()
@trydoc raw"""
    GetReadEntry(this::ByConstRef1{TTree})::Int64


""" GetReadEntry(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetReadEvent()
@trydoc raw"""
    GetReadEvent(this::ByConstRef1{TTree})::Int64


""" GetReadEvent(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetScanField()
@trydoc raw"""
    GetScanField(this::ByConstRef1{TTree})::Int32


""" GetScanField(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetSelectedRows()
@trydoc raw"""
    GetSelectedRows(this::ByRef1{TTree})::Int64


""" GetSelectedRows(this::ByRef1{TTree})

# Wrapper of Float_t TTree::GetTargetMemoryRatio()
@trydoc raw"""
    GetTargetMemoryRatio(this::ByConstRef1{TTree})::Float32


""" GetTargetMemoryRatio(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetTimerInterval()
@trydoc raw"""
    GetTimerInterval(this::ByConstRef1{TTree})::Int32


""" GetTimerInterval(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetTotBytes()
@trydoc raw"""
    GetTotBytes(this::ByConstRef1{TTree})::Int64


""" GetTotBytes(this::ByConstRef1{TTree})

# Wrapper of TBuffer * TTree::GetTransientBuffer(Int_t)
@trydoc raw"""
    GetTransientBuffer(this::ByRef1{TTree}, size::Int32)::CxxPtr1{TBuffer}
Returns the transient buffer currently used by this [TTree](@ref) for reading/writing baskets.

""" GetTransientBuffer(this::ByRef1{TTree}, size::Int32)

# Wrapper of TTree * TTree::GetTree()
@trydoc raw"""
    GetTree(this::ByConstRef1{TTree})::CxxPtr1{TTree}


""" GetTree(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetTreeNumber()
@trydoc raw"""
    GetTreeNumber(this::ByConstRef1{TTree})::Int32


""" GetTreeNumber(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::GetUpdate()
@trydoc raw"""
    GetUpdate(this::ByConstRef1{TTree})::Int32


""" GetUpdate(this::ByConstRef1{TTree})

# Wrapper of TList * TTree::GetUserInfo()
@trydoc raw"""
    GetUserInfo(this::ByRef1{TTree})::CxxPtr1{TList}
Return a pointer to the list containing user objects associated to this tree.
The list is automatically created if it does not exist.

WARNING: By default the [TTree](@ref) destructor will delete all objects added to this list. If you do not want these objects to be deleted, call: 
```
mytree->GetUserInfo()->Clear();
```  before deleting the tree.
""" GetUserInfo(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV1()
@trydoc raw"""
    GetV1(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV1(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV2()
@trydoc raw"""
    GetV2(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV2(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV3()
@trydoc raw"""
    GetV3(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV3(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetV4()
@trydoc raw"""
    GetV4(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetV4(this::ByRef1{TTree})

# Wrapper of Double_t * TTree::GetVal(Int_t)
@trydoc raw"""
    GetVal(this::ByRef1{TTree}, i::Int32)::CxxPtr2{Float64}


""" GetVal(this::ByRef1{TTree}, i::Int32)

# Wrapper of Double_t * TTree::GetW()
@trydoc raw"""
    GetW(this::ByRef1{TTree})::CxxPtr2{Float64}


""" GetW(this::ByRef1{TTree})

# Wrapper of Double_t TTree::GetWeight()
@trydoc raw"""
    GetWeight(this::ByConstRef1{TTree})::Float64


""" GetWeight(this::ByConstRef1{TTree})

# Wrapper of Long64_t TTree::GetZipBytes()
@trydoc raw"""
    GetZipBytes(this::ByConstRef1{TTree})::Int64


""" GetZipBytes(this::ByConstRef1{TTree})

# Wrapper of void TTree::IncrementTotalBuffers(Int_t)
@trydoc raw"""
    IncrementTotalBuffers(this::ByRef1{TTree}, nbytes::Int32)::Nothing


""" IncrementTotalBuffers(this::ByRef1{TTree}, nbytes::Int32)

# Wrapper of bool TTree::InPlaceClone(TDirectory *, const char *)
@trydoc raw"""
    InPlaceClone(this::ByRef1{TTree}, newdirectory::ByPtr1{TDirectory}, options::ByCopy{String})::Bool
Copy the content to a new new file, update this [TTree](@ref) with the new location information and attach this [TTree](@ref) to the new directory.
options: Indicates a basket sorting method, see TTreeCloner!TTreeCloner for details

If new and old directory are in the same file, the data is untouched, this "just" does a call to SetDirectory. Equivalent to an "in place" cloning of the [TTree](@ref).
""" InPlaceClone(this::ByRef1{TTree}, newdirectory::ByPtr1{TDirectory}, options::ByCopy{String})

# Wrapper of bool TTree::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TTree})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TTree})

# Wrapper of Int_t TTree::LoadBaskets(Long64_t)
@trydoc raw"""
    LoadBaskets(this::ByRef1{TTree}, maxmemory::Int64)::Int32
Read in memory all baskets from all branches up to the limit of maxmemory bytes.
If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly [TBranch!LoadBaskets](@ref).
""" LoadBaskets(this::ByRef1{TTree}, maxmemory::Int64)

# Wrapper of Long64_t TTree::LoadTree(Long64_t)
@trydoc raw"""
    LoadTree(this::ByRef1{TTree}, entry::Int64)::Int64
Set current entry.
Returns -2 if entry does not exist (just as [TChain!LoadTree()](@ref)). Returns -6 if an error occurs in the notification callback (just as [TChain!LoadTree()](@ref)).

Calls fNotify->[Notify()](@ref) (if fNotify is not null) when starting the processing of a new tree.

###Note

This function is overloaded in TChain.
""" LoadTree(this::ByRef1{TTree}, entry::Int64)

# Wrapper of Long64_t TTree::LoadTreeFriend(Long64_t, TTree *)
@trydoc raw"""
    LoadTreeFriend(this::ByRef1{TTree}, entry::Int64, T::ByPtr1{TTree})::Int64
Load entry on behalf of our master tree, we may use an index.
Called by [LoadTree()](@ref) when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.

If we have no index, our entry number and the masterTree entry number are the same.

If we *do* have an index, we must find the (major, minor) value pair in masterTree to locate our corresponding entry.
""" LoadTreeFriend(this::ByRef1{TTree}, entry::Int64, T::ByPtr1{TTree})

# Wrapper of Int_t TTree::MakeClass(const char *, Option_t *)
@trydoc raw"""
    MakeClass(this::ByRef1{TTree}, classname::ByCopy{String}, option::ByCopy{String})::Int32
Generate a skeleton analysis class for this tree.
The following files are produced: classname.h and classname.C. If classname is 0, classname will be called "nameoftree".

The generated code in classname.h includes the following:

- Identification of the original tree and the input file name.
- Definition of an analysis class (data members and member functions).
- The following member functions:

    - constructor (by default opening the tree file),
    - GetEntry(Long64_t entry),
    - Init(TTree* tree) to initialize a new [TTree](@ref),
    - Show(Long64_t entry) to read and dump entry.

The generated code in classname.C includes only the main analysis function Loop.

To use this function:

- Open your tree file (eg: [TFile](@ref) f("myfile.root");)
- T->MakeClass("MyClass");

where T is the name of the [TTree](@ref) in file myfile.root, and MyClass.h, MyClass.C the name of the files created by this function. In a [ROOT](@ref) session, you can do: 

    root > .L MyClass.C
    root > MyClass* t = new MyClass;
    root > t->GetEntry(12); // Fill data members of t with entry number 12.
    root > t->Show();       // Show values of entry 12.
    root > t->Show(16);     // Read and show values of entry 16.
    root > t->Loop();       // Loop on all entries.

(C++ version of the code)

 NOTE: Do not use the code generated for a single [TTree](@ref) which is part of a [TChain](@ref) to process that entire [TChain](@ref). The maximum dimensions calculated for arrays on the basis of a single [TTree](@ref) from the [TChain](@ref) might be (will be!) too small when processing all of the TTrees in the [TChain](@ref). You must use myChain.MakeClass() to generate the code, not myTree.MakeClass(...).
""" MakeClass(this::ByRef1{TTree}, classname::ByCopy{String}, option::ByCopy{String})

# Wrapper of Int_t TTree::MakeCode(const char *)
@trydoc raw"""
    MakeCode(this::ByRef1{TTree}, filename::ByCopy{String})::Int32
Generate a skeleton function for this tree.
The function code is written on filename. If filename is 0, filename will be called nameoftree.C

The generated code includes the following:

- Identification of the original Tree and Input file name,
- Opening the Tree file,
- Declaration of Tree variables,
- Setting of branches addresses,
- A skeleton for the entry loop.

To use this function:

- Open your Tree file (eg: [TFile](@ref) f("myfile.root");)
- T->MakeCode("MyAnalysis.C");

where T is the name of the [TTree](@ref) in file myfile.root and MyAnalysis.C the name of the file created by this function.

NOTE: Since the implementation of this function, a new and better function [TTree!MakeClass()](@ref) has been developed.
""" MakeCode(this::ByRef1{TTree}, filename::ByCopy{String})

# Wrapper of Int_t TTree::MakeProxy(const char *, const char *, const char *, const char *, Int_t)
@trydoc raw"""
    MakeProxy(this::ByRef1{TTree}, classname::ByCopy{String}, macrofilename::ByCopy{String}, cutfilename::ByCopy{String}, option::ByCopy{String}, maxUnrolling::Int32)::Int32
Generate a skeleton analysis class for this Tree using TBranchProxy.
TBranchProxy is the base of a class hierarchy implementing an indirect access to the content of the branches of a [TTree](@ref).

"proxyClassname" is expected to be of the form: 

    [path/]fileprefix

(C++ version of the code)

 The skeleton will then be generated in the file: 

    fileprefix.h

(C++ version of the code)

 located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'

"macrofilename" and optionally "cutfilename" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: 

    [if (cutfilename())] htemp->Fill(macrofilename());

(C++ version of the code)

 "option" can be used select some of the optional features during the code generation. The possible options are:

- nohist : indicates that the generated ProcessFill should not fill the histogram.

'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of [TTreeFormula](@ref)).

The main features of this skeleton are:

- on-demand loading of branches
- ability to use the 'branchname' as if it was a data member
- protection against array out-of-bounds errors
- ability to use the branch data as an object (when the user code is available)

For example with Event.root, if 

    Double_t somePx = fTracks.fPx[2];

(C++ version of the code)

 is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.

Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: 

    x_t macrofilename(); // i.e function with the same name as the file

(C++ version of the code)

 and 

    y_t cutfilename();   // i.e function with the same name as the file

(C++ version of the code)

 x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: 
```
if (cutfilename()) htemp->Fill(macrofilename());
```  These two functions are run in a context such that the branch names are available as local_ variables of the correct (read-only) type.

Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: 

    Int_t n = fEventNumber; // Read fEventNumber
    if (n<10 || n>10) { ... }

(C++ version of the code)

 is more efficient than 

    if (fEventNumber<10 || fEventNumber>10)

(C++ version of the code)

 Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).

Concretely, with the script named h1analysisProxy.C,

- The method calls the method (if it exist)
- Begin -> void h1analysisProxy_Begin(TTree*);
- SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);
- Notify -> bool h1analysisProxy_Notify();
- Process -> bool h1analysisProxy_Process(Long64_t);
- SlaveTerminate -> void h1analysisProxy_SlaveTerminate();
- Terminate -> void h1analysisProxy_Terminate();

If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.

The default histogram is accessible via the variable named 'htemp'.

If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed `include` statements and give the ability to access the object stored in the branches.

To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: 

    double hsimple() {
       return px;
    }

(C++ version of the code)

 MakeProxy can then be used indirectly via the [TTree!Draw](@ref) interface as follow: 

    new TFile("hsimple.root")
    ntuple->Draw("hsimple.cxx");

(C++ version of the code)

 A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C
""" MakeProxy(this::ByRef1{TTree}, classname::ByCopy{String}, macrofilename::ByCopy{String}, cutfilename::ByCopy{String}, option::ByCopy{String}, maxUnrolling::Int32)

# Wrapper of Int_t TTree::MakeSelector(const char *, Option_t *)
@trydoc raw"""
    MakeSelector(this::ByRef1{TTree}, selector::ByCopy{String}, option::ByCopy{String})::Int32
Generate skeleton selector class for this tree.
The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called "nameoftree". The option can be used to specify the branches that will have a data member.

- If option is "=legacy", a pre-ROOT6 selector will be generated (data members and branch pointers instead of TTreeReaders).
- If option is empty, readers will be generated for each leaf.
- If option is "@", readers will be generated for the topmost branches.
- Individual branches can also be picked by their name:

    - "X" generates readers for leaves of X.
    - "@X" generates a reader for X as a whole.
    - "@X;Y" generates a reader for X as a whole and also readers for the leaves of Y.
- For further examples see the figure below.

![https://root.cern/doc/v636/ttree_makeselector_option_examples.png](https://root.cern/doc/v636/ttree_makeselector_option_examples.png)

The generated code in selector.h includes the following:

- Identification of the original Tree and Input file name
- Definition of selector class (data and functions)
- The following class functions:

    - constructor and destructor
    - void Begin(TTree *tree)
    - void SlaveBegin(TTree *tree)
    - void Init(TTree *tree)
    - bool [Notify()](@ref)
    - bool Process(Long64_t entry)
    - void Terminate()
    - void SlaveTerminate()

The class selector derives from [TSelector](@ref). The generated code in selector.C includes empty functions defined above.

To use this function:

- connect your Tree file (eg: `TFile f("myfile.root");`)
- `T->MakeSelector("myselect");`

where T is the name of the Tree in file myfile.root and myselect.h, myselect.C the name of the files created by this function. In a [ROOT](@ref) session, you can do: 

    root > T->Process("myselect.C")

(C++ version of the code)
""" MakeSelector(this::ByRef1{TTree}, selector::ByCopy{String}, option::ByCopy{String})

# Wrapper of bool TTree::MemoryFull(Int_t)
@trydoc raw"""
    MemoryFull(this::ByRef1{TTree}, nbytes::Int32)::Bool
Check if adding nbytes to memory we are still below MaxVirtualsize.

""" MemoryFull(this::ByRef1{TTree}, nbytes::Int32)

# Wrapper of Long64_t TTree::Merge(TCollection *, Option_t *)
@trydoc raw"""
    Merge(this::ByRef1{TTree}, list::ByPtr1{TCollection}, option::ByCopy{String})::Int64
Merge the trees in the [TList](@ref) into this tree.
Returns the total number of entries in the merged tree. Trees with no branches will be skipped, the branch structure will be taken from the first non-zero-branch Tree of {this+li}
""" Merge(this::ByRef1{TTree}, list::ByPtr1{TCollection}, option::ByCopy{String})

# Wrapper of bool TTree::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TTree})::Bool
Function called when loading a new class library.

""" Notify(this::ByRef1{TTree})

# Wrapper of void TTree::OptimizeBaskets(ULong64_t, Float_t, Option_t *)
@trydoc raw"""
    OptimizeBaskets(this::ByRef1{TTree}, maxMemory::UInt64, minComp::Float32, option::ByCopy{String})::Nothing
This function may be called after having filled some entries in a Tree.
Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.

The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.

if option ="d" an analysis report is printed.
""" OptimizeBaskets(this::ByRef1{TTree}, maxMemory::UInt64, minComp::Float32, option::ByCopy{String})

# Wrapper of TPrincipal * TTree::Principal(const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Principal(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::CxxPtr1{TPrincipal}
Interface to the Principal Components Analysis class.
Create an instance of [TPrincipal](@ref)

Fill it with the selected variables

- if option "n" is specified, the [TPrincipal](@ref) object is filled with normalized variables.
- If option "p" is specified, compute the principal components
- If option "p" and "d" print results of analysis
- If option "p" and "h" generate standard histograms
- If option "p" and "c" generate code of conversion functions
- return a pointer to the [TPrincipal](@ref) object. It is the user responsibility
- to delete this object.
- The option default value is "np"

see [TTree!Draw](@ref) for explanation of the other parameters.

The created object is named "principal" and a reference to it is added to the list of specials Root objects. you can retrieve a pointer to the created object via: 

    TPrincipal *principal =
    (TPrincipal*)gROOT->GetListOfSpecials()->FindObject("principal");

(C++ version of the code)
""" Principal(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of void TTree::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TTree}, option::ByCopy{String})::Nothing
Print a summary of the tree contents.
- If option contains "all" friend trees are also printed.
- If option contains "toponly" only the top level branches are printed.
- If option contains "clusters" information about the cluster of baskets is printed.

Wildcarding can be used to print only a subset of the branches, e.g., `T.Print("Elec*")` will print all branches with name starting with "Elec".
""" Print(this::ByConstRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::PrintCacheStats(Option_t *)
@trydoc raw"""
    PrintCacheStats(this::ByConstRef1{TTree}, option::ByCopy{String})::Nothing
Print statistics about the TreeCache for this tree.
Like: 

    ******TreeCache statistics for file: cms2.root ******
    Reading 73921562 bytes in 716 transactions
    Average transaction = 103.242405 Kbytes
    Number of blocks in current cache: 202, total size : 6001193

(C++ version of the code)

 if option = "a" the list of blocks in the cache is printed
""" PrintCacheStats(this::ByConstRef1{TTree}, option::ByCopy{String})

# Wrapper of Long64_t TTree::Process(const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Process(this::ByRef1{TTree}, filename::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Process this tree executing the [TSelector](@ref) code in the specified filename.
The return value is -1 in case of error and [TSelector!GetStatus()](@ref) in in case of success.

The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from [TSelector](@ref), where [TSelector](@ref) has the following member functions:

- `Begin()`: called every time a loop on the tree starts, a convenient place to create your histograms.
- `SlaveBegin()`: called after [Begin()](@ref), when on PROOF called only on the slave servers.
- `Process()`: called for each event, in this function you decide what to read and fill your histograms.
- `SlaveTerminate`: called at the theend of the loop on the tree, when on PROOF called only on the slave servers.
- `Terminate()`: called at the theend of the loop on the tree, a convenient place to draw/fit your histograms.

If filename is of the form file.C, the file will be interpreted.

If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.

If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.

## NOTE1

It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg 

    MySelector *selector = (MySelector*)TSelector!GetSelector(filename);
    selector->CallSomeFunction(..);
    mytree.Process(selector,..);

(C++ version of the code)

 

## NOTE2

One should not call this function twice with the same selector file in the same script. If this is required, proceed as indicated in NOTE1, by getting a pointer to the corresponding [TSelector](@ref),eg

### Workaround 1

    void stubs1() {
       TSelector *selector = TSelector!GetSelector("h1test.C");
       TFile *f1 = new TFile("stubs_nood_le1.root");
       TTree *h1 = (TTree*)f1->Get("h1");
       h1->Process(selector);
       TFile *f2 = new TFile("stubs_nood_le1_coarse.root");
       TTree *h2 = (TTree*)f2->Get("h1");
       h2->Process(selector);
    }

(C++ version of the code)

 or use ACLIC to compile the selector

### Workaround 2

    void stubs2() {
       TFile *f1 = new TFile("stubs_nood_le1.root");
       TTree *h1 = (TTree*)f1->Get("h1");
       h1->Process("h1test.C+");
       TFile *f2 = new TFile("stubs_nood_le1_coarse.root");
       TTree *h2 = (TTree*)f2->Get("h1");
       h2->Process("h1test.C+");
    }

(C++ version of the code)
""" Process(this::ByRef1{TTree}, filename::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Long64_t TTree::Project(const char *, const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Project(this::ByRef1{TTree}, hname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Make a projection of a tree using selections.
Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc., projection of the tree will be filled in histogram hname. Note that the dimension of hname must match with the dimension of varexp.
""" Project(this::ByRef1{TTree}, hname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of Long64_t TTree::ReadFile(const char *, const char *, char)
@trydoc raw"""
    ReadFile(this::ByRef1{TTree}, filename::ByCopy{String}, branchDescriptor::ByCopy{String}, delimiter::Int8)::Int64
Create or simply read branches from filename.
if branchDescriptor = "" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like 

    A/D:Table[2]/F:Ntracks/I:astring/C

(C++ version of the code)

 otherwise branchDescriptor must be specified with the above syntax.

- If the type of the first variable is not specified, it is assumed to be "/F"
- If the type of any other variable is not specified, the type of the previous variable is assumed. eg

    - `x:y:z` (all variables are assumed of type "F")
    - `x/D:y:z` (all variables are of type "D")
    - `x:y/D:z` (x is type "F", y and z of type "D")

delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == "", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type "F". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.

Lines in the input file starting with "#" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.

A [TBranch](@ref) object is created for each variable in the expression. The total number of rows read from the file is returned.

## FILLING a TTree WITH MULTIPLE INPUT TEXT FILES

To fill a [TTree](@ref) with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls 

    T.ReadFile("file1.dat","branch descriptor");
    T.ReadFile("file2.dat");

(C++ version of the code)
""" ReadFile(this::ByRef1{TTree}, filename::ByCopy{String}, branchDescriptor::ByCopy{String}, delimiter::Int8)

# Wrapper of void TTree::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TTree}, obj::ByPtr1{TObject})::Nothing
Make sure that obj (which is being deleted or will soon be) is no longer referenced by this [TTree](@ref).

""" RecursiveRemove(this::ByRef1{TTree}, obj::ByPtr1{TObject})

# Wrapper of void TTree::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TTree})::Nothing
Refresh contents of this tree and its branches from the current status on disk.
One can call this function in case the tree file is being updated by another process.
""" Refresh(this::ByRef1{TTree})

# Wrapper of void TTree::RemoveFriend(TTree *)
@trydoc raw"""
    RemoveFriend(this::ByRef1{TTree}, ::ByPtr1{TTree})::Nothing
Remove a friend from the list of friends.

""" RemoveFriend(this::ByRef1{TTree}, ::ByPtr1{TTree})

# Wrapper of void TTree::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TTree}, option::ByCopy{String})::Nothing
Reset baskets, buffers and entries count in all branches and leaves.

""" Reset(this::ByRef1{TTree}, option::ByCopy{String})

# Wrapper of void TTree::ResetBranchAddress(TBranch *)
@trydoc raw"""
    ResetBranchAddress(this::ByRef1{TTree}, ::ByPtr1{TBranch})::Nothing
Tell a branch to set its address to zero.
###Note

If the branch owns any objects, they are deleted.
""" ResetBranchAddress(this::ByRef1{TTree}, ::ByPtr1{TBranch})

# Wrapper of void TTree::ResetBranchAddresses()
@trydoc raw"""
    ResetBranchAddresses(this::ByRef1{TTree})::Nothing
Tell all of our branches to drop their current objects and allocate new ones.

""" ResetBranchAddresses(this::ByRef1{TTree})

# Wrapper of Long64_t TTree::Scan(const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    Scan(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int64
Loop over tree entries and print entries passing selection.
Interactive pagination break is on by default.

- If varexp is 0 (or "") then print only first 8 columns.
- If varexp = "*" print all columns.

Otherwise a columns selection can be made using "var1:var2:var3".

## Arguments

- **`firstentry`** 
    first entry to scan 
    
- **`nentries`** 
    total number of entries to scan (starting from firstentry). Defaults to all entries. 
    

###Note

see TTree!SetScanField to control how many lines are printed between pagination breaks (Use 0 to disable pagination) 

###See

TTreePlayer!Scan
""" Scan(this::ByRef1{TTree}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of bool TTree::SetAlias(const char *, const char *)
@trydoc raw"""
    SetAlias(this::ByRef1{TTree}, aliasName::ByCopy{String}, aliasFormula::ByCopy{String})::Bool
Set a tree variable alias.
Set an alias for an expression/formula based on the tree 'variables'.

The content of 'aliasName' can be used in [TTreeFormula](@ref) (i.e. [TTree!Draw](@ref), [TTree!Scan](@ref), [TTreeViewer](@ref)) and will be evaluated as the content of 'aliasFormula'.

If the content of 'aliasFormula' only contains symbol names, periods and array index specification (for example event.fTracks[3]), then the content of 'aliasName' can be used as the thestart of symbol.

If the alias 'aliasName' already existed, it is replaced by the new value.

When being used, the alias can be preceded by an eventual 'Friend Alias' (see [TTree!GetFriendAlias](@ref))

Return true if it was added properly.

For example: 

    tree->SetAlias("x1","(tdc1[1]-tdc1[0])/49");
    tree->SetAlias("y1","(tdc1[3]-tdc1[2])/47");
    tree->SetAlias("x2","(tdc2[1]-tdc2[0])/49");
    tree->SetAlias("y2","(tdc2[3]-tdc2[2])/47");
    tree->Draw("y2-y1:x2-x1");
    tree->SetAlias("theGoodTrack","event.fTracks[3]");
    tree->Draw("theGoodTrack.fPx"); // same as "event.fTracks[3].fPx"

(C++ version of the code)
""" SetAlias(this::ByRef1{TTree}, aliasName::ByCopy{String}, aliasFormula::ByCopy{String})

# Wrapper of void TTree::SetAutoFlush(Long64_t)
@trydoc raw"""
    SetAutoFlush(this::ByRef1{TTree}, autof::Int64)::Nothing
This function may be called at the thestart of a program to change the default value for fAutoFlush.
### CASE 1 : autof > 0

autof is the number of consecutive entries after which [TTree!Fill](@ref) will flush all branch buffers to disk.

### CASE 2 : autof < 0

When filling the Tree the branch buffers will be flushed to disk when more than autof bytes have been written to the file. At the first FlushBaskets [TTree!Fill](@ref) will replace fAutoFlush by the current value of fEntries.

Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.

The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file.

### CASE 3 : autof = 0

The AutoFlush mechanism is disabled.

Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.

A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the [TTreeCache](@ref) will read.
""" SetAutoFlush(this::ByRef1{TTree}, autof::Int64)

# Wrapper of void TTree::SetAutoSave(Long64_t)
@trydoc raw"""
    SetAutoSave(this::ByRef1{TTree}, autos::Int64)::Nothing
In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point.
This function may be called before filling a [TTree](@ref) to specify when the branch buffers and [TTree](@ref) header are flushed to disk as part of [TTree!Fill()](@ref). The default is -300000000, ie the [TTree](@ref) will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be written to the file. CASE 3: If fAutoSave is 0, [AutoSave()](@ref) will never be called automatically as part of [TTree!Fill()](@ref).
""" SetAutoSave(this::ByRef1{TTree}, autos::Int64)

# Wrapper of void TTree::SetBasketSize(const char *, Int_t)
@trydoc raw"""
    SetBasketSize(this::ByRef1{TTree}, bname::ByCopy{String}, buffsize::Int32)::Nothing
Set a branch's basket size.
bname is the name of a branch.

- if bname="*", apply to all branches.
- if bname="xxx*", apply to all branches with name starting with xxx

see [TRegexp](@ref) for wildcarding options buffsize = branc basket size
""" SetBasketSize(this::ByRef1{TTree}, bname::ByCopy{String}, buffsize::Int32)

# Wrapper of Int_t TTree::SetBranchAddress(const char *, void *, TBranch **, TClass *, EDataType, bool)
@trydoc raw"""
    SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)::Int32
Verify the validity of the type of addr before calling SetBranchAddress.
See [TTree!CheckBranchAddressType](@ref) for the semantic of the return value.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the meaning of the addr parameter and the object ownership policy.
""" SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)

# Wrapper of Int_t TTree::SetBranchAddress(const char *, void *, TBranch **)
@trydoc raw"""
    SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch})::Int32
Change branch address, dealing with clone trees properly.
See [TTree!CheckBranchAddressType](@ref) for the semantic of the return value.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the meaning of the addr parameter and the object ownership policy.
""" SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, ptr::ByPtr1{TBranch})

# Wrapper of Int_t TTree::SetBranchAddress(const char *, void *, TClass *, EDataType, bool)
@trydoc raw"""
    SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)::Int32
Verify the validity of the type of addr before calling SetBranchAddress.
See [TTree!CheckBranchAddressType](@ref) for the semantic of the return value.

Note: See the comments in [TBranchElement!SetAddress()](@ref) for the meaning of the addr parameter and the object ownership policy.
""" SetBranchAddress(this::ByRef1{TTree}, bname::ByCopy{String}, add::ByPtr2{Nothing}, realClass::ByPtr1{TClass}, datatype::ByCopy{EDataType}, isptr::Bool)

# Wrapper of void TTree::SetBranchStatus(const char *, bool, UInt_t *)
@trydoc raw"""
    SetBranchStatus(this::ByRef1{TTree}, bname::ByCopy{String}, status::Bool, found::ByPtr2{UInt32})::Nothing
Set branch status to Process or DoNotProcess.
When reading a Tree, by default, all branches are read. One can speed up considerably the analysis phase by activating only the branches that hold variables involved in a query.

bname is the name of a branch.

- if bname="*", apply to all branches.
- if bname="xxx*", apply to all branches with name starting with xxx

see [TRegexp](@ref) for wildcarding options

- status = 1 branch will be processed
- = 0 branch will not be processed

Example:

Assume a tree T with sub-branches a,b,c,d,e,f,g,etc.. when doing T.GetEntry(i) all branches are read for entry i. to read only the branches c and e, one can do 

    T.SetBranchStatus("*",0); //disable all branches
    T.SetBranchStatus("c",1);
    T.setBranchStatus("e",1);
    T.GetEntry(i);

(C++ version of the code)

 bname is interpreted as a wild-carded [TRegexp](@ref) (see TRegexp!MakeWildcard). Thus, "a*b" or "a.*b" matches branches starting with "a" and ending with "b", but not any other branch with an "a" followed at some point by a "b". For this second behavior, use "*a*b*". Note that TRegExp does not support '|', and so you cannot select, e.g. track and shower branches with "track|shower".

**WARNING! WARNING! WARNING!**

SetBranchStatus is matching the branch based on match of the branch 'name' and not on the branch hierarchy! In order to be able to selectively enable a top level object that is 'split' you need to make sure the name of the top level branch is prefixed to the sub-branches' name (by adding a dot ('.') at the theend of the Branch creation and use the corresponding bname.

I.e If your Tree has been created in split mode with a parent branch "parent." (note the trailing dot). 

    T.SetBranchStatus("parent",1);

(C++ version of the code)

 will not activate the sub-branches of "parent". You should do: 

    T.SetBranchStatus("parent*",1);

(C++ version of the code)

 Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.

An alternative to this function is to read directly and only the interesting branches. Example: 

    TBranch *brc = T.GetBranch("c");
    TBranch *bre = T.GetBranch("e");
    brc->GetEntry(i);
    bre->GetEntry(i);

(C++ version of the code)

 If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed.
""" SetBranchStatus(this::ByRef1{TTree}, bname::ByCopy{String}, status::Bool, found::ByPtr2{UInt32})

# Wrapper of Int_t TTree::SetCacheEntryRange(Long64_t, Long64_t)
@trydoc raw"""
    SetCacheEntryRange(this::ByRef1{TTree}, first::Int64, last::Int64)::Int32
interface to [TTreeCache](@ref) to set the cache entry range
Returns:

- 0 entry range set
- -1 on error
""" SetCacheEntryRange(this::ByRef1{TTree}, first::Int64, last::Int64)

# Wrapper of void TTree::SetCacheLearnEntries(Int_t)
@trydoc raw"""
    SetCacheLearnEntries(this::ByRef1{TTree}, n::Int32)::Nothing
Interface to [TTreeCache](@ref) to set the number of entries for the learning phase.

""" SetCacheLearnEntries(this::ByRef1{TTree}, n::Int32)

# Wrapper of Int_t TTree::SetCacheSize(Long64_t)
@trydoc raw"""
    SetCacheSize(this::ByRef1{TTree}, cachesize::Int64)::Int32
Set maximum size of the file cache .
- if cachesize = 0 the existing cache (if any) is deleted.
- if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes).

The cacheSize might be clamped, see [TFileCacheRead!SetBufferSize](@ref)

Returns:

- 0 size set, cache was created if possible
- -1 on error
""" SetCacheSize(this::ByRef1{TTree}, cachesize::Int64)

# Wrapper of void TTree::SetChainOffset(Long64_t)
@trydoc raw"""
    SetChainOffset(this::ByRef1{TTree}, offset::Int64)::Nothing


""" SetChainOffset(this::ByRef1{TTree}, offset::Int64)

# Wrapper of void TTree::SetCircular(Long64_t)
@trydoc raw"""
    SetCircular(this::ByRef1{TTree}, maxEntries::Int64)::Nothing
Enable/Disable circularity for this tree.
if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.

#### NOTE 1:

Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. #### NOTE 2:

Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. #### NOTE 3:

SetCircular with maxEntries <= 0 is automatically called by [TChain!Merge](@ref) #### NOTE 4:

A circular Tree can still be saved in a file. When read back, it is still a circular Tree and can be filled again.
""" SetCircular(this::ByRef1{TTree}, maxEntries::Int64)

# Wrapper of void TTree::SetClusterPrefetch(bool)
@trydoc raw"""
    SetClusterPrefetch(this::ByRef1{TTree}, enabled::Bool)::Nothing


""" SetClusterPrefetch(this::ByRef1{TTree}, enabled::Bool)

# Wrapper of void TTree::SetDebug(Int_t, Long64_t, Long64_t)
@trydoc raw"""
    SetDebug(this::ByRef1{TTree}, level::Int32, min::Int64, max::Int64)::Nothing
Set the debug level and the debug range.
For entries in the debug range, the functions [TBranchElement!Fill](@ref) and [TBranchElement!GetEntry](@ref) will print the number of bytes filled or read for each branch.
""" SetDebug(this::ByRef1{TTree}, level::Int32, min::Int64, max::Int64)

# Wrapper of void TTree::SetDefaultEntryOffsetLen(Int_t, bool)
@trydoc raw"""
    SetDefaultEntryOffsetLen(this::ByRef1{TTree}, newdefault::Int32, updateExisting::Bool)::Nothing
Update the default value for the branch's fEntryOffsetLen.
If updateExisting is true, also update all the existing branches. If newdefault is less than 10, the new default value will be 10.
""" SetDefaultEntryOffsetLen(this::ByRef1{TTree}, newdefault::Int32, updateExisting::Bool)

# Wrapper of void TTree::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TTree}, dir::ByPtr1{TDirectory})::Nothing
Change the tree's directory.
Remove reference to this tree from current directory and add reference to new directory dir. The dir parameter can be 0 in which case the tree does not belong to any directory.
""" SetDirectory(this::ByRef1{TTree}, dir::ByPtr1{TDirectory})

# Wrapper of Long64_t TTree::SetEntries(Long64_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TTree}, n::Int64)::Int64
Change number of entries in the tree.
If n >= 0, set number of entries in the tree = n.

If n < 0, set number of entries in the tree to match the number of entries in each branch. (default for n is -1)

This function should be called only when one fills each branch independently via [TBranch!Fill](@ref) without calling [TTree!Fill](@ref). Calling [TTree!SetEntries()](@ref) make sense only if the number of entries in each branch is identical, a warning is issued otherwise. The function returns the number of entries.
""" SetEntries(this::ByRef1{TTree}, n::Int64)

# Wrapper of void TTree::SetEntryList(TEntryList *, Option_t *)
@trydoc raw"""
    SetEntryList(this::ByRef1{TTree}, list::ByPtr1{TEntryList}, opt::ByCopy{String})::Nothing
Set an EntryList.

""" SetEntryList(this::ByRef1{TTree}, list::ByPtr1{TEntryList}, opt::ByCopy{String})

# Wrapper of void TTree::SetEstimate(Long64_t)
@trydoc raw"""
    SetEstimate(this::ByRef1{TTree}, nentries::Int64)::Nothing
Set number of entries to estimate variable limits.
If n is -1, the estimate is set to be the current maximum for the tree (i.e. [GetEntries()](@ref) + 1) If n is less than -1, the behavior is undefined.
""" SetEstimate(this::ByRef1{TTree}, nentries::Int64)

# Wrapper of void TTree::SetFileNumber(Int_t)
@trydoc raw"""
    SetFileNumber(this::ByRef1{TTree}, number::Int32)::Nothing
Set fFileNumber to number.
fFileNumber is used by [TTree!Fill](@ref) to set the file name for a new file to be created when the current file exceeds fgTreeMaxSize. (see [TTree!ChangeFile](@ref)) if fFileNumber=10, the new file name will have a suffix "_11", ie, fFileNumber is incremented before setting the file name
""" SetFileNumber(this::ByRef1{TTree}, number::Int32)

# Wrapper of void TTree::SetImplicitMT(bool)
@trydoc raw"""
    SetImplicitMT(this::ByRef1{TTree}, enabled::Bool)::Nothing


""" SetImplicitMT(this::ByRef1{TTree}, enabled::Bool)

# Wrapper of void TTree::SetMakeClass(Int_t)
@trydoc raw"""
    SetMakeClass(this::ByRef1{TTree}, make::Int32)::Nothing
Set all the branches in this [TTree](@ref) to be in decomposed object mode (also known as MakeClass mode).
For MakeClass mode 0, the [TTree](@ref) expects the address where the data is stored to be set by either the user or the [TTree](@ref) to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). In other words, SetMakeClass sets the branch(es) into a mode that allow its reading via a set of independant variables (see the result of running [TTree!MakeClass](@ref) on your [TTree](@ref)) by changing the interpretation of the address passed to SetAddress from being the beginning of the object containing the data to being the exact location where the data should be loaded. If you have the shared library corresponding to your object, it is better if you do `MyClass *objp = 0; tree->SetBranchAddress("toplevel",&objp);`, whereas if you do not have the shared library but know your branch data type, e.g. `Int_t* ptr = new Int_t[10];`, then: `tree->SetMakeClass(1); tree->GetBranch("x")->SetAddress(ptr)` is the way to go.
""" SetMakeClass(this::ByRef1{TTree}, make::Int32)

# Wrapper of void TTree::SetMaxEntryLoop(Long64_t)
@trydoc raw"""
    SetMaxEntryLoop(this::ByRef1{TTree}, maxev::Int64)::Nothing


""" SetMaxEntryLoop(this::ByRef1{TTree}, maxev::Int64)

# Wrapper of void TTree::SetMaxVirtualSize(Long64_t)
@trydoc raw"""
    SetMaxVirtualSize(this::ByRef1{TTree}, size::Int64)::Nothing


""" SetMaxVirtualSize(this::ByRef1{TTree}, size::Int64)

# Wrapper of void TTree::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TTree}, name::ByCopy{String})::Nothing
Change the name of this tree.

""" SetName(this::ByRef1{TTree}, name::ByCopy{String})

# Wrapper of void TTree::SetNotify(TObject *)
@trydoc raw"""
    SetNotify(this::ByRef1{TTree}, obj::ByPtr1{TObject})::Nothing
Sets the address of the object to be notified when the tree is loaded.
The method [TObject!Notify](@ref) is called for the given object when the tree is loaded. Specifically this occurs in the [TTree!LoadTree](@ref) method. To remove the notification call this method with nullptr: 

    tree->SetNotify(nullptr); 

(C++ version of the code)

If this is a [TChain](@ref), `obj` is most often going to be a [TNotifyLink](@ref).

## Arguments

- **`obj`** [in] 
    Pointer to a [TObject](@ref) to be notified.
""" SetNotify(this::ByRef1{TTree}, obj::ByPtr1{TObject})

# Wrapper of void TTree::SetObject(const char *, const char *)
@trydoc raw"""
    SetObject(this::ByRef1{TTree}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Change the name and title of this tree.

""" SetObject(this::ByRef1{TTree}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TTree::SetParallelUnzip(bool, Float_t)
@trydoc raw"""
    SetParallelUnzip(this::ByRef1{TTree}, opt::Bool, RelSize::Float32)::Nothing
Enable or disable parallel unzipping of Tree buffers.

""" SetParallelUnzip(this::ByRef1{TTree}, opt::Bool, RelSize::Float32)

# Wrapper of void TTree::SetScanField(Int_t)
@trydoc raw"""
    SetScanField(this::ByRef1{TTree}, n::Int32)::Nothing
Sets the default maximum number of lines to be shown before `<CR>` when calling [Scan()](@ref).
## Arguments

- **`n`** 
    the maximum number of lines. Default=50, if 0, all entries of the Tree are shown and there is no need to press `<CR>` or `q` to exit the function. 
    

###See

TTreePlayer!Scan for more details on how to redirect the output to an ASCII file
""" SetScanField(this::ByRef1{TTree}, n::Int32)

# Wrapper of void TTree::SetTargetMemoryRatio(Float_t)
@trydoc raw"""
    SetTargetMemoryRatio(this::ByRef1{TTree}, ratio::Float32)::Nothing


""" SetTargetMemoryRatio(this::ByRef1{TTree}, ratio::Float32)

# Wrapper of void TTree::SetTimerInterval(Int_t)
@trydoc raw"""
    SetTimerInterval(this::ByRef1{TTree}, msec::Int32)::Nothing


""" SetTimerInterval(this::ByRef1{TTree}, msec::Int32)

# Wrapper of void TTree::SetUpdate(Int_t)
@trydoc raw"""
    SetUpdate(this::ByRef1{TTree}, freq::Int32)::Nothing


""" SetUpdate(this::ByRef1{TTree}, freq::Int32)

# Wrapper of void TTree::SetWeight(Double_t, Option_t *)
@trydoc raw"""
    SetWeight(this::ByRef1{TTree}, w::Float64, option::ByCopy{String})::Nothing
Set tree weight.
The weight is used by [TTree!Draw](@ref) to automatically weight each selected entry in the resulting histogram.

For example the equivalent of: 

    T.Draw("x", "w")

(C++ version of the code)

 is: 

    T.SetWeight(w);
    T.Draw("x");

(C++ version of the code)

 This function is redefined by [TChain!SetWeight](@ref). In case of a [TChain](@ref), an option "global_" may be specified to set the same weight for all trees in the [TChain](@ref) instead of the default behaviour using the weights of each tree in the chain (see [TChain!SetWeight](@ref)).
""" SetWeight(this::ByRef1{TTree}, w::Float64, option::ByCopy{String})

# Wrapper of void TTree::Show(Long64_t, Int_t)
@trydoc raw"""
    Show(this::ByRef1{TTree}, entry::Int64, lenmax::Int32)::Nothing
Print values of all active leaves for entry.
- if entry==-1, print current entry (default)
- if a leaf is an array, a maximum of lenmax elements is printed.
""" Show(this::ByRef1{TTree}, entry::Int64, lenmax::Int32)

# Wrapper of void TTree::StartViewer()
@trydoc raw"""
    StartViewer(this::ByRef1{TTree})::Nothing
Start the [TTreeViewer](@ref) on this tree.
- ww is the width of the canvas in pixels
- wh is the height of the canvas in pixels
""" StartViewer(this::ByRef1{TTree})

# Wrapper of Int_t TTree::StopCacheLearningPhase()
@trydoc raw"""
    StopCacheLearningPhase(this::ByRef1{TTree})::Int32
Stop the cache learning phase.
Returns:

- 0 learning phase stopped or not active
- -1 on error
""" StopCacheLearningPhase(this::ByRef1{TTree})

# Wrapper of Int_t TTree::UnbinnedFit(const char *, const char *, const char *, Option_t *, Long64_t, Long64_t)
@trydoc raw"""
    UnbinnedFit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)::Int32
Unbinned fit of one or more variable(s) from a tree.
funcname is a [TF1](@ref) function.

###Note

see TTree!Draw for explanations of the other parameters.

Fit the variable varexp using the function funcname using the selection cuts given by selection.

The list of fit options is given in parameter option.

- option = "Q" Quiet mode (minimum printing)
- option = "V" Verbose mode (default is between Q and V)
- option = "E" Perform better Errors estimation using Minos technique
- option = "M" More. Improve fit results

You can specify boundary limits for some or all parameters via 

    func->SetParLimits(p_number, parmin, parmax);

(C++ version of the code)

 if parmin>=parmax, the parameter is fixed

Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do: 

    func->SetParameters(0,3.1,1.e-6,0.1,-8,100);
    func->SetParLimits(4,-10,-4);
    func->SetParLimits(5, 1,1);

(C++ version of the code)

 With this setup:

- Parameters 0->3 can vary freely
- Parameter 4 has boundaries [-10,-4] with initial value -8
- Parameter 5 is fixed to 100.

For the fit to be meaningful, the function must be self-normalized.

i.e. It must have the same integral regardless of the parameter settings. Otherwise the fit will effectively just maximize the area.

It is mandatory to have a normalization variable which is fixed for the fit. e.g. 

    TF1* f1 = new TF1("f1", "gaus(0)/sqrt(2*3.14159)/[2]", 0, 5);
    f1->SetParameters(1, 3.1, 0.01);
    f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1
    data->UnbinnedFit("f1", "jpsimass", "jpsipt>3.0");

(C++ version of the code)

 1, 2 and 3 Dimensional fits are supported. See also [TTree!Fit](@ref)

Return status:

- The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult
- The fitResult is 0 is the fit is OK.
- The fitResult is negative in case of an error not connected with the fit.
- The number of entries used in the fit can be obtained via mytree.GetSelectedRows();
- If the number of selected entries is null the function returns -1
""" UnbinnedFit(this::ByRef1{TTree}, funcname::ByCopy{String}, varexp::ByCopy{String}, selection::ByCopy{String}, option::ByCopy{String}, nentries::Int64, firstentry::Int64)

# Wrapper of void TTree::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TTree})::Nothing
Replace current attributes by current style.

""" UseCurrentStyle(this::ByRef1{TTree})

# Wrapper of Int_t TTree::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TTree}, name::ByCopy{String}, option::Int32, bufsize::Int32)::Int32
Write this object to the current directory.
For more see [TObject!Write](@ref) If option & kFlushBasket, call FlushBasket before writing the tree.
""" Write(this::ByRef1{TTree}, name::ByCopy{String}, option::Int32, bufsize::Int32)

# Wrapper of Int_t TTree::GetBranchStyle()
@trydoc raw"""
    TTree!GetBranchStyle(this::ByRef1{TTree})::Int32
Static function returning the current branch style.
- style = 0 old Branch
- style = 1 new Bronch
""" TTree!GetBranchStyle(this::ByRef1{TTree})

# Wrapper of Long64_t TTree::GetMaxTreeSize()
@trydoc raw"""
    TTree!GetMaxTreeSize(this::ByRef1{TTree})::Int64
Static function which returns the tree file size limit in bytes.

""" TTree!GetMaxTreeSize(this::ByRef1{TTree})

# Wrapper of TTree * TTree::MergeTrees(TList *, Option_t *)
@trydoc raw"""
    TTree!MergeTrees(this::ByRef1{TTree}, list::ByPtr1{TList}, option::ByCopy{String})::CxxPtr1{TTree}
Static function merging the trees in the [TList](@ref) into a new tree.
Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). Trees with no branches will be skipped, the branch structure will be taken from the first non-zero-branch Tree of {li}
""" TTree!MergeTrees(this::ByRef1{TTree}, list::ByPtr1{TList}, option::ByCopy{String})

# Wrapper of void TTree::SetBranchStyle(Int_t)
@trydoc raw"""
    TTree!SetBranchStyle(this::ByRef1{TTree}, style::Int32)::Nothing
Set the current branch style.
(static function)

- style = 0 old Branch
- style = 1 new Bronch
""" TTree!SetBranchStyle(this::ByRef1{TTree}, style::Int32)

# Wrapper of void TTree::SetMaxTreeSize(Long64_t)
@trydoc raw"""
    TTree!SetMaxTreeSize(this::ByRef1{TTree}, maxsize::Int64)::Nothing
Set the maximum size in bytes of a Tree file (static function).
The default size is 100000000000LL, ie 100 Gigabytes.

In [TTree!Fill](@ref), when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style "file_1.root" if the original requested file name was "file.root".
""" TTree!SetMaxTreeSize(this::ByRef1{TTree}, maxsize::Int64)

# Wrapper of void TLeaf::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TLeaf}, b::ByPtr1{TBrowser})::Nothing
Browse the content of this leaf.

""" Browse(this::ByRef1{TLeaf}, b::ByPtr1{TBrowser})

# Wrapper of bool TLeaf::CanGenerateOffsetArray()
@trydoc raw"""
    CanGenerateOffsetArray(this::ByRef1{TLeaf})::Bool


""" CanGenerateOffsetArray(this::ByRef1{TLeaf})

# Wrapper of void TLeaf::Export(TClonesArray *, Int_t)
@trydoc raw"""
    Export(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)::Nothing


""" Export(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)

# Wrapper of void TLeaf::FillBasket(TBuffer &)
@trydoc raw"""
    FillBasket(this::ByRef1{TLeaf}, b::ByRef1{TBuffer})::Nothing
Pack leaf elements in Basket output buffer.

""" FillBasket(this::ByRef1{TLeaf}, b::ByRef1{TBuffer})

# Wrapper of Int_t * TLeaf::GenerateOffsetArray(Int_t, Int_t)
@trydoc raw"""
    GenerateOffsetArray(this::ByRef1{TLeaf}, base::Int32, events::Int32)::CxxPtr2{Int32}


""" GenerateOffsetArray(this::ByRef1{TLeaf}, base::Int32, events::Int32)

# Wrapper of TBranch * TLeaf::GetBranch()
@trydoc raw"""
    GetBranch(this::ByConstRef1{TLeaf})::CxxPtr1{TBranch}


""" GetBranch(this::ByConstRef1{TLeaf})

# Wrapper of TString TLeaf::GetFullName()
@trydoc raw"""
    GetFullName(this::ByConstRef1{TLeaf})::ByCopy{TString}
Return the full name (including the parent's branch names) of the leaf.

""" GetFullName(this::ByConstRef1{TLeaf})

# Wrapper of TLeaf * TLeaf::GetLeafCount()
@trydoc raw"""
    GetLeafCount(this::ByConstRef1{TLeaf})::CxxPtr1{TLeaf}
If this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has variable size, return a pointer to the [TLeaf](@ref) that stores such size.
Return a nullptr otherwise.
""" GetLeafCount(this::ByConstRef1{TLeaf})

# Wrapper of TLeaf * TLeaf::GetLeafCounter(Int_t &)
@trydoc raw"""
    GetLeafCounter(this::ByConstRef1{TLeaf}, countval::ByRef2{Int32})::CxxPtr1{TLeaf}
Return a pointer to the counter of this leaf (if any) or store the number of elements that the leaf contains in countval.
- If leaf name has the form var[nelem], where nelem is alphanumeric, then if nelem is a leaf name, return countval = 1 and the pointer to the leaf named nelem, otherwise return 0.
- If leaf name has the form var[nelem], where nelem is a non-negative integer, then return countval = nelem and a null pointer.
- If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2] where nelem and nelem2 are non-negative integers) then return countval = product of all dimension sizes and a null pointer.
- If leaf name has the form var[... (and does not match the previous 2 cases) return countval = -1 and null pointer;
- Otherwise return countval = 1 and a null pointer.
""" GetLeafCounter(this::ByConstRef1{TLeaf}, countval::ByRef2{Int32})

# Wrapper of Int_t TLeaf::GetLen()
@trydoc raw"""
    GetLen(this::ByConstRef1{TLeaf})::Int32
Return the number of effective elements of this leaf, for the current entry.

""" GetLen(this::ByConstRef1{TLeaf})

# Wrapper of Int_t TLeaf::GetLenStatic()
@trydoc raw"""
    GetLenStatic(this::ByConstRef1{TLeaf})::Int32
Return the fixed length of this leaf.
If the leaf stores a fixed-length array, this is the size of the array. If the leaf stores a non-array or a variable-sized array, this method returns 1. If the leaf stores an array with 2 or more dimensions, this method returns the total number of elements in the dimensions with static length: for example for float[3][2][] it would return 6.
""" GetLenStatic(this::ByConstRef1{TLeaf})

# Wrapper of Int_t TLeaf::GetLenType()
@trydoc raw"""
    GetLenType(this::ByConstRef1{TLeaf})::Int32


""" GetLenType(this::ByConstRef1{TLeaf})

# Wrapper of Int_t TLeaf::GetMaximum()
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TLeaf})::Int32


""" GetMaximum(this::ByConstRef1{TLeaf})

# Wrapper of Int_t TLeaf::GetMinimum()
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TLeaf})::Int32


""" GetMinimum(this::ByConstRef1{TLeaf})

# Wrapper of Int_t TLeaf::GetNdata()
@trydoc raw"""
    GetNdata(this::ByConstRef1{TLeaf})::Int32


""" GetNdata(this::ByConstRef1{TLeaf})

# Wrapper of Int_t TLeaf::GetOffset()
@trydoc raw"""
    GetOffset(this::ByConstRef1{TLeaf})::Int32


""" GetOffset(this::ByConstRef1{TLeaf})

# Wrapper of const char * TLeaf::GetTypeName()
@trydoc raw"""
    GetTypeName(this::ByConstRef1{TLeaf})::ByCopy{String}


""" GetTypeName(this::ByConstRef1{TLeaf})

# Wrapper of Double_t TLeaf::GetValue(Int_t)
@trydoc raw"""
    GetValue(this::ByConstRef1{TLeaf}, i::Int32)::Float64


""" GetValue(this::ByConstRef1{TLeaf}, i::Int32)

# Wrapper of Long64_t TLeaf::GetValueLong64(Int_t)
@trydoc raw"""
    GetValueLong64(this::ByConstRef1{TLeaf}, i::Int32)::Int64


""" GetValueLong64(this::ByConstRef1{TLeaf}, i::Int32)

# Wrapper of void * TLeaf::GetValuePointer()
@trydoc raw"""
    GetValuePointer(this::ByConstRef1{TLeaf})::CxxPtr2{Nothing}


""" GetValuePointer(this::ByConstRef1{TLeaf})

# Wrapper of void TLeaf::Import(TClonesArray *, Int_t)
@trydoc raw"""
    Import(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)::Nothing


""" Import(this::ByRef1{TLeaf}, ::ByPtr1{TClonesArray}, ::Int32)

# Wrapper of bool TLeaf::IncludeRange(TLeaf *)
@trydoc raw"""
    IncludeRange(this::ByRef1{TLeaf}, ::ByPtr1{TLeaf})::Bool


""" IncludeRange(this::ByRef1{TLeaf}, ::ByPtr1{TLeaf})

# Wrapper of bool TLeaf::IsOnTerminalBranch()
@trydoc raw"""
    IsOnTerminalBranch(this::ByConstRef1{TLeaf})::Bool


""" IsOnTerminalBranch(this::ByConstRef1{TLeaf})

# Wrapper of bool TLeaf::IsRange()
@trydoc raw"""
    IsRange(this::ByConstRef1{TLeaf})::Bool


""" IsRange(this::ByConstRef1{TLeaf})

# Wrapper of bool TLeaf::IsUnsigned()
@trydoc raw"""
    IsUnsigned(this::ByConstRef1{TLeaf})::Bool


""" IsUnsigned(this::ByConstRef1{TLeaf})

# Wrapper of void TLeaf::PrintValue(Int_t)
@trydoc raw"""
    PrintValue(this::ByConstRef1{TLeaf}, i::Int32)::Nothing


""" PrintValue(this::ByConstRef1{TLeaf}, i::Int32)

# Wrapper of void TLeaf::ReadBasket(TBuffer &)
@trydoc raw"""
    ReadBasket(this::ByRef1{TLeaf}, ::ByRef1{TBuffer})::Nothing


""" ReadBasket(this::ByRef1{TLeaf}, ::ByRef1{TBuffer})

# Wrapper of void TLeaf::ReadBasketExport(TBuffer &, TClonesArray *, Int_t)
@trydoc raw"""
    ReadBasketExport(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::ByPtr1{TClonesArray}, ::Int32)::Nothing


""" ReadBasketExport(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::ByPtr1{TClonesArray}, ::Int32)

# Wrapper of bool TLeaf::ReadBasketFast(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketFast(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketFast(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of bool TLeaf::ReadBasketSerialized(TBuffer &, Long64_t)
@trydoc raw"""
    ReadBasketSerialized(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)::Bool


""" ReadBasketSerialized(this::ByRef1{TLeaf}, ::ByRef1{TBuffer}, ::Int64)

# Wrapper of Int_t TLeaf::ResetAddress(void *, bool)
@trydoc raw"""
    ResetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing}, calledFromDestructor::Bool)::Int32
Helper routine for TLeafX!SetAddress.
The return value is non-zero if we owned the old value buffer and must delete it now. The size of the value buffer is recalculated and stored, and a decision is made whether or not we own the new value buffer.
""" ResetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing}, calledFromDestructor::Bool)

# Wrapper of void TLeaf::SetAddress(void *)
@trydoc raw"""
    SetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing})::Nothing


""" SetAddress(this::ByRef1{TLeaf}, add::ByPtr2{Nothing})

# Wrapper of void TLeaf::SetBranch(TBranch *)
@trydoc raw"""
    SetBranch(this::ByRef1{TLeaf}, branch::ByPtr1{TBranch})::Nothing


""" SetBranch(this::ByRef1{TLeaf}, branch::ByPtr1{TBranch})

# Wrapper of void TLeaf::SetLeafCount(TLeaf *)
@trydoc raw"""
    SetLeafCount(this::ByRef1{TLeaf}, leaf::ByPtr1{TLeaf})::Nothing
Set the leaf count of this leaf.

""" SetLeafCount(this::ByRef1{TLeaf}, leaf::ByPtr1{TLeaf})

# Wrapper of void TLeaf::SetLen(Int_t)
@trydoc raw"""
    SetLen(this::ByRef1{TLeaf}, len::Int32)::Nothing


""" SetLen(this::ByRef1{TLeaf}, len::Int32)

# Wrapper of void TLeaf::SetOffset(Int_t)
@trydoc raw"""
    SetOffset(this::ByRef1{TLeaf}, offset::Int32)::Nothing


""" SetOffset(this::ByRef1{TLeaf}, offset::Int32)

# Wrapper of void TLeaf::SetRange(bool)
@trydoc raw"""
    SetRange(this::ByRef1{TLeaf}, range::Bool)::Nothing


""" SetRange(this::ByRef1{TLeaf}, range::Bool)

# Wrapper of void TLeaf::SetUnsigned()
@trydoc raw"""
    SetUnsigned(this::ByRef1{TLeaf})::Nothing


""" SetUnsigned(this::ByRef1{TLeaf})

# Wrapper of void TEntryList::Add(const TEntryList *)
@trydoc raw"""
    Add(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})::Nothing
Add 2 entry lists.
## Arguments

- **`elist`** [in] 
    The list that should be added to the current one.
    

###Note

If you are creating a TEntryList for a TChain and you would like to have a one to one mapping between the sub lists of the TEntryList and the sub trees in the TChain, please do not call this function but use TEntryList!AddSubList instead and pair it with a call to TChain!SetEntryList with option "sync". See the AddSubList function documentation for an example usage. This helps for example in a testing or benchmark scenario where a TChain holds multiple times the same tree in the same file. In that case, this function would not be be able to distinguish different sub entry lists that refer to the same treename and filename. Instead it would create a union of all the sub entry lists into one list.
""" Add(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})

# Wrapper of void TEntryList::AddSubList(TEntryList *)
@trydoc raw"""
    AddSubList(this::ByRef1{TEntryList}, elist::ByPtr1{TEntryList})::Nothing
Add a sub entry list to the current list.
## Arguments

- **`elist`** [in] 
    an entry list that should be added as a sub list of this list.
    

This function is specifically targeted at situations where there is a global_ [TEntryList](@ref) that should hold one or more sub [TEntryList](@ref) objects. For example, if one wants to create a one to one mapping between the sub entry lists and the trees in the files that make a [TChain](@ref). Note that in such cases this configuration of the entry list should be used in pair with the option `"sync"` of the function [TChain!SetEntryList](@ref)

    // Create a TChain with two files. Each contains a tree with 20 entries
    TChain chain{"entries"};
    chain.Add("file_20entries_1.root");
    chain.Add("file_20entries_2.root");
    // Create a global_, empty TEntryList.
    TEntryList elists;
    // Create two entry lists. Each one will be referring to a different tree in the chain
    TEntryList elist1{"","","entries","file_20entries_1.root"};
    TEntryList elist2{"","","entries","file_20entries_2.root"};
    // Select the first ten entries from the first tree and all entries from the second
    for(auto entry = 0; entry < 10; entry++){
        elist1.Enter(entry);
    }
    for(auto entry = 0; entry < 20; entry++){
        elist2.Enter(entry);
    }
    // Add sub entry lists to the global_ list
    elists.AddSubList(&elist1);
    elists.AddSubList(&elist2);
    // Set the entry list in the chain. Note the usage of option "sync"
    chain.SetEntryList(&elists, "sync");

(C++ version of the code)
""" AddSubList(this::ByRef1{TEntryList}, elist::ByPtr1{TEntryList})

# Wrapper of Int_t TEntryList::Contains(Long64_t, TTree *)
@trydoc raw"""
    Contains(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})::Int32

- When tree = 0, returns from the current list
- When tree != 0, finds the list, corresponding to this tree
- When tree is a chain, the entry is assumed to be global_ index and the local_ entry is recomputed from the treeoffset information of the chain
""" Contains(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})

# Wrapper of void TEntryList::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TEntryList}, ::ByPtr1{TDirectory})::Nothing
Called by [TKey](@ref) and others to automatically add us to a directory when we are read from a file.

""" DirectoryAutoAdd(this::ByRef1{TEntryList}, ::ByPtr1{TDirectory})

# Wrapper of bool TEntryList::Enter(Long64_t, TTree *)
@trydoc raw"""
    Enter(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})::Bool
Add entry #entry to the list.
- When tree = 0, adds to the current list
- When tree != 0, finds the list, corresponding to this tree
- When tree is a chain, the entry is assumed to be global_ index and the local_ entry is recomputed from the treeoffset information of the chain
""" Enter(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})

# Wrapper of bool TEntryList::Enter(Long64_t, const char *, const char *)
@trydoc raw"""
    Enter(this::ByRef1{TEntryList}, localentry::Int64, treename::ByCopy{String}, filename::ByCopy{String})::Bool


""" Enter(this::ByRef1{TEntryList}, localentry::Int64, treename::ByCopy{String}, filename::ByCopy{String})

# Wrapper of void TEntryList::EnterRange(Long64_t, Long64_t, TTree *, UInt_t)
@trydoc raw"""
    EnterRange(this::ByRef1{TEntryList}, thestart::Int64, theend::Int64, tree::ByPtr1{TTree}, step::UInt32)::Nothing
Enter all entries in a range in the [TEntryList](@ref).
## Arguments

- **`thestart`** [in] 
    starting entry to enter. 
    
- **`theend`** [in] 
    ending entry to enter. 
    
- **`tree`** [in] 
    passed as is to [TEntryList!Enter](@ref). 
    
- **`step`** [in] 
    step increase of the loop entering the entries.
    

This is a helper function that enters all entries between `thestart` (inclusive) and `theend` (exclusive) to the [TEntryList](@ref) in a loop. It is useful also in PyROOT to avoid having to do the same in a Python loop.
""" EnterRange(this::ByRef1{TEntryList}, thestart::Int64, theend::Int64, tree::ByPtr1{TTree}, step::UInt32)

# Wrapper of TEntryList * TEntryList::GetCurrentList()
@trydoc raw"""
    GetCurrentList(this::ByConstRef1{TEntryList})::CxxPtr1{TEntryList}


""" GetCurrentList(this::ByConstRef1{TEntryList})

# Wrapper of TDirectory * TEntryList::GetDirectory()
@trydoc raw"""
    GetDirectory(this::ByConstRef1{TEntryList})::CxxPtr1{TDirectory}


""" GetDirectory(this::ByConstRef1{TEntryList})

# Wrapper of Long64_t TEntryList::GetEntriesToProcess()
@trydoc raw"""
    GetEntriesToProcess(this::ByConstRef1{TEntryList})::Int64


""" GetEntriesToProcess(this::ByConstRef1{TEntryList})

# Wrapper of Long64_t TEntryList::GetEntry(Long64_t)
@trydoc raw"""
    GetEntry(this::ByRef1{TEntryList}, index::Int64)::Int64
Return the number of the entry #index of this [TEntryList](@ref) in the [TTree](@ref) or [TChain](@ref) See also [Next()](@ref).

""" GetEntry(this::ByRef1{TEntryList}, index::Int64)

# Wrapper of Long64_t TEntryList::GetEntryAndTree(Long64_t, Int_t &)
@trydoc raw"""
    GetEntryAndTree(this::ByRef1{TEntryList}, index::Int64, treenum::ByRef2{Int32})::Int64
Return the index of "index"-th non-zero entry in the [TTree](@ref) or [TChain](@ref) and the # of the corresponding tree in the chain.

""" GetEntryAndTree(this::ByRef1{TEntryList}, index::Int64, treenum::ByRef2{Int32})

# Wrapper of TEntryList * TEntryList::GetEntryList(const char *, const char *, Option_t *)
@trydoc raw"""
    GetEntryList(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String}, opt::ByCopy{String})::CxxPtr1{TEntryList}
Return the entry list, corresponding to treename and filename By default, the filename is first tried as is, and then, if the corresponding list is not found, the filename is expanded to the absolute path, and compared again.
To avoid it, use option "ne"
""" GetEntryList(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String}, opt::ByCopy{String})

# Wrapper of const char * TEntryList::GetFileName()
@trydoc raw"""
    GetFileName(this::ByConstRef1{TEntryList})::ByCopy{String}


""" GetFileName(this::ByConstRef1{TEntryList})

# Wrapper of TList * TEntryList::GetLists()
@trydoc raw"""
    GetLists(this::ByConstRef1{TEntryList})::CxxPtr1{TList}


""" GetLists(this::ByConstRef1{TEntryList})

# Wrapper of Long64_t TEntryList::GetN()
@trydoc raw"""
    GetN(this::ByConstRef1{TEntryList})::Int64


""" GetN(this::ByConstRef1{TEntryList})

# Wrapper of bool TEntryList::GetReapplyCut()
@trydoc raw"""
    GetReapplyCut(this::ByConstRef1{TEntryList})::Bool


""" GetReapplyCut(this::ByConstRef1{TEntryList})

# Wrapper of const char * TEntryList::GetTreeName()
@trydoc raw"""
    GetTreeName(this::ByConstRef1{TEntryList})::ByCopy{String}


""" GetTreeName(this::ByConstRef1{TEntryList})

# Wrapper of Int_t TEntryList::GetTreeNumber()
@trydoc raw"""
    GetTreeNumber(this::ByConstRef1{TEntryList})::Int32


""" GetTreeNumber(this::ByConstRef1{TEntryList})

# Wrapper of bool TEntryList::IsValid()
@trydoc raw"""
    IsValid(this::ByConstRef1{TEntryList})::Bool


""" IsValid(this::ByConstRef1{TEntryList})

# Wrapper of Int_t TEntryList::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TEntryList}, list::ByPtr1{TCollection})::Int32
Merge this list with the lists from the collection.

""" Merge(this::ByRef1{TEntryList}, list::ByPtr1{TCollection})

# Wrapper of Long64_t TEntryList::Next()
@trydoc raw"""
    Next(this::ByRef1{TEntryList})::Int64
Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than [GetEntry()](@ref)

""" Next(this::ByRef1{TEntryList})

# Wrapper of void TEntryList::OptimizeStorage()
@trydoc raw"""
    OptimizeStorage(this::ByRef1{TEntryList})::Nothing
Checks if the array representation is more economical and if so, switches to it.

""" OptimizeStorage(this::ByRef1{TEntryList})

# Wrapper of void TEntryList::Print(const Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TEntryList}, option::ByCopy{String})::Nothing
Print this list.
- option = "" - default - print the name of the tree and file
- option = "all" - print all the entry numbers
""" Print(this::ByConstRef1{TEntryList}, option::ByCopy{String})

# Wrapper of Int_t TEntryList::RelocatePaths(const char *, const char *)
@trydoc raw"""
    RelocatePaths(this::ByRef1{TEntryList}, newloc::ByCopy{String}, oldloc::ByCopy{String})::Int32
Relocate the file paths.
If `oldroot` is defined, replace `oldroot` with `newroot` in all file names, i.e. `oldroot/re/st/of/the/path` will become `newroot`/re/st/of/the/path`. If`oldroot`is null, the new path will be just`newroot/path`. Relocation is mandatory to use the entry-list with the same dataset at a different location (i.e. on a different cluster, machine or disks).
""" RelocatePaths(this::ByRef1{TEntryList}, newloc::ByCopy{String}, oldloc::ByCopy{String})

# Wrapper of bool TEntryList::Remove(Long64_t, TTree *)
@trydoc raw"""
    Remove(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})::Bool
Remove entry #entry from the list.
- When tree = 0, removes from the current list
- When tree != 0, finds the list, corresponding to this tree
- When tree is a chain, the entry is assumed to be global_ index and the local_ entry is recomputed from the treeoffset information of the chain
""" Remove(this::ByRef1{TEntryList}, entry::Int64, tree::ByPtr1{TTree})

# Wrapper of void TEntryList::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TEntryList})::Nothing
Reset this list.

""" Reset(this::ByRef1{TEntryList})

# Wrapper of Int_t TEntryList::ScanPaths(TList *, bool)
@trydoc raw"""
    ScanPaths(this::ByRef1{TEntryList}, roots::ByPtr1{TList}, notify::Bool)::Int32
Scan the paths to find the common roots.
If 'roots' is defined, add the found roots to the list as TObjStrings. Return the number of roots found.
""" ScanPaths(this::ByRef1{TEntryList}, roots::ByPtr1{TList}, notify::Bool)

# Wrapper of void TEntryList::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TEntryList}, dir::ByPtr1{TDirectory})::Nothing
Add reference to directory dir. dir can be 0.

""" SetDirectory(this::ByRef1{TEntryList}, dir::ByPtr1{TDirectory})

# Wrapper of void TEntryList::SetEntriesToProcess(Long64_t)
@trydoc raw"""
    SetEntriesToProcess(this::ByRef1{TEntryList}, nen::Int64)::Nothing


""" SetEntriesToProcess(this::ByRef1{TEntryList}, nen::Int64)

# Wrapper of void TEntryList::SetFileName(const char *)
@trydoc raw"""
    SetFileName(this::ByRef1{TEntryList}, filename::ByCopy{String})::Nothing


""" SetFileName(this::ByRef1{TEntryList}, filename::ByCopy{String})

# Wrapper of void TEntryList::SetReapplyCut(bool)
@trydoc raw"""
    SetReapplyCut(this::ByRef1{TEntryList}, apply::Bool)::Nothing


""" SetReapplyCut(this::ByRef1{TEntryList}, apply::Bool)

# Wrapper of void TEntryList::SetShift(bool)
@trydoc raw"""
    SetShift(this::ByRef1{TEntryList}, shift::Bool)::Nothing


""" SetShift(this::ByRef1{TEntryList}, shift::Bool)

# Wrapper of void TEntryList::SetTree(const char *, const char *)
@trydoc raw"""
    SetTree(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String})::Nothing
If a list for a tree with such name and filename exists, sets it as the current sublist If not, creates this list and sets it as the current sublist.
! the filename is taken as provided, no extensions to full path or url !
""" SetTree(this::ByRef1{TEntryList}, treename::ByCopy{String}, filename::ByCopy{String})

# Wrapper of void TEntryList::SetTree(const TTree *)
@trydoc raw"""
    SetTree(this::ByRef1{TEntryList}, tree::ByConstPtr1{TTree})::Nothing
If a list for a tree with such name and filename exists, sets it as the current sublist If not, creates this list and sets it as the current sublist The name of the file, where the tree is, is taken as `tree->GetTree()->GetCurrentFile()->GetName()`, and then expanded either to the absolute path, or to full url.
If, for some reason, you want to provide the filename in a different format, use [SetTree(const char *treename, const char *filename)](@ref), where the filename is taken "as is".
""" SetTree(this::ByRef1{TEntryList}, tree::ByConstPtr1{TTree})

# Wrapper of void TEntryList::SetTreeName(const char *)
@trydoc raw"""
    SetTreeName(this::ByRef1{TEntryList}, treename::ByCopy{String})::Nothing


""" SetTreeName(this::ByRef1{TEntryList}, treename::ByCopy{String})

# Wrapper of void TEntryList::SetTreeNumber(Int_t)
@trydoc raw"""
    SetTreeNumber(this::ByRef1{TEntryList}, index::Int32)::Nothing


""" SetTreeNumber(this::ByRef1{TEntryList}, index::Int32)

# Wrapper of void TEntryList::Subtract(const TEntryList *)
@trydoc raw"""
    Subtract(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})::Nothing
Remove all the entries of this entry list, that are contained in elist.

""" Subtract(this::ByRef1{TEntryList}, elist::ByConstPtr1{TEntryList})

# Wrapper of Int_t TEntryList::Relocate(const char *, const char *, const char *, const char *)
@trydoc raw"""
    TEntryList!Relocate(this::ByRef1{TEntryList}, fn::ByCopy{String}, newroot::ByCopy{String}, oldroot::ByCopy{String}, enlnm::ByCopy{String})::Int32
Relocate entry list 'enlnm' in file 'fn' replacing 'oldroot' with 'newroot' in filenames.
If 'enlnm' is null or '*' all entry lists in the file are relocated. Relocation is mandatory to use the entry-list with the same dataset at a different location (i.e. on a different cluster, machine or disks). This function can be called as many times as need to reach the desired result. The existing 'locations' can be checked qith [TEntryList!Scan](@ref)
""" TEntryList!Relocate(this::ByRef1{TEntryList}, fn::ByCopy{String}, newroot::ByCopy{String}, oldroot::ByCopy{String}, enlnm::ByCopy{String})

# Wrapper of Int_t TEntryList::Scan(const char *, TList *)
@trydoc raw"""
    TEntryList!Scan(this::ByRef1{TEntryList}, fn::ByCopy{String}, roots::ByPtr1{TList})::Int32
Scan [TEntryList](@ref) in 'fn' to find the common parts of paths.
If 'roots' is defined, add the found roots to the list as TObjStrings. Return the number of common root paths found.
""" TEntryList!Scan(this::ByRef1{TEntryList}, fn::ByCopy{String}, roots::ByPtr1{TList})

# Wrapper of Bool_t TH1::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH1}, h::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this histogram by the addition of h1 and h2.
`this = c1*h1 + c2*h2` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated

Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.

Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number independently of the labels. For adding histogram ith labels one should use [TH1!Merge](@ref)

SPECIAL CASE (Average/Efficiency histograms) For histograms representing averages or efficiencies, one should compute the average of the two histograms and not the sum. One can mark a histogram to be an average histogram by setting its bit kIsAverage with myhist.SetBit(TH1!kIsAverage); Note that the two histograms must have their kIsAverage bit set

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Add](@ref)

IMPORTANT NOTE2: You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c1 is negative, whether [TAxis!kAxisRange](@ref) is true, and whether [TH1!ResetStats](@ref) has been called on either this or h1. See [TH1!GetStats](@ref).

ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0 do a scaling this = c1 * h1 / (bin Volume)

The function returns kFALSE if the Add operation failed
""" Add(this::ByRef1{TH1}, h::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TH1::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: `this = this + c1*h1` If errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.
Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.

Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number independently of the labels. For adding histogram with labels one should use [TH1!Merge](@ref)

SPECIAL CASE (Average/Efficiency histograms) For histograms representing averages or efficiencies, one should compute the average of the two histograms and not the sum. One can mark a histogram to be an average histogram by setting its bit kIsAverage with myhist.SetBit(TH1!kIsAverage); Note that the two histograms must have their kIsAverage bit set

IMPORTANT NOTE1: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Add](@ref)

IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor is used , ie this = this + c1*factor*h1 Use the other [TH1!Add](@ref) function if you do not want this feature

IMPORTANT NOTE3: You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c1 is negative, whether [TAxis!kAxisRange](@ref) is true, and whether [TH1!ResetStats](@ref) has been called on either this or h1. See [TH1!GetStats](@ref).

The function return kFALSE if the Add operation failed
""" Add(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TH1::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TH1}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: `this = this + c1*f1` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.
By default, the function is computed at the centre of the bin. if option "I" is specified (1-d histogram only), the integral of the function in each bin is used instead of the value of the function at the centre of the bin.

Only bins inside the function range are recomputed.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Add](@ref)

The function return kFALSE if the Add operation failed
""" Add(this::ByRef1{TH1}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of void TH1::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1}, bin::Int32)

# Wrapper of void TH1::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1}, bin::Int32, w::Float64)

# Wrapper of Double_t TH1::AndersonDarlingTest(const TH1 *, Double_t &)
@trydoc raw"""
    AndersonDarlingTest(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, advalue::ByRef2{Float64})::Float64
Same function as above but returning also the test statistic value.

""" AndersonDarlingTest(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, advalue::ByRef2{Float64})

# Wrapper of Double_t TH1::AndersonDarlingTest(const TH1 *, Option_t *)
@trydoc raw"""
    AndersonDarlingTest(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, option::ByCopy{String})::Float64
Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test.
The AD 2 sample test formula are derived from the paper F.W Scholz, M.A. Stephens "k-Sample Anderson-Darling Test".

The test is implemented in root in the [ROOT!Math!GoFTest](@ref) class It is the same formula ( (6) in the paper), and also shown in [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf)

Binned data are considered as un-binned data with identical observation happening in the bin center.

## Arguments

- **`h2`** [in] 
    Pointer to 1D histogram 
    
- **`option`** [in] 
    is a character string to specify options
    
    - "D" Put out a line of "Debug" printout
    - "T" Return the normalized A-D test statistic
    
    

- Note1: Underflow and overflow are not considered in the test
- Note2: The test works only for un-weighted histogram (i.e. representing counts)
- Note3: The histograms are not required to have the same X axis
- Note4: The test works only for 1-dimensional histograms
""" AndersonDarlingTest(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TH1}, b::ByPtr1{TBrowser})::Nothing
Browse the Histogram object.

""" Browse(this::ByRef1{TH1}, b::ByPtr1{TBrowser})

# Wrapper of Int_t TH1::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TH1}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is reset and filled from the buffer. When the histogram is filled from the buffer the value fBuffer[0] is set to a negative number (= - number of entries) When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0 While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if the histogram was filled before. This is needed when drawing the histogram
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when filling the histogram and the entries is larger than the buffer size
""" BufferEmpty(this::ByRef1{TH1}, action::Int32)

# Wrapper of Bool_t TH1::CanExtendAllAxes()
@trydoc raw"""
    CanExtendAllAxes(this::ByConstRef1{TH1})::Bool
Returns true if all axes are extendable.

""" CanExtendAllAxes(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::Chi2Test(const TH1 *, Option_t *, Double_t *)
@trydoc raw"""
    Chi2Test(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, option::ByCopy{String}, res::ByPtr2{Float64})::Float64
$ \chi^{2} $ test for comparing weighted and unweighted histograms.
Compares the histograms' adjusted (normalized) residuals. Function: Returns p-value. Other return values are specified by the 3rd parameter

## Arguments

- **`h2`** [in] 
    the second histogram 
    
- **`option`** [in] 
    - "UU" = experiment experiment comparison (unweighted-unweighted)
    - "UW" = experiment MC comparison (unweighted-weighted). Note that the first histogram should be unweighted
    - "WW" = MC MC comparison (weighted-weighted)
    - "NORM" = to be used when one or both of the histograms is scaled but the histogram originally was unweighted
    - by default underflows and overflows are not included:
    
        - "OF" = overflows included
        - "UF" = underflows included
    - "P" = print chi2, ndf, p_value, igood
    - "CHI2" = returns chi2 instead of p-value
    - "CHI2/NDF" = returns $ \chi^{2} $/ndf 
    
    
- **`res`** [in] 
    not empty - computes normalized residuals and returns them in this array
    

The current implementation is based on the papers $ \chi^{2} $ test for comparison of weighted and unweighted histograms" in Proceedings of PHYSTAT05 and
 "Comparison weighted and unweighted histograms", arXiv:physics/0605123 by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.

#### Introduction:

A frequently used technique in data analysis is the comparison of histograms. First suggested by Pearson [1] the $ \chi^{2} $ test of homogeneity is used widely for comparing usual (unweighted) histograms. This paper describes the implementation modified $ \chi^{2} $ tests for comparison of weighted and unweighted histograms and two weighted histograms [2] as well as usual Pearson's $ \chi^{2} $ test for comparison two usual (unweighted) histograms.

#### Overview:

Comparison of two histograms expect hypotheses that two histograms represent identical distributions. To make a decision p-value should be calculated. The hypotheses of identity is rejected if the p-value is lower then some significance level. Traditionally significance levels 0.1, 0.05 and 0.01 are used. The comparison procedure should include an analysis of the residuals which is often helpful in identifying the bins of histograms responsible for a significant overall $ \chi^{2} $ value. Residuals are the difference between bin contents and expected bin contents. Most convenient for analysis are the normalized residuals. If hypotheses of identity are valid then normalized residuals are approximately independent and identically distributed random variables having [N(0,1)](@ref) distribution. Analysis of residuals expect test of above mentioned properties of residuals. Notice that indirectly the analysis of residuals increase the power of $ \chi^{2} $ test.

#### Methods of comparison:

$ \chi^{2} $ test for comparison two (unweighted) histograms: Let us consider two histograms with the same binning and the number of bins equal to r. Let us denote the number of events in the ith bin in the first histogram as ni and as mi in the second one. The total number of events in the first histogram is equal to: 

``N = \sum_{i=1}^{r} n_{i}``

 and 

``M = \sum_{i=1}^{r} m_{i}``

 in the second histogram. The hypothesis of identity (homogeneity) [3] is that the two histograms represent random values with identical distributions. It is equivalent that there exist r constants p1,...,pr, such that 

``\sum_{i=1}^{r} p_{i}=1``

 and the probability of belonging to the ith bin for some measured value in both experiments is equal to pi. The number of events in the ith bin is a random variable with a distribution approximated by a Poisson probability distribution 

``\frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{n_{i}!}``

 for the first histogram and with distribution 

``\frac{e^{-Mp_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}``

 for the second histogram. If the hypothesis of homogeneity is valid, then the maximum likelihood estimator of pi, i=1,...,r, is 

``\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}``

 and then 

``X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}``

 has approximately a $ \chi^{2}_{(r-1)} $ distribution [3]. The comparison procedure can include an analysis of the residuals which is often helpful in identifying the bins of histograms responsible for a significant overall $ \chi^{2} $ value. Most convenient for analysis are the adjusted (normalized) residuals [4] 

``r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}``

 If hypotheses of homogeneity are valid then residuals ri are approximately independent and identically distributed random variables having [N(0,1)](@ref) distribution. The application of the $ \chi^{2} $ test has restrictions related to the value of the expected frequencies Npi, Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the expectations must be 1 or greater for both histograms. In practical cases when expected frequencies are not known the estimated expected frequencies $ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r $ can be used.

#### Unweighted and weighted histograms comparison:

A simple modification of the ideas described above can be used for the comparison of the usual (unweighted) and weighted histograms. Let us denote the number of events in the ith bin in the unweighted histogram as ni and the common weight of events in the ith bin of the weighted histogram as wi. The total number of events in the unweighted histogram is equal to 

``N = \sum_{i=1}^{r} n_{i}``

 and the total weight of events in the weighted histogram is equal to 

``W = \sum_{i=1}^{r} w_{i}``

 Let us formulate the hypothesis of identity of an unweighted histogram to a weighted histogram so that there exist r constants p1,...,pr, such that 

``\sum_{i=1}^{r} p_{i} = 1``

 for the unweighted histogram. The weight wi is a random variable with a distribution approximated by the normal probability distribution $ N(Wp_{i},\sigma_{i}^{2}) $ where $ \sigma_{i}^{2} $ is the variance of the weight wi. If we replace the variance $ \sigma_{i}^{2} $ with estimate $ s_{i}^{2} $ (sum of squares of weights of events in the ith bin) and the hypothesis of identity is valid, then the maximum likelihood estimator of pi,i=1,...,r, is 

``\hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}``

 We may then use the test statistic 

``X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}``

 and it has approximately a $ \sigma^{2}_{(r-1)} $ distribution [2]. This test, as well as the original one [3], has a restriction on the expected frequencies. The expected frequencies recommended for the weighted histogram is more than 25. The value of the minimal expected frequency can be decreased down to 10 for the case when the weights of the events are close to constant. In the case of a weighted histogram if the number of events is unknown, then we can apply this recommendation for the equivalent number of events as 

``n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }``

 The minimal expected frequency for an unweighted histogram must be 1. Notice that any usual (unweighted) histogram can be considered as a weighted histogram with events that have constant weights equal to 1. The variance $ z_{i}^{2} $ of the difference between the weight wi and the estimated expectation value of the weight is approximately equal to: 

``z_{i}^{2} = Var(w_{i}-W\hat{p}_{i}) = N\hat{p}_{i}(1-N\hat{p}_{i})\left(\frac{Ws_{i}^{2}}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}+\frac{s_{i}^{2}}{4}\left(1+\frac{Ns_{i}^{2}-w_{i}W}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}``

 The residuals 

``r_{i} = \frac{w_{i}-W\hat{p}_{i}}{z_{i}}``

 have approximately a normal distribution with mean equal to 0 and standard deviation equal to 1.

#### Two weighted histograms comparison:

Let us denote the common weight of events of the ith bin in the first histogram as w1i and as w2i in the second one. The total weight of events in the first histogram is equal to 

``W_{1} = \sum_{i=1}^{r} w_{1i}``

 and 

``W_{2} = \sum_{i=1}^{r} w_{2i}``

 in the second histogram. Let us formulate the hypothesis of identity of weighted histograms so that there exist r constants p1,...,pr, such that 

``\sum_{i=1}^{r} p_{i} = 1``

 and also expectation value of weight w1i equal to W1pi and expectation value of weight w2i equal to W2pi. Weights in both the histograms are random variables with distributions which can be approximated by a normal probability distribution $ N(W_{1}p_{i},\sigma_{1i}^{2}) $ for the first histogram and by a distribution $ N(W_{2}p_{i},\sigma_{2i}^{2}) $ for the second. Here $ \sigma_{1i}^{2} $ and $ \sigma_{2i}^{2} $ are the variances of w1i and w2i with estimators $ s_{1i}^{2} $ and $ s_{2i}^{2} $ respectively. If the hypothesis of identity is valid, then the maximum likelihood and Least Square Method estimator of pi,i=1,...,r, is 

``\hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}``

 We may then use the test statistic 

``X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}``

 and it has approximately a $ \chi^{2}_{(r-1)} $ distribution [2]. The normalized or studentised residuals [6] 

``r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}``

 have approximately a normal distribution with mean equal to 0 and standard deviation 1. A recommended minimal expected frequency is equal to 10 for the proposed test.

#### Numerical examples:

The method described herein is now illustrated with an example. We take a distribution 

``\phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1}       (1)``

 defined on the interval [4,16]. Events distributed according to the formula (1) are simulated to create the unweighted histogram. Uniformly distributed events are simulated for the weighted histogram with weights calculated by formula (1). Each histogram has the same number of bins: 20. Fig.1 shows the result of comparison of the unweighted histogram with 200 events (minimal expected frequency equal to one) and the weighted histogram with 500 events (minimal expected frequency equal to 25)

///![https://root.cern/doc/v636/pict1_TH1_001.png](https://root.cern/doc/v636/pict1_TH1_001.png)
 Fig 1. An example of comparison of the unweighted histogram with 200 events and the weighted histogram with 500 events:

1. unweighted histogram;
2. weighted histogram;
3. normalized residuals plot;
4. normal Q-Q plot of residuals.

The value of the test statistic $ \chi^{2} $ is equal to 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of the two histograms can be accepted for 0.05 significant level. The behavior of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot (see Fig. 1d) of residuals are regular and we cannot identify the outliers or bins with a big influence on $ \chi^{2} $.

The second example presents the same two histograms but 17 events was added to content of bin number 15 in unweighted histogram. Fig.2 shows the result of comparison of the unweighted histogram with 217 events (minimal expected frequency equal to one) and the weighted histogram with 500 events (minimal expected frequency equal to 25)

///![https://root.cern/doc/v636/pict1_TH1_002.png](https://root.cern/doc/v636/pict1_TH1_002.png)
 Fig 2. An example of comparison of the unweighted histogram with 217 events and the weighted histogram with 500 events:

1. unweighted histogram;
2. weighted histogram;
3. normalized residuals plot;
4. normal Q-Q plot of residuals.

The value of the test statistic $ \chi^{2} $ is equal to 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of the two histograms is rejected for 0.05 significant level. The behavior of the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see Fig. 2d) of residuals are not regular and we can identify the outlier or bin with a big influence on $ \chi^{2} $.

#### References:

- [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to Association and Normal Correlation. Drapers' Co. Memoirs, Biometric Series No. 1, London.
- [2] Gagunashvili, N., 2006. $ \sigma^{2} $ test for comparison of weighted and unweighted histograms. Statistical Problems in Particle Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05, Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44. Gagunashvili,N., Comparison of weighted and unweighted histograms, arXiv:physics/0605123, 2006.
- [3] Cramer, H., 1946. Mathematical methods of statistics. Princeton University Press, Princeton.
- [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables. Biometrics 29, 205-220.
- [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity test in 2xN tables. Biometrics 21, 19-33.
- [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis. John Wiley & Sons Inc., New York.
""" Chi2Test(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, option::ByCopy{String}, res::ByPtr2{Float64})

# Wrapper of Double_t TH1::Chi2TestX(const TH1 *, Double_t &, Int_t &, Int_t &, Option_t *, Double_t *)
@trydoc raw"""
    Chi2TestX(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, chi2::ByRef2{Float64}, ndf::ByRef2{Int32}, igood::ByRef2{Int32}, option::ByCopy{String}, res::ByPtr2{Float64})::Float64
The computation routine of the Chisquare test.
For the method description, see [Chi2Test()](@ref) function.

###Return

p-value 

## Arguments

- **`h2`** [in] 
    the second histogram 
    
- **`option`** [in] 
    - "UU" = experiment experiment comparison (unweighted-unweighted)
    - "UW" = experiment MC comparison (unweighted-weighted). Note that the first histogram should be unweighted
    - "WW" = MC MC comparison (weighted-weighted)
    - "NORM" = if one or both histograms is scaled
    - "OF" = overflows included
    - "UF" = underflows included by default underflows and overflows are not included 
    
    
- **`igood`** [out] 
    test output
    
    - igood=0 - no problems
    - For unweighted unweighted comparison
    
        - igood=1'There is a bin in the 1st histogram with less than 1 event'
        - igood=2'There is a bin in the 2nd histogram with less than 1 event'
        - igood=3'when the conditions for igood=1 and igood=2 are satisfied'
    - For unweighted weighted comparison
    
        - igood=1'There is a bin in the 1st histogram with less then 1 event'
        - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'
        - igood=3'when the conditions for igood=1 and igood=2 are satisfied'
    - For weighted weighted comparison
    
        - igood=1'There is a bin in the 1st histogram with less then 10 effective number of events'
        - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'
        - igood=3'when the conditions for igood=1 and igood=2 are satisfied' 
    
    
    
- **`chi2`** [out] 
    chisquare of the test 
    
- **`ndf`** [out] 
    number of degrees of freedom (important, when both histograms have the same empty bins) 
    
- **`res`** [out] 
    normalized residuals for further analysis
""" Chi2TestX(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, chi2::ByRef2{Float64}, ndf::ByRef2{Int32}, igood::ByRef2{Int32}, option::ByCopy{String}, res::ByPtr2{Float64})

# Wrapper of Double_t TH1::Chisquare(TF1 *, Option_t *)
@trydoc raw"""
    Chisquare(this::ByConstRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String})::Float64
Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used, unless [TAxis!SetRange](@ref) or [TAxis!SetRangeUser](@ref) was called before.
Use option "R" for restricting the chisquare calculation to the given range of the function Use option "L" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare) Use option "P" for using the Pearson chisquare based on the expected bin errors
""" Chisquare(this::ByConstRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String})

# Wrapper of void TH1::ClearUnderflowAndOverflow()
@trydoc raw"""
    ClearUnderflowAndOverflow(this::ByRef1{TH1})::Nothing
Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins.

""" ClearUnderflowAndOverflow(this::ByRef1{TH1})

# Wrapper of TObject * TH1::Clone(const char *)
@trydoc raw"""
    Clone(this::ByConstRef1{TH1}, newname::ByCopy{String})::CxxPtr1{TObject}
Make a complete copy of the underlying object.
If 'newname' is set, the copy's name will be set to that name.
""" Clone(this::ByConstRef1{TH1}, newname::ByCopy{String})

# Wrapper of Double_t TH1::ComputeIntegral(Bool_t)
@trydoc raw"""
    ComputeIntegral(this::ByRef1{TH1}, onlyPositive::Bool)::Float64
Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions.
This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. If the routine is called with the onlyPositive flag set an error will be produced in case of negative bin content and a NaN value returned 

###Return

1 if success, 0 if integral is zero, NAN if onlyPositive-test fails
""" ComputeIntegral(this::ByRef1{TH1}, onlyPositive::Bool)

# Wrapper of void TH1::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1}, hnew::ByRef1{TObject})::Nothing
Copy this histogram structure to newth1.
Note that this function does not copy the list of associated functions. Use [TObject!Clone](@ref) to make a full copy of a histogram.

Note also that the histogram it will be created in gDirectory (if [AddDirectoryStatus()](@ref)=true) or will not be added to any directory if [AddDirectoryStatus()](@ref)=false independently of the current directory stored in the original histogram
""" Copy(this::ByConstRef1{TH1}, hnew::ByRef1{TObject})

# Wrapper of void TH1::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TH1}, ::ByPtr1{TDirectory})::Nothing
Perform the automatic addition of the histogram to the given directory.
Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a [TKey](@ref) or being Cloned)
""" DirectoryAutoAdd(this::ByRef1{TH1}, ::ByPtr1{TDirectory})

# Wrapper of Int_t TH1::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TH1}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a line.
Compute the closest distance of approach from point px,py to elements of a histogram. The distance is computed in pixels units.

#### Algorithm:

Currently, this simple model computes the distance from the mouse to the histogram contour only.
""" DistancetoPrimitive(this::ByRef1{TH1}, px::Int32, py::Int32)

# Wrapper of Bool_t TH1::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})::Bool
Divide this histogram by h1.
`this = this/h1` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated. Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. See the other [TH1!Divide](@ref) that gives the possibility to optionally compute binomial errors.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Scale](@ref)

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TH1::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this histogram by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

If errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. However, if option ="B" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Divide](@ref)

Please note also that in the binomial case errors are calculated using standard binomial statistics, which means when b1 = b2, the error is zero. If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must use the function [TGraphAsymmErrors!BayesDivide](@ref), which will return an asymmetric and non-zero lower error for the case b1=b2.

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TH1::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)` if errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.
Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Divide](@ref)

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TH1::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Draw this histogram with options.
Histograms are drawn via the [THistPainter](@ref) class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use `h->DrawCopy();` This makes a clone of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone. By default, [TH1!Draw](@ref) clears the current pad.

One can use [TH1!SetMaximum](@ref) and [TH1!SetMinimum](@ref) to force a particular value for the maximum or the minimum scale on the plot.

[TH1!UseCurrentStyle](@ref) can be used to change all histogram graphics attributes to correspond to the current selected style. This function must be called for each histogram. In case one reads and draws many histograms from a file, one can force the histograms to inherit automatically the current graphics style by calling before gROOT->ForceStyle();

See the [THistPainter](@ref) class for a description of all the drawing options.
""" Draw(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of TH1 * TH1::DrawCopy(Option_t *, const char *)
@trydoc raw"""
    DrawCopy(this::ByConstRef1{TH1}, option::ByCopy{String}, name_postfix::ByCopy{String})::CxxPtr1{TH1}
Copy this histogram and Draw in the current pad.
Once the histogram is drawn into the pad, any further modification using graphics input will be made on the copy of the histogram, and not to the original object. By default a postfix "_copy" is added to the histogram name. Pass an empty postfix in case you want to draw a histogram with the same name

See Draw for the list of options
""" DrawCopy(this::ByConstRef1{TH1}, option::ByCopy{String}, name_postfix::ByCopy{String})

# Wrapper of TH1 * TH1::DrawNormalized(Option_t *, Double_t)
@trydoc raw"""
    DrawNormalized(this::ByConstRef1{TH1}, option::ByCopy{String}, norm::Float64)::CxxPtr1{TH1}
Draw a normalized copy of this histogram.
A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the new sum of weights (excluding under and overflow) is equal to norm. Note that the returned normalized histogram is not added to the list of histograms in the current directory in memory. It is the user's responsibility to delete this histogram. The kCanDelete bit is set for the returned object. If a pad containing this copy is cleared, the histogram will be automatically deleted.

See Draw for the list of options
""" DrawNormalized(this::ByConstRef1{TH1}, option::ByCopy{String}, norm::Float64)

# Wrapper of void TH1::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TH1})::Nothing
Display a panel with all histogram drawing options.
See class TDrawPanelHist for example
""" DrawPanel(this::ByRef1{TH1})

# Wrapper of void TH1::Eval(TF1 *, Option_t *)
@trydoc raw"""
    Eval(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String})::Nothing
Evaluate function f1 at the center of bins of this histogram.
- If option "R" is specified, the function is evaluated only for the bins included in the function range.
- If option "A" is specified, the value of the function is added to the existing bin contents
- If option "S" is specified, the value of the function is used to generate a value, distributed according to the Poisson distribution, with f1 as the mean.
""" Eval(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String})

# Wrapper of void TH1::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TH1}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a histogram is clicked with the locator

If Left button clicked on the bin top value, then the content of this bin is modified according to the new position of the mouse when it is released.
""" ExecuteEvent(this::ByRef1{TH1}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TH1::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Histogram is resized along axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The algorithm works for 1-d, 2-D and 3-D histograms. The axis must be extendable before invoking this function. Ex:

    h->GetXaxis()->SetCanExtend(kTRUE);

(C++ version of the code)
""" ExtendAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of TH1 * TH1::FFT(TH1 *, Option_t *)
@trydoc raw"""
    FFT(this::ByRef1{TH1}, h_output::ByPtr1{TH1}, option::ByCopy{String})::CxxPtr1{TH1}
This function allows to do discrete Fourier transforms of [TH1](@ref) and [TH2](@ref).
Available transform types and flags are described below.

To extract more information about the transform, use the function [TVirtualFFT!GetCurrentTransform()](@ref) to get a pointer to the current transform object.

## Arguments

- **`h_output`** [out] 
    histogram for the output. If a null pointer is passed, a new histogram is created and returned, otherwise, the provided histogram is used and should be big enough 
    
- **`option`** [in] 
    option parameters consists of 3 parts:
    
    - option on what to return
    
        - "RE" - returns a histogram of the real part of the output
        - "IM" - returns a histogram of the imaginary part of the output
        - "MAG"- returns a histogram of the magnitude of the output
        - "PH" - returns a histogram of the phase of the output
    - option of transform type
    
        - "R2C" - real to complex transforms - default
        - "R2HC" - real to halfcomplex (special format of storing output data, results the same as for R2C)
        - "DHT" - discrete Hartley transform real to real transforms (sine and cosine):
        - "R2R_0", "R2R_1", "R2R_2", "R2R_3" - discrete cosine transforms of types I-IV
        - "R2R_4", "R2R_5", "R2R_6", "R2R_7" - discrete sine transforms of types I-IV To specify the type of each dimension of a 2-dimensional real to real transform, use options of form "R2R_XX", for example, "R2R_02" for a transform, which is of type "R2R_0" in 1st dimension and "R2R_2" in the 2nd.
    - option of transform flag
    
        - "ES" (from "estimate") - no time in preparing the transform, but probably sub-optimal performance
        - "M" (from "measure") - some time spend in finding the optimal way to do the transform
        - "P" (from "patient") - more time spend in finding the optimal way to do the transform
        - "EX" (from "exhaustive") - the most optimal way is found This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type. Default is "ES".
    
    
    

Examples of valid options: "Mag R2C M" "Re R2R_11" "Im R2C ES" "PH R2HC EX"
""" FFT(this::ByRef1{TH1}, h_output::ByPtr1{TH1}, option::ByCopy{String})

# Wrapper of Int_t TH1::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1}, name::ByCopy{String}, w::Float64)::Int32
Increment bin with namex with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w.
""" Fill(this::ByRef1{TH1}, name::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH1::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1}, x::Float64)::Int32
Increment bin with abscissa X by 1.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the storage of the sum of squares of weights has been triggered, via the function Sumw2, then the sum of the squares of weights is incremented by 1 in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by 1
""" Fill(this::ByRef1{TH1}, x::Float64)

# Wrapper of Int_t TH1::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1}, x::Float64, w::Float64)::Int32
Increment bin with abscissa X with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w
""" Fill(this::ByRef1{TH1}, x::Float64, w::Float64)

# Wrapper of void TH1::FillN(Int_t, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH1}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill this histogram with an array x and weights w.
## Arguments

- **`ntimes`** [in] 
    number of entries in arrays x and w (array size must be ntimes*stride) 
    
- **`x`** [in] 
    array of values to be histogrammed 
    
- **`w`** [in] 
    array of weighs 
    
- **`stride`** [in] 
    step size through arrays x and w
    

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x. if w is NULL each entry is assumed a weight=1
""" FillN(this::ByRef1{TH1}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of void TH1::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH1}, ::Int32, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::Int32)::Nothing


""" FillN(this::ByRef1{TH1}, ::Int32, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::Int32)

# Wrapper of void TH1::FillRandom(const char *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH1}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in function fname.
## Arguments

- **`fname`** 
    : Function name used for filling the histogram 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used to sample
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents for the bin range of this histogram. It is normalized to 1.

Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

One can also call [TF1!GetRandom](@ref) to get a random variate from a function.
""" FillRandom(this::ByRef1{TH1}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH1::FillRandom(TH1 *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH1}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in histogram h.
## Arguments

- **`h`** 
    : Histogram pointer used for sampling random number 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used for sampling
    

The distribution contained in the histogram h ([TH1](@ref)) is integrated over the channel contents for the bin range of this histogram. It is normalized to 1.

Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

SPECIAL CASE when the target histogram has the same binning as the source. in this case we simply use a poisson distribution where the mean value per bin = bincontent/integral.
""" FillRandom(this::ByRef1{TH1}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of Int_t TH1::FindBin(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindBin(this::ByRef1{TH1}, x::Float64, y::Float64, z::Float64)::Int32
Return Global bin number corresponding to x,y,z.
2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions. This function tries to extend the axis if the given point belongs to an under-/overflow bin AND if [CanExtendAllAxes()](@ref) is true.

See also [TH1!GetBin](@ref), [TAxis!FindBin](@ref) and [TAxis!FindFixBin](@ref)
""" FindBin(this::ByRef1{TH1}, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TH1::FindFirstBinAbove(Double_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    FindFirstBinAbove(this::ByConstRef1{TH1}, threshold::Float64, axis::Int32, firstBin::Int32, lastBin::Int32)::Int32
Find first bin with content > threshold for axis (1=x, 2=y, 3=z) if no bins with content > threshold is found the function returns -1.
The search will occur between the specified first and last bin. Specifying the value of the last bin to search to less than zero will search until the last defined bin.
""" FindFirstBinAbove(this::ByConstRef1{TH1}, threshold::Float64, axis::Int32, firstBin::Int32, lastBin::Int32)

# Wrapper of Int_t TH1::FindFixBin(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindFixBin(this::ByConstRef1{TH1}, x::Float64, y::Float64, z::Float64)::Int32
Return Global bin number corresponding to x,y,z.
2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions. This function DOES NOT try to extend the axis if the given point belongs to an under-/overflow bin.

See also [TH1!GetBin](@ref), [TAxis!FindBin](@ref) and [TAxis!FindFixBin](@ref)
""" FindFixBin(this::ByConstRef1{TH1}, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TH1::FindLastBinAbove(Double_t, Int_t, Int_t, Int_t)
@trydoc raw"""
    FindLastBinAbove(this::ByConstRef1{TH1}, threshold::Float64, axis::Int32, firstBin::Int32, lastBin::Int32)::Int32
Find last bin with content > threshold for axis (1=x, 2=y, 3=z) if no bins with content > threshold is found the function returns -1.
The search will occur between the specified first and last bin. Specifying the value of the last bin to search to less than zero will search until the last defined bin.
""" FindLastBinAbove(this::ByConstRef1{TH1}, threshold::Float64, axis::Int32, firstBin::Int32, lastBin::Int32)

# Wrapper of TObject * TH1::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TH1}, name::ByCopy{String})::CxxPtr1{TObject}
Search object named name in the list of functions.

""" FindObject(this::ByConstRef1{TH1}, name::ByCopy{String})

# Wrapper of TObject * TH1::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TH1}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Search object obj in the list of functions.

""" FindObject(this::ByConstRef1{TH1}, obj::ByConstPtr1{TObject})

# Wrapper of TFitResultPtr TH1::Fit(const char *, Option_t *, Option_t *, Double_t, Double_t)
@trydoc raw"""
    Fit(this::ByRef1{TH1}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit histogram with function fname.
fname is the name of a function available in the global_ [ROOT](@ref) list of functions `gROOT->GetListOfFunctions` The list include any [TF1](@ref) object created by the user plus some pre-defined functions which are automatically created by [ROOT](@ref) the first time a pre-defined function is requested from `gROOT` (i.e. when calling `gROOT->GetFunction(const char *name)`). These pre-defined functions are:

- `gaus, gausn` where gausn is the normalized Gaussian
- `landau, landaun`
- `expo`
- `pol1,...9, chebyshev1,...9`.

For printing the list of all available functions do: 
```
  TF1!InitStandardFunctions();   // not needed if `gROOT->GetFunction` is called before
  gROOT->GetListOfFunctions()->ls()
```  `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`, representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`

This function finds a pointer to the [TF1](@ref) object with name `fname` and calls [TH1!Fit(TF1 *, Option_t *, Option_t *,
 Double_t, Double_t)](@ref). See there for the fitting options and the details about fitting histograms
""" Fit(this::ByRef1{TH1}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of TFitResultPtr TH1::Fit(TF1 *, Option_t *, Option_t *, Double_t, Double_t)
@trydoc raw"""
    Fit(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit histogram with the function pointer f1.
## Arguments

- **`f1`** [in] 
    pointer to the function object 
    
- **`option`** [in] 
    string defining the fit options (see table below). 
    
- **`goption`** [in] 
    specify a list of graphics options. See [TH1!Draw](@ref) for a complete list of these options. 
    
- **`xxmin`** [in] 
    lower fitting range 
    
- **`xxmax`** [in] 
    upper fitting range 
    

###Return

A smart pointer to the TFitResult class

### Histogram Fitting Options

Here is the full list of fit options that can be given in the parameter `option`. Several options can be used together by concatanating the strings without the need of any delimiters.

| **option**    | **description**                                                                                                                                                                                                                                 |
|:--------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "L"           | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.                                                                                                                                   |
| "WL"          | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.                                                      |
| "P"           | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.                                                        |
| "MULTI"       | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.                                                                                                |
| "W"           | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.                                                                                                                                                         |
| "WW"          | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.                                                                                                                                                  |
| "I"           | Uses the integral of function in the bin instead of the default bin center value.                                                                                                                                                               |
| "F"           | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.                                                                                                                               |
| "U"           | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter!SetFCN`                                                                                                                          |
| "E"           | Performs a better parameter errors estimation using the Minos technique for all fit parameters.                                                                                                                                                 |
| "M"           | Uses the IMPROVE algorithm (available only in [TMinuit](@ref)). This algorithm attempts improve the found local_ minimum by searching for a better one.                                                                                         |
| "S"           | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT!Math!FitResult`.                                                               |
| "Q"           | Quiet mode (minimum printing)                                                                                                                                                                                                                   |
| "V"           | Verbose mode (default is between Q and V)                                                                                                                                                                                                       |
| "+"           | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.                                                                                                      |
| "N"           | Does not store the graphics function, does not draw the histogram with the function after fitting.                                                                                                                                              |
| "0"           | Does not draw the histogram and the fitted function after fitting, but in contrast to option "N", it stores the fitted function in the histogram list of functions.                                                                             |
| "R"           | Fit using a fitting range specified in the function range with `TF1!SetRange`.                                                                                                                                                                  |
| "B"           | Use this option when you want to fix or set limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used. |
| "C"           | In case of linear fitting, do no calculate the chisquare (saves CPU time).                                                                                                                                                                      |
| "G"           | Uses the gradient implemented in `TF1!GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided [TF1](@ref) function.                                                                |
| "WIDTH"       | Scales the histogran bin content by the bin width (useful for variable bins histograms)                                                                                                                                                         |
| "SERIAL"      | Runs in serial mode. By default if [ROOT](@ref) is built with MT support and MT is enables, the fit is perfomed in multi-thread - "E" Perform better Errors estimation using Minos technique                                                    |
| "MULTITHREAD" | Forces usage of multi-thread execution whenever possible                                                                                                                                                                                        |

The default fitting of an histogram (when no option is given) is perfomed as following:

- a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);
- the full range of the histogram is used, unless [TAxis!SetRange](@ref) or [TAxis!SetRangeUser](@ref) was called before;
- the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;
- for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.
- only the status of the fit is returned;
- the fit is performed in Multithread whenever is enabled in [ROOT](@ref);
- only the last fitted function is saved in the histogram;
- the histogram is drawn after fitting overalyed with the resulting fitting function

### Minimizer Configuration

The Fit is perfomed using the default Minimizer, defined in the `ROOT!Math!MinimizerOptions` class. It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1!Fit`):

- `ROOT!Math!MinimizerOptions!SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm. For example `ROOT!Math!MinimizerOptions!SetDefaultMinimizer("GSLMultiMin","BFGS");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization The current defaults are ("Minuit","Migrad"). See the documentation of the `ROOT!Math!MinimizerOptions` for the available minimizers in [ROOT](@ref) and their corresponding algorithms.
- `ROOT!Math!MinimizerOptions!SetDefaultTolerance` for setting a different tolerance value for the minimization.
- `ROOT!Math!MinimizerOptions!SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.
- `ROOT!Math!MinimizerOptions!SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing

Other options are possible depending on the Minimizer used, see the corresponding documentation. The default minimizer can be also set in the resource file in etc/system.rootrc. For example

    Root.Fitter:      Minuit2

(C++ version of the code)

### Chi-square Fits

By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1!GetBinError`

``Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }``

where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment of empty bins. When using option "I" the residual is computed not using the function value at the bin center, `f(x(i)|p)`, but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume. When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used. In this case empty bins are considered in the fit. Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics, because they could return a biased result.

### Likelihood Fits

When using option "L" a likelihood fit is used instead of the default chi-square fit. The likelihood is built assuming a Poisson probability density function for each bin. The negative log-likelihood to be minimized is

``NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }``

 where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`. The exact likelihood used is the Poisson likelihood described in this paper: S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,” Nucl. Instrum. Meth. 221 (1984) 437.

``NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }``

 By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.

This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ). The likelihood method has the advantage of treating correctly bins with low statistics. In case of high statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit give the same result.

The likelihood method, although a bit slower, it is therefore the recommended method, when the histogram represent counts (Poisson statistics), where the chi-square methods may give incorrect results, especially in case of low statistics. In case of a weighted histogram, it is possible to perform also a likelihood fit by using the option "WL". Note a weighted histogram is a histogram which has been filled with weights and it has the information on the sum of the weight square for each bin ( [TH1!Sumw2()](@ref) has been called). The bin error for a weighted histogram is the square root of the sum of the weight square.

### Fit Result

The function returns a [TFitResultPtr](@ref) which can hold a pointer to a [TFitResult](@ref) object. By default the [TFitResultPtr](@ref) contains only the status of the fit which is return by an automatic conversion of the [TFitResultPtr](@ref) to an integer. One can write in this case directly:

    Int_t fitStatus =  h->Fit(myFunc);

(C++ version of the code)

If the option "S" is instead used, [TFitResultPtr](@ref) behaves as a smart pointer to the [TFitResult](@ref) object. This is useful for retrieving the full result information from the fit, such as the covariance matrix, as shown in this example code:

    TFitResultPtr r = h->Fit(myFunc,"S");
    TMatrixDSym cov = r->GetCovarianceMatrix();  //  to access the covariance matrix
    Double_t chi2   = r->Chi2(); // to retrieve the fit chi2
    Double_t par0   = r->Parameter(0); // retrieve the value for the parameter 0
    Double_t err0   = r->ParError(0); // retrieve the error for the parameter 0
    r->Print("V");     // print full information of fit including covariance matrix
    r->Write();        // store the result in a file

(C++ version of the code)

The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also directly from the fitted function that is passed to this call. Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit parameters with calls such as:

    Double_t chi2 = myfunc->GetChisquare();
    Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter
    Double_t err0 = myfunc->GetParError(0);  //error on first parameter

(C++ version of the code)

##### Associated functions

One or more objects (typically a TF1*) can be added to the list of functions (fFunctions) associated to each histogram. When [TH1!Fit](@ref) is invoked, the fitted function is added to the histogram list of functions (fFunctions). If the histogram is made persistent, the list of associated functions is also persistent. Given a histogram h, one can retrieve an associated function with:

    TF1 *myfunc = h->GetFunction("myfunc");

(C++ version of the code)

 or by quering directly the list obtained by calling `TH1!GetListOfFunctions`.

### Fit status

The status of the fit is obtained converting the [TFitResultPtr](@ref) to an integer independently if the fit option "S" is used or not:

    TFitResultPtr r = h->Fit(myFunc,opt);
    Int_t fitStatus = r;

(C++ version of the code)

- `status = 0` : the fit has been performed successfully (i.e no error occurred).
- `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.
- `status > 0` : return status from Minimizer, depends on used Minimizer. For example for [TMinuit](@ref) and Minuit2 we have:

    - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`. [TMinuit](@ref) returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of [TMinuit!mnexcm](@ref)). For example, for an error only in Minos but not in Migrad a fitStatus of 40 will be returned. Minuit2 returns 0 in case of success and different values in migrad,minos or hesse depending on the error. See in this case the documentation of Minuit2Minimizer!Minimize for the migrad return status, Minuit2Minimizer!GetMinosError for the minos return status and Minuit2Minimizer!Hesse for the hesse return status. If other minimizers are used see their specific documentation for the status code returned. For example in the case of Fumili, see [TFumili!Minimize](@ref).

### Fitting in a range

In order to fit in a sub-range of the histogram you have two options:

- pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;
- define a specific range in the fitted function and use the fitting option "R". For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian only in the interval 1 to 3, you can do:

    TF1 *f1 = new TF1("f1", "gaus", 1, 3);
    histo->Fit("f1", "R");

(C++ version of the code)

The fitting range is also limited by the histogram range defined using [TAxis!SetRange](@ref) or [TAxis!SetRangeUser](@ref). Therefore the fitting range is the smallest range between the histogram one and the one defined by one of the two previous options described above.

### Setting initial conditions

Parameters must be initialized before invoking the Fit function. The setting of the parameter initial values is automatic for the predefined functions such as poln, expo, gaus, landau. One can however disable this automatic computation by using the option "B". Note that if a predefined function is defined with an argument, eg, gaus(0), expo(1), you must specify the initial values for the parameters. You can specify boundary limits for some or all parameters via

    f1->SetParLimits(p_number, parmin, parmax);

(C++ version of the code)

if `parmin >= parmax`, the parameter is fixed Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do:

    func->SetParameters(0, 3.1, 1.e-6, -8, 0, 100);
    func->SetParLimits(3, -10, -4);
    func->FixParameter(4, 0);
    func->SetParLimits(5, 1, 1);

(C++ version of the code)

With this setup, parameters 0->2 can vary freely Parameter 3 has boundaries [-10,-4] with initial value -8 Parameter 4 is fixed to 0 Parameter 5 is fixed to 100. When the lower limit and upper limit are equal, the parameter is fixed. However to fix a parameter to 0, one must call the FixParameter function.

### Fit Statistics Box

The statistics box can display the result of the fit. You can change the statistics box to display the fit parameters with the TStyle!SetOptFit(mode) method. This mode has four digits. mode = pcev (default = 0111) 
```
v = 1;  print name/values of parameters
e = 1;  print errors (if e=1, v must be 1)
c = 1;  print Chisquare/Number of degrees of freedom
p = 1;  print Probability
```  For example: gStyle->SetOptFit(1011); prints the fit probability, parameter names/values, and errors. You can change the position of the statistics box with these lines (where g is a pointer to the [TGraph](@ref)): 
```
TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject("stats");
st->SetX1NDC(newx1); //new x thestart position
st->SetX2NDC(newx2); //new x theend position
```  

### Additional Notes on Fitting

#### Fitting a histogram of dimension N with a function of dimension N-1

It is possible to fit a [TH2](@ref) with a [TF1](@ref) or a [TH3](@ref) with a [TF2](@ref). In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content. For correct error scaling, the obtained parameter error are corrected as in the case when the option "W" is used.

#### User defined objective functions

By default when fitting a chi square function is used for fitting. When option "L" is used a Poisson likelihood function is used. Using option "MULTI" a multinomial likelihood fit is used. Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they are implemented using the routines FitUtil!EvaluateChi2 or FitUtil!EvaluatePoissonLogL in the file [math/mathcore/src/FitUtil.cxx](@ref). It is possible to specify a user defined fitting function, using option "U" and calling the following functions:

    TVirtualFitter!Fitter(myhist)->SetFCN(MyFittingFunction);

(C++ version of the code)

where MyFittingFunction is of type:

    extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);

(C++ version of the code)

#### Note on treatment of empty bins

Empty bins, which have the content equal to zero AND error equal to zero, are excluded by default from the chi-square fit, but they are considered in the likelihood fit. since they affect the likelihood if the function value in these bins is not negligible. Note that if the histogram is having bins with zero content and non zero-errors they are considered as any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit. In general, one should not fit a histogram with non-empty bins and zero errors.

If the bin errors are not known, one should use the fit option "W", which gives a weight=1 for each bin (it is an unweighted least-square fit). When using option "WW" the empty bins will be also considered in the chi-square fit with an error of 1. Note that in this fitting case (option "W" or "WW") the resulting fitted parameter errors are corrected by the obtained chi2 value using this scaling expression: `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a [TGraph](@ref) with no point errors.

#### Excluding points

You can use [TF1!RejectPoint](@ref) inside your fitting function to exclude some points within a certain range from the fit. See the tutorial `fit/fitExclude.C`.

#### Warning when using the option "0"

When selecting the option "0", the fitted function is added to the list of functions of the histogram, but it is not drawn when the histogram is drawn. You can undo this behaviour resetting its corresponding bit in the [TF1](@ref) object as following:

    h.Fit("myFunction", "0"); // fit, store function but do not draw
    h.Draw(); // function is not drawn
    h.GetFunction("myFunction")->ResetBit(TF1!kNotDraw);
""" Fit(this::ByRef1{TH1}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of void TH1::FitPanel()
@trydoc raw"""
    FitPanel(this::ByRef1{TH1})::Nothing
Display a panel with all histogram fit options.
See class TFitPanel for example
""" FitPanel(this::ByRef1{TH1})

# Wrapper of TH1 * TH1::GetAsymmetry(TH1 *, Double_t, Double_t)
@trydoc raw"""
    GetAsymmetry(this::ByRef1{TH1}, h2::ByPtr1{TH1}, c2::Float64, dc2::Float64)::CxxPtr1{TH1}
Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:
Asymmetry = (h1 - h2)/(h1 + h2)  where h1 = this

(C++ version of the code)

works for 1D, 2D, etc. histograms c2 is an optional argument that gives a relative weight between the two histograms, and dc2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from 2 different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).

example: assuming 'h1' and 'h2' are already filled

    h3 = h1->GetAsymmetry(h2)

(C++ version of the code)

then 'h3' is created and filled with the asymmetry between 'h1' and 'h2'; h1 and h2 are left intact.

Note that it is the user's responsibility to manage the created histogram. The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`

code proposed by Jason Seely ([seely@mit.edu](mailto:seely@mit.edu)) and adapted by R.Brun

clone the histograms so top and bottom will have the correct dimensions: Sumw2 just makes sure the errors will be computed properly when we form sums and ratios below.
""" GetAsymmetry(this::ByRef1{TH1}, h2::ByPtr1{TH1}, c2::Float64, dc2::Float64)

# Wrapper of Color_t TH1::GetAxisColor(Option_t *)
@trydoc raw"""
    GetAxisColor(this::ByConstRef1{TH1}, axis::ByCopy{String})::Int16
Return the number of divisions for "axis".

""" GetAxisColor(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Float_t TH1::GetBarOffset()
@trydoc raw"""
    GetBarOffset(this::ByConstRef1{TH1})::Float32


""" GetBarOffset(this::ByConstRef1{TH1})

# Wrapper of Float_t TH1::GetBarWidth()
@trydoc raw"""
    GetBarWidth(this::ByConstRef1{TH1})::Float32


""" GetBarWidth(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetBin(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBin(this::ByConstRef1{TH1}, binx::Int32, biny::Int32, binz::Int32)::Int32
Return Global bin number corresponding to binx,y,z.
2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions.

In case of a TH1x, returns binx directly. see [TH1!GetBinXYZ](@ref) for the inverse transformation.

Convention for numbering bins

For all histogram types: nbins, xlow, xup

- bin = 0; underflow bin
- bin = 1; first bin with low-edge xlow INCLUDED
- bin = nbins; last bin with upper-edge xup EXCLUDED
- bin = nbins+1; overflow bin

In case of 2-D or 3-D histograms, a "global_ bin" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function

    Int_t bin = h->GetBin(binx,biny,binz);

(C++ version of the code)

returns a global_/linearized bin number. This global_ bin is useful to access the bin information independently of the dimension.
""" GetBin(this::ByConstRef1{TH1}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH1::GetBinCenter(Int_t)
@trydoc raw"""
    GetBinCenter(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return bin center for 1D histogram.
Better to use h1.GetXaxis()->GetBinCenter(bin)
""" GetBinCenter(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return content of bin number bin.
Implemented in [TH1C](@ref),S,F,D

Convention for numbering bins

For all histogram types: nbins, xlow, xup

- bin = 0; underflow bin
- bin = 1; first bin with low-edge xlow INCLUDED
- bin = nbins; last bin with upper-edge xup EXCLUDED
- bin = nbins+1; overflow bin

In case of 2-D or 3-D histograms, a "global_ bin" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function

    Int_t bin = h->GetBin(binx,biny,binz);

(C++ version of the code)

returns a global_/linearized bin number. This global_ bin is useful to access the bin information independently of the dimension.
""" GetBinContent(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinContent(Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH1}, bin::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH1}, bin::Int32, ::Int32)

# Wrapper of Double_t TH1::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH1}, bin::Int32, ::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH1}, bin::Int32, ::Int32, ::Int32)

# Wrapper of Double_t TH1::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return value of error associated to bin number bin.
if the sum of squares of weights has been defined (via Sumw2), this function returns the sqrt(sum of w2). otherwise it returns the sqrt(contents) for this bin.
""" GetBinError(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinError(Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH1}, binx::Int32, biny::Int32)::Float64


""" GetBinError(this::ByConstRef1{TH1}, binx::Int32, biny::Int32)

# Wrapper of Double_t TH1::GetBinError(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH1}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinError(this::ByConstRef1{TH1}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH1::GetBinErrorLow(Int_t)
@trydoc raw"""
    GetBinErrorLow(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return lower error associated to bin number bin.
The error will depend on the statistic option used will return the binContent - lower interval value
""" GetBinErrorLow(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinErrorUp(Int_t)
@trydoc raw"""
    GetBinErrorUp(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return upper error associated to bin number bin.
The error will depend on the statistic option used will return the binContent - upper interval value
""" GetBinErrorUp(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinLowEdge(Int_t)
@trydoc raw"""
    GetBinLowEdge(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return bin lower edge for 1D histogram.
Better to use h1.GetXaxis()->GetBinLowEdge(bin)
""" GetBinLowEdge(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinWidth(Int_t)
@trydoc raw"""
    GetBinWidth(this::ByConstRef1{TH1}, bin::Int32)::Float64
Return bin width for 1D histogram.
Better to use h1.GetXaxis()->GetBinWidth(bin)
""" GetBinWidth(this::ByConstRef1{TH1}, bin::Int32)

# Wrapper of Double_t TH1::GetBinWithContent(Double_t, Int_t &, Int_t, Int_t, Double_t)
@trydoc raw"""
    GetBinWithContent(this::ByConstRef1{TH1}, c::Float64, binx::ByRef2{Int32}, firstx::Int32, lastx::Int32, maxdiff::Float64)::Float64
Compute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.
In case several bins in the specified range with diff=0 are found the first bin found is returned in binx. In case several bins in the specified range satisfy diff <=maxdiff the bin with the smallest difference is returned in binx. In all cases the function returns the smallest difference.

NOTE1: if firstx <= 0, firstx is set to bin 1 if (lastx < firstx then firstx is set to the number of bins ie if firstx=0 and lastx=0 (default) the search is on all bins.

NOTE2: if maxdiff=0 (default), the first bin with content=c is returned.
""" GetBinWithContent(this::ByConstRef1{TH1}, c::Float64, binx::ByRef2{Int32}, firstx::Int32, lastx::Int32, maxdiff::Float64)

# Wrapper of void TH1::GetBinXYZ(Int_t, Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetBinXYZ(this::ByConstRef1{TH1}, binglobal::Int32, binx::ByRef2{Int32}, biny::ByRef2{Int32}, binz::ByRef2{Int32})::Nothing
Return binx, biny, binz corresponding to the global_ bin number globalbin see [TH1!GetBin](@ref) function above.

""" GetBinXYZ(this::ByConstRef1{TH1}, binglobal::Int32, binx::ByRef2{Int32}, biny::ByRef2{Int32}, binz::ByRef2{Int32})

# Wrapper of const Double_t * TH1::GetBuffer()
@trydoc raw"""
    GetBuffer(this::ByConstRef1{TH1})::ConstCxxPtr2{Float64}


""" GetBuffer(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetBufferLength()
@trydoc raw"""
    GetBufferLength(this::ByConstRef1{TH1})::Int32


""" GetBufferLength(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetBufferSize()
@trydoc raw"""
    GetBufferSize(this::ByConstRef1{TH1})::Int32


""" GetBufferSize(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::GetCellContent(Int_t, Int_t)
@trydoc raw"""
    GetCellContent(this::ByConstRef1{TH1}, binx::Int32, biny::Int32)::Float64


""" GetCellContent(this::ByConstRef1{TH1}, binx::Int32, biny::Int32)

# Wrapper of Double_t TH1::GetCellError(Int_t, Int_t)
@trydoc raw"""
    GetCellError(this::ByConstRef1{TH1}, binx::Int32, biny::Int32)::Float64


""" GetCellError(this::ByConstRef1{TH1}, binx::Int32, biny::Int32)

# Wrapper of void TH1::GetCenter(Double_t *)
@trydoc raw"""
    GetCenter(this::ByConstRef1{TH1}, center::ByPtr2{Float64})::Nothing
Fill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)

""" GetCenter(this::ByConstRef1{TH1}, center::ByPtr2{Float64})

# Wrapper of Int_t TH1::GetContour(Double_t *)
@trydoc raw"""
    GetContour(this::ByRef1{TH1}, levels::ByPtr2{Float64})::Int32
Return contour values into array levels if pointer levels is non zero.
The function returns the number of contour levels. see GetContourLevel to return one contour only
""" GetContour(this::ByRef1{TH1}, levels::ByPtr2{Float64})

# Wrapper of Double_t TH1::GetContourLevel(Int_t)
@trydoc raw"""
    GetContourLevel(this::ByConstRef1{TH1}, level::Int32)::Float64
Return value of contour number level.
Use GetContour to return the array of all contour levels
""" GetContourLevel(this::ByConstRef1{TH1}, level::Int32)

# Wrapper of Double_t TH1::GetContourLevelPad(Int_t)
@trydoc raw"""
    GetContourLevelPad(this::ByConstRef1{TH1}, level::Int32)::Float64
Return the value of contour number "level" in Pad coordinates.
ie: if the Pad is in log scale along Z it returns le log of the contour level value. See GetContour to return the array of all contour levels
""" GetContourLevelPad(this::ByConstRef1{TH1}, level::Int32)

# Wrapper of TH1 * TH1::GetCumulative(Bool_t, const char *)
@trydoc raw"""
    GetCumulative(this::ByConstRef1{TH1}, forward::Bool, suffix::ByCopy{String})::CxxPtr1{TH1}
Return a pointer to a histogram containing the cumulative content.
The cumulative can be computed both in the forward (default) or backward direction; the name of the new histogram is constructed from the name of this histogram with the suffix "suffix" appended provided by the user. If not provided a default suffix="_cumulative" is used.

The cumulative distribution is formed by filling each bin of the resulting histogram with the sum of that bin and all previous (forward == kTRUE) or following (forward = kFALSE) bins.

Note: while cumulative distributions make sense in one dimension, you may not be getting what you expect in more than 1D because the concept of a cumulative distribution is much trickier to define; make sure you understand the order of summation before you use this method with histograms of dimension >= 2.

Note 2: By default the cumulative is computed from bin 1 to Nbins If an axis range is set, values between the minimum and maximum of the range are set. Setting an axis range can also be used for including underflow and overflow in the cumulative (e.g. by setting h->[GetXaxis()](@ref)->SetRange(0, h->[GetNbinsX()](@ref)+1); )
""" GetCumulative(this::ByConstRef1{TH1}, forward::Bool, suffix::ByCopy{String})

# Wrapper of Int_t TH1::GetDimension()
@trydoc raw"""
    GetDimension(this::ByConstRef1{TH1})::Int32


""" GetDimension(this::ByConstRef1{TH1})

# Wrapper of TDirectory * TH1::GetDirectory()
@trydoc raw"""
    GetDirectory(this::ByConstRef1{TH1})::CxxPtr1{TDirectory}


""" GetDirectory(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::GetEffectiveEntries()
@trydoc raw"""
    GetEffectiveEntries(this::ByConstRef1{TH1})::Float64
Number of effective entries of the histogram.
``neff = \frac{(\sum Weights )^2}{(\sum Weight^2 )}``

In case of an unweighted histogram this number is equivalent to the number of entries of the histogram. For a weighted histogram, this number corresponds to the hypothetical number of unweighted entries a histogram would need to have the same statistical power as this weighted histogram. Note: The underflow/overflow are included if one has set the TH1!StatOverFlows flag and if the statistics has been computed at filling time. If a range is set in the histogram the number is computed from the given range.
""" GetEffectiveEntries(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{TH1})::Float64
Return the current number of entries.

""" GetEntries(this::ByConstRef1{TH1})

# Wrapper of TF1 * TH1::GetFunction(const char *)
@trydoc raw"""
    GetFunction(this::ByConstRef1{TH1}, name::ByCopy{String})::CxxPtr1{TF1}
Return pointer to function with name.
Functions such as [TH1!Fit](@ref) store the fitted function in the list of functions of this histogram.
""" GetFunction(this::ByConstRef1{TH1}, name::ByCopy{String})

# Wrapper of Double_t * TH1::GetIntegral()
@trydoc raw"""
    GetIntegral(this::ByRef1{TH1})::CxxPtr2{Float64}
Return a pointer to the array of bins integral.
if the pointer fIntegral is null, [TH1!ComputeIntegral](@ref) is called The array dimension is the number of bins in the histograms including underflow and overflow (fNCells) the last value integral[fNCells] is set to the number of entries of the histogram
""" GetIntegral(this::ByRef1{TH1})

# Wrapper of Double_t TH1::GetKurtosis(Int_t)
@trydoc raw"""
    GetKurtosis(this::ByConstRef1{TH1}, axis::Int32)::Float64

- For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis. Kurtosis(gaussian(0, 1)) = 0.
- For axis =11, 12 or 13 returns the approximate standard error of kurtosis of the histogram along x, y or z axis

Note, that since third and fourth moment are not calculated at the fill time, kurtosis and its standard error are computed bin by bin

IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. See [TH1!GetMean](@ref) and [TH1!GetStdDev](@ref).
""" GetKurtosis(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Color_t TH1::GetLabelColor(Option_t *)
@trydoc raw"""
    GetLabelColor(this::ByConstRef1{TH1}, axis::ByCopy{String})::Int16
Return the "axis" label color.

""" GetLabelColor(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Style_t TH1::GetLabelFont(Option_t *)
@trydoc raw"""
    GetLabelFont(this::ByConstRef1{TH1}, axis::ByCopy{String})::Int16
Return the "axis" label font.

""" GetLabelFont(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Float_t TH1::GetLabelOffset(Option_t *)
@trydoc raw"""
    GetLabelOffset(this::ByConstRef1{TH1}, axis::ByCopy{String})::Float32
Return the "axis" label offset.

""" GetLabelOffset(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Float_t TH1::GetLabelSize(Option_t *)
@trydoc raw"""
    GetLabelSize(this::ByConstRef1{TH1}, axis::ByCopy{String})::Float32
Return the "axis" label size.

""" GetLabelSize(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of TList * TH1::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByConstRef1{TH1})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByConstRef1{TH1})

# Wrapper of void TH1::GetLowEdge(Double_t *)
@trydoc raw"""
    GetLowEdge(this::ByConstRef1{TH1}, edge::ByPtr2{Float64})::Nothing
Fill array with low edge of bins for 1D histogram Better to use h1.GetXaxis()->GetLowEdge(edge)

""" GetLowEdge(this::ByConstRef1{TH1}, edge::ByPtr2{Float64})

# Wrapper of Double_t TH1::GetMaximum(Double_t)
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TH1}, maxval::Float64)::Float64
Return maximum value smaller than maxval of bins in the range, unless the value has been overridden by [TH1!SetMaximum](@ref), in which case it returns that value.
This happens, for example, when the histogram is drawn and the y or z axis limits are changed

To get the maximum value of bins in the histogram regardless of whether the value has been overridden (using [TH1!SetMaximum](@ref)), use

    h->GetBinContent(h->GetMaximumBin())

(C++ version of the code)

[TH1!GetMaximumBin](@ref) can be used to get the location of the maximum value.
""" GetMaximum(this::ByConstRef1{TH1}, maxval::Float64)

# Wrapper of Int_t TH1::GetMaximumBin()
@trydoc raw"""
    GetMaximumBin(this::ByConstRef1{TH1})::Int32
Return location of bin with maximum value in the range.
[TH1!GetMaximum](@ref) can be used to get the maximum value.
""" GetMaximumBin(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetMaximumBin(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMaximumBin(this::ByConstRef1{TH1}, locmax::ByRef2{Int32}, locmay::ByRef2{Int32}, locmaz::ByRef2{Int32})::Int32
Return location of bin with maximum value in the range.

""" GetMaximumBin(this::ByConstRef1{TH1}, locmax::ByRef2{Int32}, locmay::ByRef2{Int32}, locmaz::ByRef2{Int32})

# Wrapper of Double_t TH1::GetMaximumStored()
@trydoc raw"""
    GetMaximumStored(this::ByConstRef1{TH1})::Float64


""" GetMaximumStored(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::GetMean(Int_t)
@trydoc raw"""
    GetMean(this::ByConstRef1{TH1}, axis::Int32)::Float64
For axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.
For axis = 11, 12, 13 returns the standard error of the mean value of the histogram along X, Y or Z axis

Note that the mean value/StdDev is computed using the bins in the currently defined range (see [TAxis!SetRange](@ref)). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.

IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned mean is the (unbinned) one calculated at fill time. If a range has been set, however, the mean is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis!SetRange(0, 0) to unset the range. To ensure that the returned mean (and all other statistics) is always that of the binned data stored in the histogram, call [TH1!ResetStats](@ref). See [TH1!GetStats](@ref).

Return mean value of this histogram along the X axis.
""" GetMean(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Double_t TH1::GetMeanError(Int_t)
@trydoc raw"""
    GetMeanError(this::ByConstRef1{TH1}, axis::Int32)::Float64
Return standard error of mean of this histogram along the X axis.
Note that the mean value/StdDev is computed using the bins in the currently defined range (see [TAxis!SetRange](@ref)). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.

Also note, that although the definition of standard error doesn't include the assumption of normality, many uses of this feature implicitly assume it.

IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned value is the (unbinned) one calculated at fill time. If a range has been set, however, the value is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis!SetRange(0, 0) to unset the range. To ensure that the returned value (and all other statistics) is always that of the binned data stored in the histogram, call [TH1!ResetStats](@ref). See [TH1!GetStats](@ref).
""" GetMeanError(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Double_t TH1::GetMinimum(Double_t)
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TH1}, minval::Float64)::Float64
Return minimum value larger than minval of bins in the range, unless the value has been overridden by [TH1!SetMinimum](@ref), in which case it returns that value.
This happens, for example, when the histogram is drawn and the y or z axis limits are changed

To get the minimum value of bins in the histogram regardless of whether the value has been overridden (using [TH1!SetMinimum](@ref)), use

    h->GetBinContent(h->GetMinimumBin())

(C++ version of the code)

[TH1!GetMinimumBin](@ref) can be used to get the location of the minimum value.
""" GetMinimum(this::ByConstRef1{TH1}, minval::Float64)

# Wrapper of void TH1::GetMinimumAndMaximum(Double_t &, Double_t &)
@trydoc raw"""
    GetMinimumAndMaximum(this::ByConstRef1{TH1}, min::ByRef2{Float64}, max::ByRef2{Float64})::Nothing
Retrieve the minimum and maximum values in the histogram.
This will not return a cached value and will always search the histogram for the min and max values. The user can condition whether or not to call this with the [GetMinimumStored()](@ref) and [GetMaximumStored()](@ref) methods. If the cache is empty, then the value will be -1111. Users can then use the [SetMinimum()](@ref) or [SetMaximum()](@ref) methods to cache the results. For example, the following recipe will make efficient use of this method and the cached minimum and maximum values. 

    Double_t currentMin = pHist->GetMinimumStored();
    Double_t currentMax = pHist->GetMaximumStored();
    if ((currentMin == -1111) || (currentMax == -1111)) {
       pHist->GetMinimumAndMaximum(currentMin, currentMax);
       pHist->SetMinimum(currentMin);
       pHist->SetMaximum(currentMax);
    }

(C++ version of the code)

## Arguments

- **`min`** 
    reference to variable that will hold found minimum value 
    
- **`max`** 
    reference to variable that will hold found maximum value
""" GetMinimumAndMaximum(this::ByConstRef1{TH1}, min::ByRef2{Float64}, max::ByRef2{Float64})

# Wrapper of Int_t TH1::GetMinimumBin()
@trydoc raw"""
    GetMinimumBin(this::ByConstRef1{TH1})::Int32
Return location of bin with minimum value in the range.

""" GetMinimumBin(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetMinimumBin(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMinimumBin(this::ByConstRef1{TH1}, locmix::ByRef2{Int32}, locmiy::ByRef2{Int32}, locmiz::ByRef2{Int32})::Int32
Return location of bin with minimum value in the range.

""" GetMinimumBin(this::ByConstRef1{TH1}, locmix::ByRef2{Int32}, locmiy::ByRef2{Int32}, locmiz::ByRef2{Int32})

# Wrapper of Double_t TH1::GetMinimumStored()
@trydoc raw"""
    GetMinimumStored(this::ByConstRef1{TH1})::Float64


""" GetMinimumStored(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetNbinsX()
@trydoc raw"""
    GetNbinsX(this::ByConstRef1{TH1})::Int32


""" GetNbinsX(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetNbinsY()
@trydoc raw"""
    GetNbinsY(this::ByConstRef1{TH1})::Int32


""" GetNbinsY(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetNbinsZ()
@trydoc raw"""
    GetNbinsZ(this::ByConstRef1{TH1})::Int32


""" GetNbinsZ(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetNcells()
@trydoc raw"""
    GetNcells(this::ByConstRef1{TH1})::Int32


""" GetNcells(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetNdivisions(Option_t *)
@trydoc raw"""
    GetNdivisions(this::ByConstRef1{TH1}, axis::ByCopy{String})::Int32
Return the number of divisions for "axis".

""" GetNdivisions(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Double_t TH1::GetNormFactor()
@trydoc raw"""
    GetNormFactor(this::ByConstRef1{TH1})::Float64


""" GetNormFactor(this::ByConstRef1{TH1})

# Wrapper of char * TH1::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TH1}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Redefines [TObject!GetObjectInfo](@ref).
Displays the histogram info (bin number, contents, integral up to bin corresponding to cursor position px,py
""" GetObjectInfo(this::ByConstRef1{TH1}, px::Int32, py::Int32)

# Wrapper of Option_t * TH1::GetOption()
@trydoc raw"""
    GetOption(this::ByConstRef1{TH1})::ByCopy{String}


""" GetOption(this::ByConstRef1{TH1})

# Wrapper of TVirtualHistPainter * TH1::GetPainter(Option_t *)
@trydoc raw"""
    GetPainter(this::ByRef1{TH1}, option::ByCopy{String})::CxxPtr1{TVirtualHistPainter}
Return pointer to painter.
If painter does not exist, it is created
""" GetPainter(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of Int_t TH1::GetQuantiles(Int_t, Double_t *, const Double_t *)
@trydoc raw"""
    GetQuantiles(this::ByRef1{TH1}, n::Int32, xp::ByPtr2{Float64}, p::ByConstPtr2{Float64})::Int32
Compute Quantiles for this histogram.
A quantile x_p := Q(p) is defined as the value x_p such that the cumulative probability distribution Function F of variable X yields:

    F(x_p) = Pr(X <= x_p) = p with 0 <= p <= 1.
    x_p = Q(p) = F_inv(p)

(C++ version of the code)

For instance the median x_0.5 of a distribution is defined as that value of the random variable X for which the distribution function equals 0.5:

    F(x_0.5) = Probability(X < x_0.5) = 0.5
    x_0.5 = Q(0.5)

(C++ version of the code)

###Author

Eddy Offermann code from Eddy Offermann, Renaissance

## Arguments

- **`n`** [in] 
    maximum size of the arrays xp and p (if given) 
    
- **`xp`** [out] 
    array to be filled with nq quantiles evaluated at (p). Memory has to be preallocated by caller.
    
    - If `p == nullptr`, the quantiles are computed at the (first `n`) probabilities p given by the CDF of the histogram; `n` must thus be smaller or equal Nbins+1, otherwise the extra values of `xp` will not be filled and `nq` will be smaller than `n`. If all bins have non-zero entries, the quantiles happen to be the bin centres. Empty bins will, however, be skipped in the quantiles. If the CDF is e.g. [0., 0., 0.1, ...], the quantiles would be, [3., 3., 3., ...], with the third bin starting at 3. 
    
    
- **`p`** [in] 
    array of cumulative probabilities where quantiles should be evaluated.
    
    - if `p == nullptr`, the CDF of the histogram will be used to compute the quantiles, and will have a size of n.
    - Otherwise, it is assumed to contain at least n values. 
    
    

###Return

number of quantiles computed 

###Note

Unlike in TF1!GetQuantiles, p is here an optional argument

Note that the Integral of the histogram is automatically recomputed if the number of entries is different of the number of entries when the integral was computed last time. In case you do not use the Fill functions to fill your histogram, but SetBinContent, you must call [TH1!ComputeIntegral](@ref) before calling this function.

Getting quantiles xp from two histograms and storing results in a [TGraph](@ref), a so-called QQ-plot

    TGraph *gr = new TGraph(nprob);
    h1->GetQuantiles(nprob,gr->GetX());
    h2->GetQuantiles(nprob,gr->GetY());
    gr->Draw("alp");

(C++ version of the code)

Example:

    void quantiles() {
       // demo for quantiles
       const Int_t nq = 20;
       TH1F *h = new TH1F("h","demo quantiles",100,-3,3);
       h->FillRandom("gaus",5000);
       h->GetXaxis()->SetTitle("x");
       h->GetYaxis()->SetTitle("Counts");
       Double_t p[nq];  // probabilities where to evaluate the quantiles in [0,1]
       Double_t xp[nq]; // array of positions X to store the resulting quantiles
       for (Int_t i=0;i<nq;i++) p[i] = Float_t(i+1)/nq;
       h->GetQuantiles(nq,xp,p);
       //show the original histogram in the top pad
       TCanvas *c1 = new TCanvas("c1","demo quantiles",10,10,700,900);
       c1->Divide(1,2);
       c1->cd(1);
       h->Draw();
       // show the quantiles in the bottom pad
       c1->cd(2);
       gPad->SetGrid();
       TGraph *gr = new TGraph(nq,p,xp);
       gr->SetMarkerStyle(21);
       gr->GetXaxis()->SetTitle("p");
       gr->GetYaxis()->SetTitle("x");
       gr->Draw("alp");
    }

(C++ version of the code)
""" GetQuantiles(this::ByRef1{TH1}, n::Int32, xp::ByPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of Double_t TH1::GetRandom(TRandom *)
@trydoc raw"""
    GetRandom(this::ByConstRef1{TH1}, rng::ByPtr1{TRandom})::Float64
Return a random number distributed according the histogram bin contents.
This function checks if the bins integral exists. If not, the integral is evaluated, normalized to one.

## Arguments

- **`rng`** 
    (optional) Random number generator pointer used (default is gRandom)
    

The integral is automatically recomputed if the number of entries is not the same then when the integral was computed. NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise. If the histogram has a bin with negative content a NaN is returned
""" GetRandom(this::ByConstRef1{TH1}, rng::ByPtr1{TRandom})

# Wrapper of Double_t TH1::GetRMS(Int_t)
@trydoc raw"""
    GetRMS(this::ByConstRef1{TH1}, axis::Int32)::Float64
This function returns the Standard Deviation (Sigma) of the distribution not the Root Mean Square (RMS).
The name "RMS" is been often used as a synonym for the Standard Deviation and it was introduced many years ago (Hbook/PAW times). We keep the name GetRMS for continuity as an alias to GetStdDev. [GetStdDev()](@ref) should be used instead.
""" GetRMS(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Double_t TH1::GetRMSError(Int_t)
@trydoc raw"""
    GetRMSError(this::ByConstRef1{TH1}, axis::Int32)::Float64


""" GetRMSError(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Double_t TH1::GetSkewness(Int_t)
@trydoc raw"""
    GetSkewness(this::ByConstRef1{TH1}, axis::Int32)::Float64

- For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.
- For axis = 11, 12 or 13 returns the approximate standard error of skewness of the histogram along x, y or z axis

Note, that since third and fourth moment are not calculated at the fill time, skewness and its standard error are computed bin by bin

IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. See [TH1!GetMean](@ref) and [TH1!GetStdDev](@ref).
""" GetSkewness(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of void TH1::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TH1}, stats::ByPtr2{Float64})::Nothing
fill the array stats from the contents of this histogram The array stats must be correctly dimensioned in the calling program.
stats[0] = sumw
    stats[1] = sumw2
    stats[2] = sumwx
    stats[3] = sumwx2

(C++ version of the code)

If no axis-subrange is specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.

IMPORTANT NOTE: This means that the returned statistics are context-dependent. If [TAxis!kAxisRange](@ref), the returned statistics are dependent on the binning; otherwise, they are a copy of the histogram statistics computed at fill time, which are unbinned by default (calling [TH1!ResetStats](@ref) forces them to use binned statistics). You can reset [TAxis!kAxisRange](@ref) using TAxis!SetRange(0, 0).

Note that the mean value/StdDev is computed using the bins in the currently defined range (see [TAxis!SetRange](@ref)). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.
""" GetStats(this::ByConstRef1{TH1}, stats::ByPtr2{Float64})

# Wrapper of Double_t TH1::GetStdDev(Int_t)
@trydoc raw"""
    GetStdDev(this::ByConstRef1{TH1}, axis::Int32)::Float64
Returns the Standard Deviation (Sigma).
The Sigma estimate is computed as 

``\sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}``

 For axis = 1,2 or 3 returns the Sigma value of the histogram along X, Y or Z axis For axis = 11, 12 or 13 returns the error of StdDev estimation along X, Y or Z axis for Normal distribution

Note that the mean value/sigma is computed using the bins in the currently defined range (see [TAxis!SetRange](@ref)). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.

IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned standard deviation is the (unbinned) one calculated at fill time. If a range has been set, however, the standard deviation is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis!SetRange(0, 0) to unset the range. To ensure that the returned standard deviation (and all other statistics) is always that of the binned data stored in the histogram, call [TH1!ResetStats](@ref). See [TH1!GetStats](@ref).
""" GetStdDev(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Double_t TH1::GetStdDevError(Int_t)
@trydoc raw"""
    GetStdDevError(this::ByConstRef1{TH1}, axis::Int32)::Float64
Return error of standard deviation estimation for Normal distribution.
Note that the mean value/StdDev is computed using the bins in the currently defined range (see [TAxis!SetRange](@ref)). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.

Value returned is standard deviation of sample standard deviation. Note that it is an approximated value which is valid only in the case that the original data distribution is Normal. The correct one would require the 4-th momentum value, which cannot be accurately estimated from a histogram since the x-information for all entries is not kept.

IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned value is the (unbinned) one calculated at fill time. If a range has been set, however, the value is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis!SetRange(0, 0) to unset the range. To ensure that the returned value (and all other statistics) is always that of the binned data stored in the histogram, call [TH1!ResetStats](@ref). See [TH1!GetStats](@ref).
""" GetStdDevError(this::ByConstRef1{TH1}, axis::Int32)

# Wrapper of Double_t TH1::GetSumOfWeights()
@trydoc raw"""
    GetSumOfWeights(this::ByConstRef1{TH1})::Float64
Return the sum of weights across all bins excluding under/overflows.
###See

TH1!GetSumOfAllWeights()
""" GetSumOfWeights(this::ByConstRef1{TH1})

# Wrapper of TArrayD * TH1::GetSumw2()
@trydoc raw"""
    GetSumw2(this::ByRef1{TH1})::CxxPtr1{TArrayD}


""" GetSumw2(this::ByRef1{TH1})

# Wrapper of const TArrayD * TH1::GetSumw2()
@trydoc raw"""
    GetSumw2(this::ByConstRef1{TH1})::ConstCxxPtr1{TArrayD}


""" GetSumw2(this::ByConstRef1{TH1})

# Wrapper of Int_t TH1::GetSumw2N()
@trydoc raw"""
    GetSumw2N(this::ByConstRef1{TH1})::Int32


""" GetSumw2N(this::ByConstRef1{TH1})

# Wrapper of Float_t TH1::GetTickLength(Option_t *)
@trydoc raw"""
    GetTickLength(this::ByConstRef1{TH1}, axis::ByCopy{String})::Float32
Return the "axis" tick length.

""" GetTickLength(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Style_t TH1::GetTitleFont(Option_t *)
@trydoc raw"""
    GetTitleFont(this::ByConstRef1{TH1}, axis::ByCopy{String})::Int16
Return the "axis" title font.

""" GetTitleFont(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Float_t TH1::GetTitleOffset(Option_t *)
@trydoc raw"""
    GetTitleOffset(this::ByConstRef1{TH1}, axis::ByCopy{String})::Float32
Return the "axis" title offset.

""" GetTitleOffset(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of Float_t TH1::GetTitleSize(Option_t *)
@trydoc raw"""
    GetTitleSize(this::ByConstRef1{TH1}, axis::ByCopy{String})::Float32
Return the "axis" title size.

""" GetTitleSize(this::ByConstRef1{TH1}, axis::ByCopy{String})

# Wrapper of TAxis * TH1::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByRef1{TH1})::CxxPtr1{TAxis}


""" GetXaxis(this::ByRef1{TH1})

# Wrapper of const TAxis * TH1::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByConstRef1{TH1})::ConstCxxPtr1{TAxis}


""" GetXaxis(this::ByConstRef1{TH1})

# Wrapper of TAxis * TH1::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByRef1{TH1})::CxxPtr1{TAxis}


""" GetYaxis(this::ByRef1{TH1})

# Wrapper of const TAxis * TH1::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByConstRef1{TH1})::ConstCxxPtr1{TAxis}


""" GetYaxis(this::ByConstRef1{TH1})

# Wrapper of TAxis * TH1::GetZaxis()
@trydoc raw"""
    GetZaxis(this::ByRef1{TH1})::CxxPtr1{TAxis}


""" GetZaxis(this::ByRef1{TH1})

# Wrapper of const TAxis * TH1::GetZaxis()
@trydoc raw"""
    GetZaxis(this::ByConstRef1{TH1})::ConstCxxPtr1{TAxis}


""" GetZaxis(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::Integral(Int_t, Int_t, Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH1}, binx1::Int32, binx2::Int32, option::ByCopy{String})::Float64
Return integral of bin contents in range [binx1,binx2].
By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x.
""" Integral(this::ByConstRef1{TH1}, binx1::Int32, binx2::Int32, option::ByCopy{String})

# Wrapper of Double_t TH1::Integral(Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH1}, option::ByCopy{String})::Float64
Return integral of bin contents.
Only bins in the bins range are considered.

By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x.
""" Integral(this::ByConstRef1{TH1}, option::ByCopy{String})

# Wrapper of Double_t TH1::IntegralAndError(Int_t, Int_t, Double_t &, Option_t *)
@trydoc raw"""
    IntegralAndError(this::ByConstRef1{TH1}, binx1::Int32, binx2::Int32, err::ByRef2{Float64}, option::ByCopy{String})::Float64
Return integral of bin contents in range [binx1,binx2] and its error.
By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x. the error is computed using error propagation from the bin errors assuming that all the bins are uncorrelated
""" IntegralAndError(this::ByConstRef1{TH1}, binx1::Int32, binx2::Int32, err::ByRef2{Float64}, option::ByCopy{String})

# Wrapper of Double_t TH1::Interpolate(Double_t)
@trydoc raw"""
    Interpolate(this::ByConstRef1{TH1}, x::Float64)::Float64
Given a point x, approximates the value via linear interpolation based on the two nearest bin centers.
Andy Mastbaum 10/21/08
""" Interpolate(this::ByConstRef1{TH1}, x::Float64)

# Wrapper of Double_t TH1::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByConstRef1{TH1}, x::Float64, y::Float64)::Float64
2d Interpolation. Not yet implemented.

""" Interpolate(this::ByConstRef1{TH1}, x::Float64, y::Float64)

# Wrapper of Double_t TH1::Interpolate(Double_t, Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByConstRef1{TH1}, x::Float64, y::Float64, z::Float64)::Float64
3d Interpolation. Not yet implemented.

""" Interpolate(this::ByConstRef1{TH1}, x::Float64, y::Float64, z::Float64)

# Wrapper of Bool_t TH1::IsBinOverflow(Int_t, Int_t)
@trydoc raw"""
    IsBinOverflow(this::ByConstRef1{TH1}, bin::Int32, axis::Int32)::Bool
Return true if the bin is overflow.

""" IsBinOverflow(this::ByConstRef1{TH1}, bin::Int32, axis::Int32)

# Wrapper of Bool_t TH1::IsBinUnderflow(Int_t, Int_t)
@trydoc raw"""
    IsBinUnderflow(this::ByConstRef1{TH1}, bin::Int32, axis::Int32)::Bool
Return true if the bin is underflow.
If iaxis = 0 make OR with all axes otherwise check only for the given axis
""" IsBinUnderflow(this::ByConstRef1{TH1}, bin::Int32, axis::Int32)

# Wrapper of Bool_t TH1::IsHighlight()
@trydoc raw"""
    IsHighlight(this::ByConstRef1{TH1})::Bool


""" IsHighlight(this::ByConstRef1{TH1})

# Wrapper of Double_t TH1::KolmogorovTest(const TH1 *, Option_t *)
@trydoc raw"""
    KolmogorovTest(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, option::ByCopy{String})::Float64
Statistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.
Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data and not for binned data as in the case of the histogram (see NOTE 3 below). So, before using this method blindly, read the NOTE 3.

Default: Ignore under- and overflow bins in comparison

## Arguments

- **`h2`** [in] 
    histogram 
    
- **`option`** [in] 
    is a character string to specify options
    
    - "U" include Underflows in test (also for 2-dim)
    - "O" include Overflows (also valid for 2-dim)
    - "N" include comparison of normalizations
    - "D" Put out a line of "Debug" printout
    - "M" Return the Maximum Kolmogorov distance instead of prob
    - "X" Run the pseudo experiments post-processor with the following procedure: make pseudoexperiments based on random values from the parent distribution, compare the KS distance of the pseudoexperiment to the parent distribution, and count all the KS values above the value obtained from the original data to Monte Carlo distribution. The number of pseudo-experiments nEXPT is by default 1000, and it can be changed by specifying the option as "X=number", for example "X=10000" for 10000 toys. The function returns the probability. (thanks to Ben Kilminster to submit this procedure). Note that this option "X" is much slower.
    
    

The returned function value is the probability of test (much less than one means NOT compatible)

Code adapted by Rene Brun from original HBOOK routine HDIFF

NOTE1 A good description of the Kolmogorov test can be seen at: [http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm)

NOTE2 see also alternative function [TH1!Chi2Test](@ref) The Kolmogorov test is assumed to give better results than Chi2Test in case of histograms with low statistics.

NOTE3 (Jan Conrad, Fred James) "The returned value PROB is calculated such that it will be
uniformly distributed between zero and one for compatible histograms,
provided the data are not binned (or the number of bins is very large
compared with the number of events). Users who have access to unbinned
data and wish exact confidence levels should therefore not put their data
into histograms, but should call directly TMath!KolmogorovTest. On
the other hand, since TH1 is a convenient way of collecting data and
saving space, this function has been provided. However, the values of
PROB for binned data will be shifted slightly higher than expected,
depending on the effects of the binning. For example, when comparing two
uniform distributions of 500 events in 100 bins, the values of PROB,
instead of being exactly uniformly distributed between zero and one, have
a mean value of about 0.56. We can apply a useful
rule: As long as the bin width is small compared with any significant
physical effect (for example the experimental resolution) then the binning
cannot have an important effect. Therefore, we believe that for all
practical purposes, the probability value PROB is calculated correctly
provided the user is aware that:

 1. The value of PROB should not be expected to have exactly the correct
    distribution for binned data.
 2. The user is responsible for seeing to it that the bin widths are
    small compared with any physical phenomena of interest.
 3. The effect of binning (if any) is always to make the value of PROB
    slightly too big. That is, setting an acceptance criterion of (PROB>0.05
    will assure that at most 5% of truly compatible histograms are rejected,
    and usually somewhat less."

Note also that for GoF test of unbinned data [ROOT](@ref) provides also the class [ROOT!Math!GoFTest](@ref). The class has also method for doing one sample tests (i.e. comparing the data with a given distribution).
""" KolmogorovTest(this::ByConstRef1{TH1}, h2::ByConstPtr1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TH1}, axis::ByCopy{String})::Nothing
Reduce the number of bins for the axis passed in the option to the number of bins having a label.
The method will remove only the extra bins existing after the last "labeled" bin. Note that if there are "un-labeled" bins present between "labeled" bins they will not be removed
""" LabelsDeflate(this::ByRef1{TH1}, axis::ByCopy{String})

# Wrapper of void TH1::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TH1}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram. This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TH1}, axis::ByCopy{String})

# Wrapper of void TH1::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TH1}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Sort bins with labels or set option(s) to draw axis with labels.
## Arguments

- **`option`** [in] 
    - "a" sort by alphabetic order
    - ">" sort by decreasing values
    - "<" sort by increasing values
    - "h" draw labels horizontal
    - "v" draw labels vertical
    - "u" draw labels up (theend of label right adjusted)
    - "d" draw labels down (thestart of label left adjusted)
    
    

In case not all bins have labels sorting will work only in the case the first `n` consecutive bins have all labels and sorting will be performed on those label bins.

## Arguments

- **`ax`** [in] 
    axis
""" LabelsOption(this::ByRef1{TH1}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TH1::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection})::Int64


""" Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection})

# Wrapper of Long64_t TH1::Merge(TCollection *, Option_t *)
@trydoc raw"""
    Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection}, option::ByCopy{String})::Int64
Add all histograms in the collection to this histogram.
This function computes the min/max for the x axis, compute a new number of bins, if necessary, add bin contents, errors and statistics. If all histograms have bin labels, bins with identical labels will be merged, no matter what their order is. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

Possible option: -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check (enabled by default) slows down the merging

IMPORTANT remark. The axis x may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width. Example:

    void atest() {
      TH1F *h1 = new TH1F("h1","h1",110,-110,0);
      TH1F *h2 = new TH1F("h2","h2",220,0,110);
      TH1F *h3 = new TH1F("h3","h3",330,-55,55);
      TRandom r;
      for (Int_t i=0;i<10000;i++) {
         h1->Fill(r.Gaus(-55,10));
         h2->Fill(r.Gaus(55,10));
         h3->Fill(r.Gaus(0,10));
      }
      TList *list = new TList;
      list->Add(h1);
      list->Add(h2);
      list->Add(h3);
      TH1F *h = (TH1F*)h1->Clone("h");
      h->Reset();
      h->Merge(list);
      h->Draw();
    }

(C++ version of the code)
""" Merge(this::ByRef1{TH1}, list::ByPtr1{TCollection}, option::ByCopy{String})

# Wrapper of Bool_t TH1::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})::Bool
Multiply this histogram by h1.
`this = this*h1`

If errors of this are available ([TH1!Sumw2](@ref)), errors are recalculated. Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Multiply](@ref)

The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TH1::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this histogram by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`

If errors of this are available ([TH1!Sumw2](@ref)), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.

IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Multiply](@ref)

The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TH1}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TH1::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation:
`this = this*c1*f1`

If errors are defined (see [TH1!Sumw2](@ref)), errors are also recalculated.

Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after [TH1!Multiply](@ref)

The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TH1}, f1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TH1::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Control routine to paint any kind of histograms.
This function is automatically called by [TCanvas!Update](@ref). (see [TH1!Draw](@ref) for the list of options)
""" Paint(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TH1}, option::ByCopy{String})::Nothing
Print some global_ quantities for this histogram.
## Arguments

- **`option`** [in] 
    - "base" is given, number of bins and ranges are also printed
    - "range" is given, bin contents and errors are also printed for all bins in the current range (default 1-->nbins)
    - "all" is given, bin contents and errors are also printed for all bins including under and overflows.
""" Print(this::ByConstRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TH1}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TH1}, stats::ByPtr2{Float64})

# Wrapper of TH1 * TH1::Rebin(Int_t, const char *, const Double_t *)
@trydoc raw"""
    Rebin(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})::CxxPtr1{TH1}
Rebin this histogram.
#### case 1 xbins=0

If newname is blank (default), the current histogram is modified and a pointer to it is returned.

If newname is not blank, the current histogram is not modified, and a new histogram is returned which is a Clone of the current histogram with its name set to newname.

The parameter ngroup indicates how many bins of this have to be merged into one bin of the result.

If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

examples: if h1 is an existing [TH1F](@ref) histogram with 100 bins

    h1->Rebin();  //merges two bins in one in h1: previous contents of h1 are lost
    h1->Rebin(5); //merges five bins in one in h1
    TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,"hnew")); // creates a new histogram hnew
                                                           // merging 5 bins of h1 in one bin

(C++ version of the code)

NOTE: If ngroup is not an exact divider of the number of bins, the top limit of the rebinned histogram is reduced to the upper edge of the last bin that can make a complete group. The remaining bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.

#### case 2 xbins!=0

A new histogram is created (you should specify newname). The parameter ngroup is the number of variable size bins in the created histogram. The array xbins must contain ngroup+1 elements that represent the low-edges of the bins. If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

NOTE: The bin edges specified in xbins should correspond to bin edges in the original histogram. If a bin edge in the new histogram is in the middle of a bin in the original histogram, all entries in the split bin in the original histogram will be transfered to the lower of the two possible bins in the new histogram. This is probably not what you want. A warning message is emitted in this case

examples: if h1 is an existing [TH1F](@ref) histogram with 100 bins

    Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin
    h1->Rebin(24,"hnew",xbins);  //creates a new variable bin size histogram hnew

(C++ version of the code)
""" Rebin(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})

# Wrapper of void TH1::RebinAxis(Double_t, TAxis *)
@trydoc raw"""
    RebinAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})::Nothing


""" RebinAxis(this::ByRef1{TH1}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of TH1 * TH1::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH1}


""" RebinX(this::ByRef1{TH1}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TH1::Rebuild(Option_t *)
@trydoc raw"""
    Rebuild(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Using the current bin info, recompute the arrays for contents and errors.

""" Rebuild(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TH1}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from the list of functions.

""" RecursiveRemove(this::ByRef1{TH1}, obj::ByPtr1{TObject})

# Wrapper of void TH1::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.
## Arguments

- **`option`** [in] 
    - if "ICE" is specified, resets only Integral, Contents and Errors.
    - if "ICES" is specified, resets only Integral, Contents, Errors and Statistics This option is used
    - if "M" is specified, resets also Minimum and Maximum
""" Reset(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::ResetStats()
@trydoc raw"""
    ResetStats(this::ByRef1{TH1})::Nothing
Reset the statistics including the number of entries and replace with values calculated from bin content.
The number of entries is set to the total bin content or (in case of weighted histogram) to number of effective entries

###Note

By default, before calling this function, statistics are those computed at fill time, which are unbinned. See TH1!GetStats.
""" ResetStats(this::ByRef1{TH1})

# Wrapper of void TH1::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TH1}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save the histogram as .csv, .tsv or .txt.
In case of any other extension, fall back to [TObject!SaveAs](@ref), which saves as a .C macro (but with the file name extension specified by the user)

The Under/Overflow bins are also exported (as first and last lines) The fist 2 columns are the lower and upper edges of the bins Column 3 contains the bin contents The last column contains the error in y. If errors are not present, the column is left empty

The result can be immediately imported into Excel, gnuplot, Python or whatever, without the needing to install pyroot, etc.

## Arguments

- **`filename`** 
    the name of the file where to store the histogram 
    
- **`option`** 
    some tuning options
    

The file extension defines the delimiter used:

- `.csv` : comma
- `.tsv` : tab
- `.txt` : space

If option = "title" a title line is generated. If the y-axis has a title, this title is displayed as column 3 name, otherwise, it shows "BinContent"
""" SaveAs(this::ByConstRef1{TH1}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TH1::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TH1}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this histogram by a constant c1.
`this = c1*this`

Note that both contents and errors (if any) are scaled. This function uses the services of [TH1!Add](@ref)

IMPORTANT NOTE: [Sumw2()](@ref) is called automatically when scaling. If you are not interested in the histogram statistics you can call Sumw2(kFALSE) or use the option "nosw2"

One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1!Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram.

If option contains "width" the bin contents and errors are divided by the bin width.
""" Scale(this::ByRef1{TH1}, c1::Float64, option::ByCopy{String})

# Wrapper of void TH1::SetAxisColor(Color_t, Option_t *)
@trydoc raw"""
    SetAxisColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})::Nothing
Set color to draw the axis line and tick marks.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetAxisColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetAxisRange(Double_t, Double_t, Option_t *)
@trydoc raw"""
    SetAxisRange(this::ByRef1{TH1}, xmin::Float64, xmax::Float64, axis::ByCopy{String})::Nothing
Set the "axis" range.

""" SetAxisRange(this::ByRef1{TH1}, xmin::Float64, xmax::Float64, axis::ByCopy{String})

# Wrapper of void TH1::SetBarOffset(Float_t)
@trydoc raw"""
    SetBarOffset(this::ByRef1{TH1}, offset::Float32)::Nothing
Set the bar offset as fraction of the bin width for drawing mode "B".
This shifts bars to the right on the x axis, and helps to draw bars next to each other. 

###See

THistPainter, SetBarWidth()
""" SetBarOffset(this::ByRef1{TH1}, offset::Float32)

# Wrapper of void TH1::SetBarWidth(Float_t)
@trydoc raw"""
    SetBarWidth(this::ByRef1{TH1}, width::Float32)::Nothing
Set the width of bars as fraction of the bin width for drawing mode "B".
This allows for making bars narrower than the bin width. With [SetBarOffset()](@ref), this helps to draw multiple bars next to each other. 

###See

THistPainter, SetBarOffset()
""" SetBarWidth(this::ByRef1{TH1}, width::Float32)

# Wrapper of void TH1::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH1}, bin::Int32, content::Float64)::Nothing
Set bin content see convention for numbering bins in [TH1!GetBin](@ref) In case the bin number is greater than the number of bins and the timedisplay option is set or [CanExtendAllAxes()](@ref), the number of bins is automatically doubled to accommodate the new bin.

""" SetBinContent(this::ByRef1{TH1}, bin::Int32, content::Float64)

# Wrapper of void TH1::SetBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, content::Float64)

# Wrapper of void TH1::SetBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH1}, bin::Int32, ::Int32, ::Int32, content::Float64)

# Wrapper of void TH1::SetBinError(Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH1}, bin::Int32, error::Float64)::Nothing
Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empty bin the bin error is set by default to the square root of their content.
Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent) he needs then to provide also the corresponding bin error (using SetBinError) since the bin error will not be recalculated after setting the content and a default error = 0 will be used for those bins.

See convention for numbering bins in [TH1!GetBin](@ref)
""" SetBinError(this::ByRef1{TH1}, bin::Int32, error::Float64)

# Wrapper of void TH1::SetBinError(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, error::Float64)::Nothing
See convention for numbering bins in [TH1!GetBin](@ref).
""" SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, error::Float64)

# Wrapper of void TH1::SetBinError(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, binz::Int32, error::Float64)::Nothing
See convention for numbering bins in [TH1!GetBin](@ref).
""" SetBinError(this::ByRef1{TH1}, binx::Int32, biny::Int32, binz::Int32, error::Float64)

# Wrapper of void TH1::SetBins(Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64})::Nothing
Redefine x axis parameters with variable bin sizes.
The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref) xBins is supposed to be of length nx+1
""" SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64})

# Wrapper of void TH1::SetBins(Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})::Nothing
Redefine x and y axis parameters with variable bin sizes.
The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref) xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1
""" SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})

# Wrapper of void TH1::SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})::Nothing
Redefine x, y and z axis parameters with variable bin sizes.
The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref) xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1
""" SetBins(this::ByRef1{TH1}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})

# Wrapper of void TH1::SetBins(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64)::Nothing
Redefine x axis parameters.
The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref)
""" SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64)

# Wrapper of void TH1::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)::Nothing
Redefine x and y axis parameters.
The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref)
""" SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)

# Wrapper of void TH1::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)::Nothing
Redefine x, y and z axis parameters.
The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see [TAxis!SetRange](@ref)
""" SetBins(this::ByRef1{TH1}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)

# Wrapper of void TH1::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1}, ::Int32)::Nothing


""" SetBinsLength(this::ByRef1{TH1}, ::Int32)

# Wrapper of void TH1::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TH1}, buffersize::Int32, option::ByCopy{String})::Nothing
Set the maximum number of entries to be kept in the buffer.

""" SetBuffer(this::ByRef1{TH1}, buffersize::Int32, option::ByCopy{String})

# Wrapper of UInt_t TH1::SetCanExtend(UInt_t)
@trydoc raw"""
    SetCanExtend(this::ByRef1{TH1}, extendBitMask::UInt32)::UInt32
Make the histogram axes extendable / not extendable according to the bit mask returns the previous bit mask specifying which axes are extendable.

""" SetCanExtend(this::ByRef1{TH1}, extendBitMask::UInt32)

# Wrapper of void TH1::SetCellContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetCellContent(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)::Nothing


""" SetCellContent(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)

# Wrapper of void TH1::SetCellError(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetCellError(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)::Nothing


""" SetCellError(this::ByRef1{TH1}, binx::Int32, biny::Int32, content::Float64)

# Wrapper of void TH1::SetContent(const Double_t *)
@trydoc raw"""
    SetContent(this::ByRef1{TH1}, content::ByConstPtr2{Float64})::Nothing
Replace bin contents by the contents of array content.

""" SetContent(this::ByRef1{TH1}, content::ByConstPtr2{Float64})

# Wrapper of void TH1::SetContour(Int_t, const Double_t *)
@trydoc raw"""
    SetContour(this::ByRef1{TH1}, nlevels::Int32, levels::ByConstPtr2{Float64})::Nothing
Set the number and values of contour levels.
By default the number of contour levels is set to 20. The contours values in the array "levels" should be specified in increasing order.

if argument levels = 0 or missing, equidistant contours are computed
""" SetContour(this::ByRef1{TH1}, nlevels::Int32, levels::ByConstPtr2{Float64})

# Wrapper of void TH1::SetContourLevel(Int_t, Double_t)
@trydoc raw"""
    SetContourLevel(this::ByRef1{TH1}, level::Int32, value::Float64)::Nothing
Set value for one contour level.

""" SetContourLevel(this::ByRef1{TH1}, level::Int32, value::Float64)

# Wrapper of void TH1::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TH1}, dir::ByPtr1{TDirectory})::Nothing
By default, when a histogram is created, it is added to the list of histogram objects in the current directory in memory.
Remove reference to this histogram from current directory and add reference to new directory dir. dir can be 0 in which case the histogram does not belong to any directory.

Note that the directory is not a real property of the histogram and it will not be copied when the histogram is copied or cloned. If the user wants to have the copied (cloned) histogram in the same directory, he needs to set again the directory using SetDirectory to the copied histograms
""" SetDirectory(this::ByRef1{TH1}, dir::ByPtr1{TDirectory})

# Wrapper of void TH1::SetEntries(Double_t)
@trydoc raw"""
    SetEntries(this::ByRef1{TH1}, n::Float64)::Nothing


""" SetEntries(this::ByRef1{TH1}, n::Float64)

# Wrapper of void TH1::SetError(const Double_t *)
@trydoc raw"""
    SetError(this::ByRef1{TH1}, error::ByConstPtr2{Float64})::Nothing
Replace bin errors by values in array error.

""" SetError(this::ByRef1{TH1}, error::ByConstPtr2{Float64})

# Wrapper of void TH1::SetHighlight(Bool_t)
@trydoc raw"""
    SetHighlight(this::ByRef1{TH1}, set::Bool)::Nothing
Set highlight (enable/disable) mode for the histogram by default highlight mode is disable.

""" SetHighlight(this::ByRef1{TH1}, set::Bool)

# Wrapper of void TH1::SetLabelColor(Color_t, Option_t *)
@trydoc raw"""
    SetLabelColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})::Nothing
Set axis labels color.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelColor(this::ByRef1{TH1}, color::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetLabelFont(Style_t, Option_t *)
@trydoc raw"""
    SetLabelFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})::Nothing
Set font number used to draw axis labels.
font : Text font code = 10*fontnumber + precision Font numbers must be between 1 and 14 precision = 1 fast hardware fonts (steps in the size) precision = 2 scalable and rotatable hardware fonts

The default font number is 62. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetLabelOffset(Float_t, Option_t *)
@trydoc raw"""
    SetLabelOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})::Nothing
Set offset between axis and axis' labels.
The offset is expressed as a percent of the pad height. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetLabelSize(Float_t, Option_t *)
@trydoc raw"""
    SetLabelSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})::Nothing
Set size of axis' labels.
The size is expressed as a percent of the pad height. axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetLabelSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TH1}, maximum::Float64)::Nothing


""" SetMaximum(this::ByRef1{TH1}, maximum::Float64)

# Wrapper of void TH1::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TH1}, minimum::Float64)::Nothing


""" SetMinimum(this::ByRef1{TH1}, minimum::Float64)

# Wrapper of void TH1::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TH1}, name::ByCopy{String})::Nothing
Change the name of this histogram.

""" SetName(this::ByRef1{TH1}, name::ByCopy{String})

# Wrapper of void TH1::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TH1}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Change the name and title of this histogram.

""" SetNameTitle(this::ByRef1{TH1}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TH1::SetNdivisions(Int_t, Option_t *)
@trydoc raw"""
    SetNdivisions(this::ByRef1{TH1}, n::Int32, axis::ByCopy{String})::Nothing
Set the number of divisions to draw an axis.
ndiv : Number of divisions. 
```
 n = N1 + 100*N2 + 10000*N3
 N1=number of primary divisions.
 N2=number of secondary divisions.
 N3=number of 3rd divisions.
     e.g.:
     nndi=0 --> no tick marks.
     nndi=2 --> 2 divisions, one tick mark in the middle
                of the axis.
```  axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetNdivisions(this::ByRef1{TH1}, n::Int32, axis::ByCopy{String})

# Wrapper of void TH1::SetNormFactor(Double_t)
@trydoc raw"""
    SetNormFactor(this::ByRef1{TH1}, factor::Float64)::Nothing


""" SetNormFactor(this::ByRef1{TH1}, factor::Float64)

# Wrapper of void TH1::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TH1}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TH1}, option::ByCopy{String})

# Wrapper of void TH1::SetStats(Bool_t)
@trydoc raw"""
    SetStats(this::ByRef1{TH1}, stats::Bool)::Nothing
Set statistics option on/off.
By default, the statistics box is drawn. The paint options can be selected via gStyle->SetOptStat. This function sets/resets the kNoStats bit in the histogram object. It has priority over the Style option.
""" SetStats(this::ByRef1{TH1}, stats::Bool)

# Wrapper of void TH1::SetTickLength(Float_t, Option_t *)
@trydoc raw"""
    SetTickLength(this::ByRef1{TH1}, length::Float32, axis::ByCopy{String})::Nothing
Set the axis' tick marks length.
axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetTickLength(this::ByRef1{TH1}, length::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing
Change/set the title.
If title is in the form `stringt;stringx;stringy;stringz` the histogram title is set to `stringt`, the x axis title to `stringx`, the y axis title to `stringy`, and the z axis title to `stringz`.

To insert the character `;` in one of the titles, one should use `#;` or `#semicolon`.
""" SetTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of void TH1::SetTitleFont(Style_t, Option_t *)
@trydoc raw"""
    SetTitleFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})::Nothing
Set the axis' title font.
- if axis =="x" set the X axis title font
- if axis =="y" set the Y axis title font
- if axis =="z" set the Z axis title font any other value of axis will set the pad title font

if axis="xyz" set all 3 axes
""" SetTitleFont(this::ByRef1{TH1}, font::Int16, axis::ByCopy{String})

# Wrapper of void TH1::SetTitleOffset(Float_t, Option_t *)
@trydoc raw"""
    SetTitleOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})::Nothing
Specify a parameter offset to control the distance between the axis and the axis' title.
- offset = 1 means : use the default distance
- offset = 1.2 means: the distance will be 1.2*(default distance)
- offset = 0.8 means: the distance will be 0.8*(default distance)

axis specifies which axis ("x","y","z"), default = "x" if axis="xyz" set all 3 axes
""" SetTitleOffset(this::ByRef1{TH1}, offset::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetTitleSize(Float_t, Option_t *)
@trydoc raw"""
    SetTitleSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})::Nothing
Set the axis' title size.
- if axis = "x" set the X axis title size
- if axis = "y" set the Y axis title size
- if axis = "z" set the Z axis title size

if axis ="xyz" set all 3 axes
""" SetTitleSize(this::ByRef1{TH1}, size::Float32, axis::ByCopy{String})

# Wrapper of void TH1::SetXTitle(const char *)
@trydoc raw"""
    SetXTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing


""" SetXTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of void TH1::SetYTitle(const char *)
@trydoc raw"""
    SetYTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing


""" SetYTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of void TH1::SetZTitle(const char *)
@trydoc raw"""
    SetZTitle(this::ByRef1{TH1}, title::ByCopy{String})::Nothing


""" SetZTitle(this::ByRef1{TH1}, title::ByCopy{String})

# Wrapper of TH1 * TH1::ShowBackground(Int_t, Option_t *)
@trydoc raw"""
    ShowBackground(this::ByRef1{TH1}, niter::Int32, option::ByCopy{String})::CxxPtr1{TH1}
This function calculates the background spectrum in this histogram.
The background is returned as a histogram.

## Arguments

- **`niter`** [in] 
    number of iterations (default value = 2) Increasing niter make the result smoother and lower. 
    
- **`option`** [in] 
    may contain one of the following options
    
    - to set the direction parameter "BackDecreasingWindow". By default the direction is BackIncreasingWindow
    - filterOrder-order of clipping filter (default "BackOrder2") possible values= "BackOrder4" "BackOrder6" "BackOrder8"
    - "nosmoothing" - if selected, the background is not smoothed By default the background is smoothed.
    - smoothWindow - width of smoothing window, (default is "BackSmoothing3") possible values= "BackSmoothing5" "BackSmoothing7" "BackSmoothing9" "BackSmoothing11" "BackSmoothing13" "BackSmoothing15"
    - "nocompton" - if selected the estimation of Compton edge will be not be included (by default the compton estimation is set)
    - "same" if this option is specified, the resulting background histogram is superimposed on the picture in the current pad. This option is given by default.
    
    

NOTE that the background is only evaluated in the current range of this histogram. i.e., if this has a bin range (set via h->[GetXaxis()](@ref)->SetRange(binmin, binmax), the returned histogram will be created with the same number of bins as this input histogram, but only bins from binmin to binmax will be filled with the estimated background.
""" ShowBackground(this::ByRef1{TH1}, niter::Int32, option::ByCopy{String})

# Wrapper of Int_t TH1::ShowPeaks(Double_t, Option_t *, Double_t)
@trydoc raw"""
    ShowPeaks(this::ByRef1{TH1}, sigma::Float64, option::ByCopy{String}, threshold::Float64)::Int32
Interface to [TSpectrum!Search](@ref).
The function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. For more details see [TSpectrum!Search](@ref). Note the difference in the default value for option compared to [TSpectrum!Search](@ref) option="" by default (instead of "goff").
""" ShowPeaks(this::ByRef1{TH1}, sigma::Float64, option::ByCopy{String}, threshold::Float64)

# Wrapper of void TH1::Smooth(Int_t, Option_t *)
@trydoc raw"""
    Smooth(this::ByRef1{TH1}, ntimes::Int32, option::ByCopy{String})::Nothing
Smooth bin contents of this histogram.
if option contains "R" smoothing is applied only to the bins defined in the X axis range (default is to smooth all bins) Bin contents are replaced by their smooth values. Errors (if any) are not modified. the smoothing procedure is repeated ntimes (default=1)
""" Smooth(this::ByRef1{TH1}, ntimes::Int32, option::ByCopy{String})

# Wrapper of void TH1::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TH1}, flag::Bool)::Nothing
Create structure to store sum of squares of weights.
if histogram is already filled, the sum of squares of weights is filled with the existing bin contents

The error per bin will be computed as sqrt(sum of squares of weight) for each bin.

This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag = false the structure containing the sum of the square of weights is rest and it will be empty, but it is not deleted (i.e. [GetSumw2()](@ref)->fN = 0)
""" Sumw2(this::ByRef1{TH1}, flag::Bool)

# Wrapper of void TH1::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TH1})::Nothing
Copy current attributes from/to current style.

""" UseCurrentStyle(this::ByRef1{TH1})

# Wrapper of void TH1::AddDirectory(Bool_t)
@trydoc raw"""
    TH1!AddDirectory(this::ByRef1{TH1}, add::Bool)::Nothing
Sets the flag controlling the automatic add of histograms in memory.
By default (fAddDirectory = kTRUE), histograms are automatically added to the list of objects in memory. Note that one histogram can be removed from its support directory by calling h->SetDirectory(nullptr) or h->SetDirectory(dir) to add it to the list of objects in the directory dir.

NOTE that this is a static function. To call it, use; [TH1!AddDirectory](@ref)
""" TH1!AddDirectory(this::ByRef1{TH1}, add::Bool)

# Wrapper of Bool_t TH1::AddDirectoryStatus()
@trydoc raw"""
    TH1!AddDirectoryStatus(this::ByRef1{TH1})::Bool
Static function: cannot be inlined on Windows/NT.

""" TH1!AddDirectoryStatus(this::ByRef1{TH1})

# Wrapper of Int_t TH1::FitOptionsMake(Option_t *, Foption_t &)
@trydoc raw"""
    TH1!FitOptionsMake(this::ByRef1{TH1}, option::ByCopy{String}, Foption::ByRef1{Foption_t})::Int32
Decode string choptin and fill fitOption structure.

""" TH1!FitOptionsMake(this::ByRef1{TH1}, option::ByCopy{String}, Foption::ByRef1{Foption_t})

# Wrapper of Int_t TH1::GetDefaultBufferSize()
@trydoc raw"""
    TH1!GetDefaultBufferSize(this::ByRef1{TH1})::Int32
Static function return the default buffer size for automatic histograms the parameter fgBufferSize may be changed via SetDefaultBufferSize.

""" TH1!GetDefaultBufferSize(this::ByRef1{TH1})

# Wrapper of Bool_t TH1::GetDefaultSumw2()
@trydoc raw"""
    TH1!GetDefaultSumw2(this::ByRef1{TH1})::Bool
Return kTRUE if [TH1!Sumw2](@ref) must be called when creating new histograms.
see [TH1!SetDefaultSumw2](@ref).
""" TH1!GetDefaultSumw2(this::ByRef1{TH1})

# Wrapper of void TH1::SetDefaultBufferSize(Int_t)
@trydoc raw"""
    TH1!SetDefaultBufferSize(this::ByRef1{TH1}, buffersize::Int32)::Nothing
Static function to set the default buffer size for automatic histograms.
When a histogram is created with one of its axis lower limit greater or equal to its upper limit, the function SetBuffer is automatically called with the default buffer size.
""" TH1!SetDefaultBufferSize(this::ByRef1{TH1}, buffersize::Int32)

# Wrapper of void TH1::SetDefaultSumw2(Bool_t)
@trydoc raw"""
    TH1!SetDefaultSumw2(this::ByRef1{TH1}, sumw2::Bool)::Nothing
When this static function is called with `sumw2=kTRUE`, all new histograms will automatically activate the storage of the sum of squares of errors, ie [TH1!Sumw2](@ref) is automatically called.

""" TH1!SetDefaultSumw2(this::ByRef1{TH1}, sumw2::Bool)

# Wrapper of void TH1::SmoothArray(Int_t, Double_t *, Int_t)
@trydoc raw"""
    TH1!SmoothArray(this::ByRef1{TH1}, NN::Int32, XX::ByPtr2{Float64}, ntimes::Int32)::Nothing
Smooth array xx, translation of Hbook routine `hsmoof.F`.
Based on algorithm 353QH twice presented by J. Friedman in [Proc. of the 1974 CERN School of Computing, Norway, 11-24 August, 1974](https://cds.cern.ch/record/186223). See also Section 4.2 in [J. Friedman, Data Analysis Techniques for High Energy Physics](https://www.slac.stanford.edu/pubs/slacreports/reports16/slac-r-176.pdf).
""" TH1!SmoothArray(this::ByRef1{TH1}, NN::Int32, XX::ByPtr2{Float64}, ntimes::Int32)

# Wrapper of void TH1::StatOverflows(Bool_t)
@trydoc raw"""
    TH1!StatOverflows(this::ByRef1{TH1}, flag::Bool)::Nothing
if flag=kTRUE, underflows and overflows are used by the Fill functions in the computation of statistics (mean value, StdDev).
By default, underflows or overflows are not used.
""" TH1!StatOverflows(this::ByRef1{TH1}, flag::Bool)

# Wrapper of void TPrincipal::AddRow(const Double_t *)
@trydoc raw"""
    AddRow(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64})::Nothing
Add a data point and update the covariance matrix.
The input array must be `fNumberOfVariables` long.

The Covariance matrix and mean values of the input data is calculated on the fly by the following equations:

``\left<x_i\right>^{(0)}  = x_{i0}``

``\left<x_i\right>^{(n)} = \left<x_i\right>^{(n-1)}
+ \frac1n \left(x_{in} - \left<x_i\right>^{(n-1)}\right)``

``C_{ij}^{(0)} = 0``

``C_{ij}^{(n)} = C_{ij}^{(n-1)}
+ \frac1{n-1}\left[\left(x_{in} - \left<x_i\right>^{(n)}\right)
  \left(x_{jn} - \left<x_j\right>^{(n)}\right)\right]
- \frac1n C_{ij}^{(n-1)}``

since this is a really fast method, with no rounding errors (please refer to CERN 72-21 pp. 54-106).

The data is stored internally in a `TVectorD`, in the following way:

``\mathbf{x} = \left[\left(x_{0_0},\ldots,x_{{P-1}_0}\right),\ldots,
    \left(x_{0_i},\ldots,x_{{P-1}_i}\right), \ldots\right]``

With $P$ as defined in the class description.
""" AddRow(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64})

# Wrapper of void TPrincipal::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TPrincipal}, b::ByPtr1{TBrowser})::Nothing
Browse the [TPrincipal](@ref) object in the [TBrowser](@ref).

""" Browse(this::ByRef1{TPrincipal}, b::ByPtr1{TBrowser})

# Wrapper of void TPrincipal::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TPrincipal}, option::ByCopy{String})::Nothing
Clear the data in Object.
Notice, that's not possible to change the dimension of the original data.
""" Clear(this::ByRef1{TPrincipal}, option::ByCopy{String})

# Wrapper of const TMatrixD * TPrincipal::GetCovarianceMatrix()
@trydoc raw"""
    GetCovarianceMatrix(this::ByConstRef1{TPrincipal})::ConstCxxPtr1{TMatrixD}
Return the covariance matrix.
###Note

Only the lower diagonal of the covariance matrix is computed by the class
""" GetCovarianceMatrix(this::ByConstRef1{TPrincipal})

# Wrapper of const TVectorD * TPrincipal::GetEigenValues()
@trydoc raw"""
    GetEigenValues(this::ByConstRef1{TPrincipal})::ConstCxxPtr1{TVectorD}


""" GetEigenValues(this::ByConstRef1{TPrincipal})

# Wrapper of const TMatrixD * TPrincipal::GetEigenVectors()
@trydoc raw"""
    GetEigenVectors(this::ByConstRef1{TPrincipal})::ConstCxxPtr1{TMatrixD}


""" GetEigenVectors(this::ByConstRef1{TPrincipal})

# Wrapper of TList * TPrincipal::GetHistograms()
@trydoc raw"""
    GetHistograms(this::ByConstRef1{TPrincipal})::CxxPtr1{TList}


""" GetHistograms(this::ByConstRef1{TPrincipal})

# Wrapper of const TVectorD * TPrincipal::GetMeanValues()
@trydoc raw"""
    GetMeanValues(this::ByConstRef1{TPrincipal})::ConstCxxPtr1{TVectorD}


""" GetMeanValues(this::ByConstRef1{TPrincipal})

# Wrapper of const Double_t * TPrincipal::GetRow(Long64_t)
@trydoc raw"""
    GetRow(this::ByRef1{TPrincipal}, row::Int64)::ConstCxxPtr2{Float64}
Return a row of the user supplied data.
If row is out of bounds, 0 is returned. It's up to the user to delete the returned array. Row 0 is the first row;
""" GetRow(this::ByRef1{TPrincipal}, row::Int64)

# Wrapper of const TVectorD * TPrincipal::GetSigmas()
@trydoc raw"""
    GetSigmas(this::ByConstRef1{TPrincipal})::ConstCxxPtr1{TVectorD}


""" GetSigmas(this::ByConstRef1{TPrincipal})

# Wrapper of const TVectorD * TPrincipal::GetUserData()
@trydoc raw"""
    GetUserData(this::ByConstRef1{TPrincipal})::ConstCxxPtr1{TVectorD}


""" GetUserData(this::ByConstRef1{TPrincipal})

# Wrapper of Bool_t TPrincipal::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TPrincipal})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TPrincipal})

# Wrapper of void TPrincipal::MakeCode(const char *, Option_t *)
@trydoc raw"""
    MakeCode(this::ByRef1{TPrincipal}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Generates the file `<filename>`, with `.C` appended if it does argument doesn't theend in .cxx or .C.
The file contains the implementation of two functions 

    void X2P(Double_t *x, Double *p)
    void P2X(Double_t *p, Double *x, Int_t nTest)

(C++ version of the code)

 which does the same as `TPrincipal!X2P` and `TPrincipal!P2X` respectively. Please refer to these methods.

Further, the static variables: 

    Int_t    gNVariables
    Double_t gEigenValues[]
    Double_t gEigenVectors[]
    Double_t gMeanValues[]
    Double_t gSigmaValues[]

(C++ version of the code)

 are initialized. The only [ROOT](@ref) header file needed is Rtypes.h

See [TPrincipal!MakeRealCode](@ref) for a list of options
""" MakeCode(this::ByRef1{TPrincipal}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TPrincipal::MakeHistograms(const char *, Option_t *)
@trydoc raw"""
    MakeHistograms(this::ByRef1{TPrincipal}, name::ByCopy{String}, option::ByCopy{String})::Nothing
Make histograms of the result of the analysis.
The option string say which histograms to create

- X Histogram original data
- P Histogram principal components corresponding to original data
- D Histogram the difference between the original data and the projection of principal unto a lower dimensional subspace (2D histograms)
- E Histogram the eigenvalues
- S Histogram the square of the residues (see `TPrincipal!SumOfSquareResiduals`) The histograms will be named `<name>_<type><number>`, where `<name>` is the first argument, `<type>` is one of X,P,D,E,S, and `<number>` is the variable.
""" MakeHistograms(this::ByRef1{TPrincipal}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TPrincipal::MakeMethods(const char *, Option_t *)
@trydoc raw"""
    MakeMethods(this::ByRef1{TPrincipal}, classname::ByCopy{String}, option::ByCopy{String})::Nothing
Generate the file `<classname>PCA.cxx` which contains the implementation of two methods:
void <classname>!X2P(Double_t *x, Double *p)
    void <classname>!P2X(Double_t *p, Double *x, Int_t nTest)

(C++ version of the code)

 which does the same as [TPrincipal!X2P](@ref) and [TPrincipal!P2X](@ref) respectively. Please refer to these methods.

Further, the public static members: 

    Int_t    <classname>!fgNVariables
    Double_t <classname>!fgEigenValues[]
    Double_t <classname>!fgEigenVectors[]
    Double_t <classname>!fgMeanValues[]
    Double_t <classname>!fgSigmaValues[]

(C++ version of the code)

 are initialized, and assumed to exist. The class declaration is assumed to be in `<classname>.h` and assumed to be provided by the user.

See [TPrincipal!MakeRealCode](@ref) for a list of options

The minimal class definition is: 

    class <classname> {
    public:
      static Int_t    fgNVariables;
      static Double_t fgEigenVectors[];
      static Double_t fgEigenValues[];
      static Double_t fgMeanValues[];
      static Double_t fgSigmaValues[];
      void X2P(Double_t *x, Double_t *p);
      void P2X(Double_t *p, Double_t *x, Int_t nTest);
    };

(C++ version of the code)

 Whether the methods `<classname>!X2P` and `<classname>!P2X` should be static or not, is up to the user.
""" MakeMethods(this::ByRef1{TPrincipal}, classname::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TPrincipal::MakePrincipals()
@trydoc raw"""
    MakePrincipals(this::ByRef1{TPrincipal})::Nothing
Perform the principal components analysis.
This is done in several stages in the [TMatrix!EigenVectors](@ref) method:

- Transform the covariance matrix into a tridiagonal matrix.
- Find the eigenvalues and vectors of the tridiagonal matrix.
""" MakePrincipals(this::ByRef1{TPrincipal})

# Wrapper of void TPrincipal::P2X(const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    P2X(this::ByRef1{TPrincipal}, p::ByConstPtr2{Float64}, x::ByPtr2{Float64}, nTest::Int32)::Nothing
Calculate x as a function of nTest of the most significant principal components p, and return it in x.
It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for x).
""" P2X(this::ByRef1{TPrincipal}, p::ByConstPtr2{Float64}, x::ByPtr2{Float64}, nTest::Int32)

# Wrapper of void TPrincipal::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TPrincipal}, opt::ByCopy{String})::Nothing
Print the statistics Options are.
- M Print mean values of original data
- S Print sigma values of original data
- E Print eigenvalues of covariance matrix
- V Print eigenvectors of covariance matrix Default is MSE
""" Print(this::ByConstRef1{TPrincipal}, opt::ByCopy{String})

# Wrapper of void TPrincipal::SumOfSquareResiduals(const Double_t *, Double_t *)
@trydoc raw"""
    SumOfSquareResiduals(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, s::ByPtr2{Float64})::Nothing
Calculates the sum of the square residuals, that is.
``E_N = \sum_{i=0}^{P-1} \left(x_i - x^\prime_i\right)^2``

where $x^\prime_i = \sum_{j=i}^N p_i e_{n_j}$ is the $i^{\mbox{th}}$ component of the principal vector, corresponding to $x_i$, the original data; I.e., the square distance to the space spanned by $N$ eigenvectors.
""" SumOfSquareResiduals(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, s::ByPtr2{Float64})

# Wrapper of void TPrincipal::Test(Option_t *)
@trydoc raw"""
    Test(this::ByRef1{TPrincipal}, option::ByCopy{String})::Nothing
Test the PCA, bye calculating the sum square of residuals (see method SumOfSquareResiduals), and display the histogram.

""" Test(this::ByRef1{TPrincipal}, option::ByCopy{String})

# Wrapper of void TPrincipal::X2P(const Double_t *, Double_t *)
@trydoc raw"""
    X2P(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, p::ByPtr2{Float64})::Nothing
Calculate the principal components from the original data vector x, and return it in p.
It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for p).
""" X2P(this::ByRef1{TPrincipal}, x::ByConstPtr2{Float64}, p::ByPtr2{Float64})

# Wrapper of const TCollection * TTreeFriendLeafIter::GetCollection()
@trydoc raw"""
    GetCollection(this::ByConstRef1{TTreeFriendLeafIter})::ConstCxxPtr1{TCollection}


""" GetCollection(this::ByConstRef1{TTreeFriendLeafIter})

# Wrapper of Option_t * TTreeFriendLeafIter::GetOption()
@trydoc raw"""
    GetOption(this::ByConstRef1{TTreeFriendLeafIter})::ByCopy{String}
Returns the object option stored in the list.

""" GetOption(this::ByConstRef1{TTreeFriendLeafIter})

# Wrapper of TObject * TTreeFriendLeafIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TTreeFriendLeafIter})::CxxPtr1{TObject}
Go the next friend element.

""" Next(this::ByRef1{TTreeFriendLeafIter})

# Wrapper of bool TTreeFriendLeafIter::operator!=(const TIterator &)
@trydoc raw"""
    Base.:(!=)(this::ByConstRef1{TTreeFriendLeafIter}, ::ByConstRef1{TIterator})::Bool
Compare two iterator objects.
For backward compatibility reasons we have to provide this default implementation.
""" Base.:(!=)(this::ByConstRef1{TTreeFriendLeafIter}, ::ByConstRef1{TIterator})

# Wrapper of bool TTreeFriendLeafIter::operator!=(const TTreeFriendLeafIter &)
@trydoc raw"""
    Base.:(!=)(this::ByConstRef1{TTreeFriendLeafIter}, ::ByConstRef1{TTreeFriendLeafIter})::Bool


""" Base.:(!=)(this::ByConstRef1{TTreeFriendLeafIter}, ::ByConstRef1{TTreeFriendLeafIter})

# Wrapper of TObject * TTreeFriendLeafIter::operator*()
@trydoc raw"""
    Base.getindex(this::ByConstRef1{TTreeFriendLeafIter})::CxxPtr1{TObject}
Return current object or nullptr.
For backward compatibility reasons we have to provide this default implementation.
""" Base.getindex(this::ByConstRef1{TTreeFriendLeafIter})

# Wrapper of TIterator & TTreeFriendLeafIter::operator=(const TIterator &)
@trydoc raw"""
    assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TIterator})::CxxRef1{TIterator}
Overridden assignment operator. Does NOT copy the 'cursor' location!

""" assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TIterator})

# Wrapper of TTreeFriendLeafIter & TTreeFriendLeafIter::operator=(const TTreeFriendLeafIter &)
@trydoc raw"""
    assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TTreeFriendLeafIter})::CxxRef1{TTreeFriendLeafIter}
Overridden assignment operator. Does NOT copy the 'cursor' location!

""" assign(this::ByRef1{TTreeFriendLeafIter}, rhs::ByConstRef1{TTreeFriendLeafIter})

# Wrapper of void TTreeFriendLeafIter::Reset()
@trydoc raw"""
    Reset(this::ByRef1{TTreeFriendLeafIter})::Nothing


""" Reset(this::ByRef1{TTreeFriendLeafIter})

# Wrapper of Long64_t TTreeReader::GetCurrentEntry()
@trydoc raw"""
    GetCurrentEntry(this::ByConstRef1{TTreeReader})::Int64
Returns the index of the current entry being read.
If `IsChain()`, the returned index corresponds to the global_ entry number (i.e. not the entry number local_ to the chain's current tree). If `fEntryList`, the returned index corresponds to an index in the [TEntryList](@ref); to translate to the [TChain](@ref)'s / [TTree](@ref)'s entry number pass it through `reader.GetEntryList()->GetEntry(reader.GetCurrentEntry())`.
""" GetCurrentEntry(this::ByConstRef1{TTreeReader})

# Wrapper of Long64_t TTreeReader::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{TTreeReader})::Int64
Returns the number of entries of the [TEntryList](@ref) if one is provided, else of the [TTree](@ref) / [TChain](@ref), independent of a range set by [SetEntriesRange()](@ref) by calling TTree/TChain!GetEntriesFast.
""" GetEntries(this::ByConstRef1{TTreeReader})

# Wrapper of Long64_t TTreeReader::GetEntries(bool)
@trydoc raw"""
    GetEntries(this::ByRef1{TTreeReader}, force::Bool)::Int64
Returns the number of entries of the [TEntryList](@ref) if one is provided, else of the [TTree](@ref) / [TChain](@ref), independent of a range set by [SetEntriesRange()](@ref).
## Arguments

- **`force`** 
    If `IsChain()` and `force`, determines whether all TFiles of this [TChain](@ref) should be opened to determine the exact number of entries of the [TChain](@ref). If `!IsChain()`, `force` is ignored.
""" GetEntries(this::ByRef1{TTreeReader}, force::Bool)

# Wrapper of TEntryList * TTreeReader::GetEntryList()
@trydoc raw"""
    GetEntryList(this::ByConstRef1{TTreeReader})::CxxPtr1{TEntryList}


""" GetEntryList(this::ByConstRef1{TTreeReader})

# Wrapper of TTree * TTreeReader::GetTree()
@trydoc raw"""
    GetTree(this::ByConstRef1{TTreeReader})::CxxPtr1{TTree}


""" GetTree(this::ByConstRef1{TTreeReader})

# Wrapper of bool TTreeReader::IsChain()
@trydoc raw"""
    IsChain(this::ByConstRef1{TTreeReader})::Bool


""" IsChain(this::ByConstRef1{TTreeReader})

# Wrapper of bool TTreeReader::IsInvalid()
@trydoc raw"""
    IsInvalid(this::ByConstRef1{TTreeReader})::Bool


""" IsInvalid(this::ByConstRef1{TTreeReader})

# Wrapper of bool TTreeReader::Notify()
@trydoc raw"""
    Notify(this::ByRef1{TTreeReader})::Bool
Notify director and values of a change in tree.
Called from [TChain](@ref) and [TTree](@ref)'s LoadTree. [TTreeReader](@ref) registers its fNotify data member with the TChain/TTree which in turn leads to this method being called upon the execution of LoadTree.
""" Notify(this::ByRef1{TTreeReader})

# Wrapper of void TTreeReader::SetTree(const char *, TDirectory *, TEntryList *)
@trydoc raw"""
    SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, dir::ByPtr1{TDirectory}, entryList::ByPtr1{TEntryList})::Nothing
Set (or update) the which tree to read from, passing the name of a tree in a directory.
## Arguments

- **`keyname`** 
    - name of the tree in `dir` 
    
- **`dir`** 
    - the `TDirectory` to load `keyname` from (or gDirectory if `nullptr`) 
    
- **`entryList`** 
    - the `TEntryList` to attach to the `TTreeReader`.
""" SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, dir::ByPtr1{TDirectory}, entryList::ByPtr1{TEntryList})

# Wrapper of void TTreeReader::SetTree(const char *, TEntryList *)
@trydoc raw"""
    SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, entryList::ByPtr1{TEntryList})::Nothing


""" SetTree(this::ByRef1{TTreeReader}, keyname::ByCopy{String}, entryList::ByPtr1{TEntryList})

# Wrapper of void TTreeReader::SetTree(TTree *, TEntryList *)
@trydoc raw"""
    SetTree(this::ByRef1{TTreeReader}, tree::ByPtr1{TTree}, entryList::ByPtr1{TEntryList})::Nothing
Set (or update) the which tree to read from.
`tree` can be a [TTree](@ref) or a [TChain](@ref).
""" SetTree(this::ByRef1{TTreeReader}, tree::ByPtr1{TTree}, entryList::ByPtr1{TEntryList})

# Wrapper of T * TTreeReaderValue::Get()
@trydoc raw"""
    Get(this::ByRef1{TTreeReaderValue})::CxxPtr1{T}
Return a pointer to the value of the current entry.
Return a nullptr and print an error if no entry has been loaded yet. The returned address is guaranteed to stay constant while a given [TTree](@ref) is being read from a given file, unless the branch addresses are manipulated directly (e.g. through [TTree!SetBranchAddress()](@ref)). The address might also change when the underlying TTree/TFile is switched, e.g. when a [TChain](@ref) switches files.
""" Get(this::ByRef1{TTreeReaderValue})

# Wrapper of T & TTreeReaderValue::operator*()
@trydoc raw"""
    Base.getindex(this::ByRef1{TTreeReaderValue})::CxxRef1{T}
Return a reference to the value of the current entry.
Equivalent to dereferencing the pointer returned by [Get()](@ref). Behavior is undefined if no entry has been loaded yet. Most likely a crash will occur.
""" Base.getindex(this::ByRef1{TTreeReaderValue})

# Wrapper of T * TTreeReaderValue::operator->()
@trydoc raw"""
    arrow(this::ByRef1{TTreeReaderValue})::CxxPtr1{T}
Return a pointer to the value of the current entry.
Equivalent to [Get()](@ref).
""" arrow(this::ByRef1{TTreeReaderValue})

# Wrapper of Int_t TRandom::Binomial(Int_t, Double_t)
@trydoc raw"""
    Binomial(this::ByRef1{TRandom}, ntot::Int32, prob::Float64)::Int32
Generates a random integer N according to the binomial law.
Coded from Los Alamos report LA-5061-MS.

N is binomially distributed between 0 and ntot inclusive with mean prob*ntot and prob is between 0 and 1.

Note: This function should not be used when ntot is large (say >100). The normal approximation is then recommended instead (with mean =*ntot+0.5 and standard deviation sqrt(ntot*prob*(1-prob)).
""" Binomial(this::ByRef1{TRandom}, ntot::Int32, prob::Float64)

# Wrapper of Double_t TRandom::BreitWigner(Double_t, Double_t)
@trydoc raw"""
    BreitWigner(this::ByRef1{TRandom}, mean::Float64, gamma::Float64)::Float64
Return a number distributed following a BreitWigner function with mean and gamma.

""" BreitWigner(this::ByRef1{TRandom}, mean::Float64, gamma::Float64)

# Wrapper of void TRandom::Circle(Double_t &, Double_t &, Double_t)
@trydoc raw"""
    Circle(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, r::Float64)::Nothing
Generates random vectors, uniformly distributed over a circle of given radius.
Input : r = circle radius Output: x,y a random 2-d vector of length r
""" Circle(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, r::Float64)

# Wrapper of Double_t TRandom::Exp(Double_t)
@trydoc raw"""
    Exp(this::ByRef1{TRandom}, tau::Float64)::Float64
Returns an exponential deviate.
```
     exp( -t/tau ) 
```
""" Exp(this::ByRef1{TRandom}, tau::Float64)

# Wrapper of Double_t TRandom::Gaus(Double_t, Double_t)
@trydoc raw"""
    Gaus(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)::Float64
Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigma.
Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger This is one of the fastest existing method for generating normal random variables. It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous version of [TRandom!Gaus](@ref). The speed is comparable to the Ziggurat method (from Marsaglia) implemented for example in GSL and available in the MathMore library.

REFERENCE: - W. Hoermann and G. Derflinger (1990): The ACR Method for generating normal random variables, OR Spektrum 12 (1990), 181-185.

Implementation taken from UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien
""" Gaus(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)

# Wrapper of UInt_t TRandom::GetSeed()
@trydoc raw"""
    GetSeed(this::ByConstRef1{TRandom})::UInt32
Get the random generator seed.
###Warning

Might not be the initial seed!

Note that this function returns the given seed only when using as random generator engine [TRandom](@ref) itself, which is an LCG generator and it has as seed (state) only one 32 bit word. In case of the other generators GetSeed will return one of the state elements and not the given seed. See the documentation of the corresponding generator used (for example [TRandom3!GetSeed()](@ref) when using [TRandom3](@ref) or gRandom. If one needs to save the generator seed in order to be used later for obtaining reproducible numbers, one should store the full generator, either in a file or in memory in a separate [TRandom](@ref) object. Here is an example on how to store reproducible states: 

    // set a unique seed
     gRandom->SetSeed(0);
     // save generator state in a different TRandom instance
     TRandom* rngSaved = static_cast<TRandom*>(gRandom->Clone());
     // now both rngSaved and gRandom will produce the same sequence of numbers
     for (int i = 0; i < 10; ++i )
        std!cout << "generated number from gRandom : " << gRandom->Rndm() << "  from saved generator " <<
        rngSaved->Rndm() << std!endl;

(C++ version of the code)
""" GetSeed(this::ByConstRef1{TRandom})

# Wrapper of UInt_t TRandom::Integer(UInt_t)
@trydoc raw"""
    Integer(this::ByRef1{TRandom}, imax::UInt32)::UInt32
Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].
Note that the interval contains the values of 0 and imax-1 but not imax.
""" Integer(this::ByRef1{TRandom}, imax::UInt32)

# Wrapper of Double_t TRandom::Landau(Double_t, Double_t)
@trydoc raw"""
    Landau(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)::Float64
Generate a random number following a Landau distribution with location parameter mu and scale parameter sigma: Landau( (x-mu)/sigma ) Note that mu is not the mpv(most probable value) of the Landa distribution and sigma is not the standard deviation of the distribution which is not defined.
For mu =0 and sigma=1, the mpv = -0.22278

The Landau random number generation is implemented using the function landau_quantile(x,sigma), which provides the inverse of the landau cumulative distribution. landau_quantile has been converted from CERNLIB ranlan(G110).
""" Landau(this::ByRef1{TRandom}, mean::Float64, sigma::Float64)

# Wrapper of ULong64_t TRandom::Poisson(Double_t)
@trydoc raw"""
    Poisson(this::ByRef1{TRandom}, mean::Float64)::UInt64
Generates a random integer N according to a Poisson law.
Prob(N) = exp(-mean)*mean^N/Factorial(N)

Use a different procedure according to the mean value. The algorithm is the same used by CLHEP. For lower value (mean < 25) use the rejection method based on the exponential. For higher values use a rejection method comparing with a Lorentzian distribution, as suggested by several authors. This routine returns now an unsigned 64 bit integer For large values, larger than 1.84e+19, we print an error message advising to use the Trandom!PoissonD for such large values, and return the max value UINT64_MAX
""" Poisson(this::ByRef1{TRandom}, mean::Float64)

# Wrapper of Double_t TRandom::PoissonD(Double_t)
@trydoc raw"""
    PoissonD(this::ByRef1{TRandom}, mean::Float64)::Float64
Generates a random number according to a Poisson law.
Prob(N) = exp(-mean)*mean^N/Factorial(N)

This function is a variant of [TRandom!Poisson](@ref) returning a double instead of an integer.
""" PoissonD(this::ByRef1{TRandom}, mean::Float64)

# Wrapper of void TRandom::Rannor(Double_t &, Double_t &)
@trydoc raw"""
    Rannor(this::ByRef1{TRandom}, a::ByRef2{Float64}, b::ByRef2{Float64})::Nothing
Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.

""" Rannor(this::ByRef1{TRandom}, a::ByRef2{Float64}, b::ByRef2{Float64})

# Wrapper of void TRandom::Rannor(Float_t &, Float_t &)
@trydoc raw"""
    Rannor(this::ByRef1{TRandom}, a::ByRef2{Float32}, b::ByRef2{Float32})::Nothing
Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.

""" Rannor(this::ByRef1{TRandom}, a::ByRef2{Float32}, b::ByRef2{Float32})

# Wrapper of void TRandom::ReadRandom(const char *)
@trydoc raw"""
    ReadRandom(this::ByRef1{TRandom}, filename::ByCopy{String})::Nothing
Reads saved random generator status from filename.

""" ReadRandom(this::ByRef1{TRandom}, filename::ByCopy{String})

# Wrapper of Double_t TRandom::Rndm()
@trydoc raw"""
    Rndm(this::ByRef1{TRandom})::Float64
Machine independent random number generator.
Based on the BSD Unix (Rand) Linear congruential generator. Produces uniformly-distributed floating points between 0 and 1. Identical sequence on all machines of >= 32 bits. Periodicity = 2**31, generates a number in (0,1). Note that this is a generator which is known to have defects (the lower random bits are correlated) and therefore should NOT be used in any statistical study).
""" Rndm(this::ByRef1{TRandom})

# Wrapper of Double_t TRandom::Rndm(Int_t)
@trydoc raw"""
    Rndm(this::ByRef1{TRandom}, ::Int32)::Float64


""" Rndm(this::ByRef1{TRandom}, ::Int32)

# Wrapper of void TRandom::RndmArray(Int_t, Double_t *)
@trydoc raw"""
    RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float64})::Nothing
Return an array of n random numbers uniformly distributed in ]0,1].

""" RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float64})

# Wrapper of void TRandom::RndmArray(Int_t, Float_t *)
@trydoc raw"""
    RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float32})::Nothing
Return an array of n random numbers uniformly distributed in ]0,1].

""" RndmArray(this::ByRef1{TRandom}, n::Int32, array::ByPtr2{Float32})

# Wrapper of void TRandom::SetSeed(ULong_t)
@trydoc raw"""
    SetSeed(this::ByRef1{TRandom}, seed::UInt64)::Nothing
Set the random generator seed.
Note that default value is zero, which is different than the default value used when constructing the class. If the seed is zero the seed is set to a random value which in case of [TRandom](@ref) depends on the lowest 4 bytes of [TUUID](@ref) The UUID will be identical if SetSeed(0) is called with time smaller than 100 ns Instead if a different generator implementation is used ([TRandom1](@ref), 2 or 3) the seed is generated using a 128 bit UUID. This results in different seeds and then random sequence for every SetSeed(0) call.
""" SetSeed(this::ByRef1{TRandom}, seed::UInt64)

# Wrapper of void TRandom::Sphere(Double_t &, Double_t &, Double_t &, Double_t)
@trydoc raw"""
    Sphere(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, r::Float64)::Nothing
Generates random vectors, uniformly distributed over the surface of a sphere of given radius.
Input : r = sphere radius Output: x,y,z a random 3-d vector of length r Method: (based on algorithm suggested by Knuth and attributed to Robert E Knop) which uses less random numbers than the CERNLIB RN23DIM algorithm
""" Sphere(this::ByRef1{TRandom}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, r::Float64)

# Wrapper of Double_t TRandom::Uniform(Double_t, Double_t)
@trydoc raw"""
    Uniform(this::ByRef1{TRandom}, x1::Float64, x2::Float64)::Float64
Returns a uniform deviate on the interval (x1, x2).

""" Uniform(this::ByRef1{TRandom}, x1::Float64, x2::Float64)

# Wrapper of Double_t TRandom::Uniform(Double_t)
@trydoc raw"""
    Uniform(this::ByRef1{TRandom}, x1::Float64)::Float64
Returns a uniform deviate on the interval (0, x1).

""" Uniform(this::ByRef1{TRandom}, x1::Float64)

# Wrapper of void TRandom::WriteRandom(const char *)
@trydoc raw"""
    WriteRandom(this::ByConstRef1{TRandom}, filename::ByCopy{String})::Nothing
Writes random generator status to filename.

""" WriteRandom(this::ByConstRef1{TRandom}, filename::ByCopy{String})

# Wrapper of void TDirectoryFile::Add(TObject *, Bool_t)
@trydoc raw"""
    Add(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)::Nothing


""" Add(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of void TDirectoryFile::Append(TObject *, Bool_t)
@trydoc raw"""
    Append(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)::Nothing
Append object to this directory.
If replace is true: remove any existing objects with the same same (if the name is not ""
""" Append(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, replace::Bool)

# Wrapper of Int_t TDirectoryFile::AppendKey(TKey *)
@trydoc raw"""
    AppendKey(this::ByRef1{TDirectoryFile}, key::ByPtr1{TKey})::Int32
Insert key in the linked list of keys of this directory.

""" AppendKey(this::ByRef1{TDirectoryFile}, key::ByPtr1{TKey})

# Wrapper of void TDirectoryFile::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TDirectoryFile}, b::ByPtr1{TBrowser})::Nothing
Browse the content of the directory.

""" Browse(this::ByRef1{TDirectoryFile}, b::ByPtr1{TBrowser})

# Wrapper of void TDirectoryFile::Build(TFile *, TDirectory *)
@trydoc raw"""
    Build(this::ByRef1{TDirectoryFile}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})::Nothing


""" Build(this::ByRef1{TDirectoryFile}, motherFile::ByPtr1{TFile}, motherDir::ByPtr1{TDirectory})

# Wrapper of Bool_t TDirectoryFile::cd()
@trydoc raw"""
    cd(this::ByRef1{TDirectoryFile})::Bool
Change current directory to "this" directory.
Returns kTRUE in case of success.
""" cd(this::ByRef1{TDirectoryFile})

# Wrapper of Bool_t TDirectoryFile::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TDirectoryFile}, path::ByCopy{String})::Bool
Change current directory the directory described by the path if given one.
change the current directory to "path". The absolute path syntax is: 
```
file.root:/dir1/dir2
```  where file.root is the file and /dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to "this" directory. E.g: ../aa. Returns kTRUE in case of success.
""" cd(this::ByRef1{TDirectoryFile}, path::ByCopy{String})

# Wrapper of TObject * TDirectoryFile::CloneObject(const TObject *, Bool_t)
@trydoc raw"""
    CloneObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, autoadd::Bool)::CxxPtr1{TObject}
Make a clone of an object using the Streamer facility.
If the object derives from [TNamed](@ref), this function is called by [TNamed!Clone](@ref). [TNamed!Clone](@ref) uses the optional argument newname to set a new name to the newly created object.

If autoadd is true and if the object class has a DirectoryAutoAdd function, it will be called at the theend of the function with the parameter gDirectory. This usually means that the object will be appended to the current [ROOT](@ref) directory.
""" CloneObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, autoadd::Bool)

# Wrapper of void TDirectoryFile::Close(Option_t *)
@trydoc raw"""
    Close(this::ByRef1{TDirectoryFile}, option::ByCopy{String})::Nothing
Delete all objects from memory and directory structure itself.

""" Close(this::ByRef1{TDirectoryFile}, option::ByCopy{String})

# Wrapper of void TDirectoryFile::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TDirectoryFile}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TDirectoryFile}, object::ByRef1{TObject})

# Wrapper of void TDirectoryFile::Delete(const char *)
@trydoc raw"""
    Delete(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})::Nothing
Delete Objects or/and keys in a directory.
Properties of the namecycle string:

- namecycle has the format name;cycle
- namecycle = "" is same as namecycle ="T*"
- name = * means all
- cycle = * means all cycles (memory and keys)
- cycle = "" or cycle = 9999 ==> apply to a memory object When name=* use T* to delete subdirectories also

To delete one directory, you must specify the directory cycle, eg. file.Delete("dir1;1");

Examples: 
| **[Pattern](@ref)** | **Description**                                                |
|:--------------------|:---------------------------------------------------------------|
| foo                 | delete object named foo in memory                              |
| foo*                | delete all objects with a name starting with foo               |
| foo;1               | delete cycle 1 of foo on file                                  |
| foo;*               | delete all cycles of foo on file and also from memory          |
| *;2                 | delete all objects on file having the cycle 2                  |
| *;*                 | delete all objects from memory and file                        |
| T*;*                | delete all objects from memory and file and all subdirectories |

## WARNING

If the key to be deleted contains special characters ("+","^","?", etc that have a special meaning for the regular expression parser (see [TRegexp](@ref)) then you must specify 2 backslash characters to escape the regular expression. For example, if the key to be deleted is namecycle = "C++", you must call 
```
mydir.Delete("C\\+\\+"));
```
""" Delete(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})

# Wrapper of void TDirectoryFile::FillBuffer(char *&)
@trydoc raw"""
    FillBuffer(this::ByRef1{TDirectoryFile}, buffer::ByPtr2{Int8})::Nothing
Encode directory header into output buffer.

""" FillBuffer(this::ByRef1{TDirectoryFile}, buffer::ByPtr2{Int8})

# Wrapper of TKey * TDirectoryFile::FindKey(const char *)
@trydoc raw"""
    FindKey(this::ByConstRef1{TDirectoryFile}, keyname::ByCopy{String})::CxxPtr1{TKey}
Find key with name `keyname` in the current directory.
`keyname` may be of the form name;cycle. See [GetKey()](@ref) for details on the semantics of this form.
""" FindKey(this::ByConstRef1{TDirectoryFile}, keyname::ByCopy{String})

# Wrapper of TKey * TDirectoryFile::FindKeyAny(const char *)
@trydoc raw"""
    FindKeyAny(this::ByConstRef1{TDirectoryFile}, keyname::ByCopy{String})::CxxPtr1{TKey}
Find key with name `keyname` in the current directory or its subdirectories.
`keyname` may be of the form name;cycle. See [GetKey()](@ref) for details on the semantics of this form.

NOTE: that If a key is found, the directory containing the key becomes the current directory
""" FindKeyAny(this::ByConstRef1{TDirectoryFile}, keyname::ByCopy{String})

# Wrapper of TObject * TDirectoryFile::FindObjectAny(const char *)
@trydoc raw"""
    FindObjectAny(this::ByConstRef1{TDirectoryFile}, name::ByCopy{String})::CxxPtr1{TObject}
Find object by name in the list of memory objects of the current directory or its sub-directories.
After this call the current directory is not changed. To automatically set the current directory where the object is found, use FindKeyAny(aname)->ReadObj().
""" FindObjectAny(this::ByConstRef1{TDirectoryFile}, name::ByCopy{String})

# Wrapper of TObject * TDirectoryFile::FindObjectAnyFile(const char *)
@trydoc raw"""
    FindObjectAnyFile(this::ByConstRef1{TDirectoryFile}, name::ByCopy{String})::CxxPtr1{TObject}
Scan the memory lists of all files for an object with name.

""" FindObjectAnyFile(this::ByConstRef1{TDirectoryFile}, name::ByCopy{String})

# Wrapper of TObject * TDirectoryFile::Get(const char *)
@trydoc raw"""
    Get(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})::CxxPtr1{TObject}
Return pointer to object identified by namecycle.
Properties:

- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

Examples: 
| **Pattern** | **Explanation**                                                                             |
|:------------|:--------------------------------------------------------------------------------------------|
| foo         | get object named foo in memory if object is not in memory, try with highest cycle from file |
| foo;1       | get cycle 1 of foo on file                                                                  |

The retrieved object should in principle derive from [TObject](@ref). If not, the function [TDirectoryFile!Get<T>](@ref) should be called. However, this function will still work for a non-TObject, provided that the calling application cast the return type to the correct type (which is the actual type of the object).

### The Get<T> Method

The method Get<T> offers better protection and avoids the need for any cast: 

    auto objPtr = directory->Get<MyClass>("some object");
    if (objPtr) { ... the object exist and inherits from MyClass ... }

(C++ version of the code)

### Very important note about inheritance

In case the class of this object derives from [TObject](@ref) but not as a first inheritance, one must use dynamic_cast<>().

#### Example 1 - Normal case:

```
class MyClass : public TObject, public AnotherClass
```  then on return, one can adopt a C style cast: 
```
auto objPtr = (MyClass*)directory->Get("some object of MyClass");
```  #### Example 2 - Special case:

```
class MyClass : public AnotherClass, public TObject
```  then on return, one must do: 
```
auto objPtr = dynamic_cast<MyClass*>(directory->Get("some object of MyClass"));
```  Of course, dynamic_cast<> can also be used in the example 1.
""" Get(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})

# Wrapper of Int_t TDirectoryFile::GetBufferSize()
@trydoc raw"""
    GetBufferSize(this::ByConstRef1{TDirectoryFile})::Int32
Return the buffer size to create new TKeys.
If the stored fBufferSize is null, the value returned is the average buffer size of objects in the file so far.
""" GetBufferSize(this::ByConstRef1{TDirectoryFile})

# Wrapper of const TDatime & TDirectoryFile::GetCreationDate()
@trydoc raw"""
    GetCreationDate(this::ByConstRef1{TDirectoryFile})::ConstCxxRef1{TDatime}


""" GetCreationDate(this::ByConstRef1{TDirectoryFile})

# Wrapper of TDirectory * TDirectoryFile::GetDirectory(const char *, Bool_t, const char *)
@trydoc raw"""
    GetDirectory(this::ByRef1{TDirectoryFile}, apath::ByCopy{String}, printError::Bool, funcname::ByCopy{String})::CxxPtr1{TDirectory}
Find a directory named "apath".
It apath is null or empty, returns "this" directory. Otherwise use the name "apath" to find a directory. The absolute path syntax is: 
```
file.root:/dir1/dir2
```  where file.root is the file and /dir1/dir2 the desired subdirectory in the file. Relative syntax is relative to "this" directory. E.g: ../aa. Returns 0 in case path does not exist. If printError is true, use Error with 'funcname' to issue an error message.
""" GetDirectory(this::ByRef1{TDirectoryFile}, apath::ByCopy{String}, printError::Bool, funcname::ByCopy{String})

# Wrapper of TFile * TDirectoryFile::GetFile()
@trydoc raw"""
    GetFile(this::ByConstRef1{TDirectoryFile})::CxxPtr1{TFile}


""" GetFile(this::ByConstRef1{TDirectoryFile})

# Wrapper of TKey * TDirectoryFile::GetKey(const char *, Short_t)
@trydoc raw"""
    GetKey(this::ByConstRef1{TDirectoryFile}, name::ByCopy{String}, cycle::Int16)::CxxPtr1{TKey}
Return pointer to key with name,cycle.
If no key exists with the specified cycle, returns the key with the highest cycle that is lower than the requested cycle.

if cycle = 9999 returns highest cycle
""" GetKey(this::ByConstRef1{TDirectoryFile}, name::ByCopy{String}, cycle::Int16)

# Wrapper of TList * TDirectoryFile::GetListOfKeys()
@trydoc raw"""
    GetListOfKeys(this::ByConstRef1{TDirectoryFile})::CxxPtr1{TList}


""" GetListOfKeys(this::ByConstRef1{TDirectoryFile})

# Wrapper of const TDatime & TDirectoryFile::GetModificationDate()
@trydoc raw"""
    GetModificationDate(this::ByConstRef1{TDirectoryFile})::ConstCxxRef1{TDatime}


""" GetModificationDate(this::ByConstRef1{TDirectoryFile})

# Wrapper of Int_t TDirectoryFile::GetNbytesKeys()
@trydoc raw"""
    GetNbytesKeys(this::ByConstRef1{TDirectoryFile})::Int32


""" GetNbytesKeys(this::ByConstRef1{TDirectoryFile})

# Wrapper of Int_t TDirectoryFile::GetNkeys()
@trydoc raw"""
    GetNkeys(this::ByConstRef1{TDirectoryFile})::Int32


""" GetNkeys(this::ByConstRef1{TDirectoryFile})

# Wrapper of void * TDirectoryFile::GetObjectChecked(const char *, const char *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, classname::ByCopy{String})::CxxPtr2{Nothing}
See documentation of TDirectoryFile!GetObjectCheck(const char *namecycle, const TClass *cl)

""" GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, classname::ByCopy{String})

# Wrapper of void * TDirectoryFile::GetObjectChecked(const char *, const TClass *)
@trydoc raw"""
    GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a "expectedClass" If expectedClass is null, no check is performed.
- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

### Very important note

The calling application must cast the returned pointer to the type described by the 2 arguments (i.e. cl):

auto objPtr = (MyClass*)directory->GetObjectChecked("some object of MyClass","MyClass"));

Note: We recommend using the method [TDirectoryFile!Get<T>](@ref): 

    auto objPtr = directory->Get<MyClass>("some object inheriting from MyClass");
    if (objPtr) { ... we found what we are looking for ... }

(C++ version of the code)
""" GetObjectChecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String}, cl::ByConstPtr1{TClass})

# Wrapper of void * TDirectoryFile::GetObjectUnchecked(const char *)
@trydoc raw"""
    GetObjectUnchecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})::CxxPtr2{Nothing}
Return pointer to object identified by namecycle.
The returned object may or may not derive from [TObject](@ref).

- namecycle has the format name;cycle
- name = * is illegal, cycle = * is illegal
- cycle = "" or cycle = 9999 ==> apply to a memory object

## Very important note

The calling application must cast the returned object to the final type, e.g.

auto objPtr = (MyClass*)directory->GetObject("some object of MyClass");
""" GetObjectUnchecked(this::ByRef1{TDirectoryFile}, namecycle::ByCopy{String})

# Wrapper of Long64_t TDirectoryFile::GetSeekDir()
@trydoc raw"""
    GetSeekDir(this::ByConstRef1{TDirectoryFile})::Int64


""" GetSeekDir(this::ByConstRef1{TDirectoryFile})

# Wrapper of Long64_t TDirectoryFile::GetSeekKeys()
@trydoc raw"""
    GetSeekKeys(this::ByConstRef1{TDirectoryFile})::Int64


""" GetSeekKeys(this::ByConstRef1{TDirectoryFile})

# Wrapper of Long64_t TDirectoryFile::GetSeekParent()
@trydoc raw"""
    GetSeekParent(this::ByConstRef1{TDirectoryFile})::Int64


""" GetSeekParent(this::ByConstRef1{TDirectoryFile})

# Wrapper of Bool_t TDirectoryFile::IsModified()
@trydoc raw"""
    IsModified(this::ByConstRef1{TDirectoryFile})::Bool


""" IsModified(this::ByConstRef1{TDirectoryFile})

# Wrapper of Bool_t TDirectoryFile::IsWritable()
@trydoc raw"""
    IsWritable(this::ByConstRef1{TDirectoryFile})::Bool


""" IsWritable(this::ByConstRef1{TDirectoryFile})

# Wrapper of void TDirectoryFile::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TDirectoryFile}, option::ByCopy{String})::Nothing
List Directory contents.
Indentation is used to identify the directory tree Subdirectories are listed first, then objects in memory, then objects on the file

The option can has the following format: <b>`[-d |-m][<regexp>]`</b> Options:

- -d: only list objects in the file
- -m: only list objects in memory The `<regexp>` will be used to match the name of the objects. By default memory and disk objects are listed.
""" ls(this::ByConstRef1{TDirectoryFile}, option::ByCopy{String})

# Wrapper of TDirectory * TDirectoryFile::mkdir(const char *, const char *, Bool_t)
@trydoc raw"""
    mkdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)::CxxPtr1{TDirectory}
Create a sub-directory "a" or a hierarchy of sub-directories "a/b/c/...".
## Arguments

- **`name`** 
    the name or hierarchy of the subdirectory ("a" or "a/b/c") 
    
- **`title`** 
    the title 
    
- **`returnExistingDirectory`** 
    if key-name is already existing, the returned value points to preexisting sub-directory if true and to `nullptr` if false. 
    

###Return

a pointer to the created sub-directory, not to the top sub-directory of the hierarchy (in the above example, the returned TDirectory * points to "c"). In case of an error, it returns nullptr. In case of a preexisting sub-directory (hierarchy) with the requested name, the return value depends on the parameter returnExistingDirectory.
""" mkdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, title::ByCopy{String}, returnExistingDirectory::Bool)

# Wrapper of TFile * TDirectoryFile::OpenFile(const char *, Option_t *, const char *, Int_t, Int_t)
@trydoc raw"""
    OpenFile(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)::CxxPtr1{TFile}
Interface to [TFile!Open](@ref).
""" OpenFile(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, option::ByCopy{String}, ftitle::ByCopy{String}, compress::Int32, netopt::Int32)

# Wrapper of void TDirectoryFile::Purge(Short_t)
@trydoc raw"""
    Purge(this::ByRef1{TDirectoryFile}, nkeep::Int16)::Nothing
Purge lowest key cycles in a directory.
By default, only the highest cycle of a key is kept. Keys for which the "KEEP" flag has been set are not removed. See [TKey!Keep()](@ref). NOTE: This does not reduce the size of a [TFile](@ref)– the space is simply freed up to be overwritten.
""" Purge(this::ByRef1{TDirectoryFile}, nkeep::Int16)

# Wrapper of void TDirectoryFile::ReadAll(Option_t *)
@trydoc raw"""
    ReadAll(this::ByRef1{TDirectoryFile}, option::ByCopy{String})::Nothing
Read objects from a [ROOT](@ref) file directory into memory.
If an object is already in memory, the memory copy is deleted and the object is again read from the file. If opt=="dirs", only subdirectories will be read If opt=="dirs*" complete directory tree will be read
""" ReadAll(this::ByRef1{TDirectoryFile}, option::ByCopy{String})

# Wrapper of Int_t TDirectoryFile::ReadKeys(Bool_t)
@trydoc raw"""
    ReadKeys(this::ByRef1{TDirectoryFile}, forceRead::Bool)::Int32
Read the linked list of keys.
Every directory has a linked list (fKeys). This linked list has been written on the file via WriteKeys as a single data record.

It is interesting to call this function in the following situation. Assume another process1 is connecting this directory in Update mode

- Process1 is adding/updating objects in this directory
- You want to see the latest status from process1. Example Process1: 

        obj1.Write();
        obj2.Write();
        gDirectory->SaveSelf();

(C++ version of the code)


Example Process2: 

    gDirectory->ReadKeys();
    obj1->Draw();

(C++ version of the code)

 This is an efficient way (without opening/closing files) to view the latest updates of a file being modified by another process as it is typically the case in a data acquisition system.
""" ReadKeys(this::ByRef1{TDirectoryFile}, forceRead::Bool)

# Wrapper of Int_t TDirectoryFile::ReadTObject(TObject *, const char *)
@trydoc raw"""
    ReadTObject(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, keyname::ByCopy{String})::Int32
Read object with keyname from the current directory.
Read contents of object with specified name from the current directory. First the key with keyname is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See [TObject!Write()](@ref).
""" ReadTObject(this::ByRef1{TDirectoryFile}, obj::ByPtr1{TObject}, keyname::ByCopy{String})

# Wrapper of void TDirectoryFile::rmdir(const char *)
@trydoc raw"""
    rmdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String})::Nothing
Removes subdirectory from the directory.
When directory is deleted, all keys in all subdirectories will be read first and deleted from file (if exists) Equivalent call is Delete("name;*");
""" rmdir(this::ByRef1{TDirectoryFile}, name::ByCopy{String})

# Wrapper of void TDirectoryFile::Save()
@trydoc raw"""
    Save(this::ByRef1{TDirectoryFile})::Nothing
Save recursively all directory keys and headers.

""" Save(this::ByRef1{TDirectoryFile})

# Wrapper of Int_t TDirectoryFile::SaveObjectAs(const TObject *, const char *, Option_t *)
@trydoc raw"""
    SaveObjectAs(this::ByConstRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, filename::ByCopy{String}, option::ByCopy{String})::Int32
Save object in filename.
If filename is `nullptr` or "", a file with "<objectname>.root" is created. The name of the key is the object name. By default new file will be created. Using option "a", one can append object to the existing [ROOT](@ref) file. If the operation is successful, it returns the number of bytes written to the file otherwise it returns 0. By default a message is printed. Use option "q" to not print the message. If filename contains ".json" extension, JSON representation of the object will be created and saved in the text file. Such file can be used in JavaScript [ROOT](@ref) ([https://root.cern/js/](https://root.cern/js/)) to display object in web browser When creating JSON file, option string may contain compression level from 0 to 3 (default 0)
""" SaveObjectAs(this::ByConstRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TDirectoryFile::SaveSelf(Bool_t)
@trydoc raw"""
    SaveSelf(this::ByRef1{TDirectoryFile}, force::Bool)::Nothing
Save Directory keys and header.
If the directory has been modified (fModified set), write the keys and the directory header. This function assumes the cd is correctly set.

It is recommended to use this function in the following situation: Assume a process1 using a directory in Update mode

- New objects or modified objects have been written to the directory.
- You do not want to close the file.
- You want your changes be visible from another process2 already connected to this directory in read mode.
- Call this function.
- In process2, use [TDirectoryFile!ReadKeys](@ref) to refresh the directory.
""" SaveSelf(this::ByRef1{TDirectoryFile}, force::Bool)

# Wrapper of void TDirectoryFile::SetBufferSize(Int_t)
@trydoc raw"""
    SetBufferSize(this::ByRef1{TDirectoryFile}, bufsize::Int32)::Nothing
Set the default buffer size when creating new TKeys.
See also [TDirectoryFile!GetBufferSize](@ref)
""" SetBufferSize(this::ByRef1{TDirectoryFile}, bufsize::Int32)

# Wrapper of void TDirectoryFile::SetModified()
@trydoc raw"""
    SetModified(this::ByRef1{TDirectoryFile})::Nothing


""" SetModified(this::ByRef1{TDirectoryFile})

# Wrapper of void TDirectoryFile::SetSeekDir(Long64_t)
@trydoc raw"""
    SetSeekDir(this::ByRef1{TDirectoryFile}, v::Int64)::Nothing


""" SetSeekDir(this::ByRef1{TDirectoryFile}, v::Int64)

# Wrapper of void TDirectoryFile::SetTRefAction(TObject *, TObject *)
@trydoc raw"""
    SetTRefAction(this::ByRef1{TDirectoryFile}, ref::ByPtr1{TObject}, parent::ByPtr1{TObject})::Nothing
Find the action to be executed in the dictionary of the parent class and store the corresponding exec number into fBits.
This function searches a data member in the class of parent with an offset corresponding to this. If a comment "TEXEC:" is found in the comment field of the data member, the function stores the exec identifier of the exec statement following this keyword.
""" SetTRefAction(this::ByRef1{TDirectoryFile}, ref::ByPtr1{TObject}, parent::ByPtr1{TObject})

# Wrapper of void TDirectoryFile::SetWritable(Bool_t)
@trydoc raw"""
    SetWritable(this::ByRef1{TDirectoryFile}, writable::Bool)::Nothing
Set the new value of fWritable recursively.

""" SetWritable(this::ByRef1{TDirectoryFile}, writable::Bool)

# Wrapper of Int_t TDirectoryFile::Sizeof()
@trydoc raw"""
    Sizeof(this::ByConstRef1{TDirectoryFile})::Int32
Return the size in bytes of the directory header.

""" Sizeof(this::ByConstRef1{TDirectoryFile})

# Wrapper of Int_t TDirectoryFile::Write(const char *, Int_t, Int_t)
@trydoc raw"""
    Write(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, opt::Int32, bufsize::Int32)::Int32
Write all objects in memory to disk.
Loop on all objects in memory (including subdirectories). A new key is created in the keys linked list for each object. For allowed options see [TObject!Write()](@ref). The directory header info is rewritten on the directory header record.
""" Write(this::ByRef1{TDirectoryFile}, name::ByCopy{String}, opt::Int32, bufsize::Int32)

# Wrapper of void TDirectoryFile::WriteDirHeader()
@trydoc raw"""
    WriteDirHeader(this::ByRef1{TDirectoryFile})::Nothing
Overwrite the Directory header record.

""" WriteDirHeader(this::ByRef1{TDirectoryFile})

# Wrapper of void TDirectoryFile::WriteKeys()
@trydoc raw"""
    WriteKeys(this::ByRef1{TDirectoryFile})::Nothing
Write Keys linked list on the file.
The linked list of keys (fKeys) is written as a single data record
""" WriteKeys(this::ByRef1{TDirectoryFile})

# Wrapper of Int_t TDirectoryFile::WriteObjectAny(const void *, const char *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, classname::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)::Int32
Write object from pointer of class classname in this directory.
obj may not derive from [TObject](@ref). See [TDirectoryFile!WriteTObject](@ref) for comments

## Very important note

The value passed as 'obj' needs to be from a pointer to the type described by classname. For example: 

    TopClass *top;
    BottomClass *bottom;
    top = bottom;

(C++ version of the code)

 you can do: 

    directory->WriteObjectAny(top,"top","name of object");
    directory->WriteObjectAny(bottom,"bottom","name of object");

(C++ version of the code)

 **BUT YOU CAN NOT DO** the following since it will fail with multiple inheritance: 

    directory->WriteObjectAny(top,"bottom","name of object");

(C++ version of the code)

 We **STRONGLY** recommend to use 

    TopClass *top = ....;
    directory->WriteObject(top,"name of object")

(C++ version of the code)

 See also remarks in [TDirectoryFile!WriteTObject](@ref)
""" WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, classname::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TDirectoryFile::WriteObjectAny(const void *, const TClass *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)::Int32
Write object of class with dictionary cl in this directory.
obj may not derive from [TObject](@ref) To get the TClass* cl pointer, one can use 
```
TClass *cl = TClass!GetClass("classname");
```  An alternative is to call the function WriteObjectAny above. see [TDirectoryFile!WriteTObject](@ref) for comments
""" WriteObjectAny(this::ByRef1{TDirectoryFile}, obj::ByConstPtr2{Nothing}, cl::ByConstPtr1{TClass}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TDirectoryFile::WriteTObject(const TObject *, const char *, Option_t *, Int_t)
@trydoc raw"""
    WriteTObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)::Int32
Write object obj to this directory.
The data structure corresponding to this object is serialized. The corresponding buffer is written to this directory with an associated key with name "name".

Writing an object to a file involves the following steps:

- Creation of a support [TKey](@ref) object in the directory. The [TKey](@ref) object creates a [TBuffer](@ref) object.
- The [TBuffer](@ref) object is filled via the class!Streamer function.
- If the file is compressed (default) a second buffer is created to hold the compressed buffer.
- Reservation of the corresponding space in the file by looking in the [TFree](@ref) list of free blocks of the file.
- The buffer is written to the file.

By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far. Use [TDirectoryFile!SetBufferSize](@ref) to force a given buffer size.

If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by obj->[GetName()](@ref).

The option can be a combination of:

- "SingleKey"
- "Overwrite"
- "WriteDelete" Using the "Overwrite" option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the "WriteDelete" option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. The "SingleKey" option is only used by [TCollection!Write()](@ref) to write a container with a single key instead of each object in the container with its own key. An object is read from this directory via [TDirectoryFile!Get](@ref). The function returns the total number of bytes written to the directory. It returns 0 if the object cannot be written.

WARNING: avoid special characters like '^','$','.' in the name as they are used by the regular expression parser (see [TRegexp](@ref)).
""" WriteTObject(this::ByRef1{TDirectoryFile}, obj::ByConstPtr1{TObject}, name::ByCopy{String}, option::ByCopy{String}, bufsize::Int32)

# Wrapper of Int_t TFileOpenHandle::GetCompress()
@trydoc raw"""
    GetCompress(this::ByConstRef1{TFileOpenHandle})::Int32


""" GetCompress(this::ByConstRef1{TFileOpenHandle})

# Wrapper of Int_t TFileOpenHandle::GetNetOpt()
@trydoc raw"""
    GetNetOpt(this::ByConstRef1{TFileOpenHandle})::Int32


""" GetNetOpt(this::ByConstRef1{TFileOpenHandle})

# Wrapper of const char * TFileOpenHandle::GetOpt()
@trydoc raw"""
    GetOpt(this::ByConstRef1{TFileOpenHandle})::ByCopy{String}


""" GetOpt(this::ByConstRef1{TFileOpenHandle})

# Wrapper of Bool_t TFileOpenHandle::Matches(const char *)
@trydoc raw"""
    Matches(this::ByRef1{TFileOpenHandle}, name::ByCopy{String})::Bool
Return kTRUE if this async request matches the open request specified by 'url'.

""" Matches(this::ByRef1{TFileOpenHandle}, name::ByCopy{String})

# Wrapper of bool TFitResult::Contour(unsigned int, unsigned int, TGraph *, double)
@trydoc raw"""
    Contour(this::ByRef1{TFitResult}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)::Bool
Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or is invalid it will return false on exit a [TGraph](@ref) is filled with the contour points the number of contour points is determined by the size of the [TGraph](@ref).
if the size is zero a default number of points = 20 is used pass optionally the confidence level, default is 0.683 it is assumed that ErrorDef() defines the right error definition (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level
""" Contour(this::ByRef1{TFitResult}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)

# Wrapper of double TFitResult::Error(unsigned int)
@trydoc raw"""
    Error(this::ByConstRef1{TFitResult}, i::UInt32)::Float64


""" Error(this::ByConstRef1{TFitResult}, i::UInt32)

# Wrapper of TMatrixDSym TFitResult::GetCorrelationMatrix()
@trydoc raw"""
    GetCorrelationMatrix(this::ByConstRef1{TFitResult})::ByCopy{TMatrixDSym}
Return the correlation matrix from fit.
The matrix is a symmetric matrix with a size N equal to the total number of parameters considered in the fit including the fixed ones The matrix row and columns corresponding to the fixed parameters will contain only zero's
""" GetCorrelationMatrix(this::ByConstRef1{TFitResult})

# Wrapper of TMatrixDSym TFitResult::GetCovarianceMatrix()
@trydoc raw"""
    GetCovarianceMatrix(this::ByConstRef1{TFitResult})::ByCopy{TMatrixDSym}
Return the covariance matrix from fit.
The matrix is a symmetric matrix with a size N equal to the total number of parameters considered in the fit including the fixed ones The matrix row and columns corresponding to the fixed parameters will contain only zero's
""" GetCovarianceMatrix(this::ByConstRef1{TFitResult})

# Wrapper of void TFitResult::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TFitResult}, option::ByCopy{String})::Nothing
Print result of the fit, by default chi2, parameter values and errors.
if option "V" is given print also error matrix and correlation
""" Print(this::ByConstRef1{TFitResult}, option::ByCopy{String})

# Wrapper of bool TFitResult::Scan(unsigned int, TGraph *, double, double)
@trydoc raw"""
    Scan(this::ByRef1{TFitResult}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)::Bool
Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return filled with the scan resul If the graph size is zero, a default size n = 40 will be used.

""" Scan(this::ByRef1{TFitResult}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of TFitResult * TFitResultPtr::Get()
@trydoc raw"""
    Get(this::ByConstRef1{TFitResultPtr})::CxxPtr1{TFitResult}
Return contained pointer.

""" Get(this::ByConstRef1{TFitResultPtr})

# Wrapper of TFitResult & TFitResultPtr::operator*()
@trydoc raw"""
    Base.getindex(this::ByConstRef1{TFitResultPtr})::CxxRef1{TFitResult}
Implement the de-reference operator to make the class acts as a pointer to a [TFitResult](@ref) assert in case the class does not contain a pointer to [TFitResult](@ref).

""" Base.getindex(this::ByConstRef1{TFitResultPtr})

# Wrapper of TFitResult * TFitResultPtr::operator->()
@trydoc raw"""
    arrow(this::ByConstRef1{TFitResultPtr})::CxxPtr1{TFitResult}
Implement the -> operator to make the class acts as a pointer to a [TFitResult](@ref).
assert in case the class does not contain a pointer to [TFitResult](@ref)
""" arrow(this::ByConstRef1{TFitResultPtr})

# Wrapper of TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr &)
@trydoc raw"""
    assign(this::ByRef1{TFitResultPtr}, rhs::ByConstRef1{TFitResultPtr})::CxxRef1{TFitResultPtr}
Assignment operator.
if needed copy the [TFitResult](@ref) object and delete previous one if existing
""" assign(this::ByRef1{TFitResultPtr}, rhs::ByConstRef1{TFitResultPtr})

# Wrapper of void TF1::AddParameter(const TString &, Double_t)
@trydoc raw"""
    AddParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)::Nothing


""" AddParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of Bool_t TF1::AddToGlobalList(Bool_t)
@trydoc raw"""
    AddToGlobalList(this::ByRef1{TF1}, on::Bool)::Bool
Add to global_ list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the function was already in the list false if not)

""" AddToGlobalList(this::ByRef1{TF1}, on::Bool)

# Wrapper of void TF1::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TF1}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TF1}, b::ByPtr1{TBrowser})

# Wrapper of Double_t TF1::CentralMoment(Double_t, Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    CentralMoment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return nth central moment of function between a and b (i.e the n-th moment around the mean value)
See [TF1!Integral()](@ref) for parameter definitions

###Author

Gene Van Buren gene@bnl.gov
""" CentralMoment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of TObject * TF1::Clone(const char *)
@trydoc raw"""
    Clone(this::ByConstRef1{TF1}, newname::ByCopy{String})::CxxPtr1{TObject}
Make a complete copy of the underlying object.
If 'newname' is set, the copy's name will be set to that name.
""" Clone(this::ByConstRef1{TF1}, newname::ByCopy{String})

# Wrapper of void TF1::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF1}, f1::ByRef1{TObject})::Nothing
Copy this F1 to a new F1.
Note that the cached integral with its related arrays are not copied (they are also set as transient data members)
""" Copy(this::ByConstRef1{TF1}, f1::ByRef1{TObject})

# Wrapper of TH1 * TF1::CreateHistogram()
@trydoc raw"""
    CreateHistogram(this::ByRef1{TF1})::CxxPtr1{TH1}


""" CreateHistogram(this::ByRef1{TF1})

# Wrapper of Double_t TF1::Derivative(Double_t, Double_t *, Double_t)
@trydoc raw"""
    Derivative(this::ByConstRef1{TF1}, x::Float64, params::ByPtr2{Float64}, epsilon::Float64)::Float64
Returns the first derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas.
``D(h) = \frac{f(x+h) - f(x-h)}{2h}``

 the final estimate 

``D = \frac{4D(h/2) - D(h)}{3}``

 "Numerical Methods for Scientists and Engineers", H.M.Antia, 2nd edition"

if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.

the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.

Getting the error via [TF1!DerivativeError](@ref): (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: 

``err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},``

 where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.

###Author

Anna Kreshuk
""" Derivative(this::ByConstRef1{TF1}, x::Float64, params::ByPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::Derivative2(Double_t, Double_t *, Double_t)
@trydoc raw"""
    Derivative2(this::ByConstRef1{TF1}, x::Float64, params::ByPtr2{Float64}, epsilon::Float64)::Float64
Returns the second derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas.
``D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}``

 the final estimate 

``D = \frac{4D(h/2) - D(h)}{3}``

 "Numerical Methods for Scientists and Engineers", H.M.Antia, 2nd edition"

if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.

the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.

Getting the error via [TF1!DerivativeError](@ref): (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: 

``err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},``

 where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.

###Author

Anna Kreshuk
""" Derivative2(this::ByConstRef1{TF1}, x::Float64, params::ByPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::Derivative3(Double_t, Double_t *, Double_t)
@trydoc raw"""
    Derivative3(this::ByConstRef1{TF1}, x::Float64, params::ByPtr2{Float64}, epsilon::Float64)::Float64
Returns the third derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas.
``D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}``

 the final estimate 

``D = \frac{4D(h/2) - D(h)}{3}``

 "Numerical Methods for Scientists and Engineers", H.M.Antia, 2nd edition"

if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.

the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.

Getting the error via [TF1!DerivativeError](@ref): (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: 

``err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},``

 where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.

###Author

Anna Kreshuk
""" Derivative3(this::ByConstRef1{TF1}, x::Float64, params::ByPtr2{Float64}, epsilon::Float64)

# Wrapper of Int_t TF1::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TF1}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a function.
Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.

Note that px is called with a negative value when the [TF1](@ref) is in [TGraph](@ref) or [TH1](@ref) list of functions. In this case there is no point looking at the histogram axis.
""" DistancetoPrimitive(this::ByRef1{TF1}, px::Int32, py::Int32)

# Wrapper of void TF1::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TF1}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.
Possible option values are:

| **option** | **description**                                  |
|:-----------|:-------------------------------------------------|
| "SAME"     | superimpose on top of existing picture           |
| "L"        | connect all computed points with a straight line |
| "C"        | connect all computed points with a smooth curve  |
| "FC"       | draw a fill area below a smooth curve            |

Note that the default value is "L". Therefore to draw on top of an existing picture, specify option "LSAME"

NB. You must use DrawCopy if you want to draw several times the same function in the current canvas.
""" Draw(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of TF1 * TF1::DrawCopy(Option_t *)
@trydoc raw"""
    DrawCopy(this::ByConstRef1{TF1}, option::ByCopy{String})::CxxPtr1{TF1}
Draw a copy of this function with its current attributes.
This function MUST be used instead of Draw when you want to draw the same function with different parameters settings in the same canvas.

Possible option values are:

| **option** | **description**                                  |
|:-----------|:-------------------------------------------------|
| "SAME"     | superimpose on top of existing picture           |
| "L"        | connect all computed points with a straight line |
| "C"        | connect all computed points with a smooth curve  |
| "FC"       | draw a fill area below a smooth curve            |

Note that the default value is "L". Therefore to draw on top of an existing picture, specify option "LSAME"
""" DrawCopy(this::ByConstRef1{TF1}, option::ByCopy{String})

# Wrapper of TObject * TF1::DrawDerivative(Option_t *)
@trydoc raw"""
    DrawDerivative(this::ByRef1{TF1}, option::ByCopy{String})::CxxPtr1{TObject}
Draw derivative of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawDerivative(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawDerivative(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of void TF1::DrawF1(Double_t, Double_t, Option_t *)
@trydoc raw"""
    DrawF1(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, option::ByCopy{String})::Nothing
Draw function between xmin and xmax.

""" DrawF1(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, option::ByCopy{String})

# Wrapper of TObject * TF1::DrawIntegral(Option_t *)
@trydoc raw"""
    DrawIntegral(this::ByRef1{TF1}, option::ByCopy{String})::CxxPtr1{TObject}
Draw integral of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawIntegral(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawIntegral(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of Double_t TF1::Eval(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TF1}, x::Float64, y::Float64, z::Float64, t::Float64)::Float64
Evaluate this function.
Computes the value of this function (general case for a 3-d function) at point x,y,z. For a 1-d function give y=0 and z=0 The current value of variables x,y,z is passed through x, y and z. The parameters used will be the ones in the array params if params is given otherwise parameters will be taken from the stored data members fParams
""" Eval(this::ByConstRef1{TF1}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of Double_t TF1::EvalPar(const Double_t *, const Double_t *)
@trydoc raw"""
    EvalPar(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Float64
Evaluate function with given coordinates and parameters.
Compute the value of this function at point defined by array x and current values of parameters in array params. If argument params is omitted or equal 0, the internal values of parameters (array fParams) will be used instead. For a 1-D function only x[0] must be given. In case of a multi-dimensional function, the arrays x must be filled with the corresponding number of dimensions.

WARNING. In case of an interpreted function (fType=2), it is the user's responsibility to initialize the parameters via InitArgs before calling this function. InitArgs should be called at least once to specify the addresses of the arguments x and params. InitArgs should be called every time these addresses change.
""" EvalPar(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of void TF1::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TF1}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a F1 is clicked with the locator
""" ExecuteEvent(this::ByRef1{TF1}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TF1::FixParameter(Int_t, Double_t)
@trydoc raw"""
    FixParameter(this::ByRef1{TF1}, ipar::Int32, value::Float64)::Nothing
Fix the value of a parameter for a fit operation The specified value will be used in the fit and the parameter will be constant (nor varying) during fitting Note that when using pre-defined functions (e.g gaus), one needs to use the fit option 'B' to have the fix of the paramter effective.
See [TH1!Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t)](@ref) for the fitting documentation and the fitting options.
""" FixParameter(this::ByRef1{TF1}, ipar::Int32, value::Float64)

# Wrapper of Double_t TF1::GetChisquare()
@trydoc raw"""
    GetChisquare(this::ByConstRef1{TF1})::Float64
Return the Chisquare after fitting. See [ROOT!Fit!FitResult!Chi2()](@ref)
""" GetChisquare(this::ByConstRef1{TF1})

# Wrapper of TString TF1::GetExpFormula(Option_t *)
@trydoc raw"""
    GetExpFormula(this::ByConstRef1{TF1}, option::ByCopy{String})::ByCopy{TString}


""" GetExpFormula(this::ByConstRef1{TF1}, option::ByCopy{String})

# Wrapper of TFormula * TF1::GetFormula()
@trydoc raw"""
    GetFormula(this::ByRef1{TF1})::CxxPtr1{TFormula}


""" GetFormula(this::ByRef1{TF1})

# Wrapper of const TFormula * TF1::GetFormula()
@trydoc raw"""
    GetFormula(this::ByConstRef1{TF1})::ConstCxxPtr1{TFormula}


""" GetFormula(this::ByConstRef1{TF1})

# Wrapper of TH1 * TF1::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByConstRef1{TF1})::CxxPtr1{TH1}
Return a pointer to the histogram used to visualise the function Note that this histogram is managed by the function and in same case it is automatically deleted when some [TF1](@ref) functions are called such as [TF1!SetParameters](@ref), [TF1!SetNpx](@ref), [TF1!SetRange](@ref) It is then reccomended either to clone the return object or calling again teh GetHistogram function whenever is needed.

""" GetHistogram(this::ByConstRef1{TF1})

# Wrapper of const TObject * TF1::GetLinearPart(Int_t)
@trydoc raw"""
    GetLinearPart(this::ByConstRef1{TF1}, i::Int32)::ConstCxxPtr1{TObject}


""" GetLinearPart(this::ByConstRef1{TF1}, i::Int32)

# Wrapper of Double_t TF1::GetMaximum(Double_t, Double_t, Double_t, Int_t, Bool_t)
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)::Float64
Returns the maximum value of the function.
Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the [SetNpx()](@ref) function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad

NOTE: see also [TF1!GetMaximumX](@ref) and [TF1!GetX](@ref)
""" GetMaximum(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)

# Wrapper of Double_t TF1::GetMaximumStored()
@trydoc raw"""
    GetMaximumStored(this::ByConstRef1{TF1})::Float64


""" GetMaximumStored(this::ByConstRef1{TF1})

# Wrapper of Double_t TF1::GetMaximumX(Double_t, Double_t, Double_t, Int_t, Bool_t)
@trydoc raw"""
    GetMaximumX(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)::Float64
Returns the X value corresponding to the maximum value of the function.
Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the [SetNpx()](@ref) function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad

NOTE: see also [TF1!GetX](@ref)
""" GetMaximumX(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)

# Wrapper of TMethodCall * TF1::GetMethodCall()
@trydoc raw"""
    GetMethodCall(this::ByConstRef1{TF1})::CxxPtr1{TMethodCall}


""" GetMethodCall(this::ByConstRef1{TF1})

# Wrapper of Double_t TF1::GetMinimum(Double_t, Double_t, Double_t, Int_t, Bool_t)
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)::Float64
Returns the minimum value of the function on the (xmin, xmax) interval.
Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the [SetNpx()](@ref) function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad

NOTE: see also [TF1!GetMaximumX](@ref) and [TF1!GetX](@ref)
""" GetMinimum(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)

# Wrapper of Double_t TF1::GetMinimumStored()
@trydoc raw"""
    GetMinimumStored(this::ByConstRef1{TF1})::Float64


""" GetMinimumStored(this::ByConstRef1{TF1})

# Wrapper of Double_t TF1::GetMinimumX(Double_t, Double_t, Double_t, Int_t, Bool_t)
@trydoc raw"""
    GetMinimumX(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)::Float64
Returns the X value corresponding to the minimum value of the function on the (xmin, xmax) interval.
Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the [SetNpx()](@ref) function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad

NOTE: see also [TF1!GetX](@ref)
""" GetMinimumX(this::ByConstRef1{TF1}, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)

# Wrapper of Int_t TF1::GetNDF()
@trydoc raw"""
    GetNDF(this::ByConstRef1{TF1})::Int32
Return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit.
The number of degrees of freedom corresponds to the number of points used in the fit minus the number of free parameters.
""" GetNDF(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetNdim()
@trydoc raw"""
    GetNdim(this::ByConstRef1{TF1})::Int32


""" GetNdim(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetNpar()
@trydoc raw"""
    GetNpar(this::ByConstRef1{TF1})::Int32


""" GetNpar(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetNpx()
@trydoc raw"""
    GetNpx(this::ByConstRef1{TF1})::Int32


""" GetNpx(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetNumber()
@trydoc raw"""
    GetNumber(this::ByConstRef1{TF1})::Int32


""" GetNumber(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetNumberFitPoints()
@trydoc raw"""
    GetNumberFitPoints(this::ByConstRef1{TF1})::Int32


""" GetNumberFitPoints(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetNumberFreeParameters()
@trydoc raw"""
    GetNumberFreeParameters(this::ByConstRef1{TF1})::Int32
Return the number of free parameters.

""" GetNumberFreeParameters(this::ByConstRef1{TF1})

# Wrapper of char * TF1::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TF1}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Redefines [TObject!GetObjectInfo](@ref).
Displays the function info (x, function value) corresponding to cursor position px,py
""" GetObjectInfo(this::ByConstRef1{TF1}, px::Int32, py::Int32)

# Wrapper of Double_t TF1::GetParameter(const TString &)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TF1}, name::ByConstRef1{TString})::Float64


""" GetParameter(this::ByConstRef1{TF1}, name::ByConstRef1{TString})

# Wrapper of Double_t TF1::GetParameter(Int_t)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TF1}, ipar::Int32)::Float64


""" GetParameter(this::ByConstRef1{TF1}, ipar::Int32)

# Wrapper of Double_t * TF1::GetParameters()
@trydoc raw"""
    GetParameters(this::ByConstRef1{TF1})::CxxPtr2{Float64}


""" GetParameters(this::ByConstRef1{TF1})

# Wrapper of void TF1::GetParameters(Double_t *)
@trydoc raw"""
    GetParameters(this::ByRef1{TF1}, params::ByPtr2{Float64})::Nothing


""" GetParameters(this::ByRef1{TF1}, params::ByPtr2{Float64})

# Wrapper of TObject * TF1::GetParent()
@trydoc raw"""
    GetParent(this::ByConstRef1{TF1})::CxxPtr1{TObject}


""" GetParent(this::ByConstRef1{TF1})

# Wrapper of Double_t TF1::GetParError(Int_t)
@trydoc raw"""
    GetParError(this::ByConstRef1{TF1}, ipar::Int32)::Float64
Return value of parameter number ipar.

""" GetParError(this::ByConstRef1{TF1}, ipar::Int32)

# Wrapper of const Double_t * TF1::GetParErrors()
@trydoc raw"""
    GetParErrors(this::ByConstRef1{TF1})::ConstCxxPtr2{Float64}


""" GetParErrors(this::ByConstRef1{TF1})

# Wrapper of void TF1::GetParLimits(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetParLimits(this::ByConstRef1{TF1}, ipar::Int32, parmin::ByRef2{Float64}, parmax::ByRef2{Float64})::Nothing
Return limits for parameter ipar.

""" GetParLimits(this::ByConstRef1{TF1}, ipar::Int32, parmin::ByRef2{Float64}, parmax::ByRef2{Float64})

# Wrapper of const char * TF1::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TF1}, ipar::Int32)::ByCopy{String}


""" GetParName(this::ByConstRef1{TF1}, ipar::Int32)

# Wrapper of Int_t TF1::GetParNumber(const char *)
@trydoc raw"""
    GetParNumber(this::ByConstRef1{TF1}, name::ByCopy{String})::Int32


""" GetParNumber(this::ByConstRef1{TF1}, name::ByCopy{String})

# Wrapper of Double_t TF1::GetProb()
@trydoc raw"""
    GetProb(this::ByConstRef1{TF1})::Float64
Return the fit probability.

""" GetProb(this::ByConstRef1{TF1})

# Wrapper of Int_t TF1::GetQuantiles(Int_t, Double_t *, const Double_t *)
@trydoc raw"""
    GetQuantiles(this::ByRef1{TF1}, n::Int32, xp::ByPtr2{Float64}, p::ByConstPtr2{Float64})::Int32
Compute Quantiles for density distribution of this function.
Quantile x_p of a probability distribution Function F is defined as 

``F(x_{p}) = \int_{xmin}^{x_{p}} f dx = p \text{with} 0 <= p <= 1.``

 For instance the median $ x_{\frac{1}{2}} $ of a distribution is defined as that value of the random variable for which the distribution function equals 0.5: 

``F(x_{\frac{1}{2}}) = \prod(x < x_{\frac{1}{2}}) = \frac{1}{2}``

## Arguments

- **`n`** [in] 
    maximum size of array xp and size of array p 
    
- **`xp`** [out] 
    array filled with n quantiles evaluated at p. Memory has to be preallocated by caller. 
    
- **`p`** [in] 
    array of cumulative probabilities where quantiles should be evaluated. It is assumed to contain at least n values. 
    

###Return

n, the number of quantiles computed (same as input argument n)

Getting quantiles from two histograms and storing results in a [TGraph](@ref), a so-called QQ-plot 
```
TGraph *gr = new TGraph(nprob);
f1->GetQuantiles(nprob,gr->GetX(),p);
f2->GetQuantiles(nprob,gr->GetY(),p);
gr->Draw("alp");
```  

###Author

Eddy Offermann 

###Warning

Function leads to undefined behavior if xp or p are null or their size does not match with n
""" GetQuantiles(this::ByRef1{TF1}, n::Int32, xp::ByPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of Double_t TF1::GetRandom(Double_t, Double_t, TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape in [xmin,xmax].
The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents. It is normalized to 1. For each bin the integral is approximated by a parabola. The parabola coefficients are stored as non persistent data members Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Evaluate the parabolic curve in the selected bin to find the corresponding X value.

The parabolic approximation is very good as soon as the number of bins is greater than 50.

## Arguments

- **`xmin`** 
    minimum value for generated random numbers 
    
- **`xmax`** 
    maximum value for generated random numbers 
    
- **`rng`** 
    (optional) random number generator pointer 
    
- **`option`** 
    (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table
    

IMPORTANT NOTE

The integral of the function is computed at fNpx points. If the function has sharp peaks, you should increase the number of points (SetNpx) such that the peak is correctly tabulated at several points.
""" GetRandom(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of Double_t TF1::GetRandom(TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF1}, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape.
## Arguments

- **`rng`** 
    Random number generator. By default (or when passing a nullptr) the global_ gRandom is used 
    
- **`option`** 
    Option string which controls the binning used to compute the integral. Default mode is automatic depending of xmax, xmin and Npx (function points). Possible values are:
    
    - "LOG" to force usage of log scale for tabulating the integral
    - "LIN" to force usage of linear scale when tabulating the integral
    
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents. It is normalized to 1. For each bin the integral is approximated by a parabola. The parabola coefficients are stored as non persistent data members Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Evaluate the parabolic curve in the selected bin to find the corresponding X value.

The user can provide as optional parameter a Random number generator. By default gRandom is used

If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x A log scale for the intergral is also always used if a user specifies the "LOG" option Instead if a user requestes a "LIN" option the integral binning is never done in log scale whatever the fXmax/fXmin ratio is

Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.
""" GetRandom(this::ByRef1{TF1}, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of void TF1::GetRange(Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF1}, xmin::ByRef2{Float64}, xmax::ByRef2{Float64})::Nothing
Return range of a 1-D function.

""" GetRange(this::ByConstRef1{TF1}, xmin::ByRef2{Float64}, xmax::ByRef2{Float64})

# Wrapper of void TF1::GetRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF1}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Return range of a 2-D function.

""" GetRange(this::ByConstRef1{TF1}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of void TF1::GetRange(Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF1}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, zmin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64}, zmax::ByRef2{Float64})::Nothing
Return range of function.

""" GetRange(this::ByConstRef1{TF1}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, zmin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64}, zmax::ByRef2{Float64})

# Wrapper of Double_t TF1::GetSave(const Double_t *)
@trydoc raw"""
    GetSave(this::ByRef1{TF1}, x::ByConstPtr2{Float64})::Float64
Get value corresponding to X in array of fSave values.

""" GetSave(this::ByRef1{TF1}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF1::GetVariable(const TString &)
@trydoc raw"""
    GetVariable(this::ByRef1{TF1}, name::ByConstRef1{TString})::Float64


""" GetVariable(this::ByRef1{TF1}, name::ByConstRef1{TString})

# Wrapper of Double_t TF1::GetX(Double_t, Double_t, Double_t, Double_t, Int_t, Bool_t)
@trydoc raw"""
    GetX(this::ByConstRef1{TF1}, y::Float64, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)::Float64
Returns the X value corresponding to the function value fy for (xmin<x<xmax).
in other words it can find the roots of the function when fy=0 and successive calls by changing the next call to [xmin+eps,xmax] where xmin is the previous root.

Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the [SetNpx()](@ref) function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad

NOTE: see also [TF1!GetMaximumX](@ref), [TF1!GetMinimumX](@ref)
""" GetX(this::ByConstRef1{TF1}, y::Float64, xmin::Float64, xmax::Float64, epsilon::Float64, maxiter::Int32, logx::Bool)

# Wrapper of TAxis * TF1::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByConstRef1{TF1})::CxxPtr1{TAxis}
Get x axis of the function.

""" GetXaxis(this::ByConstRef1{TF1})

# Wrapper of Double_t TF1::GetXmax()
@trydoc raw"""
    GetXmax(this::ByConstRef1{TF1})::Float64


""" GetXmax(this::ByConstRef1{TF1})

# Wrapper of Double_t TF1::GetXmin()
@trydoc raw"""
    GetXmin(this::ByConstRef1{TF1})::Float64


""" GetXmin(this::ByConstRef1{TF1})

# Wrapper of TAxis * TF1::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByConstRef1{TF1})::CxxPtr1{TAxis}
Get y axis of the function.

""" GetYaxis(this::ByConstRef1{TF1})

# Wrapper of TAxis * TF1::GetZaxis()
@trydoc raw"""
    GetZaxis(this::ByConstRef1{TF1})::CxxPtr1{TAxis}
Get z axis of the function. (In case this object is a [TF2](@ref) or [TF3](@ref))

""" GetZaxis(this::ByConstRef1{TF1})

# Wrapper of void TF1::GradientPar(const Double_t *, Double_t *, Double_t)
@trydoc raw"""
    GradientPar(this::ByConstRef1{TF1}, x::ByConstPtr2{Float64}, grad::ByPtr2{Float64}, eps::Float64)::Nothing
Compute the gradient wrt parameters If the [TF1](@ref) object is based on a formula expression ([TFormula](@ref)) and [TFormula!GenerateGradientPar()](@ref) has been successfully called automatic differentiation using CLAD is used instead of the default numerical differentiation.
## Arguments

- **`x`** 
    point, were the gradient is computed 
    
- **`grad`** 
    used to return the computed gradient, assumed to be of at least fNpar size 
    
- **`eps`** 
    if the errors of parameters have been computed, the step used in numerical differentiation is eps*parameter_error.
    

if the errors have not been computed, step=eps is used default value of eps = 0.01 Method is the same as in [Derivative()](@ref) function

If a parameter is fixed, the gradient on this parameter = 0
""" GradientPar(this::ByConstRef1{TF1}, x::ByConstPtr2{Float64}, grad::ByPtr2{Float64}, eps::Float64)

# Wrapper of Double_t TF1::GradientPar(Int_t, const Double_t *, Double_t)
@trydoc raw"""
    GradientPar(this::ByConstRef1{TF1}, ipar::Int32, x::ByConstPtr2{Float64}, eps::Float64)::Float64
Compute the gradient (derivative) wrt a parameter ipar.
## Arguments

- **`ipar`** 
    index of parameter for which the derivative is computed 
    
- **`x`** 
    point, where the derivative is computed 
    
- **`eps`** 
    - if the errors of parameters have been computed, the step used in numerical differentiation is eps*parameter_error.
    

if the errors have not been computed, step=eps is used default value of eps = 0.01 Method is the same as in [Derivative()](@ref) function

If a parameter is fixed, the gradient on this parameter = 0
""" GradientPar(this::ByConstRef1{TF1}, ipar::Int32, x::ByConstPtr2{Float64}, eps::Float64)

# Wrapper of void TF1::InitArgs(const Double_t *, const Double_t *)
@trydoc raw"""
    InitArgs(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Nothing
Initialize parameters addresses.

""" InitArgs(this::ByRef1{TF1}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of Double_t TF1::Integral(Double_t, Double_t, Double_t)
@trydoc raw"""
    Integral(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64)::Float64
IntegralOneDim or analytical integral.

""" Integral(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64)

# Wrapper of Double_t TF1::IntegralError(Double_t, Double_t, const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    IntegralError(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return Error on Integral of a parametric function between a and b due to the parameter uncertainties and their covariance matrix from the fit.
In addition to the integral limits, this method takes as input a pointer to the fitted parameter values and a pointer the covariance matrix from the fit. These pointers should be retrieved from the previously performed fit using the [TFitResult](@ref) class. Note that to get the [TFitResult](@ref), te fit should be done using the fit option `S`. Example: 

    TFitResultPtr r = histo->Fit(func, "S");
    func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );

(C++ version of the code)

IMPORTANT NOTE1:

A null pointer to the parameter values vector and to the covariance matrix can be passed. In this case, when the parameter values pointer is null, the parameter values stored in this [TF1](@ref) function object are used in the integral error computation. When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved from a global_ fitter instance when it exists. Note that the global_ fitter instance esists only when [ROOT](@ref) is not running with multi-threading enabled ([ROOT!IsImplicitMTEnabled()](@ref) == True). When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is returned.

IMPORTANT NOTE2:

When no covariance matrix is passed and in the meantime a fit is done using another function, the routine will signal an error and it will return zero only when the number of fit parameter is different than the values stored in [TF1](@ref) ([TF1!GetNpar()](@ref) ). In the case that npar is the same, an incorrect result is returned.

IMPORTANT NOTE3:

The user must pass a pointer to the elements of the full covariance matrix dimensioned with the right size (npar*npar), where npar is the total number of parameters ([TF1!GetNpar()](@ref)), including also the fixed parameters. The covariance matrix must be retrieved from the [TFitResult](@ref) class as shown above and not from [TVirtualFitter!GetCovarianceMatrix()](@ref) function.
""" IntegralError(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::IntegralError(Int_t, const Double_t *, const Double_t *, const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    IntegralError(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return Error on Integral of a parametric function with dimension larger than one between a[] and b[] due to the parameters uncertainties.
For a [TF1](@ref) with dimension larger than 1 (for example a [TF2](@ref) or [TF3](@ref)) [TF1!IntegralMultiple](@ref) is used for the integral calculation

In addition to the integral limits, this method takes as input a pointer to the fitted parameter values and a pointer the covariance matrix from the fit. These pointers should be retrieved from the previously performed fit using the [TFitResult](@ref) class. Note that to get the [TFitResult](@ref), te fit should be done using the fit option `S`. Example: 

    TFitResultPtr r = histo2d->Fit(func2, "S");
    func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );

(C++ version of the code)

IMPORTANT NOTE1:

A null pointer to the parameter values vector and to the covariance matrix can be passed. In this case, when the parameter values pointer is null, the parameter values stored in this [TF1](@ref) function object are used in the integral error computation. When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved from a global_ fitter instance when it exists. Note that the global_ fitter instance esists only when [ROOT](@ref) is not running with multi-threading enabled ([ROOT!IsImplicitMTEnabled()](@ref) == True). When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is returned.

IMPORTANT NOTE2:

When no covariance matrix is passed and in the meantime a fit is done using another function, the routine will signal an error and it will return zero only when the number of fit parameter is different than the values stored in [TF1](@ref) ([TF1!GetNpar()](@ref) ). In the case that npar is the same, an incorrect result is returned.

IMPORTANT NOTE3:

The user must pass a pointer to the elements of the full covariance matrix dimensioned with the right size (npar*npar), where npar is the total number of parameters ([TF1!GetNpar()](@ref)), including also the fixed parameters. The covariance matrix must be retrieved from the [TFitResult](@ref) class as shown above and not from [TVirtualFitter!GetCovarianceMatrix()](@ref)
""" IntegralError(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, params::ByConstPtr2{Float64}, covmat::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::IntegralFast(Int_t, Double_t *, Double_t *, Double_t, Double_t, Double_t *, Double_t)
@trydoc raw"""
    IntegralFast(this::ByRef1{TF1}, num::Int32, x::ByPtr2{Float64}, w::ByPtr2{Float64}, a::Float64, b::Float64, params::ByPtr2{Float64}, epsilon::Float64)::Float64
Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints.

""" IntegralFast(this::ByRef1{TF1}, num::Int32, x::ByPtr2{Float64}, w::ByPtr2{Float64}, a::Float64, b::Float64, params::ByPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::IntegralMultiple(Int_t, const Double_t *, const Double_t *, Double_t, Double_t &)
@trydoc raw"""
    IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, epsrel::Float64, relerr::ByRef2{Float64})::Float64
See more general prototype below.
This interface kept for back compatibility It is recommended to use the other interface where one can specify also epsabs and the maximum number of points
""" IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, epsrel::Float64, relerr::ByRef2{Float64})

# Wrapper of Double_t TF1::IntegralMultiple(Int_t, const Double_t *, const Double_t *, Int_t, Double_t, Double_t, Double_t &, Int_t &, Int_t &)
@trydoc raw"""
    IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, maxpts::Int32, epsrel::Float64, epsabs::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})::Float64
This function computes, to an attempted specified accuracy, the value of the integral.
## Arguments

- **`n`** [in], **`a`** [in], **`b`** [in], **`maxpts`** [in], **`epsrel`** [in], **`epsabs`** [in], **`relerr`** [out], **`nfnevl`** [out], **`ifail`** [out] 
    Number of dimensions [2,15] 
    . 
    One-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. 
    . 
    Maximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts 
    . 
    Specified relative accuracy. 
    . 
    Specified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy
    . 
    Contains, on exit, an estimation of the relative accuracy of the result. 
    . 
    number of function evaluations performed. 
    . 
    0 Normal exit. At least minpts and at most maxpts calls to the function were performed.
    
    1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.
    
    3 n<2 or n>15 
    
    

Method:

The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class [ROOT!Math!AdaptiveIntegratorMultiDim](@ref) (see the reference documentation of the class)

Other methods can be used by setting [ROOT!Math!IntegratorMultiDimOptions!SetDefaultIntegrator()](@ref) to different integrators. Other possible integrators are MC integrators based on the [ROOT!Math!GSLMCIntegrator](@ref) class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts
""" IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, maxpts::Int32, epsrel::Float64, epsabs::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})

# Wrapper of Double_t TF1::IntegralMultiple(Int_t, const Double_t *, const Double_t *, Int_t, Int_t, Double_t, Double_t &, Int_t &, Int_t &)
@trydoc raw"""
    IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, ::Int32, maxpts::Int32, epsrel::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})::Float64


""" IntegralMultiple(this::ByRef1{TF1}, n::Int32, a::ByConstPtr2{Float64}, b::ByConstPtr2{Float64}, ::Int32, maxpts::Int32, epsrel::Float64, relerr::ByRef2{Float64}, nfnevl::ByRef2{Int32}, ifail::ByRef2{Int32})

# Wrapper of Double_t TF1::IntegralOneDim(Double_t, Double_t, Double_t, Double_t, Double_t &)
@trydoc raw"""
    IntegralOneDim(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64, epsabs::Float64, err::ByRef2{Float64})::Float64
Return Integral of function between a and b using the given parameter values and relative and absolute tolerance.
The default integrator defined in [ROOT!Math!IntegratorOneDimOptions!DefaultIntegrator()](@ref) is used If [ROOT](@ref) contains the MathMore library the default integrator is set to be the adaptive [ROOT!Math!GSLIntegrator](@ref) (based on QUADPACK) or otherwise the [ROOT!Math!GaussIntegrator](@ref) is used See the reference documentation of these classes for more information about the integration algorithms To change integration algorithm just do : ROOT!Math!IntegratorOneDimOptions!SetDefaultIntegrator(IntegratorName); Valid integrator names are:

- Gauss : for [ROOT!Math!GaussIntegrator](@ref)
- GaussLegendre : for [ROOT!Math!GaussLegendreIntegrator](@ref)
- Adaptive : for [ROOT!Math!GSLIntegrator](@ref) adaptive method (QAG)
- AdaptiveSingular : for [ROOT!Math!GSLIntegrator](@ref) adaptive singular method (QAGS)
- NonAdaptive : for [ROOT!Math!GSLIntegrator](@ref) non adaptive (QNG)

In order to use the GSL integrators one needs to have the MathMore library installed

Note 1:

Values of the function [f(x)](@ref) at the interval theend-points A and B are not required. The subprogram may therefore be used when these values are undefined.

Note 2:

Instead of [TF1!Integral](@ref), you may want to use the combination of [TF1!CalcGaussLegendreSamplingPoints](@ref) and [TF1!IntegralFast](@ref). See an example with the following script:

    void gint() {
       TF1 *g = new TF1("g","gaus",-5,5);
       g->SetParameters(1,0,1);
       //default gaus integration method uses 6 points
       //not suitable to integrate on a large domain
       double r1 = g->Integral(0,5);
       double r2 = g->Integral(0,1000);
       //try with user directives computing more points
       Int_t np = 1000;
       double *x=new double[np];
       double *w=new double[np];
       g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);
       double r3 = g->IntegralFast(np,x,w,0,5);
       double r4 = g->IntegralFast(np,x,w,0,1000);
       double r5 = g->IntegralFast(np,x,w,0,10000);
       double r6 = g->IntegralFast(np,x,w,0,100000);
       printf("g->Integral(0,5)               = %g\n",r1);
       printf("g->Integral(0,1000)            = %g\n",r2);
       printf("g->IntegralFast(n,x,w,0,5)     = %g\n",r3);
       printf("g->IntegralFast(n,x,w,0,1000)  = %g\n",r4);
       printf("g->IntegralFast(n,x,w,0,10000) = %g\n",r5);
       printf("g->IntegralFast(n,x,w,0,100000)= %g\n",r6);
       delete [] x;
       delete [] w;
    }

(C++ version of the code)

This example produces the following results:

    g->Integral(0,5)               = 1.25331
    g->Integral(0,1000)            = 1.25319
    g->IntegralFast(n,x,w,0,5)     = 1.25331
    g->IntegralFast(n,x,w,0,1000)  = 1.25331
    g->IntegralFast(n,x,w,0,10000) = 1.25331
    g->IntegralFast(n,x,w,0,100000)= 1.253

(C++ version of the code)
""" IntegralOneDim(this::ByRef1{TF1}, a::Float64, b::Float64, epsrel::Float64, epsabs::Float64, err::ByRef2{Float64})

# Wrapper of Bool_t TF1::IsEvalNormalized()
@trydoc raw"""
    IsEvalNormalized(this::ByConstRef1{TF1})::Bool


""" IsEvalNormalized(this::ByConstRef1{TF1})

# Wrapper of Bool_t TF1::IsInside(const Double_t *)
@trydoc raw"""
    IsInside(this::ByConstRef1{TF1}, x::ByConstPtr2{Float64})::Bool
return kTRUE if the point is inside the function range

""" IsInside(this::ByConstRef1{TF1}, x::ByConstPtr2{Float64})

# Wrapper of Bool_t TF1::IsLinear()
@trydoc raw"""
    IsLinear(this::ByConstRef1{TF1})::Bool


""" IsLinear(this::ByConstRef1{TF1})

# Wrapper of Bool_t TF1::IsValid()
@trydoc raw"""
    IsValid(this::ByConstRef1{TF1})::Bool
Return kTRUE if the function is valid.

""" IsValid(this::ByConstRef1{TF1})

# Wrapper of bool TF1::IsVectorized()
@trydoc raw"""
    IsVectorized(this::ByRef1{TF1})::Bool


""" IsVectorized(this::ByRef1{TF1})

# Wrapper of Double_t TF1::Mean(Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    Mean(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64


""" Mean(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::Moment(Double_t, Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    Moment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64
Return nth moment of function between a and b.
See [TF1!Integral()](@ref) for parameter definitions
""" Moment(this::ByRef1{TF1}, n::Float64, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of Double_t TF1::operator()(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    paren(this::ByConstRef1{TF1}, x::Float64, y::Float64, z::Float64, t::Float64)::Float64


""" paren(this::ByConstRef1{TF1}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of TF1 & TF1::operator=(const TF1 &)
@trydoc raw"""
    assign(this::ByRef1{TF1}, rhs::ByConstRef1{TF1})::CxxRef1{TF1}
Operator =.

""" assign(this::ByRef1{TF1}, rhs::ByConstRef1{TF1})

# Wrapper of void TF1::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TF1}, option::ByCopy{String})::Nothing
Paint this function with its current attributes.
The function is going to be converted in an histogram and the corresponding histogram is painted. The painted histogram can be retrieved calling afterwards the method [TF1!GetHistogram()](@ref)
""" Paint(this::ByRef1{TF1}, option::ByCopy{String})

# Wrapper of void TF1::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TF1}, option::ByCopy{String})::Nothing
Print [TNamed](@ref) name and title.

""" Print(this::ByConstRef1{TF1}, option::ByCopy{String})

# Wrapper of void TF1::ReleaseParameter(Int_t)
@trydoc raw"""
    ReleaseParameter(this::ByRef1{TF1}, ipar::Int32)::Nothing
Release parameter number ipar during a fit operation.
After releasing it, the parameter can vary freely in the fit. The parameter limits are reset to 0,0.
""" ReleaseParameter(this::ByRef1{TF1}, ipar::Int32)

# Wrapper of void TF1::Save(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Save(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Nothing
Save values of function in array fSave.

""" Save(this::ByRef1{TF1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TF1::SetChisquare(Double_t)
@trydoc raw"""
    SetChisquare(this::ByRef1{TF1}, chi2::Float64)::Nothing


""" SetChisquare(this::ByRef1{TF1}, chi2::Float64)

# Wrapper of void TF1::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TF1}, maximum::Float64)::Nothing
Set the maximum value along Y for this function In case the function is already drawn, set also the maximum in the helper histogram.

""" SetMaximum(this::ByRef1{TF1}, maximum::Float64)

# Wrapper of void TF1::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TF1}, minimum::Float64)::Nothing
Set the minimum value along Y for this function In case the function is already drawn, set also the minimum in the helper histogram.

""" SetMinimum(this::ByRef1{TF1}, minimum::Float64)

# Wrapper of void TF1::SetNDF(Int_t)
@trydoc raw"""
    SetNDF(this::ByRef1{TF1}, ndf::Int32)::Nothing
Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of free parameters.

""" SetNDF(this::ByRef1{TF1}, ndf::Int32)

# Wrapper of void TF1::SetNormalized(Bool_t)
@trydoc raw"""
    SetNormalized(this::ByRef1{TF1}, flag::Bool)::Nothing


""" SetNormalized(this::ByRef1{TF1}, flag::Bool)

# Wrapper of void TF1::SetNpx(Int_t)
@trydoc raw"""
    SetNpx(this::ByRef1{TF1}, npx::Int32)::Nothing
Set the number of points used to draw the function.
The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions You can increase this value to get a better resolution when drawing pictures with sharp peaks or to get a better result when using [TF1!GetRandom](@ref) the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions
""" SetNpx(this::ByRef1{TF1}, npx::Int32)

# Wrapper of void TF1::SetNumberFitPoints(Int_t)
@trydoc raw"""
    SetNumberFitPoints(this::ByRef1{TF1}, npfits::Int32)::Nothing


""" SetNumberFitPoints(this::ByRef1{TF1}, npfits::Int32)

# Wrapper of void TF1::SetParameter(const TString &, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TF1::SetParameter(Int_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1}, param::Int32, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1}, param::Int32, value::Float64)

# Wrapper of void TF1::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1}, params::ByConstPtr2{Float64})::Nothing


""" SetParameters(this::ByRef1{TF1}, params::ByConstPtr2{Float64})

# Wrapper of void TF1::SetParameters(double, double, double, double, double, double, double, double, double, double, double)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)::Nothing
Set parameter values.
NaN values will be skipped, meaning that the corresponding parameters will not be changed.
""" SetParameters(this::ByRef1{TF1}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)

# Wrapper of void TF1::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TF1}, p::ByPtr1{TObject})::Nothing


""" SetParent(this::ByRef1{TF1}, p::ByPtr1{TObject})

# Wrapper of void TF1::SetParError(Int_t, Double_t)
@trydoc raw"""
    SetParError(this::ByRef1{TF1}, ipar::Int32, error::Float64)::Nothing
Set error for parameter number ipar.

""" SetParError(this::ByRef1{TF1}, ipar::Int32, error::Float64)

# Wrapper of void TF1::SetParErrors(const Double_t *)
@trydoc raw"""
    SetParErrors(this::ByRef1{TF1}, errors::ByConstPtr2{Float64})::Nothing
Set errors for all active parameters when calling this function, the array errors must have at least fNpar values.

""" SetParErrors(this::ByRef1{TF1}, errors::ByConstPtr2{Float64})

# Wrapper of void TF1::SetParLimits(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetParLimits(this::ByRef1{TF1}, ipar::Int32, parmin::Float64, parmax::Float64)::Nothing
Set lower and upper limits for parameter ipar.
The specified limits will be used in a fit operation. Note that when this function is a pre-defined function (e.g. gaus) one needs to use the fit option "B" to have the limits used in the fit. See [TH1!Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t)](@ref) for the fitting documentation and the [fitting options](@ref)

To fix a parameter, use [TF1!FixParameter](@ref)
""" SetParLimits(this::ByRef1{TF1}, ipar::Int32, parmin::Float64, parmax::Float64)

# Wrapper of void TF1::SetParName(Int_t, const char *)
@trydoc raw"""
    SetParName(this::ByRef1{TF1}, ipar::Int32, name::ByCopy{String})::Nothing
Set name of parameter number ipar.

""" SetParName(this::ByRef1{TF1}, ipar::Int32, name::ByCopy{String})

# Wrapper of void TF1::SetParNames(const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *)
@trydoc raw"""
    SetParNames(this::ByRef1{TF1}, name0::ByCopy{String}, name1::ByCopy{String}, name2::ByCopy{String}, name3::ByCopy{String}, name4::ByCopy{String}, name5::ByCopy{String}, name6::ByCopy{String}, name7::ByCopy{String}, name8::ByCopy{String}, name9::ByCopy{String}, name10::ByCopy{String})::Nothing
Set up to 10 parameter names.
Empty strings will be skipped, meaning that the corresponding name will not be changed.
""" SetParNames(this::ByRef1{TF1}, name0::ByCopy{String}, name1::ByCopy{String}, name2::ByCopy{String}, name3::ByCopy{String}, name4::ByCopy{String}, name5::ByCopy{String}, name6::ByCopy{String}, name7::ByCopy{String}, name8::ByCopy{String}, name9::ByCopy{String}, name10::ByCopy{String})

# Wrapper of void TF1::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1}, xmin::Float64, xmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.
The function range is also used in an histogram fit operation when the option "R" is specified.
""" SetRange(this::ByRef1{TF1}, xmin::Float64, xmax::Float64)

# Wrapper of void TF1::SetRange(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing


""" SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TF1::SetRange(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)::Nothing


""" SetRange(this::ByRef1{TF1}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)

# Wrapper of void TF1::SetSavedPoint(Int_t, Double_t)
@trydoc raw"""
    SetSavedPoint(this::ByRef1{TF1}, point::Int32, value::Float64)::Nothing
Restore value of function saved at point.

""" SetSavedPoint(this::ByRef1{TF1}, point::Int32, value::Float64)

# Wrapper of void TF1::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TF1}, title::ByCopy{String})::Nothing
Set function title if title has the form "fffffff;xxxx;yyyy", it is assumed that the function title is "fffffff" and "xxxx" and "yyyy" are the titles for the X and Y axis respectively.

""" SetTitle(this::ByRef1{TF1}, title::ByCopy{String})

# Wrapper of void TF1::SetVectorized(Bool_t)
@trydoc raw"""
    SetVectorized(this::ByRef1{TF1}, vectorized::Bool)::Nothing


""" SetVectorized(this::ByRef1{TF1}, vectorized::Bool)

# Wrapper of void TF1::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1})::Nothing
Called by functions such as SetRange, SetNpx, SetParameters to force the deletion of the associated histogram or Integral.

""" Update(this::ByRef1{TF1})

# Wrapper of Double_t TF1::Variance(Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    Variance(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)::Float64


""" Variance(this::ByRef1{TF1}, a::Float64, b::Float64, params::ByConstPtr2{Float64}, epsilon::Float64)

# Wrapper of void TF1::AbsValue(Bool_t)
@trydoc raw"""
    TF1!AbsValue(this::ByRef1{TF1}, reject::Bool)::Nothing
Static function: set the fgAbsValue flag.
By default [TF1!Integral](@ref) uses the original function value to compute the integral However, [TF1!Moment](@ref), CentralMoment require to compute the integral using the absolute value of the function.
""" TF1!AbsValue(this::ByRef1{TF1}, reject::Bool)

# Wrapper of void TF1::CalcGaussLegendreSamplingPoints(Int_t, Double_t *, Double_t *, Double_t)
@trydoc raw"""
    TF1!CalcGaussLegendreSamplingPoints(this::ByRef1{TF1}, num::Int32, x::ByPtr2{Float64}, w::ByPtr2{Float64}, eps::Float64)::Nothing
Type safe interface (static method) The number of sampling points are taken from the [TGraph](@ref).
Type: unsafe but fast interface filling the arrays x and w (static method)

Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.

Gauss-Legendre: 

``W(x)=1  -1<x<1 \\
      (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}``

 num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision

If num<=0 or eps<=0 no action is done.

Reference: Numerical Recipes in C, Second Edition
""" TF1!CalcGaussLegendreSamplingPoints(this::ByRef1{TF1}, num::Int32, x::ByPtr2{Float64}, w::ByPtr2{Float64}, eps::Float64)

# Wrapper of Bool_t TF1::DefaultAddToGlobalList(Bool_t)
@trydoc raw"""
    TF1!DefaultAddToGlobalList(this::ByRef1{TF1}, on::Bool)::Bool
Static method to add/avoid to add automatically functions to the global_ list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour.
By default the functions are added automatically It returns the previous status (true if the functions are added automatically)
""" TF1!DefaultAddToGlobalList(this::ByRef1{TF1}, on::Bool)

# Wrapper of Double_t TF1::DerivativeError()
@trydoc raw"""
    TF1!DerivativeError(this::ByRef1{TF1})::Float64
Static function returning the error of the last call to the of Derivative's functions.

""" TF1!DerivativeError(this::ByRef1{TF1})

# Wrapper of TF1 * TF1::GetCurrent()
@trydoc raw"""
    TF1!GetCurrent(this::ByRef1{TF1})::CxxPtr1{TF1}
Static function returning the current function being processed.

""" TF1!GetCurrent(this::ByRef1{TF1})

# Wrapper of void TF1::InitStandardFunctions()
@trydoc raw"""
    TF1!InitStandardFunctions(this::ByRef1{TF1})::Nothing
Create the basic function objects.

""" TF1!InitStandardFunctions(this::ByRef1{TF1})

# Wrapper of Bool_t TF1::RejectedPoint()
@trydoc raw"""
    TF1!RejectedPoint(this::ByRef1{TF1})::Bool
See [TF1!RejectPoint](@ref) above.

""" TF1!RejectedPoint(this::ByRef1{TF1})

# Wrapper of void TF1::RejectPoint(Bool_t)
@trydoc raw"""
    TF1!RejectPoint(this::ByRef1{TF1}, reject::Bool)::Nothing
Static function to set the global_ flag to reject points the fgRejectPoint global_ flag is tested by all fit functions if TRUE the point is not included in the fit.
This flag can be set by a user in a fitting function. The fgRejectPoint flag is reset by the [TH1](@ref) and [TGraph](@ref) fitting functions.
""" TF1!RejectPoint(this::ByRef1{TF1}, reject::Bool)

# Wrapper of void TF1::SetCurrent(TF1 *)
@trydoc raw"""
    TF1!SetCurrent(this::ByRef1{TF1}, f1::ByPtr1{TF1})::Nothing
Static function setting the current function.
the current function may be accessed in static C-like functions when fitting or painting a function.
""" TF1!SetCurrent(this::ByRef1{TF1}, f1::ByPtr1{TF1})

# Wrapper of void TGraph::AddPoint(Double_t, Double_t)
@trydoc raw"""
    AddPoint(this::ByRef1{TGraph}, x::Float64, y::Float64)::Nothing
Append a new point to the graph.

""" AddPoint(this::ByRef1{TGraph}, x::Float64, y::Float64)

# Wrapper of void TGraph::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraph}, f::ByPtr1{TF1})::Nothing
Apply function f to all the data points f may be a 1-D function [TF1](@ref) or 2-d function [TF2](@ref) The Y values of the graph are replaced by the new values computed using the function.

""" Apply(this::ByRef1{TGraph}, f::ByPtr1{TF1})

# Wrapper of void TGraph::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGraph}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TGraph}, b::ByPtr1{TBrowser})

# Wrapper of Double_t TGraph::Chisquare(TF1 *, Option_t *)
@trydoc raw"""
    Chisquare(this::ByConstRef1{TGraph}, f1::ByPtr1{TF1}, option::ByCopy{String})::Float64
Return the chisquare of this graph with respect to f1.
The chisquare is computed as the sum of the quantity below at each point: 

``\frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}``

 where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x). This method to approximate the uncertainty in y because of the errors in x, is called "effective variance" method. In case of a pure [TGraph](@ref), the denominator is 1. In case of a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref) the errors are taken into account. By default the range of the graph is used whatever function range. Use option "R" to use the function range
""" Chisquare(this::ByConstRef1{TGraph}, f1::ByPtr1{TF1}, option::ByCopy{String})

# Wrapper of void TGraph::ComputeRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    ComputeRange(this::ByConstRef1{TGraph}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Compute the x/y range of the points in this graph.

""" ComputeRange(this::ByConstRef1{TGraph}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of Int_t TGraph::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGraph}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a graph.
Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TGraph}, px::Int32, py::Int32)

# Wrapper of void TGraph::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGraph}, chopt::ByCopy{String})::Nothing
Draw this graph with its current attributes.
The options to draw a graph are described in [TGraphPainter](@ref) class.
""" Draw(this::ByRef1{TGraph}, chopt::ByCopy{String})

# Wrapper of void TGraph::DrawGraph(Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, option::ByCopy{String})::Nothing
Draw this graph with new attributes.

""" DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TGraph::DrawGraph(Int_t, const Float_t *, const Float_t *, Option_t *)
@trydoc raw"""
    DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32}, option::ByCopy{String})::Nothing
Draw this graph with new attributes.

""" DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Float32}, y::ByConstPtr2{Float32}, option::ByCopy{String})

# Wrapper of void TGraph::DrawGraph(Int_t, const Int_t *, const Int_t *, Option_t *)
@trydoc raw"""
    DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Int32}, y::ByConstPtr2{Int32}, option::ByCopy{String})::Nothing
Draw this graph with new attributes.

""" DrawGraph(this::ByRef1{TGraph}, n::Int32, x::ByConstPtr2{Int32}, y::ByConstPtr2{Int32}, option::ByCopy{String})

# Wrapper of void TGraph::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TGraph})::Nothing
Display a panel with all graph drawing options.

""" DrawPanel(this::ByRef1{TGraph})

# Wrapper of Double_t TGraph::Eval(Double_t, TSpline *, Option_t *)
@trydoc raw"""
    Eval(this::ByConstRef1{TGraph}, x::Float64, spline::ByPtr1{TSpline}, option::ByCopy{String})::Float64
Interpolate points in this graph at x using a [TSpline](@ref).
- if spline==0 and option="" a linear interpolation between the two points close to x is computed. If x is outside the graph range, a linear extrapolation is computed.
- if spline==0 and option="S" a [TSpline3](@ref) object is created using this graph and the interpolated value from the spline is returned. the internally created spline is deleted on return.
- if spline is specified, it is used to return the interpolated value.

    If the points are sorted in X a binary search is used (significantly faster) One needs to set the bit TGraph!SetBit(TGraph!kIsSortedX) before calling [TGraph!Eval](@ref) to indicate that the graph is sorted in X.
""" Eval(this::ByConstRef1{TGraph}, x::Float64, spline::ByPtr1{TSpline}, option::ByCopy{String})

# Wrapper of void TGraph::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGraph}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a graph is clicked with the locator

If Left button clicked on one of the line theend points, this point follows the cursor until button is released.

if Middle button clicked, the line is moved parallel to itself until the button is released.
""" ExecuteEvent(this::ByRef1{TGraph}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TGraph::Expand(Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TGraph}, newsize::Int32)::Nothing
If array sizes <= newsize, expand storage to 2*newsize.

""" Expand(this::ByRef1{TGraph}, newsize::Int32)

# Wrapper of void TGraph::Expand(Int_t, Int_t)
@trydoc raw"""
    Expand(this::ByRef1{TGraph}, newsize::Int32, step::Int32)::Nothing
If graph capacity is less than newsize points then make array sizes equal to least multiple of step to contain newsize points.

""" Expand(this::ByRef1{TGraph}, newsize::Int32, step::Int32)

# Wrapper of TObject * TGraph::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TGraph}, name::ByCopy{String})::CxxPtr1{TObject}
Search object named name in the list of functions.

""" FindObject(this::ByConstRef1{TGraph}, name::ByCopy{String})

# Wrapper of TObject * TGraph::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TGraph}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
Search object obj in the list of functions.

""" FindObject(this::ByConstRef1{TGraph}, obj::ByConstPtr1{TObject})

# Wrapper of TFitResultPtr TGraph::Fit(const char *, Option_t *, Option_t *, Axis_t, Axis_t)
@trydoc raw"""
    Fit(this::ByRef1{TGraph}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit this graph with function with name `fname`.
This is a different interface to [TGraph](@ref) fitting using [TGraph!Fit(TF1 *f1,Option_t *, Option_t *, Axis_t, Axis_t)](@ref) See there for the details about fitting a [TGraph](@ref).

The parameter `fname` is the name of an already predefined function created by [TF1](@ref) or [TF2](@ref) Predefined functions such as gaus, expo and poln are automatically created by [ROOT](@ref).

The parameter `fname` can also be a formula, accepted by the linear fitter (linear parts divided by "++" sign), for example "x++sin(x)" for fitting "[0]*x+[1]*sin(x)"
""" Fit(this::ByRef1{TGraph}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of TFitResultPtr TGraph::Fit(TF1 *, Option_t *, Option_t *, Axis_t, Axis_t)
@trydoc raw"""
    Fit(this::ByRef1{TGraph}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)::ByCopy{TFitResultPtr}
Fit this graph with function f1.
## Arguments

- **`f1`** [in] 
    pointer to the function object 
    
- **`option`** [in] 
    string defining the fit options (see table below). 
    
- **`goption`** [in] 
    specify a list of graphics options. See [TGraph!Draw](@ref) and [TGraphPainter](@ref) for a complete list of these possible options. 
    
- **`rxmin`** [in] 
    lower fitting range 
    
- **`rxmax`** [in] 
    upper fitting range
    

### Graph Fitting Options

The list of fit options is given in parameter option.

| **option** | **description**                                                                                                                                                                                                                           |
|:-----------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "S"        | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT!Math!FitResult`.                                                         |
| "W"        | Ignore all point errors when fitting a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref)                                                                                                                                                  |
| "F"        | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.                                                                                                                         |
| "U"        | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter!SetFCN`                                                                                                                    |
| "E"        | Performs a better parameter errors estimation using the Minos technique for all fit parameters.                                                                                                                                           |
| "M"        | Uses the IMPROVE algorithm (available only in [TMinuit](@ref)). This algorithm attempts improve the found local_ minimum by searching for a better one.                                                                                   |
| "Q"        | Quiet mode (minimum printing)                                                                                                                                                                                                             |
| "V"        | Verbose mode (default is between Q and V)                                                                                                                                                                                                 |
| "+"        | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.                                                                                                |
| "N"        | Does not store the graphics function, does not draw the histogram with the function after fitting.                                                                                                                                        |
| "0"        | Does not draw the histogram and the fitted function after fitting, but in contrast to option "N", it stores the fitted function in the histogram list of functions.                                                                       |
| "R"        | Fit using a fitting range specified in the function range with `TF1!SetRange`.                                                                                                                                                            |
| "B"        | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.                 |
| "C"        | In case of linear fitting, do no calculate the chisquare (saves CPU time).                                                                                                                                                                |
| "G"        | Uses the gradient implemented in `TF1!GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided [TF1](@ref) function.                                                          |
| "EX0"      | When fitting a [TGraphErrors](@ref) or TGraphAsymErrors do not consider errors in the X coordinates                                                                                                                                       |
| "ROB"      | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points "ROB=0.x" - compute the LTS regression coefficients, using 0.x as a fraction of good points |

This function is used for fitting also the derived [TGraph](@ref) classes such as [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref). See the note below on how the errors are used when fitting a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref).

The fitting of the [TGraph](@ref), i.e simple data points without any error associated, is performed using the un-weighted least-square (chi-square) method.

### TGraphErrors fit:

In case of a [TGraphErrors](@ref) or [TGraphAsymmErrors](@ref) object, when `x` errors are present, the error along x, is projected along the y-direction by calculating the function at the points `x-ex_low` and `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x. The chi-square is then computed as the sum of the quantity below at each data point:

``\frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}``

where `x` and `y` are the point coordinates, and 'f'(x)`is the derivative of the function`[f(x)](@ref)`.

In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).

The approach used to approximate the uncertainty in y because of the errors in x is to make it equal the error in x times the slope of the line. This approach is called "effective variance method" and the implementation is provided in the function FitUtil!EvaluateChi2Effective

### Linear fitting:

When the fitting function is linear (contains the `++` sign) or the fitting function is a polynomial, a linear fitter is initialised. To create a linear function, use the following syntax: linear parts separated by `++` sign. Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a [TF1](@ref) object as 
```
TF1 *f1 = new TF1("f1", "x++sin(x)", xmin, xmax);
```  For such a [TF1](@ref) you don't have to set the initial conditions and the linear fitter is used. Going via the linear fitter for functions, linear in parameters, gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`. See the tutorial `fitLinearRobust.C`.

### Notes on TGraph/TGraphErrors Fitting:

1. By using the "effective variance" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.
2. The effective variance technique assumes that there is no correlation between the x and y coordinate.
3. The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option "EX0"
4. The linear fitter doesn't take into account the errors in x. When fitting a [TGraphErrors](@ref) with a linear functions the errors in x will not be considered. If errors in x are important, use option "F" for linear function fitting.
5. When fitting a [TGraph](@ref) (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: `parameter_error *= sqrt(chisquare/(ndf-1))`

### General Fitting documentation

See in [TH1!Fit](@ref) for the documentation of

- [Fit Result](@ref)
- [Fit Status](@ref)
- [Fit Statistics Box](@ref)
- [Fitting in a Range](@ref)
- [Setting Initial Conditions](@ref)
""" Fit(this::ByRef1{TGraph}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::FitPanel()
@trydoc raw"""
    FitPanel(this::ByRef1{TGraph})::Nothing
Display a GUI panel with all graph fit options.
See class [TFitEditor](@ref) for example
""" FitPanel(this::ByRef1{TGraph})

# Wrapper of Double_t TGraph::GetCorrelationFactor()
@trydoc raw"""
    GetCorrelationFactor(this::ByConstRef1{TGraph})::Float64
Return graph correlation factor.

""" GetCorrelationFactor(this::ByConstRef1{TGraph})

# Wrapper of Double_t TGraph::GetCovariance()
@trydoc raw"""
    GetCovariance(this::ByConstRef1{TGraph})::Float64
Return covariance of vectors x,y.

""" GetCovariance(this::ByConstRef1{TGraph})

# Wrapper of Bool_t TGraph::GetEditable()
@trydoc raw"""
    GetEditable(this::ByConstRef1{TGraph})::Bool
Return kTRUE if kNotEditable bit is not set, kFALSE otherwise.

""" GetEditable(this::ByConstRef1{TGraph})

# Wrapper of Double_t TGraph::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraph}, bin::Int32)::Float64
It always returns a negative value. Real implementation in [TGraphErrors](@ref).

""" GetErrorX(this::ByConstRef1{TGraph}, bin::Int32)

# Wrapper of Double_t TGraph::GetErrorXhigh(Int_t)
@trydoc raw"""
    GetErrorXhigh(this::ByConstRef1{TGraph}, bin::Int32)::Float64
It always returns a negative value.
Real implementation in [TGraphErrors](@ref) and [TGraphAsymmErrors](@ref)
""" GetErrorXhigh(this::ByConstRef1{TGraph}, bin::Int32)

# Wrapper of Double_t TGraph::GetErrorXlow(Int_t)
@trydoc raw"""
    GetErrorXlow(this::ByConstRef1{TGraph}, bin::Int32)::Float64
It always returns a negative value.
Real implementation in [TGraphErrors](@ref) and [TGraphAsymmErrors](@ref)
""" GetErrorXlow(this::ByConstRef1{TGraph}, bin::Int32)

# Wrapper of Double_t TGraph::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraph}, bin::Int32)::Float64
It always returns a negative value. Real implementation in [TGraphErrors](@ref).

""" GetErrorY(this::ByConstRef1{TGraph}, bin::Int32)

# Wrapper of Double_t TGraph::GetErrorYhigh(Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraph}, bin::Int32)::Float64
It always returns a negative value.
Real implementation in [TGraphErrors](@ref) and [TGraphAsymmErrors](@ref)
""" GetErrorYhigh(this::ByConstRef1{TGraph}, bin::Int32)

# Wrapper of Double_t TGraph::GetErrorYlow(Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraph}, bin::Int32)::Float64
It always returns a negative value.
Real implementation in [TGraphErrors](@ref) and [TGraphAsymmErrors](@ref)
""" GetErrorYlow(this::ByConstRef1{TGraph}, bin::Int32)

# Wrapper of Double_t * TGraph::GetEX()
@trydoc raw"""
    GetEX(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEX(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEXhigh()
@trydoc raw"""
    GetEXhigh(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEXhigh(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEXhighd()
@trydoc raw"""
    GetEXhighd(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEXhighd(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEXlow()
@trydoc raw"""
    GetEXlow(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEXlow(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEXlowd()
@trydoc raw"""
    GetEXlowd(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEXlowd(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEY()
@trydoc raw"""
    GetEY(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEY(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEYhigh()
@trydoc raw"""
    GetEYhigh(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEYhigh(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEYhighd()
@trydoc raw"""
    GetEYhighd(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEYhighd(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEYlow()
@trydoc raw"""
    GetEYlow(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEYlow(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetEYlowd()
@trydoc raw"""
    GetEYlowd(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetEYlowd(this::ByConstRef1{TGraph})

# Wrapper of TF1 * TGraph::GetFunction(const char *)
@trydoc raw"""
    GetFunction(this::ByConstRef1{TGraph}, name::ByCopy{String})::CxxPtr1{TF1}
Return pointer to function with name.
Functions such as [TGraph!Fit](@ref) store the fitted function in the list of functions of this graph.
""" GetFunction(this::ByConstRef1{TGraph}, name::ByCopy{String})

# Wrapper of TH1F * TGraph::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByConstRef1{TGraph})::CxxPtr1{TH1F}
Returns a pointer to the histogram used to draw the axis Takes into account the two following cases.
1. option 'A' was specified in [TGraph!Draw](@ref). Return fHistogram
2. user had called [TPad!DrawFrame](@ref). return pointer to hframe histogram
""" GetHistogram(this::ByConstRef1{TGraph})

# Wrapper of TList * TGraph::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByConstRef1{TGraph})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByConstRef1{TGraph})

# Wrapper of Double_t TGraph::GetMaximum()
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TGraph})::Float64


""" GetMaximum(this::ByConstRef1{TGraph})

# Wrapper of Int_t TGraph::GetMaxSize()
@trydoc raw"""
    GetMaxSize(this::ByConstRef1{TGraph})::Int32


""" GetMaxSize(this::ByConstRef1{TGraph})

# Wrapper of Double_t TGraph::GetMean(Int_t)
@trydoc raw"""
    GetMean(this::ByConstRef1{TGraph}, axis::Int32)::Float64
Return mean value of X (axis=1) or Y (axis=2)

""" GetMean(this::ByConstRef1{TGraph}, axis::Int32)

# Wrapper of Double_t TGraph::GetMinimum()
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TGraph})::Float64


""" GetMinimum(this::ByConstRef1{TGraph})

# Wrapper of Int_t TGraph::GetN()
@trydoc raw"""
    GetN(this::ByConstRef1{TGraph})::Int32


""" GetN(this::ByConstRef1{TGraph})

# Wrapper of char * TGraph::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TGraph}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Implementation to get information on point of graph at cursor position Adapted from class [TH1](@ref).

""" GetObjectInfo(this::ByConstRef1{TGraph}, px::Int32, py::Int32)

# Wrapper of Int_t TGraph::GetPoint(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetPoint(this::ByConstRef1{TGraph}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})::Int32
Get x and y values for point number i.
The function returns -1 in case of an invalid request or the point number otherwise
""" GetPoint(this::ByConstRef1{TGraph}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of Double_t TGraph::GetPointX(Int_t)
@trydoc raw"""
    GetPointX(this::ByConstRef1{TGraph}, i::Int32)::Float64
Get x value for point i.

""" GetPointX(this::ByConstRef1{TGraph}, i::Int32)

# Wrapper of Double_t TGraph::GetPointY(Int_t)
@trydoc raw"""
    GetPointY(this::ByConstRef1{TGraph}, i::Int32)::Float64
Get y value for point i.

""" GetPointY(this::ByConstRef1{TGraph}, i::Int32)

# Wrapper of Double_t TGraph::GetRMS(Int_t)
@trydoc raw"""
    GetRMS(this::ByConstRef1{TGraph}, axis::Int32)::Float64
Return RMS of X (axis=1) or Y (axis=2)

""" GetRMS(this::ByConstRef1{TGraph}, axis::Int32)

# Wrapper of Double_t * TGraph::GetX()
@trydoc raw"""
    GetX(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetX(this::ByConstRef1{TGraph})

# Wrapper of TAxis * TGraph::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByConstRef1{TGraph})::CxxPtr1{TAxis}
Get x axis of the graph.

""" GetXaxis(this::ByConstRef1{TGraph})

# Wrapper of Double_t * TGraph::GetY()
@trydoc raw"""
    GetY(this::ByConstRef1{TGraph})::CxxPtr2{Float64}


""" GetY(this::ByConstRef1{TGraph})

# Wrapper of TAxis * TGraph::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByConstRef1{TGraph})::CxxPtr1{TAxis}
Get y axis of the graph.

""" GetYaxis(this::ByConstRef1{TGraph})

# Wrapper of void TGraph::InitExpo(Double_t, Double_t)
@trydoc raw"""
    InitExpo(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)::Nothing
Compute Initial values of parameters for an exponential.

""" InitExpo(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::InitGaus(Double_t, Double_t)
@trydoc raw"""
    InitGaus(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)::Nothing
Compute Initial values of parameters for a gaussian.

""" InitGaus(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::InitPolynom(Double_t, Double_t)
@trydoc raw"""
    InitPolynom(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)::Nothing
Compute Initial values of parameters for a polynom.

""" InitPolynom(this::ByRef1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of Int_t TGraph::InsertPoint()
@trydoc raw"""
    InsertPoint(this::ByRef1{TGraph})::Int32
Insert a new point at the mouse position.

""" InsertPoint(this::ByRef1{TGraph})

# Wrapper of void TGraph::InsertPointBefore(Int_t, Double_t, Double_t)
@trydoc raw"""
    InsertPointBefore(this::ByRef1{TGraph}, ipoint::Int32, x::Float64, y::Float64)::Nothing
Insert a new point with coordinates (x,y) before the point number `ipoint`.

""" InsertPointBefore(this::ByRef1{TGraph}, ipoint::Int32, x::Float64, y::Float64)

# Wrapper of Double_t TGraph::Integral(Int_t, Int_t)
@trydoc raw"""
    Integral(this::ByConstRef1{TGraph}, first::Int32, last::Int32)::Float64
Integrate the [TGraph](@ref) data within a given (index) range.
Note that this function computes the area of the polygon enclosed by the points of the [TGraph](@ref). The polygon segments, which are defined by the points of the [TGraph](@ref), do not need to form a closed polygon, since the last polygon segment, which closes the polygon, is taken as the line connecting the last [TGraph](@ref) point with the first one. It is clear that the order of the point is essential in defining the polygon. Also note that the segments should not intersect.

NB:

- if last=-1 (default) last is set to the last point.
- if (first <0) the first point (0) is taken.

### Method:

There are many ways to calculate the surface of a polygon. It all depends on what kind of data you have to deal with. The most evident solution would be to divide the polygon in triangles and calculate the surface of them. But this can quickly become complicated as you will have to test every segments of every triangles and check if they are intersecting with a current polygon's segment or if it goes outside the polygon. Many calculations that would lead to many problems...

### The solution (implemented by R.Brun)

Fortunately for us, there is a simple way to solve this problem, as long as the polygon's segments don't intersect. It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.

### Sources

- [http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html](http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html)
- [http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon](http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon)
""" Integral(this::ByConstRef1{TGraph}, first::Int32, last::Int32)

# Wrapper of Bool_t TGraph::IsEditable()
@trydoc raw"""
    IsEditable(this::ByConstRef1{TGraph})::Bool


""" IsEditable(this::ByConstRef1{TGraph})

# Wrapper of Bool_t TGraph::IsHighlight()
@trydoc raw"""
    IsHighlight(this::ByConstRef1{TGraph})::Bool


""" IsHighlight(this::ByConstRef1{TGraph})

# Wrapper of Int_t TGraph::IsInside(Double_t, Double_t)
@trydoc raw"""
    IsInside(this::ByConstRef1{TGraph}, x::Float64, y::Float64)::Int32
Return 1 if the point (x,y) is inside the polygon defined by the graph vertices 0 otherwise.
Algorithm:

The loop is executed with the theend-point coordinates of a line segment (X1,Y1)-(X2,Y2) and the Y-coordinate of a horizontal line. The counter inter is incremented if the line (X1,Y1)-(X2,Y2) intersects the horizontal line. In this case XINT is set to the X-coordinate of the intersection point. If inter is an odd number, then the point x,y is within the polygon.
""" IsInside(this::ByConstRef1{TGraph}, x::Float64, y::Float64)

# Wrapper of void TGraph::LeastSquareFit(Int_t, Double_t *, Double_t, Double_t)
@trydoc raw"""
    LeastSquareFit(this::ByRef1{TGraph}, m::Int32, a::ByPtr2{Float64}, xmin::Float64, xmax::Float64)::Nothing
Least squares polynomial fitting without weights.
## Arguments

- **`m`** [in] 
    number of parameters 
    
- **`a`** [in] 
    array of parameters 
    
- **`xmin`** [in] 
    1st point number to fit (default =0) 
    
- **`xmax`** [in] 
    last point number to fit (default=fNpoints-1)
    

based on CERNLIB routine LSQ: Translated to C++ by Rene Brun
""" LeastSquareFit(this::ByRef1{TGraph}, m::Int32, a::ByPtr2{Float64}, xmin::Float64, xmax::Float64)

# Wrapper of void TGraph::LeastSquareLinearFit(Int_t, Double_t &, Double_t &, Int_t &, Double_t, Double_t)
@trydoc raw"""
    LeastSquareLinearFit(this::ByRef1{TGraph}, n::Int32, a0::ByRef2{Float64}, a1::ByRef2{Float64}, ifail::ByRef2{Int32}, xmin::Float64, xmax::Float64)::Nothing
Least square linear fit without weights.
Fit a straight line (a0 + a1*x) to the data in this graph.

## Arguments

- **`ndata`** [in], **`a0`** [in], **`a1`** [in], **`ifail`** [in], **`xmin`** [in], **`xmax`** [in] 
    if ndata<0, fits the logarithm of the graph (used in [InitExpo()](@ref) to set the initial parameter values for a fit with exponential function. 
    . 
    constant 
    . 
    slope 
    . 
    return parameter indicating the status of the fit (ifail=0, fit is OK) 
    . 
    fitting range
    

extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun
""" LeastSquareLinearFit(this::ByRef1{TGraph}, n::Int32, a0::ByRef2{Float64}, a1::ByRef2{Float64}, ifail::ByRef2{Int32}, xmin::Float64, xmax::Float64)

# Wrapper of Int_t TGraph::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TGraph}, list::ByPtr1{TCollection})::Int32
Adds all graphs from the collection to this graph.
Returns the total number of points in the result or -1 in case of an error.
""" Merge(this::ByRef1{TGraph}, list::ByPtr1{TCollection})

# Wrapper of void TGraph::MovePoints(Double_t, Double_t, Bool_t, Bool_t)
@trydoc raw"""
    MovePoints(this::ByRef1{TGraph}, dx::Float64, dy::Float64, logx::Bool, logy::Bool)::Nothing
Move all graph points on specified values dx,dy If log argument specified, calculation done in logarithmic scale like: new_value = exp( log(old_value) + delta );.

""" MovePoints(this::ByRef1{TGraph}, dx::Float64, dy::Float64, logx::Bool, logy::Bool)

# Wrapper of TGraph & TGraph::operator=(const TGraph &)
@trydoc raw"""
    assign(this::ByRef1{TGraph}, ::ByConstRef1{TGraph})::CxxRef1{TGraph}
Equal operator for this graph.

""" assign(this::ByRef1{TGraph}, ::ByConstRef1{TGraph})

# Wrapper of void TGraph::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGraph}, chopt::ByCopy{String})::Nothing
Draw this graph with its current attributes.

""" Paint(this::ByRef1{TGraph}, chopt::ByCopy{String})

# Wrapper of void TGraph::PaintGraph(Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGraph(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing
Draw the (x,y) as a graph.

""" PaintGraph(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TGraph::PaintGrapHist(Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGrapHist(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing
Draw the (x,y) as a histogram.

""" PaintGrapHist(this::ByRef1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TGraph::PaintStats(TF1 *)
@trydoc raw"""
    PaintStats(this::ByRef1{TGraph}, fit::ByPtr1{TF1})::Nothing
Draw the stats.

""" PaintStats(this::ByRef1{TGraph}, fit::ByPtr1{TF1})

# Wrapper of void TGraph::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraph}, chopt::ByCopy{String})::Nothing
Print graph values.

""" Print(this::ByConstRef1{TGraph}, chopt::ByCopy{String})

# Wrapper of void TGraph::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{TGraph}, obj::ByPtr1{TObject})::Nothing
Recursively remove object from the list of functions.

""" RecursiveRemove(this::ByRef1{TGraph}, obj::ByPtr1{TObject})

# Wrapper of Int_t TGraph::RemovePoint()
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph})::Int32
Delete point close to the mouse position Returns index of removed point (or -1 if nothing was changed)

""" RemovePoint(this::ByRef1{TGraph})

# Wrapper of Int_t TGraph::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph}, ipoint::Int32)::Int32
Delete point number ipoint Returns index of removed point (or -1 if nothing was changed)

""" RemovePoint(this::ByRef1{TGraph}, ipoint::Int32)

# Wrapper of void TGraph::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TGraph}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save the graph as .csv, .tsv or .txt.
In case of any other extension, fall back to [TObject!SaveAs](@ref)

The result can be immediately imported into Excel, gnuplot, Python or whatever, without the needing to install pyroot, etc.

## Arguments

- **`filename`** 
    the name of the file where to store the graph 
    
- **`option`** 
    some tuning options
    

The file extension defines the delimiter used:

- `.csv` : comma
- `.tsv` : tab
- `.txt` : space

If option = "title" a title line is generated with the axis titles.
""" SaveAs(this::ByConstRef1{TGraph}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TGraph::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values of a [TGraph](@ref) by a constant c1.
If option contains "x" the x values are scaled If option contains "y" the y values are scaled If option contains "xy" both x and y values are scaled
""" Scale(this::ByRef1{TGraph}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph}, n::Int32)::Nothing
Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints are preset to 0.

""" Set(this::ByRef1{TGraph}, n::Int32)

# Wrapper of void TGraph::SetEditable(Bool_t)
@trydoc raw"""
    SetEditable(this::ByRef1{TGraph}, editable::Bool)::Nothing
if editable=kFALSE, the graph cannot be modified with the mouse by default a [TGraph](@ref) is editable

""" SetEditable(this::ByRef1{TGraph}, editable::Bool)

# Wrapper of void TGraph::SetHighlight(Bool_t)
@trydoc raw"""
    SetHighlight(this::ByRef1{TGraph}, set::Bool)::Nothing
Set highlight (enable/disable) mode for the graph by default highlight mode is disable.

""" SetHighlight(this::ByRef1{TGraph}, set::Bool)

# Wrapper of void TGraph::SetHistogram(TH1F *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TGraph}, h::ByPtr1{TH1F})::Nothing


""" SetHistogram(this::ByRef1{TGraph}, h::ByPtr1{TH1F})

# Wrapper of void TGraph::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TGraph}, maximum::Float64)::Nothing
Set the maximum of the graph.

""" SetMaximum(this::ByRef1{TGraph}, maximum::Float64)

# Wrapper of void TGraph::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TGraph}, minimum::Float64)::Nothing
Set the minimum of the graph.

""" SetMinimum(this::ByRef1{TGraph}, minimum::Float64)

# Wrapper of void TGraph::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TGraph}, name::ByCopy{String})::Nothing
Set graph name.

""" SetName(this::ByRef1{TGraph}, name::ByCopy{String})

# Wrapper of void TGraph::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TGraph}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Set graph name and title.

""" SetNameTitle(this::ByRef1{TGraph}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TGraph::SetOption(Option_t *)
@trydoc raw"""
    SetOption(this::ByRef1{TGraph}, option::ByCopy{String})::Nothing


""" SetOption(this::ByRef1{TGraph}, option::ByCopy{String})

# Wrapper of void TGraph::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph}, i::Int32, x::Float64, y::Float64)::Nothing
Set x and y values for point number i.

""" SetPoint(this::ByRef1{TGraph}, i::Int32, x::Float64, y::Float64)

# Wrapper of void TGraph::SetPointX(Int_t, Double_t)
@trydoc raw"""
    SetPointX(this::ByRef1{TGraph}, i::Int32, x::Float64)::Nothing
Set x value for point i.

""" SetPointX(this::ByRef1{TGraph}, i::Int32, x::Float64)

# Wrapper of void TGraph::SetPointY(Int_t, Double_t)
@trydoc raw"""
    SetPointY(this::ByRef1{TGraph}, i::Int32, y::Float64)::Nothing
Set y value for point i.

""" SetPointY(this::ByRef1{TGraph}, i::Int32, y::Float64)

# Wrapper of void TGraph::SetStats(Bool_t)
@trydoc raw"""
    SetStats(this::ByRef1{TGraph}, stats::Bool)::Nothing
Set statistics option on/off.
By default, the statistics box is drawn. The paint options can be selected via gStyle->SetOptStat. This function sets/resets the kNoStats bit in the graph object. It has priority over the Style option.
""" SetStats(this::ByRef1{TGraph}, stats::Bool)

# Wrapper of void TGraph::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TGraph}, title::ByCopy{String})::Nothing
Change (i.e.
set) the title

if title is in the form `stringt;stringx;stringy;stringz` the graph title is set to `stringt`, the x axis title to `stringx`, the y axis title to `stringy`, and the z axis title to `stringz`.

To insert the character `;` in one of the titles, one should use `#;` or `#semicolon`.
""" SetTitle(this::ByRef1{TGraph}, title::ByCopy{String})

# Wrapper of void TGraph::UseCurrentStyle()
@trydoc raw"""
    UseCurrentStyle(this::ByRef1{TGraph})::Nothing
Set current style settings in this graph This function is called when either [TCanvas!UseCurrentStyle](@ref) or [TROOT!ForceStyle](@ref) have been invoked.

""" UseCurrentStyle(this::ByRef1{TGraph})

# Wrapper of void TGraph::Zero(Int_t &, Double_t, Double_t, Double_t, Double_t &, Double_t &, Int_t)
@trydoc raw"""
    Zero(this::ByRef1{TGraph}, k::ByRef2{Int32}, AZ::Float64, BZ::Float64, E2::Float64, X::ByRef2{Float64}, Y::ByRef2{Float64}, maxiterations::Int32)::Nothing
Find zero of a continuous function.
This function finds a real zero of the continuous real function Y(X) in a given interval (A,B). See accompanying notes for details of the argument list and calling sequence
""" Zero(this::ByRef1{TGraph}, k::ByRef2{Int32}, AZ::Float64, BZ::Float64, E2::Float64, X::ByRef2{Float64}, Y::ByRef2{Float64}, maxiterations::Int32)

# Wrapper of Bool_t TGraph::CompareArg(const TGraph *, Int_t, Int_t)
@trydoc raw"""
    TGraph!CompareArg(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)::Bool
Return kTRUE if point number "left"'s argument (angle with respect to positive x-axis) is bigger than that of point number "right".
Can be used by Sort.
""" TGraph!CompareArg(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)

# Wrapper of Bool_t TGraph::CompareRadius(const TGraph *, Int_t, Int_t)
@trydoc raw"""
    TGraph!CompareRadius(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)::Bool
Return kTRUE if point number "left"'s distance to origin is bigger than that of point number "right".
Can be used by Sort.
""" TGraph!CompareRadius(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)

# Wrapper of Bool_t TGraph::CompareX(const TGraph *, Int_t, Int_t)
@trydoc raw"""
    TGraph!CompareX(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)::Bool
Return kTRUE if fX[left] > fX[right]. Can be used by Sort.

""" TGraph!CompareX(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)

# Wrapper of Bool_t TGraph::CompareY(const TGraph *, Int_t, Int_t)
@trydoc raw"""
    TGraph!CompareY(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)::Bool
Return kTRUE if fY[left] > fY[right]. Can be used by Sort.

""" TGraph!CompareY(this::ByRef1{TGraph}, gr::ByConstPtr1{TGraph}, left::Int32, right::Int32)

# Wrapper of void TGraph2D::AddPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    AddPoint(this::ByRef1{TGraph2D}, x::Float64, y::Float64, z::Float64)::Nothing
Append a new point to the graph.

""" AddPoint(this::ByRef1{TGraph2D}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2D::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGraph2D}, ::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{TGraph2D}, ::ByPtr1{TBrowser})

# Wrapper of void TGraph2D::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGraph2D}, option::ByCopy{String})::Nothing
Free all memory allocated by this object.

""" Clear(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of void TGraph2D::DirectoryAutoAdd(TDirectory *)
@trydoc raw"""
    DirectoryAutoAdd(this::ByRef1{TGraph2D}, ::ByPtr1{TDirectory})::Nothing
Perform the automatic addition of the graph to the given directory.
Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a [TKey](@ref) or being Cloned)
""" DirectoryAutoAdd(this::ByRef1{TGraph2D}, ::ByPtr1{TDirectory})

# Wrapper of Int_t TGraph2D::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGraph2D}, px::Int32, py::Int32)::Int32
Computes distance from point px,py to a graph.

""" DistancetoPrimitive(this::ByRef1{TGraph2D}, px::Int32, py::Int32)

# Wrapper of void TGraph2D::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGraph2D}, option::ByCopy{String})::Nothing
Specific drawing options can be used to paint a [TGraph2D](@ref):
- "TRI" : The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color.
- "TRIW" : The Delaunay triangles are drawn as wire frame
- "TRI1" : The Delaunay triangles are painted with color levels. The edges of each triangles are painted with the current line color.
- "TRI2" : the Delaunay triangles are painted with color levels.
- "P" : Draw a marker at each vertex
- "P0" : Draw a circle at each vertex. Each circle background is white.
- "PCOL" : Draw a marker at each vertex. The color of each marker is defined according to its Z position.
- "CONT" : Draw contours
- "LINE" : Draw a 3D polyline

A [TGraph2D](@ref) can be also drawn with ANY options valid to draw a 2D histogram.

When a [TGraph2D](@ref) is drawn with one of the 2D histogram drawing option, a intermediate 2D histogram is filled using the Delaunay triangles technique to interpolate the data set.
""" Draw(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of void TGraph2D::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGraph2D}, event::Int32, px::Int32, py::Int32)::Nothing
Executes action corresponding to one event.

""" ExecuteEvent(this::ByRef1{TGraph2D}, event::Int32, px::Int32, py::Int32)

# Wrapper of TObject * TGraph2D::FindObject(const char *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TGraph2D}, name::ByCopy{String})::CxxPtr1{TObject}
search object named name in the list of functions

""" FindObject(this::ByConstRef1{TGraph2D}, name::ByCopy{String})

# Wrapper of TObject * TGraph2D::FindObject(const TObject *)
@trydoc raw"""
    FindObject(this::ByConstRef1{TGraph2D}, obj::ByConstPtr1{TObject})::CxxPtr1{TObject}
search object obj in the list of functions

""" FindObject(this::ByConstRef1{TGraph2D}, obj::ByConstPtr1{TObject})

# Wrapper of TFitResultPtr TGraph2D::Fit(const char *, Option_t *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TGraph2D}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String})::ByCopy{TFitResultPtr}
Fits this graph with function with name fname Predefined functions such as gaus, expo and poln are automatically created by [ROOT](@ref).
fname can also be a formula, accepted by the linear fitter (linear parts divided by "++" sign), for example "x++sin(y)" for fitting "[0]*x+[1]*sin(y)"
""" Fit(this::ByRef1{TGraph2D}, formula::ByCopy{String}, option::ByCopy{String}, goption::ByCopy{String})

# Wrapper of TFitResultPtr TGraph2D::Fit(TF2 *, Option_t *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TGraph2D}, f2::ByPtr1{TF2}, option::ByCopy{String}, goption::ByCopy{String})::ByCopy{TFitResultPtr}
Fits this 2D graph with function f2.
f2 is an already predefined function created by [TF2](@ref).

See [TGraph!Fit](@ref) for the available fitting options and fitting notes
""" Fit(this::ByRef1{TGraph2D}, f2::ByPtr1{TF2}, option::ByCopy{String}, goption::ByCopy{String})

# Wrapper of void TGraph2D::FitPanel()
@trydoc raw"""
    FitPanel(this::ByRef1{TGraph2D})::Nothing
Display a GUI panel with all graph fit options.
See class [TFitEditor](@ref) for example
""" FitPanel(this::ByRef1{TGraph2D})

# Wrapper of TList * TGraph2D::GetContourList(Double_t)
@trydoc raw"""
    GetContourList(this::ByRef1{TGraph2D}, contour::Float64)::CxxPtr1{TList}
Returns the X and Y graphs building a contour.
A contour level may consist in several parts not connected to each other. This function returns them in a graphs' list.
""" GetContourList(this::ByRef1{TGraph2D}, contour::Float64)

# Wrapper of TDirectory * TGraph2D::GetDirectory()
@trydoc raw"""
    GetDirectory(this::ByConstRef1{TGraph2D})::CxxPtr1{TDirectory}


""" GetDirectory(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraph2D}, bin::Int32)::Float64
This function is called by Graph2DFitChisquare.
It always returns a negative value. Real implementation in [TGraph2DErrors](@ref)
""" GetErrorX(this::ByConstRef1{TGraph2D}, bin::Int32)

# Wrapper of Double_t TGraph2D::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraph2D}, bin::Int32)::Float64
This function is called by Graph2DFitChisquare.
It always returns a negative value. Real implementation in [TGraph2DErrors](@ref)
""" GetErrorY(this::ByConstRef1{TGraph2D}, bin::Int32)

# Wrapper of Double_t TGraph2D::GetErrorZ(Int_t)
@trydoc raw"""
    GetErrorZ(this::ByConstRef1{TGraph2D}, bin::Int32)::Float64
This function is called by Graph2DFitChisquare.
It always returns a negative value. Real implementation in [TGraph2DErrors](@ref)
""" GetErrorZ(this::ByConstRef1{TGraph2D}, bin::Int32)

# Wrapper of Double_t * TGraph2D::GetEX()
@trydoc raw"""
    GetEX(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEX(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEXhigh()
@trydoc raw"""
    GetEXhigh(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEXhigh(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEXlow()
@trydoc raw"""
    GetEXlow(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEXlow(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEY()
@trydoc raw"""
    GetEY(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEY(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEYhigh()
@trydoc raw"""
    GetEYhigh(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEYhigh(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEYlow()
@trydoc raw"""
    GetEYlow(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEYlow(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEZ()
@trydoc raw"""
    GetEZ(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEZ(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEZhigh()
@trydoc raw"""
    GetEZhigh(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEZhigh(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetEZlow()
@trydoc raw"""
    GetEZlow(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetEZlow(this::ByConstRef1{TGraph2D})

# Wrapper of TH2D * TGraph2D::GetHistogram(Option_t *)
@trydoc raw"""
    GetHistogram(this::ByRef1{TGraph2D}, option::ByCopy{String})::CxxPtr1{TH2D}
By default returns a pointer to the Delaunay histogram.
If fHistogram doesn't exist, books the 2D histogram fHistogram with a margin around the hull. Calls [TGraphDelaunay!Interpolate](@ref) at each bin centre to build up an interpolated 2D histogram.

If the "empty" option is selected, returns an empty histogram booked with the limits of fX, fY and fZ. This option is used when the data set is drawn with markers only. In that particular case there is no need to find the Delaunay triangles.

By default use the new interpolation routine based on Triangles If the option "old" the old interpolation is used
""" GetHistogram(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of TList * TGraph2D::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByConstRef1{TGraph2D})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetMargin()
@trydoc raw"""
    GetMargin(this::ByConstRef1{TGraph2D})::Float64


""" GetMargin(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetMaximum()
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TGraph2D})::Float64


""" GetMaximum(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetMinimum()
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TGraph2D})::Float64


""" GetMinimum(this::ByConstRef1{TGraph2D})

# Wrapper of Int_t TGraph2D::GetN()
@trydoc raw"""
    GetN(this::ByConstRef1{TGraph2D})::Int32


""" GetN(this::ByConstRef1{TGraph2D})

# Wrapper of Int_t TGraph2D::GetNpx()
@trydoc raw"""
    GetNpx(this::ByConstRef1{TGraph2D})::Int32


""" GetNpx(this::ByConstRef1{TGraph2D})

# Wrapper of Int_t TGraph2D::GetNpy()
@trydoc raw"""
    GetNpy(this::ByConstRef1{TGraph2D})::Int32


""" GetNpy(this::ByConstRef1{TGraph2D})

# Wrapper of Int_t TGraph2D::GetPoint(Int_t, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetPoint(this::ByConstRef1{TGraph2D}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})::Int32
Get x, y and z values for point number i.
The function returns -1 in case of an invalid request or the point number otherwise
""" GetPoint(this::ByConstRef1{TGraph2D}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})

# Wrapper of Double_t * TGraph2D::GetX()
@trydoc raw"""
    GetX(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetX(this::ByConstRef1{TGraph2D})

# Wrapper of TAxis * TGraph2D::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByConstRef1{TGraph2D})::CxxPtr1{TAxis}
Get x axis of the graph.

""" GetXaxis(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetXmax()
@trydoc raw"""
    GetXmax(this::ByConstRef1{TGraph2D})::Float64
Returns the X maximum.

""" GetXmax(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetXmaxE()
@trydoc raw"""
    GetXmaxE(this::ByConstRef1{TGraph2D})::Float64


""" GetXmaxE(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetXmin()
@trydoc raw"""
    GetXmin(this::ByConstRef1{TGraph2D})::Float64
Returns the X minimum.

""" GetXmin(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetXminE()
@trydoc raw"""
    GetXminE(this::ByConstRef1{TGraph2D})::Float64


""" GetXminE(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetY()
@trydoc raw"""
    GetY(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetY(this::ByConstRef1{TGraph2D})

# Wrapper of TAxis * TGraph2D::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByConstRef1{TGraph2D})::CxxPtr1{TAxis}
Get y axis of the graph.

""" GetYaxis(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetYmax()
@trydoc raw"""
    GetYmax(this::ByConstRef1{TGraph2D})::Float64
Returns the Y maximum.

""" GetYmax(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetYmaxE()
@trydoc raw"""
    GetYmaxE(this::ByConstRef1{TGraph2D})::Float64


""" GetYmaxE(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetYmin()
@trydoc raw"""
    GetYmin(this::ByConstRef1{TGraph2D})::Float64
Returns the Y minimum.

""" GetYmin(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetYminE()
@trydoc raw"""
    GetYminE(this::ByConstRef1{TGraph2D})::Float64


""" GetYminE(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t * TGraph2D::GetZ()
@trydoc raw"""
    GetZ(this::ByConstRef1{TGraph2D})::CxxPtr2{Float64}


""" GetZ(this::ByConstRef1{TGraph2D})

# Wrapper of TAxis * TGraph2D::GetZaxis()
@trydoc raw"""
    GetZaxis(this::ByConstRef1{TGraph2D})::CxxPtr1{TAxis}
Get z axis of the graph.

""" GetZaxis(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetZmax()
@trydoc raw"""
    GetZmax(this::ByConstRef1{TGraph2D})::Float64
Returns the Z maximum.

""" GetZmax(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetZmaxE()
@trydoc raw"""
    GetZmaxE(this::ByConstRef1{TGraph2D})::Float64


""" GetZmaxE(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetZmin()
@trydoc raw"""
    GetZmin(this::ByConstRef1{TGraph2D})::Float64
Returns the Z minimum.

""" GetZmin(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::GetZminE()
@trydoc raw"""
    GetZminE(this::ByConstRef1{TGraph2D})::Float64


""" GetZminE(this::ByConstRef1{TGraph2D})

# Wrapper of Double_t TGraph2D::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByRef1{TGraph2D}, x::Float64, y::Float64)::Float64
Finds the z value at the position (x,y) thanks to the Delaunay interpolation.

""" Interpolate(this::ByRef1{TGraph2D}, x::Float64, y::Float64)

# Wrapper of TGraph2D & TGraph2D::operator=(const TGraph2D &)
@trydoc raw"""
    assign(this::ByRef1{TGraph2D}, ::ByConstRef1{TGraph2D})::CxxRef1{TGraph2D}
Graph2D operator "=".

""" assign(this::ByRef1{TGraph2D}, ::ByConstRef1{TGraph2D})

# Wrapper of void TGraph2D::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGraph2D}, option::ByCopy{String})::Nothing
Paints this 2D graph with its current attributes.

""" Paint(this::ByRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of void TGraph2D::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraph2D}, chopt::ByCopy{String})::Nothing
Print 2D graph values.

""" Print(this::ByConstRef1{TGraph2D}, chopt::ByCopy{String})

# Wrapper of TH1 * TGraph2D::Project(Option_t *)
@trydoc raw"""
    Project(this::ByConstRef1{TGraph2D}, option::ByCopy{String})::CxxPtr1{TH1}
Projects a 2-d graph into 1 or 2-d histograms depending on the option parameter.
option may contain a combination of the characters x,y,z:

- option = "x" return the x projection into a [TH1D](@ref) histogram
- option = "y" return the y projection into a [TH1D](@ref) histogram
- option = "xy" return the x versus y projection into a [TH2D](@ref) histogram
- option = "yx" return the y versus x projection into a [TH2D](@ref) histogram
""" Project(this::ByConstRef1{TGraph2D}, option::ByCopy{String})

# Wrapper of Int_t TGraph2D::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph2D}, ipoint::Int32)::Int32
Deletes point number ipoint.

""" RemovePoint(this::ByRef1{TGraph2D}, ipoint::Int32)

# Wrapper of void TGraph2D::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph2D}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values of a [TGraph2D](@ref) by a constant c1.
If option contains "x" the x values are scaled If option contains "y" the y values are scaled If option contains "z" the z values are scaled If option contains "xyz" all three x, y and z values are scaled
""" Scale(this::ByRef1{TGraph2D}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph2D::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph2D}, n::Int32)::Nothing
Set number of points in the 2D graph.
Existing coordinates are preserved. New coordinates above fNpoints are preset to 0.
""" Set(this::ByRef1{TGraph2D}, n::Int32)

# Wrapper of void TGraph2D::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TGraph2D}, dir::ByPtr1{TDirectory})::Nothing
By default when an 2D graph is created, it is added to the list of 2D graph objects in the current directory in memory.
This method removes reference to this 2D graph from current directory and add reference to new directory dir. dir can be 0 in which case the 2D graph does not belong to any directory.
""" SetDirectory(this::ByRef1{TGraph2D}, dir::ByPtr1{TDirectory})

# Wrapper of void TGraph2D::SetHistogram(TH2 *, Option_t *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TGraph2D}, h::ByPtr1{TH2}, option::ByCopy{String})::Nothing
Sets the histogram to be filled.
If the 2D graph needs to be save in a [TFile](@ref) the following set should be followed to read it back:

1. Create [TGraph2D](@ref)
2. Call g->SetHistogram(h), and do whatever you need to do
3. Save g and h to the [TFile](@ref), exit
4. Open the [TFile](@ref), retrieve g and h
5. Call h->SetDirectory(0)
6. Call g->SetHistogram(h) again
7. Carry on as normal

By default use the new interpolation routine based on Triangles If the option "old" the old interpolation is used
""" SetHistogram(this::ByRef1{TGraph2D}, h::ByPtr1{TH2}, option::ByCopy{String})

# Wrapper of void TGraph2D::SetMargin(Double_t)
@trydoc raw"""
    SetMargin(this::ByRef1{TGraph2D}, m::Float64)::Nothing
Sets the extra space (in %) around interpolated area for the 2D histogram.

""" SetMargin(this::ByRef1{TGraph2D}, m::Float64)

# Wrapper of void TGraph2D::SetMarginBinsContent(Double_t)
@trydoc raw"""
    SetMarginBinsContent(this::ByRef1{TGraph2D}, z::Float64)::Nothing
Sets the histogram bin height for points lying outside the [TGraphDelaunay](@ref) convex hull ie: the bins in the margin.

""" SetMarginBinsContent(this::ByRef1{TGraph2D}, z::Float64)

# Wrapper of void TGraph2D::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{TGraph2D}, maximum::Float64)::Nothing
Set maximum.

""" SetMaximum(this::ByRef1{TGraph2D}, maximum::Float64)

# Wrapper of void TGraph2D::SetMaxIter(Int_t)
@trydoc raw"""
    SetMaxIter(this::ByRef1{TGraph2D}, n::Int32)::Nothing


""" SetMaxIter(this::ByRef1{TGraph2D}, n::Int32)

# Wrapper of void TGraph2D::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{TGraph2D}, minimum::Float64)::Nothing
Set minimum.

""" SetMinimum(this::ByRef1{TGraph2D}, minimum::Float64)

# Wrapper of void TGraph2D::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TGraph2D}, name::ByCopy{String})::Nothing
Changes the name of this 2D graph.

""" SetName(this::ByRef1{TGraph2D}, name::ByCopy{String})

# Wrapper of void TGraph2D::SetNameTitle(const char *, const char *)
@trydoc raw"""
    SetNameTitle(this::ByRef1{TGraph2D}, name::ByCopy{String}, title::ByCopy{String})::Nothing
Change the name and title of this 2D graph.

""" SetNameTitle(this::ByRef1{TGraph2D}, name::ByCopy{String}, title::ByCopy{String})

# Wrapper of void TGraph2D::SetNpx(Int_t)
@trydoc raw"""
    SetNpx(this::ByRef1{TGraph2D}, npx::Int32)::Nothing
Sets the number of bins along X used to draw the function.

""" SetNpx(this::ByRef1{TGraph2D}, npx::Int32)

# Wrapper of void TGraph2D::SetNpy(Int_t)
@trydoc raw"""
    SetNpy(this::ByRef1{TGraph2D}, npx::Int32)::Nothing
Sets the number of bins along Y used to draw the function.

""" SetNpy(this::ByRef1{TGraph2D}, npx::Int32)

# Wrapper of void TGraph2D::SetPoint(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph2D}, point::Int32, x::Float64, y::Float64, z::Float64)::Nothing
Sets point number n.
If n is greater than the current size, the arrays are automatically extended.
""" SetPoint(this::ByRef1{TGraph2D}, point::Int32, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2D::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TGraph2D}, title::ByCopy{String})::Nothing
Sets the 2D graph title.
This method allows to change the global_ title and the axis' titles of a 2D graph. If `g` is the 2D graph one can do:

    g->SetTitle("Graph title; X axis title; Y axis title; Z axis title");

(C++ version of the code)
""" SetTitle(this::ByRef1{TGraph2D}, title::ByCopy{String})

# Wrapper of void TGraphErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})::Nothing
Apply function to all the data points $ y = f(x,y) $.
The error is calculated as $ ey=(f(x,y+ey)-f(x,y-ey))/2 $. This is the same as $ error(fy) = df/dy * ey $ for small errors.

For generic functions the symmetric errors might become non-symmetric and are averaged here. Use [TGraphAsymmErrors](@ref) if desired.

Error on $ x $ doesn't change.

function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphErrors::ApplyX(TF1 *)
@trydoc raw"""
    ApplyX(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})::Nothing
Apply function to all the data points $ x = f(x,y) $.
The error is calculated as $ ex=(f(x+ex,y)-f(x-ex,y))/2 $. This is the same as $ error(fx) = df/dx * ex $ for small errors.

For generic functions the symmetric errors might become non-symmetric and are averaged here. Use [TGraphAsymmErrors](@ref) if desired.

Error on $ y $ doesn't change.
""" ApplyX(this::ByRef1{TGraphErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphErrors::ComputeRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    ComputeRange(this::ByConstRef1{TGraphErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Compute range.

""" ComputeRange(this::ByConstRef1{TGraphErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of Double_t TGraphErrors::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraphErrors}, bin::Int32)::Float64
It returns the error along X at point `i`.

""" GetErrorX(this::ByConstRef1{TGraphErrors}, bin::Int32)

# Wrapper of Double_t TGraphErrors::GetErrorXhigh(Int_t)
@trydoc raw"""
    GetErrorXhigh(this::ByConstRef1{TGraphErrors}, bin::Int32)::Float64
It returns the error along X at point `i`.
For [TGraphErrors](@ref) this method is the same as GetErrorX.
""" GetErrorXhigh(this::ByConstRef1{TGraphErrors}, bin::Int32)

# Wrapper of Double_t TGraphErrors::GetErrorXlow(Int_t)
@trydoc raw"""
    GetErrorXlow(this::ByConstRef1{TGraphErrors}, bin::Int32)::Float64
It returns the error along X at point `i`.
For [TGraphErrors](@ref) this method is the same as GetErrorX.
""" GetErrorXlow(this::ByConstRef1{TGraphErrors}, bin::Int32)

# Wrapper of Double_t TGraphErrors::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraphErrors}, bin::Int32)::Float64
It returns the error along Y at point `i`.

""" GetErrorY(this::ByConstRef1{TGraphErrors}, bin::Int32)

# Wrapper of Double_t TGraphErrors::GetErrorYhigh(Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraphErrors}, bin::Int32)::Float64
It returns the error along Y at point `i`.
For [TGraphErrors](@ref) this method is the same as GetErrorY.
""" GetErrorYhigh(this::ByConstRef1{TGraphErrors}, bin::Int32)

# Wrapper of Double_t TGraphErrors::GetErrorYlow(Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraphErrors}, bin::Int32)::Float64
It returns the error along Y at point `i`.
For [TGraphErrors](@ref) this method is the same as GetErrorY.
""" GetErrorYlow(this::ByConstRef1{TGraphErrors}, bin::Int32)

# Wrapper of Double_t * TGraphErrors::GetEX()
@trydoc raw"""
    GetEX(this::ByConstRef1{TGraphErrors})::CxxPtr2{Float64}


""" GetEX(this::ByConstRef1{TGraphErrors})

# Wrapper of Double_t * TGraphErrors::GetEY()
@trydoc raw"""
    GetEY(this::ByConstRef1{TGraphErrors})::CxxPtr2{Float64}


""" GetEY(this::ByConstRef1{TGraphErrors})

# Wrapper of Int_t TGraphErrors::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TGraphErrors}, list::ByPtr1{TCollection})::Int32
Adds all graphs with errors from the collection to this graph.
Returns the total number of points in the result or -1 in case of an error.
""" Merge(this::ByRef1{TGraphErrors}, list::ByPtr1{TCollection})

# Wrapper of TGraphErrors & TGraphErrors::operator=(const TGraphErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraphErrors}, gr::ByConstRef1{TGraphErrors})::CxxRef1{TGraphErrors}
[TGraphErrors](@ref) assignment operator.

""" assign(this::ByRef1{TGraphErrors}, gr::ByConstRef1{TGraphErrors})

# Wrapper of void TGraphErrors::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraphErrors}, chopt::ByCopy{String})::Nothing
Print graph and errors values.

""" Print(this::ByConstRef1{TGraphErrors}, chopt::ByCopy{String})

# Wrapper of void TGraphErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "xy" both x and y values and errors are scaled
""" Scale(this::ByRef1{TGraphErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphErrors::SetPointError(Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphErrors}, ex::Float64, ey::Float64)::Nothing
Set `ex` and `ey` values for point pointed by the mouse.

""" SetPointError(this::ByRef1{TGraphErrors}, ex::Float64, ey::Float64)

# Wrapper of void TGraphErrors::SetPointError(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphErrors}, i::Int32, ex::Float64, ey::Float64)::Nothing
Set `ex` and `ey` values for point number i.

""" SetPointError(this::ByRef1{TGraphErrors}, i::Int32, ex::Float64, ey::Float64)

# Wrapper of Int_t TGraphErrors::CalculateScanfFields(const char *)
@trydoc raw"""
    TGraphErrors!CalculateScanfFields(this::ByRef1{TGraphErrors}, fmt::ByCopy{String})::Int32
Calculate scan fields.

""" TGraphErrors!CalculateScanfFields(this::ByRef1{TGraphErrors}, fmt::ByCopy{String})

# Wrapper of Bool_t TAxis::CanBeAlphanumeric()
@trydoc raw"""
    CanBeAlphanumeric(this::ByRef1{TAxis})::Bool


""" CanBeAlphanumeric(this::ByRef1{TAxis})

# Wrapper of Bool_t TAxis::CanExtend()
@trydoc raw"""
    CanExtend(this::ByConstRef1{TAxis})::Bool


""" CanExtend(this::ByConstRef1{TAxis})

# Wrapper of void TAxis::CenterLabels(Bool_t)
@trydoc raw"""
    CenterLabels(this::ByRef1{TAxis}, center::Bool)::Nothing
Center axis labels.
If center = kTRUE axis labels will be centered (horizontal axes only) on the bin center. Default is to center on the primary tick marks This option does not make sense if there are more bins than tick marks
""" CenterLabels(this::ByRef1{TAxis}, center::Bool)

# Wrapper of void TAxis::CenterTitle(Bool_t)
@trydoc raw"""
    CenterTitle(this::ByRef1{TAxis}, center::Bool)::Nothing
Center axis title.
If center = kTRUE axis title will be centered default is right adjusted
""" CenterTitle(this::ByRef1{TAxis}, center::Bool)

# Wrapper of void TAxis::ChangeLabel(Int_t, Double_t, Double_t, Int_t, Int_t, Int_t, const TString &)
@trydoc raw"""
    ChangeLabel(this::ByRef1{TAxis}, labNum::Int32, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})::Nothing
Define new text attributes for the label number "labNum".
It allows to do a fine tuning of the labels. All the attributes can be changed, even the label text itself.

## Arguments

- **`labNum`** [in] 
    Number of the label to be changed, negative numbers thestart from the theend 
    
- **`labAngle`** [in] 
    New angle value 
    
- **`labSize`** [in] 
    New size (0 erase the label) 
    
- **`labAlign`** [in] 
    New alignment value 
    
- **`labColor`** [in] 
    New label color 
    
- **`labFont`** [in] 
    New label font 
    
- **`labText`** [in] 
    New label text
    

#### Notes:

- If an attribute should not be changed just give the value "-1".
- If labnum=0 the list of modified labels is reset.
- To erase a label set labSize to 0.
- If labText is not specified or is an empty string, the text label is not changed.
- To retrieve the number of axis labels use [TAxis!GetNlabels](@ref).
""" ChangeLabel(this::ByRef1{TAxis}, labNum::Int32, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})

# Wrapper of void TAxis::ChangeLabelByValue(Double_t, Double_t, Double_t, Int_t, Int_t, Int_t, const TString &)
@trydoc raw"""
    ChangeLabelByValue(this::ByRef1{TAxis}, labValue::Float64, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})::Nothing
Define new text attributes for the label value "labValue".
It allows to do a fine tuning of the labels. All the attributes can be changed, even the label text itself.

## Arguments

- **`labValue`** [in] 
    Axis value to be changed 
    
- **`labAngle`** [in] 
    New angle value 
    
- **`labSize`** [in] 
    New size (0 erase the label) 
    
- **`labAlign`** [in] 
    New alignment value 
    
- **`labColor`** [in] 
    New label color 
    
- **`labFont`** [in] 
    New label font 
    
- **`labText`** [in] 
    New label text
    

#### Notes:

- If an attribute should not be changed just give the value "-1".
- If labnum=0 the list of modified labels is reset.
- To erase a label set labSize to 0.
- If labText is not specified or is an empty string, the text label is not changed.
- To retrieve the number of axis labels use [TAxis!GetNlabels](@ref).
""" ChangeLabelByValue(this::ByRef1{TAxis}, labValue::Float64, labAngle::Float64, labSize::Float64, labAlign::Int32, labColor::Int32, labFont::Int32, labText::ByConstRef1{TString})

# Wrapper of const char * TAxis::ChooseTimeFormat(Double_t)
@trydoc raw"""
    ChooseTimeFormat(this::ByRef1{TAxis}, axislength::Float64)::ByCopy{String}
Choose a reasonable time format from the coordinates in the active pad and the number of divisions in this axis If orientation = "X", the horizontal axis of the pad will be used for ref.
If orientation = "Y", the vertical axis of the pad will be used for ref.
""" ChooseTimeFormat(this::ByRef1{TAxis}, axislength::Float64)

# Wrapper of void TAxis::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TAxis}, axis::ByRef1{TObject})::Nothing
Copy axis structure to another axis.

""" Copy(this::ByConstRef1{TAxis}, axis::ByRef1{TObject})

# Wrapper of void TAxis::Delete(Option_t *)
@trydoc raw"""
    Delete(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Delete this object.
Typically called as a command via the interpreter. Normally use "delete" operator when object has been allocated on the heap.
""" Delete(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of Int_t TAxis::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TAxis}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to an axis.

""" DistancetoPrimitive(this::ByRef1{TAxis}, px::Int32, py::Int32)

# Wrapper of TObject * TAxis::DrawClone(Option_t *)
@trydoc raw"""
    DrawClone(this::ByConstRef1{TAxis}, option::ByCopy{String})::CxxPtr1{TObject}
Draw a clone of this object in the current selected pad with: `gROOT->SetSelectedPad(c1)`.
If pad was not selected - `gPad` will be used.
""" DrawClone(this::ByConstRef1{TAxis}, option::ByCopy{String})

# Wrapper of void TAxis::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TAxis}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed and the position where it is released. If the mouse position is outside the current axis range when it is released the axis is unzoomed with the corresponding proportions. Note that the mouse does not need to be in the pad or even canvas when it is released.
""" ExecuteEvent(this::ByRef1{TAxis}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TAxis::FindBin(const char *)
@trydoc raw"""
    FindBin(this::ByRef1{TAxis}, label::ByCopy{String})::Int32
Find bin number with label.
If the List of labels does not exist create it and make the axis alphanumeric If one wants just to add a single label- just call [TAxis!SetBinLabel](@ref) If label is not in the list of labels do the following depending on the bit TAxis!kCanExtend; of the axis.

- if the bit is set add the new label and if the number of labels exceeds the number of bins, double the number of bins via [TH1!LabelsInflate](@ref)
- if the bit is not set and the histogram has labels in each bin set the bit automatically and consider the histogram as alphanumeric if histogram has only some bins with labels then the histogram is not consider alphanumeric and return -1

-1 is returned only when the Axis has no parent histogram
""" FindBin(this::ByRef1{TAxis}, label::ByCopy{String})

# Wrapper of Int_t TAxis::FindBin(Double_t)
@trydoc raw"""
    FindBin(this::ByConstRef1{TAxis}, x::Float64)::Int32


""" FindBin(this::ByConstRef1{TAxis}, x::Float64)

# Wrapper of Int_t TAxis::FindFixBin(const char *)
@trydoc raw"""
    FindFixBin(this::ByConstRef1{TAxis}, label::ByCopy{String})::Int32
Find bin number with label.
If the List of labels does not exist or the label does not exist just return -1 . Do not attempt to modify the axis. This is different than FindBin
""" FindFixBin(this::ByConstRef1{TAxis}, label::ByCopy{String})

# Wrapper of Int_t TAxis::FindFixBin(Double_t)
@trydoc raw"""
    FindFixBin(this::ByConstRef1{TAxis}, x::Float64)::Int32
Find bin number corresponding to abscissa `x`
Identical to [TAxis!FindBin](@ref) except that if `x` is an underflow/overflow no attempt is made to extend the axis. 

###See

TAxis!FindBin
""" FindFixBin(this::ByConstRef1{TAxis}, x::Float64)

# Wrapper of Double_t TAxis::GetBinCenter(Int_t)
@trydoc raw"""
    GetBinCenter(this::ByConstRef1{TAxis}, bin::Int32)::Float64
Return center of bin.

""" GetBinCenter(this::ByConstRef1{TAxis}, bin::Int32)

# Wrapper of Double_t TAxis::GetBinCenterLog(Int_t)
@trydoc raw"""
    GetBinCenterLog(this::ByConstRef1{TAxis}, bin::Int32)::Float64
Return center of bin in log With a log-equidistant binning for a bin with low and up edges, the mean is : 0.5*(ln low + ln up) i.e.
sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10). Imagine a bin with low=1 and up=100 :

- the center in lin is (100-1)/2=50.5
- the center in log would be sqrt(1*100)=10 (!=log(50.5))

NB: if the low edge of the bin is negative, the function returns the bin center as computed by [TAxis!GetBinCenter](@ref)
""" GetBinCenterLog(this::ByConstRef1{TAxis}, bin::Int32)

# Wrapper of const char * TAxis::GetBinLabel(Int_t)
@trydoc raw"""
    GetBinLabel(this::ByConstRef1{TAxis}, bin::Int32)::ByCopy{String}
Return label for bin.

""" GetBinLabel(this::ByConstRef1{TAxis}, bin::Int32)

# Wrapper of Double_t TAxis::GetBinLowEdge(Int_t)
@trydoc raw"""
    GetBinLowEdge(this::ByConstRef1{TAxis}, bin::Int32)::Float64
Return low edge of bin.

""" GetBinLowEdge(this::ByConstRef1{TAxis}, bin::Int32)

# Wrapper of Double_t TAxis::GetBinUpEdge(Int_t)
@trydoc raw"""
    GetBinUpEdge(this::ByConstRef1{TAxis}, bin::Int32)::Float64
Return up edge of bin.

""" GetBinUpEdge(this::ByConstRef1{TAxis}, bin::Int32)

# Wrapper of Double_t TAxis::GetBinWidth(Int_t)
@trydoc raw"""
    GetBinWidth(this::ByConstRef1{TAxis}, bin::Int32)::Float64
Return bin width.
If `bin > fNbins` (overflow bin) or `bin < 1` (underflow bin), the returned bin width is `(fXmax - fXmin) / fNbins`.
""" GetBinWidth(this::ByConstRef1{TAxis}, bin::Int32)

# Wrapper of void TAxis::GetCenter(Double_t *)
@trydoc raw"""
    GetCenter(this::ByConstRef1{TAxis}, center::ByPtr2{Float64})::Nothing
Return an array with the center of all bins.

""" GetCenter(this::ByConstRef1{TAxis}, center::ByPtr2{Float64})

# Wrapper of Bool_t TAxis::GetCenterLabels()
@trydoc raw"""
    GetCenterLabels(this::ByConstRef1{TAxis})::Bool


""" GetCenterLabels(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::GetCenterTitle()
@trydoc raw"""
    GetCenterTitle(this::ByConstRef1{TAxis})::Bool


""" GetCenterTitle(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::GetDecimals()
@trydoc raw"""
    GetDecimals(this::ByConstRef1{TAxis})::Bool


""" GetDecimals(this::ByConstRef1{TAxis})

# Wrapper of Int_t TAxis::GetFirst()
@trydoc raw"""
    GetFirst(this::ByConstRef1{TAxis})::Int32
Return first bin on the axis i.e.
1 if no range defined 

###Note

in some cases a zero is returned (see TAxis!SetRange)
""" GetFirst(this::ByConstRef1{TAxis})

# Wrapper of Int_t TAxis::GetLast()
@trydoc raw"""
    GetLast(this::ByConstRef1{TAxis})::Int32
Return last bin on the axis i.e.
fNbins if no range defined 

###Note

in some cases a zero is returned (see TAxis!SetRange)
""" GetLast(this::ByConstRef1{TAxis})

# Wrapper of void TAxis::GetLowEdge(Double_t *)
@trydoc raw"""
    GetLowEdge(this::ByConstRef1{TAxis}, edge::ByPtr2{Float64})::Nothing
Return an array with the low edge of all bins.

""" GetLowEdge(this::ByConstRef1{TAxis}, edge::ByPtr2{Float64})

# Wrapper of TList * TAxis::GetModifiedLabels()
@trydoc raw"""
    GetModifiedLabels(this::ByConstRef1{TAxis})::CxxPtr1{TList}


""" GetModifiedLabels(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::GetMoreLogLabels()
@trydoc raw"""
    GetMoreLogLabels(this::ByConstRef1{TAxis})::Bool


""" GetMoreLogLabels(this::ByConstRef1{TAxis})

# Wrapper of Int_t TAxis::GetNbins()
@trydoc raw"""
    GetNbins(this::ByConstRef1{TAxis})::Int32


""" GetNbins(this::ByConstRef1{TAxis})

# Wrapper of Int_t TAxis::GetNlabels()
@trydoc raw"""
    GetNlabels(this::ByConstRef1{TAxis})::Int32
Return the number of axis labels.
It is sometimes useful to know the number of labels on an axis. For instance when changing the labels with [TAxis!ChangeLabel](@ref). The number of labels is equal to `the_number_of_divisions + 1`. By default the number of divisions is optimised to show a coherent labeling of the main tick marks. After optimisation the real number of divisions will be smaller or equal to number of divisions requested. In order to turn off the labeling optimization, it is enough to give a negative number of divisions to [TAttAxis!SetNdivisions](@ref). The absolute value of this number will be use as the exact number of divisions. This method takes the two cases (optimised or not) into account.
""" GetNlabels(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::GetNoExponent()
@trydoc raw"""
    GetNoExponent(this::ByConstRef1{TAxis})::Bool


""" GetNoExponent(this::ByConstRef1{TAxis})

# Wrapper of TObject * TAxis::GetParent()
@trydoc raw"""
    GetParent(this::ByConstRef1{TAxis})::CxxPtr1{TObject}


""" GetParent(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::GetRotateTitle()
@trydoc raw"""
    GetRotateTitle(this::ByConstRef1{TAxis})::Bool


""" GetRotateTitle(this::ByConstRef1{TAxis})

# Wrapper of const char * TAxis::GetTicks()
@trydoc raw"""
    GetTicks(this::ByConstRef1{TAxis})::ByCopy{String}
Return the ticks option (see SetTicks)

""" GetTicks(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::GetTimeDisplay()
@trydoc raw"""
    GetTimeDisplay(this::ByConstRef1{TAxis})::Bool


""" GetTimeDisplay(this::ByConstRef1{TAxis})

# Wrapper of const char * TAxis::GetTimeFormat()
@trydoc raw"""
    GetTimeFormat(this::ByConstRef1{TAxis})::ByCopy{String}


""" GetTimeFormat(this::ByConstRef1{TAxis})

# Wrapper of const char * TAxis::GetTimeFormatOnly()
@trydoc raw"""
    GetTimeFormatOnly(this::ByConstRef1{TAxis})::ByCopy{String}
Return *only* the time format from the string fTimeFormat.

""" GetTimeFormatOnly(this::ByConstRef1{TAxis})

# Wrapper of UInt_t TAxis::GetTimeOffset()
@trydoc raw"""
    GetTimeOffset(this::ByRef1{TAxis})::UInt32
Return the time offset in GMT.

""" GetTimeOffset(this::ByRef1{TAxis})

# Wrapper of const char * TAxis::GetTitle()
@trydoc raw"""
    GetTitle(this::ByConstRef1{TAxis})::ByCopy{String}
Returns title of object.
This default method returns the class title (i.e. description). Classes that give objects a title should override this method.
""" GetTitle(this::ByConstRef1{TAxis})

# Wrapper of const TArrayD * TAxis::GetXbins()
@trydoc raw"""
    GetXbins(this::ByConstRef1{TAxis})::ConstCxxPtr1{TArrayD}


""" GetXbins(this::ByConstRef1{TAxis})

# Wrapper of Double_t TAxis::GetXmax()
@trydoc raw"""
    GetXmax(this::ByConstRef1{TAxis})::Float64


""" GetXmax(this::ByConstRef1{TAxis})

# Wrapper of Double_t TAxis::GetXmin()
@trydoc raw"""
    GetXmin(this::ByConstRef1{TAxis})::Float64


""" GetXmin(this::ByConstRef1{TAxis})

# Wrapper of void TAxis::ImportAttributes(const TAxis *)
@trydoc raw"""
    ImportAttributes(this::ByRef1{TAxis}, axis::ByConstPtr1{TAxis})::Nothing
Copy axis attributes to this.

""" ImportAttributes(this::ByRef1{TAxis}, axis::ByConstPtr1{TAxis})

# Wrapper of Bool_t TAxis::IsAlphanumeric()
@trydoc raw"""
    IsAlphanumeric(this::ByConstRef1{TAxis})::Bool


""" IsAlphanumeric(this::ByConstRef1{TAxis})

# Wrapper of Bool_t TAxis::IsVariableBinSize()
@trydoc raw"""
    IsVariableBinSize(this::ByConstRef1{TAxis})::Bool


""" IsVariableBinSize(this::ByConstRef1{TAxis})

# Wrapper of void TAxis::LabelsOption(Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Set option(s) to draw axis with labels option can be:
- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of TAxis & TAxis::operator=(const TAxis &)
@trydoc raw"""
    assign(this::ByRef1{TAxis}, ::ByConstRef1{TAxis})::CxxRef1{TAxis}
Assignment operator.

""" assign(this::ByRef1{TAxis}, ::ByConstRef1{TAxis})

# Wrapper of void TAxis::RotateTitle(Bool_t)
@trydoc raw"""
    RotateTitle(this::ByRef1{TAxis}, rotate::Bool)::Nothing
Rotate title by 180 degrees.
By default the title is drawn right adjusted. If rotate is TRUE, the title is left adjusted at the theend of the axis and rotated by 180 degrees
""" RotateTitle(this::ByRef1{TAxis}, rotate::Bool)

# Wrapper of void TAxis::Set(Int_t, const Double_t *)
@trydoc raw"""
    Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float64})::Nothing
Initialize axis with variable bins.

""" Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float64})

# Wrapper of void TAxis::Set(Int_t, const Float_t *)
@trydoc raw"""
    Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float32})::Nothing
Initialize axis with variable bins.

""" Set(this::ByRef1{TAxis}, nbins::Int32, xbins::ByConstPtr2{Float32})

# Wrapper of void TAxis::Set(Int_t, Double_t, Double_t)
@trydoc raw"""
    Set(this::ByRef1{TAxis}, nbins::Int32, xmin::Float64, xmax::Float64)::Nothing
Initialize axis with fix bins.

""" Set(this::ByRef1{TAxis}, nbins::Int32, xmin::Float64, xmax::Float64)

# Wrapper of void TAxis::SetAlphanumeric(Bool_t)
@trydoc raw"""
    SetAlphanumeric(this::ByRef1{TAxis}, alphanumeric::Bool)::Nothing
Set axis alphanumeric.

""" SetAlphanumeric(this::ByRef1{TAxis}, alphanumeric::Bool)

# Wrapper of void TAxis::SetBinLabel(Int_t, const char *)
@trydoc raw"""
    SetBinLabel(this::ByRef1{TAxis}, bin::Int32, label::ByCopy{String})::Nothing
Set label for bin.
If no label list exists, it is created. If all the bins have labels, the axis becomes alphanumeric and extendable. New labels will not be added with the Fill method but will theend-up in the underflow bin. See documentation of [TAxis!FindBin(const char*)](@ref)
""" SetBinLabel(this::ByRef1{TAxis}, bin::Int32, label::ByCopy{String})

# Wrapper of void TAxis::SetCanExtend(Bool_t)
@trydoc raw"""
    SetCanExtend(this::ByRef1{TAxis}, canExtend::Bool)::Nothing


""" SetCanExtend(this::ByRef1{TAxis}, canExtend::Bool)

# Wrapper of void TAxis::SetDecimals(Bool_t)
@trydoc raw"""
    SetDecimals(this::ByRef1{TAxis}, dot::Bool)::Nothing
Sets the decimals flag By default, blank characters are stripped, and then the label is correctly aligned.
If the dot is the last character of the string, it is also stripped, unless this option is specified.
""" SetDecimals(this::ByRef1{TAxis}, dot::Bool)

# Wrapper of void TAxis::SetDefaults()
@trydoc raw"""
    SetDefaults(this::ByRef1{TAxis})::Nothing
Set axis default values (from [TStyle](@ref))

""" SetDefaults(this::ByRef1{TAxis})

# Wrapper of void TAxis::SetDrawOption(Option_t *)
@trydoc raw"""
    SetDrawOption(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Set drawing option for object.
This option only affects the drawing style and is stored in the option field of the [TObjOptLink](@ref) supporting a [TPad](@ref)'s primitive list ([TList](@ref)). Note that it does not make sense to call object.SetDrawOption(option) before having called object.Draw().
""" SetDrawOption(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of void TAxis::SetLimits(Double_t, Double_t)
@trydoc raw"""
    SetLimits(this::ByRef1{TAxis}, xmin::Float64, xmax::Float64)::Nothing


""" SetLimits(this::ByRef1{TAxis}, xmin::Float64, xmax::Float64)

# Wrapper of void TAxis::SetMoreLogLabels(Bool_t)
@trydoc raw"""
    SetMoreLogLabels(this::ByRef1{TAxis}, more::Bool)::Nothing
Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale and there is a small number of decades (<3).
The flag (in fBits) is passed to the drawing function [TGaxis!PaintAxis](@ref)
""" SetMoreLogLabels(this::ByRef1{TAxis}, more::Bool)

# Wrapper of void TAxis::SetNoAlphanumeric(Bool_t)
@trydoc raw"""
    SetNoAlphanumeric(this::ByRef1{TAxis}, noalpha::Bool)::Nothing


""" SetNoAlphanumeric(this::ByRef1{TAxis}, noalpha::Bool)

# Wrapper of void TAxis::SetNoExponent(Bool_t)
@trydoc raw"""
    SetNoExponent(this::ByRef1{TAxis}, noExponent::Bool)::Nothing
Set the NoExponent flag By default, an exponent of the form 10^N is used when the label value are either all very small or very large.
The flag (in fBits) is passed to the drawing function [TGaxis!PaintAxis](@ref)
""" SetNoExponent(this::ByRef1{TAxis}, noExponent::Bool)

# Wrapper of void TAxis::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TAxis}, obj::ByPtr1{TObject})::Nothing


""" SetParent(this::ByRef1{TAxis}, obj::ByPtr1{TObject})

# Wrapper of void TAxis::SetRange(Int_t, Int_t)
@trydoc raw"""
    SetRange(this::ByRef1{TAxis}, first::Int32, last::Int32)::Nothing
Set the viewing range for the axis using bin numbers.
## Arguments

- **`first`** 
    First bin of the range. 
    
- **`last`** 
    Last bin of the range.
    

To set a range using the axis coordinates, use [TAxis!SetRangeUser](@ref).

If `first == last == 0` or if `first > last` or if the range specified does not intersect at all with the maximum available range `[0, fNbins + 1]`, then the viewing range is reset by removing the bit [TAxis!kAxisRange](@ref). In this case, the functions [TAxis!GetFirst()](@ref) and [TAxis!GetLast()](@ref) will return 1 and fNbins.

If the range specified partially intersects with `[0, fNbins + 1]`, then the intersection range is accepted. For instance, if `first == -2` and `last == fNbins`, the accepted range will be `[0, fNbins]` (`fFirst = 0` and `fLast = fNbins`).

If `last > fNbins`, the overflow bin is included in the range and will be displayed during drawing. If `first < 1`, the underflow bin is included in the range and will be displayed during drawing.

###Note

For historical reasons, SetRange(0,0) resets the range even though bin 0 is technically reserved for the underflow; in order to set the range of the axis so that it only includes the underflow, use SetRange(-1,0). 

###Note

This function will also restrict the fitting range
""" SetRange(this::ByRef1{TAxis}, first::Int32, last::Int32)

# Wrapper of void TAxis::SetRangeUser(Double_t, Double_t)
@trydoc raw"""
    SetRangeUser(this::ByRef1{TAxis}, ufirst::Float64, ulast::Float64)::Nothing
Set the viewing range for the axis from `ufirst` to `ulast` (in user coordinates, that is, the "natural" axis coordinates).
To set a range using the axis bin numbers, use [TAxis!SetRange](@ref).

If `ulast > fXmax`, the overflow bin is included in the range and will be displayed during drawing. If `ufirst < fXmin`, the underflow bin is included in the range and will be displayed during drawing.

###Note

This function will also restrict the fitting range
""" SetRangeUser(this::ByRef1{TAxis}, ufirst::Float64, ulast::Float64)

# Wrapper of void TAxis::SetTicks(Option_t *)
@trydoc raw"""
    SetTicks(this::ByRef1{TAxis}, option::ByCopy{String})::Nothing
Set ticks orientation.
option = "+" ticks drawn on the "positive side" (default) option = "-" ticks drawn on the "negative side" option = "+-" ticks drawn on both sides option = "" ticks will be drawn as whatever is defined as default. No bit is set internally.
""" SetTicks(this::ByRef1{TAxis}, option::ByCopy{String})

# Wrapper of void TAxis::SetTimeDisplay(Int_t)
@trydoc raw"""
    SetTimeDisplay(this::ByRef1{TAxis}, value::Int32)::Nothing


""" SetTimeDisplay(this::ByRef1{TAxis}, value::Int32)

# Wrapper of void TAxis::SetTimeFormat(const char *)
@trydoc raw"""
    SetTimeFormat(this::ByRef1{TAxis}, format::ByCopy{String})::Nothing
Change the format used for time plotting.
The format string for date and time use the same options as the one used in the standard strftime C function, i.e. : for date : 
```
     %a abbreviated weekday name
     %b abbreviated month name
     %d day of the month (01-31)
     %m month (01-12)
     %y year without century
```  for time : 
```
     %H hour (24-hour clock)
     %I hour (12-hour clock)
     %p local_ equivalent of AM or PM
     %M minute (00-59)
     %S seconds (00-61)
     %% %
```  This function allows also to define the time offset. It is done via F which should be appended at the theend of the format string. The time offset has the following format: 'yyyy-mm-dd hh:mm:ss' Example: 
```
     h = new TH1F("Test","h",3000,0.,200000.);
     h->GetXaxis()->SetTimeDisplay(1);
     h->GetXaxis()->SetTimeFormat("%d\/%m\/%y%F2000-02-28 13:00:01");
```  This defines the time format being "dd/mm/yy" and the time offset as the February 28th 2003 at 13:00:01

If F is not specified, the time offset used will be the one defined by: gStyle->SetTimeOffset. For example like that: 
```
     TDatime da(2003,02,28,12,00,00);
     gStyle->SetTimeOffset(da.Convert()); 
```
""" SetTimeFormat(this::ByRef1{TAxis}, format::ByCopy{String})

# Wrapper of void TAxis::SetTimeOffset(Double_t, Option_t *)
@trydoc raw"""
    SetTimeOffset(this::ByRef1{TAxis}, toffset::Float64, option::ByCopy{String})::Nothing
Change the time offset If option = "gmt", set display mode to GMT.

""" SetTimeOffset(this::ByRef1{TAxis}, toffset::Float64, option::ByCopy{String})

# Wrapper of void TAxis::UnZoom()
@trydoc raw"""
    UnZoom(this::ByRef1{TAxis})::Nothing
Reset first & last bin to the full range.

""" UnZoom(this::ByRef1{TAxis})

# Wrapper of void TAxis::ZoomOut(Double_t, Double_t)
@trydoc raw"""
    ZoomOut(this::ByRef1{TAxis}, factor::Float64, offset::Float64)::Nothing
Zoom out by a factor of 'factor' (default =2) uses previous zoom factor by default Keep center defined by 'offset' fixed ie.
-1 at left of current range, 0 in center, +1 at right
""" ZoomOut(this::ByRef1{TAxis}, factor::Float64, offset::Float64)

# Wrapper of Int_t TAxisModLab::GetAlign()
@trydoc raw"""
    GetAlign(this::ByConstRef1{TAxisModLab})::Int32


""" GetAlign(this::ByConstRef1{TAxisModLab})

# Wrapper of Double_t TAxisModLab::GetAngle()
@trydoc raw"""
    GetAngle(this::ByConstRef1{TAxisModLab})::Float64


""" GetAngle(this::ByConstRef1{TAxisModLab})

# Wrapper of Int_t TAxisModLab::GetColor()
@trydoc raw"""
    GetColor(this::ByConstRef1{TAxisModLab})::Int32


""" GetColor(this::ByConstRef1{TAxisModLab})

# Wrapper of Int_t TAxisModLab::GetFont()
@trydoc raw"""
    GetFont(this::ByConstRef1{TAxisModLab})::Int32


""" GetFont(this::ByConstRef1{TAxisModLab})

# Wrapper of Int_t TAxisModLab::GetLabNum()
@trydoc raw"""
    GetLabNum(this::ByConstRef1{TAxisModLab})::Int32


""" GetLabNum(this::ByConstRef1{TAxisModLab})

# Wrapper of Double_t TAxisModLab::GetLabValue()
@trydoc raw"""
    GetLabValue(this::ByConstRef1{TAxisModLab})::Float64


""" GetLabValue(this::ByConstRef1{TAxisModLab})

# Wrapper of Double_t TAxisModLab::GetSize()
@trydoc raw"""
    GetSize(this::ByConstRef1{TAxisModLab})::Float64


""" GetSize(this::ByConstRef1{TAxisModLab})

# Wrapper of const TString & TAxisModLab::GetText()
@trydoc raw"""
    GetText(this::ByConstRef1{TAxisModLab})::ConstCxxRef1{TString}


""" GetText(this::ByConstRef1{TAxisModLab})

# Wrapper of void TAxisModLab::SetAlign(Int_t)
@trydoc raw"""
    SetAlign(this::ByRef1{TAxisModLab}, a::Int32)::Nothing
Set modified label alignment.

""" SetAlign(this::ByRef1{TAxisModLab}, a::Int32)

# Wrapper of void TAxisModLab::SetAngle(Double_t)
@trydoc raw"""
    SetAngle(this::ByRef1{TAxisModLab}, a::Float64)::Nothing
Set modified label angle.

""" SetAngle(this::ByRef1{TAxisModLab}, a::Float64)

# Wrapper of void TAxisModLab::SetColor(Int_t)
@trydoc raw"""
    SetColor(this::ByRef1{TAxisModLab}, c::Int32)::Nothing
Set modified label color.

""" SetColor(this::ByRef1{TAxisModLab}, c::Int32)

# Wrapper of void TAxisModLab::SetFont(Int_t)
@trydoc raw"""
    SetFont(this::ByRef1{TAxisModLab}, f::Int32)::Nothing
Set modified label font.

""" SetFont(this::ByRef1{TAxisModLab}, f::Int32)

# Wrapper of void TAxisModLab::SetLabNum(Int_t)
@trydoc raw"""
    SetLabNum(this::ByRef1{TAxisModLab}, n::Int32)::Nothing
Set modified label number.

""" SetLabNum(this::ByRef1{TAxisModLab}, n::Int32)

# Wrapper of void TAxisModLab::SetLabValue(Double_t)
@trydoc raw"""
    SetLabValue(this::ByRef1{TAxisModLab}, v::Float64)::Nothing
Set modified label value.

""" SetLabValue(this::ByRef1{TAxisModLab}, v::Float64)

# Wrapper of void TAxisModLab::SetSize(Double_t)
@trydoc raw"""
    SetSize(this::ByRef1{TAxisModLab}, s::Float64)::Nothing
Set modified label size.

""" SetSize(this::ByRef1{TAxisModLab}, s::Float64)

# Wrapper of void TAxisModLab::SetText(TString)
@trydoc raw"""
    SetText(this::ByRef1{TAxisModLab}, t::ByCopy{TString})::Nothing
Set modified label text.

""" SetText(this::ByRef1{TAxisModLab}, t::ByCopy{TString})

# Wrapper of Double_t TVirtualFitter::Chisquare(Int_t, Double_t *)
@trydoc raw"""
    Chisquare(this::ByConstRef1{TVirtualFitter}, npar::Int32, params::ByPtr2{Float64})::Float64


""" Chisquare(this::ByConstRef1{TVirtualFitter}, npar::Int32, params::ByPtr2{Float64})

# Wrapper of void TVirtualFitter::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TVirtualFitter}, option::ByCopy{String})::Nothing
Set name and title to empty strings ("").

""" Clear(this::ByRef1{TVirtualFitter}, option::ByCopy{String})

# Wrapper of Int_t TVirtualFitter::ExecuteCommand(const char *, Double_t *, Int_t)
@trydoc raw"""
    ExecuteCommand(this::ByRef1{TVirtualFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)::Int32


""" ExecuteCommand(this::ByRef1{TVirtualFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)

# Wrapper of void TVirtualFitter::FixParameter(Int_t)
@trydoc raw"""
    FixParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)::Nothing


""" FixParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of void TVirtualFitter::GetConfidenceIntervals(Int_t, Int_t, const Double_t *, Double_t *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)::Nothing
return confidence intervals in array x of dimension ndim implemented in [TFitter](@ref) and [TLinearFitter](@ref)

""" GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)

# Wrapper of void TVirtualFitter::GetConfidenceIntervals(TObject *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject}, cl::Float64)::Nothing
return confidence intervals in [TObject](@ref) obj implemented in [TFitter](@ref) and [TLinearFitter](@ref)

""" GetConfidenceIntervals(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject}, cl::Float64)

# Wrapper of Double_t * TVirtualFitter::GetCovarianceMatrix()
@trydoc raw"""
    GetCovarianceMatrix(this::ByConstRef1{TVirtualFitter})::CxxPtr2{Float64}


""" GetCovarianceMatrix(this::ByConstRef1{TVirtualFitter})

# Wrapper of Double_t TVirtualFitter::GetCovarianceMatrixElement(Int_t, Int_t)
@trydoc raw"""
    GetCovarianceMatrixElement(this::ByConstRef1{TVirtualFitter}, i::Int32, j::Int32)::Float64


""" GetCovarianceMatrixElement(this::ByConstRef1{TVirtualFitter}, i::Int32, j::Int32)

# Wrapper of Int_t TVirtualFitter::GetErrors(Int_t, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetErrors(this::ByConstRef1{TVirtualFitter}, ipar::Int32, eplus::ByRef2{Float64}, eminus::ByRef2{Float64}, eparab::ByRef2{Float64}, globcc::ByRef2{Float64})::Int32


""" GetErrors(this::ByConstRef1{TVirtualFitter}, ipar::Int32, eplus::ByRef2{Float64}, eminus::ByRef2{Float64}, eparab::ByRef2{Float64}, globcc::ByRef2{Float64})

# Wrapper of Foption_t TVirtualFitter::GetFitOption()
@trydoc raw"""
    GetFitOption(this::ByConstRef1{TVirtualFitter})::ByCopy{Foption_t}


""" GetFitOption(this::ByConstRef1{TVirtualFitter})

# Wrapper of TMethodCall * TVirtualFitter::GetMethodCall()
@trydoc raw"""
    GetMethodCall(this::ByConstRef1{TVirtualFitter})::CxxPtr1{TMethodCall}


""" GetMethodCall(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetNumberFreeParameters()
@trydoc raw"""
    GetNumberFreeParameters(this::ByConstRef1{TVirtualFitter})::Int32


""" GetNumberFreeParameters(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetNumberTotalParameters()
@trydoc raw"""
    GetNumberTotalParameters(this::ByConstRef1{TVirtualFitter})::Int32


""" GetNumberTotalParameters(this::ByConstRef1{TVirtualFitter})

# Wrapper of TObject * TVirtualFitter::GetObjectFit()
@trydoc raw"""
    GetObjectFit(this::ByConstRef1{TVirtualFitter})::CxxPtr1{TObject}


""" GetObjectFit(this::ByConstRef1{TVirtualFitter})

# Wrapper of Double_t TVirtualFitter::GetParameter(Int_t)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TVirtualFitter}, ipar::Int32)::Float64


""" GetParameter(this::ByConstRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of Int_t TVirtualFitter::GetParameter(Int_t, char *, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TVirtualFitter}, ipar::Int32, name::ByPtr2{Int8}, value::ByRef2{Float64}, verr::ByRef2{Float64}, vlow::ByRef2{Float64}, vhigh::ByRef2{Float64})::Int32


""" GetParameter(this::ByConstRef1{TVirtualFitter}, ipar::Int32, name::ByPtr2{Int8}, value::ByRef2{Float64}, verr::ByRef2{Float64}, vlow::ByRef2{Float64}, vhigh::ByRef2{Float64})

# Wrapper of Double_t TVirtualFitter::GetParError(Int_t)
@trydoc raw"""
    GetParError(this::ByConstRef1{TVirtualFitter}, ipar::Int32)::Float64


""" GetParError(this::ByConstRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of const char * TVirtualFitter::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TVirtualFitter}, ipar::Int32)::ByCopy{String}


""" GetParName(this::ByConstRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of Int_t TVirtualFitter::GetStats(Double_t &, Double_t &, Double_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetStats(this::ByConstRef1{TVirtualFitter}, amin::ByRef2{Float64}, edm::ByRef2{Float64}, errdef::ByRef2{Float64}, nvpar::ByRef2{Int32}, nparx::ByRef2{Int32})::Int32


""" GetStats(this::ByConstRef1{TVirtualFitter}, amin::ByRef2{Float64}, edm::ByRef2{Float64}, errdef::ByRef2{Float64}, nvpar::ByRef2{Int32}, nparx::ByRef2{Int32})

# Wrapper of Double_t TVirtualFitter::GetSumLog(Int_t)
@trydoc raw"""
    GetSumLog(this::ByRef1{TVirtualFitter}, i::Int32)::Float64


""" GetSumLog(this::ByRef1{TVirtualFitter}, i::Int32)

# Wrapper of TObject * TVirtualFitter::GetUserFunc()
@trydoc raw"""
    GetUserFunc(this::ByConstRef1{TVirtualFitter})::CxxPtr1{TObject}


""" GetUserFunc(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetXfirst()
@trydoc raw"""
    GetXfirst(this::ByConstRef1{TVirtualFitter})::Int32


""" GetXfirst(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetXlast()
@trydoc raw"""
    GetXlast(this::ByConstRef1{TVirtualFitter})::Int32


""" GetXlast(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetYfirst()
@trydoc raw"""
    GetYfirst(this::ByConstRef1{TVirtualFitter})::Int32


""" GetYfirst(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetYlast()
@trydoc raw"""
    GetYlast(this::ByConstRef1{TVirtualFitter})::Int32


""" GetYlast(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetZfirst()
@trydoc raw"""
    GetZfirst(this::ByConstRef1{TVirtualFitter})::Int32


""" GetZfirst(this::ByConstRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetZlast()
@trydoc raw"""
    GetZlast(this::ByConstRef1{TVirtualFitter})::Int32


""" GetZlast(this::ByConstRef1{TVirtualFitter})

# Wrapper of Bool_t TVirtualFitter::IsFixed(Int_t)
@trydoc raw"""
    IsFixed(this::ByConstRef1{TVirtualFitter}, ipar::Int32)::Bool


""" IsFixed(this::ByConstRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of void TVirtualFitter::PrintResults(Int_t, Double_t)
@trydoc raw"""
    PrintResults(this::ByConstRef1{TVirtualFitter}, level::Int32, amin::Float64)::Nothing


""" PrintResults(this::ByConstRef1{TVirtualFitter}, level::Int32, amin::Float64)

# Wrapper of void TVirtualFitter::ReleaseParameter(Int_t)
@trydoc raw"""
    ReleaseParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)::Nothing


""" ReleaseParameter(this::ByRef1{TVirtualFitter}, ipar::Int32)

# Wrapper of Double_t * TVirtualFitter::SetCache(Int_t, Int_t)
@trydoc raw"""
    SetCache(this::ByRef1{TVirtualFitter}, npoints::Int32, psize::Int32)::CxxPtr2{Float64}
Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point.
if (npoints*psize > fCacheSize) the existing cache is deleted and a new array is created. The function returns a pointer to the cache
""" SetCache(this::ByRef1{TVirtualFitter}, npoints::Int32, psize::Int32)

# Wrapper of void TVirtualFitter::SetFitMethod(const char *)
@trydoc raw"""
    SetFitMethod(this::ByRef1{TVirtualFitter}, name::ByCopy{String})::Nothing


""" SetFitMethod(this::ByRef1{TVirtualFitter}, name::ByCopy{String})

# Wrapper of void TVirtualFitter::SetFitOption(Foption_t)
@trydoc raw"""
    SetFitOption(this::ByRef1{TVirtualFitter}, option::ByCopy{Foption_t})::Nothing


""" SetFitOption(this::ByRef1{TVirtualFitter}, option::ByCopy{Foption_t})

# Wrapper of void TVirtualFitter::SetObjectFit(TObject *)
@trydoc raw"""
    SetObjectFit(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject})::Nothing


""" SetObjectFit(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject})

# Wrapper of Int_t TVirtualFitter::SetParameter(Int_t, const char *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TVirtualFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)::Int32


""" SetParameter(this::ByRef1{TVirtualFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)

# Wrapper of void TVirtualFitter::SetUserFunc(TObject *)
@trydoc raw"""
    SetUserFunc(this::ByRef1{TVirtualFitter}, userfunc::ByPtr1{TObject})::Nothing


""" SetUserFunc(this::ByRef1{TVirtualFitter}, userfunc::ByPtr1{TObject})

# Wrapper of void TVirtualFitter::SetXfirst(Int_t)
@trydoc raw"""
    SetXfirst(this::ByRef1{TVirtualFitter}, first::Int32)::Nothing


""" SetXfirst(this::ByRef1{TVirtualFitter}, first::Int32)

# Wrapper of void TVirtualFitter::SetXlast(Int_t)
@trydoc raw"""
    SetXlast(this::ByRef1{TVirtualFitter}, last::Int32)::Nothing


""" SetXlast(this::ByRef1{TVirtualFitter}, last::Int32)

# Wrapper of void TVirtualFitter::SetYfirst(Int_t)
@trydoc raw"""
    SetYfirst(this::ByRef1{TVirtualFitter}, first::Int32)::Nothing


""" SetYfirst(this::ByRef1{TVirtualFitter}, first::Int32)

# Wrapper of void TVirtualFitter::SetYlast(Int_t)
@trydoc raw"""
    SetYlast(this::ByRef1{TVirtualFitter}, last::Int32)::Nothing


""" SetYlast(this::ByRef1{TVirtualFitter}, last::Int32)

# Wrapper of void TVirtualFitter::SetZfirst(Int_t)
@trydoc raw"""
    SetZfirst(this::ByRef1{TVirtualFitter}, first::Int32)::Nothing


""" SetZfirst(this::ByRef1{TVirtualFitter}, first::Int32)

# Wrapper of void TVirtualFitter::SetZlast(Int_t)
@trydoc raw"""
    SetZlast(this::ByRef1{TVirtualFitter}, last::Int32)::Nothing


""" SetZlast(this::ByRef1{TVirtualFitter}, last::Int32)

# Wrapper of TVirtualFitter * TVirtualFitter::Fitter(TObject *, Int_t)
@trydoc raw"""
    TVirtualFitter!Fitter(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject}, maxpar::Int32)::CxxPtr1{TVirtualFitter}
Static function returning a pointer to the current fitter.
If the fitter does not exist, the default [TFitter](@ref) is created. Don't delete the returned fitter object, it will be re-used.
""" TVirtualFitter!Fitter(this::ByRef1{TVirtualFitter}, obj::ByPtr1{TObject}, maxpar::Int32)

# Wrapper of const char * TVirtualFitter::GetDefaultFitter()
@trydoc raw"""
    TVirtualFitter!GetDefaultFitter(this::ByRef1{TVirtualFitter})::ByCopy{String}
static: return the name of the default fitter

""" TVirtualFitter!GetDefaultFitter(this::ByRef1{TVirtualFitter})

# Wrapper of Double_t TVirtualFitter::GetErrorDef()
@trydoc raw"""
    TVirtualFitter!GetErrorDef(this::ByRef1{TVirtualFitter})::Float64
static: Return the Error Definition

""" TVirtualFitter!GetErrorDef(this::ByRef1{TVirtualFitter})

# Wrapper of TVirtualFitter * TVirtualFitter::GetFitter()
@trydoc raw"""
    TVirtualFitter!GetFitter(this::ByRef1{TVirtualFitter})::CxxPtr1{TVirtualFitter}
static: return the current Fitter

""" TVirtualFitter!GetFitter(this::ByRef1{TVirtualFitter})

# Wrapper of Int_t TVirtualFitter::GetMaxIterations()
@trydoc raw"""
    TVirtualFitter!GetMaxIterations(this::ByRef1{TVirtualFitter})::Int32
static: Return the maximum number of iterations actually max number of function calls

""" TVirtualFitter!GetMaxIterations(this::ByRef1{TVirtualFitter})

# Wrapper of Double_t TVirtualFitter::GetPrecision()
@trydoc raw"""
    TVirtualFitter!GetPrecision(this::ByRef1{TVirtualFitter})::Float64
static: Return the fit relative precision

""" TVirtualFitter!GetPrecision(this::ByRef1{TVirtualFitter})

# Wrapper of void TVirtualFitter::SetDefaultFitter(const char *)
@trydoc raw"""
    TVirtualFitter!SetDefaultFitter(this::ByRef1{TVirtualFitter}, name::ByCopy{String})::Nothing
static: set name of default fitter

""" TVirtualFitter!SetDefaultFitter(this::ByRef1{TVirtualFitter}, name::ByCopy{String})

# Wrapper of void TVirtualFitter::SetErrorDef(Double_t)
@trydoc raw"""
    TVirtualFitter!SetErrorDef(this::ByRef1{TVirtualFitter}, errdef::Float64)::Nothing
static: Set the Error Definition (default=1) For Minuit this is the value passed with the "SET ERR" command (see [https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html](https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html))

""" TVirtualFitter!SetErrorDef(this::ByRef1{TVirtualFitter}, errdef::Float64)

# Wrapper of void TVirtualFitter::SetFitter(TVirtualFitter *, Int_t)
@trydoc raw"""
    TVirtualFitter!SetFitter(this::ByRef1{TVirtualFitter}, fitter::ByPtr1{TVirtualFitter}, maxpar::Int32)::Nothing
Static function to set an alternative fitter.

""" TVirtualFitter!SetFitter(this::ByRef1{TVirtualFitter}, fitter::ByPtr1{TVirtualFitter}, maxpar::Int32)

# Wrapper of void TVirtualFitter::SetMaxIterations(Int_t)
@trydoc raw"""
    TVirtualFitter!SetMaxIterations(this::ByRef1{TVirtualFitter}, niter::Int32)::Nothing
static: Set the maximum number of function calls for the minimization algorithm For example for MIGRAD this is the maxcalls value passed as first argument (see [https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html](https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html) )

""" TVirtualFitter!SetMaxIterations(this::ByRef1{TVirtualFitter}, niter::Int32)

# Wrapper of void TVirtualFitter::SetPrecision(Double_t)
@trydoc raw"""
    TVirtualFitter!SetPrecision(this::ByRef1{TVirtualFitter}, prec::Float64)::Nothing
static: Set the tolerance used in the minimization algorithm For example for MIGRAD this is tolerance value passed as second argument (see [https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html](https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html) )

""" TVirtualFitter!SetPrecision(this::ByRef1{TVirtualFitter}, prec::Float64)

# Wrapper of Double_t TBackCompFitter::Chisquare(Int_t, Double_t *)
@trydoc raw"""
    Chisquare(this::ByConstRef1{TBackCompFitter}, npar::Int32, params::ByPtr2{Float64})::Float64
Do chisquare calculations in case of likelihood fits Do evaluation a the minimum only.

""" Chisquare(this::ByConstRef1{TBackCompFitter}, npar::Int32, params::ByPtr2{Float64})

# Wrapper of void TBackCompFitter::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TBackCompFitter}, option::ByCopy{String})::Nothing
Clear resources for consecutive fits.

""" Clear(this::ByRef1{TBackCompFitter}, option::ByCopy{String})

# Wrapper of bool TBackCompFitter::Contour(unsigned int, unsigned int, TGraph *, double)
@trydoc raw"""
    Contour(this::ByRef1{TBackCompFitter}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)::Bool
Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or is invalid it will return false on exit a [TGraph](@ref) is filled with the contour points the number of contour points is determined by the size of the [TGraph](@ref).
if the size is zero a default number of points = 20 is used pass optionally the confidence level, default is 0.683 it is assumed that ErrorDef() defines the right error definition (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level
""" Contour(this::ByRef1{TBackCompFitter}, ipar::UInt32, jpar::UInt32, gr::ByPtr1{TGraph}, confLevel::Float64)

# Wrapper of Int_t TBackCompFitter::ExecuteCommand(const char *, Double_t *, Int_t)
@trydoc raw"""
    ExecuteCommand(this::ByRef1{TBackCompFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)::Int32
Execute the command (Fortran Minuit compatible interface)

""" ExecuteCommand(this::ByRef1{TBackCompFitter}, command::ByCopy{String}, args::ByPtr2{Float64}, nargs::Int32)

# Wrapper of void TBackCompFitter::FixParameter(Int_t)
@trydoc raw"""
    FixParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)::Nothing
Fix the parameter.

""" FixParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of void TBackCompFitter::GetConfidenceIntervals(Int_t, Int_t, const Double_t *, Double_t *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)::Nothing
Computes point-by-point confidence intervals for the fitted function.
## Arguments

- **`n`** 
    number of points 
    
- **`ndim`** 
    dimensions of points 
    
- **`x`** 
    points, at which to compute the intervals, for ndim > 1 should be in order: (x0,y0, x1, y1, ... xn, yn) 
    
- **`ci`** 
    computed intervals are returned in this array 
    
- **`cl`** 
    confidence level, default=0.95
    

NOTE, that the intervals are approximate for nonlinear(in parameters) models
""" GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, n::Int32, ndim::Int32, x::ByConstPtr2{Float64}, ci::ByPtr2{Float64}, cl::Float64)

# Wrapper of void TBackCompFitter::GetConfidenceIntervals(TObject *, Double_t)
@trydoc raw"""
    GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, obj::ByPtr1{TObject}, cl::Float64)::Nothing
Computes confidence intervals at level cl.
Default is 0.95 The [TObject](@ref) parameter can be a [TGraphErrors](@ref), a [TGraph2DErrors](@ref) or a [TH1](@ref),2,3. For Graphs, confidence intervals are computed for each point, the value of the graph at that point is set to the function value at that point, and the graph y-errors (or z-errors) are set to the value of the confidence interval at that point. For Histograms, confidence intervals are computed for each bin center The bin content of this bin is then set to the function value at the bin center, and the bin error is set to the confidence interval value. NOTE: confidence intervals are approximate for nonlinear models!

Allowed combinations:

| **Fitted object**                 | **Passed object**                   |
|:----------------------------------|:------------------------------------|
| [TGraph](@ref)                    | [TGraphErrors](@ref), [TH1](@ref)   |
| [TGraphErrors](@ref), AsymmErrors | [TGraphErrors](@ref), [TH1](@ref)   |
| [TH1](@ref)                       | [TGraphErrors](@ref), [TH1](@ref)   |
| [TGraph2D](@ref)                  | [TGraph2DErrors](@ref), [TH2](@ref) |
| [TGraph2DErrors](@ref)            | [TGraph2DErrors](@ref), [TH2](@ref) |
| [TH2](@ref)                       | [TGraph2DErrors](@ref), [TH2](@ref) |
| [TH3](@ref)                       | [TH3](@ref)                         |
""" GetConfidenceIntervals(this::ByRef1{TBackCompFitter}, obj::ByPtr1{TObject}, cl::Float64)

# Wrapper of Double_t * TBackCompFitter::GetCovarianceMatrix()
@trydoc raw"""
    GetCovarianceMatrix(this::ByConstRef1{TBackCompFitter})::CxxPtr2{Float64}
Get the error matrix in a pointer to a NxN array.
excluding the fixed parameters
""" GetCovarianceMatrix(this::ByConstRef1{TBackCompFitter})

# Wrapper of Double_t TBackCompFitter::GetCovarianceMatrixElement(Int_t, Int_t)
@trydoc raw"""
    GetCovarianceMatrixElement(this::ByConstRef1{TBackCompFitter}, i::Int32, j::Int32)::Float64
Get error matrix element (return all zero if matrix is not available)

""" GetCovarianceMatrixElement(this::ByConstRef1{TBackCompFitter}, i::Int32, j::Int32)

# Wrapper of Int_t TBackCompFitter::GetErrors(Int_t, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetErrors(this::ByConstRef1{TBackCompFitter}, ipar::Int32, eplus::ByRef2{Float64}, eminus::ByRef2{Float64}, eparab::ByRef2{Float64}, globcc::ByRef2{Float64})::Int32
Get fit errors.

""" GetErrors(this::ByConstRef1{TBackCompFitter}, ipar::Int32, eplus::ByRef2{Float64}, eminus::ByRef2{Float64}, eparab::ByRef2{Float64}, globcc::ByRef2{Float64})

# Wrapper of Int_t TBackCompFitter::GetNumberFreeParameters()
@trydoc raw"""
    GetNumberFreeParameters(this::ByConstRef1{TBackCompFitter})::Int32


""" GetNumberFreeParameters(this::ByConstRef1{TBackCompFitter})

# Wrapper of Int_t TBackCompFitter::GetNumberTotalParameters()
@trydoc raw"""
    GetNumberTotalParameters(this::ByConstRef1{TBackCompFitter})::Int32
Number of total parameters.

""" GetNumberTotalParameters(this::ByConstRef1{TBackCompFitter})

# Wrapper of Double_t TBackCompFitter::GetParameter(Int_t)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TBackCompFitter}, ipar::Int32)::Float64
Parameter value.

""" GetParameter(this::ByConstRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of Int_t TBackCompFitter::GetParameter(Int_t, char *, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TBackCompFitter}, ipar::Int32, name::ByPtr2{Int8}, value::ByRef2{Float64}, verr::ByRef2{Float64}, vlow::ByRef2{Float64}, vhigh::ByRef2{Float64})::Int32
Get all parameter info (name, value, errors)

""" GetParameter(this::ByConstRef1{TBackCompFitter}, ipar::Int32, name::ByPtr2{Int8}, value::ByRef2{Float64}, verr::ByRef2{Float64}, vlow::ByRef2{Float64}, vhigh::ByRef2{Float64})

# Wrapper of Double_t TBackCompFitter::GetParError(Int_t)
@trydoc raw"""
    GetParError(this::ByConstRef1{TBackCompFitter}, ipar::Int32)::Float64
Parameter error.

""" GetParError(this::ByConstRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of const char * TBackCompFitter::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TBackCompFitter}, ipar::Int32)::ByCopy{String}
Return name of parameter ipar.

""" GetParName(this::ByConstRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of Int_t TBackCompFitter::GetStats(Double_t &, Double_t &, Double_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetStats(this::ByConstRef1{TBackCompFitter}, amin::ByRef2{Float64}, edm::ByRef2{Float64}, errdef::ByRef2{Float64}, nvpar::ByRef2{Int32}, nparx::ByRef2{Int32})::Int32
Get fit statistical information.

""" GetStats(this::ByConstRef1{TBackCompFitter}, amin::ByRef2{Float64}, edm::ByRef2{Float64}, errdef::ByRef2{Float64}, nvpar::ByRef2{Int32}, nparx::ByRef2{Int32})

# Wrapper of Double_t TBackCompFitter::GetSumLog(Int_t)
@trydoc raw"""
    GetSumLog(this::ByRef1{TBackCompFitter}, i::Int32)::Float64
Sum of log (un-needed)

""" GetSumLog(this::ByRef1{TBackCompFitter}, i::Int32)

# Wrapper of TFitResult * TBackCompFitter::GetTFitResult()
@trydoc raw"""
    GetTFitResult(this::ByConstRef1{TBackCompFitter})::CxxPtr1{TFitResult}
Get a copy of the Fit result returning directly a new [TFitResult](@ref).
Return a new copy of the [TFitResult](@ref) object which needs to be deleted later by the user.
""" GetTFitResult(this::ByConstRef1{TBackCompFitter})

# Wrapper of Bool_t TBackCompFitter::IsFixed(Int_t)
@trydoc raw"""
    IsFixed(this::ByConstRef1{TBackCompFitter}, ipar::Int32)::Bool
Query if parameter ipar is fixed.

""" IsFixed(this::ByConstRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of void TBackCompFitter::PrintResults(Int_t, Double_t)
@trydoc raw"""
    PrintResults(this::ByConstRef1{TBackCompFitter}, level::Int32, amin::Float64)::Nothing
Print the fit result.
Use PrintResults function in case of Minuit for old -style printing
""" PrintResults(this::ByConstRef1{TBackCompFitter}, level::Int32, amin::Float64)

# Wrapper of void TBackCompFitter::ReCreateMinimizer()
@trydoc raw"""
    ReCreateMinimizer(this::ByRef1{TBackCompFitter})::Nothing
Recreate a minimizer instance using the function and data set objective function in minimizers function to re-create FCN from stored data object and fit options.

""" ReCreateMinimizer(this::ByRef1{TBackCompFitter})

# Wrapper of void TBackCompFitter::ReleaseParameter(Int_t)
@trydoc raw"""
    ReleaseParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)::Nothing
Release a fit parameter.

""" ReleaseParameter(this::ByRef1{TBackCompFitter}, ipar::Int32)

# Wrapper of bool TBackCompFitter::Scan(unsigned int, TGraph *, double, double)
@trydoc raw"""
    Scan(this::ByRef1{TBackCompFitter}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)::Bool
Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return filled with the scan resul If the graph size is zero, a default size n = 40 will be used.

""" Scan(this::ByRef1{TBackCompFitter}, ipar::UInt32, gr::ByPtr1{TGraph}, xmin::Float64, xmax::Float64)

# Wrapper of void TBackCompFitter::SetFitMethod(const char *)
@trydoc raw"""
    SetFitMethod(this::ByRef1{TBackCompFitter}, name::ByCopy{String})::Nothing
Set fit method (chi2 or likelihood).
According to the method the appropriate FCN function will be created
""" SetFitMethod(this::ByRef1{TBackCompFitter}, name::ByCopy{String})

# Wrapper of void TBackCompFitter::SetMethodCall(TMethodCall *)
@trydoc raw"""
    SetMethodCall(this::ByRef1{TBackCompFitter}, m::ByPtr1{TMethodCall})::Nothing
For using interpreted function passed by the user.

""" SetMethodCall(this::ByRef1{TBackCompFitter}, m::ByPtr1{TMethodCall})

# Wrapper of Int_t TBackCompFitter::SetParameter(Int_t, const char *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TBackCompFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)::Int32
Set (add) a new fit parameter passing initial value, step size (verr) and parameter limits if vlow > vhigh the parameter is unbounded if the stepsize (verr) == 0 the parameter is treated as fixed.

""" SetParameter(this::ByRef1{TBackCompFitter}, ipar::Int32, parname::ByCopy{String}, value::Float64, verr::Float64, vlow::Float64, vhigh::Float64)

# Wrapper of Double_t TBinomialEfficiencyFitter::EvaluateFCN(const Double_t *)
@trydoc raw"""
    EvaluateFCN(this::ByRef1{TBinomialEfficiencyFitter}, par::ByConstPtr2{Float64})::Float64


""" EvaluateFCN(this::ByRef1{TBinomialEfficiencyFitter}, par::ByConstPtr2{Float64})

# Wrapper of TFitResultPtr TBinomialEfficiencyFitter::Fit(TF1 *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TBinomialEfficiencyFitter}, f1::ByPtr1{TF1}, option::ByCopy{String})::ByCopy{TFitResultPtr}
Carry out the fit of the given function to the given histograms.
If option "I" is used, the fit function will be averaged over the bin (the default is to evaluate it simply at the bin center).

If option "R" is used, the fit range will be taken from the fit function (the default is to use the entire histogram).

If option "S" a [TFitResult](@ref) object is returned and it can be used to obtain additional fit information, like covariance or correlation matrix.

Note that all parameter values, limits, and step sizes are copied from the input fit function f1 (so they should be set before calling this method. This is particularly relevant for the step sizes, taken to be the "error" set on input, as a null step size usually fixes the corresponding parameter. That is protected against, but in such cases an arbitrary starting step size will be used, and the reliability of the fit should be questioned). If parameters are to be fixed, this should be done by specifying non-null parameter limits, with lower limits larger than upper limits.

On output, f1 contains the fitted parameters and errors, as well as the number of degrees of freedom, and the goodness-of-fit estimator as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437.
""" Fit(this::ByRef1{TBinomialEfficiencyFitter}, f1::ByPtr1{TF1}, option::ByCopy{String})

# Wrapper of void TBinomialEfficiencyFitter::Set(const TH1 *, const TH1 *)
@trydoc raw"""
    Set(this::ByRef1{TBinomialEfficiencyFitter}, numerator::ByConstPtr1{TH1}, denominator::ByConstPtr1{TH1})::Nothing
Initialize with a new set of inputs.

""" Set(this::ByRef1{TBinomialEfficiencyFitter}, numerator::ByConstPtr1{TH1}, denominator::ByConstPtr1{TH1})

# Wrapper of void TBinomialEfficiencyFitter::SetPrecision(Double_t)
@trydoc raw"""
    SetPrecision(this::ByRef1{TBinomialEfficiencyFitter}, epsilon::Float64)::Nothing
Set the required integration precision, see [TF1!Integral()](@ref)
""" SetPrecision(this::ByRef1{TBinomialEfficiencyFitter}, epsilon::Float64)

# Wrapper of Double_t TConfidenceLevel::CLb(bool)
@trydoc raw"""
    CLb(this::ByConstRef1{TConfidenceLevel}, use_sMC::Bool)::Float64
Get the Confidence Level for the background only.

""" CLb(this::ByConstRef1{TConfidenceLevel}, use_sMC::Bool)

# Wrapper of Double_t TConfidenceLevel::CLs(bool)
@trydoc raw"""
    CLs(this::ByConstRef1{TConfidenceLevel}, use_sMC::Bool)::Float64
Get the Confidence Level defined by CLs = CLsb/CLb.
This quantity is stable w.r.t. background fluctuations.
""" CLs(this::ByConstRef1{TConfidenceLevel}, use_sMC::Bool)

# Wrapper of Double_t TConfidenceLevel::CLsb(bool)
@trydoc raw"""
    CLsb(this::ByConstRef1{TConfidenceLevel}, use_sMC::Bool)::Float64
Get the Confidence Level for the signal plus background hypothesis.

""" CLsb(this::ByConstRef1{TConfidenceLevel}, use_sMC::Bool)

# Wrapper of void TConfidenceLevel::Draw(const Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TConfidenceLevel}, option::ByCopy{String})::Nothing
Display sort of a "canonical" -2lnQ plot.
This results in a plot with 2 elements:

- The histogram of -2lnQ for background hypothesis (full)
- The histogram of -2lnQ for signal and background hypothesis (dashed)

The 2 histograms are respectively named b_hist and sb_hist.
""" Draw(this::ByRef1{TConfidenceLevel}, option::ByCopy{String})

# Wrapper of Double_t TConfidenceLevel::Get3sProbability()
@trydoc raw"""
    Get3sProbability(this::ByConstRef1{TConfidenceLevel})::Float64
Get 3s probability.

""" Get3sProbability(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Double_t TConfidenceLevel::Get5sProbability()
@trydoc raw"""
    Get5sProbability(this::ByConstRef1{TConfidenceLevel})::Float64
Get 5s probability.

""" Get5sProbability(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Double_t TConfidenceLevel::GetAverageCLs()
@trydoc raw"""
    GetAverageCLs(this::ByConstRef1{TConfidenceLevel})::Float64
Get average CLs.

""" GetAverageCLs(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Double_t TConfidenceLevel::GetAverageCLsb()
@trydoc raw"""
    GetAverageCLsb(this::ByConstRef1{TConfidenceLevel})::Float64
Get average CLsb.

""" GetAverageCLsb(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Double_t TConfidenceLevel::GetBtot()
@trydoc raw"""
    GetBtot(this::ByConstRef1{TConfidenceLevel})::Float64


""" GetBtot(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Int_t TConfidenceLevel::GetDtot()
@trydoc raw"""
    GetDtot(this::ByConstRef1{TConfidenceLevel})::Int32


""" GetDtot(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Double_t TConfidenceLevel::GetExpectedCLb_b(Int_t)
@trydoc raw"""
    GetExpectedCLb_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)::Float64
Get the expected Confidence Level for the background only if there is only background.

""" GetExpectedCLb_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)

# Wrapper of Double_t TConfidenceLevel::GetExpectedCLb_sb(Int_t)
@trydoc raw"""
    GetExpectedCLb_sb(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)::Float64
Get the expected Confidence Level for the background only if there is signal and background.

""" GetExpectedCLb_sb(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)

# Wrapper of Double_t TConfidenceLevel::GetExpectedCLs_b(Int_t)
@trydoc raw"""
    GetExpectedCLs_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)::Float64


""" GetExpectedCLs_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)

# Wrapper of Double_t TConfidenceLevel::GetExpectedCLsb_b(Int_t)
@trydoc raw"""
    GetExpectedCLsb_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)::Float64
Get the expected Confidence Level for the signal plus background hypothesis if there is only background.

""" GetExpectedCLsb_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)

# Wrapper of Double_t TConfidenceLevel::GetExpectedStatistic_b(Int_t)
@trydoc raw"""
    GetExpectedStatistic_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)::Float64
Get the expected statistic value in the background only hypothesis.

""" GetExpectedStatistic_b(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)

# Wrapper of Double_t TConfidenceLevel::GetExpectedStatistic_sb(Int_t)
@trydoc raw"""
    GetExpectedStatistic_sb(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)::Float64
Get the expected statistic value in the signal plus background hypothesis.

""" GetExpectedStatistic_sb(this::ByConstRef1{TConfidenceLevel}, sigma::Int32)

# Wrapper of Double_t TConfidenceLevel::GetStatistic()
@trydoc raw"""
    GetStatistic(this::ByConstRef1{TConfidenceLevel})::Float64


""" GetStatistic(this::ByConstRef1{TConfidenceLevel})

# Wrapper of Double_t TConfidenceLevel::GetStot()
@trydoc raw"""
    GetStot(this::ByConstRef1{TConfidenceLevel})::Float64


""" GetStot(this::ByConstRef1{TConfidenceLevel})

# Wrapper of void TConfidenceLevel::SetBtot(Double_t)
@trydoc raw"""
    SetBtot(this::ByRef1{TConfidenceLevel}, in::Float64)::Nothing


""" SetBtot(this::ByRef1{TConfidenceLevel}, in::Float64)

# Wrapper of void TConfidenceLevel::SetDtot(Int_t)
@trydoc raw"""
    SetDtot(this::ByRef1{TConfidenceLevel}, in::Int32)::Nothing


""" SetDtot(this::ByRef1{TConfidenceLevel}, in::Int32)

# Wrapper of void TConfidenceLevel::SetLRB(Double_t *)
@trydoc raw"""
    SetLRB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing


""" SetLRB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TConfidenceLevel::SetLRS(Double_t *)
@trydoc raw"""
    SetLRS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing


""" SetLRS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TConfidenceLevel::SetStot(Double_t)
@trydoc raw"""
    SetStot(this::ByRef1{TConfidenceLevel}, in::Float64)::Nothing


""" SetStot(this::ByRef1{TConfidenceLevel}, in::Float64)

# Wrapper of void TConfidenceLevel::SetTSB(Double_t *)
@trydoc raw"""
    SetTSB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing
Set the TSB.

""" SetTSB(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TConfidenceLevel::SetTSD(Double_t)
@trydoc raw"""
    SetTSD(this::ByRef1{TConfidenceLevel}, in::Float64)::Nothing


""" SetTSD(this::ByRef1{TConfidenceLevel}, in::Float64)

# Wrapper of void TConfidenceLevel::SetTSS(Double_t *)
@trydoc raw"""
    SetTSS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})::Nothing
Set the TSS.

""" SetTSS(this::ByRef1{TConfidenceLevel}, in::ByPtr2{Float64})

# Wrapper of void TEfficiency::Add(const TEfficiency &)
@trydoc raw"""
    Add(this::ByRef1{TEfficiency}, rEff::ByConstRef1{TEfficiency})::Nothing


""" Add(this::ByRef1{TEfficiency}, rEff::ByConstRef1{TEfficiency})

# Wrapper of void TEfficiency::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TEfficiency}, b::ByPtr1{TBrowser})::Nothing
Browse object. May be overridden for another default action.

""" Browse(this::ByRef1{TEfficiency}, b::ByPtr1{TBrowser})

# Wrapper of TGraphAsymmErrors * TEfficiency::CreateGraph(Option_t *)
@trydoc raw"""
    CreateGraph(this::ByConstRef1{TEfficiency}, opt::ByCopy{String})::CxxPtr1{TGraphAsymmErrors}
Create the graph used be painted (for dim=1 [TEfficiency](@ref)) The return object is managed by the caller.

""" CreateGraph(this::ByConstRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of TGraph2DAsymmErrors * TEfficiency::CreateGraph2D(Option_t *)
@trydoc raw"""
    CreateGraph2D(this::ByConstRef1{TEfficiency}, opt::ByCopy{String})::CxxPtr1{TGraph2DAsymmErrors}
Create the graph used be painted (for dim=1 [TEfficiency](@ref)) The return object is managed by the caller.

""" CreateGraph2D(this::ByConstRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of TH2 * TEfficiency::CreateHistogram(Option_t *)
@trydoc raw"""
    CreateHistogram(this::ByConstRef1{TEfficiency}, opt::ByCopy{String})::CxxPtr1{TH2}
Create the histogram used to be painted (for dim=2 [TEfficiency](@ref)) The return object is managed by the caller.

""" CreateHistogram(this::ByConstRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of Int_t TEfficiency::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TEfficiency}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a graph.
Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units.

Forward the call to the painted graph
""" DistancetoPrimitive(this::ByRef1{TEfficiency}, px::Int32, py::Int32)

# Wrapper of void TEfficiency::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TEfficiency}, opt::ByCopy{String})::Nothing
Draws the current [TEfficiency](@ref) object.
## Arguments

- **`opt`** [in] 
    - 1-dimensional case: same options as [TGraphAsymmErrors!Draw()](@ref) but as default "AP" is used
    - 2-dimensional case: by default use an histogram and in this case same options as [TH2!Draw()](@ref) if using instad option "GRAPH" a [TGraph2DAsymmErrors](@ref) is used and the same options as for [TGraph2D](@ref) applies
    - 3-dimensional case: not yet supported
    
    

Specific [TEfficiency](@ref) drawing options:

- E0 - plot bins where the total number of passed events is zero (the error interval will be [0,1] )
""" Draw(this::ByRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of void TEfficiency::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TEfficiency}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when the drawn class is clicked with the locator If Left button clicked on one of the line theend points, this point follows the cursor until button is released.

if Middle button clicked, the line is moved parallel to itself until the button is released. Forward the call to the underlying graph
""" ExecuteEvent(this::ByRef1{TEfficiency}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TEfficiency::Fill(Bool_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TEfficiency}, bPassed::Bool, x::Float64, y::Float64, z::Float64)::Nothing
This function is used for filling the two histograms.
## Arguments

- **`bPassed`** [in] 
    flag whether the current event passed the selection
    
    - true: both histograms are filled
    - false: only the total histogram is filled 
    
    
- **`x`** [in] 
    x-value 
    
- **`y`** [in] 
    y-value (use default=0 for 1-D efficiencies) 
    
- **`z`** [in] 
    z-value (use default=0 for 2-D or 1-D efficiencies)
""" Fill(this::ByRef1{TEfficiency}, bPassed::Bool, x::Float64, y::Float64, z::Float64)

# Wrapper of void TEfficiency::FillWeighted(Bool_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    FillWeighted(this::ByRef1{TEfficiency}, bPassed::Bool, weight::Float64, x::Float64, y::Float64, z::Float64)::Nothing
This function is used for filling the two histograms with a weight.
## Arguments

- **`bPassed`** [in] 
    flag whether the current event passed the selection
    
    - true: both histograms are filled
    - false: only the total histogram is filled 
    
    
- **`weight`** [in] 
    weight for the event 
    
- **`x`** [in] 
    x-value 
    
- **`y`** [in] 
    y-value (use default=0 for 1-D efficiencies) 
    
- **`z`** [in] 
    z-value (use default=0 for 2-D or 1-D efficiencies)
    

Note: - this function will call SetUseWeightedEvents if it was not called by the user before
""" FillWeighted(this::ByRef1{TEfficiency}, bPassed::Bool, weight::Float64, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TEfficiency::FindFixBin(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindFixBin(this::ByConstRef1{TEfficiency}, x::Float64, y::Float64, z::Float64)::Int32
Returns the global_ bin number containing the given values.
Note:

- values which belong to dimensions higher than the current dimension of the [TEfficiency](@ref) object are ignored (i.e. for 1-dimensional efficiencies only the x-value is considered)
""" FindFixBin(this::ByConstRef1{TEfficiency}, x::Float64, y::Float64, z::Float64)

# Wrapper of TFitResultPtr TEfficiency::Fit(TF1 *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TEfficiency}, f1::ByPtr1{TF1}, opt::ByCopy{String})::ByCopy{TFitResultPtr}
Fits the efficiency using the [TBinomialEfficiencyFitter](@ref) class.
The resulting fit function is added to the list of associated functions.

Options:

- "+": previous fitted functions in the list are kept, by default all functions in the list are deleted
- "N": do not store fitted function
- for more fitting options see [TBinomialEfficiencyFitter!Fit](@ref)
""" Fit(this::ByRef1{TEfficiency}, f1::ByPtr1{TF1}, opt::ByCopy{String})

# Wrapper of Double_t TEfficiency::GetBetaAlpha(Int_t)
@trydoc raw"""
    GetBetaAlpha(this::ByConstRef1{TEfficiency}, bin::Int32)::Float64


""" GetBetaAlpha(this::ByConstRef1{TEfficiency}, bin::Int32)

# Wrapper of Double_t TEfficiency::GetBetaBeta(Int_t)
@trydoc raw"""
    GetBetaBeta(this::ByConstRef1{TEfficiency}, bin::Int32)::Float64


""" GetBetaBeta(this::ByConstRef1{TEfficiency}, bin::Int32)

# Wrapper of Double_t TEfficiency::GetConfidenceLevel()
@trydoc raw"""
    GetConfidenceLevel(this::ByConstRef1{TEfficiency})::Float64


""" GetConfidenceLevel(this::ByConstRef1{TEfficiency})

# Wrapper of TH1 * TEfficiency::GetCopyPassedHisto()
@trydoc raw"""
    GetCopyPassedHisto(this::ByConstRef1{TEfficiency})::CxxPtr1{TH1}
Returns a cloned version of fPassedHistogram.
Notes:

- The histogram is filled with unit weights. You might want to scale it with the global_ weight [GetWeight()](@ref).
- The returned object is owned by the user who has to care about the deletion of the new [TH1](@ref) object.
- This histogram is by default NOT attached to the current directory to avoid duplication of data. If you want to store it automatically during the next [TFile!Write()](@ref) command, you have to attach it to the corresponding directory.

    TFile* pFile = new TFile("passed.root","update");
    TEfficiency* pEff = (TEfficiency*)gDirectory->Get("my_eff");
    TH1* copy = pEff->GetCopyPassedHisto();
    copy->SetDirectory(gDirectory);
    pFile->Write();

(C++ version of the code)
""" GetCopyPassedHisto(this::ByConstRef1{TEfficiency})

# Wrapper of TH1 * TEfficiency::GetCopyTotalHisto()
@trydoc raw"""
    GetCopyTotalHisto(this::ByConstRef1{TEfficiency})::CxxPtr1{TH1}
Returns a cloned version of fTotalHistogram.
Notes:

- The histogram is filled with unit weights. You might want to scale it with the global_ weight [GetWeight()](@ref).
- The returned object is owned by the user who has to care about the deletion of the new [TH1](@ref) object.
- This histogram is by default NOT attached to the current directory to avoid duplication of data. If you want to store it automatically during the next [TFile!Write()](@ref) command, you have to attach it to the corresponding directory.

    TFile* pFile = new TFile("total.root","update");
    TEfficiency* pEff = (TEfficiency*)gDirectory->Get("my_eff");
    TH1* copy = pEff->GetCopyTotalHisto();
    copy->SetDirectory(gDirectory);
    pFile->Write();

(C++ version of the code)
""" GetCopyTotalHisto(this::ByConstRef1{TEfficiency})

# Wrapper of Int_t TEfficiency::GetDimension()
@trydoc raw"""
    GetDimension(this::ByConstRef1{TEfficiency})::Int32
returns the dimension of the current [TEfficiency](@ref) object

""" GetDimension(this::ByConstRef1{TEfficiency})

# Wrapper of TDirectory * TEfficiency::GetDirectory()
@trydoc raw"""
    GetDirectory(this::ByConstRef1{TEfficiency})::CxxPtr1{TDirectory}


""" GetDirectory(this::ByConstRef1{TEfficiency})

# Wrapper of Double_t TEfficiency::GetEfficiency(Int_t)
@trydoc raw"""
    GetEfficiency(this::ByConstRef1{TEfficiency}, bin::Int32)::Float64
Returns the efficiency in the given global_ bin.
Note:

- The estimated efficiency depends on the chosen statistic option: for frequentist ones: $ \hat{\varepsilon} = \frac{passed}{total} $ for bayesian ones the expectation value of the resulting posterior distribution is returned: $ \hat{\varepsilon} = \frac{passed + \alpha}{total + \alpha + \beta} $ If the bit kPosteriorMode is set (or the method TEfficiency!UsePosteriorMode() has been called ) the mode (most probable value) of the posterior is returned: $ \hat{\varepsilon} = \frac{passed + \alpha -1}{total + \alpha + \beta -2} $

    - If the denominator is equal to 0, an efficiency of 0 is returned.
    - When $ passed + \alpha < 1 $ or $ total - passed + \beta < 1 $ the above formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1.
""" GetEfficiency(this::ByConstRef1{TEfficiency}, bin::Int32)

# Wrapper of Double_t TEfficiency::GetEfficiencyErrorLow(Int_t)
@trydoc raw"""
    GetEfficiencyErrorLow(this::ByConstRef1{TEfficiency}, bin::Int32)::Float64
Returns the lower error on the efficiency in the given global_ bin.
The result depends on the current confidence level fConfLevel and the chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for more details.

Note: If the histograms are filled with weights, only bayesian methods and the normal approximation are supported.
""" GetEfficiencyErrorLow(this::ByConstRef1{TEfficiency}, bin::Int32)

# Wrapper of Double_t TEfficiency::GetEfficiencyErrorUp(Int_t)
@trydoc raw"""
    GetEfficiencyErrorUp(this::ByConstRef1{TEfficiency}, bin::Int32)::Float64
Returns the upper error on the efficiency in the given global_ bin.
The result depends on the current confidence level fConfLevel and the chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for more details.

Note: If the histograms are filled with weights, only bayesian methods and the normal approximation are supported.
""" GetEfficiencyErrorUp(this::ByConstRef1{TEfficiency}, bin::Int32)

# Wrapper of Int_t TEfficiency::GetGlobalBin(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetGlobalBin(this::ByConstRef1{TEfficiency}, binx::Int32, biny::Int32, binz::Int32)::Int32
Returns the global_ bin number which can be used as argument for the following functions:
- GetEfficiency(bin), GetEfficiencyErrorLow(bin), GetEfficiencyErrorUp(bin)
- SetPassedEvents(bin), SetTotalEvents(bin)

see [TH1!GetBin()](@ref) for conventions on numbering bins
""" GetGlobalBin(this::ByConstRef1{TEfficiency}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of TList * TEfficiency::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByRef1{TEfficiency})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByRef1{TEfficiency})

# Wrapper of TGraphAsymmErrors * TEfficiency::GetPaintedGraph()
@trydoc raw"""
    GetPaintedGraph(this::ByConstRef1{TEfficiency})::CxxPtr1{TGraphAsymmErrors}


""" GetPaintedGraph(this::ByConstRef1{TEfficiency})

# Wrapper of TGraph2DAsymmErrors * TEfficiency::GetPaintedGraph2D()
@trydoc raw"""
    GetPaintedGraph2D(this::ByConstRef1{TEfficiency})::CxxPtr1{TGraph2DAsymmErrors}


""" GetPaintedGraph2D(this::ByConstRef1{TEfficiency})

# Wrapper of TH2 * TEfficiency::GetPaintedHistogram()
@trydoc raw"""
    GetPaintedHistogram(this::ByConstRef1{TEfficiency})::CxxPtr1{TH2}


""" GetPaintedHistogram(this::ByConstRef1{TEfficiency})

# Wrapper of const TH1 * TEfficiency::GetPassedHistogram()
@trydoc raw"""
    GetPassedHistogram(this::ByConstRef1{TEfficiency})::ConstCxxPtr1{TH1}


""" GetPassedHistogram(this::ByConstRef1{TEfficiency})

# Wrapper of const TH1 * TEfficiency::GetTotalHistogram()
@trydoc raw"""
    GetTotalHistogram(this::ByConstRef1{TEfficiency})::ConstCxxPtr1{TH1}


""" GetTotalHistogram(this::ByConstRef1{TEfficiency})

# Wrapper of Double_t TEfficiency::GetWeight()
@trydoc raw"""
    GetWeight(this::ByConstRef1{TEfficiency})::Float64


""" GetWeight(this::ByConstRef1{TEfficiency})

# Wrapper of Long64_t TEfficiency::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TEfficiency}, list::ByPtr1{TCollection})::Int64
Merges the [TEfficiency](@ref) objects in the given list to the given [TEfficiency](@ref) object using the operator+=(TEfficiency&)
The merged result is stored in the current object. The statistic options and the confidence level are taken from the current object.

This function should be used when all [TEfficiency](@ref) objects correspond to the same process.

The new weight is set according to: $  \frac{1}{w_{new}} = \sum_{i} \frac{1}{w_{i}} $
""" Merge(this::ByRef1{TEfficiency}, list::ByPtr1{TCollection})

# Wrapper of TEfficiency & TEfficiency::operator+=(const TEfficiency &)
@trydoc raw"""
    add!(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})::CxxRef1{TEfficiency}
Adds the histograms of another [TEfficiency](@ref) object to current histograms.
The statistic options and the confidence level remain unchanged.

fTotalHistogram += rhs.fTotalHistogram; fPassedHistogram += rhs.fPassedHistogram;

calculates a new weight: current weight of this [TEfficiency](@ref) object = $ w_{1} $ weight of rhs = $ w_{2} $ $ w_{new} = \frac{w_{1} \times w_{2}}{w_{1} + w_{2}} $
""" add!(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})

# Wrapper of TEfficiency & TEfficiency::operator=(const TEfficiency &)
@trydoc raw"""
    assign(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})::CxxRef1{TEfficiency}
Assignment operator.
The histograms, statistic option, confidence level, weight and paint styles of rhs are copied to the this [TEfficiency](@ref) object.

Note: - The list of associated functions is not copied. After this operation the list of associated functions is empty.
""" assign(this::ByRef1{TEfficiency}, rhs::ByConstRef1{TEfficiency})

# Wrapper of void TEfficiency::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TEfficiency}, opt::ByCopy{String})::Nothing
Paints this [TEfficiency](@ref) object.
For details on the possible option see [Draw(Option_t*)](@ref)

Note for 1D classes In 1D the [TEfficiency](@ref) uses a [TGraphAsymmErrors](@ref) for drawing The [TGraph](@ref) is created only the first time Paint is used. The user can manipulate the [TGraph](@ref) via the method [TEfficiency!GetPaintedGraph()](@ref) The [TGraph](@ref) creates behing an histogram for the axis. The histogram is created also only the first time. If the axis needs to be updated because in the meantime the class changed use this trick which will trigger a re-calculation of the axis of the graph [TEfficiency!GetPaintedGraph()](@ref)->Set(0)

Note that in order to access the painted graph via [GetPaintedGraph()](@ref) you need either to call Paint or better gPad->Update();
""" Paint(this::ByRef1{TEfficiency}, opt::ByCopy{String})

# Wrapper of void TEfficiency::SetBetaAlpha(Double_t)
@trydoc raw"""
    SetBetaAlpha(this::ByRef1{TEfficiency}, alpha::Float64)::Nothing
Sets the shape parameter α.
The prior probability of the efficiency is given by the beta distribution: 

``f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}``

Note: - both shape parameters have to be positive (i.e. > 0)
""" SetBetaAlpha(this::ByRef1{TEfficiency}, alpha::Float64)

# Wrapper of void TEfficiency::SetBetaBeta(Double_t)
@trydoc raw"""
    SetBetaBeta(this::ByRef1{TEfficiency}, beta::Float64)::Nothing
Sets the shape parameter β.
The prior probability of the efficiency is given by the beta distribution: 

``f(\varepsilon;\alpha,\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}``

Note: - both shape parameters have to be positive (i.e. > 0)
""" SetBetaBeta(this::ByRef1{TEfficiency}, beta::Float64)

# Wrapper of void TEfficiency::SetBetaBinParameters(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBetaBinParameters(this::ByRef1{TEfficiency}, bin::Int32, alpha::Float64, beta::Float64)::Nothing
Sets different shape parameter α and β for the prior distribution for each bin.
By default the global_ parameter are used if they are not set for the specific bin The prior probability of the efficiency is given by the beta distribution: 

``f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}``

Note:

- both shape parameters have to be positive (i.e. > 0)
- bin gives the global_ bin number (cf. GetGlobalBin)
""" SetBetaBinParameters(this::ByRef1{TEfficiency}, bin::Int32, alpha::Float64, beta::Float64)

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64})::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64})

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64)::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64)

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64)

# Wrapper of Bool_t TEfficiency::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)::Bool
Set the bins for the underlined passed and total histograms If the class have been already filled the previous contents will be lost.

""" SetBins(this::ByRef1{TEfficiency}, nx::Int32, xmin::Float64, xmax::Float64, ny::Int32, ymin::Float64, ymax::Float64, nz::Int32, zmin::Float64, zmax::Float64)

# Wrapper of void TEfficiency::SetCentralInterval(Bool_t)
@trydoc raw"""
    SetCentralInterval(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetCentralInterval(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetConfidenceLevel(Double_t)
@trydoc raw"""
    SetConfidenceLevel(this::ByRef1{TEfficiency}, level::Float64)::Nothing
Sets the confidence level (0 < level < 1) The default value is 1-sigma :~ 0.683.

""" SetConfidenceLevel(this::ByRef1{TEfficiency}, level::Float64)

# Wrapper of void TEfficiency::SetDirectory(TDirectory *)
@trydoc raw"""
    SetDirectory(this::ByRef1{TEfficiency}, dir::ByPtr1{TDirectory})::Nothing
Sets the directory holding this [TEfficiency](@ref) object.
A reference to this [TEfficiency](@ref) object is removed from the current directory (if it exists) and a new reference to this [TEfficiency](@ref) object is added to the given directory.

Notes: - If the given directory is 0, the [TEfficiency](@ref) object does not belong to any directory and will not be written to file during the next [TFile!Write()](@ref) command.
""" SetDirectory(this::ByRef1{TEfficiency}, dir::ByPtr1{TDirectory})

# Wrapper of void TEfficiency::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TEfficiency}, name::ByCopy{String})::Nothing
Sets the name.
Note: The names of the internal histograms are set to "name + _total" and "name + _passed" respectively.
""" SetName(this::ByRef1{TEfficiency}, name::ByCopy{String})

# Wrapper of Bool_t TEfficiency::SetPassedHistogram(const TH1 &, Option_t *)
@trydoc raw"""
    SetPassedHistogram(this::ByRef1{TEfficiency}, rPassed::ByConstRef1{TH1}, opt::ByCopy{String})::Bool
Sets the histogram containing the passed events.
The given histogram is cloned and stored internally as histogram containing the passed events. The given histogram has to be consistent with the current fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fPassedHistogram has been replaced (true) or not (false).

Note: The list of associated functions fFunctions is cleared.

Option:

- "f": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fTotalHistogram is replaced by a consistent one (with respect to rPassed) as well.
""" SetPassedHistogram(this::ByRef1{TEfficiency}, rPassed::ByConstRef1{TH1}, opt::ByCopy{String})

# Wrapper of void TEfficiency::SetPosteriorAverage(Bool_t)
@trydoc raw"""
    SetPosteriorAverage(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetPosteriorAverage(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetPosteriorMode(Bool_t)
@trydoc raw"""
    SetPosteriorMode(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetPosteriorMode(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetShortestInterval(Bool_t)
@trydoc raw"""
    SetShortestInterval(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetShortestInterval(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{TEfficiency}, title::ByCopy{String})::Nothing
Sets the title.
Notes:

- The titles of the internal histograms are set to "title + (total)" or "title + (passed)" respectively.
- It is possible to label the axis of the histograms as usual (see [TH1!SetTitle](@ref)).

Example: Setting the title to "My Efficiency" and label the axis pEff->SetTitle("My Efficiency;x label;eff");
""" SetTitle(this::ByRef1{TEfficiency}, title::ByCopy{String})

# Wrapper of Bool_t TEfficiency::SetTotalEvents(Int_t, Double_t)
@trydoc raw"""
    SetTotalEvents(this::ByRef1{TEfficiency}, bin::Int32, events::Float64)::Bool
Sets the number of total events in the given global_ bin.
returns "true" if the number of total events has been updated otherwise "false" ist returned

Note: - requires: fPassedHistogram->GetBinContent(bin) <= events
""" SetTotalEvents(this::ByRef1{TEfficiency}, bin::Int32, events::Float64)

# Wrapper of Bool_t TEfficiency::SetTotalHistogram(const TH1 &, Option_t *)
@trydoc raw"""
    SetTotalHistogram(this::ByRef1{TEfficiency}, rTotal::ByConstRef1{TH1}, opt::ByCopy{String})::Bool
Sets the histogram containing all events.
The given histogram is cloned and stored internally as histogram containing all events. The given histogram has to be consistent with the current fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fTotalHistogram has been replaced (true) or not (false).

Note: The list of associated functions fFunctions is cleared.

Option:

- "f": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fPassedHistogram is replaced by a consistent one (with respect to rTotal) as well.
""" SetTotalHistogram(this::ByRef1{TEfficiency}, rTotal::ByConstRef1{TH1}, opt::ByCopy{String})

# Wrapper of void TEfficiency::SetUseWeightedEvents(Bool_t)
@trydoc raw"""
    SetUseWeightedEvents(this::ByRef1{TEfficiency}, on::Bool)::Nothing


""" SetUseWeightedEvents(this::ByRef1{TEfficiency}, on::Bool)

# Wrapper of void TEfficiency::SetWeight(Double_t)
@trydoc raw"""
    SetWeight(this::ByRef1{TEfficiency}, weight::Float64)::Nothing
Sets the global_ weight for this [TEfficiency](@ref) object.
Note: - weight has to be positive ( > 0)
""" SetWeight(this::ByRef1{TEfficiency}, weight::Float64)

# Wrapper of Bool_t TEfficiency::UsesBayesianStat()
@trydoc raw"""
    UsesBayesianStat(this::ByConstRef1{TEfficiency})::Bool


""" UsesBayesianStat(this::ByConstRef1{TEfficiency})

# Wrapper of Bool_t TEfficiency::UsesCentralInterval()
@trydoc raw"""
    UsesCentralInterval(this::ByConstRef1{TEfficiency})::Bool


""" UsesCentralInterval(this::ByConstRef1{TEfficiency})

# Wrapper of Bool_t TEfficiency::UsesPosteriorAverage()
@trydoc raw"""
    UsesPosteriorAverage(this::ByConstRef1{TEfficiency})::Bool


""" UsesPosteriorAverage(this::ByConstRef1{TEfficiency})

# Wrapper of Bool_t TEfficiency::UsesPosteriorMode()
@trydoc raw"""
    UsesPosteriorMode(this::ByConstRef1{TEfficiency})::Bool


""" UsesPosteriorMode(this::ByConstRef1{TEfficiency})

# Wrapper of Bool_t TEfficiency::UsesShortestInterval()
@trydoc raw"""
    UsesShortestInterval(this::ByConstRef1{TEfficiency})::Bool


""" UsesShortestInterval(this::ByConstRef1{TEfficiency})

# Wrapper of Bool_t TEfficiency::UsesWeights()
@trydoc raw"""
    UsesWeights(this::ByConstRef1{TEfficiency})::Bool


""" UsesWeights(this::ByConstRef1{TEfficiency})

# Wrapper of Double_t TEfficiency::AgrestiCoull(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!AgrestiCoull(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)::Float64
Calculates the boundaries for the frequentist Agresti-Coull interval.
## Arguments

- **`total`** 
    number of total events 
    
- **`passed`** 
    0 <= number of passed events <= total 
    
- **`level`** 
    confidence level 
    
- **`bUpper`** 
    true - upper boundary is returned false - lower boundary is returned
    

\thebegin{eqnarray*}
  \alpha &=& 1 - \frac{level}{2} \\
  \kappa &=& \Phi^{-1}(1 - \alpha,1)\ ... normal\ quantile\ function\\
  mode &=& \frac{passed + \frac{\kappa^{2}}{2}}{total + \kappa^{2}}\\
  \Delta &=& \kappa * \sqrt{\frac{mode * (1 - mode)}{total + \kappa^{2}}}\\
  return &=&  max(0,mode - \Delta)\ or\ min(1,mode + \Delta)
\theend{eqnarray*}
""" TEfficiency!AgrestiCoull(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)

# Wrapper of Double_t TEfficiency::Bayesian(Double_t, Double_t, Double_t, Double_t, Double_t, Bool_t, Bool_t)
@trydoc raw"""
    TEfficiency!Bayesian(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, alpha::Float64, beta::Float64, bUpper::Bool, bShortest::Bool)::Float64
Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending on the option) as explained in D.
Casadei, Estimating the selection efficiency, 2012 JINST 7 P08021, [https://doi.org/10.1088/1748-0221/7/08/P08021](https://doi.org/10.1088/1748-0221/7/08/P08021) ([https://arxiv.org/abs/0908.0130](https://arxiv.org/abs/0908.0130)).

## Arguments

- **`total`** [in] 
    number of total events 
    
- **`passed`** [in] 
    0 <= number of passed events <= total 
    
- **`level`** [in] 
    confidence level 
    
- **`alpha`** [in] 
    shape parameter > 0 for the prior distribution (fBeta_alpha) 
    
- **`beta`** [in] 
    shape parameter > 0 for the prior distribution (fBeta_beta) 
    
- **`bUpper`** [in] 
    - true - upper boundary is returned
    - false - lower boundary is returned 
    
    
- **`bShortest`** [in] 
    ??
    

Note: In the case central confidence interval is calculated. when passed = 0 (or passed = total) the lower (or upper) interval values will be larger than 0 (or smaller than 1).

Calculation:

The posterior probability in bayesian statistics is given by: 

``P(\varepsilon |k,N) \propto L(\varepsilon|k,N) \times Prior(\varepsilon)``

 As an efficiency can be interpreted as probability of a positive outcome of a Bernoullli trial the likelihood function is given by the binomial distribution: 

``L(\varepsilon|k,N) = Binomial(N,k) \varepsilon ^{k} (1 - \varepsilon)^{N-k}``

 At the moment only beta distributions are supported as prior probabilities of the efficiency ( $ B(\alpha,\beta)$ is the beta function): 

``Prior(\varepsilon) = \frac{1}{B(\alpha,\beta)} \varepsilon ^{\alpha - 1} (1 - \varepsilon)^{\beta - 1}``

 The posterior probability is therefore again given by a beta distribution: 

``P(\varepsilon |k,N) \propto \varepsilon ^{k + \alpha - 1} (1 - \varepsilon)^{N - k + \beta - 1}``

 In case of central intervals the lower boundary for the equal-tailed confidence interval is given by the inverse cumulative (= quantile) function for the quantile $ \frac{1 - level}{2} $. The upper boundary for the equal-tailed confidence interval is given by the inverse cumulative (= quantile) function for the quantile $ \frac{1 + level}{2} $. Hence it is the solution $ \varepsilon $ of the following equation: 

``I_{\varepsilon}(k + \alpha,N - k + \beta) = \frac{1}{norm} \int_{0}^{\varepsilon} dt t^{k + \alpha - 1} (1 - t)^{N - k + \beta - 1} =  \frac{1 \pm level}{2}``

 In the case of shortest interval the minimum interval around the mode is found by minimizing the length of all intervals width the given probability content. See [TEfficiency!BetaShortestInterval](@ref)
""" TEfficiency!Bayesian(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, alpha::Float64, beta::Float64, bUpper::Bool, bShortest::Bool)

# Wrapper of Double_t TEfficiency::BetaCentralInterval(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!BetaCentralInterval(this::ByRef1{TEfficiency}, level::Float64, alpha::Float64, beta::Float64, bUpper::Bool)::Float64
Calculates the boundaries for a central confidence interval for a Beta distribution.
## Arguments

- **`level`** [in] 
    confidence level 
    
- **`a`** [in] 
    parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha 
    
- **`b`** [in] 
    parameter > 0 for the beta distribution (for a posterior is (total-passed) + prior_beta 
    
- **`bUpper`** [in] 
    true - upper boundary is returned false - lower boundary is returned
""" TEfficiency!BetaCentralInterval(this::ByRef1{TEfficiency}, level::Float64, alpha::Float64, beta::Float64, bUpper::Bool)

# Wrapper of Double_t TEfficiency::BetaMean(Double_t, Double_t)
@trydoc raw"""
    TEfficiency!BetaMean(this::ByRef1{TEfficiency}, alpha::Float64, beta::Float64)::Float64
Compute the mean (average) of the beta distribution.
## Arguments

- **`a`** [in] 
    parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha 
    
- **`b`** [in] 
    parameter > 0 for the beta distribution (for a posterior is (total-passed) + prior_beta
""" TEfficiency!BetaMean(this::ByRef1{TEfficiency}, alpha::Float64, beta::Float64)

# Wrapper of Double_t TEfficiency::BetaMode(Double_t, Double_t)
@trydoc raw"""
    TEfficiency!BetaMode(this::ByRef1{TEfficiency}, alpha::Float64, beta::Float64)::Float64
Compute the mode of the beta distribution.
## Arguments

- **`a`** [in] 
    parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha 
    
- **`b`** [in] 
    parameter > 0 for the beta distribution (for a posterior is (total-passed) + prior_beta
    

note the mode is defined for a Beta(a,b) only if (a,b)>1 (a = passed+alpha; b = total-passed+beta) return then the following in case (a,b) < 1:

- if (a==b) return 0.5 (it is really undefined)
- if (a < b) return 0;
- if (a > b) return 1;
""" TEfficiency!BetaMode(this::ByRef1{TEfficiency}, alpha::Float64, beta::Float64)

# Wrapper of Bool_t TEfficiency::BetaShortestInterval(Double_t, Double_t, Double_t, Double_t &, Double_t &)
@trydoc raw"""
    TEfficiency!BetaShortestInterval(this::ByRef1{TEfficiency}, level::Float64, alpha::Float64, beta::Float64, lower::ByRef2{Float64}, upper::ByRef2{Float64})::Bool
Calculates the boundaries for a shortest confidence interval for a Beta distribution.
## Arguments

- **`level`** [in] 
    confidence level 
    
- **`a`** [in] 
    parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha 
    
- **`b`** [in] 
    parameter > 0 for the beta distribution (for a posterior is (total-passed) + prior_beta 
    
- **`upper`** [out] 
    upper boundary is returned 
    
- **`lower`** [out] 
    lower boundary is returned
    

The lower/upper boundary are then obtained by finding the shortest interval of the beta distribution contained the desired probability level. The length of all possible intervals is minimized in order to find the shortest one
""" TEfficiency!BetaShortestInterval(this::ByRef1{TEfficiency}, level::Float64, alpha::Float64, beta::Float64, lower::ByRef2{Float64}, upper::ByRef2{Float64})

# Wrapper of Bool_t TEfficiency::CheckBinning(const TH1 &, const TH1 &)
@trydoc raw"""
    TEfficiency!CheckBinning(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1})::Bool
Checks binning for each axis.
It is assumed that the passed histograms have the same dimension.
""" TEfficiency!CheckBinning(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1})

# Wrapper of Bool_t TEfficiency::CheckConsistency(const TH1 &, const TH1 &, Option_t *)
@trydoc raw"""
    TEfficiency!CheckConsistency(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1}, opt::ByCopy{String})::Bool
Checks the consistence of the given histograms.
The histograms are considered as consistent if:

- both have the same dimension
- both have the same binning
- pass.GetBinContent(i) <= total.GetBinContent(i) for each bin i
""" TEfficiency!CheckConsistency(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1}, opt::ByCopy{String})

# Wrapper of Bool_t TEfficiency::CheckEntries(const TH1 &, const TH1 &, Option_t *)
@trydoc raw"""
    TEfficiency!CheckEntries(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1}, opt::ByCopy{String})::Bool
Checks whether bin contents are compatible with binomial statistics.
The following inequality has to be valid for each bin i: total.GetBinContent(i) >= pass.GetBinContent(i)

Note:

- It is assumed that both histograms have the same dimension and binning.
""" TEfficiency!CheckEntries(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1}, opt::ByCopy{String})

# Wrapper of Bool_t TEfficiency::CheckWeights(const TH1 &, const TH1 &)
@trydoc raw"""
    TEfficiency!CheckWeights(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1})::Bool
Check if both histogram are weighted.
If they are weighted a true is returned
""" TEfficiency!CheckWeights(this::ByRef1{TEfficiency}, pass::ByConstRef1{TH1}, total::ByConstRef1{TH1})

# Wrapper of Double_t TEfficiency::ClopperPearson(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!ClopperPearson(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)::Float64
Calculates the boundaries for the frequentist Clopper-Pearson interval.
This interval is recommended by the PDG.

## Arguments

- **`total`** [in] 
    number of total events 
    
- **`passed`** [in] 
    0 <= number of passed events <= total 
    
- **`level`** [in] 
    confidence level 
    
- **`bUpper`** [in] 
    true - upper boundary is returned ;false - lower boundary is returned
    

Calculation:

The lower boundary of the Clopper-Pearson interval is the "exact" inversion of the test: \thebegin{eqnarray*}
      P(x \geq passed; total) &=& \frac{1 - level}{2}\\
      P(x \geq passed; total) &=& 1 - P(x \leq passed - 1; total)\\
      &=& 1 - \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed} (1 - t)^{passed - 1} dt\\
      &=& 1 - \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed - 1} (1 - t)^{total - passed} dt\\
      &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed - 1} (1 - t)^{total - passed} dt\\
      &=& I_{\varepsilon}(passed,total - passed + 1)
    \theend{eqnarray*} The lower boundary is therefore given by the $ \frac{1 - level}{2}$ quantile of the beta distribution.

The upper boundary of the Clopper-Pearson interval is the "exact" inversion of the test: \thebegin{eqnarray*}
      P(x \leq passed; total) &=& \frac{1 - level}{2}\\
      P(x \leq passed; total) &=& \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed - 1} (1 - t)^{passed} dt\\
      &=& \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed} (1 - t)^{total - passed - 1} dt\\
      &=& 1 - \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed - 1} dt\\
      \Rightarrow 1 - \frac{1 - level}{2} &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed -1} dt\\
      \frac{1 + level}{2} &=& I_{\varepsilon}(passed + 1,total - passed)
    \theend{eqnarray*} The upper boundary is therefore given by the $\frac{1 + level}{2}$ quantile of the beta distribution.

Note: The connection between the binomial distribution and the regularized incomplete beta function $ I_{\varepsilon}(\alpha,\beta)$ has been used.
""" TEfficiency!ClopperPearson(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)

# Wrapper of Double_t TEfficiency::Combine(Double_t &, Double_t &, Int_t, const Int_t *, const Int_t *, Double_t, Double_t, Double_t, const Double_t *, Option_t *)
@trydoc raw"""
    TEfficiency!Combine(this::ByRef1{TEfficiency}, up::ByRef2{Float64}, low::ByRef2{Float64}, n::Int32, pass::ByConstPtr2{Int32}, total::ByConstPtr2{Int32}, alpha::Float64, beta::Float64, level::Float64, w::ByConstPtr2{Float64}, opt::ByCopy{String})::Float64

```
Calculates the combined efficiency and its uncertainties

This method does a bayesian combination of the given samples.

\param[in] up  contains the upper limit of the confidence interval afterwards
\param[in] low  contains the lower limit of the confidence interval afterwards
\param[in] n    number of samples which are combined
\param[in] pass array of length n containing the number of passed events
\param[in] total array of length n containing the corresponding numbers of total events
\param[in] alpha  shape parameters for the beta distribution as prior
\param[in] beta   shape parameters for the beta distribution as prior
\param[in] level  desired confidence level
\param[in] w weights for each sample; if not given, all samples get the weight 1
          The weights do not need to be normalized, since they are internally renormalized
          to the number of effective entries.
\param[in] opt
  -  mode : The mode is returned instead of the mean of the posterior as best value
            When using the mode the shortest interval is also computed instead of the central one
  -  shortest: compute shortest interval (done by default if mode option is set)
  -  central: compute central interval (done by default if mode option is NOT set)

Calculation:

The combined posterior distributions is calculated from the Bayes theorem assuming a common prior Beta distribution.
    It is easy to proof that the combined posterior is then:
```  \thebegin{eqnarray*}
      P_{comb}(\epsilon |{w_{i}}; {k_{i}}; {N_{i}}) &=& B(\epsilon, \sum_{i}{ w_{i} k_{i}} + \alpha, \sum_{i}{ w_{i}(n_{i}-k_{i})}+\beta)\\
      w_{i} &=& weight\ for\ each\ sample\ renormalized\ to\ the\ effective\ entries\\
      w^{'}_{i} &=&  w_{i} \frac{ \sum_{i} {w_{i} } } { \sum_{i} {w_{i}^{2} } }
    \theend{eqnarray*}

The estimated efficiency is the mode (or the mean) of the obtained posterior distribution

The boundaries of the confidence interval for a confidence level (1 - a) are given by the a/2 and 1-a/2 quantiles of the resulting cumulative distribution.

Example (uniform prior distribution):

(C++ version of the code)

![https://root.cern/doc/v636/pict1_TEfficiency_006.png](https://root.cern/doc/v636/pict1_TEfficiency_006.png)
""" TEfficiency!Combine(this::ByRef1{TEfficiency}, up::ByRef2{Float64}, low::ByRef2{Float64}, n::Int32, pass::ByConstPtr2{Int32}, total::ByConstPtr2{Int32}, alpha::Float64, beta::Float64, level::Float64, w::ByConstPtr2{Float64}, opt::ByCopy{String})

# Wrapper of TGraphAsymmErrors * TEfficiency::Combine(TCollection *, Option_t *, Int_t, const Double_t *)
@trydoc raw"""
    TEfficiency!Combine(this::ByRef1{TEfficiency}, pList::ByPtr1{TCollection}, opt::ByCopy{String}, n::Int32, w::ByConstPtr2{Float64})::CxxPtr1{TGraphAsymmErrors}
Combines a list of 1-dimensional [TEfficiency](@ref) objects.
A [TGraphAsymmErrors](@ref) object is returned which contains the estimated efficiency and its uncertainty for each bin. If the combination fails, a zero pointer is returned.

At the moment the combining is only implemented for bayesian statistics.

## Arguments

- **`pList`** [in] 
    list containing [TEfficiency](@ref) objects which should be combined only one-dimensional efficiencies are taken into account 
    
- **`option`** [in] 
    - s : strict combining; only [TEfficiency](@ref) objects with the same beta prior and the flag kIsBayesian == true are combined If not specified the prior parameter of the first [TEfficiency](@ref) object is used
    - v : verbose mode; print information about combining
    - cl=x : set confidence level (0 < cl < 1). If not specified, the confidence level of the first [TEfficiency](@ref) object is used.
    - mode Use mode of combined posterior as estimated value for the efficiency
    - shortest: compute shortest interval (done by default if mode option is set)
    - central: compute central interval (done by default if mode option is NOT set) 
    
    
- **`n`** [in] 
    number of weights (has to be the number of one-dimensional [TEfficiency](@ref) objects in pList) If no weights are passed, the internal weights [GetWeight()](@ref) of the given [TEfficiency](@ref) objects are used. 
    
- **`w`** [in] 
    array of length n with weights for each [TEfficiency](@ref) object in pList (w[0] correspond to pList->First ... w[n-1] -> pList->Last) The weights do not have to be normalised.
    

For each bin the calculation is done by the Combine(double&, double& ...) method.
""" TEfficiency!Combine(this::ByRef1{TEfficiency}, pList::ByPtr1{TCollection}, opt::ByCopy{String}, n::Int32, w::ByConstPtr2{Float64})

# Wrapper of Double_t TEfficiency::FeldmanCousins(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!FeldmanCousins(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)::Float64
Calculates the boundaries for the frequentist Feldman-Cousins interval.
## Arguments

- **`total`** 
    number of total events 
    
- **`passed`** 
    0 <= number of passed events <= total 
    
- **`level`** 
    confidence level 
    
- **`bUpper`** 
    true - upper boundary is returned false - lower boundary is returned
""" TEfficiency!FeldmanCousins(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)

# Wrapper of Bool_t TEfficiency::FeldmanCousinsInterval(Double_t, Double_t, Double_t, Double_t &, Double_t &)
@trydoc raw"""
    TEfficiency!FeldmanCousinsInterval(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, lower::ByRef2{Float64}, upper::ByRef2{Float64})::Bool
Calculates the interval boundaries using the frequentist methods of Feldman-Cousins.
## Arguments

- **`total`** [in] 
    number of total events 
    
- **`passed`** [in] 
    0 <= number of passed events <= total 
    
- **`level`** [in] 
    confidence level 
    
- **`lower`** [out] 
    lower boundary returned on exit 
    
- **`upper`** [out] 
    lower boundary returned on exit 
    

###Return

a flag with the status of the calculation

Calculation:

The Feldman-Cousins is a frequentist method where the interval is estimated using a Neyman construction where the ordering is based on the likelihood ratio: 

``LR =  \frac{Binomial(k | N, \epsilon)}{Binomial(k | N, \hat{\epsilon} ) }``

 See G. J. Feldman and R. D. Cousins, Phys. Rev. D57 (1998) 3873 and R. D. Cousins, K. E. Hymes, J. Tucker, Nuclear Instruments and Methods in Physics Research A 612 (2010) 388

Implemented using classes developed by Jordan Tucker and Luca Lista See File hist/hist/src/TEfficiencyHelper.h
""" TEfficiency!FeldmanCousinsInterval(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, lower::ByRef2{Float64}, upper::ByRef2{Float64})

# Wrapper of Double_t TEfficiency::MidPInterval(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!MidPInterval(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)::Float64
Calculates the boundaries using the mid-P binomial interval (Lancaster method) from B.
Cousing and J. Tucker. See [http://arxiv.org/abs/0905.3831](http://arxiv.org/abs/0905.3831) for a description and references for the method

Modify equal_tailed to get the kind of interval you want. Can also be converted to interval on ratio of poisson means X/Y by the substitutions 

    X = passed
    total = X + Y
    lower_poisson = lower/(1 - lower)
    upper_poisson = upper/(1 - upper)

(C++ version of the code)
""" TEfficiency!MidPInterval(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)

# Wrapper of Double_t TEfficiency::Normal(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!Normal(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)::Float64
Returns the confidence limits for the efficiency supposing that the efficiency follows a normal distribution with the rms below.
## Arguments

- **`total`** [in] 
    number of total events 
    
- **`passed`** [in] 
    0 <= number of passed events <= total 
    
- **`level`** [in] 
    confidence level 
    
- **`bUpper`** [in] 
    - true - upper boundary is returned
    - false - lower boundary is returned
    
    

Calculation:

\thebegin{eqnarray*}
      \hat{\varepsilon} &=& \frac{passed}{total}\\
      \sigma_{\varepsilon} &=& \sqrt{\frac{\hat{\varepsilon} (1 - \hat{\varepsilon})}{total}}\\
      \varepsilon_{low} &=& \hat{\varepsilon} \pm \Phi^{-1}(\frac{level}{2},\sigma_{\varepsilon})
\theend{eqnarray*}
""" TEfficiency!Normal(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)

# Wrapper of Double_t TEfficiency::Wilson(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TEfficiency!Wilson(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)::Float64
Calculates the boundaries for the frequentist Wilson interval.
## Arguments

- **`total`** [in] 
    number of total events 
    
- **`passed`** [in] 
    0 <= number of passed events <= total 
    
- **`level`** [in] 
    confidence level 
    
- **`bUpper`** [in] 
    - true - upper boundary is returned
    - false - lower boundary is returned
    
    

Calculation: \thebegin{eqnarray*}
      \alpha &=& 1 - \frac{level}{2}\\
      \kappa &=& \Phi^{-1}(1 - \alpha,1) ...\ normal\ quantile\ function\\
      mode &=& \frac{passed + \frac{\kappa^{2}}{2}}{total + \kappa^{2}}\\
      \Delta &=& \frac{\kappa}{total + \kappa^{2}} * \sqrt{passed (1 - \frac{passed}{total}) + \frac{\kappa^{2}}{4}}\\
      return &=& max(0,mode - \Delta)\ or\ min(1,mode + \Delta)
\theend{eqnarray*}
""" TEfficiency!Wilson(this::ByRef1{TEfficiency}, total::Float64, passed::Float64, level::Float64, bUpper::Bool)

# Wrapper of void TGraphAsymmErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphAsymmErrors}, f::ByPtr1{TF1})::Nothing
Apply a function to all data points $ y = f(x,y) $.
Errors are calculated as $ eyh = f(x,y+eyh)-f(x,y) $ and $ eyl = f(x,y)-f(x,y-eyl) $

Special treatment has to be applied for the functions where the role of "up" and "down" is reversed.

Function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphAsymmErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphAsymmErrors::BayesDivide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    BayesDivide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
This function is only kept for backward compatibility.
You should rather use the Divide method. It calls `Divide(pass,total,"cl=0.683 b(1,1) mode")` which is equivalent to the former BayesDivide method.
""" BayesDivide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of void TGraphAsymmErrors::ComputeRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    ComputeRange(this::ByConstRef1{TGraphAsymmErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Compute Range.

""" ComputeRange(this::ByConstRef1{TGraphAsymmErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of void TGraphAsymmErrors::Divide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
Fill this [TGraphAsymmErrors](@ref) by dividing two 1-dimensional histograms pass/total.
This method serves two purposes:

### 1) calculating efficiencies:

The assumption is that the entries in "pass" are a subset of those in "total". That is, we create an "efficiency" graph, where each entry is between 0 and 1, inclusive.

If the histograms are not filled with unit weights, the number of effective entries is used to normalise the bin contents which might lead to wrong results. 

``\text{effective entries} = \frac{(\sum w_{i})^{2}}{\sum w_{i}^{2}}``

 The points are assigned a x value at the center of each histogram bin. The y values are $\text{eff} = \frac{\text{pass}}{\text{total}}$ for all options except for the bayesian methods where the result depends on the chosen option.

If the denominator becomes 0 or pass > total, the corresponding bin is skipped.

### 2) calculating ratios of two Poisson means (option 'pois'):

The two histograms are interpreted as independent Poisson processes and the ratio 

``\tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}``

 with $\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}$. The histogram 'pass' is interpreted as $n_{1}$ and the total histogram is used for $n_{2}$.

The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties of efficiency by a parameter transformation: 

``\Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}``

The x errors span each histogram bin (lowedge ... lowedge+width) The y errors depend on the chosen statistic methode which can be determined by the options given below. For a detailed description of the used statistic calculations please have a look at the corresponding functions!

Options:

- v : verbose mode: prints information about the number of used bins and calculated efficiencies with their errors
- cl=x : determine the used confidence level (0<x<1) (default is 0.683)
- cp : Clopper-Pearson interval (see [TEfficiency!ClopperPearson](@ref))
- w : Wilson interval (see [TEfficiency!Wilson](@ref))
- n : normal approximation propagation (see [TEfficiency!Normal](@ref))
- ac : Agresti-Coull interval (see [TEfficiency!AgrestiCoull](@ref))
- fc : Feldman-Cousins interval (see [TEfficiency!FeldmanCousinsInterval](@ref))
- midp : Lancaster mid-P interval (see [TEfficiency!MidPInterval](@ref))
- [b(a,b)](@ref): bayesian interval using a prior probability ~Beta(a,b); a,b > 0 (see [TEfficiency!Bayesian](@ref))
- mode : use mode of posterior for Bayesian interval (default is mean)
- shortest: use shortest interval (done by default if mode is set)
- central: use central interval (done by default if mode is NOT set)
- pois: interpret histograms as poisson ratio instead of efficiency
- e0 : plot efficiency and interval for bins where total=0 (default is to skip them)

Note: Unfortunately there is no straightforward approach for determining a confidence interval for a given confidence level. The actual coverage probability of the confidence interval oscillates significantly according to the total number of events and the true efficiency. In order to decrease the impact of this oscillation on the actual coverage probability a couple of approximations and methodes has been developed. For a detailed discussion, please have a look at this statistical paper: [http://www-stat.wharton.upenn.edu/~tcai/paper/Binomial-StatSci.pdf](http://www-stat.wharton.upenn.edu/~tcai/paper/Binomial-StatSci.pdf)
""" Divide(this::ByRef1{TGraphAsymmErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of Double_t TGraphAsymmErrors::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraphAsymmErrors}, bin::Int32)::Float64
Returns the combined error along X at point i by computing the average of the lower and upper variance.

""" GetErrorX(this::ByConstRef1{TGraphAsymmErrors}, bin::Int32)

# Wrapper of Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t)
@trydoc raw"""
    GetErrorXhigh(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)::Float64
Get high error on X.

""" GetErrorXhigh(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraphAsymmErrors::GetErrorXlow(Int_t)
@trydoc raw"""
    GetErrorXlow(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)::Float64
Get low error on X.

""" GetErrorXlow(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraphAsymmErrors::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraphAsymmErrors}, bin::Int32)::Float64
Returns the combined error along Y at point i by computing the average of the lower and upper variance.

""" GetErrorY(this::ByConstRef1{TGraphAsymmErrors}, bin::Int32)

# Wrapper of Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)::Float64
Get high error on Y.

""" GetErrorYhigh(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraphAsymmErrors::GetErrorYlow(Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)::Float64
Get low error on Y.

""" GetErrorYlow(this::ByConstRef1{TGraphAsymmErrors}, i::Int32)

# Wrapper of Double_t * TGraphAsymmErrors::GetEXhigh()
@trydoc raw"""
    GetEXhigh(this::ByConstRef1{TGraphAsymmErrors})::CxxPtr2{Float64}


""" GetEXhigh(this::ByConstRef1{TGraphAsymmErrors})

# Wrapper of Double_t * TGraphAsymmErrors::GetEXlow()
@trydoc raw"""
    GetEXlow(this::ByConstRef1{TGraphAsymmErrors})::CxxPtr2{Float64}


""" GetEXlow(this::ByConstRef1{TGraphAsymmErrors})

# Wrapper of Double_t * TGraphAsymmErrors::GetEYhigh()
@trydoc raw"""
    GetEYhigh(this::ByConstRef1{TGraphAsymmErrors})::CxxPtr2{Float64}


""" GetEYhigh(this::ByConstRef1{TGraphAsymmErrors})

# Wrapper of Double_t * TGraphAsymmErrors::GetEYlow()
@trydoc raw"""
    GetEYlow(this::ByConstRef1{TGraphAsymmErrors})::CxxPtr2{Float64}


""" GetEYlow(this::ByConstRef1{TGraphAsymmErrors})

# Wrapper of Int_t TGraphAsymmErrors::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TGraphAsymmErrors}, list::ByPtr1{TCollection})::Int32
Adds all graphs with asymmetric errors from the collection to this graph.
Returns the total number of points in the result or -1 in case of an error.
""" Merge(this::ByRef1{TGraphAsymmErrors}, list::ByPtr1{TCollection})

# Wrapper of TGraphAsymmErrors & TGraphAsymmErrors::operator=(const TGraphAsymmErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraphAsymmErrors}, gr::ByConstRef1{TGraphAsymmErrors})::CxxRef1{TGraphAsymmErrors}
[TGraphAsymmErrors](@ref) assignment operator.

""" assign(this::ByRef1{TGraphAsymmErrors}, gr::ByConstRef1{TGraphAsymmErrors})

# Wrapper of void TGraphAsymmErrors::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraphAsymmErrors}, chopt::ByCopy{String})::Nothing
Print graph and errors values.

""" Print(this::ByConstRef1{TGraphAsymmErrors}, chopt::ByCopy{String})

# Wrapper of void TGraphAsymmErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphAsymmErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphAsymmErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "xy" both x and y values and errors are scaled
""" Scale(this::ByRef1{TGraphAsymmErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphAsymmErrors::SetPointError(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphAsymmErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)::Nothing
Set ex and ey values for point pointed by the mouse.

""" SetPointError(this::ByRef1{TGraphAsymmErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointError(Int_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)::Nothing
Set ex and ey values for point number i.

""" SetPointError(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEXhigh(Int_t, Double_t)
@trydoc raw"""
    SetPointEXhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, exh::Float64)::Nothing
Set EXhigh for point `i`.

""" SetPointEXhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, exh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEXlow(Int_t, Double_t)
@trydoc raw"""
    SetPointEXlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64)::Nothing
Set EXlow for point `i`.

""" SetPointEXlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, exl::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEYhigh(Int_t, Double_t)
@trydoc raw"""
    SetPointEYhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyh::Float64)::Nothing
Set EYhigh for point `i`.

""" SetPointEYhigh(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyh::Float64)

# Wrapper of void TGraphAsymmErrors::SetPointEYlow(Int_t, Double_t)
@trydoc raw"""
    SetPointEYlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyl::Float64)::Nothing
Set EYlow for point `i`.

""" SetPointEYlow(this::ByRef1{TGraphAsymmErrors}, i::Int32, eyl::Float64)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraph2DAsymmErrors}, bin::Int32)::Float64
Returns the combined error along X at point i by computing the average of the lower and upper variance.

""" GetErrorX(this::ByConstRef1{TGraph2DAsymmErrors}, bin::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorXhigh(Int_t)
@trydoc raw"""
    GetErrorXhigh(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)::Float64
Returns the high error along X at point i.

""" GetErrorXhigh(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorXlow(Int_t)
@trydoc raw"""
    GetErrorXlow(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)::Float64
Returns the low error along X at point i.

""" GetErrorXlow(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraph2DAsymmErrors}, bin::Int32)::Float64
Returns the combined error along Y at point i by computing the average of the lower and upper variance.

""" GetErrorY(this::ByConstRef1{TGraph2DAsymmErrors}, bin::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorYhigh(Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)::Float64
Returns the high error along Y at point i.

""" GetErrorYhigh(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorYlow(Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)::Float64
Returns the low error along Y at point i.

""" GetErrorYlow(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorZ(Int_t)
@trydoc raw"""
    GetErrorZ(this::ByConstRef1{TGraph2DAsymmErrors}, bin::Int32)::Float64
Returns the combined error along Z at point i by computing the average of the lower and upper variance.

""" GetErrorZ(this::ByConstRef1{TGraph2DAsymmErrors}, bin::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorZhigh(Int_t)
@trydoc raw"""
    GetErrorZhigh(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)::Float64
Returns the high error along Z at point i.

""" GetErrorZhigh(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)

# Wrapper of Double_t TGraph2DAsymmErrors::GetErrorZlow(Int_t)
@trydoc raw"""
    GetErrorZlow(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)::Float64
Returns the low error along Z at point i.

""" GetErrorZlow(this::ByConstRef1{TGraph2DAsymmErrors}, i::Int32)

# Wrapper of Double_t * TGraph2DAsymmErrors::GetEXhigh()
@trydoc raw"""
    GetEXhigh(this::ByConstRef1{TGraph2DAsymmErrors})::CxxPtr2{Float64}


""" GetEXhigh(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t * TGraph2DAsymmErrors::GetEXlow()
@trydoc raw"""
    GetEXlow(this::ByConstRef1{TGraph2DAsymmErrors})::CxxPtr2{Float64}


""" GetEXlow(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t * TGraph2DAsymmErrors::GetEYhigh()
@trydoc raw"""
    GetEYhigh(this::ByConstRef1{TGraph2DAsymmErrors})::CxxPtr2{Float64}


""" GetEYhigh(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t * TGraph2DAsymmErrors::GetEYlow()
@trydoc raw"""
    GetEYlow(this::ByConstRef1{TGraph2DAsymmErrors})::CxxPtr2{Float64}


""" GetEYlow(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t * TGraph2DAsymmErrors::GetEZhigh()
@trydoc raw"""
    GetEZhigh(this::ByConstRef1{TGraph2DAsymmErrors})::CxxPtr2{Float64}


""" GetEZhigh(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t * TGraph2DAsymmErrors::GetEZlow()
@trydoc raw"""
    GetEZlow(this::ByConstRef1{TGraph2DAsymmErrors})::CxxPtr2{Float64}


""" GetEZlow(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t TGraph2DAsymmErrors::GetXmaxE()
@trydoc raw"""
    GetXmaxE(this::ByConstRef1{TGraph2DAsymmErrors})::Float64
Returns the X maximum with errors.

""" GetXmaxE(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t TGraph2DAsymmErrors::GetXminE()
@trydoc raw"""
    GetXminE(this::ByConstRef1{TGraph2DAsymmErrors})::Float64
Returns the X minimum with errors.

""" GetXminE(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t TGraph2DAsymmErrors::GetYmaxE()
@trydoc raw"""
    GetYmaxE(this::ByConstRef1{TGraph2DAsymmErrors})::Float64
Returns the Y maximum with errors.

""" GetYmaxE(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t TGraph2DAsymmErrors::GetYminE()
@trydoc raw"""
    GetYminE(this::ByConstRef1{TGraph2DAsymmErrors})::Float64
Returns the Y minimum with errors.

""" GetYminE(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t TGraph2DAsymmErrors::GetZmaxE()
@trydoc raw"""
    GetZmaxE(this::ByConstRef1{TGraph2DAsymmErrors})::Float64
Returns the Z maximum with errors.

""" GetZmaxE(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of Double_t TGraph2DAsymmErrors::GetZminE()
@trydoc raw"""
    GetZminE(this::ByConstRef1{TGraph2DAsymmErrors})::Float64
Returns the Z minimum with errors.

""" GetZminE(this::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of TGraph2DAsymmErrors & TGraph2DAsymmErrors::operator=(const TGraph2DAsymmErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraph2DAsymmErrors}, ::ByConstRef1{TGraph2DAsymmErrors})::CxxRef1{TGraph2DAsymmErrors}
Assignment operator Copy everything except list of functions.

""" assign(this::ByRef1{TGraph2DAsymmErrors}, ::ByConstRef1{TGraph2DAsymmErrors})

# Wrapper of void TGraph2DAsymmErrors::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraph2DAsymmErrors}, chopt::ByCopy{String})::Nothing
Print 2D graph and errors values.

""" Print(this::ByConstRef1{TGraph2DAsymmErrors}, chopt::ByCopy{String})

# Wrapper of Int_t TGraph2DAsymmErrors::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph2DAsymmErrors}, ipoint::Int32)::Int32
Deletes point number ipoint.

""" RemovePoint(this::ByRef1{TGraph2DAsymmErrors}, ipoint::Int32)

# Wrapper of void TGraph2DAsymmErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph2DAsymmErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraph2DAsymmErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "z" the z values and errors are scaled If option contains "xyz" all three x, y and z values and errors are scaled
""" Scale(this::ByRef1{TGraph2DAsymmErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph2DAsymmErrors::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph2DAsymmErrors}, n::Int32)::Nothing
Set number of points in the 2D graph.
Existing coordinates are preserved. New coordinates above fNpoints are preset to 0.
""" Set(this::ByRef1{TGraph2DAsymmErrors}, n::Int32)

# Wrapper of void TGraph2DAsymmErrors::SetPoint(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, x::Float64, y::Float64, z::Float64)::Nothing
Set x, y and z values for point number i.

""" SetPoint(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2DAsymmErrors::SetPointError(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, ezl::Float64, ezh::Float64)::Nothing
Set ex, ey and ez values for point number i.

""" SetPointError(this::ByRef1{TGraph2DAsymmErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, ezl::Float64, ezh::Float64)

# Wrapper of void TH2::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, bin::Int32)

# Wrapper of void TH2::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, bin::Int32, w::Float64)

# Wrapper of void TH2::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of void TH2::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of Int_t TH2::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TH2}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TH2}, action::Int32)

# Wrapper of void TH2::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2}, hnew::ByRef1{TObject})

# Wrapper of Int_t TH2::Fill(const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,namey

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH2::Fill(const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, namex::ByCopy{String}, y::Float64, w::Float64)::Int32
Increment cell defined by namex,y by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,y

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, namex::ByCopy{String}, y::Float64, w::Float64)

# Wrapper of Int_t TH2::Fill(Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, x::Float64, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to x,y.

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, x::Float64, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH2::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, x::Float64, y::Float64)::Int32
Increment cell defined by x,y by 1.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the storage of the sum of squares of weights has been triggered, via the function Sumw2, then the sum of the squares of weights is incremented by 1 in the cell corresponding to x,y.

The function returns the corresponding global_ bin number which has its content incremented by 1
""" Fill(this::ByRef1{TH2}, x::Float64, y::Float64)

# Wrapper of Int_t TH2::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2}, x::Float64, y::Float64, w::Float64)::Int32
Increment cell defined by x,y by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to x,y

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH2}, x::Float64, y::Float64, w::Float64)

# Wrapper of void TH2::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill a 2-D histogram with an array of values and weights.
- ntimes: number of entries in arrays x and w (array size must be ntimes*stride)
- x: array of x values to be histogrammed
- y: array of y values to be histogrammed
- w: array of weights
- stride: step size through arrays x, y and w

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w[i]^2 in the bin corresponding to x[i],y[i].
    - If w is NULL each entry is assumed a weight=1

NB: function only valid for a TH2x object
""" FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of void TH2::FillN(Int_t, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill this histogram with an array x and weights w.
## Arguments

- **`ntimes`** [in] 
    number of entries in arrays x and w (array size must be ntimes*stride) 
    
- **`x`** [in] 
    array of values to be histogrammed 
    
- **`w`** [in] 
    array of weighs 
    
- **`stride`** [in] 
    step size through arrays x and w
    

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x. if w is NULL each entry is assumed a weight=1
""" FillN(this::ByRef1{TH2}, ntimes::Int32, x::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of void TH2::FillRandom(const char *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH2}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in function fname.
## Arguments

- **`fname`** 
    : Function name used for filling the histogram 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used to sample
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents for the bin range of this histogram. It is normalized to 1.

Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

One can also call [TF1!GetRandom](@ref) to get a random variate from a function.
""" FillRandom(this::ByRef1{TH2}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH2::FillRandom(TH1 *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH2}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in histogram h.
## Arguments

- **`h`** 
    : Histogram pointer used for sampling random number 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used for sampling
    

The distribution contained in the histogram h ([TH2](@ref)) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated
""" FillRandom(this::ByRef1{TH2}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH2::FitSlicesX(TF1 *, Int_t, Int_t, Int_t, Option_t *, TObjArray *)
@trydoc raw"""
    FitSlicesX(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstybin::Int32, lastybin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})::Nothing
Project slices along X in case of a 2-D histogram, then fit each slice with function f1 and make a histogram for each fit parameter Only bins along Y between firstybin and lastybin are considered.
By default (firstybin == 0, lastybin == -1), all bins in y including over- and underflows are taken into account. If f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along X via f1->SetRange(xmin,xmax) The argument option (default="QNR") can be used to change the fit options.

- "Q" means Quiet mode
- "N" means do not show the result of the fit
- "R" means fit the function in the specified function range
- "G2" merge 2 consecutive bins along X
- "G3" merge 3 consecutive bins along X
- "G4" merge 4 consecutive bins along X
- "G5" merge 5 consecutive bins along X
- "S" sliding merge: merge n consecutive bins along X accordingly to what Gn is given. It makes sense when used together with a Gn option

The generated histograms are returned by adding them to arr, if arr is not NULL. arr's SetOwner() is called, to signal that it is the user's responsibility to delete the histograms, possibly by deleting the array. 

    TObjArray aSlices;
    h2->FitSlicesX(func, 0, -1, 0, "QNR", &aSlices);

(C++ version of the code)

 will already delete the histograms once aSlice goes out of scope. aSlices will contain the histogram for the i-th parameter of the fit function at aSlices[i]; aSlices[n] (n being the number of parameters) contains the chi2 distribution of the fits.

If arr is NULL, the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.

Example: Assume a 2-d histogram h2 

    Root > h2->FitSlicesX(); produces 4 TH1D histograms
           with h2_0 containing parameter 0(Constant) for a Gaus fit
                     of each bin in Y projected along X
           with h2_1 containing parameter 1(Mean) for a gaus fit
           with h2_2 containing parameter 2(StdDev)  for a gaus fit
           with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit
    Root > h2->FitSlicesX(0,15,22,10);
           same as above, but only for bins 15 to 22 along Y
           and only for bins in Y for which the corresponding projection
           along X has more than cut bins filled.

(C++ version of the code)

 NOTE: To access the generated histograms in the current directory, do eg: 

    TH1D *h2_1 = (TH1D*)gDirectory->Get("h2_1");

(C++ version of the code)
""" FitSlicesX(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstybin::Int32, lastybin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})

# Wrapper of void TH2::FitSlicesY(TF1 *, Int_t, Int_t, Int_t, Option_t *, TObjArray *)
@trydoc raw"""
    FitSlicesY(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstxbin::Int32, lastxbin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})::Nothing
Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a histogram for each fit parameter Only bins along X between firstxbin and lastxbin are considered.
By default (firstxbin == 0, lastxbin == -1), all bins in x including over- and underflows are taken into account. If f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along Y via f1->SetRange(ymin,ymax) The argument option (default="QNR") can be used to change the fit options.

- "Q" means Quiet mode
- "N" means do not show the result of the fit
- "R" means fit the function in the specified function range
- "G2" merge 2 consecutive bins along Y
- "G3" merge 3 consecutive bins along Y
- "G4" merge 4 consecutive bins along Y
- "G5" merge 5 consecutive bins along Y
- "S" sliding merge: merge n consecutive bins along Y accordingly to what Gn is given. It makes sense when used together with a Gn option

The generated histograms are returned by adding them to arr, if arr is not NULL. arr's SetOwner() is called, to signal that it is the user's responsibility to delete the histograms, possibly by deleting the array. 

    TObjArray aSlices;
    h2->FitSlicesY(func, 0, -1, 0, "QNR", &aSlices);

(C++ version of the code)

 will already delete the histograms once aSlice goes out of scope. aSlices will contain the histogram for the i-th parameter of the fit function at aSlices[i]; aSlices[n] (n being the number of parameters) contains the chi2 distribution of the fits.

If arr is NULL, the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.

Example: Assume a 2-d histogram h2 

    Root > h2->FitSlicesY(); produces 4 TH1D histograms
           with h2_0 containing parameter 0(Constant) for a Gaus fit
                     of each bin in X projected along Y
           with h2_1 containing parameter 1(Mean) for a gaus fit
           with h2_2 containing parameter 2(StdDev)  for a gaus fit
           with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit
    Root > h2->FitSlicesY(0,15,22,10);
           same as above, but only for bins 15 to 22 along X
           and only for bins in X for which the corresponding projection
           along Y has more than cut bins filled.

(C++ version of the code)

NOTE: To access the generated histograms in the current directory, do eg: 

    TH1D *h2_1 = (TH1D*)gDirectory->Get("h2_1");

(C++ version of the code)

A complete example of this function is given in tutorial:fitslicesy.C.
""" FitSlicesY(this::ByRef1{TH2}, f1::ByPtr1{TF1}, firstxbin::Int32, lastxbin::Int32, cut::Int32, option::ByCopy{String}, arr::ByPtr1{TObjArray})

# Wrapper of Int_t TH2::GetBin(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBin(this::ByConstRef1{TH2}, binx::Int32, biny::Int32, binz::Int32)::Int32
Return Global bin number corresponding to binx,y,z.
2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions.

In case of a TH1x, returns binx directly. see [TH1!GetBinXYZ](@ref) for the inverse transformation.

Convention for numbering bins

For all histogram types: nbins, xlow, xup

- bin = 0; underflow bin
- bin = 1; first bin with low-edge xlow INCLUDED
- bin = nbins; last bin with upper-edge xup EXCLUDED
- bin = nbins+1; overflow bin

In case of 2-D or 3-D histograms, a "global_ bin" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function

    Int_t bin = h->GetBin(binx,biny,binz);

(C++ version of the code)

returns a global_/linearized bin number. This global_ bin is useful to access the bin information independently of the dimension.
""" GetBin(this::ByConstRef1{TH2}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH2::GetBinContent(Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH2}, binx::Int32, biny::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of Double_t TH2::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH2}, binx::Int32, biny::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH2}, binx::Int32, biny::Int32, ::Int32)

# Wrapper of Double_t TH2::GetBinErrorLow(Int_t, Int_t)
@trydoc raw"""
    GetBinErrorLow(this::ByRef1{TH2}, binx::Int32, biny::Int32)::Float64


""" GetBinErrorLow(this::ByRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of Double_t TH2::GetBinErrorUp(Int_t, Int_t)
@trydoc raw"""
    GetBinErrorUp(this::ByRef1{TH2}, binx::Int32, biny::Int32)::Float64


""" GetBinErrorUp(this::ByRef1{TH2}, binx::Int32, biny::Int32)

# Wrapper of Double_t TH2::GetBinWithContent2(Double_t, Int_t &, Int_t &, Int_t, Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    GetBinWithContent2(this::ByConstRef1{TH2}, c::Float64, binx::ByRef2{Int32}, biny::ByRef2{Int32}, firstxbin::Int32, lastxbin::Int32, firstybin::Int32, lastybin::Int32, maxdiff::Float64)::Float64
compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff = abs(cell_content-c) <= maxdiff In case several cells in the specified range with diff=0 are found the first cell found is returned in binx,biny.
In case several cells in the specified range satisfy diff <=maxdiff the cell with the smallest difference is returned in binx,biny. In all cases the function returns the smallest difference.

NOTE1: if firstxbin < 0, firstxbin is set to 1 if (lastxbin < firstxbin then lastxbin is set to the number of bins in X ie if firstxbin=1 and lastxbin=0 (default) the search is on all bins in X except for X's under- and overflow bins. if firstybin < 0, firstybin is set to 1 if (lastybin < firstybin then lastybin is set to the number of bins in Y ie if firstybin=1 and lastybin=0 (default) the search is on all bins in Y except for Y's under- and overflow bins.

NOTE2: if maxdiff=0 (default), the first cell with content=c is returned.
""" GetBinWithContent2(this::ByConstRef1{TH2}, c::Float64, binx::ByRef2{Int32}, biny::ByRef2{Int32}, firstxbin::Int32, lastxbin::Int32, firstybin::Int32, lastybin::Int32, maxdiff::Float64)

# Wrapper of Double_t TH2::GetCorrelationFactor(Int_t, Int_t)
@trydoc raw"""
    GetCorrelationFactor(this::ByConstRef1{TH2}, axis1::Int32, axis2::Int32)::Float64
Return correlation factor between axis1 and axis2.

""" GetCorrelationFactor(this::ByConstRef1{TH2}, axis1::Int32, axis2::Int32)

# Wrapper of Double_t TH2::GetCovariance(Int_t, Int_t)
@trydoc raw"""
    GetCovariance(this::ByConstRef1{TH2}, axis1::Int32, axis2::Int32)::Float64
Return covariance between axis1 and axis2.

""" GetCovariance(this::ByConstRef1{TH2}, axis1::Int32, axis2::Int32)

# Wrapper of void TH2::GetRandom2(Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom2(this::ByRef1{TH2}, x::ByRef2{Float64}, y::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D histogram.
Return a NaN if the histogram has a bin with negative content

## Arguments

- **`x`** [out] 
    reference to random generated x value 
    
- **`y`** [out] 
    reference to random generated y value 
    
- **`rng`** [in] 
    (optional) Random number generator pointer used (default is gRandom)
""" GetRandom2(this::ByRef1{TH2}, x::ByRef2{Float64}, y::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of void TH2::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TH2}, stats::ByPtr2{Float64})::Nothing
Fill the array stats from the contents of this histogram The array stats must be correctly dimensioned in the calling program.
stats[0] = sumw
    stats[1] = sumw2
    stats[2] = sumwx
    stats[3] = sumwx2
    stats[4] = sumwy
    stats[5] = sumwy2
    stats[6] = sumwxy

(C++ version of the code)

If no axis-subranges are specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If sub-ranges are specified, the function recomputes these quantities from the bin contents in the current axis ranges.

Note that the mean value/StdDev is computed using the bins in the currently defined ranges (see [TAxis!SetRange](@ref)). By default the ranges include all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.
""" GetStats(this::ByConstRef1{TH2}, stats::ByPtr2{Float64})

# Wrapper of Double_t TH2::Integral(Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH2}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, option::ByCopy{String})::Float64
Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram By default the integral is computed as the sum of bin contents in the range.
if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x and in y.
""" Integral(this::ByConstRef1{TH2}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, option::ByCopy{String})

# Wrapper of Double_t TH2::Integral(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH2}, ::Int32, ::Int32, ::Int32, ::Int32, ::Int32, ::Int32, ::ByCopy{String})::Float64


""" Integral(this::ByConstRef1{TH2}, ::Int32, ::Int32, ::Int32, ::Int32, ::Int32, ::Int32, ::ByCopy{String})

# Wrapper of Double_t TH2::Integral(Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH2}, option::ByCopy{String})::Float64
Return integral of bin contents.
Only bins in the bins range are considered. By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x and in y.
""" Integral(this::ByConstRef1{TH2}, option::ByCopy{String})

# Wrapper of Double_t TH2::IntegralAndError(Int_t, Int_t, Int_t, Int_t, Double_t &, Option_t *)
@trydoc raw"""
    IntegralAndError(this::ByConstRef1{TH2}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, err::ByRef2{Float64}, option::ByCopy{String})::Float64
Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram.
Calculates also the integral error using error propagation from the bin errors assuming that all the bins are uncorrelated. By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x and in y.
""" IntegralAndError(this::ByConstRef1{TH2}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, err::ByRef2{Float64}, option::ByCopy{String})

# Wrapper of Double_t TH2::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByConstRef1{TH2}, x::Float64, y::Float64)::Float64
Given a point P(x,y), Interpolate approximates the value via bilinear interpolation based on the four nearest bin centers see Wikipedia, Bilinear Interpolation Andy Mastbaum 10/8/2008 vaguely based on R.Raja 6-Sep-2008.

""" Interpolate(this::ByConstRef1{TH2}, x::Float64, y::Float64)

# Wrapper of Double_t TH2::Interpolate(Double_t, Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByConstRef1{TH2}, x::Float64, y::Float64, z::Float64)::Float64
illegal for a [TH2](@ref)

""" Interpolate(this::ByConstRef1{TH2}, x::Float64, y::Float64, z::Float64)

# Wrapper of Double_t TH2::KolmogorovTest(const TH1 *, Option_t *)
@trydoc raw"""
    KolmogorovTest(this::ByConstRef1{TH2}, h2::ByConstPtr1{TH1}, option::ByCopy{String})::Float64
Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.
Default: Ignore under- and overflow bins in comparison

option is a character string to specify options

- "U" include Underflows in test
- "O" include Overflows
- "N" include comparison of normalizations
- "D" Put out a line of "Debug" printout
- "M" Return the Maximum Kolmogorov distance instead of prob

The returned function value is the probability of test (much less than one means NOT compatible)

The KS test uses the distance between the pseudo-CDF's obtained from the histogram. Since in 2D the order for generating the pseudo-CDF is arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the other from the y axis and the maximum distance is the average of the two maximum distances obtained.

Code adapted by Rene Brun from original HBOOK routine HDIFF
""" KolmogorovTest(this::ByConstRef1{TH2}, h2::ByConstPtr1{TH1}, option::ByCopy{String})

# Wrapper of TProfile * TH2::ProfileX(const char *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProfileX(this::ByConstRef1{TH2}, name::ByCopy{String}, firstybin::Int32, lastybin::Int32, option::ByCopy{String})::CxxPtr1{TProfile}
Project a 2-D histogram into a profile histogram along X.
The projection is made from the channels along the Y axis ranging from firstybin to lastybin included. By default, bins 1 to ny are included When all bins are included, the number of entries in the projection is set to the number of entries of the 2-D histogram, otherwise the number of entries is incremented by 1 for all non empty cells.

if option "d" is specified, the profile is drawn in the current pad.

if option "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See [TProfile!BuildOptions](@ref) for details

Using a [TCutG](@ref) object, it is possible to select a sub-range of a 2-D histogram. One must create a graphical cut (mouse or C++) and specify the name of the cut between [] in the option. For example, with a [TCutG](@ref) named "cutg", one can call: myhist->ProfileX(" ",firstybin,lastybin,"[cutg]"); To invert the cut, it is enough to put a "-" in front of its name: myhist->ProfileX(" ",firstybin,lastybin,"[-cutg]"); It is possible to apply several cuts ("," means logical AND): myhist->ProfileX(" ",firstybin,lastybin,"[cutg1,cutg2]");

NOTE that if a [TProfile](@ref) named "name" exists in the current directory or pad with a compatible axis the profile is reset and filled again with the projected contents of the [TH2](@ref). In the case of axis incompatibility an error is reported and a NULL pointer is returned.

NOTE that the X axis attributes of the [TH2](@ref) are copied to the X axis of the profile.

NOTE that the default under- / overflow behavior differs from what ProjectionX does! Profiles take the bin center into account, so here the under- and overflow bins are ignored by default.

NOTE that the return profile histogram is computed using the Y bin center values instead of the real Y values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770)
""" ProfileX(this::ByConstRef1{TH2}, name::ByCopy{String}, firstybin::Int32, lastybin::Int32, option::ByCopy{String})

# Wrapper of TProfile * TH2::ProfileY(const char *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProfileY(this::ByConstRef1{TH2}, name::ByCopy{String}, firstxbin::Int32, lastxbin::Int32, option::ByCopy{String})::CxxPtr1{TProfile}
Project a 2-D histogram into a profile histogram along Y.
The projection is made from the channels along the X axis ranging from firstxbin to lastxbin included. By default, bins 1 to nx are included When all bins are included, the number of entries in the projection is set to the number of entries of the 2-D histogram, otherwise the number of entries is incremented by 1 for all non empty cells.

if option "d" is specified, the profile is drawn in the current pad.

if option "o" , the original axis range of the target axis will be kept, but only bins inside the selected range will be filled.

The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See [TProfile!BuildOptions](@ref) for details Using a [TCutG](@ref) object, it is possible to select a sub-range of a 2-D histogram.

One must create a graphical cut (mouse or C++) and specify the name of the cut between [] in the option. For example, with a [TCutG](@ref) named "cutg", one can call: myhist->ProfileY(" ",firstybin,lastybin,"[cutg]"); To invert the cut, it is enough to put a "-" in front of its name: myhist->ProfileY(" ",firstybin,lastybin,"[-cutg]"); It is possible to apply several cuts: myhist->ProfileY(" ",firstybin,lastybin,"[cutg1,cutg2]");

NOTE that if a [TProfile](@ref) named "name" exists in the current directory or pad with a compatible axis the profile is reset and filled again with the projected contents of the [TH2](@ref). In the case of axis incompatibility an error is reported and a NULL pointer is returned.

NOTE that the Y axis attributes of the [TH2](@ref) are copied to the X axis of the profile.

NOTE that the default under- / overflow behavior differs from what ProjectionX does! Profiles take the bin center into account, so here the under- and overflow bins are ignored by default.

NOTE that the return profile histogram is computed using the X bin center values instead of the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770)
""" ProfileY(this::ByConstRef1{TH2}, name::ByCopy{String}, firstxbin::Int32, lastxbin::Int32, option::ByCopy{String})

# Wrapper of TH1D * TH2::ProjectionX(const char *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProjectionX(this::ByConstRef1{TH2}, name::ByCopy{String}, firstybin::Int32, lastybin::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Project a 2-D histogram into a 1-D histogram along X.
The projection is always of the type [TH1D](@ref). The projection is made from the channels along the Y axis ranging from firstybin to lastybin included. By default, all bins including under- and overflow are included. The number of entries in the projection is estimated from the number of effective entries for all the cells included in the projection.

To exclude the underflow bins in Y, use firstybin=1. To exclude the overflow bins in Y, use lastybin=nx.

if option "e" is specified, the errors are computed. if option "d" is specified, the projection is drawn in the current pad. if option "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

Using a [TCutG](@ref) object, it is possible to select a sub-range of a 2-D histogram. One must create a graphical cut (mouse or C++) and specify the name of the cut between [] in the option. For example, with a [TCutG](@ref) named "cutg", one can call: myhist->ProjectionX(" ",firstybin,lastybin,"[cutg]"); To invert the cut, it is enough to put a "-" in front of its name: myhist->ProjectionX(" ",firstybin,lastybin,"[-cutg]"); It is possible to apply several cuts: myhist->ProjectionX(" ",firstybin,lastybin,"[cutg1,cutg2]");

NOTE that if a [TH1D](@ref) named "name" exists in the current directory or pad the histogram is reset and filled again with the projected contents of the [TH2](@ref).

NOTE that the X axis attributes of the [TH2](@ref) are copied to the X axis of the projection.
""" ProjectionX(this::ByConstRef1{TH2}, name::ByCopy{String}, firstybin::Int32, lastybin::Int32, option::ByCopy{String})

# Wrapper of TH1D * TH2::ProjectionY(const char *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProjectionY(this::ByConstRef1{TH2}, name::ByCopy{String}, firstxbin::Int32, lastxbin::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Project a 2-D histogram into a 1-D histogram along Y.
The projection is always of the type [TH1D](@ref). The projection is made from the channels along the X axis ranging from firstxbin to lastxbin included. By default, all bins including under- and overflow are included. The number of entries in the projection is estimated from the number of effective entries for all the cells included in the projection

To exclude the underflow bins in X, use firstxbin=1. To exclude the overflow bins in X, use lastxbin=nx.

if option "e" is specified, the errors are computed. if option "d" is specified, the projection is drawn in the current pad. if option "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

Using a [TCutG](@ref) object, it is possible to select a sub-range of a 2-D histogram. One must create a graphical cut (mouse or C++) and specify the name of the cut between [] in the option. For example, with a [TCutG](@ref) named "cutg", one can call: myhist->ProjectionY(" ",firstxbin,lastxbin,"[cutg]"); To invert the cut, it is enough to put a "-" in front of its name: myhist->ProjectionY(" ",firstxbin,lastxbin,"[-cutg]"); It is possible to apply several cuts: myhist->ProjectionY(" ",firstxbin,lastxbin,"[cutg1,cutg2]");

NOTE that if a [TH1D](@ref) named "name" exists in the current directory or pad and having a compatible axis, the histogram is reset and filled again with the projected contents of the [TH2](@ref). In the case of axis incompatibility, an error is reported and a NULL pointer is returned.

NOTE that the Y axis attributes of the [TH2](@ref) are copied to the X axis of the projection.
""" ProjectionY(this::ByConstRef1{TH2}, name::ByCopy{String}, firstxbin::Int32, lastxbin::Int32, option::ByCopy{String})

# Wrapper of void TH2::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TH2}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TH2}, stats::ByPtr2{Float64})

# Wrapper of TH1D * TH2::QuantilesX(Double_t, const char *)
@trydoc raw"""
    QuantilesX(this::ByConstRef1{TH2}, prob::Float64, name::ByCopy{String})::CxxPtr1{TH1D}
Compute the X distribution of quantiles in the other variable Y name is the name of the returned histogram prob is the probability content for the quantile (0.5 is the default for the median) An approximate error for the quantile is computed assuming that the distribution in the other variable is normal.
According to this approximate formula the error on the quantile is estimated as sqrt( p (1-p) / ( n * [f(q)](@ref)^2) ), where p is the probability content of the quantile and n is the number of events used to compute the quantile and [f(q)](@ref) is the probability distribution for the other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be a normal distribution.
""" QuantilesX(this::ByConstRef1{TH2}, prob::Float64, name::ByCopy{String})

# Wrapper of TH1D * TH2::QuantilesY(Double_t, const char *)
@trydoc raw"""
    QuantilesY(this::ByConstRef1{TH2}, prob::Float64, name::ByCopy{String})::CxxPtr1{TH1D}
Compute the Y distribution of quantiles in the other variable X name is the name of the returned histogram prob is the probability content for the quantile (0.5 is the default for the median) An approximate error for the quantile is computed assuming that the distribution in the other variable is normal.

""" QuantilesY(this::ByConstRef1{TH2}, prob::Float64, name::ByCopy{String})

# Wrapper of TH2 * TH2::Rebin(Int_t, const char *, const Double_t *)
@trydoc raw"""
    Rebin(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})::CxxPtr1{TH2}
Override [TH1!Rebin](@ref) as [TH2!RebinX](@ref) Rebinning in variable binning as for [TH1](@ref) is not allowed If a non-null pointer is given an error is flagged see RebinX and Rebin2D.

""" Rebin(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})

# Wrapper of TH2 * TH2::Rebin2D(Int_t, Int_t, const char *)
@trydoc raw"""
    Rebin2D(this::ByRef1{TH2}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})::CxxPtr1{TH2}
Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.
if newname is not blank a new temporary histogram hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to me merged into one bin of hnew If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

examples: if hpxpy is an existing [TH2](@ref) histogram with 40 x 40 bins 

    hpxpy->Rebin2D();  // merges two bins along the xaxis and yaxis in one in hpxpy
                       // Carefull: previous contents of hpxpy are lost
    hpxpy->RebinX(5);  //merges five bins along the xaxis in one in hpxpy
    TH2 *hnew = hpxpy->RebinY(5,"hnew"); // creates a new histogram hnew
                                         // merging 5 bins of h1 along the yaxis in one bin

(C++ version of the code)

NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned histogram is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.
""" Rebin2D(this::ByRef1{TH2}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})

# Wrapper of TH2 * TH2::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH2}
Rebin only the X axis see Rebin2D.

""" RebinX(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TH2 * TH2::RebinY(Int_t, const char *)
@trydoc raw"""
    RebinY(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH2}
Rebin only the Y axis see Rebin2D.

""" RebinY(this::ByRef1{TH2}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TH2::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2}, option::ByCopy{String})

# Wrapper of void TH2::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2}, bin::Int32, content::Float64)::Nothing
Set bin content.

""" SetBinContent(this::ByRef1{TH2}, bin::Int32, content::Float64)

# Wrapper of void TH2::SetBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, content::Float64)

# Wrapper of void TH2::SetBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH2}, binx::Int32, biny::Int32, ::Int32, content::Float64)

# Wrapper of void TH2::SetShowProjectionX(Int_t)
@trydoc raw"""
    SetShowProjectionX(this::ByRef1{TH2}, nbins::Int32)::Nothing
When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the projection along X corresponding to the mouse position along Y.
To stop the generation of the projections, delete the canvas containing the projection. ## Arguments

- **`nbins`** 
    number of bins in Y to sum across for the projection
""" SetShowProjectionX(this::ByRef1{TH2}, nbins::Int32)

# Wrapper of void TH2::SetShowProjectionXY(Int_t, Int_t)
@trydoc raw"""
    SetShowProjectionXY(this::ByRef1{TH2}, nbinsY::Int32, nbinsX::Int32)::Nothing
When the mouse is moved in a pad containing a 2-d view of this histogram two canvases show the projection along X and Y corresponding to the mouse position along Y and X, respectively.
To stop the generation of the projections, delete the canvas containing the projection. ## Arguments

- **`nbinsY`** 
    number of bins in Y to sum across for the x projection 
    
- **`nbinsX`** 
    number of bins in X to sum across for the y projection
""" SetShowProjectionXY(this::ByRef1{TH2}, nbinsY::Int32, nbinsX::Int32)

# Wrapper of void TH2::SetShowProjectionY(Int_t)
@trydoc raw"""
    SetShowProjectionY(this::ByRef1{TH2}, nbins::Int32)::Nothing
When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the projection along Y corresponding to the mouse position along X.
To stop the generation of the projections, delete the canvas containing the projection. ## Arguments

- **`nbins`** 
    number of bins in X to sum across for the projection
""" SetShowProjectionY(this::ByRef1{TH2}, nbins::Int32)

# Wrapper of TH1 * TH2::ShowBackground(Int_t, Option_t *)
@trydoc raw"""
    ShowBackground(this::ByRef1{TH2}, niter::Int32, option::ByCopy{String})::CxxPtr1{TH1}
This function calculates the background spectrum in this histogram.
The background is returned as a histogram. to be implemented (may be)
""" ShowBackground(this::ByRef1{TH2}, niter::Int32, option::ByCopy{String})

# Wrapper of Int_t TH2::ShowPeaks(Double_t, Option_t *, Double_t)
@trydoc raw"""
    ShowPeaks(this::ByRef1{TH2}, sigma::Float64, option::ByCopy{String}, threshold::Float64)::Int32
Interface to [TSpectrum2!Search](@ref) the function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this.
for more details see [TSpectrum!Search](@ref). note the difference in the default value for option compared to [TSpectrum2!Search](@ref) option="" by default (instead of "goff")
""" ShowPeaks(this::ByRef1{TH2}, sigma::Float64, option::ByCopy{String}, threshold::Float64)

# Wrapper of void TH2::Smooth(Int_t, Option_t *)
@trydoc raw"""
    Smooth(this::ByRef1{TH2}, ntimes::Int32, option::ByCopy{String})::Nothing
Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community.
Bin contents in the active range are replaced by their smooth values. The algorithm retains the input dimension by using Kernel Crop at the input boundaries. Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the normalization accordingly. If Errors are defined via Sumw2, they are also scaled and computed. However, note the resulting errors will be correlated between different-bins, so the errors should not be used blindly to perform any calculation involving several bins, like fitting the histogram. One would need to compute also the bin by bin correlation matrix.

3 kernels are proposed k5a, k5b and k3a. k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j) k5b is a bit more stronger in smoothing k3a acts only on 3x3 cells (i-1,i,i+1, and same for j). By default the kernel "k5a" is used. You can select the kernels "k5b" or "k3a" via the option argument. If [TAxis!SetRange](@ref) has been called on the x or/and y axis, only the bins in the specified range are smoothed. In the current implementation if the first argument is not used (default value=1).

implementation by David McKee ([dmckee@bama.ua.edu](mailto:dmckee@bama.ua.edu)). Extended by Rene Brun
""" Smooth(this::ByRef1{TH2}, ntimes::Int32, option::ByCopy{String})

# Wrapper of void TFormula::AddParameter(const TString &, Double_t)
@trydoc raw"""
    AddParameter(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)::Nothing


""" AddParameter(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TFormula::AddVariable(const TString &, Double_t)
@trydoc raw"""
    AddVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)::Nothing
Adds variable to known variables, and reprocess formula.

""" AddVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TFormula::AddVariables(const TString *, const Int_t)
@trydoc raw"""
    AddVariables(this::ByRef1{TFormula}, vars::ByConstPtr1{TString}, size::ByCopy{Int32})::Nothing
Adds multiple variables.
First argument is an array of pairs<TString,Double>, where first argument is name of variable, second argument represents value. size - number of variables passed in first argument
""" AddVariables(this::ByRef1{TFormula}, vars::ByConstPtr1{TString}, size::ByCopy{Int32})

# Wrapper of void TFormula::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TFormula}, option::ByCopy{String})::Nothing
Clear the formula setting expression to empty and reset the variables and parameters containers.

""" Clear(this::ByRef1{TFormula}, option::ByCopy{String})

# Wrapper of Int_t TFormula::Compile(const char *)
@trydoc raw"""
    Compile(this::ByRef1{TFormula}, expression::ByCopy{String})::Int32
Compile the given expression with Cling backward compatibility method to be used in combination with the empty constructor if no expression is given , the current stored formula (retrieved with [GetExpFormula()](@ref)) or the title is used.
return 0 if the formula compilation is successful
""" Compile(this::ByRef1{TFormula}, expression::ByCopy{String})

# Wrapper of void TFormula::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TFormula}, named::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TFormula}, named::ByRef1{TObject})

# Wrapper of Double_t TFormula::EvalPar(const Double_t *, const Double_t *)
@trydoc raw"""
    EvalPar(this::ByConstRef1{TFormula}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Float64


""" EvalPar(this::ByConstRef1{TFormula}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of bool TFormula::GenerateGradientPar()
@trydoc raw"""
    GenerateGradientPar(this::ByRef1{TFormula})::Bool
Generate gradient computation routine with respect to the parameters.
returns true on success.

###Return

true if a gradient was generated and GradientPar can be called.
""" GenerateGradientPar(this::ByRef1{TFormula})

# Wrapper of bool TFormula::GenerateHessianPar()
@trydoc raw"""
    GenerateHessianPar(this::ByRef1{TFormula})::Bool
Generate hessian computation routine with respect to the parameters.
returns true on success.

###Return

true if a hessian was generated and HessianPar can be called.
""" GenerateHessianPar(this::ByRef1{TFormula})

# Wrapper of TString TFormula::GetGradientFormula()
@trydoc raw"""
    GetGradientFormula(this::ByConstRef1{TFormula})::ByCopy{TString}


""" GetGradientFormula(this::ByConstRef1{TFormula})

# Wrapper of TString TFormula::GetHessianFormula()
@trydoc raw"""
    GetHessianFormula(this::ByConstRef1{TFormula})::ByCopy{TString}


""" GetHessianFormula(this::ByConstRef1{TFormula})

# Wrapper of const TObject * TFormula::GetLinearPart(Int_t)
@trydoc raw"""
    GetLinearPart(this::ByConstRef1{TFormula}, i::Int32)::ConstCxxPtr1{TObject}
Return linear part.

""" GetLinearPart(this::ByConstRef1{TFormula}, i::Int32)

# Wrapper of Int_t TFormula::GetNdim()
@trydoc raw"""
    GetNdim(this::ByConstRef1{TFormula})::Int32


""" GetNdim(this::ByConstRef1{TFormula})

# Wrapper of Int_t TFormula::GetNpar()
@trydoc raw"""
    GetNpar(this::ByConstRef1{TFormula})::Int32


""" GetNpar(this::ByConstRef1{TFormula})

# Wrapper of Int_t TFormula::GetNumber()
@trydoc raw"""
    GetNumber(this::ByConstRef1{TFormula})::Int32


""" GetNumber(this::ByConstRef1{TFormula})

# Wrapper of Double_t TFormula::GetParameter(const char *)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TFormula}, name::ByCopy{String})::Float64
Returns parameter value given by string.

""" GetParameter(this::ByConstRef1{TFormula}, name::ByCopy{String})

# Wrapper of Double_t TFormula::GetParameter(Int_t)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TFormula}, param::Int32)::Float64
Return parameter value given by integer.

""" GetParameter(this::ByConstRef1{TFormula}, param::Int32)

# Wrapper of Double_t * TFormula::GetParameters()
@trydoc raw"""
    GetParameters(this::ByConstRef1{TFormula})::CxxPtr2{Float64}


""" GetParameters(this::ByConstRef1{TFormula})

# Wrapper of void TFormula::GetParameters(Double_t *)
@trydoc raw"""
    GetParameters(this::ByConstRef1{TFormula}, params::ByPtr2{Float64})::Nothing


""" GetParameters(this::ByConstRef1{TFormula}, params::ByPtr2{Float64})

# Wrapper of const char * TFormula::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TFormula}, ipar::Int32)::ByCopy{String}
Return parameter name given by integer.

""" GetParName(this::ByConstRef1{TFormula}, ipar::Int32)

# Wrapper of Int_t TFormula::GetParNumber(const char *)
@trydoc raw"""
    GetParNumber(this::ByConstRef1{TFormula}, name::ByCopy{String})::Int32
Return parameter index given a name (return -1 for not existing parameters) non need to print an error.

""" GetParNumber(this::ByConstRef1{TFormula}, name::ByCopy{String})

# Wrapper of TString TFormula::GetUniqueFuncName()
@trydoc raw"""
    GetUniqueFuncName(this::ByConstRef1{TFormula})::ByCopy{TString}


""" GetUniqueFuncName(this::ByConstRef1{TFormula})

# Wrapper of Double_t TFormula::GetVariable(const char *)
@trydoc raw"""
    GetVariable(this::ByConstRef1{TFormula}, name::ByCopy{String})::Float64
Returns variable value.

""" GetVariable(this::ByConstRef1{TFormula}, name::ByCopy{String})

# Wrapper of TString TFormula::GetVarName(Int_t)
@trydoc raw"""
    GetVarName(this::ByConstRef1{TFormula}, ivar::Int32)::ByCopy{TString}
Returns variable name given its position in the array.

""" GetVarName(this::ByConstRef1{TFormula}, ivar::Int32)

# Wrapper of Int_t TFormula::GetVarNumber(const char *)
@trydoc raw"""
    GetVarNumber(this::ByConstRef1{TFormula}, name::ByCopy{String})::Int32
Returns variable number (positon in array) given its name.

""" GetVarNumber(this::ByConstRef1{TFormula}, name::ByCopy{String})

# Wrapper of void TFormula::GradientPar(const Double_t *, Double_t *)
@trydoc raw"""
    GradientPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})::Nothing
Compute the gradient with respect to the parameter passing a buffer with a size at least equal to the number of parameters.
Note that the result buffer needs to be initialized to zero before passed to this function.
""" GradientPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})

# Wrapper of bool TFormula::HasGeneratedGradient()
@trydoc raw"""
    HasGeneratedGradient(this::ByConstRef1{TFormula})::Bool


""" HasGeneratedGradient(this::ByConstRef1{TFormula})

# Wrapper of bool TFormula::HasGeneratedHessian()
@trydoc raw"""
    HasGeneratedHessian(this::ByConstRef1{TFormula})::Bool


""" HasGeneratedHessian(this::ByConstRef1{TFormula})

# Wrapper of void TFormula::HessianPar(const Double_t *, Double_t *)
@trydoc raw"""
    HessianPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})::Nothing


""" HessianPar(this::ByRef1{TFormula}, x::ByConstPtr2{Float64}, result::ByPtr2{Float64})

# Wrapper of Bool_t TFormula::IsLinear()
@trydoc raw"""
    IsLinear(this::ByConstRef1{TFormula})::Bool


""" IsLinear(this::ByConstRef1{TFormula})

# Wrapper of Bool_t TFormula::IsValid()
@trydoc raw"""
    IsValid(this::ByConstRef1{TFormula})::Bool


""" IsValid(this::ByConstRef1{TFormula})

# Wrapper of Bool_t TFormula::IsVectorized()
@trydoc raw"""
    IsVectorized(this::ByConstRef1{TFormula})::Bool


""" IsVectorized(this::ByConstRef1{TFormula})

# Wrapper of TFormula & TFormula::operator=(const TFormula &)
@trydoc raw"""
    assign(this::ByRef1{TFormula}, rhs::ByConstRef1{TFormula})::CxxRef1{TFormula}
= operator.

""" assign(this::ByRef1{TFormula}, rhs::ByConstRef1{TFormula})

# Wrapper of void TFormula::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TFormula}, option::ByCopy{String})::Nothing
Print the formula and its attributes.

""" Print(this::ByConstRef1{TFormula}, option::ByCopy{String})

# Wrapper of void TFormula::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TFormula}, name::ByCopy{String})::Nothing
Set the name of the formula.
We need to allow the list of function to properly handle the hashes.
""" SetName(this::ByRef1{TFormula}, name::ByCopy{String})

# Wrapper of void TFormula::SetParameter(const char *, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TFormula}, name::ByCopy{String}, value::Float64)::Nothing
Sets parameter value.

""" SetParameter(this::ByRef1{TFormula}, name::ByCopy{String}, value::Float64)

# Wrapper of void TFormula::SetParameter(Int_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TFormula}, param::Int32, value::Float64)::Nothing
Set a parameter given a parameter index.
The parameter index is by default the alphabetic order given to the parameters, apart if the users has defined explicitly the parameter names.
""" SetParameter(this::ByRef1{TFormula}, param::Int32, value::Float64)

# Wrapper of void TFormula::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TFormula}, params::ByConstPtr2{Float64})::Nothing
Set a vector of parameters value.
Order in the vector is by default the alphabetic order given to the parameters apart if the users has defined explicitly the parameter names
""" SetParameters(this::ByRef1{TFormula}, params::ByConstPtr2{Float64})

# Wrapper of void TFormula::SetParName(Int_t, const char *)
@trydoc raw"""
    SetParName(this::ByRef1{TFormula}, ipar::Int32, name::ByCopy{String})::Nothing


""" SetParName(this::ByRef1{TFormula}, ipar::Int32, name::ByCopy{String})

# Wrapper of void TFormula::SetVariable(const TString &, Double_t)
@trydoc raw"""
    SetVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)::Nothing
Sets variable value.

""" SetVariable(this::ByRef1{TFormula}, name::ByConstRef1{TString}, value::Float64)

# Wrapper of void TFormula::SetVectorized(Bool_t)
@trydoc raw"""
    SetVectorized(this::ByRef1{TFormula}, vectorized::Bool)::Nothing


""" SetVectorized(this::ByRef1{TFormula}, vectorized::Bool)

# Wrapper of const char * TFormulaFunction::GetBody()
@trydoc raw"""
    GetBody(this::ByConstRef1{TFormulaFunction})::ByCopy{String}


""" GetBody(this::ByConstRef1{TFormulaFunction})

# Wrapper of const char * TFormulaFunction::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TFormulaFunction})::ByCopy{String}


""" GetName(this::ByConstRef1{TFormulaFunction})

# Wrapper of Int_t TFormulaFunction::GetNargs()
@trydoc raw"""
    GetNargs(this::ByConstRef1{TFormulaFunction})::Int32


""" GetNargs(this::ByConstRef1{TFormulaFunction})

# Wrapper of Bool_t TFormulaFunction::IsFuncCall()
@trydoc raw"""
    IsFuncCall(this::ByConstRef1{TFormulaFunction})::Bool


""" IsFuncCall(this::ByConstRef1{TFormulaFunction})

# Wrapper of Bool_t TFormulaFunction::operator<(const TFormulaFunction &)
@trydoc raw"""
    Base.:(<)(this::ByConstRef1{TFormulaFunction}, rhv::ByConstRef1{TFormulaFunction})::Bool


""" Base.:(<)(this::ByConstRef1{TFormulaFunction}, rhv::ByConstRef1{TFormulaFunction})

# Wrapper of Bool_t TFormulaFunction::operator==(const TFormulaFunction &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TFormulaFunction}, rhv::ByConstRef1{TFormulaFunction})::Bool


""" Base.:(==)(this::ByConstRef1{TFormulaFunction}, rhv::ByConstRef1{TFormulaFunction})

# Wrapper of Int_t TFormulaVariable::GetArrayPos()
@trydoc raw"""
    GetArrayPos(this::ByConstRef1{TFormulaVariable})::Int32


""" GetArrayPos(this::ByConstRef1{TFormulaVariable})

# Wrapper of Double_t TFormulaVariable::GetInitialValue()
@trydoc raw"""
    GetInitialValue(this::ByConstRef1{TFormulaVariable})::Float64


""" GetInitialValue(this::ByConstRef1{TFormulaVariable})

# Wrapper of const char * TFormulaVariable::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TFormulaVariable})::ByCopy{String}


""" GetName(this::ByConstRef1{TFormulaVariable})

# Wrapper of Bool_t TFormulaVariable::operator<(const TFormulaVariable &)
@trydoc raw"""
    Base.:(<)(this::ByConstRef1{TFormulaVariable}, rhv::ByConstRef1{TFormulaVariable})::Bool


""" Base.:(<)(this::ByConstRef1{TFormulaVariable}, rhv::ByConstRef1{TFormulaVariable})

# Wrapper of void TF1AbsComposition::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF1AbsComposition}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TF1AbsComposition}, object::ByRef1{TObject})

# Wrapper of double TF1AbsComposition::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByRef1{TF1AbsComposition}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64


""" paren(this::ByRef1{TF1AbsComposition}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of void TF1AbsComposition::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1AbsComposition}, params::ByConstPtr2{Float64})::Nothing


""" SetParameters(this::ByRef1{TF1AbsComposition}, params::ByConstPtr2{Float64})

# Wrapper of void TF1AbsComposition::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1AbsComposition}, a::Float64, b::Float64)::Nothing


""" SetRange(this::ByRef1{TF1AbsComposition}, a::Float64, b::Float64)

# Wrapper of void TF1AbsComposition::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1AbsComposition})::Nothing


""" Update(this::ByRef1{TF1AbsComposition})

# Wrapper of Double_t TF1Parameters::GetParameter(const char *)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TF1Parameters}, name::ByCopy{String})::Float64


""" GetParameter(this::ByConstRef1{TF1Parameters}, name::ByCopy{String})

# Wrapper of Double_t TF1Parameters::GetParameter(Int_t)
@trydoc raw"""
    GetParameter(this::ByConstRef1{TF1Parameters}, iparam::Int32)::Float64


""" GetParameter(this::ByConstRef1{TF1Parameters}, iparam::Int32)

# Wrapper of const Double_t * TF1Parameters::GetParameters()
@trydoc raw"""
    GetParameters(this::ByConstRef1{TF1Parameters})::ConstCxxPtr2{Float64}


""" GetParameters(this::ByConstRef1{TF1Parameters})

# Wrapper of const char * TF1Parameters::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TF1Parameters}, iparam::Int32)::ByCopy{String}


""" GetParName(this::ByConstRef1{TF1Parameters}, iparam::Int32)

# Wrapper of Int_t TF1Parameters::GetParNumber(const char *)
@trydoc raw"""
    GetParNumber(this::ByConstRef1{TF1Parameters}, name::ByCopy{String})::Int32
Returns the parameter number given a name not very efficient but list of parameters is typically small could use a map if needed.

""" GetParNumber(this::ByConstRef1{TF1Parameters}, name::ByCopy{String})

# Wrapper of TF1Parameters & TF1Parameters::operator=(const TF1Parameters &)
@trydoc raw"""
    assign(this::ByRef1{TF1Parameters}, rhs::ByConstRef1{TF1Parameters})::CxxRef1{TF1Parameters}


""" assign(this::ByRef1{TF1Parameters}, rhs::ByConstRef1{TF1Parameters})

# Wrapper of void TF1Parameters::SetParameter(const char *, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1Parameters}, name::ByCopy{String}, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1Parameters}, name::ByCopy{String}, value::Float64)

# Wrapper of void TF1Parameters::SetParameter(Int_t, Double_t)
@trydoc raw"""
    SetParameter(this::ByRef1{TF1Parameters}, iparam::Int32, value::Float64)::Nothing


""" SetParameter(this::ByRef1{TF1Parameters}, iparam::Int32, value::Float64)

# Wrapper of void TF1Parameters::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1Parameters}, params::ByConstPtr2{Float64})::Nothing


""" SetParameters(this::ByRef1{TF1Parameters}, params::ByConstPtr2{Float64})

# Wrapper of void TF1Parameters::SetParName(Int_t, const char *)
@trydoc raw"""
    SetParName(this::ByRef1{TF1Parameters}, iparam::Int32, name::ByCopy{String})::Nothing


""" SetParName(this::ByRef1{TF1Parameters}, iparam::Int32, name::ByCopy{String})

# Wrapper of Double_t TF2::CentralMoment2(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CentralMoment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny central moment of a 2d function in range [ax,bx],[ay,by].
###Author

Gene Van Buren gene@bnl.gov
""" CentralMoment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of void TF2::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF2}, f2::ByRef1{TObject})::Nothing
Copy this F2 to a new F2.

""" Copy(this::ByConstRef1{TF2}, f2::ByRef1{TObject})

# Wrapper of Double_t TF2::Covariance2XY(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance2XY(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Covariance2XY(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of TH1 * TF2::CreateHistogram()
@trydoc raw"""
    CreateHistogram(this::ByRef1{TF2})::CxxPtr1{TH1}
Create a histogram from function.
always created it, even if it is already existing
""" CreateHistogram(this::ByRef1{TF2})

# Wrapper of Int_t TF2::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TF2}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a function.
## Arguments

- **`px`** [in] 
    x position 
    
- **`py`** [in] 
    y position
    

Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TF2}, px::Int32, py::Int32)

# Wrapper of void TF2::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TF2}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.
NB. You must use DrawCopy if you want to draw several times the same function in the current canvas.
""" Draw(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of TF1 * TF2::DrawCopy(Option_t *)
@trydoc raw"""
    DrawCopy(this::ByConstRef1{TF2}, option::ByCopy{String})::CxxPtr1{TF1}
Draw a copy of this function with its current attributes-*.
This function MUST be used instead of Draw when you want to draw the same function with different parameters settings in the same canvas.

Possible option values are:

| **option** | **description**                                  |
|:-----------|:-------------------------------------------------|
| "SAME"     | superimpose on top of existing picture           |
| "L"        | connect all computed points with a straight line |
| "C"        | connect all computed points with a smooth curve. |

Note that the default value is "F". Therefore to draw on top of an existing picture, specify option "SL"
""" DrawCopy(this::ByConstRef1{TF2}, option::ByCopy{String})

# Wrapper of TObject * TF2::DrawDerivative(Option_t *)
@trydoc raw"""
    DrawDerivative(this::ByRef1{TF2}, option::ByCopy{String})::CxxPtr1{TObject}
Draw derivative of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawDerivative(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawDerivative(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of TObject * TF2::DrawIntegral(Option_t *)
@trydoc raw"""
    DrawIntegral(this::ByRef1{TF2}, option::ByCopy{String})::CxxPtr1{TObject}
Draw integral of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawIntegral(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawIntegral(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of void TF2::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TF2}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a F2 is clicked with the locator
""" ExecuteEvent(this::ByRef1{TF2}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TF2::GetContour(Double_t *)
@trydoc raw"""
    GetContour(this::ByRef1{TF2}, levels::ByPtr2{Float64})::Int32
Return contour values into array levels.
The number of contour levels can be returned by getContourLevel
""" GetContour(this::ByRef1{TF2}, levels::ByPtr2{Float64})

# Wrapper of Double_t TF2::GetContourLevel(Int_t)
@trydoc raw"""
    GetContourLevel(this::ByConstRef1{TF2}, level::Int32)::Float64
Return the number of contour levels.

""" GetContourLevel(this::ByConstRef1{TF2}, level::Int32)

# Wrapper of Double_t TF2::GetMaximum(Double_t *)
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TF2}, x::ByPtr2{Float64})::Float64
Return maximum value of the function See [TF2!GetMinimum](@ref).
""" GetMaximum(this::ByConstRef1{TF2}, x::ByPtr2{Float64})

# Wrapper of Double_t TF2::GetMaximumXY(Double_t &, Double_t &)
@trydoc raw"""
    GetMaximumXY(this::ByConstRef1{TF2}, x::ByRef2{Float64}, y::ByRef2{Float64})::Float64
Compute the X and Y values corresponding to the maximum value of the function.
Return the maximum value of the function See [TF2!GetMinimumXY](@ref)
""" GetMaximumXY(this::ByConstRef1{TF2}, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of Double_t TF2::GetMinimum(Double_t *)
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TF2}, x::ByPtr2{Float64})::Float64
Return minimum/maximum value of the function.
To find the minimum on a range, first set this range via the SetRange function If a vector x of coordinate is passed it will be used as starting point for the minimum. In addition on exit x will contain the coordinate values at the minimuma If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is "good" (or "bad"), these values can be changed by SetNpx and SetNpy functions Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT!Math!Minimizer!SetDefaultMinimizerType("..") Other option for the minimizer can be set using the static method of the MinimizerOptions class
""" GetMinimum(this::ByConstRef1{TF2}, x::ByPtr2{Float64})

# Wrapper of Double_t TF2::GetMinimumXY(Double_t &, Double_t &)
@trydoc raw"""
    GetMinimumXY(this::ByConstRef1{TF2}, x::ByRef2{Float64}, y::ByRef2{Float64})::Float64
Compute the X and Y values corresponding to the minimum value of the function.
Return the minimum value of the function To find the minimum on a range, first set this range via the SetRange function

Method: First, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is "good" (or "bad"), these values can be changed by SetNpx and SetNpy functions Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT!Math!Minimizer!SetDefaultMinimizerType("..") Other option for the minimizer can be set using the static method of the MinimizerOptions class

Note that this method will always do first a grid search in contrast to GetMinimum
""" GetMinimumXY(this::ByConstRef1{TF2}, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of Int_t TF2::GetNpy()
@trydoc raw"""
    GetNpy(this::ByConstRef1{TF2})::Int32


""" GetNpy(this::ByConstRef1{TF2})

# Wrapper of char * TF2::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TF2}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Redefines [TObject!GetObjectInfo](@ref).
Displays the function value corresponding to cursor position px,py
""" GetObjectInfo(this::ByConstRef1{TF2}, px::Int32, py::Int32)

# Wrapper of Double_t TF2::GetRandom(Double_t, Double_t, TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape.

""" GetRandom(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of Double_t TF2::GetRandom(TRandom *, Option_t *)
@trydoc raw"""
    GetRandom(this::ByRef1{TF2}, rng::ByPtr1{TRandom}, opt::ByCopy{String})::Float64
Return a random number following this function shape.

""" GetRandom(this::ByRef1{TF2}, rng::ByPtr1{TRandom}, opt::ByCopy{String})

# Wrapper of void TF2::GetRandom2(Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom2(this::ByRef1{TF2}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 2 random numbers following this function shape.
The distribution contained in this [TF2](@ref) function is integrated over the cell contents. It is normalized to 1. Getting the two random numbers implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which cell in the normalized integral r1 corresponds to
- make a linear interpolation in the returned cell

IMPORTANT NOTE

The integral of the function is computed at fNpx * fNpy points. If the function has sharp peaks, you should increase the number of points (SetNpx, SetNpy) such that the peak is correctly tabulated at several points.
""" GetRandom2(this::ByRef1{TF2}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of void TF2::GetRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF2}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Return range of a 2-D function.

""" GetRange(this::ByConstRef1{TF2}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of void TF2::GetRange(Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF2}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, zmin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64}, zmax::ByRef2{Float64})::Nothing
Return range of function.

""" GetRange(this::ByConstRef1{TF2}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, zmin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64}, zmax::ByRef2{Float64})

# Wrapper of Double_t TF2::GetSave(const Double_t *)
@trydoc raw"""
    GetSave(this::ByRef1{TF2}, x::ByConstPtr2{Float64})::Float64
Get value corresponding to X in array of fSave values.

""" GetSave(this::ByRef1{TF2}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF2::GetYmax()
@trydoc raw"""
    GetYmax(this::ByConstRef1{TF2})::Float64


""" GetYmax(this::ByConstRef1{TF2})

# Wrapper of Double_t TF2::GetYmin()
@trydoc raw"""
    GetYmin(this::ByConstRef1{TF2})::Float64


""" GetYmin(this::ByConstRef1{TF2})

# Wrapper of Double_t TF2::Integral(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Integral(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsrel::Float64)::Float64
Return Integral of a 2d function in range [ax,bx],[ay,by] with desired relative accuracy (defined by eps)

""" Integral(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsrel::Float64)

# Wrapper of Bool_t TF2::IsInside(const Double_t *)
@trydoc raw"""
    IsInside(this::ByConstRef1{TF2}, x::ByConstPtr2{Float64})::Bool
Return kTRUE is the point is inside the function range.

""" IsInside(this::ByConstRef1{TF2}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF2::Mean2X(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Mean2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Mean2Y(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Mean2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Moment2(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Moment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny moment of a 2d function in range [ax,bx],[ay,by].
###Author

Gene Van Buren gene@bnl.gov
""" Moment2(this::ByRef1{TF2}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of TF2 & TF2::operator=(const TF2 &)
@trydoc raw"""
    assign(this::ByRef1{TF2}, rhs::ByConstRef1{TF2})::CxxRef1{TF2}
Operator =.

""" assign(this::ByRef1{TF2}, rhs::ByConstRef1{TF2})

# Wrapper of void TF2::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TF2}, option::ByCopy{String})::Nothing
Paint this 2-D function with its current attributes.

""" Paint(this::ByRef1{TF2}, option::ByCopy{String})

# Wrapper of void TF2::Save(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Save(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Nothing
Save values of function in array fSave.

""" Save(this::ByRef1{TF2}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TF2::SetContour(Int_t, const Double_t *)
@trydoc raw"""
    SetContour(this::ByRef1{TF2}, nlevels::Int32, levels::ByConstPtr2{Float64})::Nothing
Set the number and values of contour levels.
By default the number of contour levels is set to 20.

if argument levels = 0 or missing, equidistant contours are computed
""" SetContour(this::ByRef1{TF2}, nlevels::Int32, levels::ByConstPtr2{Float64})

# Wrapper of void TF2::SetContourLevel(Int_t, Double_t)
@trydoc raw"""
    SetContourLevel(this::ByRef1{TF2}, level::Int32, value::Float64)::Nothing
Set value for one contour level.

""" SetContourLevel(this::ByRef1{TF2}, level::Int32, value::Float64)

# Wrapper of void TF2::SetNpy(Int_t)
@trydoc raw"""
    SetNpy(this::ByRef1{TF2}, npy::Int32)::Nothing
Set the number of points used to draw the function.
The default number of points along x is 30 for 2-d/3-d functions. You can increase this value to get a better resolution when drawing pictures with sharp peaks or to get a better result when using [TF2!GetRandom2](@ref) the minimum number of points is 4, the maximum is 10000 for 2-d/3-d functions
""" SetNpy(this::ByRef1{TF2}, npy::Int32)

# Wrapper of void TF2::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF2}, xmin::Float64, xmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.
The function range is also used in an histogram fit operation when the option "R" is specified.
""" SetRange(this::ByRef1{TF2}, xmin::Float64, xmax::Float64)

# Wrapper of void TF2::SetRange(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function-.

""" SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TF2::SetRange(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)::Nothing


""" SetRange(this::ByRef1{TF2}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)

# Wrapper of Double_t TF2::Variance2X(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Variance2X(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of Double_t TF2::Variance2Y(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)::Float64


""" Variance2Y(this::ByRef1{TF2}, ax::Float64, bx::Float64, ay::Float64, by::Float64, epsilon::Float64)

# Wrapper of void TF12::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF12}, f12::ByRef1{TObject})::Nothing
Copy this F2 to a new F2.

""" Copy(this::ByConstRef1{TF12}, f12::ByRef1{TObject})

# Wrapper of TF1 * TF12::DrawCopy(Option_t *)
@trydoc raw"""
    DrawCopy(this::ByConstRef1{TF12}, option::ByCopy{String})::CxxPtr1{TF1}
Draw a copy of this function with its current attributes.
This function MUST be used instead of Draw when you want to draw the same function with different parameters settings in the same canvas.

Possible option values are:

| **option** | **description**                                  |
|:-----------|:-------------------------------------------------|
| "SAME"     | superimpose on top of existing picture           |
| "L"        | connect all computed points with a straight line |
| "C"        | connect all computed points with a smooth curve  |

Note that the default value is "F". Therefore to draw on top of an existing picture, specify option "SL"
""" DrawCopy(this::ByConstRef1{TF12}, option::ByCopy{String})

# Wrapper of Double_t TF12::Eval(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TF12}, x::Float64, y::Float64, z::Float64, t::Float64)::Float64
Evaluate this formula.
Computes the value of the referenced [TF2](@ref) for a fix value of X or Y
""" Eval(this::ByConstRef1{TF12}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of Double_t TF12::EvalPar(const Double_t *, const Double_t *)
@trydoc raw"""
    EvalPar(this::ByRef1{TF12}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})::Float64
Evaluate this function at point x[0].
x[0] is the value along X if fCase =0, the value along Y if fCase=1 if params is non null, the array will be used instead of the internal [TF2](@ref) parameters
""" EvalPar(this::ByRef1{TF12}, x::ByConstPtr2{Float64}, params::ByConstPtr2{Float64})

# Wrapper of Double_t TF12::GetXY()
@trydoc raw"""
    GetXY(this::ByConstRef1{TF12})::Float64


""" GetXY(this::ByConstRef1{TF12})

# Wrapper of void TF12::SetXY(Double_t)
@trydoc raw"""
    SetXY(this::ByRef1{TF12}, xy::Float64)::Nothing
Set the value of the constant for the [TF2](@ref).
constant in X when projecting along Y constant in Y when projecting along X The function title is set to include the value of the constant The current pad is updated
""" SetXY(this::ByRef1{TF12}, xy::Float64)

# Wrapper of Int_t TSpline::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TSpline}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a spline.

""" DistancetoPrimitive(this::ByRef1{TSpline}, px::Int32, py::Int32)

# Wrapper of void TSpline::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TSpline}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.
Possible option values are:

- "SAME" superimpose on top of existing picture
- "L" connect all computed points with a straight line
- "C" connect all computed points with a smooth curve.
- "P" add a polymarker at each knot

Note that the default value is "L". Therefore to draw on top of an existing picture, specify option "LSAME"
""" Draw(this::ByRef1{TSpline}, option::ByCopy{String})

# Wrapper of Double_t TSpline::Eval(Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TSpline}, x::Float64)::Float64


""" Eval(this::ByConstRef1{TSpline}, x::Float64)

# Wrapper of void TSpline::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TSpline}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.

""" ExecuteEvent(this::ByRef1{TSpline}, event::Int32, px::Int32, py::Int32)

# Wrapper of Double_t TSpline::GetDelta()
@trydoc raw"""
    GetDelta(this::ByConstRef1{TSpline})::Float64


""" GetDelta(this::ByConstRef1{TSpline})

# Wrapper of TH1F * TSpline::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByConstRef1{TSpline})::CxxPtr1{TH1F}


""" GetHistogram(this::ByConstRef1{TSpline})

# Wrapper of void TSpline::GetKnot(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetKnot(this::ByConstRef1{TSpline}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})::Nothing


""" GetKnot(this::ByConstRef1{TSpline}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of Int_t TSpline::GetNp()
@trydoc raw"""
    GetNp(this::ByConstRef1{TSpline})::Int32


""" GetNp(this::ByConstRef1{TSpline})

# Wrapper of Int_t TSpline::GetNpx()
@trydoc raw"""
    GetNpx(this::ByConstRef1{TSpline})::Int32


""" GetNpx(this::ByConstRef1{TSpline})

# Wrapper of Double_t TSpline::GetXmax()
@trydoc raw"""
    GetXmax(this::ByConstRef1{TSpline})::Float64


""" GetXmax(this::ByConstRef1{TSpline})

# Wrapper of Double_t TSpline::GetXmin()
@trydoc raw"""
    GetXmin(this::ByConstRef1{TSpline})::Float64


""" GetXmin(this::ByConstRef1{TSpline})

# Wrapper of void TSpline::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TSpline}, option::ByCopy{String})::Nothing
Paint this function with its current attributes.

""" Paint(this::ByRef1{TSpline}, option::ByCopy{String})

# Wrapper of void TSpline::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TSpline}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save this object in the file specified by filename.
- if "filename" contains ".root" the object is saved in filename as root binary file.
- if "filename" contains ".xml" the object is saved in filename as a xml ascii file.
- if "filename" contains ".cc" the object is saved in filename as C code independant from [ROOT](@ref). The code is generated via [SavePrimitive()](@ref). Specific code should be implemented in each object to handle this option. Like in [TF1!SavePrimitive()](@ref).
- otherwise the object is written to filename as a CINT/C++ script. The C++ code to rebuild this object is generated via [SavePrimitive()](@ref). The "option" parameter is passed to SavePrimitive. By default it is an empty string. It can be used to specify the Draw option in the code generated by SavePrimitive.

    The function is available via the object context menu.
""" SaveAs(this::ByConstRef1{TSpline}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TSpline::SetNpx(Int_t)
@trydoc raw"""
    SetNpx(this::ByRef1{TSpline}, n::Int32)::Nothing


""" SetNpx(this::ByRef1{TSpline}, n::Int32)

# Wrapper of void TH1F::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1F}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1F}, bin::Int32)

# Wrapper of void TH1F::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1F}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
###Warning

The value of w is cast to Float_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1F}, bin::Int32, w::Float64)

# Wrapper of void TH1F::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1F}, hnew::ByRef1{TObject})::Nothing
Copy this to newth1.

""" Copy(this::ByConstRef1{TH1F}, hnew::ByRef1{TObject})

# Wrapper of TH1F & TH1F::operator=(const TH1F &)
@trydoc raw"""
    assign(this::ByRef1{TH1F}, h1::ByConstRef1{TH1F})::CxxRef1{TH1F}
Operator =.

""" assign(this::ByRef1{TH1F}, h1::ByConstRef1{TH1F})

# Wrapper of void TH1F::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1F}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1F}, option::ByCopy{String})

# Wrapper of void TH1F::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1F}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1F}, n::Int32)

# Wrapper of void TF1Convolution::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF1Convolution}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TF1Convolution}, object::ByRef1{TObject})

# Wrapper of Int_t TF1Convolution::GetNpar()
@trydoc raw"""
    GetNpar(this::ByConstRef1{TF1Convolution})::Int32


""" GetNpar(this::ByConstRef1{TF1Convolution})

# Wrapper of const char * TF1Convolution::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TF1Convolution}, ipar::Int32)::ByCopy{String}


""" GetParName(this::ByConstRef1{TF1Convolution}, ipar::Int32)

# Wrapper of void TF1Convolution::GetRange(Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF1Convolution}, a::ByRef2{Float64}, b::ByRef2{Float64})::Nothing
Get the range used for the convolution.

""" GetRange(this::ByConstRef1{TF1Convolution}, a::ByRef2{Float64}, b::ByRef2{Float64})

# Wrapper of Double_t TF1Convolution::GetXmax()
@trydoc raw"""
    GetXmax(this::ByConstRef1{TF1Convolution})::Float64


""" GetXmax(this::ByConstRef1{TF1Convolution})

# Wrapper of Double_t TF1Convolution::GetXmin()
@trydoc raw"""
    GetXmin(this::ByConstRef1{TF1Convolution})::Float64


""" GetXmin(this::ByConstRef1{TF1Convolution})

# Wrapper of Double_t TF1Convolution::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByRef1{TF1Convolution}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64
Used in [TF1](@ref) when doing the fit, will be evaluated at each point.

""" paren(this::ByRef1{TF1Convolution}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of TF1Convolution & TF1Convolution::operator=(const TF1Convolution &)
@trydoc raw"""
    assign(this::ByRef1{TF1Convolution}, rhs::ByConstRef1{TF1Convolution})::CxxRef1{TF1Convolution}
Operator =.

""" assign(this::ByRef1{TF1Convolution}, rhs::ByConstRef1{TF1Convolution})

# Wrapper of void TF1Convolution::SetExtraRange(Double_t)
@trydoc raw"""
    SetExtraRange(this::ByRef1{TF1Convolution}, percentage::Float64)::Nothing
Set the fraction of extra range used when doing an convolution.
The extra range is often needed to avoid mirroring effect of the resulting convolution function at the borders. By default an extra range of 0.1 is used when doing FFT and it is not use for numerical convolution
""" SetExtraRange(this::ByRef1{TF1Convolution}, percentage::Float64)

# Wrapper of void TF1Convolution::SetNofPointsFFT(Int_t)
@trydoc raw"""
    SetNofPointsFFT(this::ByRef1{TF1Convolution}, n::Int32)::Nothing
Set the number of points used for the FFT convolution.

""" SetNofPointsFFT(this::ByRef1{TF1Convolution}, n::Int32)

# Wrapper of void TF1Convolution::SetNumConv(Bool_t)
@trydoc raw"""
    SetNumConv(this::ByRef1{TF1Convolution}, flag::Bool)::Nothing


""" SetNumConv(this::ByRef1{TF1Convolution}, flag::Bool)

# Wrapper of void TF1Convolution::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1Convolution}, params::ByConstPtr2{Float64})::Nothing
Set the vector of parameters p for the convolution function [g(x,p)](@ref) = f1 * f2.

""" SetParameters(this::ByRef1{TF1Convolution}, params::ByConstPtr2{Float64})

# Wrapper of void TF1Convolution::SetParameters(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1Convolution}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64)::Nothing
Set the parameter values for the convolution function.

""" SetParameters(this::ByRef1{TF1Convolution}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64)

# Wrapper of void TF1Convolution::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1Convolution}, a::Float64, b::Float64)::Nothing
Set the actual range used for the convolution.
In case a or b are -inf or +inf and FFT convolution is used, then the range of the first function will be used and extended by the default extra range fraction.
""" SetRange(this::ByRef1{TF1Convolution}, a::Float64, b::Float64)

# Wrapper of void TF1Convolution::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1Convolution})::Nothing
Update the two component functions of the convolution.

""" Update(this::ByRef1{TF1Convolution})

# Wrapper of Double_t TF1Convolution::SetDefaultExtraRange(Double_t)
@trydoc raw"""
    TF1Convolution!SetDefaultExtraRange(this::ByRef1{TF1Convolution}, percentage::Float64)::Float64
Set the default extra range fraction used when doing a FFT convolution.
By default the value is 0.1 (10%). The function return the previous default defined value.
""" TF1Convolution!SetDefaultExtraRange(this::ByRef1{TF1Convolution}, percentage::Float64)

# Wrapper of void TF1NormSum::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF1NormSum}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TF1NormSum}, object::ByRef1{TObject})

# Wrapper of Int_t TF1NormSum::GetNpar()
@trydoc raw"""
    GetNpar(this::ByConstRef1{TF1NormSum})::Int32
Return the number of (non constant) parameters including the coefficients: for 2 functions: c1,c2,p0,p1,p2,p3...

""" GetNpar(this::ByConstRef1{TF1NormSum})

# Wrapper of const char * TF1NormSum::GetParName(Int_t)
@trydoc raw"""
    GetParName(this::ByConstRef1{TF1NormSum}, ipar::Int32)::ByCopy{String}


""" GetParName(this::ByConstRef1{TF1NormSum}, ipar::Int32)

# Wrapper of void TF1NormSum::GetRange(Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF1NormSum}, a::ByRef2{Float64}, b::ByRef2{Float64})::Nothing


""" GetRange(this::ByConstRef1{TF1NormSum}, a::ByRef2{Float64}, b::ByRef2{Float64})

# Wrapper of Double_t TF1NormSum::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TF1NormSum})::Float64


""" GetScale(this::ByConstRef1{TF1NormSum})

# Wrapper of Double_t TF1NormSum::GetXmax()
@trydoc raw"""
    GetXmax(this::ByConstRef1{TF1NormSum})::Float64


""" GetXmax(this::ByConstRef1{TF1NormSum})

# Wrapper of Double_t TF1NormSum::GetXmin()
@trydoc raw"""
    GetXmin(this::ByConstRef1{TF1NormSum})::Float64


""" GetXmin(this::ByConstRef1{TF1NormSum})

# Wrapper of double TF1NormSum::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByRef1{TF1NormSum}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64
Overload the parenthesis to add the functions.

""" paren(this::ByRef1{TF1NormSum}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of TF1NormSum & TF1NormSum::operator=(const TF1NormSum &)
@trydoc raw"""
    assign(this::ByRef1{TF1NormSum}, rhs::ByConstRef1{TF1NormSum})::CxxRef1{TF1NormSum}
Operator =.

""" assign(this::ByRef1{TF1NormSum}, rhs::ByConstRef1{TF1NormSum})

# Wrapper of void TF1NormSum::SetParameters(const Double_t *)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1NormSum}, params::ByConstPtr2{Float64})::Nothing
Initialize array of all parameters.
double *params must contains first an array of the coefficients, then an array of the parameters.
""" SetParameters(this::ByRef1{TF1NormSum}, params::ByConstPtr2{Float64})

# Wrapper of void TF1NormSum::SetParameters(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParameters(this::ByRef1{TF1NormSum}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)::Nothing
Initialize array of all parameters.
Overload the [TF1!SetParameters()](@ref) method. A maximum of 10 parameters must be used, with first the coefficients, then the parameters
""" SetParameters(this::ByRef1{TF1NormSum}, p0::Float64, p1::Float64, p2::Float64, p3::Float64, p4::Float64, p5::Float64, p6::Float64, p7::Float64, p8::Float64, p9::Float64, p10::Float64)

# Wrapper of void TF1NormSum::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF1NormSum}, a::Float64, b::Float64)::Nothing


""" SetRange(this::ByRef1{TF1NormSum}, a::Float64, b::Float64)

# Wrapper of void TF1NormSum::SetScale(Double_t)
@trydoc raw"""
    SetScale(this::ByRef1{TF1NormSum}, scale::Float64)::Nothing


""" SetScale(this::ByRef1{TF1NormSum}, scale::Float64)

# Wrapper of void TF1NormSum::Update()
@trydoc raw"""
    Update(this::ByRef1{TF1NormSum})::Nothing
Update the component functions of the normalized sum.

""" Update(this::ByRef1{TF1NormSum})

# Wrapper of Double_t TF3::CentralMoment3(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CentralMoment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny * z^nz central moment of a 3d function in range [ax,bx],[ay,by],[az,bz].
###Author

Gene Van Buren gene@bnl.gov
""" CentralMoment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of void TF3::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TF3}, f3::ByRef1{TObject})::Nothing
Copy this F3 to a new F3.

""" Copy(this::ByConstRef1{TF3}, f3::ByRef1{TObject})

# Wrapper of Double_t TF3::Covariance3XY(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance3XY(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Covariance3XY(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Covariance3XZ(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance3XZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Covariance3XZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Covariance3YZ(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Covariance3YZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Covariance3YZ(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of TH1 * TF3::CreateHistogram()
@trydoc raw"""
    CreateHistogram(this::ByRef1{TF3})::CxxPtr1{TH1}
Create a histogram for axis range.

""" CreateHistogram(this::ByRef1{TF3})

# Wrapper of Int_t TF3::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TF3}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a function.
Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TF3}, px::Int32, py::Int32)

# Wrapper of void TF3::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TF3}, option::ByCopy{String})::Nothing
Draw this function with its current attributes.

""" Draw(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of TObject * TF3::DrawDerivative(Option_t *)
@trydoc raw"""
    DrawDerivative(this::ByRef1{TF3}, option::ByCopy{String})::CxxPtr1{TObject}
Draw derivative of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawDerivative(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawDerivative(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of TObject * TF3::DrawIntegral(Option_t *)
@trydoc raw"""
    DrawIntegral(this::ByRef1{TF3}, option::ByCopy{String})::CxxPtr1{TObject}
Draw integral of this function.
An intermediate [TGraph](@ref) object is built and drawn with option. The function returns a pointer to the [TGraph](@ref) object. Do: 
```
TGraph *g = (TGraph*)myfunc.DrawIntegral(option);
```  The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function.
""" DrawIntegral(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of void TF3::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TF3}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a F3 is clicked with the locator
""" ExecuteEvent(this::ByRef1{TF3}, event::Int32, px::Int32, py::Int32)

# Wrapper of const Double_t * TF3::GetClippingBox()
@trydoc raw"""
    GetClippingBox(this::ByConstRef1{TF3})::ConstCxxPtr2{Float64}


""" GetClippingBox(this::ByConstRef1{TF3})

# Wrapper of Bool_t TF3::GetClippingBoxOn()
@trydoc raw"""
    GetClippingBoxOn(this::ByConstRef1{TF3})::Bool


""" GetClippingBoxOn(this::ByConstRef1{TF3})

# Wrapper of Double_t TF3::GetMaximumXYZ(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetMaximumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})::Float64
Compute the X, Y and Z values corresponding to the maximum value of the function on its range.
Return the function value at the maximum. See [TF3!GetMinimumXYZ](@ref)
""" GetMaximumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})

# Wrapper of Double_t TF3::GetMinimumXYZ(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetMinimumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})::Float64
Compute the X, Y and Z values corresponding to the minimum value of the function on its range.
Returns the function value at the minimum. To find the minimum on a subrange, use the [SetRange()](@ref) function first.

Method: First, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx,fNpy and fNpz sub-ranges. If the function is "good" (or "bad"), these values can be changed by [SetNpx()](@ref), [SetNpy()](@ref) and [SetNpz()](@ref) functions. Then, Minuit minimization is used with starting values found by the grid search

Note that this method will always do first a grid search in contrast to GetMinimum
""" GetMinimumXYZ(this::ByRef1{TF3}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64})

# Wrapper of Int_t TF3::GetNpz()
@trydoc raw"""
    GetNpz(this::ByConstRef1{TF3})::Int32


""" GetNpz(this::ByConstRef1{TF3})

# Wrapper of void TF3::GetRandom3(Double_t &, Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom3(this::ByRef1{TF3}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, zrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 3 random numbers following this function shape.
The distribution contained in this [TF3](@ref) function is integrated over the cell contents. It is normalized to 1. Getting the three random numbers implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which cell in the normalized integral r1 corresponds to
- make a linear interpolation in the returned cell

IMPORTANT NOTE

The integral of the function is computed at fNpx * fNpy * fNpz points. If the function has sharp peaks, you should increase the number of points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated at several points.
""" GetRandom3(this::ByRef1{TF3}, xrandom::ByRef2{Float64}, yrandom::ByRef2{Float64}, zrandom::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of void TF3::GetRange(Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF3}, xmin::ByRef2{Float64}, xmax::ByRef2{Float64})::Nothing
Return range of a 1-D function.

""" GetRange(this::ByConstRef1{TF3}, xmin::ByRef2{Float64}, xmax::ByRef2{Float64})

# Wrapper of void TF3::GetRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF3}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Return range of a 2-D function.

""" GetRange(this::ByConstRef1{TF3}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of void TF3::GetRange(Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TF3}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, zmin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64}, zmax::ByRef2{Float64})::Nothing
Return range of function.

""" GetRange(this::ByConstRef1{TF3}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, zmin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64}, zmax::ByRef2{Float64})

# Wrapper of Double_t TF3::GetSave(const Double_t *)
@trydoc raw"""
    GetSave(this::ByRef1{TF3}, x::ByConstPtr2{Float64})::Float64
Get value corresponding to X in array of fSave values.

""" GetSave(this::ByRef1{TF3}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF3::GetZmax()
@trydoc raw"""
    GetZmax(this::ByConstRef1{TF3})::Float64


""" GetZmax(this::ByConstRef1{TF3})

# Wrapper of Double_t TF3::GetZmin()
@trydoc raw"""
    GetZmin(this::ByConstRef1{TF3})::Float64


""" GetZmin(this::ByConstRef1{TF3})

# Wrapper of Double_t TF3::Integral(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Integral(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsrel::Float64)::Float64
Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz] with a desired relative accuracy.

""" Integral(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsrel::Float64)

# Wrapper of Bool_t TF3::IsInside(const Double_t *)
@trydoc raw"""
    IsInside(this::ByConstRef1{TF3}, x::ByConstPtr2{Float64})::Bool
Return kTRUE is the point is inside the function range.

""" IsInside(this::ByConstRef1{TF3}, x::ByConstPtr2{Float64})

# Wrapper of Double_t TF3::Mean3X(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Mean3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Mean3Y(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Mean3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Mean3Z(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Mean3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Mean3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Moment3(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Moment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64
Return x^nx * y^ny * z^nz moment of a 3d function in range [ax,bx],[ay,by],[az,bz].
###Author

Gene Van Buren gene@bnl.gov
""" Moment3(this::ByRef1{TF3}, nx::Float64, ax::Float64, bx::Float64, ny::Float64, ay::Float64, by::Float64, nz::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of TF3 & TF3::operator=(const TF3 &)
@trydoc raw"""
    assign(this::ByRef1{TF3}, rhs::ByConstRef1{TF3})::CxxRef1{TF3}
Operator =.

""" assign(this::ByRef1{TF3}, rhs::ByConstRef1{TF3})

# Wrapper of void TF3::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TF3}, option::ByCopy{String})::Nothing
Paint this 3-D function with its current attributes.

""" Paint(this::ByRef1{TF3}, option::ByCopy{String})

# Wrapper of void TF3::Save(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Save(this::ByRef1{TF3}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Nothing
Save values of function in array fSave.

""" Save(this::ByRef1{TF3}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of void TF3::SetClippingBoxOff()
@trydoc raw"""
    SetClippingBoxOff(this::ByRef1{TF3})::Nothing
Set the function clipping box (for drawing) "off".

""" SetClippingBoxOff(this::ByRef1{TF3})

# Wrapper of void TF3::SetClippingBoxOn(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetClippingBoxOn(this::ByRef1{TF3}, xclip::Float64, yclip::Float64, zclip::Float64)::Nothing
Set the function clipping box (for drawing) "on" and define the clipping box.
xclip, yclip and zclip is a point within the function range. All the function values having x<=xclip and y<=yclip and z>=zclip are clipped.
""" SetClippingBoxOn(this::ByRef1{TF3}, xclip::Float64, yclip::Float64, zclip::Float64)

# Wrapper of void TF3::SetNpz(Int_t)
@trydoc raw"""
    SetNpz(this::ByRef1{TF3}, npz::Int32)::Nothing
Set the number of points used to draw the function.
The default number of points along x is 30 for 2-d/3-d functions. You can increase this value to get a better resolution when drawing pictures with sharp peaks or to get a better result when using [TF3!GetRandom2](@ref) the minimum number of points is 4, the maximum is 10000 for 2-d/3-d functions
""" SetNpz(this::ByRef1{TF3}, npz::Int32)

# Wrapper of void TF3::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF3}, xmin::Float64, xmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.
The function range is also used in an histogram fit operation when the option "R" is specified.
""" SetRange(this::ByRef1{TF3}, xmin::Float64, xmax::Float64)

# Wrapper of void TF3::SetRange(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function-.

""" SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, xmax::Float64, ymax::Float64)

# Wrapper of void TF3::SetRange(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)::Nothing
Initialize the upper and lower bounds to draw the function.

""" SetRange(this::ByRef1{TF3}, xmin::Float64, ymin::Float64, zmin::Float64, xmax::Float64, ymax::Float64, zmax::Float64)

# Wrapper of Double_t TF3::Variance3X(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Variance3X(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Variance3Y(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Variance3Y(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of Double_t TF3::Variance3Z(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Variance3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)::Float64


""" Variance3Z(this::ByRef1{TF3}, ax::Float64, bx::Float64, ay::Float64, by::Float64, az::Float64, bz::Float64, epsilon::Float64)

# Wrapper of void TFractionFitter::Constrain(Int_t, Double_t, Double_t)
@trydoc raw"""
    Constrain(this::ByRef1{TFractionFitter}, parm::Int32, low::Float64, high::Float64)::Nothing
Constrain the values of parameter number `<parm>` (the parameter numbering follows that of the input template vector).
Use [UnConstrain()](@ref) to remove this constraint.
""" Constrain(this::ByRef1{TFractionFitter}, parm::Int32, low::Float64, high::Float64)

# Wrapper of void TFractionFitter::ErrorAnalysis(Double_t)
@trydoc raw"""
    ErrorAnalysis(this::ByRef1{TFractionFitter}, UP::Float64)::Nothing
Set UP to the given value (see class [TMinuit](@ref)), and perform a MINOS minimisation.

""" ErrorAnalysis(this::ByRef1{TFractionFitter}, UP::Float64)

# Wrapper of Double_t TFractionFitter::EvaluateFCN(const Double_t *)
@trydoc raw"""
    EvaluateFCN(this::ByRef1{TFractionFitter}, par::ByConstPtr2{Float64})::Float64


""" EvaluateFCN(this::ByRef1{TFractionFitter}, par::ByConstPtr2{Float64})

# Wrapper of void TFractionFitter::ExcludeBin(Int_t)
@trydoc raw"""
    ExcludeBin(this::ByRef1{TFractionFitter}, bin::Int32)::Nothing
Exclude the given bin from the fit.
The bin numbering to be used is that of [TH1!GetBin()](@ref).
""" ExcludeBin(this::ByRef1{TFractionFitter}, bin::Int32)

# Wrapper of TFitResultPtr TFractionFitter::Fit()
@trydoc raw"""
    Fit(this::ByRef1{TFractionFitter})::ByCopy{TFitResultPtr}
Perform the fit with the default UP value.
The value returned is the minimisation status.
""" Fit(this::ByRef1{TFractionFitter})

# Wrapper of Double_t TFractionFitter::GetChisquare()
@trydoc raw"""
    GetChisquare(this::ByConstRef1{TFractionFitter})::Float64
Return the likelihood ratio Chi-squared (chi2) for the fit.
The value is computed when the fit is executed successfully. Chi2 calculation is based on the "likelihood ratio" lambda, lambda = L(y;n) / L(m;n), where L(y;n) is the likelihood of the fit result `<y>` describing the data `<n>` and L(m;n) is the likelihood of an unknown "true" underlying distribution `<m>` describing the data `<n>`. Since `<m>` is unknown, the data distribution is used instead, lambda = L(y;n) / L(n;n). Note that this ratio is 1 if the fit is perfect. The chi2 value is then computed according to chi2 = -2*ln(lambda). This parameter can be shown to follow a Chi-square distribution. See for example S. Baker and R. Cousins, "Clarification of the use of chi-square
and likelihood functions in fits to histograms", Nucl. Instr. Meth. A221, pp. 437-442 (1984)
""" GetChisquare(this::ByConstRef1{TFractionFitter})

# Wrapper of TH1 * TFractionFitter::GetMCPrediction(Int_t)
@trydoc raw"""
    GetMCPrediction(this::ByConstRef1{TFractionFitter}, parm::Int32)::CxxPtr1{TH1}
Return the adjusted MC template (Aji) for template (parm).
Note that the (Aji) times fractions only sum to the total prediction of the fit if all weights are 1. Note also that the histogram is managed by the [TFractionFitter](@ref) class, so the returned pointer will be invalid if the class is deleted
""" GetMCPrediction(this::ByConstRef1{TFractionFitter}, parm::Int32)

# Wrapper of Int_t TFractionFitter::GetNDF()
@trydoc raw"""
    GetNDF(this::ByConstRef1{TFractionFitter})::Int32
return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit.
The number of degrees of freedom corresponds to the number of points used in the fit minus the number of templates.
""" GetNDF(this::ByConstRef1{TFractionFitter})

# Wrapper of TH1 * TFractionFitter::GetPlot()
@trydoc raw"""
    GetPlot(this::ByRef1{TFractionFitter})::CxxPtr1{TH1}
Return the "template prediction" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account).
Note that the name of this histogram will simply be the same as that of the "data" histogram, prefixed with the string "Fraction fit to hist: ". Note also that the histogram is managed by the [TFractionFitter](@ref) class, so the returned pointer will be invalid if the class is deleted
""" GetPlot(this::ByRef1{TFractionFitter})

# Wrapper of Double_t TFractionFitter::GetProb()
@trydoc raw"""
    GetProb(this::ByConstRef1{TFractionFitter})::Float64
return the fit probability

""" GetProb(this::ByConstRef1{TFractionFitter})

# Wrapper of void TFractionFitter::GetResult(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetResult(this::ByConstRef1{TFractionFitter}, parm::Int32, value::ByRef2{Float64}, error::ByRef2{Float64})::Nothing
Obtain the fit result for parameter `<parm>` (the parameter numbering follows that of the input template vector).

""" GetResult(this::ByConstRef1{TFractionFitter}, parm::Int32, value::ByRef2{Float64}, error::ByRef2{Float64})

# Wrapper of void TFractionFitter::IncludeBin(Int_t)
@trydoc raw"""
    IncludeBin(this::ByRef1{TFractionFitter}, bin::Int32)::Nothing
Include the given bin in the fit, if it was excluded before using [ExcludeBin()](@ref).
The bin numbering to be used is that of [TH1!GetBin()](@ref).
""" IncludeBin(this::ByRef1{TFractionFitter}, bin::Int32)

# Wrapper of void TFractionFitter::ReleaseRangeX()
@trydoc raw"""
    ReleaseRangeX(this::ByRef1{TFractionFitter})::Nothing
Release restrictions on the X range of the histogram to be used in the fit.

""" ReleaseRangeX(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::ReleaseRangeY()
@trydoc raw"""
    ReleaseRangeY(this::ByRef1{TFractionFitter})::Nothing
Release restrictions on the Y range of the histogram to be used in the fit.

""" ReleaseRangeY(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::ReleaseRangeZ()
@trydoc raw"""
    ReleaseRangeZ(this::ByRef1{TFractionFitter})::Nothing
Release restrictions on the Z range of the histogram to be used in the fit.

""" ReleaseRangeZ(this::ByRef1{TFractionFitter})

# Wrapper of void TFractionFitter::SetData(TH1 *)
@trydoc raw"""
    SetData(this::ByRef1{TFractionFitter}, data::ByPtr1{TH1})::Nothing
Change the histogram to be fitted to.
Notes:

- Parameter constraints and settings are retained from a possible previous fit.
- Modifying the dimension or number of bins results in an error (in this case rather instantiate a new [TFractionFitter](@ref) object)
""" SetData(this::ByRef1{TFractionFitter}, data::ByPtr1{TH1})

# Wrapper of void TFractionFitter::SetMC(Int_t, TH1 *)
@trydoc raw"""
    SetMC(this::ByRef1{TFractionFitter}, parm::Int32, MC::ByPtr1{TH1})::Nothing
Change the histogram for template number `<parm>`.
Notes:

- Parameter constraints and settings are retained from a possible previous fit.
- Modifying the dimension or number of bins results in an error (in this case rather instantiate a new [TFractionFitter](@ref) object)
""" SetMC(this::ByRef1{TFractionFitter}, parm::Int32, MC::ByPtr1{TH1})

# Wrapper of void TFractionFitter::SetRangeX(Int_t, Int_t)
@trydoc raw"""
    SetRangeX(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)::Nothing
Set the X range of the histogram to be used in the fit.
Use [ReleaseRangeX()](@ref) to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). ## Arguments

- **`low`** [in] 
    lower X bin number 
    
- **`high`** [in] 
    upper X bin number
""" SetRangeX(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)

# Wrapper of void TFractionFitter::SetRangeY(Int_t, Int_t)
@trydoc raw"""
    SetRangeY(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)::Nothing
Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).
Use [ReleaseRangeY()](@ref) to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). ## Arguments

- **`low`** [in] 
    lower X bin number 
    
- **`high`** [in] 
    upper X bin number
""" SetRangeY(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)

# Wrapper of void TFractionFitter::SetRangeZ(Int_t, Int_t)
@trydoc raw"""
    SetRangeZ(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)::Nothing
Set the Z range of the histogram to be used in the fit (3D histograms only).
Use [ReleaseRangeY()](@ref) to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). ## Arguments

- **`low`** [in] 
    lower X bin number 
    
- **`high`** [in] 
    upper X bin number
""" SetRangeZ(this::ByRef1{TFractionFitter}, low::Int32, high::Int32)

# Wrapper of void TFractionFitter::SetWeight(Int_t, TH1 *)
@trydoc raw"""
    SetWeight(this::ByRef1{TFractionFitter}, parm::Int32, weight::ByPtr1{TH1})::Nothing
Set bin by bin weights for template number `<parm>` (the parameter numbering follows that of the input template vector).
Weights can be "unset" by passing a null pointer. Consistency of the weights histogram with the data histogram is checked at this point, and an error in case of problems.
""" SetWeight(this::ByRef1{TFractionFitter}, parm::Int32, weight::ByPtr1{TH1})

# Wrapper of void TFractionFitter::UnConstrain(Int_t)
@trydoc raw"""
    UnConstrain(this::ByRef1{TFractionFitter}, parm::Int32)::Nothing
Remove the constraints on the possible values of parameter `<parm>`.

""" UnConstrain(this::ByRef1{TFractionFitter}, parm::Int32)

# Wrapper of void TH2D::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, bin::Int32)

# Wrapper of void TH2D::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, bin::Int32, w::Float64)

# Wrapper of void TH2D::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32)

# Wrapper of void TH2D::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2D}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of void TH2D::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2D}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2D}, hnew::ByRef1{TObject})

# Wrapper of TH2D & TH2D::operator=(const TH2D &)
@trydoc raw"""
    assign(this::ByRef1{TH2D}, h1::ByConstRef1{TH2D})::CxxRef1{TH2D}
Operator =.

""" assign(this::ByRef1{TH2D}, h1::ByConstRef1{TH2D})

# Wrapper of void TH2D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2D}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2D}, option::ByCopy{String})

# Wrapper of void TH2D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2D}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2D}, n::Int32)

# Wrapper of Double_t TGraph2DErrors::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraph2DErrors}, bin::Int32)::Float64
This function is called by Graph2DFitChisquare.
It returns the error along X at point i.
""" GetErrorX(this::ByConstRef1{TGraph2DErrors}, bin::Int32)

# Wrapper of Double_t TGraph2DErrors::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraph2DErrors}, bin::Int32)::Float64
This function is called by Graph2DFitChisquare.
It returns the error along Y at point i.
""" GetErrorY(this::ByConstRef1{TGraph2DErrors}, bin::Int32)

# Wrapper of Double_t TGraph2DErrors::GetErrorZ(Int_t)
@trydoc raw"""
    GetErrorZ(this::ByConstRef1{TGraph2DErrors}, bin::Int32)::Float64
This function is called by Graph2DFitChisquare.
It returns the error along Z at point i.
""" GetErrorZ(this::ByConstRef1{TGraph2DErrors}, bin::Int32)

# Wrapper of Double_t * TGraph2DErrors::GetEX()
@trydoc raw"""
    GetEX(this::ByConstRef1{TGraph2DErrors})::CxxPtr2{Float64}


""" GetEX(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t * TGraph2DErrors::GetEY()
@trydoc raw"""
    GetEY(this::ByConstRef1{TGraph2DErrors})::CxxPtr2{Float64}


""" GetEY(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t * TGraph2DErrors::GetEZ()
@trydoc raw"""
    GetEZ(this::ByConstRef1{TGraph2DErrors})::CxxPtr2{Float64}


""" GetEZ(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t TGraph2DErrors::GetXmaxE()
@trydoc raw"""
    GetXmaxE(this::ByConstRef1{TGraph2DErrors})::Float64
Returns the X maximum with errors.

""" GetXmaxE(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t TGraph2DErrors::GetXminE()
@trydoc raw"""
    GetXminE(this::ByConstRef1{TGraph2DErrors})::Float64
Returns the X minimum with errors.

""" GetXminE(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t TGraph2DErrors::GetYmaxE()
@trydoc raw"""
    GetYmaxE(this::ByConstRef1{TGraph2DErrors})::Float64
Returns the Y maximum with errors.

""" GetYmaxE(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t TGraph2DErrors::GetYminE()
@trydoc raw"""
    GetYminE(this::ByConstRef1{TGraph2DErrors})::Float64
Returns the Y minimum with errors.

""" GetYminE(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t TGraph2DErrors::GetZmaxE()
@trydoc raw"""
    GetZmaxE(this::ByConstRef1{TGraph2DErrors})::Float64
Returns the Z maximum with errors.

""" GetZmaxE(this::ByConstRef1{TGraph2DErrors})

# Wrapper of Double_t TGraph2DErrors::GetZminE()
@trydoc raw"""
    GetZminE(this::ByConstRef1{TGraph2DErrors})::Float64
Returns the Z minimum with errors.

""" GetZminE(this::ByConstRef1{TGraph2DErrors})

# Wrapper of TGraph2DErrors & TGraph2DErrors::operator=(const TGraph2DErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraph2DErrors}, ::ByConstRef1{TGraph2DErrors})::CxxRef1{TGraph2DErrors}
Assignment operator Copy everything except list of functions.

""" assign(this::ByRef1{TGraph2DErrors}, ::ByConstRef1{TGraph2DErrors})

# Wrapper of void TGraph2DErrors::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraph2DErrors}, chopt::ByCopy{String})::Nothing
Print 2D graph and errors values.

""" Print(this::ByConstRef1{TGraph2DErrors}, chopt::ByCopy{String})

# Wrapper of Int_t TGraph2DErrors::RemovePoint(Int_t)
@trydoc raw"""
    RemovePoint(this::ByRef1{TGraph2DErrors}, ipoint::Int32)::Int32
Deletes point number ipoint.

""" RemovePoint(this::ByRef1{TGraph2DErrors}, ipoint::Int32)

# Wrapper of void TGraph2DErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraph2DErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraph2DErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "z" the z values and errors are scaled If option contains "xyz" all three x, y and z values and errors are scaled
""" Scale(this::ByRef1{TGraph2DErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraph2DErrors::Set(Int_t)
@trydoc raw"""
    Set(this::ByRef1{TGraph2DErrors}, n::Int32)::Nothing
Set number of points in the 2D graph.
Existing coordinates are preserved. New coordinates above fNpoints are preset to 0.
""" Set(this::ByRef1{TGraph2DErrors}, n::Int32)

# Wrapper of void TGraph2DErrors::SetPoint(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TGraph2DErrors}, i::Int32, x::Float64, y::Float64, z::Float64)::Nothing
Set x, y and z values for point number i.

""" SetPoint(this::ByRef1{TGraph2DErrors}, i::Int32, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGraph2DErrors::SetPointError(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraph2DErrors}, i::Int32, ex::Float64, ey::Float64, ez::Float64)::Nothing
Set ex, ey and ez values for point number i.

""" SetPointError(this::ByRef1{TGraph2DErrors}, i::Int32, ex::Float64, ey::Float64, ez::Float64)

# Wrapper of void TGraphBentErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphBentErrors}, f::ByPtr1{TF1})::Nothing
Apply a function to all data points $ y = f(x,y) $.
Errors are calculated as $ eyh = f(x,y+eyh)-f(x,y) $ and $ eyl = f(x,y)-f(x,y-eyl) $.

Special treatment has to be applied for the functions where the role of "up" and "down" is reversed.

Function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphBentErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphBentErrors::ComputeRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    ComputeRange(this::ByConstRef1{TGraphBentErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Compute range.

""" ComputeRange(this::ByConstRef1{TGraphBentErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of Double_t TGraphBentErrors::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraphBentErrors}, bin::Int32)::Float64
It returns the error along X at point `i`.

""" GetErrorX(this::ByConstRef1{TGraphBentErrors}, bin::Int32)

# Wrapper of Double_t TGraphBentErrors::GetErrorXhigh(Int_t)
@trydoc raw"""
    GetErrorXhigh(this::ByConstRef1{TGraphBentErrors}, bin::Int32)::Float64
Get high error on X[i].

""" GetErrorXhigh(this::ByConstRef1{TGraphBentErrors}, bin::Int32)

# Wrapper of Double_t TGraphBentErrors::GetErrorXlow(Int_t)
@trydoc raw"""
    GetErrorXlow(this::ByConstRef1{TGraphBentErrors}, bin::Int32)::Float64
Get low error on X[i].

""" GetErrorXlow(this::ByConstRef1{TGraphBentErrors}, bin::Int32)

# Wrapper of Double_t TGraphBentErrors::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraphBentErrors}, bin::Int32)::Float64
It returns the error along Y at point `i`.

""" GetErrorY(this::ByConstRef1{TGraphBentErrors}, bin::Int32)

# Wrapper of Double_t TGraphBentErrors::GetErrorYhigh(Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraphBentErrors}, bin::Int32)::Float64
Get high error on Y[i].

""" GetErrorYhigh(this::ByConstRef1{TGraphBentErrors}, bin::Int32)

# Wrapper of Double_t TGraphBentErrors::GetErrorYlow(Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraphBentErrors}, bin::Int32)::Float64
Get low error on Y[i].

""" GetErrorYlow(this::ByConstRef1{TGraphBentErrors}, bin::Int32)

# Wrapper of Double_t * TGraphBentErrors::GetEXhigh()
@trydoc raw"""
    GetEXhigh(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEXhigh(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEXhighd()
@trydoc raw"""
    GetEXhighd(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEXhighd(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEXlow()
@trydoc raw"""
    GetEXlow(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEXlow(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEXlowd()
@trydoc raw"""
    GetEXlowd(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEXlowd(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEYhigh()
@trydoc raw"""
    GetEYhigh(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEYhigh(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEYhighd()
@trydoc raw"""
    GetEYhighd(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEYhighd(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEYlow()
@trydoc raw"""
    GetEYlow(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEYlow(this::ByConstRef1{TGraphBentErrors})

# Wrapper of Double_t * TGraphBentErrors::GetEYlowd()
@trydoc raw"""
    GetEYlowd(this::ByConstRef1{TGraphBentErrors})::CxxPtr2{Float64}


""" GetEYlowd(this::ByConstRef1{TGraphBentErrors})

# Wrapper of void TGraphBentErrors::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraphBentErrors}, chopt::ByCopy{String})::Nothing
Print graph and errors values.

""" Print(this::ByConstRef1{TGraphBentErrors}, chopt::ByCopy{String})

# Wrapper of void TGraphBentErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphBentErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphBentErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and errors are scaled If option contains "xy" both x and y values and errors are scaled
""" Scale(this::ByRef1{TGraphBentErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphBentErrors::SetPointError(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphBentErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)::Nothing
Set ex and ey values for point pointed by the mouse.

""" SetPointError(this::ByRef1{TGraphBentErrors}, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)

# Wrapper of void TGraphBentErrors::SetPointError(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphBentErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)::Nothing
Set ex and ey values for point number `i`.

""" SetPointError(this::ByRef1{TGraphBentErrors}, i::Int32, exl::Float64, exh::Float64, eyl::Float64, eyh::Float64, exld::Float64, exhd::Float64, eyld::Float64, eyhd::Float64)

# Wrapper of Double_t TGraphDelaunay::ComputeZ(Double_t, Double_t)
@trydoc raw"""
    ComputeZ(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)::Float64
Return the z value corresponding to the (x,y) point in fGraph2D.

""" ComputeZ(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)

# Wrapper of void TGraphDelaunay::FindAllTriangles()
@trydoc raw"""
    FindAllTriangles(this::ByRef1{TGraphDelaunay})::Nothing
Attempt to find all the Delaunay triangles of the point set.
It is not guaranteed that it will fully succeed, and no check is made that it has fully succeeded (such a check would be possible by referencing the points that make up the convex hull). The method is to check if each triangle shares all three of its sides with other triangles. If not, a point is generated just outside the triangle on the side(s) not shared, and a new triangle is found for that point. If this method is not working properly (many triangles are not being found) it's probably because the new points are too far beyond or too close to the non-shared sides. Fiddling with the size of the 'alittlebit' parameter may help.
""" FindAllTriangles(this::ByRef1{TGraphDelaunay})

# Wrapper of TGraph2D * TGraphDelaunay::GetGraph2D()
@trydoc raw"""
    GetGraph2D(this::ByConstRef1{TGraphDelaunay})::CxxPtr1{TGraph2D}


""" GetGraph2D(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::GetMarginBinsContent()
@trydoc raw"""
    GetMarginBinsContent(this::ByConstRef1{TGraphDelaunay})::Float64


""" GetMarginBinsContent(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Int_t * TGraphDelaunay::GetMTried()
@trydoc raw"""
    GetMTried(this::ByConstRef1{TGraphDelaunay})::CxxPtr2{Int32}


""" GetMTried(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Int_t TGraphDelaunay::GetNdt()
@trydoc raw"""
    GetNdt(this::ByConstRef1{TGraphDelaunay})::Int32


""" GetNdt(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Int_t * TGraphDelaunay::GetNTried()
@trydoc raw"""
    GetNTried(this::ByConstRef1{TGraphDelaunay})::CxxPtr2{Int32}


""" GetNTried(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Int_t * TGraphDelaunay::GetPTried()
@trydoc raw"""
    GetPTried(this::ByConstRef1{TGraphDelaunay})::CxxPtr2{Int32}


""" GetPTried(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t * TGraphDelaunay::GetXN()
@trydoc raw"""
    GetXN(this::ByConstRef1{TGraphDelaunay})::CxxPtr2{Float64}


""" GetXN(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::GetXNmax()
@trydoc raw"""
    GetXNmax(this::ByConstRef1{TGraphDelaunay})::Float64


""" GetXNmax(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::GetXNmin()
@trydoc raw"""
    GetXNmin(this::ByConstRef1{TGraphDelaunay})::Float64


""" GetXNmin(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t * TGraphDelaunay::GetYN()
@trydoc raw"""
    GetYN(this::ByConstRef1{TGraphDelaunay})::CxxPtr2{Float64}


""" GetYN(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::GetYNmax()
@trydoc raw"""
    GetYNmax(this::ByConstRef1{TGraphDelaunay})::Float64


""" GetYNmax(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::GetYNmin()
@trydoc raw"""
    GetYNmin(this::ByConstRef1{TGraphDelaunay})::Float64


""" GetYNmin(this::ByConstRef1{TGraphDelaunay})

# Wrapper of Double_t TGraphDelaunay::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)::Float64
Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by linearly interpolating the z-values that make up that triangle.

""" Interpolate(this::ByRef1{TGraphDelaunay}, x::Float64, y::Float64)

# Wrapper of void TGraphDelaunay::SetMarginBinsContent(Double_t)
@trydoc raw"""
    SetMarginBinsContent(this::ByRef1{TGraphDelaunay}, z::Float64)::Nothing
Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin.

""" SetMarginBinsContent(this::ByRef1{TGraphDelaunay}, z::Float64)

# Wrapper of void TGraphDelaunay::SetMaxIter(Int_t)
@trydoc raw"""
    SetMaxIter(this::ByRef1{TGraphDelaunay}, n::Int32)::Nothing
Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoning the search.

""" SetMaxIter(this::ByRef1{TGraphDelaunay}, n::Int32)

# Wrapper of Double_t TGraphDelaunay2D::ComputeZ(Double_t, Double_t)
@trydoc raw"""
    ComputeZ(this::ByRef1{TGraphDelaunay2D}, x::Float64, y::Float64)::Float64


""" ComputeZ(this::ByRef1{TGraphDelaunay2D}, x::Float64, y::Float64)

# Wrapper of void TGraphDelaunay2D::FindAllTriangles()
@trydoc raw"""
    FindAllTriangles(this::ByRef1{TGraphDelaunay2D})::Nothing


""" FindAllTriangles(this::ByRef1{TGraphDelaunay2D})

# Wrapper of TGraph2D * TGraphDelaunay2D::GetGraph2D()
@trydoc raw"""
    GetGraph2D(this::ByConstRef1{TGraphDelaunay2D})::CxxPtr1{TGraph2D}


""" GetGraph2D(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of Double_t TGraphDelaunay2D::GetMarginBinsContent()
@trydoc raw"""
    GetMarginBinsContent(this::ByConstRef1{TGraphDelaunay2D})::Float64


""" GetMarginBinsContent(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of Int_t TGraphDelaunay2D::GetNdt()
@trydoc raw"""
    GetNdt(this::ByConstRef1{TGraphDelaunay2D})::Int32


""" GetNdt(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of Double_t TGraphDelaunay2D::GetXNmax()
@trydoc raw"""
    GetXNmax(this::ByConstRef1{TGraphDelaunay2D})::Float64


""" GetXNmax(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of Double_t TGraphDelaunay2D::GetXNmin()
@trydoc raw"""
    GetXNmin(this::ByConstRef1{TGraphDelaunay2D})::Float64


""" GetXNmin(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of Double_t TGraphDelaunay2D::GetYNmax()
@trydoc raw"""
    GetYNmax(this::ByConstRef1{TGraphDelaunay2D})::Float64


""" GetYNmax(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of Double_t TGraphDelaunay2D::GetYNmin()
@trydoc raw"""
    GetYNmin(this::ByConstRef1{TGraphDelaunay2D})::Float64


""" GetYNmin(this::ByConstRef1{TGraphDelaunay2D})

# Wrapper of void TGraphDelaunay2D::SetMarginBinsContent(Double_t)
@trydoc raw"""
    SetMarginBinsContent(this::ByRef1{TGraphDelaunay2D}, z::Float64)::Nothing


""" SetMarginBinsContent(this::ByRef1{TGraphDelaunay2D}, z::Float64)

# Wrapper of void TGraphMultiErrors::AddYError(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    AddYError(this::ByRef1{TGraphMultiErrors}, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Add a new y asymmetric errors to the graph and fill them with the values from `eyL` and `eyH`
## Arguments

- **`np`** 
    number of data points in the graph 
    
- **`eyL`** 
    array of low (left) errors, length must match `np` 
    
- **`eyH`** 
    array of high (right) errors, length must match `np` 
    

###Note

This function can be called repeatedly for the same graph to overlay different types of y errors (dimensions). If done, then specify how to sum the different error contributions, for example g.SetSumErrorsMode(TGraphMultiErrors!kSquareSum);
""" AddYError(this::ByRef1{TGraphMultiErrors}, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::Apply(TF1 *)
@trydoc raw"""
    Apply(this::ByRef1{TGraphMultiErrors}, f::ByPtr1{TF1})::Nothing
Apply a function to all data points $ y = f(x,y) $.
Errors are calculated as $ eyh = f(x,y+eyh)-f(x,y) $ and $ eyl = f(x,y)-f(x,y-eyl) $

Only the first error dimension is affected.

Special treatment has to be applied for the functions where the role of "up" and "down" is reversed.

Function suggested/implemented by Miroslav Helbich [helbich@mail.desy.de](mailto:helbich@mail.desy.de)
""" Apply(this::ByRef1{TGraphMultiErrors}, f::ByPtr1{TF1})

# Wrapper of void TGraphMultiErrors::BayesDivide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    BayesDivide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
This function is only kept for backward compatibility.
You should rather use the Divide method. It calls `Divide(pass,total,"cl=0.683 b(1,1) mode")` which is equivalent to the former BayesDivide method.
""" BayesDivide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of void TGraphMultiErrors::ComputeRange(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    ComputeRange(this::ByConstRef1{TGraphMultiErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})::Nothing
Compute Range.

""" ComputeRange(this::ByConstRef1{TGraphMultiErrors}, xmin::ByRef2{Float64}, ymin::ByRef2{Float64}, xmax::ByRef2{Float64}, ymax::ByRef2{Float64})

# Wrapper of void TGraphMultiErrors::DeleteYError(Int_t)
@trydoc raw"""
    DeleteYError(this::ByRef1{TGraphMultiErrors}, e::Int32)::Nothing
Deletes the y error with the index `e`.
Note that you must keep at least 1 error
""" DeleteYError(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of void TGraphMultiErrors::Divide(const TH1 *, const TH1 *, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})::Nothing
This function was adapted from the [TGraphAsymmErrors](@ref) class.
See [TGraphAsymmErrors!Divide](@ref) for the documentation

Only the first error dimension is affected.
""" Divide(this::ByRef1{TGraphMultiErrors}, pass::ByConstPtr1{TH1}, total::ByConstPtr1{TH1}, opt::ByCopy{String})

# Wrapper of TAttFill * TGraphMultiErrors::GetAttFill(Int_t)
@trydoc raw"""
    GetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr1{TAttFill}
Get AttFill pointer for specified error dimension.

""" GetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of TAttLine * TGraphMultiErrors::GetAttLine(Int_t)
@trydoc raw"""
    GetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr1{TAttLine}
Get AttLine pointer for specified error dimension.

""" GetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorX(Int_t)
@trydoc raw"""
    GetErrorX(this::ByConstRef1{TGraphMultiErrors}, i::Int32)::Float64
Get error on x coordinate for point `i`.
In case of asymmetric errors the mean of the square sum is returned
""" GetErrorX(this::ByConstRef1{TGraphMultiErrors}, i::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorXhigh(Int_t)
@trydoc raw"""
    GetErrorXhigh(this::ByConstRef1{TGraphMultiErrors}, i::Int32)::Float64
Get high error on x coordinate for point `i`.

""" GetErrorXhigh(this::ByConstRef1{TGraphMultiErrors}, i::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorXlow(Int_t)
@trydoc raw"""
    GetErrorXlow(this::ByConstRef1{TGraphMultiErrors}, i::Int32)::Float64
Get low error on x coordinate for point `i`.

""" GetErrorXlow(this::ByConstRef1{TGraphMultiErrors}, i::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorY(Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraphMultiErrors}, i::Int32)::Float64
Get error on y coordinate for point `i`.
The multiple errors of the dimensions are summed according to `fSumErrorsMode`. In case of asymmetric errors the mean of the square sum is returned
""" GetErrorY(this::ByConstRef1{TGraphMultiErrors}, i::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorY(Int_t, Int_t)
@trydoc raw"""
    GetErrorY(this::ByConstRef1{TGraphMultiErrors}, i::Int32, e::Int32)::Float64
Get error e on y coordinate for point `i`.
In case of asymmetric errors the mean of the square sum is returned
""" GetErrorY(this::ByConstRef1{TGraphMultiErrors}, i::Int32, e::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorYhigh(Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraphMultiErrors}, i::Int32)::Float64
Get high error on y coordinate for point `i`.
The multiple errors of the dimensions are summed according to `fSumErrorsMode`.
""" GetErrorYhigh(this::ByConstRef1{TGraphMultiErrors}, i::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorYhigh(Int_t, Int_t)
@trydoc raw"""
    GetErrorYhigh(this::ByConstRef1{TGraphMultiErrors}, i::Int32, e::Int32)::Float64
Get high error e on y coordinate for point `i`.

""" GetErrorYhigh(this::ByConstRef1{TGraphMultiErrors}, i::Int32, e::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorYlow(Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraphMultiErrors}, i::Int32)::Float64
Get low error on y coordinate for point `i`.
The multiple errors of the dimensions are summed according to `fSumErrorsMode`.
""" GetErrorYlow(this::ByConstRef1{TGraphMultiErrors}, i::Int32)

# Wrapper of Double_t TGraphMultiErrors::GetErrorYlow(Int_t, Int_t)
@trydoc raw"""
    GetErrorYlow(this::ByConstRef1{TGraphMultiErrors}, i::Int32, e::Int32)::Float64
Get low error e on y coordinate for point `i`.

""" GetErrorYlow(this::ByConstRef1{TGraphMultiErrors}, i::Int32, e::Int32)

# Wrapper of Double_t * TGraphMultiErrors::GetEXhigh()
@trydoc raw"""
    GetEXhigh(this::ByConstRef1{TGraphMultiErrors})::CxxPtr2{Float64}


""" GetEXhigh(this::ByConstRef1{TGraphMultiErrors})

# Wrapper of Double_t * TGraphMultiErrors::GetEXlow()
@trydoc raw"""
    GetEXlow(this::ByConstRef1{TGraphMultiErrors})::CxxPtr2{Float64}


""" GetEXlow(this::ByConstRef1{TGraphMultiErrors})

# Wrapper of Double_t * TGraphMultiErrors::GetEYhigh()
@trydoc raw"""
    GetEYhigh(this::ByConstRef1{TGraphMultiErrors})::CxxPtr2{Float64}
Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.

""" GetEYhigh(this::ByConstRef1{TGraphMultiErrors})

# Wrapper of Double_t * TGraphMultiErrors::GetEYhigh(Int_t)
@trydoc raw"""
    GetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr2{Float64}
Get all high errors `e` on y coordinates as an array.

""" GetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Double_t * TGraphMultiErrors::GetEYlow()
@trydoc raw"""
    GetEYlow(this::ByConstRef1{TGraphMultiErrors})::CxxPtr2{Float64}
Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.

""" GetEYlow(this::ByConstRef1{TGraphMultiErrors})

# Wrapper of Double_t * TGraphMultiErrors::GetEYlow(Int_t)
@trydoc raw"""
    GetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32)::CxxPtr2{Float64}
Get all low errors `e` on y coordinates as an array.

""" GetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Color_t TGraphMultiErrors::GetFillColor(Int_t)
@trydoc raw"""
    GetFillColor(this::ByConstRef1{TGraphMultiErrors}, e::Int32)::Int16
Get Fill Color for specified error e (-1 = Global and x errors).

""" GetFillColor(this::ByConstRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Style_t TGraphMultiErrors::GetFillStyle(Int_t)
@trydoc raw"""
    GetFillStyle(this::ByConstRef1{TGraphMultiErrors}, e::Int32)::Int16
Get Fill Style for specified error e (-1 = Global and x errors).

""" GetFillStyle(this::ByConstRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Color_t TGraphMultiErrors::GetLineColor(Int_t)
@trydoc raw"""
    GetLineColor(this::ByConstRef1{TGraphMultiErrors}, e::Int32)::Int16
Get Line Color for specified error e (-1 = Global and x errors).

""" GetLineColor(this::ByConstRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Style_t TGraphMultiErrors::GetLineStyle(Int_t)
@trydoc raw"""
    GetLineStyle(this::ByConstRef1{TGraphMultiErrors}, e::Int32)::Int16
Get Line Style for specified error e (-1 = Global and x errors).

""" GetLineStyle(this::ByConstRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Width_t TGraphMultiErrors::GetLineWidth(Int_t)
@trydoc raw"""
    GetLineWidth(this::ByConstRef1{TGraphMultiErrors}, e::Int32)::Int16
Get Line Width for specified error e (-1 = Global and x errors).

""" GetLineWidth(this::ByConstRef1{TGraphMultiErrors}, e::Int32)

# Wrapper of Int_t TGraphMultiErrors::GetNYErrors()
@trydoc raw"""
    GetNYErrors(this::ByConstRef1{TGraphMultiErrors})::Int32


""" GetNYErrors(this::ByConstRef1{TGraphMultiErrors})

# Wrapper of Int_t TGraphMultiErrors::GetSumErrorsMode()
@trydoc raw"""
    GetSumErrorsMode(this::ByConstRef1{TGraphMultiErrors})::Int32


""" GetSumErrorsMode(this::ByConstRef1{TGraphMultiErrors})

# Wrapper of TGraphMultiErrors & TGraphMultiErrors::operator=(const TGraphMultiErrors &)
@trydoc raw"""
    assign(this::ByRef1{TGraphMultiErrors}, tgme::ByConstRef1{TGraphMultiErrors})::CxxRef1{TGraphMultiErrors}
[TGraphMultiErrors](@ref) assignment operator.

""" assign(this::ByRef1{TGraphMultiErrors}, tgme::ByConstRef1{TGraphMultiErrors})

# Wrapper of void TGraphMultiErrors::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGraphMultiErrors}, chopt::ByCopy{String})::Nothing
Print graph and errors values.

""" Print(this::ByConstRef1{TGraphMultiErrors}, chopt::ByCopy{String})

# Wrapper of void TGraphMultiErrors::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TGraphMultiErrors}, c1::Float64, option::ByCopy{String})::Nothing
Multiply the values and errors of a [TGraphMultiErrors](@ref) by a constant c1.
If option contains "x" the x values and errors are scaled If option contains "y" the y values and (multiple) errors are scaled If option contains "xy" both x and y values and (multiple) errors are scaled
""" Scale(this::ByRef1{TGraphMultiErrors}, c1::Float64, option::ByCopy{String})

# Wrapper of void TGraphMultiErrors::SetAttFill(Int_t, TAttFill *)
@trydoc raw"""
    SetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32, taf::ByPtr1{TAttFill})::Nothing
Set [TAttFill](@ref) parameters of error e by copying from another [TAttFill](@ref) (-1 = Global and x errors).

""" SetAttFill(this::ByRef1{TGraphMultiErrors}, e::Int32, taf::ByPtr1{TAttFill})

# Wrapper of void TGraphMultiErrors::SetAttLine(Int_t, TAttLine *)
@trydoc raw"""
    SetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32, tal::ByPtr1{TAttLine})::Nothing
Set [TAttLine](@ref) parameters of error e by copying from another [TAttLine](@ref) (-1 = Global and x errors).

""" SetAttLine(this::ByRef1{TGraphMultiErrors}, e::Int32, tal::ByPtr1{TAttLine})

# Wrapper of void TGraphMultiErrors::SetEY(Int_t, Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    SetEY(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Set error e eyL values (low/left) and eyH values (high/right).
## Arguments

- **`e`** 
    the y error type (dimension) 
    
- **`np`** 
    number of points to set for this dimension 
    
- **`eyL`** 
    array of low (left) errors, length must match `np` 
    
- **`eyH`** 
    array of high (right) errors, length must match `np`
""" SetEY(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetEYhigh(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyH::ByConstPtr2{Float64})::Nothing
Set error e eyH values (high/right).
## Arguments

- **`e`** 
    the y error type (dimension) 
    
- **`np`** 
    number of points to set for this dimension 
    
- **`eyH`** 
    array of high (right) errors, length must match `np` 
    

###Note

if np < fNpoints, rest will be set to 0. if np >= fNpoints, extra data will be ignored.
""" SetEYhigh(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetEYlow(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64})::Nothing
Set error e eyL values (low/left).
## Arguments

- **`e`** 
    the y error type (dimension) 
    
- **`np`** 
    number of points to set for this dimension 
    
- **`eyL`** 
    array of low (left) errors, length must match `np` 
    

###Note

if np < fNpoints, rest will be set to 0. if np >= fNpoints, extra data will be ignored.
""" SetEYlow(this::ByRef1{TGraphMultiErrors}, e::Int32, np::Int32, eyL::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetFillColor(Int_t, Color_t)
@trydoc raw"""
    SetFillColor(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16)::Nothing
Set Fill Color of error e (-1 = Global and x errors).

""" SetFillColor(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16)

# Wrapper of void TGraphMultiErrors::SetFillColorAlpha(Int_t, Color_t, Float_t)
@trydoc raw"""
    SetFillColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16, falpha::Float32)::Nothing
Set Fill Color and Alpha of error e (-1 = Global and x errors).

""" SetFillColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, fcolor::Int16, falpha::Float32)

# Wrapper of void TGraphMultiErrors::SetFillStyle(Int_t, Style_t)
@trydoc raw"""
    SetFillStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, fstyle::Int16)::Nothing
Set Fill Style of error e (-1 = Global and x errors).

""" SetFillStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, fstyle::Int16)

# Wrapper of void TGraphMultiErrors::SetLineColor(Int_t, Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16)::Nothing
Set Line Color of error e (-1 = Global and x errors).

""" SetLineColor(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16)

# Wrapper of void TGraphMultiErrors::SetLineColorAlpha(Int_t, Color_t, Float_t)
@trydoc raw"""
    SetLineColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16, lalpha::Float32)::Nothing
Set Line Color and Alpha of error e (-1 = Global and x errors).

""" SetLineColorAlpha(this::ByRef1{TGraphMultiErrors}, e::Int32, lcolor::Int16, lalpha::Float32)

# Wrapper of void TGraphMultiErrors::SetLineStyle(Int_t, Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, lstyle::Int16)::Nothing
Set Line Style of error e (-1 = Global and x errors).

""" SetLineStyle(this::ByRef1{TGraphMultiErrors}, e::Int32, lstyle::Int16)

# Wrapper of void TGraphMultiErrors::SetLineWidth(Int_t, Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TGraphMultiErrors}, e::Int32, lwidth::Int16)::Nothing
Set Line Width of error e (-1 = Global and x errors).

""" SetLineWidth(this::ByRef1{TGraphMultiErrors}, e::Int32, lwidth::Int16)

# Wrapper of void TGraphMultiErrors::SetPointError(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphMultiErrors}, exL::Float64, exH::Float64, eyL1::Float64, eyH1::Float64, eyL2::Float64, eyH2::Float64, eyL3::Float64, eyH3::Float64)::Nothing
Set ex and ey values for point pointed by the mouse.
Up to 3 y error dimensions possible.
""" SetPointError(this::ByRef1{TGraphMultiErrors}, exL::Float64, exH::Float64, eyL1::Float64, eyH1::Float64, eyL2::Float64, eyH2::Float64, eyL3::Float64, eyH3::Float64)

# Wrapper of void TGraphMultiErrors::SetPointError(Int_t, Int_t, Double_t, Double_t, const Double_t *, const Double_t *)
@trydoc raw"""
    SetPointError(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, exL::Float64, exH::Float64, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Set ex and ey values for point `i` (first error dimension).

""" SetPointError(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, exL::Float64, exH::Float64, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetPointEX(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPointEX(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64, exH::Float64)::Nothing
Set ex values for point `i` (first error dimension).

""" SetPointEX(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64, exH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEXhigh(Int_t, Double_t)
@trydoc raw"""
    SetPointEXhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, exH::Float64)::Nothing
Set exH value for point `i` (first error dimension).

""" SetPointEXhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, exH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEXlow(Int_t, Double_t)
@trydoc raw"""
    SetPointEXlow(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64)::Nothing
Set exL value for point `i` (first error dimension).

""" SetPointEXlow(this::ByRef1{TGraphMultiErrors}, i::Int32, exL::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEY(Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64, eyH::Float64)::Nothing
Set error e eyL value (low/left) and eyH value (high/right) for point `i`.
## Arguments

- **`e`** 
    the y error type (dimension) 
    
- **`eyL`** 
    low (left) error 
    
- **`eyH`** 
    high (right) error
""" SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64, eyH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEY(Int_t, Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})::Nothing
Set error eyL values (low/left) and eyH values (high/right) for point `i` for all dimensions.
## Arguments

- **`ne`** 
    number of error types (dimensions) 
    
- **`eyL`** 
    array of high (right) errors, length must match `ne` 
    
- **`eyH`** 
    array of high (right) errors, length must match `ne`
""" SetPointEY(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64}, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetPointEYhigh(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyH::Float64)::Nothing
Set error e eyH value (high/right) for point `i`.
## Arguments

- **`e`** 
    the y error type (dimension) 
    
- **`eyH`** 
    high (right) error
""" SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyH::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEYhigh(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyH::ByConstPtr2{Float64})::Nothing
Set error eyH values (high/right) for point `i` for all dimensions.
## Arguments

- **`ne`** 
    number of error types (dimensions) 
    
- **`eyH`** 
    array of high (right) errors, length must match `ne`
""" SetPointEYhigh(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyH::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetPointEYlow(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64)::Nothing
Set error e eyL value (low/left) for point `i`.
## Arguments

- **`e`** 
    the y error type (dimension) 
    
- **`eyL`** 
    low (left) error
""" SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, e::Int32, eyL::Float64)

# Wrapper of void TGraphMultiErrors::SetPointEYlow(Int_t, Int_t, const Double_t *)
@trydoc raw"""
    SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64})::Nothing
Set error eyL values (low/left) for point `i` for all dimensions.
## Arguments

- **`ne`** 
    number of error types (dimensions) 
    
- **`eyL`** 
    array of high (right) errors, length must match `ne`
""" SetPointEYlow(this::ByRef1{TGraphMultiErrors}, i::Int32, ne::Int32, eyL::ByConstPtr2{Float64})

# Wrapper of void TGraphMultiErrors::SetSumErrorsMode(Int_t)
@trydoc raw"""
    SetSumErrorsMode(this::ByRef1{TGraphMultiErrors}, m::Int32)::Nothing
Set the sum errors mode and recalculate summed errors.
This function is useful if you defined more than 1 error dimension:

- kOnlyFirst = Only First dimension (default)
- kSquareSum = Squared Sum
- kSum = Absolute Addition
""" SetSumErrorsMode(this::ByRef1{TGraphMultiErrors}, m::Int32)

# Wrapper of TGraph * TGraphSmooth::Approx(TGraph *, Option_t *, Int_t, Double_t *, Double_t, Double_t, Int_t, Double_t, Option_t *)
@trydoc raw"""
    Approx(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, nout::Int32, xout::ByPtr2{Float64}, yleft::Float64, yright::Float64, rule::Int32, f::Float64, ties::ByCopy{String})::CxxPtr1{TGraph}
Approximate data points.
## Arguments

- **`grin`** [in] 
    graph giving the coordinates of the points to be interpolated. Alternatively a single plotting structure can be specified: 
    
- **`option`** [in] 
    specifies the interpolation method to be used. Choices are "linear" (iKind = 1) or "constant" (iKind = 2). 
    
- **`nout`** [in] 
    If xout is not specified, interpolation takes place at n equally spaced points spanning the interval [min(x), max(x)], where nout = max(nout, number of input data). 
    
- **`xout`** [in] 
    an optional set of values specifying where interpolation is to take place. 
    
- **`yleft`** [in] 
    the value to be returned when input x values less than min(x). The default is defined by the value of rule given below. 
    
- **`yright`** [in] 
    the value to be returned when input x values greater than max(x). The default is defined by the value of rule given below. 
    
- **`rule`** [in] 
    an integer describing how interpolation is to take place outside the interval [min(x), max(x)]. If rule is 0 then the given yleft and yright values are returned, if it is 1 then 0 is returned for such points and if it is 2, the value at the closest data extreme is used. 
    
- **`f`** [in] 
    For method="constant" a number between 0 and 1 inclusive, indicating a compromise between left- and right-continuous step functions. If y0 and y1 are the values to the left and right of the point then the value is y0*f+y1*(1-f) so that f=0 is right-continuous and f=1 is left-continuous 
    
- **`ties`** [in] 
    Handling of tied x values. An integer describing a function with a single vector argument returning a single number result:
    
    - ties = "ordered" (iTies = 0): input x are "ordered"
    - ties = "mean" (iTies = 1): function "mean"
    - ties = "min" (iTies = 2): function "min"
    - ties = "max" (iTies = 3): function "max"
    
    

Details:

At least two complete (x, y) pairs are required. If there are duplicated (tied) x values and ties is a function it is applied to the y values for each distinct x value. Useful functions in this context include mean, min, and max. If ties="ordered" the x values are assumed to be already ordered. The first y value will be used for interpolation to the left and the last one for interpolation to the right.

Value:

approx returns a graph with components x and y, containing n coordinates which interpolate the given data points according to the method (and rule) desired.
""" Approx(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, nout::Int32, xout::ByPtr2{Float64}, yleft::Float64, yright::Float64, rule::Int32, f::Float64, ties::ByCopy{String})

# Wrapper of void TGraphSmooth::Approxin(TGraph *, Int_t, Double_t &, Double_t &, Int_t, Int_t)
@trydoc raw"""
    Approxin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, iKind::Int32, Ylow::ByRef2{Float64}, Yhigh::ByRef2{Float64}, rule::Int32, iTies::Int32)::Nothing
Sort data points and eliminate double x values.

""" Approxin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, iKind::Int32, Ylow::ByRef2{Float64}, Yhigh::ByRef2{Float64}, rule::Int32, iTies::Int32)

# Wrapper of void TGraphSmooth::Lowess(Double_t *, Double_t *, Int_t, Double_t *, Double_t, Int_t, Double_t)
@trydoc raw"""
    Lowess(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, ys::ByPtr2{Float64}, span::Float64, iter::Int32, delta::Float64)::Nothing
Lowess regression smoother.
Based on R function clowess: Translated to C++ by C. Stratowa (R source file: lowess.c by R Development Core Team (C) 1999-2001)
""" Lowess(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, ys::ByPtr2{Float64}, span::Float64, iter::Int32, delta::Float64)

# Wrapper of void TGraphSmooth::Smoothin(TGraph *)
@trydoc raw"""
    Smoothin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph})::Nothing
Sort input data points.

""" Smoothin(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph})

# Wrapper of TGraph * TGraphSmooth::SmoothKern(TGraph *, Option_t *, Double_t, Int_t, Double_t *)
@trydoc raw"""
    SmoothKern(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bandwidth::Float64, nout::Int32, xout::ByPtr2{Float64})::CxxPtr1{TGraph}
Smooth data with Kernel smoother.
Smooth grin with the Nadaraya-Watson kernel regression estimate.

## Arguments

- **`grin`** [in] 
    input graph 
    
- **`option`** [in] 
    the kernel to be used: "box", "normal" 
    
- **`bandwidth`** [in] 
    the bandwidth. The kernels are scaled so that their quartiles (viewed as probability densities) are at +/- 0.25*bandwidth. 
    
- **`nout`** [in] 
    If xout is not specified, interpolation takes place at equally spaced points spanning the interval [min(x), max(x)], where nout = max(nout, number of input data). 
    
- **`xout`** [in] 
    an optional set of values at which to evaluate the fit
""" SmoothKern(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bandwidth::Float64, nout::Int32, xout::ByPtr2{Float64})

# Wrapper of TGraph * TGraphSmooth::SmoothLowess(TGraph *, Option_t *, Double_t, Int_t, Double_t)
@trydoc raw"""
    SmoothLowess(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, span::Float64, iter::Int32, delta::Float64)::CxxPtr1{TGraph}
Smooth data with Lowess smoother.
This function performs the computations for the LOWESS smoother (see the reference below). Lowess returns the output points x and y which give the coordinates of the smooth.

## Arguments

- **`grin`** [in] 
    Input graph 
    
- **`option`** [in] 
    specific options 
    
- **`span`** [in] 
    the smoother span. This gives the proportion of points in the plot which influence the smooth at each value. Larger values give more smoothness. 
    
- **`iter`** [in] 
    the number of robustifying iterations which should be performed. Using smaller values of iter will make lowess run faster. 
    
- **`delta`** [in] 
    values of x which lie within delta of each other replaced by a single value in the output from lowess. For delta = 0, delta will be calculated.
    

References:

- Cleveland, W. S. (1979) Robust locally weighted regression and smoothing scatterplots. J. Amer. Statist. Assoc. 74, 829-836.
- Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots by robust locally weighted regression. The American Statistician, 35, 54.
""" SmoothLowess(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, span::Float64, iter::Int32, delta::Float64)

# Wrapper of TGraph * TGraphSmooth::SmoothSuper(TGraph *, Option_t *, Double_t, Double_t, Bool_t, Double_t *)
@trydoc raw"""
    SmoothSuper(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bass::Float64, span::Float64, isPeriodic::Bool, w::ByPtr2{Float64})::CxxPtr1{TGraph}
Smooth data with Super smoother.
Smooth the (x, y) values by Friedman's `'super smoother''.

## Arguments

- **`grin`** [in] 
    graph for smoothing 
    
- **`option`** [in] 
    specific options 
    
- **`span`** [in] 
    the fraction of the observations in the span of the running lines smoother, or 0 to choose this by leave-one-out cross-validation. 
    
- **`bass`** [in] 
    controls the smoothness of the fitted curve. Values of up to 10 indicate increasing smoothness. 
    
- **`isPeriodic`** [in] 
    if TRUE, the x values are assumed to be in [0, 1] and of period 1. 
    
- **`w`** [in] 
    case weights
    

Details:

supsmu is a running lines smoother which chooses between three spans for the lines. The running lines smoothers are symmetric, with k/2 data points each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and 0.05 * n, where n is the number of data points. If span is specified, a single smoother with span span * n is used.

The best of the three smoothers is chosen by cross-validation for each prediction. The best spans are then smoothed by a running lines smoother and the final prediction chosen by linear interpolation.

The FORTRAN code says: ``For small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. Reasonable span values are 0.2 to 0.4.''

References:

- Friedman, J. H. (1984) SMART User's Guide. Laboratory for Computational Statistics, Stanford University Technical Report No. 1.
- Friedman, J. H. (1984) A variable span scatterplot smoother. Laboratory for Computational Statistics, Stanford University Technical Report No. 5.
""" SmoothSuper(this::ByRef1{TGraphSmooth}, grin::ByPtr1{TGraph}, option::ByCopy{String}, bass::Float64, span::Float64, isPeriodic::Bool, w::ByPtr2{Float64})

# Wrapper of Double_t TGraphSmooth::Approx1(Double_t, Double_t, Double_t *, Double_t *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    TGraphSmooth!Approx1(this::ByRef1{TGraphSmooth}, v::Float64, f::Float64, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, iKind::Int32, Ylow::Float64, Yhigh::Float64)::Float64
Approximate one data point.
Approximate y(v), given (x,y)[i], i = 0,..,n-1 Based on R function approx1: Translated to C++ by Christian Stratowa (R source file: approx.c by R Development Core Team (C) 1999-2001)
""" TGraphSmooth!Approx1(this::ByRef1{TGraphSmooth}, v::Float64, f::Float64, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, iKind::Int32, Ylow::Float64, Yhigh::Float64)

# Wrapper of void TGraphSmooth::BDRksmooth(Double_t *, Double_t *, Int_t, Double_t *, Double_t *, Int_t, Int_t, Double_t)
@trydoc raw"""
    TGraphSmooth!BDRksmooth(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, xp::ByPtr2{Float64}, yp::ByPtr2{Float64}, np::Int32, kernel::Int32, bw::Float64)::Nothing
Smooth data with specified kernel.
Based on R function ksmooth: Translated to C++ by C. Stratowa (R source file: ksmooth.c by B.D.Ripley Copyright (C) 1998)
""" TGraphSmooth!BDRksmooth(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, xp::ByPtr2{Float64}, yp::ByPtr2{Float64}, np::Int32, kernel::Int32, bw::Float64)

# Wrapper of void TGraphSmooth::BDRsmooth(Int_t, Double_t *, Double_t *, Double_t *, Double_t, Int_t, Double_t, Double_t *, Double_t *)
@trydoc raw"""
    TGraphSmooth!BDRsmooth(this::ByRef1{TGraphSmooth}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, w::ByPtr2{Float64}, span::Float64, iper::Int32, vsmlsq::Float64, smo::ByPtr2{Float64}, acvr::ByPtr2{Float64})::Nothing
Function for super smoother Based on R function supsmu: Translated to C++ by C.
Stratowa (R source file: ppr.f by B.D.Ripley Copyright (C) 1994-97)
""" TGraphSmooth!BDRsmooth(this::ByRef1{TGraphSmooth}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, w::ByPtr2{Float64}, span::Float64, iper::Int32, vsmlsq::Float64, smo::ByPtr2{Float64}, acvr::ByPtr2{Float64})

# Wrapper of void TGraphSmooth::BDRsupsmu(Int_t, Double_t *, Double_t *, Double_t *, Int_t, Double_t, Double_t, Double_t *, Double_t *)
@trydoc raw"""
    TGraphSmooth!BDRsupsmu(this::ByRef1{TGraphSmooth}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, w::ByPtr2{Float64}, iper::Int32, span::Float64, alpha::Float64, smo::ByPtr2{Float64}, sc::ByPtr2{Float64})::Nothing
Friedmanns super smoother (Friedman, 1984).
version 10/10/84 coded and copyright (c) 1984 by: 
```
                   Jerome H. Friedman
                department of statistics
                          and
           stanford linear accelerator center
                   stanford university
```  all rights reserved.

## Arguments

- **`n`** [in] 
    number of observations (x,y - pairs). 
    
- **`x`** [in] 
    ordered abscissa values. 
    
- **`y`** [in] 
    corresponding ordinate (response) values. 
    
- **`w`** [in] 
    weight for each (x,y) observation. 
    
- **`iper`** [in] 
    periodic variable flag.
    
    - iper=1 => x is ordered interval variable.
    - iper=2 => x is a periodic variable with values in the range (0.0,1.0) and period 1.0. 
    
    
- **`span`** [in] 
    smoother span (fraction of observations in window).
    
    - span=0.0 => automatic (variable) span selection. 
    
    
- **`alpha`** [in] 
    controls high frequency (small span) penality used with automatic span selection (bass tone control). (alpha.le.0.0 or alpha.gt.10.0 => no effect.) 
    
- **`smo`** [out] 
    smoothed ordinate (response) values. 
    
- **`sc`** 
    internal working storage.
    

note:

for small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. reasonable span values are 0.2 to 0.4.

current implementation:

Based on R function supsmu: Translated to C++ by C. Stratowa (R source file: ppr.f by B.D.Ripley Copyright (C) 1994-97)
""" TGraphSmooth!BDRsupsmu(this::ByRef1{TGraphSmooth}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, w::ByPtr2{Float64}, iper::Int32, span::Float64, alpha::Float64, smo::ByPtr2{Float64}, sc::ByPtr2{Float64})

# Wrapper of void TGraphSmooth::Lowest(Double_t *, Double_t *, Int_t, Double_t &, Double_t &, Int_t, Int_t, Double_t *, Bool_t, Double_t *, Bool_t &)
@trydoc raw"""
    TGraphSmooth!Lowest(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, xs::ByRef2{Float64}, ys::ByRef2{Float64}, nleft::Int32, nright::Int32, w::ByPtr2{Float64}, userw::Bool, rw::ByPtr2{Float64}, ok::ByRef2{Bool})::Nothing
Fit value at x[i] Based on R function lowest: Translated to C++ by C.
Stratowa (R source file: lowess.c by R Development Core Team (C) 1999-2001)
""" TGraphSmooth!Lowest(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, y::ByPtr2{Float64}, n::Int32, xs::ByRef2{Float64}, ys::ByRef2{Float64}, nleft::Int32, nright::Int32, w::ByPtr2{Float64}, userw::Bool, rw::ByPtr2{Float64}, ok::ByRef2{Bool})

# Wrapper of void TGraphSmooth::Psort(Double_t *, Int_t, Int_t)
@trydoc raw"""
    TGraphSmooth!Psort(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, n::Int32, k::Int32)::Nothing
Static function based on R function rPsort: adapted to C++ by Christian Stratowa (R source file: R_sort.c by R Development Core Team (C) 1999-2001)

""" TGraphSmooth!Psort(this::ByRef1{TGraphSmooth}, x::ByPtr2{Float64}, n::Int32, k::Int32)

# Wrapper of void TGraphSmooth::Rank(Int_t, Double_t *, Int_t *, Int_t *, Bool_t)
@trydoc raw"""
    TGraphSmooth!Rank(this::ByRef1{TGraphSmooth}, n::Int32, a::ByPtr2{Float64}, index::ByPtr2{Int32}, rank::ByPtr2{Int32}, down::Bool)::Nothing
static function

""" TGraphSmooth!Rank(this::ByRef1{TGraphSmooth}, n::Int32, a::ByPtr2{Float64}, index::ByPtr2{Int32}, rank::ByPtr2{Int32}, down::Bool)

# Wrapper of Int_t TGraphSmooth::Rcmp(Double_t, Double_t)
@trydoc raw"""
    TGraphSmooth!Rcmp(this::ByRef1{TGraphSmooth}, x::Float64, y::Float64)::Int32
Static function if (ISNAN(x)) return 1; if (ISNAN(y)) return -1;.

""" TGraphSmooth!Rcmp(this::ByRef1{TGraphSmooth}, x::Float64, y::Float64)

# Wrapper of Int_t TGraphTime::Add(const TObject *, Int_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TGraphTime}, obj::ByConstPtr1{TObject}, slot::Int32, option::ByCopy{String})::Int32
Add one object to a time slot.
[TGraphTime](@ref) becomes the owner of this object. object will be drawn with option
""" Add(this::ByRef1{TGraphTime}, obj::ByConstPtr1{TObject}, slot::Int32, option::ByCopy{String})

# Wrapper of void TGraphTime::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGraphTime}, chopt::ByCopy{String})::Nothing
Draw this [TGraphTime](@ref).
for each time step the list of objects added to this step are drawn.
""" Draw(this::ByRef1{TGraphTime}, chopt::ByCopy{String})

# Wrapper of TObjArray * TGraphTime::GetSteps()
@trydoc raw"""
    GetSteps(this::ByConstRef1{TGraphTime})::CxxPtr1{TObjArray}


""" GetSteps(this::ByConstRef1{TGraphTime})

# Wrapper of void TGraphTime::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGraphTime}, chopt::ByCopy{String})::Nothing
Paint all objects added to each time step.

""" Paint(this::ByRef1{TGraphTime}, chopt::ByCopy{String})

# Wrapper of void TGraphTime::SaveAnimatedGif(const char *)
@trydoc raw"""
    SaveAnimatedGif(this::ByConstRef1{TGraphTime}, filename::ByCopy{String})::Nothing
Save this object to filename as an animated gif file if filename is specified it must be of the form xxx.gif otherwise a file yyy.gif is produced where yyy is the object name.

""" SaveAnimatedGif(this::ByConstRef1{TGraphTime}, filename::ByCopy{String})

# Wrapper of void TGraphTime::SetSleepTime(Int_t)
@trydoc raw"""
    SetSleepTime(this::ByRef1{TGraphTime}, stime::Int32)::Nothing


""" SetSleepTime(this::ByRef1{TGraphTime}, stime::Int32)

# Wrapper of Int_t TVirtualHistPainter::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TVirtualHistPainter}, px::Int32, py::Int32)::Int32
Computes distance from point (px,py) to the object.
This member function must be implemented for each graphics primitive. This default function returns a big number (999999).
""" DistancetoPrimitive(this::ByRef1{TVirtualHistPainter}, px::Int32, py::Int32)

# Wrapper of void TVirtualHistPainter::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TVirtualHistPainter})::Nothing


""" DrawPanel(this::ByRef1{TVirtualHistPainter})

# Wrapper of void TVirtualHistPainter::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TVirtualHistPainter}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to an event at (px,py).
This method must be overridden if an object can react to graphics events.
""" ExecuteEvent(this::ByRef1{TVirtualHistPainter}, event::Int32, px::Int32, py::Int32)

# Wrapper of TList * TVirtualHistPainter::GetContourList(Double_t)
@trydoc raw"""
    GetContourList(this::ByConstRef1{TVirtualHistPainter}, contour::Float64)::CxxPtr1{TList}


""" GetContourList(this::ByConstRef1{TVirtualHistPainter}, contour::Float64)

# Wrapper of char * TVirtualHistPainter::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TVirtualHistPainter}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Returns string containing info about the object at position (px,py).
This method is typically overridden by classes of which the objects can report peculiarities for different positions. Returned string will be re-used (lock in MT environment).
""" GetObjectInfo(this::ByConstRef1{TVirtualHistPainter}, px::Int32, py::Int32)

# Wrapper of TList * TVirtualHistPainter::GetStack()
@trydoc raw"""
    GetStack(this::ByConstRef1{TVirtualHistPainter})::CxxPtr1{TList}


""" GetStack(this::ByConstRef1{TVirtualHistPainter})

# Wrapper of Bool_t TVirtualHistPainter::IsInside(Double_t, Double_t)
@trydoc raw"""
    IsInside(this::ByRef1{TVirtualHistPainter}, x::Float64, y::Float64)::Bool


""" IsInside(this::ByRef1{TVirtualHistPainter}, x::Float64, y::Float64)

# Wrapper of Bool_t TVirtualHistPainter::IsInside(Int_t, Int_t)
@trydoc raw"""
    IsInside(this::ByRef1{TVirtualHistPainter}, x::Int32, y::Int32)::Bool


""" IsInside(this::ByRef1{TVirtualHistPainter}, x::Int32, y::Int32)

# Wrapper of Int_t TVirtualHistPainter::MakeCuts(char *)
@trydoc raw"""
    MakeCuts(this::ByRef1{TVirtualHistPainter}, cutsopt::ByPtr2{Int8})::Int32


""" MakeCuts(this::ByRef1{TVirtualHistPainter}, cutsopt::ByPtr2{Int8})

# Wrapper of void TVirtualHistPainter::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String})

# Wrapper of void TVirtualHistPainter::PaintStat(Int_t, TF1 *)
@trydoc raw"""
    PaintStat(this::ByRef1{TVirtualHistPainter}, dostat::Int32, fit::ByPtr1{TF1})::Nothing


""" PaintStat(this::ByRef1{TVirtualHistPainter}, dostat::Int32, fit::ByPtr1{TF1})

# Wrapper of void TVirtualHistPainter::ProcessMessage(const char *, const TObject *)
@trydoc raw"""
    ProcessMessage(this::ByRef1{TVirtualHistPainter}, mess::ByCopy{String}, obj::ByConstPtr1{TObject})::Nothing


""" ProcessMessage(this::ByRef1{TVirtualHistPainter}, mess::ByCopy{String}, obj::ByConstPtr1{TObject})

# Wrapper of void TVirtualHistPainter::SetHighlight()
@trydoc raw"""
    SetHighlight(this::ByRef1{TVirtualHistPainter})::Nothing


""" SetHighlight(this::ByRef1{TVirtualHistPainter})

# Wrapper of void TVirtualHistPainter::SetHistogram(TH1 *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TVirtualHistPainter}, h::ByPtr1{TH1})::Nothing


""" SetHistogram(this::ByRef1{TVirtualHistPainter}, h::ByPtr1{TH1})

# Wrapper of void TVirtualHistPainter::SetShowProjection(const char *, Int_t)
@trydoc raw"""
    SetShowProjection(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbins::Int32)::Nothing


""" SetShowProjection(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbins::Int32)

# Wrapper of void TVirtualHistPainter::SetShowProjectionXY(const char *, Int_t, Int_t)
@trydoc raw"""
    SetShowProjectionXY(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbinsY::Int32, nbinsX::Int32)::Nothing


""" SetShowProjectionXY(this::ByRef1{TVirtualHistPainter}, option::ByCopy{String}, nbinsY::Int32, nbinsX::Int32)

# Wrapper of void TVirtualHistPainter::SetStack(TList *)
@trydoc raw"""
    SetStack(this::ByRef1{TVirtualHistPainter}, stack::ByPtr1{TList})::Nothing


""" SetStack(this::ByRef1{TVirtualHistPainter}, stack::ByPtr1{TList})

# Wrapper of TVirtualHistPainter * TVirtualHistPainter::HistPainter(TH1 *)
@trydoc raw"""
    TVirtualHistPainter!HistPainter(this::ByRef1{TVirtualHistPainter}, obj::ByPtr1{TH1})::CxxPtr1{TVirtualHistPainter}
Static function returning a pointer to the current histogram painter.
The painter will paint the specified obj. If the histogram painter does not exist a default painter is created.
""" TVirtualHistPainter!HistPainter(this::ByRef1{TVirtualHistPainter}, obj::ByPtr1{TH1})

# Wrapper of void TVirtualHistPainter::SetPainter(const char *)
@trydoc raw"""
    TVirtualHistPainter!SetPainter(this::ByRef1{TVirtualHistPainter}, painter::ByCopy{String})::Nothing
Static function to set an alternative histogram painter.

""" TVirtualHistPainter!SetPainter(this::ByRef1{TVirtualHistPainter}, painter::ByCopy{String})

# Wrapper of void TH1C::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1C}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1C}, bin::Int32)

# Wrapper of void TH1C::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1C}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1C}, bin::Int32, w::Float64)

# Wrapper of void TH1C::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1C}, hnew::ByRef1{TObject})::Nothing
Copy this to newth1.

""" Copy(this::ByConstRef1{TH1C}, hnew::ByRef1{TObject})

# Wrapper of TH1C & TH1C::operator=(const TH1C &)
@trydoc raw"""
    assign(this::ByRef1{TH1C}, h1::ByConstRef1{TH1C})::CxxRef1{TH1C}
Operator =.

""" assign(this::ByRef1{TH1C}, h1::ByConstRef1{TH1C})

# Wrapper of void TH1C::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1C}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1C}, option::ByCopy{String})

# Wrapper of void TH1C::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1C}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1C}, n::Int32)

# Wrapper of void TH1S::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1S}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1S}, bin::Int32)

# Wrapper of void TH1S::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1S}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Int_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1S}, bin::Int32, w::Float64)

# Wrapper of void TH1S::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1S}, hnew::ByRef1{TObject})::Nothing
Copy this to newth1.

""" Copy(this::ByConstRef1{TH1S}, hnew::ByRef1{TObject})

# Wrapper of TH1S & TH1S::operator=(const TH1S &)
@trydoc raw"""
    assign(this::ByRef1{TH1S}, h1::ByConstRef1{TH1S})::CxxRef1{TH1S}
Operator =.

""" assign(this::ByRef1{TH1S}, h1::ByConstRef1{TH1S})

# Wrapper of void TH1S::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1S}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1S}, option::ByCopy{String})

# Wrapper of void TH1S::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1S}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1S}, n::Int32)

# Wrapper of void TH1I::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1I}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1I}, bin::Int32)

# Wrapper of void TH1I::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1I}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1I}, bin::Int32, w::Float64)

# Wrapper of void TH1I::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1I}, hnew::ByRef1{TObject})::Nothing
Copy this to newth1.

""" Copy(this::ByConstRef1{TH1I}, hnew::ByRef1{TObject})

# Wrapper of TH1I & TH1I::operator=(const TH1I &)
@trydoc raw"""
    assign(this::ByRef1{TH1I}, h1::ByConstRef1{TH1I})::CxxRef1{TH1I}
Operator =.

""" assign(this::ByRef1{TH1I}, h1::ByConstRef1{TH1I})

# Wrapper of void TH1I::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1I}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1I}, option::ByCopy{String})

# Wrapper of void TH1I::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1I}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1I}, n::Int32)

# Wrapper of void TH1L::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1L}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1L}, bin::Int32)

# Wrapper of void TH1L::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1L}, bin::Int32, w::Float64)::Nothing
Increment bin content by w.
###Warning

The value of w is cast to Long64_t before being added. Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1L}, bin::Int32, w::Float64)

# Wrapper of void TH1L::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1L}, hnew::ByRef1{TObject})::Nothing
Copy this to newth1.

""" Copy(this::ByConstRef1{TH1L}, hnew::ByRef1{TObject})

# Wrapper of TH1L & TH1L::operator=(const TH1L &)
@trydoc raw"""
    assign(this::ByRef1{TH1L}, h1::ByConstRef1{TH1L})::CxxRef1{TH1L}
Operator =.

""" assign(this::ByRef1{TH1L}, h1::ByConstRef1{TH1L})

# Wrapper of void TH1L::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1L}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1L}, option::ByCopy{String})

# Wrapper of void TH1L::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1L}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1L}, n::Int32)

# Wrapper of void TH1D::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1D}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH1D}, bin::Int32)

# Wrapper of void TH1D::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH1D}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w Passing an out-of-range bin leads to undefined behavior.

""" AddBinContent(this::ByRef1{TH1D}, bin::Int32, w::Float64)

# Wrapper of void TH1D::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1D}, hnew::ByRef1{TObject})::Nothing
Copy this to newth1.

""" Copy(this::ByConstRef1{TH1D}, hnew::ByRef1{TObject})

# Wrapper of TH1D & TH1D::operator=(const TH1D &)
@trydoc raw"""
    assign(this::ByRef1{TH1D}, h1::ByConstRef1{TH1D})::CxxRef1{TH1D}
Operator =.

""" assign(this::ByRef1{TH1D}, h1::ByConstRef1{TH1D})

# Wrapper of void TH1D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1D}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1D}, option::ByCopy{String})

# Wrapper of void TH1D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH1D}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH1D}, n::Int32)

# Wrapper of void TH1K::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH1K}, obj::ByRef1{TObject})::Nothing
Copy this histogram structure to newth1.
Note that this function does not copy the list of associated functions. Use [TObject!Clone](@ref) to make a full copy of an histogram.
""" Copy(this::ByConstRef1{TH1K}, obj::ByRef1{TObject})

# Wrapper of Int_t TH1K::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1K}, name::ByCopy{String}, w::Float64)::Int32
Increment bin with namex with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w.
""" Fill(this::ByRef1{TH1K}, name::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH1K::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1K}, x::Float64)::Int32
Increment bin with abscissa X by 1.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is greater than the upper edge of last bin, the Overflow bin is incremented

If the storage of the sum of squares of weights has been triggered, via the function Sumw2, then the sum of the squares of weights is incremented by 1 in the bin corresponding to x.
""" Fill(this::ByRef1{TH1K}, x::Float64)

# Wrapper of Int_t TH1K::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH1K}, x::Float64, w::Float64)::Int32
Increment bin with abscissa X with a weight w.
if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented

If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by $ w^2 $ in the bin corresponding to x.

The function returns the corresponding bin number which has its content incremented by w
""" Fill(this::ByRef1{TH1K}, x::Float64, w::Float64)

# Wrapper of Double_t TH1K::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH1K}, bin::Int32)::Float64
Return content of global_ bin number bin.

""" GetBinContent(this::ByConstRef1{TH1K}, bin::Int32)

# Wrapper of Double_t TH1K::GetBinContent(Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH1K}, bin::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH1K}, bin::Int32, ::Int32)

# Wrapper of Double_t TH1K::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH1K}, bin::Int32, ::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH1K}, bin::Int32, ::Int32, ::Int32)

# Wrapper of Double_t TH1K::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH1K}, bin::Int32)::Float64
Return content of global_ bin error.

""" GetBinError(this::ByConstRef1{TH1K}, bin::Int32)

# Wrapper of Double_t TH1K::GetBinError(Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH1K}, bin::Int32, ::Int32)::Float64


""" GetBinError(this::ByConstRef1{TH1K}, bin::Int32, ::Int32)

# Wrapper of Double_t TH1K::GetBinError(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH1K}, bin::Int32, ::Int32, ::Int32)::Float64


""" GetBinError(this::ByConstRef1{TH1K}, bin::Int32, ::Int32, ::Int32)

# Wrapper of void TH1K::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH1K}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TH1K}, option::ByCopy{String})

# Wrapper of void TH1K::SetKOrd(Int_t)
@trydoc raw"""
    SetKOrd(this::ByRef1{TH1K}, k::Int32)::Nothing


""" SetKOrd(this::ByRef1{TH1K}, k::Int32)

# Wrapper of Bool_t TProfile::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this profile by the addition of h1 and h2.
`this = c1*h1 + c2*h2`

c1 and c2 are considered as weights applied to the two summed profiles. The operation acts therefore like merging the two profiles with a weight c1 and c2
""" Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TProfile::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: this = this + c1*h1.

""" Add(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TProfile::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: this = this + c1*f1.

""" Add(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TProfile::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TProfile}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TProfile}, action::Int32)

# Wrapper of void TProfile::BuildOptions(Double_t, Double_t, Option_t *)
@trydoc raw"""
    BuildOptions(this::ByRef1{TProfile}, ymin::Float64, ymax::Float64, option::ByCopy{String})::Nothing
Set Profile histogram structure and options.
## Arguments

- **`ymin`** [in] 
    minimum value allowed for y 
    
- **`ymax`** [in] 
    maximum value allowed for y if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf) 
    
- **`option`** [in] 
    this is the option for the computation of the y error of the profile ( [TProfile!GetBinError](@ref) ) possible values for the options are:
    
    - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N) where S(Y) is the standard deviation (RMS) of the Y data in the bin and N is the number of bin entries (from TProfile!GetBinEntries(ibin) ) (i.e the errors are the standard error on the bin content of the profile)
    - 's' Errors are the standard deviation of Y, S(Y)
    - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default) The only difference is only when the standard deviation in Y is zero. In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is 1./SQRT(12*N). This approximation assumes that the Y values are integer (e.g. ADC counts) and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12)
    - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j W is obtained as from TProfile!GetBinEntries(ibin) This errors corresponds to the standard deviation of weighted mean where each measurement Y is uncorrelated and has an error sigma, which is expressed in the weight used to fill the Profile: w = 1/sigma^2 The resulting error in [TProfile](@ref) is then 1./SQRT( Sum(1./sigma^2) )
    
    

In the case of Profile filled weights and with [TProfile!Sumw2()](@ref) called, STD(Y) is the standard deviation of the weighted sample Y and N is in this case the number of effective entries (TProfile!GetBinEffectiveEntries(ibin) )

If a bin has N data points all with the same value Y (especially possible when dealing with integers), the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. To avoid this problem one can use an approximation for the standard deviation S(Y), by using the average of all the S(Y) of the other Profile bins. To use this approximation one must call before [TProfile!Approximate](@ref) This approximation applies only for the default and the 's' options
""" BuildOptions(this::ByRef1{TProfile}, ymin::Float64, ymax::Float64, option::ByCopy{String})

# Wrapper of void TProfile::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TProfile}, hnew::ByRef1{TObject})::Nothing
Copy a Profile histogram to a new profile histogram.

""" Copy(this::ByConstRef1{TProfile}, hnew::ByRef1{TObject})

# Wrapper of Bool_t TProfile::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})::Bool
Divide this profile by h1.
`this = this/h1`

This function accepts to divide a [TProfile](@ref) by a histogram

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

The function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)`.
This function is not implemented for the [TProfile](@ref)
""" Divide(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TProfile::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TProfile}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Profile histogram is resized along x axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The axis must be extendable before invoking this function.

Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`
""" ExtendAxis(this::ByRef1{TProfile}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of Int_t TProfile::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64)::Int32
Fill a Profile histogram (no weights).

""" Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64)

# Wrapper of Int_t TProfile::Fill(const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64, w::Float64)::Int32
Fill a Profile histogram with weights.

""" Fill(this::ByRef1{TProfile}, namex::ByCopy{String}, y::Float64, w::Float64)

# Wrapper of Int_t TProfile::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, x::Float64, y::Float64)::Int32
Fill a Profile histogram (no weights).

""" Fill(this::ByRef1{TProfile}, x::Float64, y::Float64)

# Wrapper of Int_t TProfile::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile}, x::Float64, y::Float64, w::Float64)::Int32
Fill a Profile histogram with weights.

""" Fill(this::ByRef1{TProfile}, x::Float64, y::Float64, w::Float64)

# Wrapper of void TProfile::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TProfile}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fill a Profile histogram with weights.

""" FillN(this::ByRef1{TProfile}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of Double_t TProfile::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile}, bin::Int32)::Float64
Return bin content of a Profile histogram.

""" GetBinContent(this::ByConstRef1{TProfile}, bin::Int32)

# Wrapper of Double_t TProfile::GetBinContent(Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile}, bin::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TProfile}, bin::Int32, ::Int32)

# Wrapper of Double_t TProfile::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile}, bin::Int32, ::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TProfile}, bin::Int32, ::Int32, ::Int32)

# Wrapper of Double_t TProfile::GetBinEffectiveEntries(Int_t)
@trydoc raw"""
    GetBinEffectiveEntries(this::ByConstRef1{TProfile}, bin::Int32)::Float64
Return bin effective entries for a weighted filled Profile histogram.
In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. [TProfile!Sumw2()](@ref) must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored.
""" GetBinEffectiveEntries(this::ByConstRef1{TProfile}, bin::Int32)

# Wrapper of Double_t TProfile::GetBinEntries(Int_t)
@trydoc raw"""
    GetBinEntries(this::ByConstRef1{TProfile}, bin::Int32)::Float64
Return bin entries of a Profile histogram.

""" GetBinEntries(this::ByConstRef1{TProfile}, bin::Int32)

# Wrapper of Double_t TProfile::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile}, bin::Int32)::Float64
Return bin error of a Profile histogram.
Computing errors: A moving field

The computation of errors for a [TProfile](@ref) has evolved with the versions of [ROOT](@ref). The difficulty is in computing errors for bins with low statistics.

- prior to version 3.00, we had no special treatment of low statistic bins. As a result, these bins had huge errors. The reason is that the expression eprim2 is very close to 0 (rounding problems) or 0.
- in version 3.00 (18 Dec 2000), the algorithm is protected for values of eprim2 very small and the bin errors set to the average bin errors, following recommendations from a group of users.
- in version 3.01 (19 Apr 2001), it is realized that the algorithm above should be applied only to low statistic bins.
- in version 3.02 (26 Sep 2001), the same group of users recommend instead to take two times the average error on all bins for these low statistics bins giving a very small value for eprim2.
- in version 3.04 (Nov 2002), the algorithm is modified/protected for the case when a [TProfile](@ref) is projected (ProjectionX). The previous algorithm generated a N^2 problem when projecting a [TProfile](@ref) with a large number of bins (eg 100000).
- in version 3.05/06, a new static function [TProfile!Approximate](@ref) is introduced to enable or disable (default) the approximation.

Ideas for improvements of this algorithm are welcome. No suggestions received since our call for advice to roottalk in Jul 2002. see for instance: [http://root.cern/root/roottalk/roottalk02/2916.html](http://root.cern/root/roottalk/roottalk02/2916.html)
""" GetBinError(this::ByConstRef1{TProfile}, bin::Int32)

# Wrapper of Double_t TProfile::GetBinError(Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile}, bin::Int32, ::Int32)::Float64


""" GetBinError(this::ByConstRef1{TProfile}, bin::Int32, ::Int32)

# Wrapper of Double_t TProfile::GetBinError(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile}, bin::Int32, ::Int32, ::Int32)::Float64


""" GetBinError(this::ByConstRef1{TProfile}, bin::Int32, ::Int32, ::Int32)

# Wrapper of TArrayD * TProfile::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByRef1{TProfile})::CxxPtr1{TArrayD}


""" GetBinSumw2(this::ByRef1{TProfile})

# Wrapper of const TArrayD * TProfile::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByConstRef1{TProfile})::ConstCxxPtr1{TArrayD}


""" GetBinSumw2(this::ByConstRef1{TProfile})

# Wrapper of Option_t * TProfile::GetErrorOption()
@trydoc raw"""
    GetErrorOption(this::ByConstRef1{TProfile})::ByCopy{String}
Return option to compute profile errors.

""" GetErrorOption(this::ByConstRef1{TProfile})

# Wrapper of void TProfile::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TProfile}, stats::ByPtr2{Float64})::Nothing
fill the array stats from the contents of this profile.
The array stats must be correctly dimensioned in the calling program.

- stats[0] = sumw
- stats[1] = sumw2
- stats[2] = sumwx
- stats[3] = sumwx2
- stats[4] = sumwy
- stats[5] = sumwy2

If no axis-subrange is specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.
""" GetStats(this::ByConstRef1{TProfile}, stats::ByPtr2{Float64})

# Wrapper of Double_t TProfile::GetYmax()
@trydoc raw"""
    GetYmax(this::ByConstRef1{TProfile})::Float64


""" GetYmax(this::ByConstRef1{TProfile})

# Wrapper of Double_t TProfile::GetYmin()
@trydoc raw"""
    GetYmin(this::ByConstRef1{TProfile})::Float64


""" GetYmin(this::ByConstRef1{TProfile})

# Wrapper of void TProfile::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TProfile}, axis::ByCopy{String})::Nothing
Reduce the number of bins for this axis to the number of bins having a label.

""" LabelsDeflate(this::ByRef1{TProfile}, axis::ByCopy{String})

# Wrapper of void TProfile::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TProfile}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TProfile}, axis::ByCopy{String})

# Wrapper of void TProfile::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TProfile}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Set option(s) to draw axis with labels.
option might have the following values:

- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TProfile}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TProfile::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile}, list::ByPtr1{TCollection})::Int64
Merge all histograms in the collection in this histogram.
This function computes the min/max for the x axis, compute a new number of bins, if necessary, add bin contents, errors and statistics. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

IMPORTANT remark. The axis x may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width.
""" Merge(this::ByRef1{TProfile}, list::ByPtr1{TCollection})

# Wrapper of Bool_t TProfile::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})::Bool
Multiply this profile by h1.
`this = this*h1`
""" Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`
""" Multiply(this::ByRef1{TProfile}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: this = this*c1*f1.
The function return kFALSE if the Multiply operation failed
""" Multiply(this::ByRef1{TProfile}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of TProfile & TProfile::operator=(const TProfile &)
@trydoc raw"""
    assign(this::ByRef1{TProfile}, profile::ByConstRef1{TProfile})::CxxRef1{TProfile}


""" assign(this::ByRef1{TProfile}, profile::ByConstRef1{TProfile})

# Wrapper of TH1D * TProfile::ProjectionX(const char *, Option_t *)
@trydoc raw"""
    ProjectionX(this::ByConstRef1{TProfile}, name::ByCopy{String}, option::ByCopy{String})::CxxPtr1{TH1D}
Project this profile into a 1-D histogram along X.
The projection is always of the type [TH1D](@ref).

- if option "E" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option "E" is defined as the default one in the header file.
- if option "" is specified the histogram errors are simply the sqrt of its content
- if option "B" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile, otherwise (default) it will be equal to GetBinContent(bin)
- if option "C=E" the bin contents of the projection are set to the bin errors of the profile
- if option "W" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a [TH1D](@ref) using the 2-nd value as a weight. This makes sense only for profile filled with weights =1. If not, the error of the projected histogram obtained with this option will not be correct.
""" ProjectionX(this::ByConstRef1{TProfile}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TProfile::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TProfile}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TProfile}, stats::ByPtr2{Float64})

# Wrapper of TH1 * TProfile::Rebin(Int_t, const char *, const Double_t *)
@trydoc raw"""
    Rebin(this::ByRef1{TProfile}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})::CxxPtr1{TH1}
Rebin this profile grouping ngroup bins together.
## case 1  xbins=0

if newname is not blank a new temporary profile hnew is created. else the current profile is modified (default) The parameter ngroup indicates how many bins of this have to me merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.

examples: if hp is an existing [TProfile](@ref) histogram with 100 bins

    hp->Rebin();  //merges two bins in one in hp: previous contents of hp are lost
    hp->Rebin(5); //merges five bins in one in hp
    TProfile *hnew = hp->Rebin(5,"hnew"); // creates a new profile hnew
                                      //merging 5 bins of hp in one bin

(C++ version of the code)

NOTE: If ngroup is not an exact divider of the number of bins, the top limit of the rebinned profile is changed to the upper edge of the bin=newbins*ngroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.

## case 2  xbins!=0

a new profile is created (you should specify newname). The parameter ngroup is the number of variable size bins in the created profile The array xbins must contain ngroup+1 elements that represent the low-edge of the bins. The data of the old bins are added to the new bin which contains the bin center of the old bins. It is possible that information from the old binning are attached to the under-/overflow bins of the new binning.

examples: if hp is an existing [TProfile](@ref) with 100 bins

    Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin
    hp->Rebin(24,"hpnew",xbins);  //creates a new variable bin size profile hpnew

(C++ version of the code)
""" Rebin(this::ByRef1{TProfile}, ngroup::Int32, newname::ByCopy{String}, xbins::ByConstPtr2{Float64})

# Wrapper of void TProfile::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile}, option::ByCopy{String})::Nothing
Reset contents of a Profile histogram.

""" Reset(this::ByRef1{TProfile}, option::ByCopy{String})

# Wrapper of void TProfile::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TProfile}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this profile by a constant c1.
`this = c1*this`

This function uses the services of [TProfile!Add](@ref)
""" Scale(this::ByRef1{TProfile}, c1::Float64, option::ByCopy{String})

# Wrapper of void TProfile::SetBinEntries(Int_t, Double_t)
@trydoc raw"""
    SetBinEntries(this::ByRef1{TProfile}, bin::Int32, w::Float64)::Nothing
Set the number of entries in bin.

""" SetBinEntries(this::ByRef1{TProfile}, bin::Int32, w::Float64)

# Wrapper of void TProfile::SetBins(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile}, nbins::Int32, xmin::Float64, xmax::Float64)::Nothing
Redefine x axis parameters.

""" SetBins(this::ByRef1{TProfile}, nbins::Int32, xmin::Float64, xmax::Float64)

# Wrapper of void TProfile::SetBins(Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile}, nx::Int32, xbins::ByConstPtr2{Float64})::Nothing
Redefine x axis parameters.

""" SetBins(this::ByRef1{TProfile}, nx::Int32, xbins::ByConstPtr2{Float64})

# Wrapper of void TProfile::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TProfile}, n::Int32)::Nothing
Set total number of bins including under/overflow.
Reallocate bin contents array
""" SetBinsLength(this::ByRef1{TProfile}, n::Int32)

# Wrapper of void TProfile::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TProfile}, buffersize::Int32, option::ByCopy{String})::Nothing
Set the buffer size in units of 8 bytes (double).

""" SetBuffer(this::ByRef1{TProfile}, buffersize::Int32, option::ByCopy{String})

# Wrapper of void TProfile::SetErrorOption(Option_t *)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile}, option::ByCopy{String})::Nothing
Set option to compute profile errors.
The computation of the bin errors is based on the parameter option:

-' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y), i.e. the standard error of the bin contents. Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Y is 0 and the number of bin entries is > 0 -'s' The bin errors are the standard deviations of the Y bin values Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Y is 0 and the number of bin entries is > 0 -'i' Errors are as in default case (standard errors of the bin contents) The only difference is for the case when the spread in Y is zero. In this case for N > 0 the error is 1./SQRT(12.*N) -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0. W is the sum in the bin of the weights of the profile. This option is for combining measurements y +/- dy, and the profile is filled with values y and weights w = 1/dy**2

See [TProfile!BuildOptions](@ref) for a detailed explanation of all options
""" SetErrorOption(this::ByRef1{TProfile}, option::ByCopy{String})

# Wrapper of void TProfile::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TProfile}, flag::Bool)::Nothing
Create/delete structure to store sum of squares of weights per bin.
This is needed to compute the correct statistical quantities of a profile filled with weights

This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag is false the structure is deleted
""" Sumw2(this::ByRef1{TProfile}, flag::Bool)

# Wrapper of void TProfile::Approximate(Bool_t)
@trydoc raw"""
    TProfile!Approximate(this::ByRef1{TProfile}, approx::Bool)::Nothing
Static function to set the fgApproximate flag.
When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only

- the number of bins in the profile is less than 1002
- the bin number of entries is small ( <5)
- the estimated bin error is extremely small compared to the bin content (see [TProfile!GetBinError](@ref))
""" TProfile!Approximate(this::ByRef1{TProfile}, approx::Bool)

# Wrapper of void TH2C::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, bin::Int32)

# Wrapper of void TH2C::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, bin::Int32, w::Float64)

# Wrapper of void TH2C::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32)

# Wrapper of void TH2C::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2C}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of void TH2C::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2C}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2C}, hnew::ByRef1{TObject})

# Wrapper of TH2C & TH2C::operator=(const TH2C &)
@trydoc raw"""
    assign(this::ByRef1{TH2C}, h1::ByConstRef1{TH2C})::CxxRef1{TH2C}
Operator =.

""" assign(this::ByRef1{TH2C}, h1::ByConstRef1{TH2C})

# Wrapper of void TH2C::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2C}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2C}, option::ByCopy{String})

# Wrapper of void TH2C::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2C}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2C}, n::Int32)

# Wrapper of void TH2S::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, bin::Int32)

# Wrapper of void TH2S::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, bin::Int32, w::Float64)

# Wrapper of void TH2S::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32)

# Wrapper of void TH2S::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2S}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of void TH2S::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2S}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2S}, hnew::ByRef1{TObject})

# Wrapper of TH2S & TH2S::operator=(const TH2S &)
@trydoc raw"""
    assign(this::ByRef1{TH2S}, h1::ByConstRef1{TH2S})::CxxRef1{TH2S}
Operator =.

""" assign(this::ByRef1{TH2S}, h1::ByConstRef1{TH2S})

# Wrapper of void TH2S::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2S}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2S}, option::ByCopy{String})

# Wrapper of void TH2S::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2S}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2S}, n::Int32)

# Wrapper of void TH2I::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, bin::Int32)

# Wrapper of void TH2I::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, bin::Int32, w::Float64)

# Wrapper of void TH2I::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32)

# Wrapper of void TH2I::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2I}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of void TH2I::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2I}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2I}, hnew::ByRef1{TObject})

# Wrapper of TH2I & TH2I::operator=(const TH2I &)
@trydoc raw"""
    assign(this::ByRef1{TH2I}, h1::ByConstRef1{TH2I})::CxxRef1{TH2I}
Operator =.

""" assign(this::ByRef1{TH2I}, h1::ByConstRef1{TH2I})

# Wrapper of void TH2I::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2I}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2I}, option::ByCopy{String})

# Wrapper of void TH2I::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2I}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2I}, n::Int32)

# Wrapper of void TH2L::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, bin::Int32)

# Wrapper of void TH2L::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, bin::Int32, w::Float64)

# Wrapper of void TH2L::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32)

# Wrapper of void TH2L::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2L}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of void TH2L::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2L}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2L}, hnew::ByRef1{TObject})

# Wrapper of TH2L & TH2L::operator=(const TH2L &)
@trydoc raw"""
    assign(this::ByRef1{TH2L}, h1::ByConstRef1{TH2L})::CxxRef1{TH2L}
Operator =.

""" assign(this::ByRef1{TH2L}, h1::ByConstRef1{TH2L})

# Wrapper of void TH2L::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2L}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2L}, option::ByCopy{String})

# Wrapper of void TH2L::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2L}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2L}, n::Int32)

# Wrapper of void TH2F::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, bin::Int32)

# Wrapper of void TH2F::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, bin::Int32, w::Float64)

# Wrapper of void TH2F::AddBinContent(Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32)::Nothing
Increment 2D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32)

# Wrapper of void TH2F::AddBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32, w::Float64)::Nothing
Increment 2D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH2F}, binx::Int32, biny::Int32, w::Float64)

# Wrapper of void TH2F::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2F}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH2F}, hnew::ByRef1{TObject})

# Wrapper of TH2F & TH2F::operator=(const TH2F &)
@trydoc raw"""
    assign(this::ByRef1{TH2F}, h1::ByConstRef1{TH2F})::CxxRef1{TH2F}
Operator =.

""" assign(this::ByRef1{TH2F}, h1::ByConstRef1{TH2F})

# Wrapper of void TH2F::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2F}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2F}, option::ByCopy{String})

# Wrapper of void TH2F::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH2F}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH2F}, n::Int32)

# Wrapper of Bool_t TH2Poly::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TH2Poly::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: this = this + c1*h1.

""" Add(this::ByRef1{TH2Poly}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TH2Poly::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TH2Poly}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Add(this::ByRef1{TH2Poly}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TH2Poly::AddBin(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    AddBin(this::ByRef1{TH2Poly}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Int32
Add a new bin to the histogram.
The bin shape is a rectangle. It returns the bin number of the bin in the histogram.
""" AddBin(this::ByRef1{TH2Poly}, x1::Float64, y1::Float64, x2::Float64, y2::Float64)

# Wrapper of Int_t TH2Poly::AddBin(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    AddBin(this::ByRef1{TH2Poly}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})::Int32
Adds a new bin to the histogram.
The number of vertices and their (x,y) coordinates are required as input. It returns the bin number in the histogram.
""" AddBin(this::ByRef1{TH2Poly}, n::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64})

# Wrapper of Int_t TH2Poly::AddBin(TObject *)
@trydoc raw"""
    AddBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})::Int32
Adds a new bin to the histogram.
It can be any object having the method [IsInside()](@ref). It returns the bin number in the histogram. It returns 0 if it failed to add. To allow the histogram limits to expand when a bin outside the limits is added, call [SetFloat()](@ref) before adding the bin.
""" AddBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})

# Wrapper of void TH2Poly::ChangePartition(Int_t, Int_t)
@trydoc raw"""
    ChangePartition(this::ByRef1{TH2Poly}, n::Int32, m::Int32)::Nothing
Changes the number of partition cells in the histogram.
Deletes the old partition and constructs a new one.
""" ChangePartition(this::ByRef1{TH2Poly}, n::Int32, m::Int32)

# Wrapper of void TH2Poly::ClearBinContents()
@trydoc raw"""
    ClearBinContents(this::ByRef1{TH2Poly})::Nothing
Clears the contents of all bins in the histogram.

""" ClearBinContents(this::ByRef1{TH2Poly})

# Wrapper of Double_t TH2Poly::ComputeIntegral(Bool_t)
@trydoc raw"""
    ComputeIntegral(this::ByRef1{TH2Poly}, ::Bool)::Float64
NOT IMPLEMENTED for [TH2Poly](@ref).

""" ComputeIntegral(this::ByRef1{TH2Poly}, ::Bool)

# Wrapper of void TH2Poly::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH2Poly}, newth2p::ByRef1{TObject})::Nothing
Copy function for [TH2Poly](@ref).

""" Copy(this::ByConstRef1{TH2Poly}, newth2p::ByRef1{TObject})

# Wrapper of TH2PolyBin * TH2Poly::CreateBin(TObject *)
@trydoc raw"""
    CreateBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})::CxxPtr1{TH2PolyBin}
Create appropriate histogram bin.
e.g. [TH2Poly](@ref) creates [TH2PolyBin](@ref), [TProfile2Poly](@ref) creates [TProfile2PolyBin](@ref) This is done so that [TH2Poly!AddBin](@ref) does not have to be duplicated, but only create needs to be reimplemented for additional histogram types
""" CreateBin(this::ByRef1{TH2Poly}, poly::ByPtr1{TObject})

# Wrapper of Bool_t TH2Poly::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Divide(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)

# Wrapper of TH1 * TH2Poly::FFT(TH1 *, Option_t *)
@trydoc raw"""
    FFT(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::ByCopy{String})::CxxPtr1{TH1}
NOT IMPLEMENTED for [TH2Poly](@ref).

""" FFT(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::ByCopy{String})

# Wrapper of Int_t TH2Poly::Fill(const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2Poly}, name::ByCopy{String}, w::Float64)::Int32
Increment the bin named "name" by w.

""" Fill(this::ByRef1{TH2Poly}, name::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH2Poly::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64)::Int32
Increment the bin containing (x,y) by 1.
Uses the partitioning algorithm.
""" Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64)

# Wrapper of Int_t TH2Poly::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64, w::Float64)::Int32
Increment the bin containing (x,y) by w.
Uses the partitioning algorithm.
""" Fill(this::ByRef1{TH2Poly}, x::Float64, y::Float64, w::Float64)

# Wrapper of void TH2Poly::FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)
@trydoc raw"""
    FillN(this::ByRef1{TH2Poly}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)::Nothing
Fills a 2-D histogram with an array of values and weights.
## Arguments

- **`ntimes`** [in] 
    number of entries in arrays x and w (array size must be ntimes*stride) 
    
- **`x`** [in] 
    array of x values to be histogrammed 
    
- **`y`** [in] 
    array of y values to be histogrammed 
    
- **`w`** [in] 
    array of weights 
    
- **`stride`** [in] 
    step size through arrays x, y and w
""" FillN(this::ByRef1{TH2Poly}, ntimes::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, w::ByConstPtr2{Float64}, stride::Int32)

# Wrapper of Int_t TH2Poly::FindBin(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindBin(this::ByRef1{TH2Poly}, x::Float64, y::Float64, z::Float64)::Int32
Returns the bin number of the bin at the given coordinate.
-1 to -9 are the overflow and underflow bins. overflow bin -5 is the unbinned areas in the histogram (also called "the sea"). The third parameter can be left blank. The overflow/underflow bins are: 

    -1 | -2 | -3
    -------------
    -4 | -5 | -6
    -------------
    -7 | -8 | -9

(C++ version of the code)

 where -5 means is the "sea" bin (i.e. unbinned areas)
""" FindBin(this::ByRef1{TH2Poly}, x::Float64, y::Float64, z::Float64)

# Wrapper of TH1 * TH2Poly::GetAsymmetry(TH1 *, Double_t, Double_t)
@trydoc raw"""
    GetAsymmetry(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::Float64, ::Float64)::CxxPtr1{TH1}
NOT IMPLEMENTED for [TH2Poly](@ref).

""" GetAsymmetry(this::ByRef1{TH2Poly}, ::ByPtr1{TH1}, ::Float64, ::Float64)

# Wrapper of Double_t TH2Poly::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH2Poly}, bin::Int32)::Float64
Returns the content of the input bin Bin numbers are from [1,nbins] and for the overflow/underflow/sea bins the range is [-9,-1]:
-1 | -2 | -3
    ---+----+----
    -4 | -5 | -6
    ---+----+----
    -7 | -8 | -9

(C++ version of the code)

 where -5 is the "sea" bin (i.e. unbinned areas)
""" GetBinContent(this::ByConstRef1{TH2Poly}, bin::Int32)

# Wrapper of Bool_t TH2Poly::GetBinContentChanged()
@trydoc raw"""
    GetBinContentChanged(this::ByConstRef1{TH2Poly})::Bool


""" GetBinContentChanged(this::ByConstRef1{TH2Poly})

# Wrapper of Double_t TH2Poly::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TH2Poly}, bin::Int32)::Float64
Returns the value of error associated to bin number bin.
If the sum of squares of weights has been defined (via Sumw2), this function returns the sqrt(sum of w2). otherwise it returns the sqrt(contents) for this bin. Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins. See also [TH2Poly!GetBinContent](@ref)
""" GetBinError(this::ByConstRef1{TH2Poly}, bin::Int32)

# Wrapper of const char * TH2Poly::GetBinName(Int_t)
@trydoc raw"""
    GetBinName(this::ByConstRef1{TH2Poly}, bin::Int32)::ByCopy{String}
Returns the bin name.

""" GetBinName(this::ByConstRef1{TH2Poly}, bin::Int32)

# Wrapper of TList * TH2Poly::GetBins()
@trydoc raw"""
    GetBins(this::ByRef1{TH2Poly})::CxxPtr1{TList}
Returns the [TList](@ref) of all bins in the histogram.

""" GetBins(this::ByRef1{TH2Poly})

# Wrapper of const char * TH2Poly::GetBinTitle(Int_t)
@trydoc raw"""
    GetBinTitle(this::ByConstRef1{TH2Poly}, bin::Int32)::ByCopy{String}
Returns the bin title.

""" GetBinTitle(this::ByConstRef1{TH2Poly}, bin::Int32)

# Wrapper of Bool_t TH2Poly::GetFloat()
@trydoc raw"""
    GetFloat(this::ByRef1{TH2Poly})::Bool


""" GetFloat(this::ByRef1{TH2Poly})

# Wrapper of Double_t TH2Poly::GetMaximum()
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TH2Poly})::Float64
Returns the maximum value of the histogram.

""" GetMaximum(this::ByConstRef1{TH2Poly})

# Wrapper of Double_t TH2Poly::GetMaximum(Double_t)
@trydoc raw"""
    GetMaximum(this::ByConstRef1{TH2Poly}, maxval::Float64)::Float64
Returns the maximum value of the histogram that is less than maxval.

""" GetMaximum(this::ByConstRef1{TH2Poly}, maxval::Float64)

# Wrapper of Double_t TH2Poly::GetMinimum()
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TH2Poly})::Float64
Returns the minimum value of the histogram.

""" GetMinimum(this::ByConstRef1{TH2Poly})

# Wrapper of Double_t TH2Poly::GetMinimum(Double_t)
@trydoc raw"""
    GetMinimum(this::ByConstRef1{TH2Poly}, minval::Float64)::Float64
Returns the minimum value of the histogram that is greater than minval.

""" GetMinimum(this::ByConstRef1{TH2Poly}, minval::Float64)

# Wrapper of Bool_t TH2Poly::GetNewBinAdded()
@trydoc raw"""
    GetNewBinAdded(this::ByConstRef1{TH2Poly})::Bool


""" GetNewBinAdded(this::ByConstRef1{TH2Poly})

# Wrapper of Int_t TH2Poly::GetNumberOfBins()
@trydoc raw"""
    GetNumberOfBins(this::ByConstRef1{TH2Poly})::Int32
Return the number of bins : it should be the size of the bin list.

""" GetNumberOfBins(this::ByConstRef1{TH2Poly})

# Wrapper of void TH2Poly::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TH2Poly}, stats::ByPtr2{Float64})::Nothing
Fill the array stats from the contents of this histogram The array stats must be correctly dimensioned in the calling program.
stats[0] = sumw
    stats[1] = sumw2
    stats[2] = sumwx
    stats[3] = sumwx2
    stats[4] = sumwy
    stats[5] = sumwy2
    stats[6] = sumwxy

(C++ version of the code)

If no axis-subranges are specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If sub-ranges are specified, the function recomputes these quantities from the bin contents in the current axis ranges.

Note that the mean value/StdDev is computed using the bins in the currently defined ranges (see [TAxis!SetRange](@ref)). By default the ranges include all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1!StatOverflows(kTRUE) before filling the histogram.
""" GetStats(this::ByConstRef1{TH2Poly}, stats::ByPtr2{Float64})

# Wrapper of void TH2Poly::Honeycomb(Double_t, Double_t, Double_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Honeycomb(this::ByRef1{TH2Poly}, xstart::Float64, ystart::Float64, a::Float64, k::Int32, s::Int32, option::ByCopy{String})::Nothing
Bins the histogram using a honeycomb structure If the option "v" is specified, the hexagons are drawn "vertically" (default).
If the option "h" is selected they are drawn "horizontally".
""" Honeycomb(this::ByRef1{TH2Poly}, xstart::Float64, ystart::Float64, a::Float64, k::Int32, s::Int32, option::ByCopy{String})

# Wrapper of Double_t TH2Poly::Integral(Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH2Poly}, option::ByCopy{String})::Float64
Returns the integral of bin contents.
By default the integral is computed as the sum of bin contents. If option "width" or "area" is specified, the integral is the sum of the bin contents multiplied by the area of the bin.
""" Integral(this::ByConstRef1{TH2Poly}, option::ByCopy{String})

# Wrapper of Double_t TH2Poly::Interpolate(Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByRef1{TH2Poly}, ::Float64, ::Float64)::Float64
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Interpolate(this::ByRef1{TH2Poly}, ::Float64, ::Float64)

# Wrapper of Bool_t TH2Poly::IsInsideBin(Int_t, Double_t, Double_t)
@trydoc raw"""
    IsInsideBin(this::ByRef1{TH2Poly}, binnr::Int32, x::Float64, y::Float64)::Bool
Return "true" if the point (x,y) is inside the bin of binnr.

""" IsInsideBin(this::ByRef1{TH2Poly}, binnr::Int32, x::Float64, y::Float64)

# Wrapper of Long64_t TH2Poly::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TH2Poly}, ::ByPtr1{TCollection})::Int64
Merge TH2Polys Given the special nature of the [TH2Poly](@ref), the merge is implemented in terms of subsequent [TH2Poly!Add](@ref) calls.

""" Merge(this::ByRef1{TH2Poly}, ::ByPtr1{TCollection})

# Wrapper of Bool_t TH2Poly::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)::Bool
NOT IMPLEMENTED for [TH2Poly](@ref).

""" Multiply(this::ByRef1{TH2Poly}, ::ByPtr1{TF1}, ::Float64)

# Wrapper of TH2Poly & TH2Poly::operator=(const TH2Poly &)
@trydoc raw"""
    assign(this::ByRef1{TH2Poly}, rhs::ByConstRef1{TH2Poly})::CxxRef1{TH2Poly}
Assignment operator.

""" assign(this::ByRef1{TH2Poly}, rhs::ByConstRef1{TH2Poly})

# Wrapper of void TH2Poly::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH2Poly}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH2Poly}, option::ByCopy{String})

# Wrapper of void TH2Poly::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TH2Poly}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this histogram by a constant c1.

""" Scale(this::ByRef1{TH2Poly}, c1::Float64, option::ByCopy{String})

# Wrapper of void TH2Poly::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH2Poly}, bin::Int32, content::Float64)::Nothing
Sets the contents of the input bin to the input content Negative values between -1 and -9 are for the overflows and the sea.

""" SetBinContent(this::ByRef1{TH2Poly}, bin::Int32, content::Float64)

# Wrapper of void TH2Poly::SetBinContentChanged(Bool_t)
@trydoc raw"""
    SetBinContentChanged(this::ByRef1{TH2Poly}, flag::Bool)::Nothing


""" SetBinContentChanged(this::ByRef1{TH2Poly}, flag::Bool)

# Wrapper of void TH2Poly::SetBinError(Int_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{TH2Poly}, bin::Int32, error::Float64)::Nothing
Set the bin Error.
Re-implementation for [TH2Poly](@ref) given the different bin indexing in the stored squared error array. See also notes in [TH1!SetBinError](@ref)

Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins
""" SetBinError(this::ByRef1{TH2Poly}, bin::Int32, error::Float64)

# Wrapper of void TH2Poly::SetFloat(Bool_t)
@trydoc raw"""
    SetFloat(this::ByRef1{TH2Poly}, flag::Bool)::Nothing
When set to kTRUE, allows the histogram to expand if a bin outside the limits is added.

""" SetFloat(this::ByRef1{TH2Poly}, flag::Bool)

# Wrapper of void TH2Poly::SetNewBinAdded(Bool_t)
@trydoc raw"""
    SetNewBinAdded(this::ByRef1{TH2Poly}, flag::Bool)::Nothing


""" SetNewBinAdded(this::ByRef1{TH2Poly}, flag::Bool)

# Wrapper of void TH2PolyBin::ClearContent()
@trydoc raw"""
    ClearContent(this::ByRef1{TH2PolyBin})::Nothing


""" ClearContent(this::ByRef1{TH2PolyBin})

# Wrapper of void TH2PolyBin::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH2PolyBin}, w::Float64)::Nothing


""" Fill(this::ByRef1{TH2PolyBin}, w::Float64)

# Wrapper of Double_t TH2PolyBin::GetArea()
@trydoc raw"""
    GetArea(this::ByRef1{TH2PolyBin})::Float64
Returns the area of the bin.

""" GetArea(this::ByRef1{TH2PolyBin})

# Wrapper of Int_t TH2PolyBin::GetBinNumber()
@trydoc raw"""
    GetBinNumber(this::ByConstRef1{TH2PolyBin})::Int32


""" GetBinNumber(this::ByConstRef1{TH2PolyBin})

# Wrapper of Bool_t TH2PolyBin::GetChanged()
@trydoc raw"""
    GetChanged(this::ByConstRef1{TH2PolyBin})::Bool


""" GetChanged(this::ByConstRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetContent()
@trydoc raw"""
    GetContent(this::ByConstRef1{TH2PolyBin})::Float64


""" GetContent(this::ByConstRef1{TH2PolyBin})

# Wrapper of TObject * TH2PolyBin::GetPolygon()
@trydoc raw"""
    GetPolygon(this::ByConstRef1{TH2PolyBin})::CxxPtr1{TObject}


""" GetPolygon(this::ByConstRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetXMax()
@trydoc raw"""
    GetXMax(this::ByRef1{TH2PolyBin})::Float64
Returns the maximum value for the x coordinates of the bin.

""" GetXMax(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetXMin()
@trydoc raw"""
    GetXMin(this::ByRef1{TH2PolyBin})::Float64
Returns the minimum value for the x coordinates of the bin.

""" GetXMin(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetYMax()
@trydoc raw"""
    GetYMax(this::ByRef1{TH2PolyBin})::Float64
Returns the maximum value for the y coordinates of the bin.

""" GetYMax(this::ByRef1{TH2PolyBin})

# Wrapper of Double_t TH2PolyBin::GetYMin()
@trydoc raw"""
    GetYMin(this::ByRef1{TH2PolyBin})::Float64
Returns the minimum value for the y coordinates of the bin.

""" GetYMin(this::ByRef1{TH2PolyBin})

# Wrapper of Bool_t TH2PolyBin::IsInside(Double_t, Double_t)
@trydoc raw"""
    IsInside(this::ByConstRef1{TH2PolyBin}, x::Float64, y::Float64)::Bool
Return "true" if the point (x,y) is inside the bin.

""" IsInside(this::ByConstRef1{TH2PolyBin}, x::Float64, y::Float64)

# Wrapper of void TH2PolyBin::SetChanged(Bool_t)
@trydoc raw"""
    SetChanged(this::ByRef1{TH2PolyBin}, flag::Bool)::Nothing


""" SetChanged(this::ByRef1{TH2PolyBin}, flag::Bool)

# Wrapper of void TH2PolyBin::SetContent(Double_t)
@trydoc raw"""
    SetContent(this::ByRef1{TH2PolyBin}, content::Float64)::Nothing


""" SetContent(this::ByRef1{TH2PolyBin}, content::Float64)

# Wrapper of void TH3::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, bin::Int32)

# Wrapper of void TH3::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, bin::Int32, w::Float64)

# Wrapper of void TH3::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of Int_t TH3::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TH3}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref)) action = 0 histogram is filled from the buffer action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TH3}, action::Int32)

# Wrapper of void TH3::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3}, hnew::ByRef1{TObject})::Nothing
Copy.

""" Copy(this::ByConstRef1{TH3}, hnew::ByRef1{TObject})

# Wrapper of Int_t TH3::Fill(const char *, const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,namey,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(const char *, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Increment cell defined by namex,namey,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TH3::Fill(const char *, Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,y,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(const char *, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)::Int32
Increment cell defined by namex , y ,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,namey,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Increment cell defined by x,namey,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, y::Float64, namez::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,y,namez by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the corresponding cell. The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, y::Float64, namez::ByCopy{String}, w::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64)::Int32
Increment cell defined by x,y,z by 1 .
The function returns the corresponding global_ bin number which has its content incremented by 1
""" Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TH3::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64, w::Float64)::Int32
Increment cell defined by x,y,z by a weight w.
If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the cell corresponding to x,y,z.

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TH3}, x::Float64, y::Float64, z::Float64, w::Float64)

# Wrapper of void TH3::FillRandom(const char *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH3}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in function fname.
## Arguments

- **`fname`** 
    : Function name used for filling the histogram 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used to sample
    

The distribution contained in the function fname ([TF1](@ref)) is integrated over the channel contents for the bin range of this histogram. It is normalized to 1.

Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated

One can also call [TF1!GetRandom](@ref) to get a random variate from a function.
""" FillRandom(this::ByRef1{TH3}, fname::ByCopy{String}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH3::FillRandom(TH1 *, Int_t, TRandom *)
@trydoc raw"""
    FillRandom(this::ByRef1{TH3}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})::Nothing
Fill histogram following distribution in histogram h.
## Arguments

- **`h`** 
    : Histogram pointer used for sampling random number 
    
- **`ntimes`** 
    : number of times the histogram is filled 
    
- **`rng`** 
    : (optional) Random number generator used for sampling
    

The distribution contained in the histogram h ([TH3](@ref)) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:

- Generating a random number between 0 and 1 (say r1)
- Look in which bin in the normalized integral r1 corresponds to
- Fill histogram channel ntimes random numbers are generated
""" FillRandom(this::ByRef1{TH3}, h::ByPtr1{TH1}, ntimes::Int32, rng::ByPtr1{TRandom})

# Wrapper of void TH3::FitSlicesZ(TF1 *, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    FitSlicesZ(this::ByRef1{TH3}, f1::ByPtr1{TF1}, binminx::Int32, binmaxx::Int32, binminy::Int32, binmaxy::Int32, cut::Int32, option::ByCopy{String})::Nothing
Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-d histogram for each fit parameter Only cells in the bin range [binminx,binmaxx] and [binminy,binmaxy] are considered.
if f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along Z via f1->SetRange(zmin,zmax) The argument option (default="QNR") can be used to change the fit options. "Q" means Quiet mode "N" means do not show the result of the fit "R" means fit the function in the specified function range

Note that the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.

Example: Assume a 3-d histogram h3 Root > h3->[FitSlicesZ()](@ref); produces 4 [TH2D](@ref) histograms with h3_0 containing parameter 0(Constant) for a Gaus fit of each cell in X,Y projected along Z with h3_1 containing parameter 1(Mean) for a gaus fit with h3_2 containing parameter 2(StdDev) for a gaus fit with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit

Root > h3->Fit(0,15,22,0,0,10); same as above, but only for bins 15 to 22 along X and only for cells in X,Y for which the corresponding projection along Z has more than cut bins filled.

NOTE: To access the generated histograms in the current directory, do eg: [TH2D](@ref) <i>h3_1 = ([TH2D](@ref)</i>)gDirectory->Get("h3_1");
""" FitSlicesZ(this::ByRef1{TH3}, f1::ByPtr1{TF1}, binminx::Int32, binmaxx::Int32, binminy::Int32, binmaxy::Int32, cut::Int32, option::ByCopy{String})

# Wrapper of Int_t TH3::GetBin(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBin(this::ByConstRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Int32
See comments in [TH1!GetBin](@ref).
""" GetBin(this::ByConstRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH3::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH3::GetBinErrorLow(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinErrorLow(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinErrorLow(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH3::GetBinErrorUp(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinErrorUp(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinErrorUp(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TH3::GetBinWithContent3(Double_t, Int_t &, Int_t &, Int_t &, Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    GetBinWithContent3(this::ByConstRef1{TH3}, c::Float64, binx::ByRef2{Int32}, biny::ByRef2{Int32}, binz::ByRef2{Int32}, firstx::Int32, lastx::Int32, firsty::Int32, lasty::Int32, firstz::Int32, lastz::Int32, maxdiff::Float64)::Float64
Compute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,lastz] for which diff = abs(cell_content-c) <= maxdiff In case several cells in the specified range with diff=0 are found the first cell found is returned in binx,biny,binz.
In case several cells in the specified range satisfy diff <=maxdiff the cell with the smallest difference is returned in binx,biny,binz. In all cases the function returns the smallest difference.

NOTE1: if firstx <= 0, firstx is set to bin 1 if (lastx < firstx then firstx is set to the number of bins in X ie if firstx=0 and lastx=0 (default) the search is on all bins in X. if firsty <= 0, firsty is set to bin 1 if (lasty < firsty then firsty is set to the number of bins in Y ie if firsty=0 and lasty=0 (default) the search is on all bins in Y. if firstz <= 0, firstz is set to bin 1 if (lastz < firstz then firstz is set to the number of bins in Z ie if firstz=0 and lastz=0 (default) the search is on all bins in Z. NOTE2: if maxdiff=0 (default), the first cell with content=c is returned.
""" GetBinWithContent3(this::ByConstRef1{TH3}, c::Float64, binx::ByRef2{Int32}, biny::ByRef2{Int32}, binz::ByRef2{Int32}, firstx::Int32, lastx::Int32, firsty::Int32, lasty::Int32, firstz::Int32, lastz::Int32, maxdiff::Float64)

# Wrapper of Double_t TH3::GetCorrelationFactor(Int_t, Int_t)
@trydoc raw"""
    GetCorrelationFactor(this::ByConstRef1{TH3}, axis1::Int32, axis2::Int32)::Float64
Return correlation factor between axis1 and axis2.

""" GetCorrelationFactor(this::ByConstRef1{TH3}, axis1::Int32, axis2::Int32)

# Wrapper of Double_t TH3::GetCovariance(Int_t, Int_t)
@trydoc raw"""
    GetCovariance(this::ByConstRef1{TH3}, axis1::Int32, axis2::Int32)::Float64
Return covariance between axis1 and axis2.

""" GetCovariance(this::ByConstRef1{TH3}, axis1::Int32, axis2::Int32)

# Wrapper of void TH3::GetRandom3(Double_t &, Double_t &, Double_t &, TRandom *)
@trydoc raw"""
    GetRandom3(this::ByRef1{TH3}, x::ByRef2{Float64}, y::ByRef2{Float64}, ::ByRef2{Float64}, rng::ByPtr1{TRandom})::Nothing
Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-dim histogram.
## Arguments

- **`x`** [out] 
    reference to random generated x value 
    
- **`y`** [out] 
    reference to random generated y value 
    
- **`z`** [out] 
    reference to random generated z value 
    
- **`rng`** [in] 
    (optional) Random number generator pointer used (default is gRandom)
""" GetRandom3(this::ByRef1{TH3}, x::ByRef2{Float64}, y::ByRef2{Float64}, ::ByRef2{Float64}, rng::ByPtr1{TRandom})

# Wrapper of void TH3::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TH3}, stats::ByPtr2{Float64})::Nothing
Fill the array stats from the contents of this histogram The array stats must be correctly dimensioned in the calling program.
stats[0] = sumw stats[1] = sumw2 stats[2] = sumwx stats[3] = sumwx2 stats[4] = sumwy stats[5] = sumwy2 stats[6] = sumwxy stats[7] = sumwz stats[8] = sumwz2 stats[9] = sumwxz stats[10]= sumwyz
""" GetStats(this::ByConstRef1{TH3}, stats::ByPtr2{Float64})

# Wrapper of Double_t TH3::Integral(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH3}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, binz1::Int32, binz2::Int32, option::ByCopy{String})::Float64
Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram By default the integral is computed as the sum of bin contents in the range.
if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x, y and in z.
""" Integral(this::ByConstRef1{TH3}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, binz1::Int32, binz2::Int32, option::ByCopy{String})

# Wrapper of Double_t TH3::Integral(Option_t *)
@trydoc raw"""
    Integral(this::ByConstRef1{TH3}, option::ByCopy{String})::Float64
Return integral of bin contents.
Only bins in the bins range are considered. By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x, y and in z.
""" Integral(this::ByConstRef1{TH3}, option::ByCopy{String})

# Wrapper of Double_t TH3::IntegralAndError(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Double_t &, Option_t *)
@trydoc raw"""
    IntegralAndError(this::ByConstRef1{TH3}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, binz1::Int32, binz2::Int32, err::ByRef2{Float64}, option::ByCopy{String})::Float64
Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram.
Calculates also the integral error using error propagation from the bin errors assuming that all the bins are uncorrelated. By default the integral is computed as the sum of bin contents in the range. if option "width" is specified, the integral is the sum of the bin contents multiplied by the bin width in x, y and in z.
""" IntegralAndError(this::ByConstRef1{TH3}, binx1::Int32, binx2::Int32, biny1::Int32, biny2::Int32, binz1::Int32, binz2::Int32, err::ByRef2{Float64}, option::ByCopy{String})

# Wrapper of Double_t TH3::Interpolate(Double_t, Double_t, Double_t)
@trydoc raw"""
    Interpolate(this::ByConstRef1{TH3}, x::Float64, y::Float64, z::Float64)::Float64
Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation based on the 8 nearest bin center points (corner of the cube surrounding the points) The Algorithm is described in [http://en.wikipedia.org/wiki/Trilinear_interpolation](http://en.wikipedia.org/wiki/Trilinear_interpolation) The given values (x,y,z) must be between first bin center and last bin center for each coordinate:
fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ)
""" Interpolate(this::ByConstRef1{TH3}, x::Float64, y::Float64, z::Float64)

# Wrapper of Double_t TH3::KolmogorovTest(const TH1 *, Option_t *)
@trydoc raw"""
    KolmogorovTest(this::ByConstRef1{TH3}, h2::ByConstPtr1{TH1}, option::ByCopy{String})::Float64
Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.
Default: Ignore under- and overflow bins in comparison

option is a character string to specify options "U" include Underflows in test "O" include Overflows "N" include comparison of normalizations "D" Put out a line of "Debug" printout "M" Return the Maximum Kolmogorov distance instead of prob

The returned function value is the probability of test (much less than one means NOT compatible)

The KS test uses the distance between the pseudo-CDF's obtained from the histogram. Since in more than 1D the order for generating the pseudo-CDF is arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis. The average of all the maximum distances obtained is used in the tests.
""" KolmogorovTest(this::ByConstRef1{TH3}, h2::ByConstPtr1{TH1}, option::ByCopy{String})

# Wrapper of TH1 * TH3::Project3D(Option_t *)
@trydoc raw"""
    Project3D(this::ByConstRef1{TH3}, option::ByCopy{String})::CxxPtr1{TH1}
Project a 3-d histogram into 1 or 2-d histograms depending on the option parameter, which may contain a combination of the characters x,y,z,e.
- option = "x" return the x projection into a [TH1D](@ref) histogram
- option = "y" return the y projection into a [TH1D](@ref) histogram
- option = "z" return the z projection into a [TH1D](@ref) histogram
- option = "xy" return the x versus y projection into a [TH2D](@ref) histogram
- option = "yx" return the y versus x projection into a [TH2D](@ref) histogram
- option = "xz" return the x versus z projection into a [TH2D](@ref) histogram
- option = "zx" return the z versus x projection into a [TH2D](@ref) histogram
- option = "yz" return the y versus z projection into a [TH2D](@ref) histogram
- option = "zy" return the z versus y projection into a [TH2D](@ref) histogram

NB: the notation "a vs b" means "a" vertical and "b" horizontal

option = "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

If option contains the string "e", errors are computed

The projection is made for the selected bins only. To select a bin range along an axis, use [TAxis!SetRange](@ref), eg h3.GetYaxis()->SetRange(23,56);

NOTE 1: The generated histogram is named th3name + option eg if the TH3* h histogram is named "myhist", then h->Project3D("xy"); produces a [TH2D](@ref) histogram named "myhist_xy" if a histogram of the same type already exists, it is overwritten. The following sequence h->Project3D("xy"); h->Project3D("xy2"); will generate two [TH2D](@ref) histograms named "myhist_xy" and "myhist_xy2" A different name can be generated by attaching a string to the option For example h->Project3D("name_xy") will generate an histogram with the name: h3dname_name_xy.

NOTE 2: If an histogram of the same type and with the same name already exists in current Directory, the histogram is reset and filled again with the projected contents of the [TH3](@ref).

NOTE 3: The number of entries in the projected histogram is estimated from the number of effective entries for all the cells included in the projection.

NOTE 4: underflow/overflow are included by default in the projection To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option "NUF" and/or "NOF" With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as following after having called SetRange: axis->SetRange(1, axis->GetNbins());

NOTE 5: If [TH1!AddDirectory](@ref) is set to false, a new histogram is always created and the ownership of the returned pointer is delegated to the user. Be sure in this case to call `delete` on it after it's no longer needed, to avoid memory leaks.
""" Project3D(this::ByConstRef1{TH3}, option::ByCopy{String})

# Wrapper of TProfile2D * TH3::Project3DProfile(Option_t *)
@trydoc raw"""
    Project3DProfile(this::ByConstRef1{TH3}, option::ByCopy{String})::CxxPtr1{TProfile2D}
Project a 3-d histogram into a 2-d profile histograms depending on the option parameter option may contain a combination of the characters x,y,z option = "xy" return the x versus y projection into a [TProfile2D](@ref) histogram option = "yx" return the y versus x projection into a [TProfile2D](@ref) histogram option = "xz" return the x versus z projection into a [TProfile2D](@ref) histogram option = "zx" return the z versus x projection into a [TProfile2D](@ref) histogram option = "yz" return the y versus z projection into a [TProfile2D](@ref) histogram option = "zy" return the z versus y projection into a [TProfile2D](@ref) histogram NB: the notation "a vs b" means "a" vertical and "b" horizontal.
option = "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

The projection is made for the selected bins only. To select a bin range along an axis, use [TAxis!SetRange](@ref), eg h3.GetYaxis()->SetRange(23,56);

NOTE 1: The generated histogram is named th3name + "_p" + option eg if the TH3* h histogram is named "myhist", then h->Project3D("xy"); produces a [TProfile2D](@ref) histogram named "myhist_pxy". The following sequence h->Project3DProfile("xy"); h->Project3DProfile("xy2"); will generate two [TProfile2D](@ref) histograms named "myhist_pxy" and "myhist_pxy2" So, passing additional characters in the option string one can customize the name.

NOTE 2: If a profile of the same type already exists with compatible axes, the profile is reset and filled again with the projected contents of the [TH3](@ref). In the case of axes incompatibility, an error is reported and a NULL pointer is returned.

NOTE 3: The number of entries in the projected profile is estimated from the number of effective entries for all the cells included in the projection.

NOTE 4: underflow/overflow are by default excluded from the projection (Note that this is a different default behavior compared to the projection to an histogram) To include the underflow and/or overflow use option "UF" and/or "OF"
""" Project3DProfile(this::ByConstRef1{TH3}, option::ByCopy{String})

# Wrapper of TH1D * TH3::ProjectionX(const char *, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProjectionX(this::ByConstRef1{TH3}, name::ByCopy{String}, iymin::Int32, iymax::Int32, izmin::Int32, izmax::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Project a 3-D histogram into a 1-D histogram along X.
The projection is always of the type [TH1D](@ref). The projection is made from the cells along the X axis ranging from iymin to iymax and izmin to izmax included. By default, underflow and overflows are included in both the Y and Z axis. By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow in Y will be excluded By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded

if option "e" is specified, the errors are computed. if option "d" is specified, the projection is drawn in the current pad. if option "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

NOTE that if a [TH1D](@ref) named "name" exists in the current directory or pad the histogram is reset and filled again with the projected contents of the [TH3](@ref).

implemented using Project3D
""" ProjectionX(this::ByConstRef1{TH3}, name::ByCopy{String}, iymin::Int32, iymax::Int32, izmin::Int32, izmax::Int32, option::ByCopy{String})

# Wrapper of TH1D * TH3::ProjectionY(const char *, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProjectionY(this::ByConstRef1{TH3}, name::ByCopy{String}, ixmin::Int32, ixmax::Int32, izmin::Int32, izmax::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Project a 3-D histogram into a 1-D histogram along Y.
The projection is always of the type [TH1D](@ref). The projection is made from the cells along the Y axis ranging from ixmin to ixmax and izmin to izmax included. By default, underflow and overflow are included in both the X and Z axis. By setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded

if option "e" is specified, the errors are computed. if option "d" is specified, the projection is drawn in the current pad. if option "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

NOTE that if a [TH1D](@ref) named "name" exists in the current directory or pad, the histogram is reset and filled again with the projected contents of the [TH3](@ref).

implemented using Project3D
""" ProjectionY(this::ByConstRef1{TH3}, name::ByCopy{String}, ixmin::Int32, ixmax::Int32, izmin::Int32, izmax::Int32, option::ByCopy{String})

# Wrapper of TH1D * TH3::ProjectionZ(const char *, Int_t, Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProjectionZ(this::ByConstRef1{TH3}, name::ByCopy{String}, ixmin::Int32, ixmax::Int32, iymin::Int32, iymax::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Project a 3-D histogram into a 1-D histogram along Z.
The projection is always of the type [TH1D](@ref). The projection is made from the cells along the Z axis ranging from ixmin to ixmax and iymin to iymax included. By default, bins 1 to nx and 1 to ny are included By default, underflow and overflow are included in both the X and Y axis. By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded

if option "e" is specified, the errors are computed. if option "d" is specified, the projection is drawn in the current pad. if option "o" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.

NOTE that if a [TH1D](@ref) named "name" exists in the current directory or pad, the histogram is reset and filled again with the projected contents of the [TH3](@ref).

implemented using Project3D
""" ProjectionZ(this::ByConstRef1{TH3}, name::ByCopy{String}, ixmin::Int32, ixmax::Int32, iymin::Int32, iymax::Int32, option::ByCopy{String})

# Wrapper of void TH3::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TH3}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TH3}, stats::ByPtr2{Float64})

# Wrapper of TH3 * TH3::Rebin3D(Int_t, Int_t, Int_t, const char *)
@trydoc raw"""
    Rebin3D(this::ByRef1{TH3}, nxgroup::Int32, nygroup::Int32, nzgroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.
if newname is not blank a new temporary histogram hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to me merged into one bin of hnew If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.

examples: if hpxpy is an existing [TH3](@ref) histogram with 40 x 40 x 40 bins hpxpypz->[Rebin3D()](@ref); // merges two bins along the xaxis and yaxis in one in hpxpypz // Carefull: previous contents of hpxpy are lost hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz [TH3](@ref) *hnew = hpxpypz->RebinY(5,"hnew"); // creates a new histogram hnew // merging 5 bins of h1 along the yaxis in one bin

NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned histogram is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.
""" Rebin3D(this::ByRef1{TH3}, nxgroup::Int32, nygroup::Int32, nzgroup::Int32, newname::ByCopy{String})

# Wrapper of TH3 * TH3::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin only the X axis see Rebin3D.

""" RebinX(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TH3 * TH3::RebinY(Int_t, const char *)
@trydoc raw"""
    RebinY(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin only the Y axis see Rebin3D.

""" RebinY(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TH3 * TH3::RebinZ(Int_t, const char *)
@trydoc raw"""
    RebinZ(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TH3}
Rebin only the Z axis see Rebin3D.

""" RebinZ(this::ByRef1{TH3}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TH3::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3}, option::ByCopy{String})

# Wrapper of void TH3::SetBinContent(Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH3}, bin::Int32, content::Float64)::Nothing
Set bin content.

""" SetBinContent(this::ByRef1{TH3}, bin::Int32, content::Float64)

# Wrapper of void TH3::SetBinContent(Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH3}, bin::Int32, ::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH3}, bin::Int32, ::Int32, content::Float64)

# Wrapper of void TH3::SetBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, content::Float64)::Nothing


""" SetBinContent(this::ByRef1{TH3}, binx::Int32, biny::Int32, binz::Int32, content::Float64)

# Wrapper of void TH3::SetShowProjection(const char *, Int_t)
@trydoc raw"""
    SetShowProjection(this::ByRef1{TH3}, option::ByCopy{String}, nbins::Int32)::Nothing
When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a projection type given as option.
To stop the generation of the projections, delete the canvas containing the projection. option may contain a combination of the characters x,y,z,e option = "x" return the x projection into a [TH1D](@ref) histogram option = "y" return the y projection into a [TH1D](@ref) histogram option = "z" return the z projection into a [TH1D](@ref) histogram option = "xy" return the x versus y projection into a [TH2D](@ref) histogram option = "yx" return the y versus x projection into a [TH2D](@ref) histogram option = "xz" return the x versus z projection into a [TH2D](@ref) histogram option = "zx" return the z versus x projection into a [TH2D](@ref) histogram option = "yz" return the y versus z projection into a [TH2D](@ref) histogram option = "zy" return the z versus y projection into a [TH2D](@ref) histogram option can also include the drawing option for the projection, eg to draw the xy projection using the draw option "box" do myhist.SetShowProjection("xy box"); This function is typically called from the context menu. NB: the notation "a vs b" means "a" vertical and "b" horizontal
""" SetShowProjection(this::ByRef1{TH3}, option::ByCopy{String}, nbins::Int32)

# Wrapper of Bool_t TProfile2D::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this profile2D by the addition of h1 and h2.
`this = c1*h1 + c2*h2`
""" Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TProfile2D::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: `this = this + c1*h1` .

""" Add(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TProfile2D::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: `this = this + c1*f1` .

""" Add(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TProfile2D::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TProfile2D}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TProfile2D}, action::Int32)

# Wrapper of void TProfile2D::BuildOptions(Double_t, Double_t, Option_t *)
@trydoc raw"""
    BuildOptions(this::ByRef1{TProfile2D}, zmin::Float64, zmax::Float64, option::ByCopy{String})::Nothing
Set Profile2D histogram structure and options.
- zmin: minimum value allowed for z
- zmax: maximum value allowed for z if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf)
- option: this is the option for the computation of the t error of the profile ( [TProfile2D!GetBinError](@ref) ) possible values for the options are documented in [TProfile2D!SetErrorOption](@ref)

    See [TProfile!BuildOptions](@ref) for a detailed description
""" BuildOptions(this::ByRef1{TProfile2D}, zmin::Float64, zmax::Float64, option::ByCopy{String})

# Wrapper of void TProfile2D::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TProfile2D}, hnew::ByRef1{TObject})::Nothing
Copy a Profile2D histogram to a new profile2D histogram.

""" Copy(this::ByConstRef1{TProfile2D}, hnew::ByRef1{TObject})

# Wrapper of Bool_t TProfile2D::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})::Bool
Divide this profile2D by h1.
`this = this/h1`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile2D::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile2D::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)` .
This function is not implemented
""" Divide(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TProfile2D::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TProfile2D}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Profile histogram is resized along axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The axis must be extendable before invoking this function.

Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`
""" ExtendAxis(this::ByRef1{TProfile2D}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of Int_t TProfile2D::Fill(const char *, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by namex,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.

    - If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,namey

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(const char *, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, w::Float64)::Int32
Increment cell defined by namex,y by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to namex,y

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(const char *, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, namex::ByCopy{String}, y::Float64, z::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, const char *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, w::Float64)::Int32
Increment cell defined by x,namey by a weight w.
- if x or/and y is less than the low-edge of the corresponding axis first bin, the Underflow cell is incremented.
- if x or/and y is equal to or greater than the upper edge of corresponding axis last bin, the Overflow cell is incremented.
- If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by w^2 in the bin corresponding to x,y.

The function returns the corresponding global_ bin number which has its content incremented by w
""" Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, const char *, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, x::Float64, namey::ByCopy{String}, z::Float64, w::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64)::Int32
Fill a Profile2D histogram (no weights).

""" Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64)

# Wrapper of Int_t TProfile2D::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64, w::Float64)::Int32
Fill a Profile2D histogram with weights.

""" Fill(this::ByRef1{TProfile2D}, x::Float64, y::Float64, z::Float64, w::Float64)

# Wrapper of Double_t TProfile2D::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile2D}, bin::Int32)::Float64
Return bin content of a Profile2D histogram.

""" GetBinContent(this::ByConstRef1{TProfile2D}, bin::Int32)

# Wrapper of Double_t TProfile2D::GetBinContent(Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32)

# Wrapper of Double_t TProfile2D::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32, ::Int32)

# Wrapper of Double_t TProfile2D::GetBinEffectiveEntries(Int_t)
@trydoc raw"""
    GetBinEffectiveEntries(this::ByRef1{TProfile2D}, bin::Int32)::Float64
Return bin effective entries for a weighted filled Profile histogram.
In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. [TProfile!Sumw2()](@ref) must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored.
""" GetBinEffectiveEntries(this::ByRef1{TProfile2D}, bin::Int32)

# Wrapper of Double_t TProfile2D::GetBinEntries(Int_t)
@trydoc raw"""
    GetBinEntries(this::ByConstRef1{TProfile2D}, bin::Int32)::Float64
Return bin entries of a Profile2D histogram.

""" GetBinEntries(this::ByConstRef1{TProfile2D}, bin::Int32)

# Wrapper of Double_t TProfile2D::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile2D}, bin::Int32)::Float64
Return bin error of a Profile2D histogram.
### Computing errors: A moving field

The computation of errors for a [TProfile2D](@ref) has evolved with the versions of [ROOT](@ref). The difficulty is in computing errors for bins with low statistics.

- prior to version 3.10, we had no special treatment of low statistic bins. As a result, these bins had huge errors. The reason is that the expression eprim2 is very close to 0 (rounding problems) or 0.
- The algorithm is modified/protected for the case when a [TProfile2D](@ref) is projected (ProjectionX). The previous algorithm generated a N^2 problem when projecting a [TProfile2D](@ref) with a large number of bins (eg 100000).
- in version 3.10/02, a new static function [TProfile!Approximate](@ref) is introduced to enable or disable (default) the approximation. (see also comments in [TProfile!GetBinError](@ref))
""" GetBinError(this::ByConstRef1{TProfile2D}, bin::Int32)

# Wrapper of Double_t TProfile2D::GetBinError(Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32)::Float64


""" GetBinError(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32)

# Wrapper of Double_t TProfile2D::GetBinError(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32, ::Int32)::Float64


""" GetBinError(this::ByConstRef1{TProfile2D}, binx::Int32, biny::Int32, ::Int32)

# Wrapper of TArrayD * TProfile2D::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByRef1{TProfile2D})::CxxPtr1{TArrayD}


""" GetBinSumw2(this::ByRef1{TProfile2D})

# Wrapper of const TArrayD * TProfile2D::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByConstRef1{TProfile2D})::ConstCxxPtr1{TArrayD}


""" GetBinSumw2(this::ByConstRef1{TProfile2D})

# Wrapper of Option_t * TProfile2D::GetErrorOption()
@trydoc raw"""
    GetErrorOption(this::ByConstRef1{TProfile2D})::ByCopy{String}
Return option to compute profile2D errors.

""" GetErrorOption(this::ByConstRef1{TProfile2D})

# Wrapper of Double_t TProfile2D::GetNumberOfBins()
@trydoc raw"""
    GetNumberOfBins(this::ByRef1{TProfile2D})::Float64


""" GetNumberOfBins(this::ByRef1{TProfile2D})

# Wrapper of void TProfile2D::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TProfile2D}, stats::ByPtr2{Float64})::Nothing
Fill the array stats from the contents of this profile.
The array stats must be correctly dimensioned in the calling program.

- stats[0] = sumw
- stats[1] = sumw2
- stats[2] = sumwx
- stats[3] = sumwx2
- stats[4] = sumwy
- stats[5] = sumwy2
- stats[6] = sumwxy
- stats[7] = sumwz
- stats[8] = sumwz2

If no axis-subrange is specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.
""" GetStats(this::ByConstRef1{TProfile2D}, stats::ByPtr2{Float64})

# Wrapper of Double_t TProfile2D::GetZmax()
@trydoc raw"""
    GetZmax(this::ByConstRef1{TProfile2D})::Float64


""" GetZmax(this::ByConstRef1{TProfile2D})

# Wrapper of Double_t TProfile2D::GetZmin()
@trydoc raw"""
    GetZmin(this::ByConstRef1{TProfile2D})::Float64


""" GetZmin(this::ByConstRef1{TProfile2D})

# Wrapper of void TProfile2D::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})::Nothing
Reduce the number of bins for this axis to the number of bins having a label.

""" LabelsDeflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})

# Wrapper of void TProfile2D::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TProfile2D}, axis::ByCopy{String})

# Wrapper of void TProfile2D::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TProfile2D}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Set option(s) to draw axis with labels.
option might have the following values:

- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TProfile2D}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TProfile2D::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile2D}, list::ByPtr1{TCollection})::Int64
Merge all histograms in the collection in this histogram.
This function computes the min/max for the axes, compute a new number of bins, if necessary, add bin contents, errors and statistics. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

IMPORTANT remark. The 2 axis x and y may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width.
""" Merge(this::ByRef1{TProfile2D}, list::ByPtr1{TCollection})

# Wrapper of Bool_t TProfile2D::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})::Bool
Multiply this profile2D by h1.
`this = this*h1`
""" Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`
""" Multiply(this::ByRef1{TProfile2D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile2D::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: this = this*c1*f1.

""" Multiply(this::ByRef1{TProfile2D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of TProfile2D & TProfile2D::operator=(const TProfile2D &)
@trydoc raw"""
    assign(this::ByRef1{TProfile2D}, profile::ByConstRef1{TProfile2D})::CxxRef1{TProfile2D}


""" assign(this::ByRef1{TProfile2D}, profile::ByConstRef1{TProfile2D})

# Wrapper of TProfile * TProfile2D::ProfileX(const char *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProfileX(this::ByConstRef1{TProfile2D}, name::ByCopy{String}, firstybin::Int32, lastybin::Int32, option::ByCopy{String})::CxxPtr1{TProfile}
Project a 2-D histogram into a profile histogram along X.
The projection is made from the channels along the Y axis ranging from firstybin to lastybin included. The result is a 1D profile which contains the combination of all the considered bins along Y By default, bins 1 to ny are included When all bins are included, the number of entries in the projection is set to the number of entries of the 2-D histogram, otherwise the number of entries is incremented by 1 for all non empty cells.

The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See [TProfile!BuildOptions](@ref) for details
""" ProfileX(this::ByConstRef1{TProfile2D}, name::ByCopy{String}, firstybin::Int32, lastybin::Int32, option::ByCopy{String})

# Wrapper of TProfile * TProfile2D::ProfileY(const char *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    ProfileY(this::ByConstRef1{TProfile2D}, name::ByCopy{String}, firstxbin::Int32, lastxbin::Int32, option::ByCopy{String})::CxxPtr1{TProfile}
Project a 2-D histogram into a profile histogram along X.
The projection is made from the channels along the X axis ranging from firstybin to lastybin included. The result is a 1D profile which contains the combination of all the considered bins along X By default, bins 1 to ny are included When all bins are included, the number of entries in the projection is set to the number of entries of the 2-D histogram, otherwise the number of entries is incremented by 1 for all non empty cells.

The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See [TProfile!BuildOptions](@ref) for details
""" ProfileY(this::ByConstRef1{TProfile2D}, name::ByCopy{String}, firstxbin::Int32, lastxbin::Int32, option::ByCopy{String})

# Wrapper of TH2D * TProfile2D::ProjectionXY(const char *, Option_t *)
@trydoc raw"""
    ProjectionXY(this::ByConstRef1{TProfile2D}, name::ByCopy{String}, option::ByCopy{String})::CxxPtr1{TH2D}
Project this profile2D into a 2-D histogram along X,Y.
The projection is always of the type [TH2D](@ref).

- if option "E" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option "E" is defined as the default one in the header file.
- if option "" is specified the histogram errors are simply the sqrt of its content
- if option "B" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,
- if option "C=E" the bin contents of the projection are set to the bin errors of the profile
- if option "W" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a [TH2D](@ref) using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected histogram (obtained using this option "W") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable ([TProfile2D!fSumw2](@ref)[bin]
""" ProjectionXY(this::ByConstRef1{TProfile2D}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TProfile2D::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TProfile2D}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TProfile2D}, stats::ByPtr2{Float64})

# Wrapper of TProfile2D * TProfile2D::Rebin2D(Int_t, Int_t, const char *)
@trydoc raw"""
    Rebin2D(this::ByRef1{TProfile2D}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})::CxxPtr1{TProfile2D}
Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.
if newname is not blank a new profile hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to be merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.

examples: if hpxpy is an existing [TProfile2D](@ref) profile with 40 x 40 bins 

    hpxpy->Rebin2D();  // merges two bins along the xaxis and yaxis in one
                       // Carefull: previous contents of hpxpy are lost
    hpxpy->Rebin2D(3,5);  // merges 3 bins along the xaxis and 5 bins along the yaxis in one
                          // Carefull: previous contents of hpxpy are lost
    hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy
    TProfile2D *hnew = hpxpy->RebinY(5,"hnew"); // creates a new profile hnew
                                                // merging 5 bins of hpxpy along the yaxis in one bin

(C++ version of the code)

NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned profile is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the remaining bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.
""" Rebin2D(this::ByRef1{TProfile2D}, nxgroup::Int32, nygroup::Int32, newname::ByCopy{String})

# Wrapper of TProfile2D * TProfile2D::RebinX(Int_t, const char *)
@trydoc raw"""
    RebinX(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TProfile2D}
Rebin only the X axis.
see Rebin2D
""" RebinX(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of TProfile2D * TProfile2D::RebinY(Int_t, const char *)
@trydoc raw"""
    RebinY(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})::CxxPtr1{TProfile2D}
Rebin only the Y axis.
see Rebin2D
""" RebinY(this::ByRef1{TProfile2D}, ngroup::Int32, newname::ByCopy{String})

# Wrapper of void TProfile2D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile2D}, option::ByCopy{String})::Nothing
Reset contents of a Profile2D histogram.

""" Reset(this::ByRef1{TProfile2D}, option::ByCopy{String})

# Wrapper of void TProfile2D::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TProfile2D}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this profile2D by a constant c1.
`this = c1*this

This function uses the services of [TProfile2D!Add](@ref)
""" Scale(this::ByRef1{TProfile2D}, c1::Float64, option::ByCopy{String})

# Wrapper of void TProfile2D::SetBinEntries(Int_t, Double_t)
@trydoc raw"""
    SetBinEntries(this::ByRef1{TProfile2D}, bin::Int32, w::Float64)::Nothing
Set the number of entries in bin.

""" SetBinEntries(this::ByRef1{TProfile2D}, bin::Int32, w::Float64)

# Wrapper of void TProfile2D::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile2D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64)::Nothing
Redefine x and y axis parameters.

""" SetBins(this::ByRef1{TProfile2D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64)

# Wrapper of void TProfile2D::SetBins(Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile2D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})::Nothing
Redefine x and y axis parameters for variable bin sizes.

""" SetBins(this::ByRef1{TProfile2D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64})

# Wrapper of void TProfile2D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TProfile2D}, n::Int32)::Nothing
Set total number of bins including under/overflow.
Reallocate bin contents array
""" SetBinsLength(this::ByRef1{TProfile2D}, n::Int32)

# Wrapper of void TProfile2D::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TProfile2D}, buffersize::Int32, option::ByCopy{String})::Nothing
Set the buffer size in units of 8 bytes (double).

""" SetBuffer(this::ByRef1{TProfile2D}, buffersize::Int32, option::ByCopy{String})

# Wrapper of void TProfile2D::SetErrorOption(Option_t *)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile2D}, option::ByCopy{String})::Nothing
Set option to compute profile2D errors.
The computation of the bin errors is based on the parameter option:

- ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z), i.e. the standard error of the bin contents. Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Z is 0 and the number of bin entries is > 0
- 's' The bin errors are the standard deviations of the Z bin values Note that if [TProfile!Approximate()](@ref) is called, an approximation is used when the spread in Z is 0 and the number of bin entries is > 0
- 'i' Errors are as in default case (standard errors of the bin contents) The only difference is for the case when the spread in Z is zero. In this case for N > 0 the error is 1./SQRT(12.*N)
- 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0. W is the sum in the bin of the weights of the profile. This option is for combining measurements z +/- dz, and the profile is filled with values y and weights z = 1/dz**2

See [TProfile!BuildOptions](@ref) for a detailed explanation of all options
""" SetErrorOption(this::ByRef1{TProfile2D}, option::ByCopy{String})

# Wrapper of void TProfile2D::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TProfile2D}, flag::Bool)::Nothing
Create/Delete structure to store sum of squares of weights per bin.
This is needed to compute the correct statistical quantities of a profile filled with weights

This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag is false the structure is deleted
""" Sumw2(this::ByRef1{TProfile2D}, flag::Bool)

# Wrapper of void TProfile2D::Approximate(Bool_t)
@trydoc raw"""
    TProfile2D!Approximate(this::ByRef1{TProfile2D}, approx::Bool)::Nothing
Static function, set the fgApproximate flag.
When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only

- the number of bins in the profile2D is less than 10404 (eg 100x100)
- the bin number of entries is small ( <5)
- the estimated bin error is extremely small compared to the bin content (see [TProfile2D!GetBinError](@ref))
""" TProfile2D!Approximate(this::ByRef1{TProfile2D}, approx::Bool)

# Wrapper of void TH3C::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, bin::Int32)

# Wrapper of void TH3C::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, bin::Int32, w::Float64)

# Wrapper of void TH3C::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3C::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3C}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of void TH3C::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3C}, hnew::ByRef1{TObject})::Nothing
Copy this 3-D histogram structure to newth3.

""" Copy(this::ByConstRef1{TH3C}, hnew::ByRef1{TObject})

# Wrapper of TH3C & TH3C::operator=(const TH3C &)
@trydoc raw"""
    assign(this::ByRef1{TH3C}, h1::ByConstRef1{TH3C})::CxxRef1{TH3C}
Operator =.

""" assign(this::ByRef1{TH3C}, h1::ByConstRef1{TH3C})

# Wrapper of void TH3C::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3C}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3C}, option::ByCopy{String})

# Wrapper of void TH3C::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3C}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3C}, n::Int32)

# Wrapper of void TH3S::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, bin::Int32)

# Wrapper of void TH3S::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, bin::Int32, w::Float64)

# Wrapper of void TH3S::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3S::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3S}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of void TH3S::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3S}, hnew::ByRef1{TObject})::Nothing
Copy this 3-D histogram structure to newth3.

""" Copy(this::ByConstRef1{TH3S}, hnew::ByRef1{TObject})

# Wrapper of TH3S & TH3S::operator=(const TH3S &)
@trydoc raw"""
    assign(this::ByRef1{TH3S}, h1::ByConstRef1{TH3S})::CxxRef1{TH3S}
Operator =.

""" assign(this::ByRef1{TH3S}, h1::ByConstRef1{TH3S})

# Wrapper of void TH3S::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3S}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3S}, option::ByCopy{String})

# Wrapper of void TH3S::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3S}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3S}, n::Int32)

# Wrapper of void TH3I::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, bin::Int32)

# Wrapper of void TH3I::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, bin::Int32, w::Float64)

# Wrapper of void TH3I::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3I::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3I}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of void TH3I::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3I}, hnew::ByRef1{TObject})::Nothing
Copy this 3-D histogram structure to newth3.

""" Copy(this::ByConstRef1{TH3I}, hnew::ByRef1{TObject})

# Wrapper of TH3I & TH3I::operator=(const TH3I &)
@trydoc raw"""
    assign(this::ByRef1{TH3I}, h1::ByConstRef1{TH3I})::CxxRef1{TH3I}
Operator =.

""" assign(this::ByRef1{TH3I}, h1::ByConstRef1{TH3I})

# Wrapper of void TH3I::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3I}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3I}, option::ByCopy{String})

# Wrapper of void TH3I::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3I}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3I}, n::Int32)

# Wrapper of void TH3L::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, bin::Int32)

# Wrapper of void TH3L::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, bin::Int32, w::Float64)

# Wrapper of void TH3L::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3L::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3L}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of void TH3L::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3L}, hnew::ByRef1{TObject})::Nothing
Copy this 3-D histogram structure to newth3.

""" Copy(this::ByConstRef1{TH3L}, hnew::ByRef1{TObject})

# Wrapper of TH3L & TH3L::operator=(const TH3L &)
@trydoc raw"""
    assign(this::ByRef1{TH3L}, h1::ByConstRef1{TH3L})::CxxRef1{TH3L}
Operator =.

""" assign(this::ByRef1{TH3L}, h1::ByConstRef1{TH3L})

# Wrapper of void TH3L::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3L}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3L}, option::ByCopy{String})

# Wrapper of void TH3L::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3L}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3L}, n::Int32)

# Wrapper of void TH3F::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, bin::Int32)

# Wrapper of void TH3F::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, bin::Int32, w::Float64)

# Wrapper of void TH3F::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3F::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3F}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of void TH3F::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3F}, hnew::ByRef1{TObject})::Nothing
Copy this 3-D histogram structure to newth3.

""" Copy(this::ByConstRef1{TH3F}, hnew::ByRef1{TObject})

# Wrapper of TH3F & TH3F::operator=(const TH3F &)
@trydoc raw"""
    assign(this::ByRef1{TH3F}, h1::ByConstRef1{TH3F})::CxxRef1{TH3F}
Operator =.

""" assign(this::ByRef1{TH3F}, h1::ByConstRef1{TH3F})

# Wrapper of void TH3F::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3F}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3F}, option::ByCopy{String})

# Wrapper of void TH3F::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3F}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3F}, n::Int32)

# Wrapper of void TH3D::AddBinContent(Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, bin::Int32)::Nothing
Increment bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, bin::Int32)

# Wrapper of void TH3D::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, bin::Int32, w::Float64)::Nothing
Increment bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, bin::Int32, w::Float64)

# Wrapper of void TH3D::AddBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32)::Nothing
Increment 3D bin content by 1.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of void TH3D::AddBinContent(Int_t, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32, w::Float64)::Nothing
Increment 3D bin content by a weight w.
Passing an out-of-range bin leads to undefined behavior
""" AddBinContent(this::ByRef1{TH3D}, binx::Int32, biny::Int32, binz::Int32, w::Float64)

# Wrapper of void TH3D::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TH3D}, hnew::ByRef1{TObject})::Nothing
Copy this 3-D histogram structure to newth3.

""" Copy(this::ByConstRef1{TH3D}, hnew::ByRef1{TObject})

# Wrapper of TH3D & TH3D::operator=(const TH3D &)
@trydoc raw"""
    assign(this::ByRef1{TH3D}, h1::ByConstRef1{TH3D})::CxxRef1{TH3D}
Operator =.

""" assign(this::ByRef1{TH3D}, h1::ByConstRef1{TH3D})

# Wrapper of void TH3D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TH3D}, option::ByCopy{String})::Nothing
Reset this histogram: contents, errors, etc.

""" Reset(this::ByRef1{TH3D}, option::ByCopy{String})

# Wrapper of void TH3D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TH3D}, n::Int32)::Nothing
Set total number of bins including under/overflow Reallocate bin contents array.

""" SetBinsLength(this::ByRef1{TH3D}, n::Int32)

# Wrapper of bool TBinIterator::operator!=(const TBinIterator &)
@trydoc raw"""
    Base.:(!=)(this::ByConstRef1{TBinIterator}, rhs::ByConstRef1{TBinIterator})::Bool


""" Base.:(!=)(this::ByConstRef1{TBinIterator}, rhs::ByConstRef1{TBinIterator})

# Wrapper of int & TBinIterator::operator*()
@trydoc raw"""
    Base.getindex(this::ByRef1{TBinIterator})::CxxRef2{Int32}


""" Base.getindex(this::ByRef1{TBinIterator})

# Wrapper of TBinIterator & TBinIterator::operator++()
@trydoc raw"""
    inc!(this::ByRef1{TBinIterator})::CxxRef1{TBinIterator}


""" inc!(this::ByRef1{TBinIterator})

# Wrapper of TBinIterator TBinIterator::operator++(int)
@trydoc raw"""
    inc!(this::ByRef1{TBinIterator}, ::Int32)::ByCopy{TBinIterator}


""" inc!(this::ByRef1{TBinIterator}, ::Int32)

# Wrapper of bool TBinIterator::operator==(const TBinIterator &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TBinIterator}, rhs::ByConstRef1{TBinIterator})::Bool


""" Base.:(==)(this::ByConstRef1{TBinIterator}, rhs::ByConstRef1{TBinIterator})

# Wrapper of TBinIterator TBinIterator::End()
@trydoc raw"""
    TBinIterator!End(this::ByRef1{TBinIterator})::ByCopy{TBinIterator}


""" TBinIterator!End(this::ByRef1{TBinIterator})

# Wrapper of Int_t THLimitsFinder::FindGoodLimits(TH1 *, Double_t, Double_t)
@trydoc raw"""
    FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64)::Int32
Compute the best axis limits for the X axis.
If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters.

Example: With the input parameters xmin=-1.467 and xmax=2.344, the function will compute better limits -1.8 and 2.7 and store them in the axis.
""" FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64)

# Wrapper of Int_t THLimitsFinder::FindGoodLimits(TH1 *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64)::Int32
Compute the best axis limits for the X and Y axis.
If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters
""" FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64)

# Wrapper of Int_t THLimitsFinder::FindGoodLimits(TH1 *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)::Int32
Compute the best axis limits for the X, Y and Z axis.
If the bit kIsInteger is set, the number of channels is also recomputed. The axis parameters are replaced by the optimized parameters
""" FindGoodLimits(this::ByRef1{THLimitsFinder}, h::ByPtr1{TH1}, xmin::Float64, xmax::Float64, ymin::Float64, ymax::Float64, zmin::Float64, zmax::Float64)

# Wrapper of THLimitsFinder * THLimitsFinder::GetLimitsFinder()
@trydoc raw"""
    THLimitsFinder!GetLimitsFinder(this::ByRef1{THLimitsFinder})::CxxPtr1{THLimitsFinder}
Return pointer to the current finder.
Create one if none exists Use SetLimitsFinder to set a user defined finder.
""" THLimitsFinder!GetLimitsFinder(this::ByRef1{THLimitsFinder})

# Wrapper of void THLimitsFinder::Optimize(Double_t, Double_t, Int_t, Double_t &, Double_t &, Int_t &, Double_t &, Option_t *)
@trydoc raw"""
    THLimitsFinder!Optimize(this::ByRef1{THLimitsFinder}, A1::Float64, A2::Float64, nold::Int32, BinLow::ByRef2{Float64}, BinHigh::ByRef2{Float64}, nbins::ByRef2{Int32}, BWID::ByRef2{Float64}, option::ByCopy{String})::Nothing
Static function to compute reasonable axis limits.
Input parameters:

## Arguments

- **`A1`** [in], **`A2`** [in], **`BinLow`** [in], **`BinHigh`** [in], **`nold`** [out], **`nbins`** [out], **`BinWidth`** [out], **`option`** [in] 
    : Original axis limits 
    . 
    : Optimized axis limits. They should be initialized by the calling method for instance to 0. 
    . 
    : Original number of divisions. 
    . 
    : Optimized number of divisions. 
    . 
    : Optimized bin width. It should be initialized by the calling method for instance to 0. 
    . 
    : "T" means Time axis.
""" THLimitsFinder!Optimize(this::ByRef1{THLimitsFinder}, A1::Float64, A2::Float64, nold::Int32, BinLow::ByRef2{Float64}, BinHigh::ByRef2{Float64}, nbins::ByRef2{Int32}, BWID::ByRef2{Float64}, option::ByCopy{String})

# Wrapper of void THLimitsFinder::OptimizeLimits(Int_t, Int_t &, Double_t &, Double_t &, Bool_t)
@trydoc raw"""
    THLimitsFinder!OptimizeLimits(this::ByRef1{THLimitsFinder}, nbins::Int32, newbins::ByRef2{Int32}, xmin::ByRef2{Float64}, xmax::ByRef2{Float64}, isInteger::Bool)::Nothing
Optimize axis limits.
When isInter=kTRUE, the function makes an integer binwidth and recompute the number of bins accordingly.
""" THLimitsFinder!OptimizeLimits(this::ByRef1{THLimitsFinder}, nbins::Int32, newbins::ByRef2{Int32}, xmin::ByRef2{Float64}, xmax::ByRef2{Float64}, isInteger::Bool)

# Wrapper of void THLimitsFinder::SetLimitsFinder(THLimitsFinder *)
@trydoc raw"""
    THLimitsFinder!SetLimitsFinder(this::ByRef1{THLimitsFinder}, finder::ByPtr1{THLimitsFinder})::Nothing
This static function can be used to specify a finder derived from [THLimitsFinder](@ref).
The finder may redefine the functions FindGoodLimits. Note that the redefined functions may call [THLimitsFinder!FindGoodLimits](@ref).
""" THLimitsFinder!SetLimitsFinder(this::ByRef1{THLimitsFinder}, finder::ByPtr1{THLimitsFinder})

# Wrapper of void TNDArray::AddAt(ULong64_t, Double_t)
@trydoc raw"""
    AddAt(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)::Nothing


""" AddAt(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)

# Wrapper of Double_t TNDArray::AtAsDouble(ULong64_t)
@trydoc raw"""
    AtAsDouble(this::ByConstRef1{TNDArray}, linidx::UInt64)::Float64


""" AtAsDouble(this::ByConstRef1{TNDArray}, linidx::UInt64)

# Wrapper of Long64_t TNDArray::GetBin(const Int_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{TNDArray}, idx::ByConstPtr2{Int32})::Int64


""" GetBin(this::ByConstRef1{TNDArray}, idx::ByConstPtr2{Int32})

# Wrapper of Long64_t TNDArray::GetCellSize(Int_t)
@trydoc raw"""
    GetCellSize(this::ByConstRef1{TNDArray}, dim::Int32)::Int64


""" GetCellSize(this::ByConstRef1{TNDArray}, dim::Int32)

# Wrapper of Long64_t TNDArray::GetNbins()
@trydoc raw"""
    GetNbins(this::ByConstRef1{TNDArray})::Int64


""" GetNbins(this::ByConstRef1{TNDArray})

# Wrapper of Int_t TNDArray::GetNdimensions()
@trydoc raw"""
    GetNdimensions(this::ByConstRef1{TNDArray})::Int32


""" GetNdimensions(this::ByConstRef1{TNDArray})

# Wrapper of void TNDArray::Init(Int_t, const Int_t *, bool)
@trydoc raw"""
    Init(this::ByRef1{TNDArray}, ndim::Int32, nbins::ByConstPtr2{Int32}, addOverflow::Bool)::Nothing


""" Init(this::ByRef1{TNDArray}, ndim::Int32, nbins::ByConstPtr2{Int32}, addOverflow::Bool)

# Wrapper of void TNDArray::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TNDArray}, option::ByCopy{String})::Nothing


""" Reset(this::ByRef1{TNDArray}, option::ByCopy{String})

# Wrapper of void TNDArray::SetAsDouble(ULong64_t, Double_t)
@trydoc raw"""
    SetAsDouble(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)::Nothing


""" SetAsDouble(this::ByRef1{TNDArray}, linidx::UInt64, value::Float64)

# Wrapper of void THn::AddBinContent(const Int_t *, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!SetBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" AddBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THn::AddBinContent(Long64_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)

# Wrapper of void THn::AddBinError2(Long64_t, Double_t)
@trydoc raw"""
    AddBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)::Nothing


""" AddBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)

# Wrapper of void THn::FillBin(Long64_t, Double_t)
@trydoc raw"""
    FillBin(this::ByRef1{THn}, bin::Int64, w::Float64)::Nothing
Increment the bin content of "bin" by "w", return the bin index.

""" FillBin(this::ByRef1{THn}, bin::Int64, w::Float64)

# Wrapper of const TNDArray & THn::GetArray()
@trydoc raw"""
    GetArray(this::ByConstRef1{THn})::ConstCxxRef1{TNDArray}


""" GetArray(this::ByConstRef1{THn})

# Wrapper of TNDArray & THn::GetArray()
@trydoc raw"""
    GetArray(this::ByRef1{THn})::CxxRef1{TNDArray}


""" GetArray(this::ByRef1{THn})

# Wrapper of Long64_t THn::GetBin(const Double_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{THn}, x::ByConstPtr2{Float64})::Int64


""" GetBin(this::ByConstRef1{THn}, x::ByConstPtr2{Float64})

# Wrapper of Long64_t THn::GetBin(const Double_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THn}, x::ByConstPtr2{Float64}, ::Bool)::Int64


""" GetBin(this::ByRef1{THn}, x::ByConstPtr2{Float64}, ::Bool)

# Wrapper of Long64_t THn::GetBin(const Int_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{THn}, idx::ByConstPtr2{Int32})::Int64


""" GetBin(this::ByConstRef1{THn}, idx::ByConstPtr2{Int32})

# Wrapper of Long64_t THn::GetBin(const Int_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, ::Bool)::Int64


""" GetBin(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, ::Bool)

# Wrapper of Double_t THn::GetBinContent(const Int_t *)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{THn}, idx::ByConstPtr2{Int32})::Float64
Forwards to [THnBase!GetBinContent()](@ref) overload.
Non-virtual, CINT-compatible replacement of a using declaration.
""" GetBinContent(this::ByConstRef1{THn}, idx::ByConstPtr2{Int32})

# Wrapper of Double_t THn::GetBinContent(Long64_t, Int_t *)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{THn}, bin::Int64, idx::ByPtr2{Int32})::Float64
Get the content of bin, and set its index if idx is != 0.

""" GetBinContent(this::ByConstRef1{THn}, bin::Int64, idx::ByPtr2{Int32})

# Wrapper of Double_t THn::GetBinError2(Long64_t)
@trydoc raw"""
    GetBinError2(this::ByConstRef1{THn}, linidx::Int64)::Float64


""" GetBinError2(this::ByConstRef1{THn}, linidx::Int64)

# Wrapper of Long64_t THn::GetNbins()
@trydoc raw"""
    GetNbins(this::ByConstRef1{THn})::Int64


""" GetNbins(this::ByConstRef1{THn})

# Wrapper of THn * THn::Projection(Int_t, const Int_t *, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THn}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})::CxxPtr1{THn}


""" Projection(this::ByConstRef1{THn}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})

# Wrapper of TH3D * THn::Projection(Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THn}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})::CxxPtr1{TH3D}
Forwards to [THnBase!Projection()](@ref).
Non-virtual, as a CINT-compatible replacement of a using declaration.
""" Projection(this::ByConstRef1{THn}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})

# Wrapper of TH1D * THn::Projection(Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THn}, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Forwards to [THnBase!Projection()](@ref).
Non-virtual, as a CINT-compatible replacement of a using declaration.
""" Projection(this::ByConstRef1{THn}, xDim::Int32, option::ByCopy{String})

# Wrapper of TH2D * THn::Projection(Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THn}, yDim::Int32, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH2D}
Forwards to [THnBase!Projection()](@ref).
Non-virtual, as a CINT-compatible replacement of a using declaration.
""" Projection(this::ByConstRef1{THn}, yDim::Int32, xDim::Int32, option::ByCopy{String})

# Wrapper of THn * THn::Rebin(const Int_t *)
@trydoc raw"""
    Rebin(this::ByConstRef1{THn}, group::ByConstPtr2{Int32})::CxxPtr1{THn}


""" Rebin(this::ByConstRef1{THn}, group::ByConstPtr2{Int32})

# Wrapper of THn * THn::Rebin(Int_t)
@trydoc raw"""
    Rebin(this::ByConstRef1{THn}, group::Int32)::CxxPtr1{THn}


""" Rebin(this::ByConstRef1{THn}, group::Int32)

# Wrapper of void THn::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{THn}, option::ByCopy{String})::Nothing
Reset the contents of a [THn](@ref).

""" Reset(this::ByRef1{THn}, option::ByCopy{String})

# Wrapper of void THn::SetBinContent(const Int_t *, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!SetBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" SetBinContent(this::ByRef1{THn}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THn::SetBinContent(Long64_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)::Nothing


""" SetBinContent(this::ByRef1{THn}, bin::Int64, v::Float64)

# Wrapper of void THn::SetBinError2(Long64_t, Double_t)
@trydoc raw"""
    SetBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)::Nothing


""" SetBinError2(this::ByRef1{THn}, bin::Int64, e2::Float64)

# Wrapper of void THn::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THn})::Nothing
Enable calculation of errors.

""" Sumw2(this::ByRef1{THn})

# Wrapper of THn * THn::CreateHn(const char *, const char *, const TH1 *)
@trydoc raw"""
    THn!CreateHn(this::ByRef1{THn}, name::ByCopy{String}, title::ByCopy{String}, h1::ByConstPtr1{TH1})::CxxPtr1{THn}


""" THn!CreateHn(this::ByRef1{THn}, name::ByCopy{String}, title::ByCopy{String}, h1::ByConstPtr1{TH1})

# Wrapper of THn * THn::CreateHn(const char *, const char *, const THnBase *)
@trydoc raw"""
    THn!CreateHn(this::ByRef1{THn}, name::ByCopy{String}, title::ByCopy{String}, hn::ByConstPtr1{THnBase})::CxxPtr1{THn}


""" THn!CreateHn(this::ByRef1{THn}, name::ByCopy{String}, title::ByCopy{String}, hn::ByConstPtr1{THnBase})

# Wrapper of void THnBase::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{THnBase}, hist::ByConstPtr1{TH1}, c::Float64)::Nothing
Fill the [THnBase](@ref) with the bins of hist that have content or error != 0.

""" Add(this::ByRef1{THnBase}, hist::ByConstPtr1{TH1}, c::Float64)

# Wrapper of void THnBase::Add(const THnBase *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)::Nothing
Add contents of h scaled by c to this histogram: this = this + c * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.

""" Add(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)

# Wrapper of void THnBase::AddBinContent(const Int_t *, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnBase}, x::ByConstPtr2{Int32}, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THnBase}, x::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnBase::AddBinContent(Long64_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)

# Wrapper of void THnBase::AddBinError2(Long64_t, Double_t)
@trydoc raw"""
    AddBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)::Nothing


""" AddBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)

# Wrapper of void THnBase::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{THnBase}, b::ByPtr1{TBrowser})::Nothing
Browse a [THnSparse](@ref): create an entry (ROOT!THnSparseBrowsable) for each dimension.

""" Browse(this::ByRef1{THnBase}, b::ByPtr1{TBrowser})

# Wrapper of void THnBase::CalculateErrors(Bool_t)
@trydoc raw"""
    CalculateErrors(this::ByRef1{THnBase}, calc::Bool)::Nothing
Calculate errors (or not if "calc" == kFALSE)

""" CalculateErrors(this::ByRef1{THnBase}, calc::Bool)

# Wrapper of Double_t THnBase::ComputeIntegral()
@trydoc raw"""
    ComputeIntegral(this::ByRef1{THnBase})::Float64
Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions.
This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. 

###Return

1 if success, 0 if integral is zero
""" ComputeIntegral(this::ByRef1{THnBase})

# Wrapper of void THnBase::Divide(const THnBase *)
@trydoc raw"""
    Divide(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})::Nothing
Divide this histogram by h this = this/(h) Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.
The resulting errors are calculated assuming uncorrelated content.
""" Divide(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})

# Wrapper of void THnBase::Divide(const THnBase *, const THnBase *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{THnBase}, h1::ByConstPtr1{THnBase}, h2::ByConstPtr1{THnBase}, c1::Float64, c2::Float64, option::ByCopy{String})::Nothing
Replace contents of this histogram by multiplication of h1 by h2 this = (c1*h1)/(c2*h2) Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.
The resulting errors are calculated assuming uncorrelated content. However, if option ="B" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.
""" Divide(this::ByRef1{THnBase}, h1::ByConstPtr1{THnBase}, h2::ByConstPtr1{THnBase}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Long64_t THnBase::Fill(const Double_t *, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, w::Float64)::Int64


""" Fill(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, w::Float64)

# Wrapper of void THnBase::FillBin(Long64_t, Double_t)
@trydoc raw"""
    FillBin(this::ByRef1{THnBase}, bin::Int64, w::Float64)::Nothing


""" FillBin(this::ByRef1{THnBase}, bin::Int64, w::Float64)

# Wrapper of TFitResultPtr THnBase::Fit(TF1 *, Option_t *, Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{THnBase}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String})::ByCopy{TFitResultPtr}
Fit a [THnSparse](@ref) with function f.
since the data is sparse by default a likelihood fit is performed merging all the regions with empty bins for better performance efficiency

Since the [THnSparse](@ref) is not drawn no graphics options are passed Here is the list of possible options 
```
          = "I"  Use integral of function in bin instead of value at bin center
          = "X"  Use chi2 method (default is log-likelihood method)
          = "U"  Use a User specified fitting algorithm (via SetFCN)
          = "Q"  Quiet mode (minimum printing)
          = "V"  Verbose mode (default is between Q and V)
          = "E"  Perform better Errors estimation using Minos technique
          = "B"  Use this option when you want to fix one or more parameters
                 and the fitting function is like "gaus", "expo", "poln", "landau".
          = "M"  More. Improve fit results
          = "R"  Use the Range specified in the function range 
```
""" Fit(this::ByRef1{THnBase}, f1::ByPtr1{TF1}, option::ByCopy{String}, goption::ByCopy{String})

# Wrapper of TAxis * THnBase::GetAxis(Int_t)
@trydoc raw"""
    GetAxis(this::ByConstRef1{THnBase}, dim::Int32)::CxxPtr1{TAxis}


""" GetAxis(this::ByConstRef1{THnBase}, dim::Int32)

# Wrapper of Long64_t THnBase::GetBin(const Double_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{THnBase}, x::ByConstPtr2{Float64})::Int64


""" GetBin(this::ByConstRef1{THnBase}, x::ByConstPtr2{Float64})

# Wrapper of Long64_t THnBase::GetBin(const Double_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, ::Bool)::Int64


""" GetBin(this::ByRef1{THnBase}, x::ByConstPtr2{Float64}, ::Bool)

# Wrapper of Long64_t THnBase::GetBin(const Int_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{THnBase}, idx::ByConstPtr2{Int32})::Int64


""" GetBin(this::ByConstRef1{THnBase}, idx::ByConstPtr2{Int32})

# Wrapper of Long64_t THnBase::GetBin(const Int_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, ::Bool)::Int64


""" GetBin(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, ::Bool)

# Wrapper of Double_t THnBase::GetBinContent(const Int_t *)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{THnBase}, idx::ByConstPtr2{Int32})::Float64


""" GetBinContent(this::ByConstRef1{THnBase}, idx::ByConstPtr2{Int32})

# Wrapper of Double_t THnBase::GetBinContent(Long64_t, Int_t *)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{THnBase}, bin::Int64, idx::ByPtr2{Int32})::Float64


""" GetBinContent(this::ByConstRef1{THnBase}, bin::Int64, idx::ByPtr2{Int32})

# Wrapper of Double_t THnBase::GetBinError(const Int_t *)
@trydoc raw"""
    GetBinError(this::ByConstRef1{THnBase}, idx::ByConstPtr2{Int32})::Float64


""" GetBinError(this::ByConstRef1{THnBase}, idx::ByConstPtr2{Int32})

# Wrapper of Double_t THnBase::GetBinError(Long64_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{THnBase}, linidx::Int64)::Float64


""" GetBinError(this::ByConstRef1{THnBase}, linidx::Int64)

# Wrapper of Double_t THnBase::GetBinError2(Long64_t)
@trydoc raw"""
    GetBinError2(this::ByConstRef1{THnBase}, linidx::Int64)::Float64


""" GetBinError2(this::ByConstRef1{THnBase}, linidx::Int64)

# Wrapper of Bool_t THnBase::GetCalculateErrors()
@trydoc raw"""
    GetCalculateErrors(this::ByConstRef1{THnBase})::Bool


""" GetCalculateErrors(this::ByConstRef1{THnBase})

# Wrapper of Double_t THnBase::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{THnBase})::Float64


""" GetEntries(this::ByConstRef1{THnBase})

# Wrapper of TObjArray * THnBase::GetListOfAxes()
@trydoc raw"""
    GetListOfAxes(this::ByRef1{THnBase})::CxxPtr1{TObjArray}


""" GetListOfAxes(this::ByRef1{THnBase})

# Wrapper of const TObjArray * THnBase::GetListOfAxes()
@trydoc raw"""
    GetListOfAxes(this::ByConstRef1{THnBase})::ConstCxxPtr1{TObjArray}


""" GetListOfAxes(this::ByConstRef1{THnBase})

# Wrapper of TList * THnBase::GetListOfFunctions()
@trydoc raw"""
    GetListOfFunctions(this::ByRef1{THnBase})::CxxPtr1{TList}


""" GetListOfFunctions(this::ByRef1{THnBase})

# Wrapper of Long64_t THnBase::GetNbins()
@trydoc raw"""
    GetNbins(this::ByConstRef1{THnBase})::Int64


""" GetNbins(this::ByConstRef1{THnBase})

# Wrapper of Int_t THnBase::GetNdimensions()
@trydoc raw"""
    GetNdimensions(this::ByConstRef1{THnBase})::Int32


""" GetNdimensions(this::ByConstRef1{THnBase})

# Wrapper of void THnBase::GetRandom(Double_t *, Bool_t)
@trydoc raw"""
    GetRandom(this::ByRef1{THnBase}, rand::ByPtr2{Float64}, subBinRandom::Bool)::Nothing
Generate an n-dimensional random tuple based on the histogrammed distribution.
If subBinRandom, the returned tuple will be additionally randomly distributed within the randomized bin, using a flat distribution.
""" GetRandom(this::ByRef1{THnBase}, rand::ByPtr2{Float64}, subBinRandom::Bool)

# Wrapper of Double_t THnBase::GetSumw()
@trydoc raw"""
    GetSumw(this::ByConstRef1{THnBase})::Float64


""" GetSumw(this::ByConstRef1{THnBase})

# Wrapper of Double_t THnBase::GetSumw2()
@trydoc raw"""
    GetSumw2(this::ByConstRef1{THnBase})::Float64


""" GetSumw2(this::ByConstRef1{THnBase})

# Wrapper of Double_t THnBase::GetSumwx(Int_t)
@trydoc raw"""
    GetSumwx(this::ByConstRef1{THnBase}, dim::Int32)::Float64


""" GetSumwx(this::ByConstRef1{THnBase}, dim::Int32)

# Wrapper of Double_t THnBase::GetSumwx2(Int_t)
@trydoc raw"""
    GetSumwx2(this::ByConstRef1{THnBase}, dim::Int32)::Float64


""" GetSumwx2(this::ByConstRef1{THnBase}, dim::Int32)

# Wrapper of Double_t THnBase::GetWeightSum()
@trydoc raw"""
    GetWeightSum(this::ByConstRef1{THnBase})::Float64


""" GetWeightSum(this::ByConstRef1{THnBase})

# Wrapper of Bool_t THnBase::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{THnBase})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{THnBase})

# Wrapper of Bool_t THnBase::IsInRange(Int_t *)
@trydoc raw"""
    IsInRange(this::ByConstRef1{THnBase}, coord::ByPtr2{Int32})::Bool
Check whether bin coord is in range, as defined by [TAxis!SetRange()](@ref).
""" IsInRange(this::ByConstRef1{THnBase}, coord::ByPtr2{Int32})

# Wrapper of Long64_t THnBase::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{THnBase}, list::ByPtr1{TCollection})::Int64
Merge this with a list of [THnBase](@ref)'s.
All [THnBase](@ref)'s provided in the list must have the same bin layout!
""" Merge(this::ByRef1{THnBase}, list::ByPtr1{TCollection})

# Wrapper of void THnBase::Multiply(const THnBase *)
@trydoc raw"""
    Multiply(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})::Nothing
Multiply this histogram by histogram h this = this * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.

""" Multiply(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase})

# Wrapper of void THnBase::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{THnBase}, f::ByPtr1{TF1}, c::Float64)::Nothing
Performs the operation: this = this*c*f1 if errors are defined, errors are also recalculated.
Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after calling [Multiply()](@ref)
""" Multiply(this::ByRef1{THnBase}, f::ByPtr1{TF1}, c::Float64)

# Wrapper of void THnBase::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{THnBase}, option::ByCopy{String})::Nothing
Print a [THnBase](@ref).
If "option" contains:

- 'a': print axis details
- 'm': print memory usage
- 's': print statistics
- 'c': print its content, too (this can generate a LOT of output!) Other options are forwarded to [PrintEntries()](@ref).
""" Print(this::ByConstRef1{THnBase}, option::ByCopy{String})

# Wrapper of void THnBase::PrintBin(Int_t *, Option_t *)
@trydoc raw"""
    PrintBin(this::ByConstRef1{THnBase}, coord::ByPtr2{Int32}, options::ByCopy{String})::Nothing


""" PrintBin(this::ByConstRef1{THnBase}, coord::ByPtr2{Int32}, options::ByCopy{String})

# Wrapper of void THnBase::PrintBin(Long64_t, Option_t *)
@trydoc raw"""
    PrintBin(this::ByConstRef1{THnBase}, idx::Int64, options::ByCopy{String})::Nothing
Print bin with linex index "idx".
For valid options see PrintBin(Long64_t idx, Int_t* bin, Option_t* options).
""" PrintBin(this::ByConstRef1{THnBase}, idx::Int64, options::ByCopy{String})

# Wrapper of void THnBase::PrintEntries(Long64_t, Long64_t, Option_t *)
@trydoc raw"""
    PrintEntries(this::ByConstRef1{THnBase}, from::Int64, howmany::Int64, options::ByCopy{String})::Nothing
Print "howmany" entries starting at "from".
If "howmany" is -1, print all. If "options" contains:

- 'x': print in the order of axis bins, i.e. (0,0,...,0), (0,0,...,1),...
- '0': only print bins with content != 0
""" PrintEntries(this::ByConstRef1{THnBase}, from::Int64, howmany::Int64, options::ByCopy{String})

# Wrapper of TH3D * THnBase::Projection(Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnBase}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})::CxxPtr1{TH3D}
Project all bins into a 3-dimensional histogram, keeping only axes "xDim", "yDim", and "zDim".
If "option" contains:

- "E" errors will be calculated.
- "A" ranges of the taget axes will be ignored.
- "O" original axis range of the taget axes will be kept, but only bins inside the selected range will be filled.
""" Projection(this::ByConstRef1{THnBase}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})

# Wrapper of TH1D * THnBase::Projection(Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnBase}, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Project all bins into a 1-dimensional histogram, keeping only axis "xDim".
If "option" contains:

- "E" errors will be calculated.
- "A" ranges of the taget axes will be ignored.
- "O" original axis range of the taget axes will be kept, but only bins inside the selected range will be filled.
""" Projection(this::ByConstRef1{THnBase}, xDim::Int32, option::ByCopy{String})

# Wrapper of TH2D * THnBase::Projection(Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnBase}, yDim::Int32, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH2D}
Project all bins into a 2-dimensional histogram, keeping only axes "xDim" and "yDim".
WARNING: just like [TH3!Project3D](@ref)("yx") and [TTree!Draw](@ref)("y:x"), Projection(y,x) uses the first argument to define the y-axis and the second for the x-axis!

If "option" contains "E" errors will be calculated. "A" ranges of the taget axes will be ignored.
""" Projection(this::ByConstRef1{THnBase}, yDim::Int32, xDim::Int32, option::ByCopy{String})

# Wrapper of THnBase * THnBase::ProjectionND(Int_t, const Int_t *, Option_t *)
@trydoc raw"""
    ProjectionND(this::ByConstRef1{THnBase}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})::CxxPtr1{THnBase}


""" ProjectionND(this::ByConstRef1{THnBase}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})

# Wrapper of void THnBase::RebinnedAdd(const THnBase *, Double_t)
@trydoc raw"""
    RebinnedAdd(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)::Nothing
Add contents of h scaled by c to this histogram: this = this + c * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set.
In contrast to [Add()](@ref), [RebinnedAdd()](@ref) does not require consistent binning of this and h; instead, each bin's center is used to determine the target bin.
""" RebinnedAdd(this::ByRef1{THnBase}, h::ByConstPtr1{THnBase}, c::Float64)

# Wrapper of void THnBase::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{THnBase}, option::ByCopy{String})::Nothing


""" Reset(this::ByRef1{THnBase}, option::ByCopy{String})

# Wrapper of void THnBase::Scale(Double_t)
@trydoc raw"""
    Scale(this::ByRef1{THnBase}, c::Float64)::Nothing
Scale contents and errors of this histogram by c: this = this * c It does not modify the histogram's number of entries.

""" Scale(this::ByRef1{THnBase}, c::Float64)

# Wrapper of void THnBase::SetBinContent(const Int_t *, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing


""" SetBinContent(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnBase::SetBinContent(Long64_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)::Nothing


""" SetBinContent(this::ByRef1{THnBase}, bin::Int64, v::Float64)

# Wrapper of void THnBase::SetBinEdges(Int_t, const Double_t *)
@trydoc raw"""
    SetBinEdges(this::ByRef1{THnBase}, idim::Int32, bins::ByConstPtr2{Float64})::Nothing
Set the axis # of bins and bin limits on dimension idim.

""" SetBinEdges(this::ByRef1{THnBase}, idim::Int32, bins::ByConstPtr2{Float64})

# Wrapper of void THnBase::SetBinError(const Int_t *, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, e::Float64)::Nothing


""" SetBinError(this::ByRef1{THnBase}, idx::ByConstPtr2{Int32}, e::Float64)

# Wrapper of void THnBase::SetBinError(Long64_t, Double_t)
@trydoc raw"""
    SetBinError(this::ByRef1{THnBase}, bin::Int64, e::Float64)::Nothing


""" SetBinError(this::ByRef1{THnBase}, bin::Int64, e::Float64)

# Wrapper of void THnBase::SetBinError2(Long64_t, Double_t)
@trydoc raw"""
    SetBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)::Nothing


""" SetBinError2(this::ByRef1{THnBase}, bin::Int64, e2::Float64)

# Wrapper of void THnBase::SetEntries(Double_t)
@trydoc raw"""
    SetEntries(this::ByRef1{THnBase}, entries::Float64)::Nothing


""" SetEntries(this::ByRef1{THnBase}, entries::Float64)

# Wrapper of void THnBase::SetTitle(const char *)
@trydoc raw"""
    SetTitle(this::ByRef1{THnBase}, title::ByCopy{String})::Nothing
Change (i.e.
set) the title.

If title is in the form "stringt;string0;string1;string2 ..." the histogram title is set to stringt, the title of axis0 to string0, of axis1 to string1, of axis2 to string2, etc, just like it is done for TH1/TH2/TH3. To insert the character ";" in one of the titles, one should use "#;" or "#semicolon".
""" SetTitle(this::ByRef1{THnBase}, title::ByCopy{String})

# Wrapper of void THnBase::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THnBase})::Nothing


""" Sumw2(this::ByRef1{THnBase})

# Wrapper of void THnChain::AddFile(const char *)
@trydoc raw"""
    AddFile(this::ByRef1{THnChain}, fileName::ByCopy{String})::Nothing
Add a new file to this chain.
## Arguments

- **`fileName`** 
    path of the file to add
""" AddFile(this::ByRef1{THnChain}, fileName::ByCopy{String})

# Wrapper of TAxis * THnChain::GetAxis(Int_t)
@trydoc raw"""
    GetAxis(this::ByConstRef1{THnChain}, i::Int32)::CxxPtr1{TAxis}
Get an axis from the histogram.
## Arguments

- **`i`** 
    index of the axis to retrieve
    

This function requires that a file containing the histogram was already added with `AddFile`.

Properties set on the axis returned by `GetAxis` are propagated to all histograms in the chain, so it can e.g. be used to set ranges for projections.
""" GetAxis(this::ByConstRef1{THnChain}, i::Int32)

# Wrapper of TH3 * THnChain::Projection(Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnChain}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})::CxxPtr1{TH3}
See `THnBase!Projection` for the intended behavior.

""" Projection(this::ByConstRef1{THnChain}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})

# Wrapper of TH1 * THnChain::Projection(Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnChain}, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH1}
See `THnBase!Projection` for the intended behavior.

""" Projection(this::ByConstRef1{THnChain}, xDim::Int32, option::ByCopy{String})

# Wrapper of TH2 * THnChain::Projection(Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnChain}, yDim::Int32, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH2}
See `THnBase!Projection` for the intended behavior.

""" Projection(this::ByConstRef1{THnChain}, yDim::Int32, xDim::Int32, option::ByCopy{String})

# Wrapper of THnBase * THnChain::ProjectionND(Int_t, const Int_t *, Option_t *)
@trydoc raw"""
    ProjectionND(this::ByConstRef1{THnChain}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})::CxxPtr1{THnBase}
See `THnBase!Projection` for the intended behavior.

""" ProjectionND(this::ByConstRef1{THnChain}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})

# Wrapper of Int_t THnIter::GetCoord(Int_t)
@trydoc raw"""
    GetCoord(this::ByConstRef1{THnIter}, dim::Int32)::Int32


""" GetCoord(this::ByConstRef1{THnIter}, dim::Int32)

# Wrapper of Bool_t THnIter::HaveSkippedBin()
@trydoc raw"""
    HaveSkippedBin(this::ByConstRef1{THnIter})::Bool


""" HaveSkippedBin(this::ByConstRef1{THnIter})

# Wrapper of Long64_t THnIter::Next(Int_t *)
@trydoc raw"""
    Next(this::ByRef1{THnIter}, coord::ByPtr2{Int32})::Int64
Return the next bin's index.
If provided, set coord to that bin's coordinates (bin indexes). I.e. coord must point to Int_t[hist->GetNdimensions()] Returns -1 when all bins have been visited.
""" Next(this::ByRef1{THnIter}, coord::ByPtr2{Int32})

# Wrapper of Bool_t THnIter::RespectsAxisRange()
@trydoc raw"""
    RespectsAxisRange(this::ByConstRef1{THnIter})::Bool


""" RespectsAxisRange(this::ByConstRef1{THnIter})

# Wrapper of void THnSparse::AddBinContent(const Int_t *, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!AddBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" AddBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnSparse::AddBinContent(Long64_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)::Nothing
Add "v" to the content of bin with index "bin".

""" AddBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)

# Wrapper of void THnSparse::AddBinError2(Long64_t, Double_t)
@trydoc raw"""
    AddBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)::Nothing
Add "e" to error of bin with index "bin", enable errors if needed.

""" AddBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)

# Wrapper of Long64_t THnSparse::GetBin(const Double_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{THnSparse}, x::ByConstPtr2{Float64})::Int64


""" GetBin(this::ByConstRef1{THnSparse}, x::ByConstPtr2{Float64})

# Wrapper of Long64_t THnSparse::GetBin(const Double_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnSparse}, x::ByConstPtr2{Float64}, allocate::Bool)::Int64
Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and "allocate" is true.

""" GetBin(this::ByRef1{THnSparse}, x::ByConstPtr2{Float64}, allocate::Bool)

# Wrapper of Long64_t THnSparse::GetBin(const Int_t *)
@trydoc raw"""
    GetBin(this::ByConstRef1{THnSparse}, idx::ByConstPtr2{Int32})::Int64


""" GetBin(this::ByConstRef1{THnSparse}, idx::ByConstPtr2{Int32})

# Wrapper of Long64_t THnSparse::GetBin(const Int_t *, Bool_t)
@trydoc raw"""
    GetBin(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, allocate::Bool)::Int64
Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and "allocate" is true.

""" GetBin(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, allocate::Bool)

# Wrapper of Double_t THnSparse::GetBinContent(const Int_t *)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{THnSparse}, idx::ByConstPtr2{Int32})::Float64
Forwards to [THnBase!GetBinContent()](@ref) overload.
Non-virtual, CINT-compatible replacement of a using declaration.
""" GetBinContent(this::ByConstRef1{THnSparse}, idx::ByConstPtr2{Int32})

# Wrapper of Double_t THnSparse::GetBinContent(Long64_t, Int_t *)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{THnSparse}, bin::Int64, idx::ByPtr2{Int32})::Float64
Return the content of the filled bin number "idx".
If coord is non-null, it will contain the bin's coordinates for each axis that correspond to the bin.
""" GetBinContent(this::ByConstRef1{THnSparse}, bin::Int64, idx::ByPtr2{Int32})

# Wrapper of Double_t THnSparse::GetBinError2(Long64_t)
@trydoc raw"""
    GetBinError2(this::ByConstRef1{THnSparse}, linidx::Int64)::Float64
Get square of the error of bin addressed by linidx as $\sum weight^{2}$ If errors are not enabled (via [Sumw2()](@ref) or [CalculateErrors()](@ref)) return contents.

""" GetBinError2(this::ByConstRef1{THnSparse}, linidx::Int64)

# Wrapper of Int_t THnSparse::GetChunkSize()
@trydoc raw"""
    GetChunkSize(this::ByConstRef1{THnSparse})::Int32


""" GetChunkSize(this::ByConstRef1{THnSparse})

# Wrapper of Long64_t THnSparse::GetNbins()
@trydoc raw"""
    GetNbins(this::ByConstRef1{THnSparse})::Int64


""" GetNbins(this::ByConstRef1{THnSparse})

# Wrapper of Int_t THnSparse::GetNChunks()
@trydoc raw"""
    GetNChunks(this::ByConstRef1{THnSparse})::Int32


""" GetNChunks(this::ByConstRef1{THnSparse})

# Wrapper of Double_t THnSparse::GetSparseFractionBins()
@trydoc raw"""
    GetSparseFractionBins(this::ByConstRef1{THnSparse})::Float64
Return the amount of filled bins over all bins.

""" GetSparseFractionBins(this::ByConstRef1{THnSparse})

# Wrapper of Double_t THnSparse::GetSparseFractionMem()
@trydoc raw"""
    GetSparseFractionMem(this::ByConstRef1{THnSparse})::Float64
Return the amount of used memory over memory that would be used by a non-sparse n-dimensional histogram.
The value is approximate.
""" GetSparseFractionMem(this::ByConstRef1{THnSparse})

# Wrapper of THnSparse * THnSparse::Projection(Int_t, const Int_t *, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnSparse}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})::CxxPtr1{THnSparse}


""" Projection(this::ByConstRef1{THnSparse}, ndim::Int32, dim::ByConstPtr2{Int32}, option::ByCopy{String})

# Wrapper of TH3D * THnSparse::Projection(Int_t, Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnSparse}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})::CxxPtr1{TH3D}
Forwards to [THnBase!Projection()](@ref).
Non-virtual, as a CINT-compatible replacement of a using declaration.
""" Projection(this::ByConstRef1{THnSparse}, xDim::Int32, yDim::Int32, zDim::Int32, option::ByCopy{String})

# Wrapper of TH1D * THnSparse::Projection(Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnSparse}, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH1D}
Forwards to [THnBase!Projection()](@ref).
Non-virtual, as a CINT-compatible replacement of a using declaration.
""" Projection(this::ByConstRef1{THnSparse}, xDim::Int32, option::ByCopy{String})

# Wrapper of TH2D * THnSparse::Projection(Int_t, Int_t, Option_t *)
@trydoc raw"""
    Projection(this::ByConstRef1{THnSparse}, yDim::Int32, xDim::Int32, option::ByCopy{String})::CxxPtr1{TH2D}
Forwards to [THnBase!Projection()](@ref).
Non-virtual, as a CINT-compatible replacement of a using declaration.
""" Projection(this::ByConstRef1{THnSparse}, yDim::Int32, xDim::Int32, option::ByCopy{String})

# Wrapper of THnSparse * THnSparse::Rebin(const Int_t *)
@trydoc raw"""
    Rebin(this::ByConstRef1{THnSparse}, group::ByConstPtr2{Int32})::CxxPtr1{THnSparse}


""" Rebin(this::ByConstRef1{THnSparse}, group::ByConstPtr2{Int32})

# Wrapper of THnSparse * THnSparse::Rebin(Int_t)
@trydoc raw"""
    Rebin(this::ByConstRef1{THnSparse}, group::Int32)::CxxPtr1{THnSparse}


""" Rebin(this::ByConstRef1{THnSparse}, group::Int32)

# Wrapper of void THnSparse::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{THnSparse}, option::ByCopy{String})::Nothing
Clear the histogram.

""" Reset(this::ByRef1{THnSparse}, option::ByCopy{String})

# Wrapper of void THnSparse::SetBinContent(const Int_t *, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)::Nothing
Forwards to [THnBase!SetBinContent()](@ref).
Non-virtual, CINT-compatible replacement of a using declaration.
""" SetBinContent(this::ByRef1{THnSparse}, idx::ByConstPtr2{Int32}, v::Float64)

# Wrapper of void THnSparse::SetBinContent(Long64_t, Double_t)
@trydoc raw"""
    SetBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)::Nothing
Set content of bin with index "bin" to "v".

""" SetBinContent(this::ByRef1{THnSparse}, bin::Int64, v::Float64)

# Wrapper of void THnSparse::SetBinError2(Long64_t, Double_t)
@trydoc raw"""
    SetBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)::Nothing
Set error of bin with index "bin" to "e", enable errors if needed.

""" SetBinError2(this::ByRef1{THnSparse}, bin::Int64, e2::Float64)

# Wrapper of void THnSparse::SetFilledBins(Long64_t)
@trydoc raw"""
    SetFilledBins(this::ByRef1{THnSparse}, nbins::Int64)::Nothing


""" SetFilledBins(this::ByRef1{THnSparse}, nbins::Int64)

# Wrapper of void THnSparse::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THnSparse})::Nothing
Enable calculation of errors.

""" Sumw2(this::ByRef1{THnSparse})

# Wrapper of THnSparse * THnSparse::CreateSparse(const char *, const char *, const TH1 *, Int_t)
@trydoc raw"""
    THnSparse!CreateSparse(this::ByRef1{THnSparse}, name::ByCopy{String}, title::ByCopy{String}, h1::ByConstPtr1{TH1}, chunkSize::Int32)::CxxPtr1{THnSparse}


""" THnSparse!CreateSparse(this::ByRef1{THnSparse}, name::ByCopy{String}, title::ByCopy{String}, h1::ByConstPtr1{TH1}, chunkSize::Int32)

# Wrapper of THnSparse * THnSparse::CreateSparse(const char *, const char *, const THnBase *, Int_t)
@trydoc raw"""
    THnSparse!CreateSparse(this::ByRef1{THnSparse}, name::ByCopy{String}, title::ByCopy{String}, hn::ByConstPtr1{THnBase}, chunkSize::Int32)::CxxPtr1{THnSparse}


""" THnSparse!CreateSparse(this::ByRef1{THnSparse}, name::ByCopy{String}, title::ByCopy{String}, hn::ByConstPtr1{THnBase}, chunkSize::Int32)

# Wrapper of void THnSparseArrayChunk::AddBin(Int_t, const Char_t *)
@trydoc raw"""
    AddBin(this::ByRef1{THnSparseArrayChunk}, idx::Int32, idxbuf::ByCopy{String})::Nothing
Create a new bin in this chunk.

""" AddBin(this::ByRef1{THnSparseArrayChunk}, idx::Int32, idxbuf::ByCopy{String})

# Wrapper of void THnSparseArrayChunk::AddBinContent(Int_t, Double_t)
@trydoc raw"""
    AddBinContent(this::ByRef1{THnSparseArrayChunk}, idx::Int32, v::Float64)::Nothing


""" AddBinContent(this::ByRef1{THnSparseArrayChunk}, idx::Int32, v::Float64)

# Wrapper of Int_t THnSparseArrayChunk::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{THnSparseArrayChunk})::Int32


""" GetEntries(this::ByConstRef1{THnSparseArrayChunk})

# Wrapper of Bool_t THnSparseArrayChunk::Matches(Int_t, const Char_t *)
@trydoc raw"""
    Matches(this::ByConstRef1{THnSparseArrayChunk}, idx::Int32, idxbuf::ByCopy{String})::Bool
Check whether bin at idx batches idxbuf.
If we don't store indexes we trust the caller that it does match, see comment in [THnSparseCompactBinCoord!GetHash()](@ref).
""" Matches(this::ByConstRef1{THnSparseArrayChunk}, idx::Int32, idxbuf::ByCopy{String})

# Wrapper of void THnSparseArrayChunk::Sumw2()
@trydoc raw"""
    Sumw2(this::ByRef1{THnSparseArrayChunk})::Nothing
Turn on support of errors.

""" Sumw2(this::ByRef1{THnSparseArrayChunk})

# Wrapper of void THStack::Add(TH1 *, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{THStack}, h::ByPtr1{TH1}, option::ByCopy{String})::Nothing
Add a new histogram to the list.
Only 1-d and 2-d histograms currently supported. A drawing option may be specified
""" Add(this::ByRef1{THStack}, h::ByPtr1{TH1}, option::ByCopy{String})

# Wrapper of void THStack::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{THStack}, b::ByPtr1{TBrowser})::Nothing
Browse.

""" Browse(this::ByRef1{THStack}, b::ByPtr1{TBrowser})

# Wrapper of Int_t THStack::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{THStack}, px::Int32, py::Int32)::Int32
Compute distance from point px, py to each graph.

""" DistancetoPrimitive(this::ByRef1{THStack}, px::Int32, py::Int32)

# Wrapper of void THStack::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{THStack}, chopt::ByCopy{String})::Nothing
Draw this stack with its current attributes.
Options to draw histograms are described in [THistPainter!Paint](@ref) By default (if the option "nostack" is not specified), histograms will be painted stacked on top of each other.
""" Draw(this::ByRef1{THStack}, chopt::ByCopy{String})

# Wrapper of TH1 * THStack::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByConstRef1{THStack})::CxxPtr1{TH1}
Returns a pointer to the histogram used to draw the axis.
Takes into account the two following cases: 1- option 'A' was specified in [THStack!Draw](@ref). Return fHistogram 2- user had called [TPad!DrawFrame](@ref). return pointer to hframe histogram

IMPORTANT NOTES

- You must call Draw before calling this function. The returned histogram depends on the selected Draw options.
- This function returns a pointer to an intermediate fixed bin size histogram used to set the range and for picking. You cannot use this histogram to return the bin information. You must get a pointer to one of the histograms in the stack, the first one, for example.
""" GetHistogram(this::ByConstRef1{THStack})

# Wrapper of TList * THStack::GetHists()
@trydoc raw"""
    GetHists(this::ByConstRef1{THStack})::CxxPtr1{TList}


""" GetHists(this::ByConstRef1{THStack})

# Wrapper of Double_t THStack::GetMaximum(Option_t *, Double_t)
@trydoc raw"""
    GetMaximum(this::ByRef1{THStack}, option::ByCopy{String}, maxval::Float64)::Float64
Returns the maximum of all added histograms smaller than maxval.
Returns the maximum of all histograms, smaller than maxval, if option "nostack".
""" GetMaximum(this::ByRef1{THStack}, option::ByCopy{String}, maxval::Float64)

# Wrapper of Double_t THStack::GetMinimum(Option_t *, Double_t)
@trydoc raw"""
    GetMinimum(this::ByRef1{THStack}, option::ByCopy{String}, minval::Float64)::Float64
Returns the minimum of all added histograms larger than minval.
Returns the minimum of all histograms, larger than minval, if option "nostack".
""" GetMinimum(this::ByRef1{THStack}, option::ByCopy{String}, minval::Float64)

# Wrapper of Int_t THStack::GetNhists()
@trydoc raw"""
    GetNhists(this::ByConstRef1{THStack})::Int32
Return the number of histograms in the stack.

""" GetNhists(this::ByConstRef1{THStack})

# Wrapper of TObjArray * THStack::GetStack()
@trydoc raw"""
    GetStack(this::ByRef1{THStack})::CxxPtr1{TObjArray}
Return pointer to Stack. Build it if not yet done.

""" GetStack(this::ByRef1{THStack})

# Wrapper of TAxis * THStack::GetXaxis()
@trydoc raw"""
    GetXaxis(this::ByConstRef1{THStack})::CxxPtr1{TAxis}
Get the x-axis of the histogram used to draw the stack.
IMPORTANT NOTE You must call Draw before calling this function. The returned histogram depends on the selected Draw options.
""" GetXaxis(this::ByConstRef1{THStack})

# Wrapper of TAxis * THStack::GetYaxis()
@trydoc raw"""
    GetYaxis(this::ByConstRef1{THStack})::CxxPtr1{TAxis}
Get the y-axis of the histogram used to draw the stack.
IMPORTANT NOTE You must call Draw before calling this function. The returned histogram depends on the selected Draw options.
""" GetYaxis(this::ByConstRef1{THStack})

# Wrapper of TAxis * THStack::GetZaxis()
@trydoc raw"""
    GetZaxis(this::ByConstRef1{THStack})::CxxPtr1{TAxis}
Get the z-axis of the histogram used to draw the stack.
IMPORTANT NOTE You must call Draw before calling this function. The returned histogram depends on the selected Draw options.
""" GetZaxis(this::ByConstRef1{THStack})

# Wrapper of void THStack::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{THStack}, option::ByCopy{String})::Nothing
List histograms in the stack.

""" ls(this::ByConstRef1{THStack}, option::ByCopy{String})

# Wrapper of void THStack::Modified()
@trydoc raw"""
    Modified(this::ByRef1{THStack})::Nothing
Note: this method invalidates the sum of histograms.

""" Modified(this::ByRef1{THStack})

# Wrapper of void THStack::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{THStack}, chopt::ByCopy{String})::Nothing
[Paint the list of histograms.](@ref)

""" Paint(this::ByRef1{THStack}, chopt::ByCopy{String})

# Wrapper of void THStack::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{THStack}, chopt::ByCopy{String})::Nothing
Print the list of histograms.

""" Print(this::ByConstRef1{THStack}, chopt::ByCopy{String})

# Wrapper of void THStack::RecursiveRemove(TObject *)
@trydoc raw"""
    RecursiveRemove(this::ByRef1{THStack}, obj::ByPtr1{TObject})::Nothing
Recursively remove the object `obj` from the list of histograms.

""" RecursiveRemove(this::ByRef1{THStack}, obj::ByPtr1{TObject})

# Wrapper of void THStack::SetHistogram(TH1 *)
@trydoc raw"""
    SetHistogram(this::ByRef1{THStack}, h::ByPtr1{TH1})::Nothing


""" SetHistogram(this::ByRef1{THStack}, h::ByPtr1{TH1})

# Wrapper of void THStack::SetMaximum(Double_t)
@trydoc raw"""
    SetMaximum(this::ByRef1{THStack}, maximum::Float64)::Nothing
Set maximum.

""" SetMaximum(this::ByRef1{THStack}, maximum::Float64)

# Wrapper of void THStack::SetMinimum(Double_t)
@trydoc raw"""
    SetMinimum(this::ByRef1{THStack}, minimum::Float64)::Nothing
Set minimum.

""" SetMinimum(this::ByRef1{THStack}, minimum::Float64)

# Wrapper of void TKDE::Draw(const Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TKDE}, option::ByCopy{String})::Nothing
Draws either the KDE functions or its errors.

""" Draw(this::ByRef1{TKDE}, option::ByCopy{String})

# Wrapper of void TKDE::Fill(Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TKDE}, data::Float64)::Nothing


""" Fill(this::ByRef1{TKDE}, data::Float64)

# Wrapper of void TKDE::Fill(Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TKDE}, data::Float64, weight::Float64)::Nothing


""" Fill(this::ByRef1{TKDE}, data::Float64, weight::Float64)

# Wrapper of const Double_t * TKDE::GetAdaptiveWeights()
@trydoc raw"""
    GetAdaptiveWeights(this::ByConstRef1{TKDE})::ConstCxxPtr2{Float64}


""" GetAdaptiveWeights(this::ByConstRef1{TKDE})

# Wrapper of TF1 * TKDE::GetApproximateBias(UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetApproximateBias(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetApproximateBias(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of Double_t TKDE::GetBias(Double_t)
@trydoc raw"""
    GetBias(this::ByConstRef1{TKDE}, x::Float64)::Float64


""" GetBias(this::ByConstRef1{TKDE}, x::Float64)

# Wrapper of Double_t TKDE::GetError(Double_t)
@trydoc raw"""
    GetError(this::ByConstRef1{TKDE}, x::Float64)::Float64


""" GetError(this::ByConstRef1{TKDE}, x::Float64)

# Wrapper of Double_t TKDE::GetFixedWeight()
@trydoc raw"""
    GetFixedWeight(this::ByConstRef1{TKDE})::Float64


""" GetFixedWeight(this::ByConstRef1{TKDE})

# Wrapper of TF1 * TKDE::GetFunction(UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetFunction(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetFunction(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of TGraphErrors * TKDE::GetGraphWithErrors(UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetGraphWithErrors(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TGraphErrors}
return a [TGraphErrors](@ref) with the KDE values and errors The return object is managed by the user

""" GetGraphWithErrors(this::ByRef1{TKDE}, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of TF1 * TKDE::GetLowerFunction(Double_t, UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetLowerFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetLowerFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of Double_t TKDE::GetMean()
@trydoc raw"""
    GetMean(this::ByConstRef1{TKDE})::Float64


""" GetMean(this::ByConstRef1{TKDE})

# Wrapper of Double_t TKDE::GetRAMISE()
@trydoc raw"""
    GetRAMISE(this::ByConstRef1{TKDE})::Float64


""" GetRAMISE(this::ByConstRef1{TKDE})

# Wrapper of Double_t TKDE::GetSigma()
@trydoc raw"""
    GetSigma(this::ByConstRef1{TKDE})::Float64


""" GetSigma(this::ByConstRef1{TKDE})

# Wrapper of TF1 * TKDE::GetUpperFunction(Double_t, UInt_t, Double_t, Double_t)
@trydoc raw"""
    GetUpperFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)::CxxPtr1{TF1}


""" GetUpperFunction(this::ByRef1{TKDE}, confidenceLevel::Float64, npx::UInt32, xMin::Float64, xMax::Float64)

# Wrapper of Double_t TKDE::GetValue(Double_t)
@trydoc raw"""
    GetValue(this::ByConstRef1{TKDE}, x::Float64)::Float64


""" GetValue(this::ByConstRef1{TKDE}, x::Float64)

# Wrapper of Double_t TKDE::operator()(const Double_t *, const Double_t *)
@trydoc raw"""
    paren(this::ByConstRef1{TKDE}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})::Float64


""" paren(this::ByConstRef1{TKDE}, x::ByConstPtr2{Float64}, p::ByConstPtr2{Float64})

# Wrapper of Double_t TKDE::operator()(Double_t)
@trydoc raw"""
    paren(this::ByConstRef1{TKDE}, x::Float64)::Float64


""" paren(this::ByConstRef1{TKDE}, x::Float64)

# Wrapper of void TKDE::SetNBins(UInt_t)
@trydoc raw"""
    SetNBins(this::ByRef1{TKDE}, nbins::UInt32)::Nothing


""" SetNBins(this::ByRef1{TKDE}, nbins::UInt32)

# Wrapper of void TKDE::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TKDE}, xMin::Float64, xMax::Float64)::Nothing
By default computed from the data.

""" SetRange(this::ByRef1{TKDE}, xMin::Float64, xMax::Float64)

# Wrapper of void TKDE::SetTuneFactor(Double_t)
@trydoc raw"""
    SetTuneFactor(this::ByRef1{TKDE}, rho::Float64)::Nothing


""" SetTuneFactor(this::ByRef1{TKDE}, rho::Float64)

# Wrapper of void TKDE::SetUseBinsNEvents(UInt_t)
@trydoc raw"""
    SetUseBinsNEvents(this::ByRef1{TKDE}, nEvents::UInt32)::Nothing


""" SetUseBinsNEvents(this::ByRef1{TKDE}, nEvents::UInt32)

# Wrapper of TConfidenceLevel * TLimit::ComputeLimit(Double_t, Double_t, Int_t, Int_t, bool, TRandom *)
@trydoc raw"""
    TLimit!ComputeLimit(this::ByRef1{TLimit}, s::Float64, b::Float64, d::Int32, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})::CxxPtr1{TConfidenceLevel}


""" TLimit!ComputeLimit(this::ByRef1{TLimit}, s::Float64, b::Float64, d::Int32, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})

# Wrapper of TConfidenceLevel * TLimit::ComputeLimit(Double_t, Double_t, Int_t, TVectorD *, TVectorD *, TObjArray *, Int_t, bool, TRandom *)
@trydoc raw"""
    TLimit!ComputeLimit(this::ByRef1{TLimit}, s::Float64, b::Float64, d::Int32, se::ByPtr1{TVectorD}, be::ByPtr1{TVectorD}, ::ByPtr1{TObjArray}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})::CxxPtr1{TConfidenceLevel}


""" TLimit!ComputeLimit(this::ByRef1{TLimit}, s::Float64, b::Float64, d::Int32, se::ByPtr1{TVectorD}, be::ByPtr1{TVectorD}, ::ByPtr1{TObjArray}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})

# Wrapper of TConfidenceLevel * TLimit::ComputeLimit(TH1 *, TH1 *, TH1 *, Int_t, bool, TRandom *)
@trydoc raw"""
    TLimit!ComputeLimit(this::ByRef1{TLimit}, s::ByPtr1{TH1}, b::ByPtr1{TH1}, d::ByPtr1{TH1}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})::CxxPtr1{TConfidenceLevel}


""" TLimit!ComputeLimit(this::ByRef1{TLimit}, s::ByPtr1{TH1}, b::ByPtr1{TH1}, d::ByPtr1{TH1}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})

# Wrapper of TConfidenceLevel * TLimit::ComputeLimit(TH1 *, TH1 *, TH1 *, TVectorD *, TVectorD *, TObjArray *, Int_t, bool, TRandom *)
@trydoc raw"""
    TLimit!ComputeLimit(this::ByRef1{TLimit}, s::ByPtr1{TH1}, b::ByPtr1{TH1}, d::ByPtr1{TH1}, se::ByPtr1{TVectorD}, be::ByPtr1{TVectorD}, ::ByPtr1{TObjArray}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})::CxxPtr1{TConfidenceLevel}


""" TLimit!ComputeLimit(this::ByRef1{TLimit}, s::ByPtr1{TH1}, b::ByPtr1{TH1}, d::ByPtr1{TH1}, se::ByPtr1{TVectorD}, be::ByPtr1{TVectorD}, ::ByPtr1{TObjArray}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})

# Wrapper of TConfidenceLevel * TLimit::ComputeLimit(TLimitDataSource *, Int_t, bool, TRandom *)
@trydoc raw"""
    TLimit!ComputeLimit(this::ByRef1{TLimit}, data::ByPtr1{TLimitDataSource}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})::CxxPtr1{TConfidenceLevel}


""" TLimit!ComputeLimit(this::ByRef1{TLimit}, data::ByPtr1{TLimitDataSource}, nmc::Int32, stat::Bool, generator::ByPtr1{TRandom})

# Wrapper of void TLimitDataSource::AddChannel(TH1 *, TH1 *, TH1 *)
@trydoc raw"""
    AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1})::Nothing
Adds a channel with signal, background and data given as input.

""" AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1})

# Wrapper of void TLimitDataSource::AddChannel(TH1 *, TH1 *, TH1 *, TVectorD *, TVectorD *, TObjArray *)
@trydoc raw"""
    AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TVectorD}, ::ByPtr1{TVectorD}, ::ByPtr1{TObjArray})::Nothing
Adds a channel with signal, background and data given as input.
In addition, error sources are defined. [TH1](@ref) are here used for convenience: each bin has to be seen as an error source (relative). names is an array of strings containing the names of the sources. Sources with the same name are correlated.
""" AddChannel(this::ByRef1{TLimitDataSource}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TH1}, ::ByPtr1{TVectorD}, ::ByPtr1{TVectorD}, ::ByPtr1{TObjArray})

# Wrapper of TObjArray * TLimitDataSource::GetBackground()
@trydoc raw"""
    GetBackground(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetBackground(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetCandidates()
@trydoc raw"""
    GetCandidates(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetCandidates(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetErrorNames()
@trydoc raw"""
    GetErrorNames(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetErrorNames(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetErrorOnBackground()
@trydoc raw"""
    GetErrorOnBackground(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetErrorOnBackground(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetErrorOnSignal()
@trydoc raw"""
    GetErrorOnSignal(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetErrorOnSignal(this::ByRef1{TLimitDataSource})

# Wrapper of TObjArray * TLimitDataSource::GetSignal()
@trydoc raw"""
    GetSignal(this::ByRef1{TLimitDataSource})::CxxPtr1{TObjArray}


""" GetSignal(this::ByRef1{TLimitDataSource})

# Wrapper of void TLimitDataSource::SetOwner(bool)
@trydoc raw"""
    SetOwner(this::ByRef1{TLimitDataSource}, swtch::Bool)::Nothing
Gives to the [TLimitDataSource](@ref) the ownership of the various objects given as input.
Objects are then deleted by the [TLimitDataSource](@ref) destructor.
""" SetOwner(this::ByRef1{TLimitDataSource}, swtch::Bool)

# Wrapper of void TMultiDimFit::AddRow(const Double_t *, Double_t, Double_t)
@trydoc raw"""
    AddRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)::Nothing
Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization.
The mean of the variables and quantity is calculated on the fly, as outlined in [TPrincipal!AddRow](@ref). This sample should be representative of the problem at hand. Please note, that if no error is given Poisson statistics is assumed and the square error is set to the value of dependent quantity. See also the [class description](#TMultiDimFit:description)
""" AddRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)

# Wrapper of void TMultiDimFit::AddTestRow(const Double_t *, Double_t, Double_t)
@trydoc raw"""
    AddTestRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)::Nothing
Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization.
This sample needn't be representative of the problem at hand. Please note, that if no error is given Poisson statistics is assumed and the square error is set to the value of dependent quantity. See also the [class description](#TMultiDimFit:description)
""" AddTestRow(this::ByRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, D::Float64, E::Float64)

# Wrapper of void TMultiDimFit::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TMultiDimFit}, b::ByPtr1{TBrowser})::Nothing
Browse the [TMultiDimFit](@ref) object in the [TBrowser](@ref).

""" Browse(this::ByRef1{TMultiDimFit}, b::ByPtr1{TBrowser})

# Wrapper of void TMultiDimFit::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Clear internal structures and variables.

""" Clear(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Default Draw method for all objects.

""" Draw(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of Double_t TMultiDimFit::Eval(const Double_t *, const Double_t *)
@trydoc raw"""
    Eval(this::ByConstRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, coeff::ByConstPtr2{Float64})::Float64
Evaluate parameterization at point x.
Optional argument coeff is a vector of coefficients for the parameterisation, fNCoefficients elements long.
""" Eval(this::ByConstRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, coeff::ByConstPtr2{Float64})

# Wrapper of Double_t TMultiDimFit::EvalError(const Double_t *, const Double_t *)
@trydoc raw"""
    EvalError(this::ByConstRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, coeff::ByConstPtr2{Float64})::Float64
Evaluate parameterization error at point x.
Optional argument coeff is a vector of coefficients for the parameterisation, fNCoefficients elements long.
""" EvalError(this::ByConstRef1{TMultiDimFit}, x::ByConstPtr2{Float64}, coeff::ByConstPtr2{Float64})

# Wrapper of void TMultiDimFit::FindParameterization(Option_t *)
@trydoc raw"""
    FindParameterization(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Find the parameterization.
Options: None so far

For detailed description of what this entails, please refer to the [class description](#TMultiDimFit:description)
""" FindParameterization(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::Fit(Option_t *)
@trydoc raw"""
    Fit(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Try to fit the found parameterisation to the test sample.
Options M use Minuit to improve coefficients

Also, refer to [class description](#TMultiDimFit:description)
""" Fit(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of Double_t TMultiDimFit::GetChi2()
@trydoc raw"""
    GetChi2(this::ByConstRef1{TMultiDimFit})::Float64


""" GetChi2(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetCoefficients()
@trydoc raw"""
    GetCoefficients(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetCoefficients(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetCoefficientsRMS()
@trydoc raw"""
    GetCoefficientsRMS(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetCoefficientsRMS(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TMatrixD * TMultiDimFit::GetCorrelationMatrix()
@trydoc raw"""
    GetCorrelationMatrix(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TMatrixD}


""" GetCorrelationMatrix(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetError()
@trydoc raw"""
    GetError(this::ByConstRef1{TMultiDimFit})::Float64


""" GetError(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t * TMultiDimFit::GetFunctionCodes()
@trydoc raw"""
    GetFunctionCodes(this::ByConstRef1{TMultiDimFit})::CxxPtr2{Int32}


""" GetFunctionCodes(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TMatrixD * TMultiDimFit::GetFunctions()
@trydoc raw"""
    GetFunctions(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TMatrixD}


""" GetFunctions(this::ByConstRef1{TMultiDimFit})

# Wrapper of TList * TMultiDimFit::GetHistograms()
@trydoc raw"""
    GetHistograms(this::ByConstRef1{TMultiDimFit})::CxxPtr1{TList}


""" GetHistograms(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetMaxAngle()
@trydoc raw"""
    GetMaxAngle(this::ByConstRef1{TMultiDimFit})::Float64


""" GetMaxAngle(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetMaxFunctions()
@trydoc raw"""
    GetMaxFunctions(this::ByConstRef1{TMultiDimFit})::Int32


""" GetMaxFunctions(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t * TMultiDimFit::GetMaxPowers()
@trydoc raw"""
    GetMaxPowers(this::ByConstRef1{TMultiDimFit})::CxxPtr2{Int32}


""" GetMaxPowers(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetMaxQuantity()
@trydoc raw"""
    GetMaxQuantity(this::ByConstRef1{TMultiDimFit})::Float64


""" GetMaxQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetMaxStudy()
@trydoc raw"""
    GetMaxStudy(this::ByConstRef1{TMultiDimFit})::Int32


""" GetMaxStudy(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetMaxTerms()
@trydoc raw"""
    GetMaxTerms(this::ByConstRef1{TMultiDimFit})::Int32


""" GetMaxTerms(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetMaxVariables()
@trydoc raw"""
    GetMaxVariables(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetMaxVariables(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetMeanQuantity()
@trydoc raw"""
    GetMeanQuantity(this::ByConstRef1{TMultiDimFit})::Float64


""" GetMeanQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetMeanVariables()
@trydoc raw"""
    GetMeanVariables(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetMeanVariables(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetMinAngle()
@trydoc raw"""
    GetMinAngle(this::ByConstRef1{TMultiDimFit})::Float64


""" GetMinAngle(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetMinQuantity()
@trydoc raw"""
    GetMinQuantity(this::ByConstRef1{TMultiDimFit})::Float64


""" GetMinQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetMinRelativeError()
@trydoc raw"""
    GetMinRelativeError(this::ByConstRef1{TMultiDimFit})::Float64


""" GetMinRelativeError(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetMinVariables()
@trydoc raw"""
    GetMinVariables(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetMinVariables(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetNCoefficients()
@trydoc raw"""
    GetNCoefficients(this::ByConstRef1{TMultiDimFit})::Int32


""" GetNCoefficients(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetNVariables()
@trydoc raw"""
    GetNVariables(this::ByConstRef1{TMultiDimFit})::Int32


""" GetNVariables(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetPolyType()
@trydoc raw"""
    GetPolyType(this::ByConstRef1{TMultiDimFit})::Int32


""" GetPolyType(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t * TMultiDimFit::GetPowerIndex()
@trydoc raw"""
    GetPowerIndex(this::ByConstRef1{TMultiDimFit})::CxxPtr2{Int32}


""" GetPowerIndex(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetPowerLimit()
@trydoc raw"""
    GetPowerLimit(this::ByConstRef1{TMultiDimFit})::Float64


""" GetPowerLimit(this::ByConstRef1{TMultiDimFit})

# Wrapper of const Int_t * TMultiDimFit::GetPowers()
@trydoc raw"""
    GetPowers(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr2{Int32}


""" GetPowers(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetPrecision()
@trydoc raw"""
    GetPrecision(this::ByConstRef1{TMultiDimFit})::Float64


""" GetPrecision(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetQuantity()
@trydoc raw"""
    GetQuantity(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetResidualMax()
@trydoc raw"""
    GetResidualMax(this::ByConstRef1{TMultiDimFit})::Float64


""" GetResidualMax(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetResidualMaxRow()
@trydoc raw"""
    GetResidualMaxRow(this::ByConstRef1{TMultiDimFit})::Int32


""" GetResidualMaxRow(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetResidualMin()
@trydoc raw"""
    GetResidualMin(this::ByConstRef1{TMultiDimFit})::Float64


""" GetResidualMin(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetResidualMinRow()
@trydoc raw"""
    GetResidualMinRow(this::ByConstRef1{TMultiDimFit})::Int32


""" GetResidualMinRow(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetResidualSumSq()
@trydoc raw"""
    GetResidualSumSq(this::ByConstRef1{TMultiDimFit})::Float64


""" GetResidualSumSq(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetRMS()
@trydoc raw"""
    GetRMS(this::ByConstRef1{TMultiDimFit})::Float64


""" GetRMS(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetSampleSize()
@trydoc raw"""
    GetSampleSize(this::ByConstRef1{TMultiDimFit})::Int32


""" GetSampleSize(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetSqError()
@trydoc raw"""
    GetSqError(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetSqError(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetSumSqAvgQuantity()
@trydoc raw"""
    GetSumSqAvgQuantity(this::ByConstRef1{TMultiDimFit})::Float64


""" GetSumSqAvgQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetSumSqQuantity()
@trydoc raw"""
    GetSumSqQuantity(this::ByConstRef1{TMultiDimFit})::Float64


""" GetSumSqQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetTestError()
@trydoc raw"""
    GetTestError(this::ByConstRef1{TMultiDimFit})::Float64


""" GetTestError(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::GetTestPrecision()
@trydoc raw"""
    GetTestPrecision(this::ByConstRef1{TMultiDimFit})::Float64


""" GetTestPrecision(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetTestQuantity()
@trydoc raw"""
    GetTestQuantity(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetTestQuantity(this::ByConstRef1{TMultiDimFit})

# Wrapper of Int_t TMultiDimFit::GetTestSampleSize()
@trydoc raw"""
    GetTestSampleSize(this::ByConstRef1{TMultiDimFit})::Int32


""" GetTestSampleSize(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetTestSqError()
@trydoc raw"""
    GetTestSqError(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetTestSqError(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetTestVariables()
@trydoc raw"""
    GetTestVariables(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetTestVariables(this::ByConstRef1{TMultiDimFit})

# Wrapper of const TVectorD * TMultiDimFit::GetVariables()
@trydoc raw"""
    GetVariables(this::ByConstRef1{TMultiDimFit})::ConstCxxPtr1{TVectorD}


""" GetVariables(this::ByConstRef1{TMultiDimFit})

# Wrapper of Bool_t TMultiDimFit::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TMultiDimFit})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TMultiDimFit})

# Wrapper of Double_t TMultiDimFit::MakeChi2(const Double_t *)
@trydoc raw"""
    MakeChi2(this::ByRef1{TMultiDimFit}, coeff::ByConstPtr2{Float64})::Float64
Calculate Chi square over either the test sample.
The optional argument coeff is a vector of coefficients to use in the evaluation of the parameterisation. If coeff == 0, then the found coefficients is used. Used my MINUIT for fit (see TMultDimFit!Fit)
""" MakeChi2(this::ByRef1{TMultiDimFit}, coeff::ByConstPtr2{Float64})

# Wrapper of void TMultiDimFit::MakeCode(const char *, Option_t *)
@trydoc raw"""
    MakeCode(this::ByRef1{TMultiDimFit}, functionName::ByCopy{String}, option::ByCopy{String})::Nothing
Generate the file `<filename>` with .C appended if argument doesn't theend in .cxx or .C.
The contains the implementation of the function:

`Double_t <funcname>(Double_t *x)`

which does the same as [TMultiDimFit!Eval](@ref). Please refer to this method.

Further, the static variables: 
```
Int_t    gNVariables
Int_t    gNCoefficients
Double_t gDMean
Double_t gXMean[]
Double_t gXMin[]
Double_t gXMax[]
Double_t gCoefficient[]
Int_t    gPower[]
```  are initialized. The only [ROOT](@ref) header file needed is Rtypes.h

See [TMultiDimFit!MakeRealCode](@ref) for a list of options
""" MakeCode(this::ByRef1{TMultiDimFit}, functionName::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::MakeHistograms(Option_t *)
@trydoc raw"""
    MakeHistograms(this::ByRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Make histograms of the result of the analysis.
This message should be sent after having read all data points, but before finding the parameterization

Options: A All the below X Original independent variables D Original dependent variables N Normalised independent variables S Shifted dependent variables R1 Residuals versus normalised independent variables R2 Residuals versus dependent variable R3 Residuals computed on training sample R4 Residuals computed on test sample

For a description of these quantities, refer to [class description](#TMultiDimFit:description)
""" MakeHistograms(this::ByRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::MakeMethod(const Char_t *, Option_t *)
@trydoc raw"""
    MakeMethod(this::ByRef1{TMultiDimFit}, className::ByCopy{String}, option::ByCopy{String})::Nothing
Generate the file `<classname>MDF.cxx` which contains the implementation of the method:
`Double_t <classname>!MDF(Double_t *x)`

which does the same as [TMultiDimFit!Eval](@ref). Please refer to this method.

Further, the public static members: 

    Int_t    <classname>!fgNVariables
    Int_t    <classname>!fgNCoefficients
    Double_t <classname>!fgDMean
    Double_t <classname>!fgXMean[]       //[fgNVariables]
    Double_t <classname>!fgXMin[]        //[fgNVariables]
    Double_t <classname>!fgXMax[]        //[fgNVariables]
    Double_t <classname>!fgCoefficient[] //[fgNCoeffficents]
    Int_t    <classname>!fgPower[]       //[fgNCoeffficents*fgNVariables]

(C++ version of the code)

are initialized, and assumed to exist. The class declaration is assumed to be in `<classname>.h` and assumed to be provided by the user.

###Note

see TMultiDimFit!MakeRealCode for a list of options

The minimal class definition is: 

    class <classname> {
    public:
      Int_t    <classname>!fgNVariables;     // Number of variables
      Int_t    <classname>!fgNCoefficients;  // Number of terms
      Double_t <classname>!fgDMean;          // Mean from training sample
      Double_t <classname>!fgXMean[];        // Mean from training sample
      Double_t <classname>!fgXMin[];         // Min from training sample
      Double_t <classname>!fgXMax[];         // Max from training sample
      Double_t <classname>!fgCoefficient[];  // Coefficients
      Int_t    <classname>!fgPower[];        // Function powers
      Double_t Eval(Double_t *x);
    };

(C++ version of the code)

Whether the method `<classname>!Eval` should be static or not, is up to the user.
""" MakeMethod(this::ByRef1{TMultiDimFit}, className::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TMultiDimFit}, option::ByCopy{String})::Nothing
Print statistics etc.
Options are P Parameters S Statistics C Coefficients R Result of parameterisation F Result of fit K Correlation Matrix M Pretty print formula
""" Print(this::ByConstRef1{TMultiDimFit}, option::ByCopy{String})

# Wrapper of void TMultiDimFit::SetBinVarX(Int_t)
@trydoc raw"""
    SetBinVarX(this::ByRef1{TMultiDimFit}, nbbinvarx::Int32)::Nothing


""" SetBinVarX(this::ByRef1{TMultiDimFit}, nbbinvarx::Int32)

# Wrapper of void TMultiDimFit::SetBinVarY(Int_t)
@trydoc raw"""
    SetBinVarY(this::ByRef1{TMultiDimFit}, nbbinvary::Int32)::Nothing


""" SetBinVarY(this::ByRef1{TMultiDimFit}, nbbinvary::Int32)

# Wrapper of void TMultiDimFit::SetMaxAngle(Double_t)
@trydoc raw"""
    SetMaxAngle(this::ByRef1{TMultiDimFit}, angle::Float64)::Nothing
Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit.
By default it is 0, which automatically chooses another selection criteria. See also [class description](#TMultiDimFit:description)
""" SetMaxAngle(this::ByRef1{TMultiDimFit}, angle::Float64)

# Wrapper of void TMultiDimFit::SetMaxFunctions(Int_t)
@trydoc raw"""
    SetMaxFunctions(this::ByRef1{TMultiDimFit}, n::Int32)::Nothing


""" SetMaxFunctions(this::ByRef1{TMultiDimFit}, n::Int32)

# Wrapper of void TMultiDimFit::SetMaxPowers(const Int_t *)
@trydoc raw"""
    SetMaxPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32})::Nothing
Set the maximum power to be considered in the fit for each variable.
See also [class description](#TMultiDimFit:description)
""" SetMaxPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32})

# Wrapper of void TMultiDimFit::SetMaxStudy(Int_t)
@trydoc raw"""
    SetMaxStudy(this::ByRef1{TMultiDimFit}, n::Int32)::Nothing


""" SetMaxStudy(this::ByRef1{TMultiDimFit}, n::Int32)

# Wrapper of void TMultiDimFit::SetMaxTerms(Int_t)
@trydoc raw"""
    SetMaxTerms(this::ByRef1{TMultiDimFit}, terms::Int32)::Nothing


""" SetMaxTerms(this::ByRef1{TMultiDimFit}, terms::Int32)

# Wrapper of void TMultiDimFit::SetMinAngle(Double_t)
@trydoc raw"""
    SetMinAngle(this::ByRef1{TMultiDimFit}, angle::Float64)::Nothing
Set the min angle (in degrees) between a new candidate function and the subspace spanned by the previously accepted functions.
See also [class description](#TMultiDimFit:description)
""" SetMinAngle(this::ByRef1{TMultiDimFit}, angle::Float64)

# Wrapper of void TMultiDimFit::SetMinRelativeError(Double_t)
@trydoc raw"""
    SetMinRelativeError(this::ByRef1{TMultiDimFit}, error::Float64)::Nothing
Set the acceptable relative error for when sum of square residuals is considered minimized.
For a full account, refer to the [class description](#TMultiDimFit:description)
""" SetMinRelativeError(this::ByRef1{TMultiDimFit}, error::Float64)

# Wrapper of void TMultiDimFit::SetPowerLimit(Double_t)
@trydoc raw"""
    SetPowerLimit(this::ByRef1{TMultiDimFit}, limit::Float64)::Nothing
Set the user parameter for the function selection.
The bigger the limit, the more functions are used. The meaning of this variable is defined in the [class description](#TMultiDimFit:description)
""" SetPowerLimit(this::ByRef1{TMultiDimFit}, limit::Float64)

# Wrapper of void TMultiDimFit::SetPowers(const Int_t *, Int_t)
@trydoc raw"""
    SetPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32}, terms::Int32)::Nothing
Define a user function.
The input array must be of the form (p11, ..., p1N, ... ,pL1, ..., pLN) Where N is the dimension of the data sample, L is the number of terms (given in terms) and the first number, labels the term, the second the variable. More information is given in the [class description](#TMultiDimFit:description)
""" SetPowers(this::ByRef1{TMultiDimFit}, powers::ByConstPtr2{Int32}, terms::Int32)

# Wrapper of TMultiDimFit * TMultiDimFit::Instance()
@trydoc raw"""
    TMultiDimFit!Instance(this::ByRef1{TMultiDimFit})::CxxPtr1{TMultiDimFit}
Return the static instance.

""" TMultiDimFit!Instance(this::ByRef1{TMultiDimFit})

# Wrapper of void TPolyMarker::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TPolyMarker}, object::ByRef1{TObject})::Nothing
Copy this to obj.

""" Copy(this::ByConstRef1{TPolyMarker}, object::ByRef1{TObject})

# Wrapper of Int_t TPolyMarker::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TPolyMarker}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a polymarker.
Compute the closest distance of approach from point px,py to each point of the polymarker. Returns when the distance found is below DistanceMaximum. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TPolyMarker}, px::Int32, py::Int32)

# Wrapper of void TPolyMarker::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TPolyMarker}, option::ByCopy{String})::Nothing
Draw.

""" Draw(this::ByRef1{TPolyMarker}, option::ByCopy{String})

# Wrapper of void TPolyMarker::DrawPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    DrawPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing
Draw polymarker.

""" DrawPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TPolyMarker::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TPolyMarker}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function must be implemented to realize the action corresponding to the mouse click on the object in the window
""" ExecuteEvent(this::ByRef1{TPolyMarker}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TPolyMarker::GetLastPoint()
@trydoc raw"""
    GetLastPoint(this::ByConstRef1{TPolyMarker})::Int32
Get the index of the last filled point.
###Note

In case the TPolyMarker was filled in sequential order, the returned value + 1 matches the total number of points used (and is less or equal than the capacity GetN()).
""" GetLastPoint(this::ByConstRef1{TPolyMarker})

# Wrapper of Int_t TPolyMarker::GetN()
@trydoc raw"""
    GetN(this::ByConstRef1{TPolyMarker})::Int32
Get the current capacity (reserved size) of the [TPolyMarker](@ref).
###Note

In contrast to TGraph!GetN(), this does not necessarily match with the used points 

###Warning

Do not add points via SetPoint(pm->GetN(), x, y) as with a TGraph, use instead TPolyMarker!SetNextPoint 

###See

GetLastPoint()
""" GetN(this::ByConstRef1{TPolyMarker})

# Wrapper of Option_t * TPolyMarker::GetOption()
@trydoc raw"""
    GetOption(this::ByConstRef1{TPolyMarker})::ByCopy{String}


""" GetOption(this::ByConstRef1{TPolyMarker})

# Wrapper of Double_t * TPolyMarker::GetX()
@trydoc raw"""
    GetX(this::ByConstRef1{TPolyMarker})::CxxPtr2{Float64}


""" GetX(this::ByConstRef1{TPolyMarker})

# Wrapper of Double_t * TPolyMarker::GetY()
@trydoc raw"""
    GetY(this::ByConstRef1{TPolyMarker})::CxxPtr2{Float64}


""" GetY(this::ByConstRef1{TPolyMarker})

# Wrapper of void TPolyMarker::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TPolyMarker}, option::ByCopy{String})::Nothing
ls.

""" ls(this::ByConstRef1{TPolyMarker}, option::ByCopy{String})

# Wrapper of Int_t TPolyMarker::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TPolyMarker}, list::ByPtr1{TCollection})::Int32
Merge polymarkers in the collection in this polymarker.

""" Merge(this::ByRef1{TPolyMarker}, list::ByPtr1{TCollection})

# Wrapper of void TPolyMarker::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TPolyMarker}, option::ByCopy{String})::Nothing
Paint.

""" Paint(this::ByRef1{TPolyMarker}, option::ByCopy{String})

# Wrapper of void TPolyMarker::PaintPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    PaintPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing
Paint polymarker.

""" PaintPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TPolyMarker::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TPolyMarker}, option::ByCopy{String})::Nothing
Print polymarker.

""" Print(this::ByConstRef1{TPolyMarker}, option::ByCopy{String})

# Wrapper of Int_t TPolyMarker::SetNextPoint(Double_t, Double_t)
@trydoc raw"""
    SetNextPoint(this::ByRef1{TPolyMarker}, x::Float64, y::Float64)::Int32
Set point following LastPoint to x, y.
Returns index of the point (new last point).
""" SetNextPoint(this::ByRef1{TPolyMarker}, x::Float64, y::Float64)

# Wrapper of void TPolyMarker::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TPolyMarker}, point::Int32, x::Float64, y::Float64)::Nothing
Set point number n.
if n is greater than the current size, the arrays are automatically extended
""" SetPoint(this::ByRef1{TPolyMarker}, point::Int32, x::Float64, y::Float64)

# Wrapper of void TPolyMarker::SetPolyMarker(Int_t)
@trydoc raw"""
    SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32)::Nothing
If n <= 0 the current arrays of points are deleted.

""" SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32)

# Wrapper of void TPolyMarker::SetPolyMarker(Int_t, Double_t *, Double_t *, Option_t *)
@trydoc raw"""
    SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})::Nothing
If n <= 0 the current arrays of points are deleted.

""" SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float64}, y::ByPtr2{Float64}, option::ByCopy{String})

# Wrapper of void TPolyMarker::SetPolyMarker(Int_t, Float_t *, Float_t *, Option_t *)
@trydoc raw"""
    SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})::Nothing
If n <= 0 the current arrays of points are deleted.

""" SetPolyMarker(this::ByRef1{TPolyMarker}, n::Int32, x::ByPtr2{Float32}, y::ByPtr2{Float32}, option::ByCopy{String})

# Wrapper of Int_t TPolyMarker::Size()
@trydoc raw"""
    Size(this::ByConstRef1{TPolyMarker})::Int32


""" Size(this::ByConstRef1{TPolyMarker})

# Wrapper of Int_t TProfile2Poly::Fill(Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64)::Int32
Fill.

""" Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64)

# Wrapper of Int_t TProfile2Poly::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64, weight::Float64)::Int32
Fill.

""" Fill(this::ByRef1{TProfile2Poly}, xcoord::Float64, ycoord::Float64, value::Float64, weight::Float64)

# Wrapper of Double_t TProfile2Poly::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin content.

""" GetBinContent(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetBinEffectiveEntries(Int_t)
@trydoc raw"""
    GetBinEffectiveEntries(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin effective entries.

""" GetBinEffectiveEntries(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetBinEntries(Int_t)
@trydoc raw"""
    GetBinEntries(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin entries.

""" GetBinEntries(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetBinEntriesVW(Int_t)
@trydoc raw"""
    GetBinEntriesVW(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin entries VW.

""" GetBinEntriesVW(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetBinEntriesW2(Int_t)
@trydoc raw"""
    GetBinEntriesW2(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin entries W2.

""" GetBinEntriesW2(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetBinEntriesWV2(Int_t)
@trydoc raw"""
    GetBinEntriesWV2(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin entries WV2.

""" GetBinEntriesWV2(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile2Poly}, bin::Int32)::Float64
Get bin error.

""" GetBinError(this::ByConstRef1{TProfile2Poly}, bin::Int32)

# Wrapper of Double_t TProfile2Poly::GetOverflowContent(Int_t)
@trydoc raw"""
    GetOverflowContent(this::ByRef1{TProfile2Poly}, idx::Int32)::Float64


""" GetOverflowContent(this::ByRef1{TProfile2Poly}, idx::Int32)

# Wrapper of void TProfile2Poly::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TProfile2Poly}, stats::ByPtr2{Float64})::Nothing
Fill the array stats from the contents of this profile.
The array stats must be correctly dimensioned in the calling program.

- stats[0] = sumw
- stats[1] = sumw2
- stats[2] = sumwx
- stats[3] = sumwx2
- stats[4] = sumwy
- stats[5] = sumwy2
- stats[6] = sumwxy
- stats[7] = sumwz
- stats[8] = sumwz2

If no axis-subrange is specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.
""" GetStats(this::ByConstRef1{TProfile2Poly}, stats::ByPtr2{Float64})

# Wrapper of Long64_t TProfile2Poly::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile2Poly}, in::ByPtr1{TCollection})::Int64
Merge.

""" Merge(this::ByRef1{TProfile2Poly}, in::ByPtr1{TCollection})

# Wrapper of void TProfile2Poly::PrintOverflowRegions()
@trydoc raw"""
    PrintOverflowRegions(this::ByRef1{TProfile2Poly})::Nothing
Print overflow regions.

""" PrintOverflowRegions(this::ByRef1{TProfile2Poly})

# Wrapper of void TProfile2Poly::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile2Poly}, option::ByCopy{String})::Nothing
Reset.

""" Reset(this::ByRef1{TProfile2Poly}, option::ByCopy{String})

# Wrapper of void TProfile2Poly::SetContentToAverage()
@trydoc raw"""
    SetContentToAverage(this::ByRef1{TProfile2Poly})::Nothing
Set content to average.

""" SetContentToAverage(this::ByRef1{TProfile2Poly})

# Wrapper of void TProfile2Poly::SetContentToError()
@trydoc raw"""
    SetContentToError(this::ByRef1{TProfile2Poly})::Nothing
Set content to error.

""" SetContentToError(this::ByRef1{TProfile2Poly})

# Wrapper of void TProfile2Poly::SetErrorOption(EErrorType)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile2Poly}, type::ByCopy{EErrorType})::Nothing
Set error option.

""" SetErrorOption(this::ByRef1{TProfile2Poly}, type::ByCopy{EErrorType})

# Wrapper of void TProfile2PolyBin::ClearStats()
@trydoc raw"""
    ClearStats(this::ByRef1{TProfile2PolyBin})::Nothing
Clear statistics.

""" ClearStats(this::ByRef1{TProfile2PolyBin})

# Wrapper of Double_t TProfile2PolyBin::GetEffectiveEntries()
@trydoc raw"""
    GetEffectiveEntries(this::ByConstRef1{TProfile2PolyBin})::Float64


""" GetEffectiveEntries(this::ByConstRef1{TProfile2PolyBin})

# Wrapper of Double_t TProfile2PolyBin::GetEntries()
@trydoc raw"""
    GetEntries(this::ByConstRef1{TProfile2PolyBin})::Float64


""" GetEntries(this::ByConstRef1{TProfile2PolyBin})

# Wrapper of Double_t TProfile2PolyBin::GetEntriesVW()
@trydoc raw"""
    GetEntriesVW(this::ByConstRef1{TProfile2PolyBin})::Float64


""" GetEntriesVW(this::ByConstRef1{TProfile2PolyBin})

# Wrapper of Double_t TProfile2PolyBin::GetEntriesW2()
@trydoc raw"""
    GetEntriesW2(this::ByConstRef1{TProfile2PolyBin})::Float64


""" GetEntriesW2(this::ByConstRef1{TProfile2PolyBin})

# Wrapper of Double_t TProfile2PolyBin::GetEntriesWV2()
@trydoc raw"""
    GetEntriesWV2(this::ByConstRef1{TProfile2PolyBin})::Float64


""" GetEntriesWV2(this::ByConstRef1{TProfile2PolyBin})

# Wrapper of Double_t TProfile2PolyBin::GetError()
@trydoc raw"""
    GetError(this::ByConstRef1{TProfile2PolyBin})::Float64


""" GetError(this::ByConstRef1{TProfile2PolyBin})

# Wrapper of void TProfile2PolyBin::Merge(const TProfile2PolyBin *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile2PolyBin}, toMerge::ByConstPtr1{TProfile2PolyBin})::Nothing
Merge.

""" Merge(this::ByRef1{TProfile2PolyBin}, toMerge::ByConstPtr1{TProfile2PolyBin})

# Wrapper of void TProfile2PolyBin::Update()
@trydoc raw"""
    Update(this::ByRef1{TProfile2PolyBin})::Nothing
Update.

""" Update(this::ByRef1{TProfile2PolyBin})

# Wrapper of Bool_t TProfile3D::Add(const TH1 *, const TH1 *, Double_t, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)::Bool
Replace contents of this profile3D by the addition of h1 and h2.
`this = c1*h1 + c2*h2`
""" Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64)

# Wrapper of Bool_t TProfile3D::Add(const TH1 *, Double_t)
@trydoc raw"""
    Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, c1::Float64)::Bool
Performs the operation: `this = this + c1*h1` .

""" Add(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, c1::Float64)

# Wrapper of Bool_t TProfile3D::Add(TF1 *, Double_t, Option_t *)
@trydoc raw"""
    Add(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})::Bool
Performs the operation: `this = this + c1*f1` .

""" Add(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64, option::ByCopy{String})

# Wrapper of Int_t TProfile3D::BufferEmpty(Int_t)
@trydoc raw"""
    BufferEmpty(this::ByRef1{TProfile3D}, action::Int32)::Int32
Fill histogram with all entries in the buffer.
- action = -1 histogram is reset and refilled from the buffer (called by [THistPainter!Paint](@ref))
- action = 0 histogram is filled from the buffer
- action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the number of entries in the buffer is greater than the number of entries in the histogram
""" BufferEmpty(this::ByRef1{TProfile3D}, action::Int32)

# Wrapper of void TProfile3D::BuildOptions(Double_t, Double_t, Option_t *)
@trydoc raw"""
    BuildOptions(this::ByRef1{TProfile3D}, tmin::Float64, tmax::Float64, option::ByCopy{String})::Nothing
Set Profile3D histogram structure and options.
- tmin: minimum value allowed for t
- tmax: maximum value allowed for t if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf)
- option: this is the option for the computation of the t error of the profile ( [TProfile3D!GetBinError](@ref) ) possible values for the options are documented in [TProfile3D!SetErrorOption](@ref)

see also [TProfile!BuildOptions](@ref) for a detailed description
""" BuildOptions(this::ByRef1{TProfile3D}, tmin::Float64, tmax::Float64, option::ByCopy{String})

# Wrapper of void TProfile3D::Copy(TObject &)
@trydoc raw"""
    Copy(this::ByConstRef1{TProfile3D}, hnew::ByRef1{TObject})::Nothing
Copy a Profile3D histogram to a new profile2D histogram.

""" Copy(this::ByConstRef1{TProfile3D}, hnew::ByRef1{TObject})

# Wrapper of Bool_t TProfile3D::Divide(const TH1 *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})::Bool
Divide this profile2D by h1.
`this = this/h1`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile3D::Divide(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by the division of h1 by h2.
`this = c1*h1/(c2*h2)`

This function return kFALSE if the divide operation failed
""" Divide(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile3D::Divide(TF1 *, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this/(c1*f1)` .
This function is not implemented
""" Divide(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of void TProfile3D::ExtendAxis(Double_t, TAxis *)
@trydoc raw"""
    ExtendAxis(this::ByRef1{TProfile3D}, x::Float64, axis::ByPtr1{TAxis})::Nothing
Profile histogram is resized along axis such that x is in the axis range.
The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the rebinned histogram. Takes into account errors (Sumw2) if any. The axis must be rebinnable before invoking this function. Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`
""" ExtendAxis(this::ByRef1{TProfile3D}, x::Float64, axis::ByPtr1{TAxis})

# Wrapper of Int_t TProfile3D::Fill(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64)::Int32
Fill a Profile3D histogram (no weights).

""" Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of Int_t TProfile3D::Fill(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64, w::Float64)::Int32
Fill a Profile3D histogram with weights.

""" Fill(this::ByRef1{TProfile3D}, x::Float64, y::Float64, z::Float64, t::Float64, w::Float64)

# Wrapper of Double_t TProfile3D::GetBinContent(Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile3D}, bin::Int32)::Float64
Return bin content of a Profile3D histogram.

""" GetBinContent(this::ByConstRef1{TProfile3D}, bin::Int32)

# Wrapper of Double_t TProfile3D::GetBinContent(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile3D}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TProfile3D}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TProfile3D::GetBinContent(Int_t, Int_t)
@trydoc raw"""
    GetBinContent(this::ByConstRef1{TProfile3D}, ::Int32, ::Int32)::Float64


""" GetBinContent(this::ByConstRef1{TProfile3D}, ::Int32, ::Int32)

# Wrapper of Double_t TProfile3D::GetBinEffectiveEntries(Int_t)
@trydoc raw"""
    GetBinEffectiveEntries(this::ByRef1{TProfile3D}, bin::Int32)::Float64
Return bin effective entries for a weighted filled Profile histogram.
In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. [TProfile!Sumw2()](@ref) must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored.
""" GetBinEffectiveEntries(this::ByRef1{TProfile3D}, bin::Int32)

# Wrapper of Double_t TProfile3D::GetBinEntries(Int_t)
@trydoc raw"""
    GetBinEntries(this::ByConstRef1{TProfile3D}, bin::Int32)::Float64
Return bin entries of a Profile3D histogram.

""" GetBinEntries(this::ByConstRef1{TProfile3D}, bin::Int32)

# Wrapper of Double_t TProfile3D::GetBinError(Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile3D}, bin::Int32)::Float64
Return bin error of a Profile3D histogram.
### Computing errors: A moving field

The computation of errors for a [TProfile3D](@ref) has evolved with the versions of [ROOT](@ref). The difficulty is in computing errors for bins with low statistics.

- prior to version 3.10, we had no special treatment of low statistic bins. As a result, these bins had huge errors. The reason is that the expression eprim2 is very close to 0 (rounding problems) or 0.
- The algorithm is modified/protected for the case when a [TProfile3D](@ref) is projected (ProjectionX). The previous algorithm generated a N^2 problem when projecting a [TProfile3D](@ref) with a large number of bins (eg 100000).
- in version 3.10/02, a new static function [TProfile!Approximate](@ref) is introduced to enable or disable (default) the approximation. (see also comments in [TProfile!GetBinError](@ref))
""" GetBinError(this::ByConstRef1{TProfile3D}, bin::Int32)

# Wrapper of Double_t TProfile3D::GetBinError(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile3D}, binx::Int32, biny::Int32, binz::Int32)::Float64


""" GetBinError(this::ByConstRef1{TProfile3D}, binx::Int32, biny::Int32, binz::Int32)

# Wrapper of Double_t TProfile3D::GetBinError(Int_t, Int_t)
@trydoc raw"""
    GetBinError(this::ByConstRef1{TProfile3D}, ::Int32, ::Int32)::Float64


""" GetBinError(this::ByConstRef1{TProfile3D}, ::Int32, ::Int32)

# Wrapper of TArrayD * TProfile3D::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByRef1{TProfile3D})::CxxPtr1{TArrayD}


""" GetBinSumw2(this::ByRef1{TProfile3D})

# Wrapper of const TArrayD * TProfile3D::GetBinSumw2()
@trydoc raw"""
    GetBinSumw2(this::ByConstRef1{TProfile3D})::ConstCxxPtr1{TArrayD}


""" GetBinSumw2(this::ByConstRef1{TProfile3D})

# Wrapper of Option_t * TProfile3D::GetErrorOption()
@trydoc raw"""
    GetErrorOption(this::ByConstRef1{TProfile3D})::ByCopy{String}
Return option to compute profile2D errors.

""" GetErrorOption(this::ByConstRef1{TProfile3D})

# Wrapper of void TProfile3D::GetStats(Double_t *)
@trydoc raw"""
    GetStats(this::ByConstRef1{TProfile3D}, stats::ByPtr2{Float64})::Nothing
fill the array stats from the contents of this profile.
The array stats must be correctly dimensioned in the calling program.

- stats[0] = sumw
- stats[1] = sumw2
- stats[2] = sumwx
- stats[3] = sumwx2
- stats[4] = sumwy
- stats[5] = sumwy2
- stats[6] = sumwxy
- stats[7] = sumwz
- stats[8] = sumwz2
- stats[9] = sumwxz
- stats[10]= sumwyz
- stats[11]= sumwt
- stats[12]= sumwt2

If no axis-subrange is specified (via [TAxis!SetRange](@ref)), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.
""" GetStats(this::ByConstRef1{TProfile3D}, stats::ByPtr2{Float64})

# Wrapper of Double_t TProfile3D::GetTmax()
@trydoc raw"""
    GetTmax(this::ByConstRef1{TProfile3D})::Float64


""" GetTmax(this::ByConstRef1{TProfile3D})

# Wrapper of Double_t TProfile3D::GetTmin()
@trydoc raw"""
    GetTmin(this::ByConstRef1{TProfile3D})::Float64


""" GetTmin(this::ByConstRef1{TProfile3D})

# Wrapper of void TProfile3D::LabelsDeflate(Option_t *)
@trydoc raw"""
    LabelsDeflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})::Nothing
Reduce the number of bins for this axis to the number of bins having a label.

""" LabelsDeflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})

# Wrapper of void TProfile3D::LabelsInflate(Option_t *)
@trydoc raw"""
    LabelsInflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})::Nothing
Double the number of bins for axis.
Refill histogram This function is called by [TAxis!FindBin(const char *label)](@ref)
""" LabelsInflate(this::ByRef1{TProfile3D}, axis::ByCopy{String})

# Wrapper of void TProfile3D::LabelsOption(Option_t *, Option_t *)
@trydoc raw"""
    LabelsOption(this::ByRef1{TProfile3D}, option::ByCopy{String}, axis::ByCopy{String})::Nothing
Set option(s) to draw axis with labels.
option might have the following values:

- "a" sort by alphabetic order
- ">" sort by decreasing values
- "<" sort by increasing values
- "h" draw labels horizontal
- "v" draw labels vertical
- "u" draw labels up (theend of label right adjusted)
- "d" draw labels down (thestart of label left adjusted)
""" LabelsOption(this::ByRef1{TProfile3D}, option::ByCopy{String}, axis::ByCopy{String})

# Wrapper of Long64_t TProfile3D::Merge(TCollection *)
@trydoc raw"""
    Merge(this::ByRef1{TProfile3D}, list::ByPtr1{TCollection})::Int64
Merge all histograms in the collection in this histogram.
This function computes the min/max for the axes, compute a new number of bins, if necessary, add bin contents, errors and statistics. If overflows are present and limits are different the function will fail. The function returns the total number of entries in the result histogram if the merge is successful, -1 otherwise.

IMPORTANT remark. The 2 axis x and y may have different number of bins and different limits, BUT the largest bin width must be a multiple of the smallest bin width and the upper limit must also be a multiple of the bin width.
""" Merge(this::ByRef1{TProfile3D}, list::ByPtr1{TCollection})

# Wrapper of Bool_t TProfile3D::Multiply(const TH1 *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})::Bool
Multiply this profile2D by h1.
`this = this*h1`
""" Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1})

# Wrapper of Bool_t TProfile3D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})::Bool
Replace contents of this profile2D by multiplication of h1 by h2.
`this = (c1*h1)*(c2*h2)`
""" Multiply(this::ByRef1{TProfile3D}, h1::ByConstPtr1{TH1}, h2::ByConstPtr1{TH1}, c1::Float64, c2::Float64, option::ByCopy{String})

# Wrapper of Bool_t TProfile3D::Multiply(TF1 *, Double_t)
@trydoc raw"""
    Multiply(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)::Bool
Performs the operation: `this = this*c1*f1` .

""" Multiply(this::ByRef1{TProfile3D}, h1::ByPtr1{TF1}, c1::Float64)

# Wrapper of TProfile3D & TProfile3D::operator=(const TProfile3D &)
@trydoc raw"""
    assign(this::ByRef1{TProfile3D}, profile::ByConstRef1{TProfile3D})::CxxRef1{TProfile3D}


""" assign(this::ByRef1{TProfile3D}, profile::ByConstRef1{TProfile3D})

# Wrapper of TProfile2D * TProfile3D::Project3DProfile(Option_t *)
@trydoc raw"""
    Project3DProfile(this::ByConstRef1{TProfile3D}, option::ByCopy{String})::CxxPtr1{TProfile2D}
Project a 3-D profile into a 2D-profile histogram depending on the option parameter.
option may contain a combination of the characters x,y,z:

- option = "xy" return the x versus y projection into a [TProfile2D](@ref) histogram
- option = "yx" return the y versus x projection into a [TProfile2D](@ref) histogram
- option = "xz" return the x versus z projection into a [TProfile2D](@ref) histogram
- option = "zx" return the z versus x projection into a [TProfile2D](@ref) histogram
- option = "yz" return the y versus z projection into a [TProfile2D](@ref) histogram
- option = "zy" return the z versus y projection into a [TProfile2D](@ref) histogram

NB: the notation "a vs b" means "a" vertical and "b" horizontal along X

The resulting profile contains the combination of all the considered bins along X By default, all bins are included considering also underflow/overflows

The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See [TProfile!BuildOptions](@ref) for details

To select a bin range along an axis, use [TAxis!SetRange](@ref), eg `h3.GetYaxis()->SetRange(23,56);`
""" Project3DProfile(this::ByConstRef1{TProfile3D}, option::ByCopy{String})

# Wrapper of TH3D * TProfile3D::ProjectionXYZ(const char *, Option_t *)
@trydoc raw"""
    ProjectionXYZ(this::ByConstRef1{TProfile3D}, name::ByCopy{String}, option::ByCopy{String})::CxxPtr1{TH3D}
Project this profile3D into a 3-D histogram along X,Y,Z.
The projection is always of the type [TH3D](@ref).

- if option "E" is specified, the errors are computed. (default)
- if option "B" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,
- if option "C=E" the bin contents of the projection are set to the bin errors of the profile
- if option "E" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option "E" is defined as the default one in the header file.
- if option "" is specified the histogram errors are simply the sqrt of its content
- if option "B" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,
- if option "C=E" the bin contents of the projection are set to the bin errors of the profile
- if option "W" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a [TH2D](@ref) using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected histogram (obtained using this option "W") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable ([TProfile2D!fSumw2](@ref)[bin] )

    Note that the axis range is not considered when doing the projection
""" ProjectionXYZ(this::ByConstRef1{TProfile3D}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TProfile3D::PutStats(Double_t *)
@trydoc raw"""
    PutStats(this::ByRef1{TProfile3D}, stats::ByPtr2{Float64})::Nothing
Replace current statistics with the values in array stats.

""" PutStats(this::ByRef1{TProfile3D}, stats::ByPtr2{Float64})

# Wrapper of void TProfile3D::Reset(Option_t *)
@trydoc raw"""
    Reset(this::ByRef1{TProfile3D}, option::ByCopy{String})::Nothing
Reset contents of a Profile3D histogram.

""" Reset(this::ByRef1{TProfile3D}, option::ByCopy{String})

# Wrapper of void TProfile3D::Scale(Double_t, Option_t *)
@trydoc raw"""
    Scale(this::ByRef1{TProfile3D}, c1::Float64, option::ByCopy{String})::Nothing
Multiply this profile2D by a constant c1.
`this = c1*this`

This function uses the services of [TProfile3D!Add](@ref)
""" Scale(this::ByRef1{TProfile3D}, c1::Float64, option::ByCopy{String})

# Wrapper of void TProfile3D::SetBinEntries(Int_t, Double_t)
@trydoc raw"""
    SetBinEntries(this::ByRef1{TProfile3D}, bin::Int32, w::Float64)::Nothing
Set the number of entries in bin.

""" SetBinEntries(this::ByRef1{TProfile3D}, bin::Int32, w::Float64)

# Wrapper of void TProfile3D::SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile3D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64, nbinsz::Int32, zmin::Float64, zmax::Float64)::Nothing
Redefine x, y and z axis parameters.

""" SetBins(this::ByRef1{TProfile3D}, nbinsx::Int32, xmin::Float64, xmax::Float64, nbinsy::Int32, ymin::Float64, ymax::Float64, nbinsz::Int32, zmin::Float64, zmax::Float64)

# Wrapper of void TProfile3D::SetBins(Int_t, const Double_t *, Int_t, const Double_t *, Int_t, const Double_t *)
@trydoc raw"""
    SetBins(this::ByRef1{TProfile3D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})::Nothing
Redefine x, y and z axis parameters with variable bin sizes.

""" SetBins(this::ByRef1{TProfile3D}, nx::Int32, xBins::ByConstPtr2{Float64}, ny::Int32, yBins::ByConstPtr2{Float64}, nz::Int32, zBins::ByConstPtr2{Float64})

# Wrapper of void TProfile3D::SetBinsLength(Int_t)
@trydoc raw"""
    SetBinsLength(this::ByRef1{TProfile3D}, n::Int32)::Nothing
Set total number of bins including under/overflow.
Reallocate bin contents array
""" SetBinsLength(this::ByRef1{TProfile3D}, n::Int32)

# Wrapper of void TProfile3D::SetBuffer(Int_t, Option_t *)
@trydoc raw"""
    SetBuffer(this::ByRef1{TProfile3D}, buffersize::Int32, opt::ByCopy{String})::Nothing
Set the buffer size in units of 8 bytes (double).

""" SetBuffer(this::ByRef1{TProfile3D}, buffersize::Int32, opt::ByCopy{String})

# Wrapper of void TProfile3D::SetErrorOption(Option_t *)
@trydoc raw"""
    SetErrorOption(this::ByRef1{TProfile3D}, option::ByCopy{String})::Nothing
Set option to compute profile3D errors.
The computation of the bin errors is based on the parameter option:

- ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T), i.e. the standard error of the bin contents. Note that if [TProfile3D!Approximate()](@ref) is called, an approximation is used when the spread in T is 0 and the number of bin entries is > 0
- 's' The bin errors are the standard deviations of the T bin values Note that if [TProfile3D!Approximate()](@ref) is called, an approximation is used when the spread in T is 0 and the number of bin entries is > 0
- 'i' Errors are as in default case (standard errors of the bin contents) The only difference is for the case when the spread in T is zero. In this case for N > 0 the error is 1./SQRT(12.*N)
- 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0. W is the sum in the bin of the weights of the profile. This option is for combining measurements t +/- dt, and the profile is filled with values t and weights w = 1/dt**2

    See [TProfile!BuildOptions](@ref) for explanation of all options
""" SetErrorOption(this::ByRef1{TProfile3D}, option::ByCopy{String})

# Wrapper of void TProfile3D::Sumw2(Bool_t)
@trydoc raw"""
    Sumw2(this::ByRef1{TProfile3D}, flag::Bool)::Nothing
Create/Delete structure to store sum of squares of weights per bin This is needed to compute the correct statistical quantities of a profile filled with weights.
This function is automatically called when the histogram is created if the static function [TH1!SetDefaultSumw2](@ref) has been called before. If flag = false the structure is deleted
""" Sumw2(this::ByRef1{TProfile3D}, flag::Bool)

# Wrapper of void TProfile3D::Approximate(Bool_t)
@trydoc raw"""
    TProfile3D!Approximate(this::ByRef1{TProfile3D}, approx::Bool)::Nothing
Set the fgApproximate flag.
When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only

- the number of bins in the profile3D is less than 10404 (eg 100x100x100)
- the bin number of entries is small ( <5)
- the estimated bin error is extremely small compared to the bin content (see [TProfile3D!GetBinError](@ref))
""" TProfile3D!Approximate(this::ByRef1{TProfile3D}, approx::Bool)

# Wrapper of Int_t TScatter::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TScatter}, px::Int32, py::Int32)::Int32
Compute distance from point px,py to a scatter plot.
Compute the closest distance of approach from point px,py to this scatter plot. The distance is computed in pixels units.
""" DistancetoPrimitive(this::ByRef1{TScatter}, px::Int32, py::Int32)

# Wrapper of void TScatter::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TScatter}, event::Int32, px::Int32, py::Int32)::Nothing
Execute action corresponding to one event.
This member function is called when a graph is clicked with the locator

If Left button clicked on one of the line theend points, this point follows the cursor until button is released.

if Middle button clicked, the line is moved parallel to itself until the button is released.
""" ExecuteEvent(this::ByRef1{TScatter}, event::Int32, px::Int32, py::Int32)

# Wrapper of Double_t * TScatter::GetColor()
@trydoc raw"""
    GetColor(this::ByConstRef1{TScatter})::CxxPtr2{Float64}
Get the array of colors.

""" GetColor(this::ByConstRef1{TScatter})

# Wrapper of TGraph * TScatter::GetGraph()
@trydoc raw"""
    GetGraph(this::ByConstRef1{TScatter})::CxxPtr1{TGraph}
Get the graph holding X and Y positions.

""" GetGraph(this::ByConstRef1{TScatter})

# Wrapper of TH2F * TScatter::GetHistogram()
@trydoc raw"""
    GetHistogram(this::ByConstRef1{TScatter})::CxxPtr1{TH2F}
Get the graph histogram used for drawing axis.
Returns a pointer to the histogram used to draw the axis.
""" GetHistogram(this::ByConstRef1{TScatter})

# Wrapper of Double_t TScatter::GetMargin()
@trydoc raw"""
    GetMargin(this::ByConstRef1{TScatter})::Float64
Set the margin around the plot in %.

""" GetMargin(this::ByConstRef1{TScatter})

# Wrapper of Double_t TScatter::GetMaxMarkerSize()
@trydoc raw"""
    GetMaxMarkerSize(this::ByConstRef1{TScatter})::Float64
Get the largest marker size used to paint the markers.

""" GetMaxMarkerSize(this::ByConstRef1{TScatter})

# Wrapper of Double_t TScatter::GetMinMarkerSize()
@trydoc raw"""
    GetMinMarkerSize(this::ByConstRef1{TScatter})::Float64
Get the smallest marker size used to paint the markers.

""" GetMinMarkerSize(this::ByConstRef1{TScatter})

# Wrapper of Double_t * TScatter::GetSize()
@trydoc raw"""
    GetSize(this::ByConstRef1{TScatter})::CxxPtr2{Float64}
Get the array of marker sizes.

""" GetSize(this::ByConstRef1{TScatter})

# Wrapper of void TScatter::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TScatter}, chopt::ByCopy{String})::Nothing
Paint this scatter plot with its current attributes.

""" Paint(this::ByRef1{TScatter}, chopt::ByCopy{String})

# Wrapper of void TScatter::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TScatter}, chopt::ByCopy{String})::Nothing
Print graph and errors values.

""" Print(this::ByConstRef1{TScatter}, chopt::ByCopy{String})

# Wrapper of void TScatter::SetHistogram(TH2F *)
@trydoc raw"""
    SetHistogram(this::ByRef1{TScatter}, h::ByPtr1{TH2F})::Nothing


""" SetHistogram(this::ByRef1{TScatter}, h::ByPtr1{TH2F})

# Wrapper of void TScatter::SetMargin(Double_t)
@trydoc raw"""
    SetMargin(this::ByRef1{TScatter}, ::Float64)::Nothing
Set the margin around the plot in %.

""" SetMargin(this::ByRef1{TScatter}, ::Float64)

# Wrapper of void TScatter::SetMaxMarkerSize(Double_t)
@trydoc raw"""
    SetMaxMarkerSize(this::ByRef1{TScatter}, max::Float64)::Nothing
Set the largest marker size used to paint the markers.

""" SetMaxMarkerSize(this::ByRef1{TScatter}, max::Float64)

# Wrapper of void TScatter::SetMinMarkerSize(Double_t)
@trydoc raw"""
    SetMinMarkerSize(this::ByRef1{TScatter}, min::Float64)::Nothing
Set the smallest marker size used to paint the markers.

""" SetMinMarkerSize(this::ByRef1{TScatter}, min::Float64)

# Wrapper of Double_t TSplinePoly::Eval(Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TSplinePoly}, ::Float64)::Float64


""" Eval(this::ByConstRef1{TSplinePoly}, ::Float64)

# Wrapper of void TSplinePoly::GetKnot(Double_t &, Double_t &)
@trydoc raw"""
    GetKnot(this::ByConstRef1{TSplinePoly}, x::ByRef2{Float64}, y::ByRef2{Float64})::Nothing


""" GetKnot(this::ByConstRef1{TSplinePoly}, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of Double_t & TSplinePoly::X()
@trydoc raw"""
    X(this::ByRef1{TSplinePoly})::CxxRef2{Float64}


""" X(this::ByRef1{TSplinePoly})

# Wrapper of Double_t & TSplinePoly::Y()
@trydoc raw"""
    Y(this::ByRef1{TSplinePoly})::CxxRef2{Float64}


""" Y(this::ByRef1{TSplinePoly})

# Wrapper of Double_t & TSplinePoly3::B()
@trydoc raw"""
    B(this::ByRef1{TSplinePoly3})::CxxRef2{Float64}


""" B(this::ByRef1{TSplinePoly3})

# Wrapper of Double_t & TSplinePoly3::C()
@trydoc raw"""
    C(this::ByRef1{TSplinePoly3})::CxxRef2{Float64}


""" C(this::ByRef1{TSplinePoly3})

# Wrapper of Double_t & TSplinePoly3::D()
@trydoc raw"""
    D(this::ByRef1{TSplinePoly3})::CxxRef2{Float64}


""" D(this::ByRef1{TSplinePoly3})

# Wrapper of Double_t TSplinePoly3::Derivative(Double_t)
@trydoc raw"""
    Derivative(this::ByConstRef1{TSplinePoly3}, x::Float64)::Float64


""" Derivative(this::ByConstRef1{TSplinePoly3}, x::Float64)

# Wrapper of Double_t TSplinePoly3::Eval(Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TSplinePoly3}, x::Float64)::Float64


""" Eval(this::ByConstRef1{TSplinePoly3}, x::Float64)

# Wrapper of Double_t & TSplinePoly5::B()
@trydoc raw"""
    B(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" B(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t & TSplinePoly5::C()
@trydoc raw"""
    C(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" C(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t & TSplinePoly5::D()
@trydoc raw"""
    D(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" D(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t TSplinePoly5::Derivative(Double_t)
@trydoc raw"""
    Derivative(this::ByConstRef1{TSplinePoly5}, x::Float64)::Float64


""" Derivative(this::ByConstRef1{TSplinePoly5}, x::Float64)

# Wrapper of Double_t & TSplinePoly5::E()
@trydoc raw"""
    E(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" E(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t TSplinePoly5::Eval(Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TSplinePoly5}, x::Float64)::Float64


""" Eval(this::ByConstRef1{TSplinePoly5}, x::Float64)

# Wrapper of Double_t & TSplinePoly5::F()
@trydoc raw"""
    F(this::ByRef1{TSplinePoly5})::CxxRef2{Float64}


""" F(this::ByRef1{TSplinePoly5})

# Wrapper of Double_t TSpline3::Derivative(Double_t)
@trydoc raw"""
    Derivative(this::ByConstRef1{TSpline3}, x::Float64)::Float64
Derivative.

""" Derivative(this::ByConstRef1{TSpline3}, x::Float64)

# Wrapper of Double_t TSpline3::Eval(Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TSpline3}, x::Float64)::Float64
Eval this spline at x.

""" Eval(this::ByConstRef1{TSpline3}, x::Float64)

# Wrapper of Int_t TSpline3::FindX(Double_t)
@trydoc raw"""
    FindX(this::ByConstRef1{TSpline3}, x::Float64)::Int32
Find X.

""" FindX(this::ByConstRef1{TSpline3}, x::Float64)

# Wrapper of void TSpline3::GetCoeff(Int_t, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetCoeff(this::ByConstRef1{TSpline3}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, b::ByRef2{Float64}, c::ByRef2{Float64}, d::ByRef2{Float64})::Nothing


""" GetCoeff(this::ByConstRef1{TSpline3}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, b::ByRef2{Float64}, c::ByRef2{Float64}, d::ByRef2{Float64})

# Wrapper of void TSpline3::GetKnot(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetKnot(this::ByConstRef1{TSpline3}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})::Nothing


""" GetKnot(this::ByConstRef1{TSpline3}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of TSpline3 & TSpline3::operator=(const TSpline3 &)
@trydoc raw"""
    assign(this::ByRef1{TSpline3}, ::ByConstRef1{TSpline3})::CxxRef1{TSpline3}
Assignment operator.

""" assign(this::ByRef1{TSpline3}, ::ByConstRef1{TSpline3})

# Wrapper of void TSpline3::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TSpline3}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Write this spline as a C++ function that can be executed without [ROOT](@ref) the name of the function is the name of the file up to the "." if any.

""" SaveAs(this::ByConstRef1{TSpline3}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TSpline3::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TSpline3}, i::Int32, x::Float64, y::Float64)::Nothing
Set point number i.

""" SetPoint(this::ByRef1{TSpline3}, i::Int32, x::Float64, y::Float64)

# Wrapper of void TSpline3::SetPointCoeff(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointCoeff(this::ByRef1{TSpline3}, i::Int32, b::Float64, c::Float64, d::Float64)::Nothing
Set point coefficient number i.

""" SetPointCoeff(this::ByRef1{TSpline3}, i::Int32, b::Float64, c::Float64, d::Float64)

# Wrapper of void TSpline3::Test()
@trydoc raw"""
    TSpline3!Test(this::ByRef1{TSpline3})::Nothing
Test method for [TSpline5](@ref).
n          number of data points.
    m          2*m-1 is order of spline.
                  m = 2 always for third spline.
    nn,nm1,mm,
    mm1,i,k,
    j,jj       temporary integer variables.
    z,p        temporary double precision variables.
    x[n]       the sequence of knots.
    y[n]       the prescribed function values at the knots.
    a[200][4]  two dimensional array whose columns are
                  the computed spline coefficients
    diff[3]    maximum values of differences of values and
                  derivatives to right and left of knots.
    com[3]     maximum values of coefficients.

(C++ version of the code)

test of [TSpline3](@ref) with non equidistant knots and equidistant knots follows.
""" TSpline3!Test(this::ByRef1{TSpline3})

# Wrapper of Double_t TSpline5::Derivative(Double_t)
@trydoc raw"""
    Derivative(this::ByConstRef1{TSpline5}, x::Float64)::Float64
Derivative.

""" Derivative(this::ByConstRef1{TSpline5}, x::Float64)

# Wrapper of Double_t TSpline5::Eval(Double_t)
@trydoc raw"""
    Eval(this::ByConstRef1{TSpline5}, x::Float64)::Float64
Eval this spline at x.

""" Eval(this::ByConstRef1{TSpline5}, x::Float64)

# Wrapper of Int_t TSpline5::FindX(Double_t)
@trydoc raw"""
    FindX(this::ByConstRef1{TSpline5}, x::Float64)::Int32
Find X.

""" FindX(this::ByConstRef1{TSpline5}, x::Float64)

# Wrapper of void TSpline5::GetCoeff(Int_t, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetCoeff(this::ByConstRef1{TSpline5}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, b::ByRef2{Float64}, c::ByRef2{Float64}, d::ByRef2{Float64}, e::ByRef2{Float64}, f::ByRef2{Float64})::Nothing


""" GetCoeff(this::ByConstRef1{TSpline5}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, b::ByRef2{Float64}, c::ByRef2{Float64}, d::ByRef2{Float64}, e::ByRef2{Float64}, f::ByRef2{Float64})

# Wrapper of void TSpline5::GetKnot(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetKnot(this::ByConstRef1{TSpline5}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})::Nothing


""" GetKnot(this::ByConstRef1{TSpline5}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64})

# Wrapper of TSpline5 & TSpline5::operator=(const TSpline5 &)
@trydoc raw"""
    assign(this::ByRef1{TSpline5}, ::ByConstRef1{TSpline5})::CxxRef1{TSpline5}
Assignment operator.

""" assign(this::ByRef1{TSpline5}, ::ByConstRef1{TSpline5})

# Wrapper of void TSpline5::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TSpline5}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Write this spline as a C++ function that can be executed without [ROOT](@ref) the name of the function is the name of the file up to the "." if any.

""" SaveAs(this::ByConstRef1{TSpline5}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TSpline5::SetPoint(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetPoint(this::ByRef1{TSpline5}, i::Int32, x::Float64, y::Float64)::Nothing
Set point number i.

""" SetPoint(this::ByRef1{TSpline5}, i::Int32, x::Float64, y::Float64)

# Wrapper of void TSpline5::SetPointCoeff(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetPointCoeff(this::ByRef1{TSpline5}, i::Int32, b::Float64, c::Float64, d::Float64, e::Float64, f::Float64)::Nothing
Set point coefficient number i.

""" SetPointCoeff(this::ByRef1{TSpline5}, i::Int32, b::Float64, c::Float64, d::Float64, e::Float64, f::Float64)

# Wrapper of void TSpline5::Test()
@trydoc raw"""
    TSpline5!Test(this::ByRef1{TSpline5})::Nothing
Test method for [TSpline5](@ref).
n          number of data points.
    m          2*m-1 is order of spline.
                  m = 3 always for quintic spline.
    nn,nm1,mm,
    mm1,i,k,
    j,jj       temporary integer variables.
    z,p        temporary double precision variables.
    x[n]       the sequence of knots.
    y[n]       the prescribed function values at the knots.
    a[200][6]  two dimensional array whose columns are
                  the computed spline coefficients
    diff[5]    maximum values of differences of values and
                  derivatives to right and left of knots.
    com[5]     maximum values of coefficients.

(C++ version of the code)

test of [TSpline5](@ref) with non equidistant knots and equidistant knots follows.
""" TSpline5!Test(this::ByRef1{TSpline5})

# Wrapper of Double_t TSVDUnfold::ComputeChiSquared(const TH1D &, const TH1D &)
@trydoc raw"""
    ComputeChiSquared(this::ByRef1{TSVDUnfold}, truspec::ByConstRef1{TH1D}, unfspec::ByConstRef1{TH1D})::Float64
Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper.

""" ComputeChiSquared(this::ByRef1{TSVDUnfold}, truspec::ByConstRef1{TH1D}, unfspec::ByConstRef1{TH1D})

# Wrapper of TH2D * TSVDUnfold::GetAdetCovMatrix(Int_t, Int_t)
@trydoc raw"""
    GetAdetCovMatrix(this::ByRef1{TSVDUnfold}, ntoys::Int32, seed::Int32)::CxxPtr1{TH2D}
Determine covariance matrix of unfolded spectrum from finite statistics in response matrix using pseudo experiments "ntoys" - number of pseudo experiments used for the propagation "seed" - seed for pseudo experiments.

""" GetAdetCovMatrix(this::ByRef1{TSVDUnfold}, ntoys::Int32, seed::Int32)

# Wrapper of TH2D * TSVDUnfold::GetBCov()
@trydoc raw"""
    GetBCov(this::ByConstRef1{TSVDUnfold})::CxxPtr1{TH2D}
Returns the covariance matrix.

""" GetBCov(this::ByConstRef1{TSVDUnfold})

# Wrapper of TH1D * TSVDUnfold::GetD()
@trydoc raw"""
    GetD(this::ByConstRef1{TSVDUnfold})::CxxPtr1{TH1D}
Returns d vector (for choosing appropriate regularisation)

""" GetD(this::ByConstRef1{TSVDUnfold})

# Wrapper of Int_t TSVDUnfold::GetKReg()
@trydoc raw"""
    GetKReg(this::ByConstRef1{TSVDUnfold})::Int32


""" GetKReg(this::ByConstRef1{TSVDUnfold})

# Wrapper of TH1D * TSVDUnfold::GetSV()
@trydoc raw"""
    GetSV(this::ByConstRef1{TSVDUnfold})::CxxPtr1{TH1D}
Returns singular values vector.

""" GetSV(this::ByConstRef1{TSVDUnfold})

# Wrapper of TH2D * TSVDUnfold::GetUnfoldCovMatrix(const TH2D *, Int_t, Int_t)
@trydoc raw"""
    GetUnfoldCovMatrix(this::ByRef1{TSVDUnfold}, cov::ByConstPtr1{TH2D}, ntoys::Int32, seed::Int32)::CxxPtr1{TH2D}
Determine for given input error matrix covariance matrix of unfolded spectrum from toy simulation given the passed covariance matrix on measured spectrum "cov" - covariance matrix on the measured spectrum, to be propagated "ntoys" - number of pseudo experiments used for the propagation "seed" - seed for pseudo experiments Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area.

""" GetUnfoldCovMatrix(this::ByRef1{TSVDUnfold}, cov::ByConstPtr1{TH2D}, ntoys::Int32, seed::Int32)

# Wrapper of TH2D * TSVDUnfold::GetXinv()
@trydoc raw"""
    GetXinv(this::ByConstRef1{TSVDUnfold})::CxxPtr1{TH2D}
Returns the computed inverse of the covariance matrix.

""" GetXinv(this::ByConstRef1{TSVDUnfold})

# Wrapper of TH2D * TSVDUnfold::GetXtau()
@trydoc raw"""
    GetXtau(this::ByConstRef1{TSVDUnfold})::CxxPtr1{TH2D}
Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor.
Note that this covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area.
""" GetXtau(this::ByConstRef1{TSVDUnfold})

# Wrapper of void TSVDUnfold::SetNormalize(Bool_t)
@trydoc raw"""
    SetNormalize(this::ByRef1{TSVDUnfold}, normalize::Bool)::Nothing


""" SetNormalize(this::ByRef1{TSVDUnfold}, normalize::Bool)

# Wrapper of TH1D * TSVDUnfold::Unfold(Int_t)
@trydoc raw"""
    Unfold(this::ByRef1{TSVDUnfold}, kreg::Int32)::CxxPtr1{TH1D}
Perform the unfolding with regularisation parameter kreg.

""" Unfold(this::ByRef1{TSVDUnfold}, kreg::Int32)

# Wrapper of Int_t TVirtualGraphPainter::DistancetoPrimitiveHelper(TGraph *, Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitiveHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, px::Int32, py::Int32)::Int32


""" DistancetoPrimitiveHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, px::Int32, py::Int32)

# Wrapper of void TVirtualGraphPainter::DrawPanelHelper(TGraph *)
@trydoc raw"""
    DrawPanelHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})::Nothing


""" DrawPanelHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})

# Wrapper of void TVirtualGraphPainter::ExecuteEventHelper(TGraph *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEventHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteEventHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, event::Int32, px::Int32, py::Int32)

# Wrapper of char * TVirtualGraphPainter::GetObjectInfoHelper(TGraph *, Int_t, Int_t)
@trydoc raw"""
    GetObjectInfoHelper(this::ByConstRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}


""" GetObjectInfoHelper(this::ByConstRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, px::Int32, py::Int32)

# Wrapper of void TVirtualGraphPainter::PaintGraph(TGraph *, Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGraph(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing


""" PaintGraph(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintGrapHist(TGraph *, Int_t, const Double_t *, const Double_t *, Option_t *)
@trydoc raw"""
    PaintGrapHist(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})::Nothing


""" PaintGrapHist(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, npoints::Int32, x::ByConstPtr2{Float64}, y::ByConstPtr2{Float64}, chopt::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintHelper(TGraph *, Option_t *)
@trydoc raw"""
    PaintHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, option::ByCopy{String})::Nothing


""" PaintHelper(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, option::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintScatter(TScatter *, Option_t *)
@trydoc raw"""
    PaintScatter(this::ByRef1{TVirtualGraphPainter}, theScatter::ByPtr1{TScatter}, option::ByCopy{String})::Nothing


""" PaintScatter(this::ByRef1{TVirtualGraphPainter}, theScatter::ByPtr1{TScatter}, option::ByCopy{String})

# Wrapper of void TVirtualGraphPainter::PaintStats(TGraph *, TF1 *)
@trydoc raw"""
    PaintStats(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, fit::ByPtr1{TF1})::Nothing


""" PaintStats(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph}, fit::ByPtr1{TF1})

# Wrapper of void TVirtualGraphPainter::SetHighlight(TGraph *)
@trydoc raw"""
    SetHighlight(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})::Nothing


""" SetHighlight(this::ByRef1{TVirtualGraphPainter}, theGraph::ByPtr1{TGraph})

# Wrapper of TVirtualGraphPainter * TVirtualGraphPainter::GetPainter()
@trydoc raw"""
    TVirtualGraphPainter!GetPainter(this::ByRef1{TVirtualGraphPainter})::CxxPtr1{TVirtualGraphPainter}
Static function returning a pointer to the current graph painter.
If the graph painter does not exist a default painter (singleton) is created.
""" TVirtualGraphPainter!GetPainter(this::ByRef1{TVirtualGraphPainter})

# Wrapper of void TVirtualGraphPainter::SetPainter(TVirtualGraphPainter *)
@trydoc raw"""
    TVirtualGraphPainter!SetPainter(this::ByRef1{TVirtualGraphPainter}, painter::ByPtr1{TVirtualGraphPainter})::Nothing
Static function to set an alternative histogram painter.

""" TVirtualGraphPainter!SetPainter(this::ByRef1{TVirtualGraphPainter}, painter::ByPtr1{TVirtualGraphPainter})

# Wrapper of TObject * TVirtualPaveStats::GetParent()
@trydoc raw"""
    GetParent(this::ByConstRef1{TVirtualPaveStats})::CxxPtr1{TObject}


""" GetParent(this::ByConstRef1{TVirtualPaveStats})

# Wrapper of void TVirtualPaveStats::SetParent(TObject *)
@trydoc raw"""
    SetParent(this::ByRef1{TVirtualPaveStats}, ::ByPtr1{TObject})::Nothing


""" SetParent(this::ByRef1{TVirtualPaveStats}, ::ByPtr1{TObject})

# Wrapper of Double_t TGDMLMatrix::Get(size_t, size_t)
@trydoc raw"""
    Get(this::ByConstRef1{TGDMLMatrix}, r::Int64, c::Int64)::Float64


""" Get(this::ByConstRef1{TGDMLMatrix}, r::Int64, c::Int64)

# Wrapper of size_t TGDMLMatrix::GetCols()
@trydoc raw"""
    GetCols(this::ByConstRef1{TGDMLMatrix})::Int64


""" GetCols(this::ByConstRef1{TGDMLMatrix})

# Wrapper of const char * TGDMLMatrix::GetMatrixAsString()
@trydoc raw"""
    GetMatrixAsString(this::ByConstRef1{TGDMLMatrix})::ByCopy{String}


""" GetMatrixAsString(this::ByConstRef1{TGDMLMatrix})

# Wrapper of size_t TGDMLMatrix::GetRows()
@trydoc raw"""
    GetRows(this::ByConstRef1{TGDMLMatrix})::Int64


""" GetRows(this::ByConstRef1{TGDMLMatrix})

# Wrapper of TGDMLMatrix & TGDMLMatrix::operator=(const TGDMLMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGDMLMatrix}, rhs::ByConstRef1{TGDMLMatrix})::CxxRef1{TGDMLMatrix}


""" assign(this::ByRef1{TGDMLMatrix}, rhs::ByConstRef1{TGDMLMatrix})

# Wrapper of void TGDMLMatrix::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGDMLMatrix}, option::ByCopy{String})::Nothing
Print [TNamed](@ref) name and title.

""" Print(this::ByConstRef1{TGDMLMatrix}, option::ByCopy{String})

# Wrapper of void TGDMLMatrix::Set(size_t, size_t, Double_t)
@trydoc raw"""
    Set(this::ByRef1{TGDMLMatrix}, r::Int64, c::Int64, a::Float64)::Nothing


""" Set(this::ByRef1{TGDMLMatrix}, r::Int64, c::Int64, a::Float64)

# Wrapper of void TGDMLMatrix::SetMatrixAsString(const char *)
@trydoc raw"""
    SetMatrixAsString(this::ByRef1{TGDMLMatrix}, mat::ByCopy{String})::Nothing


""" SetMatrixAsString(this::ByRef1{TGDMLMatrix}, mat::ByCopy{String})

# Wrapper of void TGeoShape::AfterStreamer()
@trydoc raw"""
    AfterStreamer(this::ByRef1{TGeoShape})::Nothing


""" AfterStreamer(this::ByRef1{TGeoShape})

# Wrapper of Double_t TGeoShape::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoShape})::Float64


""" Capacity(this::ByConstRef1{TGeoShape})

# Wrapper of void TGeoShape::CheckShape(Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing
Test for shape navigation methods.
Summary for test numbers:

- 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2)
""" CheckShape(this::ByRef1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of void TGeoShape::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoShape})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoShape})

# Wrapper of void TGeoShape::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoShape})::Nothing


""" ComputeBBox(this::ByRef1{TGeoShape})

# Wrapper of void TGeoShape::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing


""" ComputeNormal(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoShape::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32)::Nothing


""" ComputeNormal_v(this::ByRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32)

# Wrapper of Bool_t TGeoShape::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64})::Bool


""" Contains(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoShape::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByPtr2{Bool}, ::Int32)::Nothing


""" Contains_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByPtr2{Bool}, ::Int32)

# Wrapper of Bool_t TGeoShape::CouldBeCrossed(const Double_t *, const Double_t *)
@trydoc raw"""
    CouldBeCrossed(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})::Bool


""" CouldBeCrossed(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of void TGeoShape::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoShape}, ::Int32)::Nothing


""" CreateThreadData(this::ByRef1{TGeoShape}, ::Int32)

# Wrapper of Int_t TGeoShape::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoShape}, px::Int32, py::Int32)::Int32
Computes distance from point (px,py) to the object.
This member function must be implemented for each graphics primitive. This default function returns a big number (999999).
""" DistancetoPrimitive(this::ByRef1{TGeoShape}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoShape::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64


""" DistFromInside(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoShape::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32, ::ByPtr2{Float64})::Nothing


""" DistFromInside_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32, ::ByPtr2{Float64})

# Wrapper of Double_t TGeoShape::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64


""" DistFromOutside(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoShape::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32, ::ByPtr2{Float64})::Nothing


""" DistFromOutside_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Float64}, ::ByPtr2{Float64}, ::Int32, ::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoShape::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}


""" Divide(this::ByRef1{TGeoShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoShape::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoShape}, option::ByCopy{String})::Nothing
Draw this shape.

""" Draw(this::ByRef1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TGeoShape::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoShape}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this shape.

""" ExecuteEvent(this::ByRef1{TGeoShape}, event::Int32, px::Int32, py::Int32)

# Wrapper of const char * TGeoShape::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoShape}, iaxis::Int32)::ByCopy{String}


""" GetAxisName(this::ByConstRef1{TGeoShape}, iaxis::Int32)

# Wrapper of Double_t TGeoShape::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoShape}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64


""" GetAxisRange(this::ByConstRef1{TGeoShape}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoShape::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoShape}, param::ByPtr2{Float64})::Nothing


""" GetBoundingCylinder(this::ByConstRef1{TGeoShape}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoShape::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoShape})::Int32


""" GetByteCount(this::ByConstRef1{TGeoShape})

# Wrapper of Int_t TGeoShape::GetFittingBox(const TGeoBBox *, TGeoMatrix *, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetFittingBox(this::ByConstRef1{TGeoShape}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})::Int32


""" GetFittingBox(this::ByConstRef1{TGeoShape}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})

# Wrapper of Int_t TGeoShape::GetId()
@trydoc raw"""
    GetId(this::ByConstRef1{TGeoShape})::Int32


""" GetId(this::ByConstRef1{TGeoShape})

# Wrapper of TGeoShape * TGeoShape::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoShape}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}


""" GetMakeRuntimeShape(this::ByConstRef1{TGeoShape}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoShape::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoShape}, ::ByRef2{Int32}, ::ByRef2{Int32}, ::ByRef2{Int32})::Nothing


""" GetMeshNumbers(this::ByConstRef1{TGeoShape}, ::ByRef2{Int32}, ::ByRef2{Int32}, ::ByRef2{Int32})

# Wrapper of const char * TGeoShape::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TGeoShape})::ByCopy{String}
Get the shape name.

""" GetName(this::ByConstRef1{TGeoShape})

# Wrapper of Int_t TGeoShape::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoShape})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoShape})

# Wrapper of const char * TGeoShape::GetPointerName()
@trydoc raw"""
    GetPointerName(this::ByConstRef1{TGeoShape})::ByCopy{String}
Provide a pointer name containing uid.

""" GetPointerName(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoShape}, npoints::Int32, array::ByPtr2{Float64})::Bool


""" GetPointsOnSegments(this::ByConstRef1{TGeoShape}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoShape::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoShape})::Nothing


""" InspectShape(this::ByConstRef1{TGeoShape})

# Wrapper of void TGeoShape::InvertShapeBit(UInt_t)
@trydoc raw"""
    InvertShapeBit(this::ByRef1{TGeoShape}, f::UInt32)::Nothing


""" InvertShapeBit(this::ByRef1{TGeoShape}, f::UInt32)

# Wrapper of Bool_t TGeoShape::IsAssembly()
@trydoc raw"""
    IsAssembly(this::ByConstRef1{TGeoShape})::Bool


""" IsAssembly(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsComposite()
@trydoc raw"""
    IsComposite(this::ByConstRef1{TGeoShape})::Bool


""" IsComposite(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoShape})::Bool


""" IsCylType(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsReflected()
@trydoc raw"""
    IsReflected(this::ByConstRef1{TGeoShape})::Bool


""" IsReflected(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsRunTimeShape()
@trydoc raw"""
    IsRunTimeShape(this::ByConstRef1{TGeoShape})::Bool


""" IsRunTimeShape(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsValid()
@trydoc raw"""
    IsValid(this::ByConstRef1{TGeoShape})::Bool


""" IsValid(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsValidBox()
@trydoc raw"""
    IsValidBox(this::ByConstRef1{TGeoShape})::Bool


""" IsValidBox(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsVecGeom()
@trydoc raw"""
    IsVecGeom(this::ByConstRef1{TGeoShape})::Bool


""" IsVecGeom(this::ByConstRef1{TGeoShape})

# Wrapper of void TGeoShape::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoShape}, option::ByCopy{String})::Nothing
Paint this shape.

""" Paint(this::ByRef1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TGeoShape::ResetShapeBit(UInt_t)
@trydoc raw"""
    ResetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)::Nothing


""" ResetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)

# Wrapper of Double_t TGeoShape::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, in::Bool)::Float64


""" Safety(this::ByConstRef1{TGeoShape}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoShape::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Bool}, ::ByPtr2{Float64}, ::Int32)::Nothing


""" Safety_v(this::ByConstRef1{TGeoShape}, ::ByConstPtr2{Float64}, ::ByConstPtr2{Bool}, ::ByPtr2{Float64}, ::Int32)

# Wrapper of void TGeoShape::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoShape}, param::ByPtr2{Float64})::Nothing


""" SetDimensions(this::ByRef1{TGeoShape}, param::ByPtr2{Float64})

# Wrapper of void TGeoShape::SetId(Int_t)
@trydoc raw"""
    SetId(this::ByRef1{TGeoShape}, id::Int32)::Nothing


""" SetId(this::ByRef1{TGeoShape}, id::Int32)

# Wrapper of void TGeoShape::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoShape}, points::ByPtr2{Float64})::Nothing


""" SetPoints(this::ByConstRef1{TGeoShape}, points::ByPtr2{Float64})

# Wrapper of void TGeoShape::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoShape}, points::ByPtr2{Float32})::Nothing


""" SetPoints(this::ByConstRef1{TGeoShape}, points::ByPtr2{Float32})

# Wrapper of void TGeoShape::SetRuntime(Bool_t)
@trydoc raw"""
    SetRuntime(this::ByRef1{TGeoShape}, flag::Bool)::Nothing


""" SetRuntime(this::ByRef1{TGeoShape}, flag::Bool)

# Wrapper of void TGeoShape::SetShapeBit(UInt_t)
@trydoc raw"""
    SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)::Nothing


""" SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32)

# Wrapper of void TGeoShape::SetShapeBit(UInt_t, Bool_t)
@trydoc raw"""
    SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32, set::Bool)::Nothing
Equivalent of [TObject!SetBit](@ref).
""" SetShapeBit(this::ByRef1{TGeoShape}, f::UInt32, set::Bool)

# Wrapper of Int_t TGeoShape::ShapeDistancetoPrimitive(Int_t, Int_t, Int_t)
@trydoc raw"""
    ShapeDistancetoPrimitive(this::ByConstRef1{TGeoShape}, numpoints::Int32, px::Int32, py::Int32)::Int32
Returns distance to shape primitive mesh.

""" ShapeDistancetoPrimitive(this::ByConstRef1{TGeoShape}, numpoints::Int32, px::Int32, py::Int32)

# Wrapper of void TGeoShape::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoShape})::Nothing


""" Sizeof3D(this::ByConstRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::TestShapeBit(UInt_t)
@trydoc raw"""
    TestShapeBit(this::ByConstRef1{TGeoShape}, f::UInt32)::Bool


""" TestShapeBit(this::ByConstRef1{TGeoShape}, f::UInt32)

# Wrapper of Int_t TGeoShape::TestShapeBits(UInt_t)
@trydoc raw"""
    TestShapeBits(this::ByConstRef1{TGeoShape}, f::UInt32)::Int32


""" TestShapeBits(this::ByConstRef1{TGeoShape}, f::UInt32)

# Wrapper of Double_t TGeoShape::Big()
@trydoc raw"""
    TGeoShape!Big(this::ByRef1{TGeoShape})::Float64


""" TGeoShape!Big(this::ByRef1{TGeoShape})

# Wrapper of Double_t TGeoShape::ComputeEpsMch()
@trydoc raw"""
    TGeoShape!ComputeEpsMch(this::ByRef1{TGeoShape})::Float64
Compute machine round-off double precision error as the smallest number that if added to 1.0 is different than 1.0.

""" TGeoShape!ComputeEpsMch(this::ByRef1{TGeoShape})

# Wrapper of Double_t TGeoShape::DistToPhiMin(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TGeoShape!DistToPhiMin(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, s1::Float64, c1::Float64, s2::Float64, c2::Float64, sm::Float64, cm::Float64, in::Bool)::Float64
compute distance from point (inside phi) to both phi planes. Return minimum.

""" TGeoShape!DistToPhiMin(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, s1::Float64, c1::Float64, s2::Float64, c2::Float64, sm::Float64, cm::Float64, in::Bool)

# Wrapper of Double_t TGeoShape::EpsMch()
@trydoc raw"""
    TGeoShape!EpsMch(this::ByRef1{TGeoShape})::Float64
static function returning the machine round-off error

""" TGeoShape!EpsMch(this::ByRef1{TGeoShape})

# Wrapper of TGeoMatrix * TGeoShape::GetTransform()
@trydoc raw"""
    TGeoShape!GetTransform(this::ByRef1{TGeoShape})::CxxPtr1{TGeoMatrix}
Returns current transformation matrix that applies to shape.

""" TGeoShape!GetTransform(this::ByRef1{TGeoShape})

# Wrapper of Bool_t TGeoShape::IsCloseToPhi(Double_t, const Double_t *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoShape!IsCloseToPhi(this::ByRef1{TGeoShape}, epsil::Float64, point::ByConstPtr2{Float64}, c1::Float64, s1::Float64, c2::Float64, s2::Float64)::Bool
True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2.

""" TGeoShape!IsCloseToPhi(this::ByRef1{TGeoShape}, epsil::Float64, point::ByConstPtr2{Float64}, c1::Float64, s1::Float64, c2::Float64, s2::Float64)

# Wrapper of Bool_t TGeoShape::IsCrossingSemiplane(const Double_t *, const Double_t *, Double_t, Double_t, Double_t &, Double_t &)
@trydoc raw"""
    TGeoShape!IsCrossingSemiplane(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, cphi::Float64, sphi::Float64, snext::ByRef2{Float64}, rxy::ByRef2{Float64})::Bool
Compute distance from POINT to semiplane defined by PHI angle along DIR.
Computes also radius at crossing point. This might be negative in case the crossing is on the other side of the semiplane.
""" TGeoShape!IsCrossingSemiplane(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, cphi::Float64, sphi::Float64, snext::ByRef2{Float64}, rxy::ByRef2{Float64})

# Wrapper of Bool_t TGeoShape::IsInPhiRange(const Double_t *, Double_t, Double_t)
@trydoc raw"""
    TGeoShape!IsInPhiRange(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, phi1::Float64, phi2::Float64)::Bool
Static method to check if a point is in the phi range (phi1, phi2) [degrees].

""" TGeoShape!IsInPhiRange(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, phi1::Float64, phi2::Float64)

# Wrapper of Bool_t TGeoShape::IsSameWithinTolerance(Double_t, Double_t)
@trydoc raw"""
    TGeoShape!IsSameWithinTolerance(this::ByRef1{TGeoShape}, a::Float64, b::Float64)::Bool
Check if two numbers differ with less than a tolerance.

""" TGeoShape!IsSameWithinTolerance(this::ByRef1{TGeoShape}, a::Float64, b::Float64)

# Wrapper of Bool_t TGeoShape::IsSegCrossing(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoShape!IsSegCrossing(this::ByRef1{TGeoShape}, x1::Float64, y1::Float64, x2::Float64, y2::Float64, x3::Float64, y3::Float64, x4::Float64, y4::Float64)::Bool
Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4)

""" TGeoShape!IsSegCrossing(this::ByRef1{TGeoShape}, x1::Float64, y1::Float64, x2::Float64, y2::Float64, x3::Float64, y3::Float64, x4::Float64, y4::Float64)

# Wrapper of void TGeoShape::NormalPhi(const Double_t *, const Double_t *, Double_t *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoShape!NormalPhi(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, c1::Float64, s1::Float64, c2::Float64, s2::Float64)::Nothing
Static method to compute normal to phi planes.

""" TGeoShape!NormalPhi(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, c1::Float64, s1::Float64, c2::Float64, s2::Float64)

# Wrapper of Double_t TGeoShape::SafetyPhi(const Double_t *, Bool_t, Double_t, Double_t)
@trydoc raw"""
    TGeoShape!SafetyPhi(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, in::Bool, phi1::Float64, phi2::Float64)::Float64
Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2.

""" TGeoShape!SafetyPhi(this::ByRef1{TGeoShape}, point::ByConstPtr2{Float64}, in::Bool, phi1::Float64, phi2::Float64)

# Wrapper of Double_t TGeoShape::SafetySeg(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    TGeoShape!SafetySeg(this::ByRef1{TGeoShape}, r::Float64, z::Float64, r1::Float64, z1::Float64, r2::Float64, z2::Float64, outer::Bool)::Float64
Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2)

""" TGeoShape!SafetySeg(this::ByRef1{TGeoShape}, r::Float64, z::Float64, r1::Float64, z1::Float64, r2::Float64, z2::Float64, outer::Bool)

# Wrapper of void TGeoShape::SetTransform(TGeoMatrix *)
@trydoc raw"""
    TGeoShape!SetTransform(this::ByRef1{TGeoShape}, matrix::ByPtr1{TGeoMatrix})::Nothing
Set current transformation matrix that applies to shape.

""" TGeoShape!SetTransform(this::ByRef1{TGeoShape}, matrix::ByPtr1{TGeoMatrix})

# Wrapper of Double_t TGeoShape::Tolerance()
@trydoc raw"""
    TGeoShape!Tolerance(this::ByRef1{TGeoShape})::Float64


""" TGeoShape!Tolerance(this::ByRef1{TGeoShape})

# Wrapper of Int_t TGeoMatrix::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoMatrix})::Int32
Get total size in bytes of this.

""" GetByteCount(this::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::GetHomogenousMatrix(Double_t *)
@trydoc raw"""
    GetHomogenousMatrix(this::ByConstRef1{TGeoMatrix}, hmat::ByPtr2{Float64})::Nothing
The homogenous matrix associated with the transformation is used for piling up's and visualization.
A homogenous matrix is a 4*4 array containing the translation, the rotation and the scale components 

    | R00*sx  R01    R02    dx |
    | R10    R11*sy  R12    dy |
    | R20     R21   R22*sz  dz |
    |  0       0      0      1 |

(C++ version of the code)

 where Rij is the rotation matrix, (sx, sy, sz) is the scale transformation and (dx, dy, dz) is the translation.
""" GetHomogenousMatrix(this::ByConstRef1{TGeoMatrix}, hmat::ByPtr2{Float64})

# Wrapper of const char * TGeoMatrix::GetPointerName()
@trydoc raw"""
    GetPointerName(this::ByConstRef1{TGeoMatrix})::ByCopy{String}
Provide a pointer name containing uid.

""" GetPointerName(this::ByConstRef1{TGeoMatrix})

# Wrapper of const Double_t * TGeoMatrix::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoMatrix})::ConstCxxPtr2{Float64}


""" GetRotationMatrix(this::ByConstRef1{TGeoMatrix})

# Wrapper of const Double_t * TGeoMatrix::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoMatrix})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoMatrix})

# Wrapper of const Double_t * TGeoMatrix::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoMatrix})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoHMatrix TGeoMatrix::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoMatrix})::ByCopy{TGeoHMatrix}


""" Inverse(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsCombi()
@trydoc raw"""
    IsCombi(this::ByConstRef1{TGeoMatrix})::Bool


""" IsCombi(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsGeneral()
@trydoc raw"""
    IsGeneral(this::ByConstRef1{TGeoMatrix})::Bool


""" IsGeneral(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsIdentity()
@trydoc raw"""
    IsIdentity(this::ByConstRef1{TGeoMatrix})::Bool


""" IsIdentity(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsOwned()
@trydoc raw"""
    IsOwned(this::ByConstRef1{TGeoMatrix})::Bool


""" IsOwned(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsReflection()
@trydoc raw"""
    IsReflection(this::ByConstRef1{TGeoMatrix})::Bool


""" IsReflection(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsRegistered()
@trydoc raw"""
    IsRegistered(this::ByConstRef1{TGeoMatrix})::Bool


""" IsRegistered(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsRotAboutZ()
@trydoc raw"""
    IsRotAboutZ(this::ByConstRef1{TGeoMatrix})::Bool
Returns true if no rotation or the rotation is about Z axis.

""" IsRotAboutZ(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsRotation()
@trydoc raw"""
    IsRotation(this::ByConstRef1{TGeoMatrix})::Bool


""" IsRotation(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsScale()
@trydoc raw"""
    IsScale(this::ByConstRef1{TGeoMatrix})::Bool


""" IsScale(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsShared()
@trydoc raw"""
    IsShared(this::ByConstRef1{TGeoMatrix})::Bool


""" IsShared(this::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoMatrix::IsTranslation()
@trydoc raw"""
    IsTranslation(this::ByConstRef1{TGeoMatrix})::Bool


""" IsTranslation(this::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoMatrix}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMaster(this::ByConstRef1{TGeoMatrix}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoMatrix::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoMatrix}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterBomb(this::ByConstRef1{TGeoMatrix}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoMatrix::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoMatrix}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterVect(this::ByConstRef1{TGeoMatrix}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of TGeoMatrix * TGeoMatrix::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoMatrix})::CxxPtr1{TGeoMatrix}


""" MakeClone(this::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoMatrix}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocal(this::ByConstRef1{TGeoMatrix}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoMatrix::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoMatrix}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalBomb(this::ByConstRef1{TGeoMatrix}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoMatrix::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoMatrix}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalVect(this::ByConstRef1{TGeoMatrix}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoMatrix::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoMatrix}, option::ByCopy{String})::Nothing
print the matrix in 4x4 format

""" Print(this::ByConstRef1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoMatrix::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoMatrix::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoMatrix::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoMatrix::RegisterYourself()
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoMatrix})::Nothing
Register the matrix in the current manager, which will become the owner.

""" RegisterYourself(this::ByRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" RotateX(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" RotateY(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" RotateZ(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetDefaultName()
@trydoc raw"""
    SetDefaultName(this::ByRef1{TGeoMatrix})::Nothing
If no name was supplied in the ctor, the type of transformation is checked.
A letter will be prepended to the name :

- t - translation
- r - rotation
- s - scale
- c - combi (translation + rotation)
- g - general (tr+rot+scale) The index of the transformation in gGeoManager list of transformations will be appended.
""" SetDefaultName(this::ByRef1{TGeoMatrix})

# Wrapper of void TGeoMatrix::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoMatrix}, ::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoMatrix}, ::Float64)

# Wrapper of void TGeoMatrix::SetShared(Bool_t)
@trydoc raw"""
    SetShared(this::ByRef1{TGeoMatrix}, flag::Bool)::Nothing


""" SetShared(this::ByRef1{TGeoMatrix}, flag::Bool)

# Wrapper of void TGeoMatrix::Normalize(Double_t *)
@trydoc raw"""
    TGeoMatrix!Normalize(this::ByRef1{TGeoMatrix}, vect::ByPtr2{Float64})::Nothing
Normalize a vector.

""" TGeoMatrix!Normalize(this::ByRef1{TGeoMatrix}, vect::ByPtr2{Float64})

# Wrapper of TGeoNode * TGeoVolume::AddNode(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::CxxPtr1{TGeoNode}
Add a [TGeoNode](@ref) to the list of nodes.
This is the usual method for adding daughters inside the container volume.
""" AddNode(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolume::AddNodeOffset(TGeoVolume *, Int_t, Double_t, Option_t *)
@trydoc raw"""
    AddNodeOffset(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, offset::Float64, option::ByCopy{String})::Nothing
Add a division node to the list of nodes.
The method is called by [TGeoVolume!Divide()](@ref) for creating the division nodes.
""" AddNodeOffset(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, offset::Float64, option::ByCopy{String})

# Wrapper of void TGeoVolume::AddNodeOverlap(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNodeOverlap(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::Nothing
Add a [TGeoNode](@ref) to the list of nodes.
This is the usual method for adding daughters inside the container volume.
""" AddNodeOverlap(this::ByRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolume::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGeoVolume}, b::ByPtr1{TBrowser})::Nothing
How to browse a volume.

""" Browse(this::ByRef1{TGeoVolume}, b::ByPtr1{TBrowser})

# Wrapper of Double_t TGeoVolume::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoVolume})::Float64
Computes the capacity of this [cm^3] as the capacity of its shape.
In case of assemblies, the capacity is computed as the sum of daughter's capacities.
""" Capacity(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::cd(Int_t)
@trydoc raw"""
    cd(this::ByConstRef1{TGeoVolume}, inode::Int32)::Nothing
Actualize matrix of node indexed `<inode>`

""" cd(this::ByConstRef1{TGeoVolume}, inode::Int32)

# Wrapper of void TGeoVolume::CheckGeometry(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CheckGeometry(this::ByConstRef1{TGeoVolume}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64)::Nothing
Shoot nrays with random directions from starting point (startx, starty, startz) in the reference frame of this volume.
Track each ray until exiting geometry, then shoot backwards from exiting point and compare boundary crossing points.
""" CheckGeometry(this::ByConstRef1{TGeoVolume}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64)

# Wrapper of void TGeoVolume::CheckOverlaps(Double_t, Option_t *)
@trydoc raw"""
    CheckOverlaps(this::ByConstRef1{TGeoVolume}, ovlp::Float64, option::ByCopy{String})::Nothing
Overlap checking tool.
Check for illegal overlaps within a limit OVLP. Use option="s[number]" to force overlap checking by sampling volume with [number] points.

Ex: 

    myVol->CheckOverlaps(0.01, "s10000000"); // shoot 10000000 points
    myVol->CheckOverlaps(0.01, "s"); // shoot the default value of 1e6 points

(C++ version of the code)
""" CheckOverlaps(this::ByConstRef1{TGeoVolume}, ovlp::Float64, option::ByCopy{String})

# Wrapper of void TGeoVolume::CheckShape(Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TGeoVolume}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing
Tests for checking the shape navigation algorithms. See [TGeoShape!CheckShape()](@ref)
""" CheckShape(this::ByRef1{TGeoVolume}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of void TGeoVolume::CheckShapes()
@trydoc raw"""
    CheckShapes(this::ByRef1{TGeoVolume})::Nothing
check for negative parameters in shapes.

""" CheckShapes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::CleanAll()
@trydoc raw"""
    CleanAll(this::ByRef1{TGeoVolume})::Nothing
Clean data of the volume.

""" CleanAll(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::ClearNodes()
@trydoc raw"""
    ClearNodes(this::ByRef1{TGeoVolume})::Nothing


""" ClearNodes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::ClearShape()
@trydoc raw"""
    ClearShape(this::ByRef1{TGeoVolume})::Nothing
Clear the shape of this volume from the list held by the current manager.

""" ClearShape(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoVolume})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::CloneNodesAndConnect(TGeoVolume *)
@trydoc raw"""
    CloneNodesAndConnect(this::ByConstRef1{TGeoVolume}, newmother::ByPtr1{TGeoVolume})::Nothing
Clone the array of nodes.

""" CloneNodesAndConnect(this::ByConstRef1{TGeoVolume}, newmother::ByPtr1{TGeoVolume})

# Wrapper of TGeoVolume * TGeoVolume::CloneVolume()
@trydoc raw"""
    CloneVolume(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoVolume}
Clone this volume.
build a volume with same name, shape and medium
""" CloneVolume(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoVolume}, point::ByConstPtr2{Float64})::Bool


""" Contains(this::ByConstRef1{TGeoVolume}, point::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoVolume::CountNodes(Int_t, Int_t)
@trydoc raw"""
    CountNodes(this::ByRef1{TGeoVolume}, nlevels::Int32, option::Int32)::Int32
Count total number of subnodes starting from this volume, nlevels down.
- option = 0 (default) - count only once per volume
- option = 1 - count every time
- option = 2 - count volumes on visible branches
- option = 3 - return maximum level counted already with option = 0
""" CountNodes(this::ByRef1{TGeoVolume}, nlevels::Int32, option::Int32)

# Wrapper of void TGeoVolume::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoVolume}, nthreads::Int32)::Nothing


""" CreateThreadData(this::ByRef1{TGeoVolume}, nthreads::Int32)

# Wrapper of Int_t TGeoVolume::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoVolume}, px::Int32, py::Int32)::Int32
compute the closest distance of approach from point px,py to this volume

""" DistancetoPrimitive(this::ByRef1{TGeoVolume}, px::Int32, py::Int32)

# Wrapper of TGeoVolume * TGeoVolume::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Division a la G3.
The volume will be divided along IAXIS (see shape classes), in NDIV slices, from START with given STEP. The division volumes will have medium number NUMED. If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0, all range of IAXIS will be divided and the resulting number of divisions will be centered on IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV. Options (case insensitive):

- N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3)
- NX - divide range starting with START in NDIV cells (GSDVN2 in G3)
- S - divide all range with given STEP. NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3)
- SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3)
""" Divide(this::ByRef1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of void TGeoVolume::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
draw top volume according to option

""" Draw(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
draw only this volume

""" DrawOnly(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoVolume}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this volume.

""" ExecuteEvent(this::ByRef1{TGeoVolume}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TGeoVolume::Export(const char *, const char *, Option_t *)
@trydoc raw"""
    Export(this::ByRef1{TGeoVolume}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})::Int32
Export this volume to a file.
- Case 1: root file or root/xml file if filename theend with ".root". The key will be named name if filename theend with ".xml" a root/xml file is produced.
- Case 2: C++ script if filename theend with ".C"
- Case 3: gdml file if filename theend with ".gdml"

NOTE that to use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml
""" Export(this::ByRef1{TGeoVolume}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of Bool_t TGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume *)
@trydoc raw"""
    FindMatrixOfDaughterVolume(this::ByConstRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume})::Bool
Find a daughter node having VOL as volume and fill TGeoManager!fHMatrix with its global_ matrix.

""" FindMatrixOfDaughterVolume(this::ByConstRef1{TGeoVolume}, vol::ByPtr1{TGeoVolume})

# Wrapper of TGeoNode * TGeoVolume::FindNode(const char *)
@trydoc raw"""
    FindNode(this::ByConstRef1{TGeoVolume}, name::ByCopy{String})::CxxPtr1{TGeoNode}
search a daughter inside the list of nodes

""" FindNode(this::ByConstRef1{TGeoVolume}, name::ByCopy{String})

# Wrapper of void TGeoVolume::FindOverlaps()
@trydoc raw"""
    FindOverlaps(this::ByConstRef1{TGeoVolume})::Nothing
loop all nodes marked as overlaps and find overlapping brothers

""" FindOverlaps(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoVolume})::Int32
get the total size in bytes for this volume

""" GetByteCount(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetCurrentNodeIndex()
@trydoc raw"""
    GetCurrentNodeIndex(this::ByConstRef1{TGeoVolume})::Int32


""" GetCurrentNodeIndex(this::ByConstRef1{TGeoVolume})

# Wrapper of TObject * TGeoVolume::GetField()
@trydoc raw"""
    GetField(this::ByConstRef1{TGeoVolume})::CxxPtr1{TObject}


""" GetField(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoPatternFinder * TGeoVolume::GetFinder()
@trydoc raw"""
    GetFinder(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoPatternFinder}


""" GetFinder(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoExtension * TGeoVolume::GetFWExtension()
@trydoc raw"""
    GetFWExtension(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoExtension}


""" GetFWExtension(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoManager * TGeoVolume::GetGeoManager()
@trydoc raw"""
    GetGeoManager(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoManager}


""" GetGeoManager(this::ByConstRef1{TGeoVolume})

# Wrapper of const char * TGeoVolume::GetIconName()
@trydoc raw"""
    GetIconName(this::ByConstRef1{TGeoVolume})::ByCopy{String}
Returns mime type name of object.
Used by the [TBrowser](@ref) (via [TGMimeTypes](@ref) class). Override for class of which you would like to have different icons for objects of the same class.
""" GetIconName(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetIndex(const TGeoNode *)
@trydoc raw"""
    GetIndex(this::ByConstRef1{TGeoVolume}, node::ByConstPtr1{TGeoNode})::Int32
get index number for a given daughter

""" GetIndex(this::ByConstRef1{TGeoVolume}, node::ByConstPtr1{TGeoNode})

# Wrapper of TGeoMaterial * TGeoVolume::GetMaterial()
@trydoc raw"""
    GetMaterial(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoMaterial}


""" GetMaterial(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoMedium * TGeoVolume::GetMedium()
@trydoc raw"""
    GetMedium(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoMedium}


""" GetMedium(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetNdaughters()
@trydoc raw"""
    GetNdaughters(this::ByConstRef1{TGeoVolume})::Int32


""" GetNdaughters(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetNextNodeIndex()
@trydoc raw"""
    GetNextNodeIndex(this::ByConstRef1{TGeoVolume})::Int32


""" GetNextNodeIndex(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoNode * TGeoVolume::GetNode(const char *)
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoVolume}, name::ByCopy{String})::CxxPtr1{TGeoNode}
get the pointer to a daughter node

""" GetNode(this::ByConstRef1{TGeoVolume}, name::ByCopy{String})

# Wrapper of TGeoNode * TGeoVolume::GetNode(Int_t)
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoVolume}, i::Int32)::CxxPtr1{TGeoNode}


""" GetNode(this::ByConstRef1{TGeoVolume}, i::Int32)

# Wrapper of Int_t TGeoVolume::GetNodeIndex(const TGeoNode *, Int_t *, Int_t)
@trydoc raw"""
    GetNodeIndex(this::ByConstRef1{TGeoVolume}, node::ByConstPtr1{TGeoNode}, check_list::ByPtr2{Int32}, ncheck::Int32)::Int32
Get the index of a daughter within check_list by providing the node pointer.

""" GetNodeIndex(this::ByConstRef1{TGeoVolume}, node::ByConstPtr1{TGeoNode}, check_list::ByPtr2{Int32}, ncheck::Int32)

# Wrapper of TObjArray * TGeoVolume::GetNodes()
@trydoc raw"""
    GetNodes(this::ByRef1{TGeoVolume})::CxxPtr1{TObjArray}


""" GetNodes(this::ByRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetNtotal()
@trydoc raw"""
    GetNtotal(this::ByConstRef1{TGeoVolume})::Int32


""" GetNtotal(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetNumber()
@trydoc raw"""
    GetNumber(this::ByConstRef1{TGeoVolume})::Int32


""" GetNumber(this::ByConstRef1{TGeoVolume})

# Wrapper of char * TGeoVolume::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TGeoVolume}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Get volume info for the browser.

""" GetObjectInfo(this::ByConstRef1{TGeoVolume}, px::Int32, py::Int32)

# Wrapper of Bool_t TGeoVolume::GetOptimalVoxels()
@trydoc raw"""
    GetOptimalVoxels(this::ByConstRef1{TGeoVolume})::Bool
Returns true if cylindrical voxelization is optimal.

""" GetOptimalVoxels(this::ByConstRef1{TGeoVolume})

# Wrapper of Option_t * TGeoVolume::GetOption()
@trydoc raw"""
    GetOption(this::ByConstRef1{TGeoVolume})::ByCopy{String}


""" GetOption(this::ByConstRef1{TGeoVolume})

# Wrapper of const char * TGeoVolume::GetPointerName()
@trydoc raw"""
    GetPointerName(this::ByConstRef1{TGeoVolume})::ByCopy{String}
Provide a pointer name containing uid.

""" GetPointerName(this::ByConstRef1{TGeoVolume})

# Wrapper of Int_t TGeoVolume::GetRefCount()
@trydoc raw"""
    GetRefCount(this::ByConstRef1{TGeoVolume})::Int32


""" GetRefCount(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoShape * TGeoVolume::GetShape()
@trydoc raw"""
    GetShape(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoShape}


""" GetShape(this::ByConstRef1{TGeoVolume})

# Wrapper of Char_t TGeoVolume::GetTransparency()
@trydoc raw"""
    GetTransparency(this::ByConstRef1{TGeoVolume})::Int8


""" GetTransparency(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoExtension * TGeoVolume::GetUserExtension()
@trydoc raw"""
    GetUserExtension(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoExtension}


""" GetUserExtension(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoVoxelFinder * TGeoVolume::GetVoxels()
@trydoc raw"""
    GetVoxels(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoVoxelFinder}
Getter for optimization structure.

""" GetVoxels(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::Grab()
@trydoc raw"""
    Grab(this::ByRef1{TGeoVolume})::Nothing


""" Grab(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::GrabFocus()
@trydoc raw"""
    GrabFocus(this::ByRef1{TGeoVolume})::Nothing
Move perspective view focus to this volume.

""" GrabFocus(this::ByRef1{TGeoVolume})

# Wrapper of TGeoExtension * TGeoVolume::GrabFWExtension()
@trydoc raw"""
    GrabFWExtension(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoExtension}
Get a copy of the framework extension pointer.
The user must call [Release()](@ref) on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new())
""" GrabFWExtension(this::ByConstRef1{TGeoVolume})

# Wrapper of TGeoExtension * TGeoVolume::GrabUserExtension()
@trydoc raw"""
    GrabUserExtension(this::ByConstRef1{TGeoVolume})::CxxPtr1{TGeoExtension}
Get a copy of the user extension pointer.
The user must call [Release()](@ref) on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new())
""" GrabUserExtension(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::Gsord(Int_t)
@trydoc raw"""
    Gsord(this::ByRef1{TGeoVolume}, ::Int32)::Nothing


""" Gsord(this::ByRef1{TGeoVolume}, ::Int32)

# Wrapper of void TGeoVolume::InspectMaterial()
@trydoc raw"""
    InspectMaterial(this::ByConstRef1{TGeoVolume})::Nothing
Inspect the material for this volume.

""" InspectMaterial(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoVolume})::Nothing


""" InspectShape(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::InvisibleAll(Bool_t)
@trydoc raw"""
    InvisibleAll(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Make volume and each of it daughters (in)visible.

""" InvisibleAll(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of Bool_t TGeoVolume::IsActive()
@trydoc raw"""
    IsActive(this::ByConstRef1{TGeoVolume})::Bool


""" IsActive(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsActiveDaughters()
@trydoc raw"""
    IsActiveDaughters(this::ByConstRef1{TGeoVolume})::Bool


""" IsActiveDaughters(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsAdded()
@trydoc raw"""
    IsAdded(this::ByConstRef1{TGeoVolume})::Bool


""" IsAdded(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsAllInvisible()
@trydoc raw"""
    IsAllInvisible(this::ByConstRef1{TGeoVolume})::Bool
Return TRUE if volume and all daughters are invisible.

""" IsAllInvisible(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsAssembly()
@trydoc raw"""
    IsAssembly(this::ByConstRef1{TGeoVolume})::Bool
Returns true if the volume is an assembly or a scaled assembly.

""" IsAssembly(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsCylVoxels()
@trydoc raw"""
    IsCylVoxels(this::ByConstRef1{TGeoVolume})::Bool


""" IsCylVoxels(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TGeoVolume})::Bool
Return TRUE if volume contains nodes.

""" IsFolder(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsOverlappingCandidate()
@trydoc raw"""
    IsOverlappingCandidate(this::ByConstRef1{TGeoVolume})::Bool


""" IsOverlappingCandidate(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsRaytracing()
@trydoc raw"""
    IsRaytracing(this::ByConstRef1{TGeoVolume})::Bool
Check if the painter is currently ray-tracing the content of this volume.

""" IsRaytracing(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsReplicated()
@trydoc raw"""
    IsReplicated(this::ByConstRef1{TGeoVolume})::Bool


""" IsReplicated(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsRunTime()
@trydoc raw"""
    IsRunTime(this::ByConstRef1{TGeoVolume})::Bool


""" IsRunTime(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsSelected()
@trydoc raw"""
    IsSelected(this::ByConstRef1{TGeoVolume})::Bool


""" IsSelected(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsStyleDefault()
@trydoc raw"""
    IsStyleDefault(this::ByConstRef1{TGeoVolume})::Bool
check if the visibility and attributes are the default ones

""" IsStyleDefault(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsTopVolume()
@trydoc raw"""
    IsTopVolume(this::ByConstRef1{TGeoVolume})::Bool
True if this is the top volume of the geometry.

""" IsTopVolume(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsValid()
@trydoc raw"""
    IsValid(this::ByConstRef1{TGeoVolume})::Bool


""" IsValid(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsVisContainers()
@trydoc raw"""
    IsVisContainers(this::ByConstRef1{TGeoVolume})::Bool


""" IsVisContainers(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsVisible()
@trydoc raw"""
    IsVisible(this::ByConstRef1{TGeoVolume})::Bool


""" IsVisible(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsVisibleDaughters()
@trydoc raw"""
    IsVisibleDaughters(this::ByConstRef1{TGeoVolume})::Bool


""" IsVisibleDaughters(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsVisLeaves()
@trydoc raw"""
    IsVisLeaves(this::ByConstRef1{TGeoVolume})::Bool


""" IsVisLeaves(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsVisOnly()
@trydoc raw"""
    IsVisOnly(this::ByConstRef1{TGeoVolume})::Bool


""" IsVisOnly(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsVolumeMulti()
@trydoc raw"""
    IsVolumeMulti(this::ByConstRef1{TGeoVolume})::Bool


""" IsVolumeMulti(this::ByConstRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::IsXYZVoxels()
@trydoc raw"""
    IsXYZVoxels(this::ByConstRef1{TGeoVolume})::Bool


""" IsXYZVoxels(this::ByConstRef1{TGeoVolume})

# Wrapper of TH2F * TGeoVolume::LegoPlot(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    LegoPlot(this::ByRef1{TGeoVolume}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})::CxxPtr1{TH2F}
Generate a lego plot fot the top volume, according to option.

""" LegoPlot(this::ByRef1{TGeoVolume}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})

# Wrapper of void TGeoVolume::MakeCopyNodes(const TGeoVolume *)
@trydoc raw"""
    MakeCopyNodes(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})::Nothing
make a new list of nodes and copy all nodes of other volume inside

""" MakeCopyNodes(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})

# Wrapper of TGeoVolume * TGeoVolume::MakeCopyVolume(TGeoShape *)
@trydoc raw"""
    MakeCopyVolume(this::ByRef1{TGeoVolume}, newshape::ByPtr1{TGeoShape})::CxxPtr1{TGeoVolume}
make a copy of this volume build a volume with same name, shape and medium

""" MakeCopyVolume(this::ByRef1{TGeoVolume}, newshape::ByPtr1{TGeoShape})

# Wrapper of TGeoVolume * TGeoVolume::MakeReflectedVolume(const char *)
@trydoc raw"""
    MakeReflectedVolume(this::ByConstRef1{TGeoVolume}, newname::ByCopy{String})::CxxPtr1{TGeoVolume}
Make a copy of this volume which is reflected with respect to XY plane.

""" MakeReflectedVolume(this::ByConstRef1{TGeoVolume}, newname::ByCopy{String})

# Wrapper of Bool_t TGeoVolume::OptimizeVoxels()
@trydoc raw"""
    OptimizeVoxels(this::ByRef1{TGeoVolume})::Bool
Perform an extensive sampling to find which type of voxelization is most efficient.

""" OptimizeVoxels(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
paint volume

""" Paint(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoVolume}, option::ByCopy{String})::Nothing
Print volume info.

""" Print(this::ByConstRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::PrintNodes()
@trydoc raw"""
    PrintNodes(this::ByConstRef1{TGeoVolume})::Nothing
print nodes

""" PrintNodes(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::PrintVoxels()
@trydoc raw"""
    PrintVoxels(this::ByConstRef1{TGeoVolume})::Nothing
Print the voxels for this volume.

""" PrintVoxels(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::RandomPoints(Int_t, Option_t *)
@trydoc raw"""
    RandomPoints(this::ByRef1{TGeoVolume}, npoints::Int32, option::ByCopy{String})::Nothing
Draw random points in the bounding box of this volume.

""" RandomPoints(this::ByRef1{TGeoVolume}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TGeoVolume::RandomRays(Int_t, Double_t, Double_t, Double_t, const char *, Bool_t)
@trydoc raw"""
    RandomRays(this::ByRef1{TGeoVolume}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)::Nothing
Random raytracing method.

""" RandomRays(this::ByRef1{TGeoVolume}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)

# Wrapper of void TGeoVolume::Raytrace(Bool_t)
@trydoc raw"""
    Raytrace(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Draw this volume with current settings and perform raytracing in the pad.

""" Raytrace(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::RegisterYourself(Option_t *)
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
Register the volume and all materials/media/matrices/shapes to the manager.

""" RegisterYourself(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::Release()
@trydoc raw"""
    Release(this::ByRef1{TGeoVolume})::Nothing


""" Release(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::RemoveNode(TGeoNode *)
@trydoc raw"""
    RemoveNode(this::ByRef1{TGeoVolume}, node::ByPtr1{TGeoNode})::Nothing
Remove an existing daughter.

""" RemoveNode(this::ByRef1{TGeoVolume}, node::ByPtr1{TGeoNode})

# Wrapper of TGeoNode * TGeoVolume::ReplaceNode(TGeoNode *, TGeoShape *, TGeoMatrix *, TGeoMedium *)
@trydoc raw"""
    ReplaceNode(this::ByRef1{TGeoVolume}, nodeorig::ByPtr1{TGeoNode}, newshape::ByPtr1{TGeoShape}, newpos::ByPtr1{TGeoMatrix}, newmed::ByPtr1{TGeoMedium})::CxxPtr1{TGeoNode}
Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium.
Not allowed for positioned assemblies. For division cells, the new shape/matrix are ignored.
""" ReplaceNode(this::ByRef1{TGeoVolume}, nodeorig::ByPtr1{TGeoNode}, newshape::ByPtr1{TGeoShape}, newpos::ByPtr1{TGeoMatrix}, newmed::ByPtr1{TGeoMedium})

# Wrapper of void TGeoVolume::ReplayCreation(const TGeoVolume *)
@trydoc raw"""
    ReplayCreation(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})::Nothing
Recreate the content of the other volume without pointer copying.
Voxels are ignored and supposed to be created in a later step via Voxelize.
""" ReplayCreation(this::ByRef1{TGeoVolume}, other::ByConstPtr1{TGeoVolume})

# Wrapper of void TGeoVolume::ResetTransparency(Char_t)
@trydoc raw"""
    ResetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)::Nothing


""" ResetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)

# Wrapper of void TGeoVolume::SaveAs(const char *, Option_t *)
@trydoc raw"""
    SaveAs(this::ByConstRef1{TGeoVolume}, filename::ByCopy{String}, option::ByCopy{String})::Nothing
Save geometry having this as top volume as a C++ macro.

""" SaveAs(this::ByConstRef1{TGeoVolume}, filename::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TGeoVolume::SelectVolume(Bool_t)
@trydoc raw"""
    SelectVolume(this::ByRef1{TGeoVolume}, clear::Bool)::Nothing
Select this volume as matching an arbitrary criteria.
The volume is added to a static list and the flag [TGeoVolume!kVolumeSelected](@ref) is set. All flags need to be reset at the theend by calling the method with CLEAR=true. This will also clear the list.
""" SelectVolume(this::ByRef1{TGeoVolume}, clear::Bool)

# Wrapper of void TGeoVolume::SetActiveDaughters(Bool_t)
@trydoc raw"""
    SetActiveDaughters(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetActiveDaughters(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetActivity(Bool_t)
@trydoc raw"""
    SetActivity(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetActivity(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetAdded()
@trydoc raw"""
    SetAdded(this::ByRef1{TGeoVolume})::Nothing


""" SetAdded(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetAsTopVolume()
@trydoc raw"""
    SetAsTopVolume(this::ByRef1{TGeoVolume})::Nothing
Set this volume as the TOP one (the whole geometry starts from here)

""" SetAsTopVolume(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetAttVisibility(Bool_t)
@trydoc raw"""
    SetAttVisibility(this::ByRef1{TGeoVolume}, vis::Bool)::Nothing


""" SetAttVisibility(this::ByRef1{TGeoVolume}, vis::Bool)

# Wrapper of void TGeoVolume::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoVolume}, x::Float64, y::Float64, z::Float64)::Nothing
Set the current tracking point.

""" SetCurrentPoint(this::ByRef1{TGeoVolume}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoVolume::SetCylVoxels(Bool_t)
@trydoc raw"""
    SetCylVoxels(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetCylVoxels(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetField(TObject *)
@trydoc raw"""
    SetField(this::ByRef1{TGeoVolume}, field::ByPtr1{TObject})::Nothing


""" SetField(this::ByRef1{TGeoVolume}, field::ByPtr1{TObject})

# Wrapper of void TGeoVolume::SetFinder(TGeoPatternFinder *)
@trydoc raw"""
    SetFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoPatternFinder})::Nothing


""" SetFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoPatternFinder})

# Wrapper of void TGeoVolume::SetFWExtension(TGeoExtension *)
@trydoc raw"""
    SetFWExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})::Nothing
Connect framework defined extension to the volume.
The volume "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for the use by TGeo and the users should NOT connect extensions using this method
""" SetFWExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoVolume::SetInvisible()
@trydoc raw"""
    SetInvisible(this::ByRef1{TGeoVolume})::Nothing


""" SetInvisible(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TGeoVolume}, lcolor::Int16)::Nothing
Set the line color.

""" SetLineColor(this::ByRef1{TGeoVolume}, lcolor::Int16)

# Wrapper of void TGeoVolume::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TGeoVolume}, lstyle::Int16)::Nothing
Set the line style.

""" SetLineStyle(this::ByRef1{TGeoVolume}, lstyle::Int16)

# Wrapper of void TGeoVolume::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TGeoVolume}, lwidth::Int16)::Nothing
Set the line width.

""" SetLineWidth(this::ByRef1{TGeoVolume}, lwidth::Int16)

# Wrapper of void TGeoVolume::SetMedium(TGeoMedium *)
@trydoc raw"""
    SetMedium(this::ByRef1{TGeoVolume}, medium::ByPtr1{TGeoMedium})::Nothing


""" SetMedium(this::ByRef1{TGeoVolume}, medium::ByPtr1{TGeoMedium})

# Wrapper of void TGeoVolume::SetNodes(TObjArray *)
@trydoc raw"""
    SetNodes(this::ByRef1{TGeoVolume}, nodes::ByPtr1{TObjArray})::Nothing


""" SetNodes(this::ByRef1{TGeoVolume}, nodes::ByPtr1{TObjArray})

# Wrapper of void TGeoVolume::SetNtotal(Int_t)
@trydoc raw"""
    SetNtotal(this::ByRef1{TGeoVolume}, ntotal::Int32)::Nothing


""" SetNtotal(this::ByRef1{TGeoVolume}, ntotal::Int32)

# Wrapper of void TGeoVolume::SetNumber(Int_t)
@trydoc raw"""
    SetNumber(this::ByRef1{TGeoVolume}, number::Int32)::Nothing


""" SetNumber(this::ByRef1{TGeoVolume}, number::Int32)

# Wrapper of void TGeoVolume::SetOption(const char *)
@trydoc raw"""
    SetOption(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
Set the current options (none implemented)

""" SetOption(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TGeoVolume::SetOverlappingCandidate(Bool_t)
@trydoc raw"""
    SetOverlappingCandidate(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing


""" SetOverlappingCandidate(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetReplicated()
@trydoc raw"""
    SetReplicated(this::ByRef1{TGeoVolume})::Nothing


""" SetReplicated(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::SetShape(const TGeoShape *)
@trydoc raw"""
    SetShape(this::ByRef1{TGeoVolume}, shape::ByConstPtr1{TGeoShape})::Nothing
set the shape associated with this volume

""" SetShape(this::ByRef1{TGeoVolume}, shape::ByConstPtr1{TGeoShape})

# Wrapper of void TGeoVolume::SetTransparency(Char_t)
@trydoc raw"""
    SetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)::Nothing


""" SetTransparency(this::ByRef1{TGeoVolume}, transparency::Int8)

# Wrapper of void TGeoVolume::SetUserExtension(TGeoExtension *)
@trydoc raw"""
    SetUserExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})::Nothing
Connect user-defined extension to the volume.
The volume "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for user extensions and is guaranteed not to be used by TGeo
""" SetUserExtension(this::ByRef1{TGeoVolume}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoVolume::SetVisContainers(Bool_t)
@trydoc raw"""
    SetVisContainers(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Set visibility for containers.

""" SetVisContainers(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoVolume}, vis::Bool)::Nothing
set visibility of this volume

""" SetVisibility(this::ByRef1{TGeoVolume}, vis::Bool)

# Wrapper of void TGeoVolume::SetVisLeaves(Bool_t)
@trydoc raw"""
    SetVisLeaves(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Set visibility for leaves.

""" SetVisLeaves(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetVisOnly(Bool_t)
@trydoc raw"""
    SetVisOnly(this::ByRef1{TGeoVolume}, flag::Bool)::Nothing
Set visibility for leaves.

""" SetVisOnly(this::ByRef1{TGeoVolume}, flag::Bool)

# Wrapper of void TGeoVolume::SetVoxelFinder(TGeoVoxelFinder *)
@trydoc raw"""
    SetVoxelFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoVoxelFinder})::Nothing


""" SetVoxelFinder(this::ByRef1{TGeoVolume}, finder::ByPtr1{TGeoVoxelFinder})

# Wrapper of void TGeoVolume::SortNodes()
@trydoc raw"""
    SortNodes(this::ByRef1{TGeoVolume})::Nothing
sort nodes by decreasing volume of the bounding box.
ONLY nodes comes first, then overlapping nodes and finally division nodes.
""" SortNodes(this::ByRef1{TGeoVolume})

# Wrapper of void TGeoVolume::UnmarkSaved()
@trydoc raw"""
    UnmarkSaved(this::ByRef1{TGeoVolume})::Nothing
Reset SavePrimitive bits.

""" UnmarkSaved(this::ByRef1{TGeoVolume})

# Wrapper of Bool_t TGeoVolume::Valid()
@trydoc raw"""
    Valid(this::ByConstRef1{TGeoVolume})::Bool
Check if the shape of this volume is valid.

""" Valid(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::VisibleDaughters(Bool_t)
@trydoc raw"""
    VisibleDaughters(this::ByRef1{TGeoVolume}, vis::Bool)::Nothing
set visibility for daughters

""" VisibleDaughters(this::ByRef1{TGeoVolume}, vis::Bool)

# Wrapper of void TGeoVolume::Voxelize(Option_t *)
@trydoc raw"""
    Voxelize(this::ByRef1{TGeoVolume}, option::ByCopy{String})::Nothing
build the voxels for this volume

""" Voxelize(this::ByRef1{TGeoVolume}, option::ByCopy{String})

# Wrapper of Double_t TGeoVolume::Weight(Double_t, Option_t *)
@trydoc raw"""
    Weight(this::ByRef1{TGeoVolume}, precision::Float64, option::ByCopy{String})::Float64
Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.
Option can contain : v - verbose, a - analytical (default)
""" Weight(this::ByRef1{TGeoVolume}, precision::Float64, option::ByCopy{String})

# Wrapper of Double_t TGeoVolume::WeightA()
@trydoc raw"""
    WeightA(this::ByConstRef1{TGeoVolume})::Float64
Analytical computation of the weight.

""" WeightA(this::ByConstRef1{TGeoVolume})

# Wrapper of void TGeoVolume::CreateDummyMedium()
@trydoc raw"""
    TGeoVolume!CreateDummyMedium(this::ByRef1{TGeoVolume})::Nothing
Create a dummy medium.

""" TGeoVolume!CreateDummyMedium(this::ByRef1{TGeoVolume})

# Wrapper of TGeoMedium * TGeoVolume::DummyMedium()
@trydoc raw"""
    TGeoVolume!DummyMedium(this::ByRef1{TGeoVolume})::CxxPtr1{TGeoMedium}


""" TGeoVolume!DummyMedium(this::ByRef1{TGeoVolume})

# Wrapper of TGeoVolume * TGeoVolume::Import(const char *, const char *, Option_t *)
@trydoc raw"""
    TGeoVolume!Import(this::ByRef1{TGeoVolume}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Import a volume from a file.

""" TGeoVolume!Import(this::ByRef1{TGeoVolume}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of Double_t TGeoBBox::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoBBox})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoBBox})

# Wrapper of void TGeoBBox::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoBBox})::Nothing
Compute bounding box - nothing to do in this case.

""" ComputeBBox(this::ByRef1{TGeoBBox})

# Wrapper of void TGeoBBox::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Computes normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoBBox::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoBBox::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64})::Bool
Test if point is inside this shape.

""" Contains(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoBBox::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Bool_t TGeoBBox::CouldBeCrossed(const Double_t *, const Double_t *)
@trydoc raw"""
    CouldBeCrossed(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})::Bool
Decides fast if the bounding box could be crossed by a vector.

""" CouldBeCrossed(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoBBox::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoBBox}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each corner.

""" DistancetoPrimitive(this::ByRef1{TGeoBBox}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoBBox::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the box.
Boundary safe algorithm.
""" DistFromInside(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoBBox::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoBBox::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the box.
Boundary safe algorithm.
""" DistFromOutside(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoBBox::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoBBox::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoBBox}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this box shape belonging to volume "voldiv" into ndiv equal volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume. In case a wrong division axis is supplied, returns pointer to volume to be divided.
""" Divide(this::ByRef1{TGeoBBox}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of const char * TGeoBBox::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoBBox}, iaxis::Int32)::ByCopy{String}
Returns name of axis IAXIS.

""" GetAxisName(this::ByConstRef1{TGeoBBox}, iaxis::Int32)

# Wrapper of Double_t TGeoBBox::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoBBox}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoBBox}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoBBox::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoBBox}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoBBox}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoBBox::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoBBox})::Int32


""" GetByteCount(this::ByConstRef1{TGeoBBox})

# Wrapper of Double_t TGeoBBox::GetDX()
@trydoc raw"""
    GetDX(this::ByConstRef1{TGeoBBox})::Float64


""" GetDX(this::ByConstRef1{TGeoBBox})

# Wrapper of Double_t TGeoBBox::GetDY()
@trydoc raw"""
    GetDY(this::ByConstRef1{TGeoBBox})::Float64


""" GetDY(this::ByConstRef1{TGeoBBox})

# Wrapper of Double_t TGeoBBox::GetDZ()
@trydoc raw"""
    GetDZ(this::ByConstRef1{TGeoBBox})::Float64


""" GetDZ(this::ByConstRef1{TGeoBBox})

# Wrapper of Double_t TGeoBBox::GetFacetArea(Int_t)
@trydoc raw"""
    GetFacetArea(this::ByConstRef1{TGeoBBox}, index::Int32)::Float64
Get area in internal units of the facet with a given index.
Possible index values:

- 0 - all facets together
- 1 to 6 - facet index from bottom to top Z
""" GetFacetArea(this::ByConstRef1{TGeoBBox}, index::Int32)

# Wrapper of Int_t TGeoBBox::GetFittingBox(const TGeoBBox *, TGeoMatrix *, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetFittingBox(this::ByConstRef1{TGeoBBox}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})::Int32
Fills real parameters of a positioned box inside this one. Returns 0 if successful.

""" GetFittingBox(this::ByConstRef1{TGeoBBox}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})

# Wrapper of TGeoShape * TGeoBBox::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoBBox}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoBBox}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoBBox::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoBBox}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoBBox}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoBBox::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoBBox})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoBBox})

# Wrapper of const Double_t * TGeoBBox::GetOrigin()
@trydoc raw"""
    GetOrigin(this::ByConstRef1{TGeoBBox})::ConstCxxPtr2{Float64}


""" GetOrigin(this::ByConstRef1{TGeoBBox})

# Wrapper of Bool_t TGeoBBox::GetPointsOnFacet(Int_t, Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnFacet(this::ByConstRef1{TGeoBBox}, index::Int32, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the surface of indexed facet.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation succeeded. Possible index values:

- 0 - all facets together
- 1 to 6 - facet index from bottom to top Z
""" GetPointsOnFacet(this::ByConstRef1{TGeoBBox}, index::Int32, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Bool_t TGeoBBox::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoBBox}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoBBox}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoBBox::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoBBox})::Nothing
Prints shape parameters.

""" InspectShape(this::ByConstRef1{TGeoBBox})

# Wrapper of Bool_t TGeoBBox::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoBBox})::Bool


""" IsCylType(this::ByConstRef1{TGeoBBox})

# Wrapper of Bool_t TGeoBBox::IsNullBox()
@trydoc raw"""
    IsNullBox(this::ByConstRef1{TGeoBBox})::Bool


""" IsNullBox(this::ByConstRef1{TGeoBBox})

# Wrapper of Bool_t TGeoBBox::IsValidBox()
@trydoc raw"""
    IsValidBox(this::ByConstRef1{TGeoBBox})::Bool


""" IsValidBox(this::ByConstRef1{TGeoBBox})

# Wrapper of Double_t TGeoBBox::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Computes the closest distance from given point to this shape.

""" Safety(this::ByConstRef1{TGeoBBox}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoBBox::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoBBox}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoBBox::SetBoxDimensions(Double_t, Double_t, Double_t, Double_t *)
@trydoc raw"""
    SetBoxDimensions(this::ByRef1{TGeoBBox}, dx::Float64, dy::Float64, dz::Float64, origin::ByPtr2{Float64})::Nothing
Set parameters of the box.

""" SetBoxDimensions(this::ByRef1{TGeoBBox}, dx::Float64, dy::Float64, dz::Float64, origin::ByPtr2{Float64})

# Wrapper of void TGeoBBox::SetBoxPoints(Double_t *)
@trydoc raw"""
    SetBoxPoints(this::ByConstRef1{TGeoBBox}, points::ByPtr2{Float64})::Nothing
Fill box vertices to an array.

""" SetBoxPoints(this::ByConstRef1{TGeoBBox}, points::ByPtr2{Float64})

# Wrapper of void TGeoBBox::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoBBox}, param::ByPtr2{Float64})::Nothing
Set dimensions based on the array of parameters param[0] - half-length in x param[1] - half-length in y param[2] - half-length in z.

""" SetDimensions(this::ByRef1{TGeoBBox}, param::ByPtr2{Float64})

# Wrapper of void TGeoBBox::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoBBox}, points::ByPtr2{Float64})::Nothing
Fill box points.

""" SetPoints(this::ByConstRef1{TGeoBBox}, points::ByPtr2{Float64})

# Wrapper of void TGeoBBox::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoBBox}, points::ByPtr2{Float32})::Nothing
Fill box points.

""" SetPoints(this::ByConstRef1{TGeoBBox}, points::ByPtr2{Float32})

# Wrapper of void TGeoBBox::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoBBox})::Nothing


""" Sizeof3D(this::ByConstRef1{TGeoBBox})

# Wrapper of Bool_t TGeoBBox::Contains(const Double_t *, Double_t, Double_t, Double_t, const Double_t *)
@trydoc raw"""
    TGeoBBox!Contains(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dx::Float64, dy::Float64, dz::Float64, origin::ByConstPtr2{Float64})::Bool
Static method to check if point[3] is located inside a box of having dx, dy, dz as half-lengths.

""" TGeoBBox!Contains(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dx::Float64, dy::Float64, dz::Float64, origin::ByConstPtr2{Float64})

# Wrapper of Double_t TGeoBBox::DistFromInside(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    TGeoBBox!DistFromInside(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dx::Float64, dy::Float64, dz::Float64, origin::ByConstPtr2{Float64}, stepmax::Float64)::Float64
Compute distance from inside point to surface of the box.
Boundary safe algorithm.
""" TGeoBBox!DistFromInside(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dx::Float64, dy::Float64, dz::Float64, origin::ByConstPtr2{Float64}, stepmax::Float64)

# Wrapper of Double_t TGeoBBox::DistFromOutside(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, const Double_t *, Double_t)
@trydoc raw"""
    TGeoBBox!DistFromOutside(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dx::Float64, dy::Float64, dz::Float64, origin::ByConstPtr2{Float64}, stepmax::Float64)::Float64
Compute distance from outside point to surface of the box.
Boundary safe algorithm.
""" TGeoBBox!DistFromOutside(this::ByRef1{TGeoBBox}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dx::Float64, dy::Float64, dz::Float64, origin::ByConstPtr2{Float64}, stepmax::Float64)

# Wrapper of Double_t TGeoArb8::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoArb8})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoArb8})

# Wrapper of void TGeoArb8::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoArb8})::Nothing
Computes bounding box for an Arb8 shape.

""" ComputeBBox(this::ByRef1{TGeoArb8})

# Wrapper of void TGeoArb8::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoArb8::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoArb8::ComputeTwist()
@trydoc raw"""
    ComputeTwist(this::ByRef1{TGeoArb8})::Nothing
Computes tangents of twist angles (angles between projections on XY plane of corresponding -dz +dz edges).
Computes also if the vertices are defined clockwise or anti-clockwise.
""" ComputeTwist(this::ByRef1{TGeoArb8})

# Wrapper of Bool_t TGeoArb8::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64})::Bool
Test if point is inside this shape.

""" Contains(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoArb8::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Double_t TGeoArb8::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the shape.

""" DistFromInside(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoArb8::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoArb8::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Computes distance from outside point to surface of the shape.

""" DistFromOutside(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoArb8::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoArb8::DistToPlane(const Double_t *, const Double_t *, Int_t, Bool_t)
@trydoc raw"""
    DistToPlane(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, ipl::Int32, in::Bool)::Float64
Computes distance to plane ipl :
- ipl=0 : points 0,4,1,5
- ipl=1 : points 1,5,2,6
- ipl=2 : points 2,6,3,7
- ipl=3 : points 3,7,0,4
""" DistToPlane(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, ipl::Int32, in::Bool)

# Wrapper of TGeoVolume * TGeoArb8::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoArb8}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this shape along one axis.

""" Divide(this::ByRef1{TGeoArb8}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoArb8::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoArb8}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get shape range on a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoArb8}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoArb8::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoArb8}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoArb8}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoArb8::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoArb8})::Int32


""" GetByteCount(this::ByConstRef1{TGeoArb8})

# Wrapper of Double_t TGeoArb8::GetClosestEdge(const Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    GetClosestEdge(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, vert::ByPtr2{Float64}, isegment::ByRef2{Int32})::Float64
Get index of the edge of the quadrilater represented by vert closest to point.
If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1.
""" GetClosestEdge(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, vert::ByPtr2{Float64}, isegment::ByRef2{Int32})

# Wrapper of Double_t TGeoArb8::GetDz()
@trydoc raw"""
    GetDz(this::ByConstRef1{TGeoArb8})::Float64


""" GetDz(this::ByConstRef1{TGeoArb8})

# Wrapper of Int_t TGeoArb8::GetFittingBox(const TGeoBBox *, TGeoMatrix *, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetFittingBox(this::ByConstRef1{TGeoArb8}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})::Int32
Fills real parameters of a positioned box inside this arb8. Returns 0 if successful.

""" GetFittingBox(this::ByConstRef1{TGeoArb8}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})

# Wrapper of TGeoShape * TGeoArb8::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoArb8}, ::ByPtr1{TGeoShape}, ::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}


""" GetMakeRuntimeShape(this::ByConstRef1{TGeoArb8}, ::ByPtr1{TGeoShape}, ::ByPtr1{TGeoMatrix})

# Wrapper of Bool_t TGeoArb8::GetPointsOnFacet(Int_t, Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnFacet(this::ByConstRef1{TGeoArb8}, ::Int32, ::Int32, ::ByPtr2{Float64})::Bool
Fills array with n random points located on the surface of indexed facet.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation succeeded. Possible index values:

- 0 - all facets together
- 1 to 6 - facet index from bottom to top Z
""" GetPointsOnFacet(this::ByConstRef1{TGeoArb8}, ::Int32, ::Int32, ::ByPtr2{Float64})

# Wrapper of Double_t TGeoArb8::GetTwist(Int_t)
@trydoc raw"""
    GetTwist(this::ByConstRef1{TGeoArb8}, iseg::Int32)::Float64
Get twist for segment I in range [0,3].

""" GetTwist(this::ByConstRef1{TGeoArb8}, iseg::Int32)

# Wrapper of Double_t * TGeoArb8::GetVertices()
@trydoc raw"""
    GetVertices(this::ByRef1{TGeoArb8})::CxxPtr2{Float64}


""" GetVertices(this::ByRef1{TGeoArb8})

# Wrapper of void TGeoArb8::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoArb8})::Nothing
Prints shape parameters.

""" InspectShape(this::ByConstRef1{TGeoArb8})

# Wrapper of Bool_t TGeoArb8::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoArb8})::Bool


""" IsCylType(this::ByConstRef1{TGeoArb8})

# Wrapper of Bool_t TGeoArb8::IsTwisted()
@trydoc raw"""
    IsTwisted(this::ByConstRef1{TGeoArb8})::Bool


""" IsTwisted(this::ByConstRef1{TGeoArb8})

# Wrapper of Double_t TGeoArb8::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Computes the closest distance from given point to this shape.

""" Safety(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoArb8::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoArb8}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Double_t TGeoArb8::SafetyToFace(const Double_t *, Int_t, Bool_t)
@trydoc raw"""
    SafetyToFace(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, iseg::Int32, in::Bool)::Float64
Estimate safety to lateral plane defined by segment iseg in range [0,3] Might be negative: plane seen only from inside.

""" SafetyToFace(this::ByConstRef1{TGeoArb8}, point::ByConstPtr2{Float64}, iseg::Int32, in::Bool)

# Wrapper of void TGeoArb8::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoArb8}, param::ByPtr2{Float64})::Nothing
Set all arb8 params in one step.
param[0] = dz param[1] = x0 param[2] = y0 ...
""" SetDimensions(this::ByRef1{TGeoArb8}, param::ByPtr2{Float64})

# Wrapper of void TGeoArb8::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoArb8}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoArb8}, dz::Float64)

# Wrapper of void TGeoArb8::SetPlaneVertices(Double_t, Double_t *)
@trydoc raw"""
    SetPlaneVertices(this::ByConstRef1{TGeoArb8}, zpl::Float64, vertices::ByPtr2{Float64})::Nothing
Computes intersection points between plane at zpl and non-horizontal edges.

""" SetPlaneVertices(this::ByConstRef1{TGeoArb8}, zpl::Float64, vertices::ByPtr2{Float64})

# Wrapper of void TGeoArb8::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoArb8}, points::ByPtr2{Float64})::Nothing
Creates arb8 mesh points.

""" SetPoints(this::ByConstRef1{TGeoArb8}, points::ByPtr2{Float64})

# Wrapper of void TGeoArb8::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoArb8}, points::ByPtr2{Float32})::Nothing
Creates arb8 mesh points.

""" SetPoints(this::ByConstRef1{TGeoArb8}, points::ByPtr2{Float32})

# Wrapper of void TGeoArb8::SetVertex(Int_t, Double_t, Double_t)
@trydoc raw"""
    SetVertex(this::ByRef1{TGeoArb8}, vnum::Int32, x::Float64, y::Float64)::Nothing
Set values for a given vertex.

""" SetVertex(this::ByRef1{TGeoArb8}, vnum::Int32, x::Float64, y::Float64)

# Wrapper of void TGeoArb8::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoArb8})::Nothing
Fill size of this 3-D object.

""" Sizeof3D(this::ByConstRef1{TGeoArb8})

# Wrapper of void TGeoArb8::GetPlaneNormal(Double_t *, Double_t *, Double_t *, Double_t *)
@trydoc raw"""
    TGeoArb8!GetPlaneNormal(this::ByRef1{TGeoArb8}, p1::ByPtr2{Float64}, p2::ByPtr2{Float64}, p3::ByPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Computes normal to plane defined by P1, P2 and P3.

""" TGeoArb8!GetPlaneNormal(this::ByRef1{TGeoArb8}, p1::ByPtr2{Float64}, p2::ByPtr2{Float64}, p3::ByPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Bool_t TGeoArb8::InsidePolygon(Double_t, Double_t, Double_t *)
@trydoc raw"""
    TGeoArb8!InsidePolygon(this::ByRef1{TGeoArb8}, x::Float64, y::Float64, pts::ByPtr2{Float64})::Bool
Finds if a point in XY plane is inside the polygon defines by PTS.

""" TGeoArb8!InsidePolygon(this::ByRef1{TGeoArb8}, x::Float64, y::Float64, pts::ByPtr2{Float64})

# Wrapper of Bool_t TGeoArb8::IsSamePoint(const Double_t *, const Double_t *)
@trydoc raw"""
    TGeoArb8!IsSamePoint(this::ByRef1{TGeoArb8}, p1::ByConstPtr2{Float64}, p2::ByConstPtr2{Float64})::Bool


""" TGeoArb8!IsSamePoint(this::ByRef1{TGeoArb8}, p1::ByConstPtr2{Float64}, p2::ByConstPtr2{Float64})

# Wrapper of Double_t TGeoTrap::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoTrap}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the trapezoid.

""" DistFromInside(this::ByConstRef1{TGeoTrap}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTrap::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoTrap}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoTrap}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoTrap::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoTrap}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the trapezoid.

""" DistFromOutside(this::ByConstRef1{TGeoTrap}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTrap::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoTrap}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoTrap}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoTrap::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTrap}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this trapezoid shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Only Z divisions are supported. For Z divisions just return the pointer to the volume to be divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTrap}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoTrap::GetAlpha1()
@trydoc raw"""
    GetAlpha1(this::ByConstRef1{TGeoTrap})::Float64


""" GetAlpha1(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetAlpha2()
@trydoc raw"""
    GetAlpha2(this::ByConstRef1{TGeoTrap})::Float64


""" GetAlpha2(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetBl1()
@trydoc raw"""
    GetBl1(this::ByConstRef1{TGeoTrap})::Float64


""" GetBl1(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetBl2()
@trydoc raw"""
    GetBl2(this::ByConstRef1{TGeoTrap})::Float64


""" GetBl2(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetH1()
@trydoc raw"""
    GetH1(this::ByConstRef1{TGeoTrap})::Float64


""" GetH1(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetH2()
@trydoc raw"""
    GetH2(this::ByConstRef1{TGeoTrap})::Float64


""" GetH2(this::ByConstRef1{TGeoTrap})

# Wrapper of TGeoShape * TGeoTrap::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoTrap}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these have to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoTrap}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of Double_t TGeoTrap::GetPhi()
@trydoc raw"""
    GetPhi(this::ByConstRef1{TGeoTrap})::Float64


""" GetPhi(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetTheta()
@trydoc raw"""
    GetTheta(this::ByConstRef1{TGeoTrap})::Float64


""" GetTheta(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetTl1()
@trydoc raw"""
    GetTl1(this::ByConstRef1{TGeoTrap})::Float64


""" GetTl1(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::GetTl2()
@trydoc raw"""
    GetTl2(this::ByConstRef1{TGeoTrap})::Float64


""" GetTl2(this::ByConstRef1{TGeoTrap})

# Wrapper of Double_t TGeoTrap::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoTrap}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Computes the closest distance from given point to this shape.

""" Safety(this::ByConstRef1{TGeoTrap}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoTrap::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoTrap}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoTrap}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoTrap::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTrap}, param::ByPtr2{Float64})::Nothing
Set all arb8 params in one step.
- param[0] = dz
- param[1] = theta
- param[2] = phi
- param[3] = h1
- param[4] = bl1
- param[5] = tl1
- param[6] = alpha1
- param[7] = h2
- param[8] = bl2
- param[9] = tl2
- param[10] = alpha2
""" SetDimensions(this::ByRef1{TGeoTrap}, param::ByPtr2{Float64})

# Wrapper of Double_t TGeoGtra::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoGtra}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the shape.

""" DistFromInside(this::ByConstRef1{TGeoGtra}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoGtra::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoGtra}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoGtra}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoGtra::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoGtra}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the shape.

""" DistFromOutside(this::ByConstRef1{TGeoGtra}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoGtra::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoGtra}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoGtra}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoShape * TGeoGtra::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoGtra}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoGtra}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of Double_t TGeoGtra::GetTwistAngle()
@trydoc raw"""
    GetTwistAngle(this::ByConstRef1{TGeoGtra})::Float64


""" GetTwistAngle(this::ByConstRef1{TGeoGtra})

# Wrapper of Double_t TGeoGtra::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoGtra}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Computes the closest distance from given point to this shape.

""" Safety(this::ByConstRef1{TGeoGtra}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoGtra::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoGtra}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoGtra}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoGtra::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoGtra}, param::ByPtr2{Float64})::Nothing
Set all arb8 params in one step.
- param[0] = dz
- param[1] = theta
- param[2] = phi
- param[3] = h1
- param[4] = bl1
- param[5] = tl1
- param[6] = alpha1
- param[7] = h2
- param[8] = bl2
- param[9] = tl2
- param[10] = alpha2
- param[11] = twist
""" SetDimensions(this::ByRef1{TGeoGtra}, param::ByPtr2{Float64})

# Wrapper of Bool_t TGeoAtt::IsActive()
@trydoc raw"""
    IsActive(this::ByConstRef1{TGeoAtt})::Bool


""" IsActive(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsActiveDaughters()
@trydoc raw"""
    IsActiveDaughters(this::ByConstRef1{TGeoAtt})::Bool


""" IsActiveDaughters(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisBranch()
@trydoc raw"""
    IsVisBranch(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisBranch(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisContainers()
@trydoc raw"""
    IsVisContainers(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisContainers(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisDaughters()
@trydoc raw"""
    IsVisDaughters(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisDaughters(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisible()
@trydoc raw"""
    IsVisible(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisible(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisLeaves()
@trydoc raw"""
    IsVisLeaves(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisLeaves(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisOnly()
@trydoc raw"""
    IsVisOnly(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisOnly(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisRaytrace()
@trydoc raw"""
    IsVisRaytrace(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisRaytrace(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisStreamed()
@trydoc raw"""
    IsVisStreamed(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisStreamed(this::ByConstRef1{TGeoAtt})

# Wrapper of Bool_t TGeoAtt::IsVisTouched()
@trydoc raw"""
    IsVisTouched(this::ByConstRef1{TGeoAtt})::Bool


""" IsVisTouched(this::ByConstRef1{TGeoAtt})

# Wrapper of void TGeoAtt::ResetAttBit(UInt_t)
@trydoc raw"""
    ResetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)::Nothing


""" ResetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)

# Wrapper of void TGeoAtt::SetActiveDaughters(Bool_t)
@trydoc raw"""
    SetActiveDaughters(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing


""" SetActiveDaughters(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetActivity(Bool_t)
@trydoc raw"""
    SetActivity(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing


""" SetActivity(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetAttBit(UInt_t)
@trydoc raw"""
    SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)::Nothing


""" SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32)

# Wrapper of void TGeoAtt::SetAttBit(UInt_t, Bool_t)
@trydoc raw"""
    SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32, set::Bool)::Nothing


""" SetAttBit(this::ByRef1{TGeoAtt}, f::UInt32, set::Bool)

# Wrapper of void TGeoAtt::SetOptimization(Option_t *)
@trydoc raw"""
    SetOptimization(this::ByRef1{TGeoAtt}, option::ByCopy{String})::Nothing
Set optimization flags.

""" SetOptimization(this::ByRef1{TGeoAtt}, option::ByCopy{String})

# Wrapper of void TGeoAtt::SetVisBranch()
@trydoc raw"""
    SetVisBranch(this::ByRef1{TGeoAtt})::Nothing
Set branch type visibility.

""" SetVisBranch(this::ByRef1{TGeoAtt})

# Wrapper of void TGeoAtt::SetVisContainers(Bool_t)
@trydoc raw"""
    SetVisContainers(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing
Set branch type visibility.

""" SetVisContainers(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisDaughters(Bool_t)
@trydoc raw"""
    SetVisDaughters(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Set visibility for the daughters.

""" SetVisDaughters(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoAtt::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Set visibility for this object.

""" SetVisibility(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoAtt::SetVisLeaves(Bool_t)
@trydoc raw"""
    SetVisLeaves(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing
Set branch type visibility.

""" SetVisLeaves(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisOnly(Bool_t)
@trydoc raw"""
    SetVisOnly(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing
Set branch type visibility.

""" SetVisOnly(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisRaytrace(Bool_t)
@trydoc raw"""
    SetVisRaytrace(this::ByRef1{TGeoAtt}, flag::Bool)::Nothing


""" SetVisRaytrace(this::ByRef1{TGeoAtt}, flag::Bool)

# Wrapper of void TGeoAtt::SetVisStreamed(Bool_t)
@trydoc raw"""
    SetVisStreamed(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Mark attributes as "streamed to file".

""" SetVisStreamed(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of void TGeoAtt::SetVisTouched(Bool_t)
@trydoc raw"""
    SetVisTouched(this::ByRef1{TGeoAtt}, vis::Bool)::Nothing
Mark visualization attributes as "modified".

""" SetVisTouched(this::ByRef1{TGeoAtt}, vis::Bool)

# Wrapper of Bool_t TGeoAtt::TestAttBit(UInt_t)
@trydoc raw"""
    TestAttBit(this::ByConstRef1{TGeoAtt}, f::UInt32)::Bool


""" TestAttBit(this::ByConstRef1{TGeoAtt}, f::UInt32)

# Wrapper of void TGeoBoolNode::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoBoolNode})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoBoolNode})

# Wrapper of void TGeoBoolNode::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoBoolNode}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing


""" ComputeBBox(this::ByRef1{TGeoBoolNode}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoBoolNode::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing


""" ComputeNormal(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Bool_t TGeoBoolNode::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64})::Bool


""" Contains(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoBoolNode::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoBoolNode}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoBoolNode}, nthreads::Int32)

# Wrapper of Int_t TGeoBoolNode::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoBoolNode}, px::Int32, py::Int32)::Int32


""" DistanceToPrimitive(this::ByRef1{TGeoBoolNode}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoBoolNode::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64


""" DistFromInside(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of Double_t TGeoBoolNode::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64


""" DistFromOutside(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of TGeoMatrix * TGeoBoolNode::GetLeftMatrix()
@trydoc raw"""
    GetLeftMatrix(this::ByConstRef1{TGeoBoolNode})::CxxPtr1{TGeoMatrix}


""" GetLeftMatrix(this::ByConstRef1{TGeoBoolNode})

# Wrapper of TGeoShape * TGeoBoolNode::GetLeftShape()
@trydoc raw"""
    GetLeftShape(this::ByConstRef1{TGeoBoolNode})::CxxPtr1{TGeoShape}


""" GetLeftShape(this::ByConstRef1{TGeoBoolNode})

# Wrapper of Int_t TGeoBoolNode::GetNpoints()
@trydoc raw"""
    GetNpoints(this::ByRef1{TGeoBoolNode})::Int32
Returns number of vertices for the composite shape described by this node.

""" GetNpoints(this::ByRef1{TGeoBoolNode})

# Wrapper of TGeoMatrix * TGeoBoolNode::GetRightMatrix()
@trydoc raw"""
    GetRightMatrix(this::ByConstRef1{TGeoBoolNode})::CxxPtr1{TGeoMatrix}


""" GetRightMatrix(this::ByConstRef1{TGeoBoolNode})

# Wrapper of TGeoShape * TGeoBoolNode::GetRightShape()
@trydoc raw"""
    GetRightShape(this::ByConstRef1{TGeoBoolNode})::CxxPtr1{TGeoShape}


""" GetRightShape(this::ByConstRef1{TGeoBoolNode})

# Wrapper of TGeoBoolNode * TGeoBoolNode::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoBoolNode})::CxxPtr1{TGeoBoolNode}


""" MakeClone(this::ByConstRef1{TGeoBoolNode})

# Wrapper of void TGeoBoolNode::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoBoolNode}, option::ByCopy{String})::Nothing
Special schema for feeding the 3D buffers to the painter client.

""" Paint(this::ByRef1{TGeoBoolNode}, option::ByCopy{String})

# Wrapper of void TGeoBoolNode::RegisterMatrices()
@trydoc raw"""
    RegisterMatrices(this::ByRef1{TGeoBoolNode})::Nothing
Register all matrices of the boolean node and descendents.

""" RegisterMatrices(this::ByRef1{TGeoBoolNode})

# Wrapper of Bool_t TGeoBoolNode::ReplaceMatrix(TGeoMatrix *, TGeoMatrix *)
@trydoc raw"""
    ReplaceMatrix(this::ByRef1{TGeoBoolNode}, mat::ByPtr1{TGeoMatrix}, newmat::ByPtr1{TGeoMatrix})::Bool
Replace one of the matrices.
Does not work with [TGeoIdentity](@ref). Returns true if replacement was successful.
""" ReplaceMatrix(this::ByRef1{TGeoBoolNode}, mat::ByPtr1{TGeoMatrix}, newmat::ByPtr1{TGeoMatrix})

# Wrapper of Double_t TGeoBoolNode::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, in::Bool)::Float64


""" Safety(this::ByConstRef1{TGeoBoolNode}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoBoolNode::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoBoolNode}, points::ByPtr2{Float64})::Nothing
Fill buffer with shape vertices.

""" SetPoints(this::ByConstRef1{TGeoBoolNode}, points::ByPtr2{Float64})

# Wrapper of void TGeoBoolNode::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoBoolNode}, points::ByPtr2{Float32})::Nothing
Fill buffer with shape vertices.

""" SetPoints(this::ByConstRef1{TGeoBoolNode}, points::ByPtr2{Float32})

# Wrapper of void TGeoBoolNode::SetSelected(Int_t)
@trydoc raw"""
    SetSelected(this::ByRef1{TGeoBoolNode}, sel::Int32)::Nothing
Set the selected branch.

""" SetSelected(this::ByRef1{TGeoBoolNode}, sel::Int32)

# Wrapper of void TGeoBoolNode::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoBoolNode})::Nothing
Register size of this 3D object.

""" Sizeof3D(this::ByConstRef1{TGeoBoolNode})

# Wrapper of void TGeoUnion::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoUnion}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing
Compute bounding box corresponding to a union of two shapes.

""" ComputeBBox(this::ByRef1{TGeoUnion}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoUnion::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0.

""" ComputeNormal(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Bool_t TGeoUnion::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64})::Bool
Find if a union of two shapes contains a given point.

""" Contains(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoUnion::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoUnion}, px::Int32, py::Int32)::Int32
Compute minimum distance to shape vertices.

""" DistanceToPrimitive(this::ByRef1{TGeoUnion}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoUnion::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Computes distance from a given point inside the shape to its boundary.

""" DistFromInside(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of Double_t TGeoUnion::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from a given outside point to the shape.

""" DistFromOutside(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of TGeoBoolNode * TGeoUnion::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoUnion})::CxxPtr1{TGeoBoolNode}
Make a clone of this. Pointers are preserved.

""" MakeClone(this::ByConstRef1{TGeoUnion})

# Wrapper of void TGeoUnion::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoUnion}, option::ByCopy{String})::Nothing
Paint method.

""" Paint(this::ByRef1{TGeoUnion}, option::ByCopy{String})

# Wrapper of Double_t TGeoUnion::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Compute safety distance for a union node;.

""" Safety(this::ByConstRef1{TGeoUnion}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoUnion::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoUnion})::Nothing
Register 3D size of this shape.

""" Sizeof3D(this::ByConstRef1{TGeoUnion})

# Wrapper of void TGeoIntersection::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoIntersection}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing
Compute bounding box corresponding to a intersection of two shapes.

""" ComputeBBox(this::ByRef1{TGeoIntersection}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoIntersection::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0.

""" ComputeNormal(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Bool_t TGeoIntersection::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64})::Bool
Find if a intersection of two shapes contains a given point.

""" Contains(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoIntersection::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoIntersection}, px::Int32, py::Int32)::Int32
Compute minimum distance to shape vertices.

""" DistanceToPrimitive(this::ByRef1{TGeoIntersection}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoIntersection::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from a given point inside to the shape boundary.

""" DistFromInside(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of Double_t TGeoIntersection::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from a given point outside to the shape.

""" DistFromOutside(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of TGeoBoolNode * TGeoIntersection::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoIntersection})::CxxPtr1{TGeoBoolNode}
Make a clone of this. Pointers are preserved.

""" MakeClone(this::ByConstRef1{TGeoIntersection})

# Wrapper of void TGeoIntersection::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoIntersection}, option::ByCopy{String})::Nothing
Paint method.

""" Paint(this::ByRef1{TGeoIntersection}, option::ByCopy{String})

# Wrapper of Double_t TGeoIntersection::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Compute safety distance for a union node;.

""" Safety(this::ByConstRef1{TGeoIntersection}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoIntersection::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoIntersection})::Nothing
Register 3D size of this shape.

""" Sizeof3D(this::ByConstRef1{TGeoIntersection})

# Wrapper of void TGeoSubtraction::ComputeBBox(Double_t &, Double_t &, Double_t &, Double_t *)
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoSubtraction}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})::Nothing
Compute bounding box corresponding to a subtraction of two shapes.

""" ComputeBBox(this::ByRef1{TGeoSubtraction}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64}, origin::ByPtr2{Float64})

# Wrapper of void TGeoSubtraction::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0.

""" ComputeNormal(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of Bool_t TGeoSubtraction::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64})::Bool
Find if a subtraction of two shapes contains a given point.

""" Contains(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoSubtraction::DistanceToPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitive(this::ByRef1{TGeoSubtraction}, px::Int32, py::Int32)::Int32
Compute minimum distance to shape vertices.

""" DistanceToPrimitive(this::ByRef1{TGeoSubtraction}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoSubtraction::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from a given point inside to the shape boundary.

""" DistFromInside(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of Double_t TGeoSubtraction::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from a given point outside to the shape.

""" DistFromOutside(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of TGeoBoolNode * TGeoSubtraction::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoSubtraction})::CxxPtr1{TGeoBoolNode}
Make a clone of this. Pointers are preserved.

""" MakeClone(this::ByConstRef1{TGeoSubtraction})

# Wrapper of void TGeoSubtraction::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoSubtraction}, option::ByCopy{String})::Nothing
Paint method.

""" Paint(this::ByRef1{TGeoSubtraction}, option::ByCopy{String})

# Wrapper of Double_t TGeoSubtraction::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Compute safety distance for a union node;.

""" Safety(this::ByConstRef1{TGeoSubtraction}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoSubtraction::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoSubtraction})::Nothing
Register 3D size of this shape.

""" Sizeof3D(this::ByConstRef1{TGeoSubtraction})

# Wrapper of void TGeoHMatrix::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoHMatrix}, option::ByCopy{String})::Nothing
clear the data for this matrix

""" Clear(this::ByRef1{TGeoHMatrix}, option::ByCopy{String})

# Wrapper of void TGeoHMatrix::CopyFrom(const TGeoMatrix *)
@trydoc raw"""
    CopyFrom(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})::Nothing
Fast copy method.

""" CopyFrom(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})

# Wrapper of Double_t TGeoHMatrix::Determinant()
@trydoc raw"""
    Determinant(this::ByConstRef1{TGeoHMatrix})::Float64
computes determinant of the rotation matrix

""" Determinant(this::ByConstRef1{TGeoHMatrix})

# Wrapper of void TGeoHMatrix::FastRotZ(const Double_t *)
@trydoc raw"""
    FastRotZ(this::ByRef1{TGeoHMatrix}, sincos::ByConstPtr2{Float64})::Nothing
Perform a rotation about Z having the sine/cosine of the rotation angle.

""" FastRotZ(this::ByRef1{TGeoHMatrix}, sincos::ByConstPtr2{Float64})

# Wrapper of Double_t * TGeoHMatrix::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByRef1{TGeoHMatrix})::CxxPtr2{Float64}


""" GetRotationMatrix(this::ByRef1{TGeoHMatrix})

# Wrapper of const Double_t * TGeoHMatrix::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoHMatrix})::ConstCxxPtr2{Float64}


""" GetRotationMatrix(this::ByConstRef1{TGeoHMatrix})

# Wrapper of Double_t * TGeoHMatrix::GetScale()
@trydoc raw"""
    GetScale(this::ByRef1{TGeoHMatrix})::CxxPtr2{Float64}


""" GetScale(this::ByRef1{TGeoHMatrix})

# Wrapper of const Double_t * TGeoHMatrix::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoHMatrix})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoHMatrix})

# Wrapper of Double_t * TGeoHMatrix::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByRef1{TGeoHMatrix})::CxxPtr2{Float64}


""" GetTranslation(this::ByRef1{TGeoHMatrix})

# Wrapper of const Double_t * TGeoHMatrix::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoHMatrix})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoHMatrix})

# Wrapper of TGeoHMatrix TGeoHMatrix::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoHMatrix})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoHMatrix})

# Wrapper of TGeoMatrix * TGeoHMatrix::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoHMatrix})::CxxPtr1{TGeoMatrix}
Make a clone of this matrix.

""" MakeClone(this::ByConstRef1{TGeoHMatrix})

# Wrapper of void TGeoHMatrix::Multiply(const TGeoMatrix &)
@trydoc raw"""
    Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstRef1{TGeoMatrix})::Nothing


""" Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::Multiply(const TGeoMatrix *)
@trydoc raw"""
    Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstPtr1{TGeoMatrix})::Nothing
multiply to the right with an other transformation if right is identity matrix, just return

""" Multiply(this::ByRef1{TGeoHMatrix}, right::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::MultiplyLeft(const TGeoMatrix &)
@trydoc raw"""
    MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstRef1{TGeoMatrix})::Nothing


""" MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::MultiplyLeft(const TGeoMatrix *)
@trydoc raw"""
    MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstPtr1{TGeoMatrix})::Nothing
multiply to the left with an other transformation if right is identity matrix, just return

""" MultiplyLeft(this::ByRef1{TGeoHMatrix}, left::ByConstPtr1{TGeoMatrix})

# Wrapper of TGeoHMatrix TGeoHMatrix::operator*(const TGeoMatrix &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})::ByCopy{TGeoHMatrix}


""" Base.:(*)(this::ByConstRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator*=(const TGeoMatrix &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoHMatrix}
Composition.

""" mult!(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator=(const TGeoHMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoHMatrix})::CxxRef1{TGeoHMatrix}


""" assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoHMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoHMatrix}
assignment

""" assign(this::ByRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoHMatrix & TGeoHMatrix::operator=(const TGeoMatrix *)
@trydoc raw"""
    assign(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})::CxxRef1{TGeoHMatrix}
assignment

""" assign(this::ByRef1{TGeoHMatrix}, other::ByConstPtr1{TGeoMatrix})

# Wrapper of Bool_t TGeoHMatrix::operator==(const TGeoMatrix &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})::Bool
Is-equal operator.

""" Base.:(==)(this::ByConstRef1{TGeoHMatrix}, other::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoHMatrix::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoHMatrix::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoHMatrix::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoHMatrix}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoHMatrix::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoHMatrix}, angle::Float64)::Nothing
Rotate about X axis with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoHMatrix}, angle::Float64)

# Wrapper of void TGeoHMatrix::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoHMatrix}, angle::Float64)::Nothing
Rotate about Y axis with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoHMatrix}, angle::Float64)

# Wrapper of void TGeoHMatrix::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoHMatrix}, angle::Float64)::Nothing
Rotate about Z axis with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoHMatrix}, angle::Float64)

# Wrapper of void TGeoHMatrix::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoHMatrix}, dx::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoHMatrix}, dx::Float64)

# Wrapper of void TGeoHMatrix::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoHMatrix}, dy::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoHMatrix}, dy::Float64)

# Wrapper of void TGeoHMatrix::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoHMatrix}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoHMatrix}, dz::Float64)

# Wrapper of void TGeoHMatrix::SetRotation(const Double_t *)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoHMatrix}, matrix::ByConstPtr2{Float64})::Nothing


""" SetRotation(this::ByRef1{TGeoHMatrix}, matrix::ByConstPtr2{Float64})

# Wrapper of void TGeoHMatrix::SetScale(const Double_t *)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoHMatrix}, scale::ByConstPtr2{Float64})::Nothing


""" SetScale(this::ByRef1{TGeoHMatrix}, scale::ByConstPtr2{Float64})

# Wrapper of void TGeoHMatrix::SetTranslation(const Double_t *)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoHMatrix}, vect::ByConstPtr2{Float64})::Nothing


""" SetTranslation(this::ByRef1{TGeoHMatrix}, vect::ByConstPtr2{Float64})

# Wrapper of void TGeoTranslation::Add(const TGeoTranslation *)
@trydoc raw"""
    Add(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})::Nothing
Adding a translation to this one.

""" Add(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})

# Wrapper of const Double_t * TGeoTranslation::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoTranslation})::ConstCxxPtr2{Float64}


""" GetRotationMatrix(this::ByConstRef1{TGeoTranslation})

# Wrapper of const Double_t * TGeoTranslation::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoTranslation})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoTranslation})

# Wrapper of const Double_t * TGeoTranslation::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoTranslation})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoTranslation})

# Wrapper of TGeoHMatrix TGeoTranslation::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoTranslation})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoTranslation})

# Wrapper of void TGeoTranslation::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoTranslation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMaster(this::ByConstRef1{TGeoTranslation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoTranslation::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoTranslation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterBomb(this::ByConstRef1{TGeoTranslation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoTranslation::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoTranslation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a vector to MARS

""" LocalToMasterVect(this::ByConstRef1{TGeoTranslation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of TGeoMatrix * TGeoTranslation::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoTranslation})::CxxPtr1{TGeoMatrix}
Make a clone of this matrix.

""" MakeClone(this::ByConstRef1{TGeoTranslation})

# Wrapper of void TGeoTranslation::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoTranslation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocal(this::ByConstRef1{TGeoTranslation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoTranslation::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoTranslation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalBomb(this::ByConstRef1{TGeoTranslation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoTranslation::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoTranslation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a vector from MARS to local_

""" MasterToLocalVect(this::ByConstRef1{TGeoTranslation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of TGeoHMatrix TGeoTranslation::operator*(const TGeoMatrix &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoTranslation}, right::ByConstRef1{TGeoMatrix})::ByCopy{TGeoHMatrix}


""" Base.:(*)(this::ByConstRef1{TGeoTranslation}, right::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoTranslation TGeoTranslation::operator*(const TGeoTranslation &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoTranslation}, right::ByConstRef1{TGeoTranslation})::ByCopy{TGeoTranslation}


""" Base.:(*)(this::ByConstRef1{TGeoTranslation}, right::ByConstRef1{TGeoTranslation})

# Wrapper of TGeoTranslation & TGeoTranslation::operator*=(const TGeoTranslation &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})::CxxRef1{TGeoTranslation}
Translation composition.

""" mult!(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})

# Wrapper of TGeoTranslation & TGeoTranslation::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoTranslation}, matrix::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoTranslation}
Assignment from a general matrix.

""" assign(this::ByRef1{TGeoTranslation}, matrix::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoTranslation & TGeoTranslation::operator=(const TGeoTranslation &)
@trydoc raw"""
    assign(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})::CxxRef1{TGeoTranslation}


""" assign(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})

# Wrapper of Bool_t TGeoTranslation::operator==(const TGeoTranslation &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})::Bool
Is-equal operator.

""" Base.:(==)(this::ByConstRef1{TGeoTranslation}, other::ByConstRef1{TGeoTranslation})

# Wrapper of void TGeoTranslation::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoTranslation}, angle::Float64)::Nothing
Rotate about X axis of the master frame with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoTranslation}, angle::Float64)

# Wrapper of void TGeoTranslation::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoTranslation}, angle::Float64)::Nothing
Rotate about Y axis of the master frame with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoTranslation}, angle::Float64)

# Wrapper of void TGeoTranslation::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoTranslation}, angle::Float64)::Nothing
Rotate about Z axis of the master frame with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoTranslation}, angle::Float64)

# Wrapper of void TGeoTranslation::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoTranslation}, dx::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoTranslation}, dx::Float64)

# Wrapper of void TGeoTranslation::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoTranslation}, dy::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoTranslation}, dy::Float64)

# Wrapper of void TGeoTranslation::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoTranslation}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoTranslation}, dz::Float64)

# Wrapper of void TGeoTranslation::SetTranslation(const TGeoMatrix &)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoMatrix})::Nothing
Set translation components.

""" SetTranslation(this::ByRef1{TGeoTranslation}, other::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoTranslation::SetTranslation(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoTranslation}, dx::Float64, dy::Float64, dz::Float64)::Nothing
Set translation components.

""" SetTranslation(this::ByRef1{TGeoTranslation}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of void TGeoTranslation::Subtract(const TGeoTranslation *)
@trydoc raw"""
    Subtract(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})::Nothing
Subtracting a translation from this one.

""" Subtract(this::ByRef1{TGeoTranslation}, other::ByConstPtr1{TGeoTranslation})

# Wrapper of void TGeoRotation::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoRotation}, option::ByCopy{String})::Nothing
reset data members

""" Clear(this::ByRef1{TGeoRotation}, option::ByCopy{String})

# Wrapper of Double_t TGeoRotation::Determinant()
@trydoc raw"""
    Determinant(this::ByConstRef1{TGeoRotation})::Float64
computes determinant of the rotation matrix

""" Determinant(this::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoRotation::FastRotZ(const Double_t *)
@trydoc raw"""
    FastRotZ(this::ByRef1{TGeoRotation}, sincos::ByConstPtr2{Float64})::Nothing
Perform a rotation about Z having the sine/cosine of the rotation angle.

""" FastRotZ(this::ByRef1{TGeoRotation}, sincos::ByConstPtr2{Float64})

# Wrapper of void TGeoRotation::GetAngles(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetAngles(this::ByConstRef1{TGeoRotation}, phi::ByRef2{Float64}, theta::ByRef2{Float64}, psi::ByRef2{Float64})::Nothing
Retrieve Euler angles.

""" GetAngles(this::ByConstRef1{TGeoRotation}, phi::ByRef2{Float64}, theta::ByRef2{Float64}, psi::ByRef2{Float64})

# Wrapper of void TGeoRotation::GetAngles(Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetAngles(this::ByConstRef1{TGeoRotation}, theta1::ByRef2{Float64}, phi1::ByRef2{Float64}, theta2::ByRef2{Float64}, phi2::ByRef2{Float64}, theta3::ByRef2{Float64}, phi3::ByRef2{Float64})::Nothing
Retrieve rotation angles.

""" GetAngles(this::ByConstRef1{TGeoRotation}, theta1::ByRef2{Float64}, phi1::ByRef2{Float64}, theta2::ByRef2{Float64}, phi2::ByRef2{Float64}, theta3::ByRef2{Float64}, phi3::ByRef2{Float64})

# Wrapper of void TGeoRotation::GetInverse(Double_t *)
@trydoc raw"""
    GetInverse(this::ByConstRef1{TGeoRotation}, invmat::ByPtr2{Float64})::Nothing
Get the inverse rotation matrix (which is simply the transpose)

""" GetInverse(this::ByConstRef1{TGeoRotation}, invmat::ByPtr2{Float64})

# Wrapper of Double_t TGeoRotation::GetPhiRotation(Bool_t)
@trydoc raw"""
    GetPhiRotation(this::ByConstRef1{TGeoRotation}, fixX::Bool)::Float64
Returns rotation angle about Z axis in degrees.
If the rotation is a pure rotation about Z, fixX parameter does not matter, otherwise its meaning is:

- fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY
- fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees
""" GetPhiRotation(this::ByConstRef1{TGeoRotation}, fixX::Bool)

# Wrapper of const Double_t * TGeoRotation::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoRotation})::ConstCxxPtr2{Float64}


""" GetRotationMatrix(this::ByConstRef1{TGeoRotation})

# Wrapper of const Double_t * TGeoRotation::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoRotation})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoRotation})

# Wrapper of const Double_t * TGeoRotation::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoRotation})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoRotation})

# Wrapper of TGeoHMatrix TGeoRotation::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoRotation})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoRotation})

# Wrapper of Bool_t TGeoRotation::IsValid()
@trydoc raw"""
    IsValid(this::ByConstRef1{TGeoRotation})::Bool
Perform orthogonality test for rotation.

""" IsValid(this::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoRotation::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoRotation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMaster(this::ByConstRef1{TGeoRotation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoRotation::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoRotation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterBomb(this::ByConstRef1{TGeoRotation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoRotation::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoRotation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterVect(this::ByConstRef1{TGeoRotation}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of TGeoMatrix * TGeoRotation::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoRotation})::CxxPtr1{TGeoMatrix}
Make a clone of this matrix.

""" MakeClone(this::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoRotation::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoRotation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocal(this::ByConstRef1{TGeoRotation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoRotation::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoRotation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalBomb(this::ByConstRef1{TGeoRotation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoRotation::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoRotation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalVect(this::ByConstRef1{TGeoRotation}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoRotation::MultiplyBy(const TGeoRotation *, Bool_t)
@trydoc raw"""
    MultiplyBy(this::ByRef1{TGeoRotation}, rot::ByConstPtr1{TGeoRotation}, after::Bool)::Nothing
Multiply this rotation with the one specified by ROT.
- after=TRUE (default): THIS*ROT
- after=FALSE : ROT*THIS
""" MultiplyBy(this::ByRef1{TGeoRotation}, rot::ByConstPtr1{TGeoRotation}, after::Bool)

# Wrapper of TGeoHMatrix TGeoRotation::operator*(const TGeoMatrix &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoRotation}, right::ByConstRef1{TGeoMatrix})::ByCopy{TGeoHMatrix}


""" Base.:(*)(this::ByConstRef1{TGeoRotation}, right::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoRotation TGeoRotation::operator*(const TGeoRotation &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})::ByCopy{TGeoRotation}


""" Base.:(*)(this::ByConstRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})

# Wrapper of TGeoRotation & TGeoRotation::operator*=(const TGeoRotation &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})::CxxRef1{TGeoRotation}
Composition.

""" mult!(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})

# Wrapper of TGeoRotation & TGeoRotation::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoRotation}
Assignment from a general matrix.

""" assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoRotation & TGeoRotation::operator=(const TGeoRotation &)
@trydoc raw"""
    assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})::CxxRef1{TGeoRotation}


""" assign(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})

# Wrapper of Bool_t TGeoRotation::operator==(const TGeoRotation &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})::Bool
Is-equal operator.

""" Base.:(==)(this::ByConstRef1{TGeoRotation}, other::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoRotation::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoRotation::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoRotation::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoRotation}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoRotation::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoRotation}, angle::Float64)::Nothing
Rotate about X axis of the master frame with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoRotation}, angle::Float64)

# Wrapper of void TGeoRotation::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoRotation}, angle::Float64)::Nothing
Rotate about Y axis of the master frame with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoRotation}, angle::Float64)

# Wrapper of void TGeoRotation::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoRotation}, angle::Float64)::Nothing
Rotate about Z axis of the master frame with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoRotation}, angle::Float64)

# Wrapper of void TGeoRotation::SetAngles(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetAngles(this::ByRef1{TGeoRotation}, phi::Float64, theta::Float64, psi::Float64)::Nothing
Set matrix elements according to Euler angles.
Phi is the rotation angle about Z axis and is done first, theta is the rotation about new X and is done second, psi is the rotation angle about new Z and is done third. All angles are in degrees.
""" SetAngles(this::ByRef1{TGeoRotation}, phi::Float64, theta::Float64, psi::Float64)

# Wrapper of void TGeoRotation::SetAngles(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetAngles(this::ByRef1{TGeoRotation}, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)::Nothing
Set matrix elements in the GEANT3 way.

""" SetAngles(this::ByRef1{TGeoRotation}, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)

# Wrapper of void TGeoRotation::SetMatrix(const Double_t *)
@trydoc raw"""
    SetMatrix(this::ByRef1{TGeoRotation}, rot::ByConstPtr2{Float64})::Nothing


""" SetMatrix(this::ByRef1{TGeoRotation}, rot::ByConstPtr2{Float64})

# Wrapper of void TGeoRotation::SetRotation(const TGeoMatrix &)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})::Nothing
Copy rotation elements from other rotation matrix.

""" SetRotation(this::ByRef1{TGeoRotation}, other::ByConstRef1{TGeoMatrix})

# Wrapper of const Double_t * TGeoScale::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoScale})::ConstCxxPtr2{Float64}


""" GetRotationMatrix(this::ByConstRef1{TGeoScale})

# Wrapper of const Double_t * TGeoScale::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoScale})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoScale})

# Wrapper of const Double_t * TGeoScale::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoScale})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoScale})

# Wrapper of TGeoHMatrix TGeoScale::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoScale})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoScale})

# Wrapper of void TGeoScale::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoScale}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Convert a local_ point to the master frame.

""" LocalToMaster(this::ByConstRef1{TGeoScale}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of Double_t TGeoScale::LocalToMaster(Double_t, const Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoScale}, dist::Float64, dir::ByConstPtr2{Float64})::Float64
Convert the local_ distance along unit vector DIR to master frame.
If DIR is not specified perform a conversion such as the returned distance is the the minimum for all possible directions.
""" LocalToMaster(this::ByConstRef1{TGeoScale}, dist::Float64, dir::ByConstPtr2{Float64})

# Wrapper of void TGeoScale::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoScale}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterVect(this::ByConstRef1{TGeoScale}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of TGeoMatrix * TGeoScale::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoScale})::CxxPtr1{TGeoMatrix}
Make a clone of this matrix.

""" MakeClone(this::ByConstRef1{TGeoScale})

# Wrapper of void TGeoScale::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoScale}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
Convert a global_ point to local_ frame.

""" MasterToLocal(this::ByConstRef1{TGeoScale}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of Double_t TGeoScale::MasterToLocal(Double_t, const Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoScale}, dist::Float64, dir::ByConstPtr2{Float64})::Float64
Convert the distance along unit vector DIR to local_ frame.
If DIR is not specified perform a conversion such as the returned distance is the the minimum for all possible directions.
""" MasterToLocal(this::ByConstRef1{TGeoScale}, dist::Float64, dir::ByConstPtr2{Float64})

# Wrapper of void TGeoScale::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoScale}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalVect(this::ByConstRef1{TGeoScale}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of TGeoHMatrix TGeoScale::operator*(const TGeoMatrix &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoScale}, right::ByConstRef1{TGeoMatrix})::ByCopy{TGeoHMatrix}


""" Base.:(*)(this::ByConstRef1{TGeoScale}, right::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoScale TGeoScale::operator*(const TGeoScale &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoScale}, other::ByConstRef1{TGeoScale})::ByCopy{TGeoScale}


""" Base.:(*)(this::ByConstRef1{TGeoScale}, other::ByConstRef1{TGeoScale})

# Wrapper of TGeoScale & TGeoScale::operator*=(const TGeoScale &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})::CxxRef1{TGeoScale}
Scale composition.

""" mult!(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})

# Wrapper of TGeoScale & TGeoScale::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoScale}
Assignment from a general matrix.

""" assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoScale & TGeoScale::operator=(const TGeoScale &)
@trydoc raw"""
    assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})::CxxRef1{TGeoScale}


""" assign(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoScale})

# Wrapper of Bool_t TGeoScale::operator==(const TGeoScale &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TGeoScale}, other::ByConstRef1{TGeoScale})::Bool
Is-equal operator.

""" Base.:(==)(this::ByConstRef1{TGeoScale}, other::ByConstRef1{TGeoScale})

# Wrapper of void TGeoScale::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoScale::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoScale::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoScale}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoScale::SetScale(const TGeoMatrix &)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})::Nothing
Set scale from other transformation.

""" SetScale(this::ByRef1{TGeoScale}, other::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoScale::SetScale(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoScale}, sx::Float64, sy::Float64, sz::Float64)::Nothing
scale setter

""" SetScale(this::ByRef1{TGeoScale}, sx::Float64, sy::Float64, sz::Float64)

# Wrapper of void TGeoCombiTrans::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoCombiTrans}, option::ByCopy{String})::Nothing
Reset translation/rotation to identity.

""" Clear(this::ByRef1{TGeoCombiTrans}, option::ByCopy{String})

# Wrapper of TGeoRotation * TGeoCombiTrans::GetRotation()
@trydoc raw"""
    GetRotation(this::ByConstRef1{TGeoCombiTrans})::CxxPtr1{TGeoRotation}


""" GetRotation(this::ByConstRef1{TGeoCombiTrans})

# Wrapper of const Double_t * TGeoCombiTrans::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoCombiTrans})::ConstCxxPtr2{Float64}
get the rotation array

""" GetRotationMatrix(this::ByConstRef1{TGeoCombiTrans})

# Wrapper of const Double_t * TGeoCombiTrans::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoCombiTrans})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoCombiTrans})

# Wrapper of const Double_t * TGeoCombiTrans::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoCombiTrans})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoCombiTrans})

# Wrapper of TGeoHMatrix TGeoCombiTrans::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoCombiTrans})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoCombiTrans})

# Wrapper of TGeoMatrix * TGeoCombiTrans::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoCombiTrans})::CxxPtr1{TGeoMatrix}
Make a clone of this matrix.

""" MakeClone(this::ByConstRef1{TGeoCombiTrans})

# Wrapper of void TGeoCombiTrans::Multiply(const TGeoMatrix *)
@trydoc raw"""
    Multiply(this::ByRef1{TGeoCombiTrans}, right::ByConstPtr1{TGeoMatrix})::Nothing
multiply to the right with an other transformation if right is identity matrix, just return

""" Multiply(this::ByRef1{TGeoCombiTrans}, right::ByConstPtr1{TGeoMatrix})

# Wrapper of TGeoCombiTrans TGeoCombiTrans::operator*(const TGeoMatrix &)
@trydoc raw"""
    Base.:(*)(this::ByConstRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})::ByCopy{TGeoCombiTrans}


""" Base.:(*)(this::ByConstRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoCombiTrans & TGeoCombiTrans::operator*=(const TGeoMatrix &)
@trydoc raw"""
    mult!(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoCombiTrans}
Composition.

""" mult!(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})

# Wrapper of TGeoCombiTrans & TGeoCombiTrans::operator=(const TGeoCombiTrans &)
@trydoc raw"""
    assign(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoCombiTrans})::CxxRef1{TGeoCombiTrans}


""" assign(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoCombiTrans})

# Wrapper of TGeoCombiTrans & TGeoCombiTrans::operator=(const TGeoMatrix &)
@trydoc raw"""
    assign(this::ByRef1{TGeoCombiTrans}, matrix::ByConstRef1{TGeoMatrix})::CxxRef1{TGeoCombiTrans}
Assignment operator with generic matrix.

""" assign(this::ByRef1{TGeoCombiTrans}, matrix::ByConstRef1{TGeoMatrix})

# Wrapper of Bool_t TGeoCombiTrans::operator==(const TGeoMatrix &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})::Bool
Is-equal operator.

""" Base.:(==)(this::ByConstRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoMatrix})

# Wrapper of void TGeoCombiTrans::ReflectX(Bool_t, Bool_t)
@trydoc raw"""
    ReflectX(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to YZ.

""" ReflectX(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoCombiTrans::ReflectY(Bool_t, Bool_t)
@trydoc raw"""
    ReflectY(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to ZX.

""" ReflectY(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoCombiTrans::ReflectZ(Bool_t, Bool_t)
@trydoc raw"""
    ReflectZ(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)::Nothing
Multiply by a reflection respect to XY.

""" ReflectZ(this::ByRef1{TGeoCombiTrans}, leftside::Bool, rotonly::Bool)

# Wrapper of void TGeoCombiTrans::RegisterYourself()
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoCombiTrans})::Nothing
Register the matrix in the current manager, which will become the owner.

""" RegisterYourself(this::ByRef1{TGeoCombiTrans})

# Wrapper of void TGeoCombiTrans::RotateX(Double_t)
@trydoc raw"""
    RotateX(this::ByRef1{TGeoCombiTrans}, angle::Float64)::Nothing
Rotate about X axis with angle expressed in degrees.

""" RotateX(this::ByRef1{TGeoCombiTrans}, angle::Float64)

# Wrapper of void TGeoCombiTrans::RotateY(Double_t)
@trydoc raw"""
    RotateY(this::ByRef1{TGeoCombiTrans}, angle::Float64)::Nothing
Rotate about Y axis with angle expressed in degrees.

""" RotateY(this::ByRef1{TGeoCombiTrans}, angle::Float64)

# Wrapper of void TGeoCombiTrans::RotateZ(Double_t)
@trydoc raw"""
    RotateZ(this::ByRef1{TGeoCombiTrans}, angle::Float64)::Nothing
Rotate about Z axis with angle expressed in degrees.

""" RotateZ(this::ByRef1{TGeoCombiTrans}, angle::Float64)

# Wrapper of void TGeoCombiTrans::SetDx(Double_t)
@trydoc raw"""
    SetDx(this::ByRef1{TGeoCombiTrans}, dx::Float64)::Nothing


""" SetDx(this::ByRef1{TGeoCombiTrans}, dx::Float64)

# Wrapper of void TGeoCombiTrans::SetDy(Double_t)
@trydoc raw"""
    SetDy(this::ByRef1{TGeoCombiTrans}, dy::Float64)::Nothing


""" SetDy(this::ByRef1{TGeoCombiTrans}, dy::Float64)

# Wrapper of void TGeoCombiTrans::SetDz(Double_t)
@trydoc raw"""
    SetDz(this::ByRef1{TGeoCombiTrans}, dz::Float64)::Nothing


""" SetDz(this::ByRef1{TGeoCombiTrans}, dz::Float64)

# Wrapper of void TGeoCombiTrans::SetRotation(const TGeoRotation &)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoRotation})::Nothing
Copy the rotation from another one.

""" SetRotation(this::ByRef1{TGeoCombiTrans}, other::ByConstRef1{TGeoRotation})

# Wrapper of void TGeoCombiTrans::SetRotation(const TGeoRotation *)
@trydoc raw"""
    SetRotation(this::ByRef1{TGeoCombiTrans}, rot::ByConstPtr1{TGeoRotation})::Nothing
Assign a foreign rotation to the combi. The rotation is NOT owned by this.

""" SetRotation(this::ByRef1{TGeoCombiTrans}, rot::ByConstPtr1{TGeoRotation})

# Wrapper of void TGeoCombiTrans::SetTranslation(const TGeoTranslation &)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoCombiTrans}, tr::ByConstRef1{TGeoTranslation})::Nothing
copy the translation component

""" SetTranslation(this::ByRef1{TGeoCombiTrans}, tr::ByConstRef1{TGeoTranslation})

# Wrapper of void TGeoCombiTrans::SetTranslation(Double_t *)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoCombiTrans}, vect::ByPtr2{Float64})::Nothing
set the translation component

""" SetTranslation(this::ByRef1{TGeoCombiTrans}, vect::ByPtr2{Float64})

# Wrapper of void TGeoCombiTrans::SetTranslation(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTranslation(this::ByRef1{TGeoCombiTrans}, dx::Float64, dy::Float64, dz::Float64)::Nothing
set the translation component

""" SetTranslation(this::ByRef1{TGeoCombiTrans}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of void TGeoGenTrans::Clear(Option_t *)
@trydoc raw"""
    Clear(this::ByRef1{TGeoGenTrans}, option::ByCopy{String})::Nothing
clear the fields of this transformation

""" Clear(this::ByRef1{TGeoGenTrans}, option::ByCopy{String})

# Wrapper of const Double_t * TGeoGenTrans::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoGenTrans})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoGenTrans})

# Wrapper of TGeoHMatrix TGeoGenTrans::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoGenTrans})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoGenTrans})

# Wrapper of TGeoMatrix * TGeoGenTrans::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoGenTrans})::CxxPtr1{TGeoMatrix}
Make a clone of this matrix.

""" MakeClone(this::ByConstRef1{TGeoGenTrans})

# Wrapper of Bool_t TGeoGenTrans::Normalize()
@trydoc raw"""
    Normalize(this::ByRef1{TGeoGenTrans})::Bool
A scale transformation should be normalized by sx*sy*sz factor.

""" Normalize(this::ByRef1{TGeoGenTrans})

# Wrapper of void TGeoGenTrans::SetScale(Double_t *)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoGenTrans}, scale::ByPtr2{Float64})::Nothing


""" SetScale(this::ByRef1{TGeoGenTrans}, scale::ByPtr2{Float64})

# Wrapper of void TGeoGenTrans::SetScale(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoGenTrans}, sx::Float64, sy::Float64, sz::Float64)::Nothing
set the scale

""" SetScale(this::ByRef1{TGeoGenTrans}, sx::Float64, sy::Float64, sz::Float64)

# Wrapper of const Double_t * TGeoIdentity::GetRotationMatrix()
@trydoc raw"""
    GetRotationMatrix(this::ByConstRef1{TGeoIdentity})::ConstCxxPtr2{Float64}


""" GetRotationMatrix(this::ByConstRef1{TGeoIdentity})

# Wrapper of const Double_t * TGeoIdentity::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoIdentity})::ConstCxxPtr2{Float64}


""" GetScale(this::ByConstRef1{TGeoIdentity})

# Wrapper of const Double_t * TGeoIdentity::GetTranslation()
@trydoc raw"""
    GetTranslation(this::ByConstRef1{TGeoIdentity})::ConstCxxPtr2{Float64}


""" GetTranslation(this::ByConstRef1{TGeoIdentity})

# Wrapper of TGeoHMatrix TGeoIdentity::Inverse()
@trydoc raw"""
    Inverse(this::ByConstRef1{TGeoIdentity})::ByCopy{TGeoHMatrix}
Return a temporary inverse of this.

""" Inverse(this::ByConstRef1{TGeoIdentity})

# Wrapper of void TGeoIdentity::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoIdentity}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMaster(this::ByConstRef1{TGeoIdentity}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoIdentity::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoIdentity}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterBomb(this::ByConstRef1{TGeoIdentity}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoIdentity::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoIdentity}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse

""" LocalToMasterVect(this::ByConstRef1{TGeoIdentity}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of TGeoMatrix * TGeoIdentity::MakeClone()
@trydoc raw"""
    MakeClone(this::ByConstRef1{TGeoIdentity})::CxxPtr1{TGeoMatrix}


""" MakeClone(this::ByConstRef1{TGeoIdentity})

# Wrapper of void TGeoIdentity::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoIdentity}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocal(this::ByConstRef1{TGeoIdentity}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoIdentity::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoIdentity}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalBomb(this::ByConstRef1{TGeoIdentity}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoIdentity::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoIdentity}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
convert a point by multiplying its column vector (x, y, z, 1) to matrix

""" MasterToLocalVect(this::ByConstRef1{TGeoIdentity}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoBranchArray::AddLevel(Int_t)
@trydoc raw"""
    AddLevel(this::ByRef1{TGeoBranchArray}, dindex::Int32)::Nothing
Add and extra daughter to the current path array. No validity check performed !

""" AddLevel(this::ByRef1{TGeoBranchArray}, dindex::Int32)

# Wrapper of void TGeoBranchArray::CleanMatrix()
@trydoc raw"""
    CleanMatrix(this::ByRef1{TGeoBranchArray})::Nothing
Garbage collect the stored matrix.

""" CleanMatrix(this::ByRef1{TGeoBranchArray})

# Wrapper of Int_t TGeoBranchArray::Compare(const TObject *)
@trydoc raw"""
    Compare(this::ByConstRef1{TGeoBranchArray}, obj::ByConstPtr1{TObject})::Int32
Compare with other object of same type.
Returns -1 if this is smaller (first smaller array value prevails), 0 if equal (size and values) and 1 if this is larger.
""" Compare(this::ByConstRef1{TGeoBranchArray}, obj::ByConstPtr1{TObject})

# Wrapper of void TGeoBranchArray::CopyTo(TGeoBranchArray *)
@trydoc raw"""
    CopyTo(this::ByRef1{TGeoBranchArray}, dest::ByPtr1{TGeoBranchArray})::Nothing
Raw memcpy of the branch array content to an existing destination.

""" CopyTo(this::ByRef1{TGeoBranchArray}, dest::ByPtr1{TGeoBranchArray})

# Wrapper of size_t TGeoBranchArray::DataSize()
@trydoc raw"""
    DataSize(this::ByConstRef1{TGeoBranchArray})::Int64


""" DataSize(this::ByConstRef1{TGeoBranchArray})

# Wrapper of void * TGeoBranchArray::DataStart()
@trydoc raw"""
    DataStart(this::ByConstRef1{TGeoBranchArray})::CxxPtr2{Nothing}


""" DataStart(this::ByConstRef1{TGeoBranchArray})

# Wrapper of TGeoNode ** TGeoBranchArray::GetArray()
@trydoc raw"""
    GetArray(this::ByConstRef1{TGeoBranchArray})::CxxPtr1{TGeoNode}


""" GetArray(this::ByConstRef1{TGeoBranchArray})

# Wrapper of TGeoNode * TGeoBranchArray::GetCurrentNode()
@trydoc raw"""
    GetCurrentNode(this::ByConstRef1{TGeoBranchArray})::CxxPtr1{TGeoNode}


""" GetCurrentNode(this::ByConstRef1{TGeoBranchArray})

# Wrapper of size_t TGeoBranchArray::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoBranchArray})::Int64


""" GetLevel(this::ByConstRef1{TGeoBranchArray})

# Wrapper of const TGeoHMatrix * TGeoBranchArray::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByConstRef1{TGeoBranchArray})::ConstCxxPtr1{TGeoHMatrix}


""" GetMatrix(this::ByConstRef1{TGeoBranchArray})

# Wrapper of size_t TGeoBranchArray::GetMaxLevel()
@trydoc raw"""
    GetMaxLevel(this::ByConstRef1{TGeoBranchArray})::Int64


""" GetMaxLevel(this::ByConstRef1{TGeoBranchArray})

# Wrapper of TGeoNode * TGeoBranchArray::GetNode(Int_t)
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoBranchArray}, level::Int32)::CxxPtr1{TGeoNode}


""" GetNode(this::ByConstRef1{TGeoBranchArray}, level::Int32)

# Wrapper of void TGeoBranchArray::GetPath(TString &)
@trydoc raw"""
    GetPath(this::ByConstRef1{TGeoBranchArray}, path::ByRef1{TString})::Nothing
Fill path pointed by the array.

""" GetPath(this::ByConstRef1{TGeoBranchArray}, path::ByRef1{TString})

# Wrapper of void TGeoBranchArray::Init(TGeoNode **, TGeoMatrix *, Int_t)
@trydoc raw"""
    Init(this::ByRef1{TGeoBranchArray}, branch::ByPtr1{TGeoNode}, global_::ByPtr1{TGeoMatrix}, level::Int32)::Nothing
Init the branch array from an array of nodes, the global_ matrix for the path and the level.

""" Init(this::ByRef1{TGeoBranchArray}, branch::ByPtr1{TGeoNode}, global_::ByPtr1{TGeoMatrix}, level::Int32)

# Wrapper of void TGeoBranchArray::InitFromNavigator(TGeoNavigator *)
@trydoc raw"""
    InitFromNavigator(this::ByRef1{TGeoBranchArray}, nav::ByPtr1{TGeoNavigator})::Nothing
Init the branch array from current navigator state.

""" InitFromNavigator(this::ByRef1{TGeoBranchArray}, nav::ByPtr1{TGeoNavigator})

# Wrapper of Bool_t TGeoBranchArray::IsOutside()
@trydoc raw"""
    IsOutside(this::ByConstRef1{TGeoBranchArray})::Bool


""" IsOutside(this::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::IsSortable()
@trydoc raw"""
    IsSortable(this::ByConstRef1{TGeoBranchArray})::Bool


""" IsSortable(this::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::operator!=(const TGeoBranchArray &)
@trydoc raw"""
    Base.:(!=)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::Bool
Not equal operator.

""" Base.:(!=)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::operator<(const TGeoBranchArray &)
@trydoc raw"""
    Base.:(<)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::Bool
Is equal operator.

""" Base.:(<)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::operator<=(const TGeoBranchArray &)
@trydoc raw"""
    Base.:(<=)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::Bool
Is equal operator.

""" Base.:(<=)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of TGeoBranchArray & TGeoBranchArray::operator=(const TGeoBranchArray &)
@trydoc raw"""
    assign(this::ByRef1{TGeoBranchArray}, ::ByConstRef1{TGeoBranchArray})::CxxRef1{TGeoBranchArray}
Assignment. Not valid anymore. Use [TGeoBranchArray!MakeCopy](@ref) instead.

""" assign(this::ByRef1{TGeoBranchArray}, ::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::operator==(const TGeoBranchArray &)
@trydoc raw"""
    Base.:(==)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::Bool
Is equal operator.

""" Base.:(==)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::operator>(const TGeoBranchArray &)
@trydoc raw"""
    Base.:(>)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::Bool
Is equal operator.

""" Base.:(>)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of Bool_t TGeoBranchArray::operator>=(const TGeoBranchArray &)
@trydoc raw"""
    Base.:(>=)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::Bool
Is equal operator.

""" Base.:(>=)(this::ByConstRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of void TGeoBranchArray::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoBranchArray}, option::ByCopy{String})::Nothing
Print branch information.

""" Print(this::ByConstRef1{TGeoBranchArray}, option::ByCopy{String})

# Wrapper of size_t TGeoBranchArray::SizeOf()
@trydoc raw"""
    SizeOf(this::ByConstRef1{TGeoBranchArray})::Int64


""" SizeOf(this::ByConstRef1{TGeoBranchArray})

# Wrapper of void TGeoBranchArray::UpdateArray(size_t)
@trydoc raw"""
    UpdateArray(this::ByRef1{TGeoBranchArray}, nobj::Int64)::Nothing
Updates the internal addresses for n contiguous objects which have the same fMaxLevel Updates the internal addresses for n contiguous objects which have the same fMaxLevel.

""" UpdateArray(this::ByRef1{TGeoBranchArray}, nobj::Int64)

# Wrapper of void TGeoBranchArray::UpdateNavigator(TGeoNavigator *)
@trydoc raw"""
    UpdateNavigator(this::ByConstRef1{TGeoBranchArray}, nav::ByPtr1{TGeoNavigator})::Nothing
Update the navigator to reflect the branch.
nav->CdTop();
""" UpdateNavigator(this::ByConstRef1{TGeoBranchArray}, nav::ByPtr1{TGeoNavigator})

# Wrapper of Long64_t TGeoBranchArray::BinarySearch(Long64_t, const TGeoBranchArray **, TGeoBranchArray *)
@trydoc raw"""
    TGeoBranchArray!BinarySearch(this::ByRef1{TGeoBranchArray}, n::Int64, array::ByConstPtr1{TGeoBranchArray}, value::ByPtr1{TGeoBranchArray})::Int64
Binary search in an array of n pointers to branch arrays, to locate value.
Returns element index or index of nearest element smaller than value
""" TGeoBranchArray!BinarySearch(this::ByRef1{TGeoBranchArray}, n::Int64, array::ByConstPtr1{TGeoBranchArray}, value::ByPtr1{TGeoBranchArray})

# Wrapper of TGeoBranchArray * TGeoBranchArray::MakeCopy(const TGeoBranchArray &)
@trydoc raw"""
    TGeoBranchArray!MakeCopy(this::ByRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})::CxxPtr1{TGeoBranchArray}
Make a copy of a branch array at the location (if indicated)

""" TGeoBranchArray!MakeCopy(this::ByRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray})

# Wrapper of TGeoBranchArray * TGeoBranchArray::MakeCopyAt(const TGeoBranchArray &, void *)
@trydoc raw"""
    TGeoBranchArray!MakeCopyAt(this::ByRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray}, addr::ByPtr2{Nothing})::CxxPtr1{TGeoBranchArray}
Make a copy of a branch array at the location (if indicated)

""" TGeoBranchArray!MakeCopyAt(this::ByRef1{TGeoBranchArray}, other::ByConstRef1{TGeoBranchArray}, addr::ByPtr2{Nothing})

# Wrapper of TGeoBranchArray * TGeoBranchArray::MakeInstance(size_t)
@trydoc raw"""
    TGeoBranchArray!MakeInstance(this::ByRef1{TGeoBranchArray}, maxlevel::Int64)::CxxPtr1{TGeoBranchArray}
Make an instance of the class which allocates the node array.
To be released using ReleaseInstance. If addr is non-zero, the user promised that addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);
""" TGeoBranchArray!MakeInstance(this::ByRef1{TGeoBranchArray}, maxlevel::Int64)

# Wrapper of TGeoBranchArray * TGeoBranchArray::MakeInstanceAt(size_t, void *)
@trydoc raw"""
    TGeoBranchArray!MakeInstanceAt(this::ByRef1{TGeoBranchArray}, maxlevel::Int64, addr::ByPtr2{Nothing})::CxxPtr1{TGeoBranchArray}
Make an instance of the class which allocates the node array.
To be released using ReleaseInstance. If addr is non-zero, the user promised that addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);
""" TGeoBranchArray!MakeInstanceAt(this::ByRef1{TGeoBranchArray}, maxlevel::Int64, addr::ByPtr2{Nothing})

# Wrapper of void TGeoBranchArray::ReleaseInstance(TGeoBranchArray *)
@trydoc raw"""
    TGeoBranchArray!ReleaseInstance(this::ByRef1{TGeoBranchArray}, obj::ByPtr1{TGeoBranchArray})::Nothing
Releases the space allocated for the object.

""" TGeoBranchArray!ReleaseInstance(this::ByRef1{TGeoBranchArray}, obj::ByPtr1{TGeoBranchArray})

# Wrapper of size_t TGeoBranchArray::SizeOf(size_t)
@trydoc raw"""
    TGeoBranchArray!SizeOf(this::ByRef1{TGeoBranchArray}, maxlevel::Int64)::Int64


""" TGeoBranchArray!SizeOf(this::ByRef1{TGeoBranchArray}, maxlevel::Int64)

# Wrapper of size_t TGeoBranchArray::SizeOfInstance(size_t)
@trydoc raw"""
    TGeoBranchArray!SizeOfInstance(this::ByRef1{TGeoBranchArray}, maxlevel::Int64)::Int64


""" TGeoBranchArray!SizeOfInstance(this::ByRef1{TGeoBranchArray}, maxlevel::Int64)

# Wrapper of void TGeoBranchArray::Sort(Int_t, TGeoBranchArray **, Int_t *, Bool_t)
@trydoc raw"""
    TGeoBranchArray!Sort(this::ByRef1{TGeoBranchArray}, n::Int32, array::ByPtr1{TGeoBranchArray}, index::ByPtr2{Int32}, down::Bool)::Nothing
Sorting of an array of branch array pointers.

""" TGeoBranchArray!Sort(this::ByRef1{TGeoBranchArray}, n::Int32, array::ByPtr1{TGeoBranchArray}, index::ByPtr2{Int32}, down::Bool)

# Wrapper of void TGeoNode::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGeoNode}, b::ByPtr1{TBrowser})::Nothing
How-to-browse for a node.

""" Browse(this::ByRef1{TGeoNode}, b::ByPtr1{TBrowser})

# Wrapper of void TGeoNode::cd()
@trydoc raw"""
    cd(this::ByConstRef1{TGeoNode})::Nothing


""" cd(this::ByConstRef1{TGeoNode})

# Wrapper of void TGeoNode::CheckOverlaps(Double_t, Option_t *)
@trydoc raw"""
    CheckOverlaps(this::ByRef1{TGeoNode}, ovlp::Float64, option::ByCopy{String})::Nothing
Check overlaps bigger than OVLP hierarchically, starting with this node.

""" CheckOverlaps(this::ByRef1{TGeoNode}, ovlp::Float64, option::ByCopy{String})

# Wrapper of void TGeoNode::CheckShapes()
@trydoc raw"""
    CheckShapes(this::ByRef1{TGeoNode})::Nothing
check for wrong parameters in shapes

""" CheckShapes(this::ByRef1{TGeoNode})

# Wrapper of Int_t TGeoNode::CountDaughters(Bool_t)
@trydoc raw"""
    CountDaughters(this::ByRef1{TGeoNode}, unique_volumes::Bool)::Int32
Returns the number of daughters.
Nodes pointing to same volume counted once if unique_volumes is set.
""" CountDaughters(this::ByRef1{TGeoNode}, unique_volumes::Bool)

# Wrapper of Int_t TGeoNode::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoNode}, px::Int32, py::Int32)::Int32
compute the closest distance of approach from point px,py to this node

""" DistancetoPrimitive(this::ByRef1{TGeoNode}, px::Int32, py::Int32)

# Wrapper of void TGeoNode::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoNode}, option::ByCopy{String})::Nothing
draw current node according to option

""" Draw(this::ByRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoNode::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TGeoNode}, option::ByCopy{String})::Nothing
draw only this node independently of its vis options

""" DrawOnly(this::ByRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoNode::DrawOverlaps()
@trydoc raw"""
    DrawOverlaps(this::ByRef1{TGeoNode})::Nothing
Method drawing the overlap candidates with this node.

""" DrawOverlaps(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoNode}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this volume.

""" ExecuteEvent(this::ByRef1{TGeoNode}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TGeoNode::FillIdArray(Int_t &, Int_t &, Int_t *)
@trydoc raw"""
    FillIdArray(this::ByConstRef1{TGeoNode}, ifree::ByRef2{Int32}, nodeid::ByRef2{Int32}, array::ByPtr2{Int32})::Nothing
Fill array with node id. Recursive on node branch.

""" FillIdArray(this::ByConstRef1{TGeoNode}, ifree::ByRef2{Int32}, nodeid::ByRef2{Int32}, array::ByPtr2{Int32})

# Wrapper of Int_t TGeoNode::FindNode(const TGeoNode *, Int_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoNode}, node::ByConstPtr1{TGeoNode}, level::Int32)::Int32
Search for a node within the branch of this one.

""" FindNode(this::ByRef1{TGeoNode}, node::ByConstPtr1{TGeoNode}, level::Int32)

# Wrapper of Int_t TGeoNode::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoNode})::Int32


""" GetByteCount(this::ByConstRef1{TGeoNode})

# Wrapper of Int_t TGeoNode::GetColour()
@trydoc raw"""
    GetColour(this::ByConstRef1{TGeoNode})::Int32


""" GetColour(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoNode * TGeoNode::GetDaughter(Int_t)
@trydoc raw"""
    GetDaughter(this::ByConstRef1{TGeoNode}, ind::Int32)::CxxPtr1{TGeoNode}


""" GetDaughter(this::ByConstRef1{TGeoNode}, ind::Int32)

# Wrapper of TGeoPatternFinder * TGeoNode::GetFinder()
@trydoc raw"""
    GetFinder(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoPatternFinder}


""" GetFinder(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoExtension * TGeoNode::GetFWExtension()
@trydoc raw"""
    GetFWExtension(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoExtension}


""" GetFWExtension(this::ByConstRef1{TGeoNode})

# Wrapper of Int_t TGeoNode::GetIndex()
@trydoc raw"""
    GetIndex(this::ByConstRef1{TGeoNode})::Int32


""" GetIndex(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoMatrix * TGeoNode::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoMatrix}


""" GetMatrix(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoMedium * TGeoNode::GetMedium()
@trydoc raw"""
    GetMedium(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoMedium}


""" GetMedium(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoVolume * TGeoNode::GetMotherVolume()
@trydoc raw"""
    GetMotherVolume(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoVolume}


""" GetMotherVolume(this::ByConstRef1{TGeoNode})

# Wrapper of Int_t TGeoNode::GetNdaughters()
@trydoc raw"""
    GetNdaughters(this::ByConstRef1{TGeoNode})::Int32


""" GetNdaughters(this::ByConstRef1{TGeoNode})

# Wrapper of TObjArray * TGeoNode::GetNodes()
@trydoc raw"""
    GetNodes(this::ByConstRef1{TGeoNode})::CxxPtr1{TObjArray}


""" GetNodes(this::ByConstRef1{TGeoNode})

# Wrapper of Int_t TGeoNode::GetNumber()
@trydoc raw"""
    GetNumber(this::ByConstRef1{TGeoNode})::Int32


""" GetNumber(this::ByConstRef1{TGeoNode})

# Wrapper of char * TGeoNode::GetObjectInfo(Int_t, Int_t)
@trydoc raw"""
    GetObjectInfo(this::ByConstRef1{TGeoNode}, px::Int32, py::Int32)::ByCopy{Union{String, Vector{CxxChar}}}
Get node info for the browser.

""" GetObjectInfo(this::ByConstRef1{TGeoNode}, px::Int32, py::Int32)

# Wrapper of Int_t TGeoNode::GetOptimalVoxels()
@trydoc raw"""
    GetOptimalVoxels(this::ByConstRef1{TGeoNode})::Int32


""" GetOptimalVoxels(this::ByConstRef1{TGeoNode})

# Wrapper of Int_t * TGeoNode::GetOverlaps(Int_t &)
@trydoc raw"""
    GetOverlaps(this::ByConstRef1{TGeoNode}, novlp::ByRef2{Int32})::CxxPtr2{Int32}


""" GetOverlaps(this::ByConstRef1{TGeoNode}, novlp::ByRef2{Int32})

# Wrapper of TGeoExtension * TGeoNode::GetUserExtension()
@trydoc raw"""
    GetUserExtension(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoExtension}


""" GetUserExtension(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoVolume * TGeoNode::GetVolume()
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoVolume}


""" GetVolume(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoExtension * TGeoNode::GrabFWExtension()
@trydoc raw"""
    GrabFWExtension(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoExtension}
Get a copy of the framework extension pointer.
The user must call Release() on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new())
""" GrabFWExtension(this::ByConstRef1{TGeoNode})

# Wrapper of TGeoExtension * TGeoNode::GrabUserExtension()
@trydoc raw"""
    GrabUserExtension(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoExtension}
Get a copy of the user extension pointer.
The user must call Release() on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new())
""" GrabUserExtension(this::ByConstRef1{TGeoNode})

# Wrapper of void TGeoNode::InspectNode()
@trydoc raw"""
    InspectNode(this::ByConstRef1{TGeoNode})::Nothing
Inspect this node.

""" InspectNode(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsCloned()
@trydoc raw"""
    IsCloned(this::ByConstRef1{TGeoNode})::Bool


""" IsCloned(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TGeoNode})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsOffset()
@trydoc raw"""
    IsOffset(this::ByConstRef1{TGeoNode})::Bool


""" IsOffset(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsOnScreen()
@trydoc raw"""
    IsOnScreen(this::ByConstRef1{TGeoNode})::Bool
check if this node is drawn. Assumes that this node is current

""" IsOnScreen(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsOverlapping()
@trydoc raw"""
    IsOverlapping(this::ByConstRef1{TGeoNode})::Bool


""" IsOverlapping(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsVirtual()
@trydoc raw"""
    IsVirtual(this::ByConstRef1{TGeoNode})::Bool


""" IsVirtual(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsVisDaughters()
@trydoc raw"""
    IsVisDaughters(this::ByConstRef1{TGeoNode})::Bool


""" IsVisDaughters(this::ByConstRef1{TGeoNode})

# Wrapper of Bool_t TGeoNode::IsVisible()
@trydoc raw"""
    IsVisible(this::ByConstRef1{TGeoNode})::Bool


""" IsVisible(this::ByConstRef1{TGeoNode})

# Wrapper of void TGeoNode::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoNode}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Convert the point coordinates from local_ reference system to mother reference.

""" LocalToMaster(this::ByConstRef1{TGeoNode}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNode::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoNode}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Convert a vector from local_ reference system to mother reference.

""" LocalToMasterVect(this::ByConstRef1{TGeoNode}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNode::ls(Option_t *)
@trydoc raw"""
    ls(this::ByConstRef1{TGeoNode}, option::ByCopy{String})::Nothing
Print the path (A/B/C/...) to this node on stdout.

""" ls(this::ByConstRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of TGeoNode * TGeoNode::MakeCopyNode()
@trydoc raw"""
    MakeCopyNode(this::ByConstRef1{TGeoNode})::CxxPtr1{TGeoNode}


""" MakeCopyNode(this::ByConstRef1{TGeoNode})

# Wrapper of void TGeoNode::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoNode}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
Convert the point coordinates from mother reference to local_ reference system.

""" MasterToLocal(this::ByConstRef1{TGeoNode}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNode::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoNode}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
Convert a vector from mother reference to local_ reference system.

""" MasterToLocalVect(this::ByConstRef1{TGeoNode}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of Bool_t TGeoNode::MayOverlap(Int_t)
@trydoc raw"""
    MayOverlap(this::ByConstRef1{TGeoNode}, iother::Int32)::Bool
Check the overlab between the bounding box of the node overlaps with the one the brother with index IOTHER.

""" MayOverlap(this::ByConstRef1{TGeoNode}, iother::Int32)

# Wrapper of void TGeoNode::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoNode}, option::ByCopy{String})::Nothing
Paint this node and its content according to visualization settings.

""" Paint(this::ByRef1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoNode::PrintCandidates()
@trydoc raw"""
    PrintCandidates(this::ByConstRef1{TGeoNode})::Nothing
print daughters candidates for containing current point

""" PrintCandidates(this::ByConstRef1{TGeoNode})

# Wrapper of void TGeoNode::PrintOverlaps()
@trydoc raw"""
    PrintOverlaps(this::ByConstRef1{TGeoNode})::Nothing
print possible overlapping nodes

""" PrintOverlaps(this::ByConstRef1{TGeoNode})

# Wrapper of Double_t TGeoNode::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoNode}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape

""" Safety(this::ByConstRef1{TGeoNode}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoNode::SetAllInvisible()
@trydoc raw"""
    SetAllInvisible(this::ByRef1{TGeoNode})::Nothing


""" SetAllInvisible(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::SetCloned(Bool_t)
@trydoc raw"""
    SetCloned(this::ByRef1{TGeoNode}, flag::Bool)::Nothing


""" SetCloned(this::ByRef1{TGeoNode}, flag::Bool)

# Wrapper of void TGeoNode::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoNode}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoNode}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNode::SetFWExtension(TGeoExtension *)
@trydoc raw"""
    SetFWExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})::Nothing
Connect framework defined extension to the node.
The node "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for the use by TGeo and the users should NOT connect extensions using this method
""" SetFWExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoNode::SetInvisible()
@trydoc raw"""
    SetInvisible(this::ByRef1{TGeoNode})::Nothing


""" SetInvisible(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::SetMotherVolume(TGeoVolume *)
@trydoc raw"""
    SetMotherVolume(this::ByRef1{TGeoNode}, mother::ByPtr1{TGeoVolume})::Nothing


""" SetMotherVolume(this::ByRef1{TGeoNode}, mother::ByPtr1{TGeoVolume})

# Wrapper of void TGeoNode::SetNumber(Int_t)
@trydoc raw"""
    SetNumber(this::ByRef1{TGeoNode}, number::Int32)::Nothing


""" SetNumber(this::ByRef1{TGeoNode}, number::Int32)

# Wrapper of void TGeoNode::SetOverlapping(Bool_t)
@trydoc raw"""
    SetOverlapping(this::ByRef1{TGeoNode}, flag::Bool)::Nothing


""" SetOverlapping(this::ByRef1{TGeoNode}, flag::Bool)

# Wrapper of void TGeoNode::SetOverlaps(Int_t *, Int_t)
@trydoc raw"""
    SetOverlaps(this::ByRef1{TGeoNode}, ovlp::ByPtr2{Int32}, novlp::Int32)::Nothing
set the list of overlaps for this node (ovlp must be created with operator new)

""" SetOverlaps(this::ByRef1{TGeoNode}, ovlp::ByPtr2{Int32}, novlp::Int32)

# Wrapper of void TGeoNode::SetUserExtension(TGeoExtension *)
@trydoc raw"""
    SetUserExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})::Nothing
Connect user-defined extension to the node.
The node "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for user extensions and is guaranteed not to be used by TGeo
""" SetUserExtension(this::ByRef1{TGeoNode}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoNode::SetVirtual()
@trydoc raw"""
    SetVirtual(this::ByRef1{TGeoNode})::Nothing


""" SetVirtual(this::ByRef1{TGeoNode})

# Wrapper of void TGeoNode::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoNode}, vis::Bool)::Nothing
Set visibility of the node (obsolete).

""" SetVisibility(this::ByRef1{TGeoNode}, vis::Bool)

# Wrapper of void TGeoNode::SetVolume(TGeoVolume *)
@trydoc raw"""
    SetVolume(this::ByRef1{TGeoNode}, volume::ByPtr1{TGeoVolume})::Nothing


""" SetVolume(this::ByRef1{TGeoNode}, volume::ByPtr1{TGeoVolume})

# Wrapper of void TGeoNode::VisibleDaughters(Bool_t)
@trydoc raw"""
    VisibleDaughters(this::ByRef1{TGeoNode}, vis::Bool)::Nothing
Set visibility of the daughters (obsolete).

""" VisibleDaughters(this::ByRef1{TGeoNode}, vis::Bool)

# Wrapper of void TGeoNavigator::BuildCache(Bool_t, Bool_t)
@trydoc raw"""
    BuildCache(this::ByRef1{TGeoNavigator}, dummy::Bool, nodeid::Bool)::Nothing
Builds the cache for physical nodes and global_ matrices.

""" BuildCache(this::ByRef1{TGeoNavigator}, dummy::Bool, nodeid::Bool)

# Wrapper of Bool_t TGeoNavigator::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TGeoNavigator}, path::ByCopy{String})::Bool
Browse the tree of nodes starting from top node according to pathname.
Changes the path accordingly. The path is changed to point to the top node in case of failure.
""" cd(this::ByRef1{TGeoNavigator}, path::ByCopy{String})

# Wrapper of void TGeoNavigator::CdDown(Int_t)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNavigator}, index::Int32)::Nothing
Make a daughter of current node current.
Can be called only with a valid daughter index (no check). Updates cache accordingly.
""" CdDown(this::ByRef1{TGeoNavigator}, index::Int32)

# Wrapper of void TGeoNavigator::CdDown(TGeoNode *)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNavigator}, node::ByPtr1{TGeoNode})::Nothing
Make a daughter of current node current.
Can be called only with a valid daughter node (no check). Updates cache accordingly.
""" CdDown(this::ByRef1{TGeoNavigator}, node::ByPtr1{TGeoNode})

# Wrapper of void TGeoNavigator::CdNext()
@trydoc raw"""
    CdNext(this::ByRef1{TGeoNavigator})::Nothing
Do a cd to the node found next by FindNextBoundary.

""" CdNext(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::CdNode(Int_t)
@trydoc raw"""
    CdNode(this::ByRef1{TGeoNavigator}, nodeid::Int32)::Nothing
Change current path to point to the node having this id.
Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)
""" CdNode(this::ByRef1{TGeoNavigator}, nodeid::Int32)

# Wrapper of void TGeoNavigator::CdTop()
@trydoc raw"""
    CdTop(this::ByRef1{TGeoNavigator})::Nothing
Make top level node the current node.
Updates the cache accordingly. Determine the overlapping state of current node.
""" CdTop(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::CdUp()
@trydoc raw"""
    CdUp(this::ByRef1{TGeoNavigator})::Nothing
Go one level up in geometry.
Updates cache accordingly. Determine the overlapping state of current node.
""" CdUp(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::CheckPath(const char *)
@trydoc raw"""
    CheckPath(this::ByConstRef1{TGeoNavigator}, path::ByCopy{String})::Bool
Check if a geometry path is valid without changing the state of the navigator.

""" CheckPath(this::ByConstRef1{TGeoNavigator}, path::ByCopy{String})

# Wrapper of TGeoNode * TGeoNavigator::CrossBoundaryAndLocate(Bool_t, TGeoNode *)
@trydoc raw"""
    CrossBoundaryAndLocate(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode.

""" CrossBoundaryAndLocate(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByPtr1{TGeoNode})

# Wrapper of void TGeoNavigator::DoBackupState()
@trydoc raw"""
    DoBackupState(this::ByRef1{TGeoNavigator})::Nothing
Backup the current state without affecting the cache stack.

""" DoBackupState(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::DoRestoreState()
@trydoc raw"""
    DoRestoreState(this::ByRef1{TGeoNavigator})::Nothing
Restore a backed-up state without affecting the cache stack.

""" DoRestoreState(this::ByRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::FindNextBoundary(Double_t, const char *, Bool_t)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoNavigator}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)::CxxPtr1{TGeoNode}
Find distance to next boundary and store it in fStep.
Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : "Is STEPMAX a safe step ?" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.

Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly [TGeoManager!Safety()](@ref) if they want this computed for the current point.
""" FindNextBoundary(this::ByRef1{TGeoNavigator}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNextBoundaryAndStep(Double_t, Bool_t)
@trydoc raw"""
    FindNextBoundaryAndStep(this::ByRef1{TGeoNavigator}, stepmax::Float64, compsafe::Bool)::CxxPtr1{TGeoNode}
Compute distance to next boundary within STEPMAX.
If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node.
""" FindNextBoundaryAndStep(this::ByRef1{TGeoNavigator}, stepmax::Float64, compsafe::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNextDaughterBoundary(Double_t *, Double_t *, Int_t &, Bool_t)
@trydoc raw"""
    FindNextDaughterBoundary(this::ByRef1{TGeoNavigator}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)::CxxPtr1{TGeoNode}
Computes as fStep the distance to next daughter of the current volume.
The point and direction must be converted in the coordinate system of the current volume. The proposed step limit is fStep.
""" FindNextDaughterBoundary(this::ByRef1{TGeoNavigator}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNode(Bool_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoNavigator}, safe_start::Bool)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoNavigator}, safe_start::Bool)

# Wrapper of TGeoNode * TGeoNavigator::FindNode(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of Double_t * TGeoNavigator::FindNormal(Bool_t)
@trydoc raw"""
    FindNormal(this::ByRef1{TGeoNavigator}, forward::Bool)::CxxPtr2{Float64}
Computes normal vector to the next surface that will be or was already crossed when propagating on a straight line from a given point/direction.
Returns the normal vector cosines in the MASTER coordinate system. The dot product of the normal and the current direction is positive defined.
""" FindNormal(this::ByRef1{TGeoNavigator}, forward::Bool)

# Wrapper of Double_t * TGeoNavigator::FindNormalFast()
@trydoc raw"""
    FindNormalFast(this::ByRef1{TGeoNavigator})::CxxPtr2{Float64}
Computes fast normal to next crossed boundary, assuming that the current point is close enough to the boundary.
Works only after calling FindNextBoundary.
""" FindNormalFast(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::GetBranchNames(Int_t *)
@trydoc raw"""
    GetBranchNames(this::ByConstRef1{TGeoNavigator}, names::ByPtr2{Int32})::Nothing
Fill volume names of current branch into an array.

""" GetBranchNames(this::ByConstRef1{TGeoNavigator}, names::ByPtr2{Int32})

# Wrapper of void TGeoNavigator::GetBranchNumbers(Int_t *, Int_t *)
@trydoc raw"""
    GetBranchNumbers(this::ByConstRef1{TGeoNavigator}, copyNumbers::ByPtr2{Int32}, volumeNumbers::ByPtr2{Int32})::Nothing
Fill node copy numbers of current branch into an array.

""" GetBranchNumbers(this::ByConstRef1{TGeoNavigator}, copyNumbers::ByPtr2{Int32}, volumeNumbers::ByPtr2{Int32})

# Wrapper of void TGeoNavigator::GetBranchOnlys(Int_t *)
@trydoc raw"""
    GetBranchOnlys(this::ByConstRef1{TGeoNavigator}, isonly::ByPtr2{Int32})::Nothing
Fill node copy numbers of current branch into an array.

""" GetBranchOnlys(this::ByConstRef1{TGeoNavigator}, isonly::ByPtr2{Int32})

# Wrapper of TGeoNodeCache * TGeoNavigator::GetCache()
@trydoc raw"""
    GetCache(this::ByConstRef1{TGeoNavigator})::CxxPtr1{TGeoNodeCache}


""" GetCache(this::ByConstRef1{TGeoNavigator})

# Wrapper of const Double_t * TGeoNavigator::GetCldir()
@trydoc raw"""
    GetCldir(this::ByConstRef1{TGeoNavigator})::ConstCxxPtr2{Float64}


""" GetCldir(this::ByConstRef1{TGeoNavigator})

# Wrapper of const Double_t * TGeoNavigator::GetCldirChecked()
@trydoc raw"""
    GetCldirChecked(this::ByConstRef1{TGeoNavigator})::ConstCxxPtr2{Float64}


""" GetCldirChecked(this::ByConstRef1{TGeoNavigator})

# Wrapper of const Double_t * TGeoNavigator::GetCurrentDirection()
@trydoc raw"""
    GetCurrentDirection(this::ByConstRef1{TGeoNavigator})::ConstCxxPtr2{Float64}


""" GetCurrentDirection(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoHMatrix * TGeoNavigator::GetCurrentMatrix()
@trydoc raw"""
    GetCurrentMatrix(this::ByConstRef1{TGeoNavigator})::CxxPtr1{TGeoHMatrix}


""" GetCurrentMatrix(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::GetCurrentNode()
@trydoc raw"""
    GetCurrentNode(this::ByConstRef1{TGeoNavigator})::CxxPtr1{TGeoNode}


""" GetCurrentNode(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetCurrentNodeId()
@trydoc raw"""
    GetCurrentNodeId(this::ByConstRef1{TGeoNavigator})::Int32


""" GetCurrentNodeId(this::ByConstRef1{TGeoNavigator})

# Wrapper of const Double_t * TGeoNavigator::GetCurrentPoint()
@trydoc raw"""
    GetCurrentPoint(this::ByConstRef1{TGeoNavigator})::ConstCxxPtr2{Float64}


""" GetCurrentPoint(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoVolume * TGeoNavigator::GetCurrentVolume()
@trydoc raw"""
    GetCurrentVolume(this::ByConstRef1{TGeoNavigator})::CxxPtr1{TGeoVolume}


""" GetCurrentVolume(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoHMatrix * TGeoNavigator::GetDivMatrix()
@trydoc raw"""
    GetDivMatrix(this::ByConstRef1{TGeoNavigator})::CxxPtr1{TGeoHMatrix}


""" GetDivMatrix(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoHMatrix * TGeoNavigator::GetHMatrix()
@trydoc raw"""
    GetHMatrix(this::ByRef1{TGeoNavigator})::CxxPtr1{TGeoHMatrix}
Return stored current matrix (global_ matrix of the next touched node).

""" GetHMatrix(this::ByRef1{TGeoNavigator})

# Wrapper of const Double_t * TGeoNavigator::GetLastPoint()
@trydoc raw"""
    GetLastPoint(this::ByConstRef1{TGeoNavigator})::ConstCxxPtr2{Float64}


""" GetLastPoint(this::ByConstRef1{TGeoNavigator})

# Wrapper of Double_t TGeoNavigator::GetLastSafety()
@trydoc raw"""
    GetLastSafety(this::ByConstRef1{TGeoNavigator})::Float64


""" GetLastSafety(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoNavigator})::Int32


""" GetLevel(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::GetMother(Int_t)
@trydoc raw"""
    GetMother(this::ByConstRef1{TGeoNavigator}, up::Int32)::CxxPtr1{TGeoNode}


""" GetMother(this::ByConstRef1{TGeoNavigator}, up::Int32)

# Wrapper of TGeoHMatrix * TGeoNavigator::GetMotherMatrix(Int_t)
@trydoc raw"""
    GetMotherMatrix(this::ByConstRef1{TGeoNavigator}, up::Int32)::CxxPtr1{TGeoHMatrix}


""" GetMotherMatrix(this::ByConstRef1{TGeoNavigator}, up::Int32)

# Wrapper of Int_t TGeoNavigator::GetNextDaughterIndex()
@trydoc raw"""
    GetNextDaughterIndex(this::ByConstRef1{TGeoNavigator})::Int32


""" GetNextDaughterIndex(this::ByConstRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::GetNextNode()
@trydoc raw"""
    GetNextNode(this::ByConstRef1{TGeoNavigator})::CxxPtr1{TGeoNode}


""" GetNextNode(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetNmany()
@trydoc raw"""
    GetNmany(this::ByConstRef1{TGeoNavigator})::Int32


""" GetNmany(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetNodeId()
@trydoc raw"""
    GetNodeId(this::ByConstRef1{TGeoNavigator})::Int32


""" GetNodeId(this::ByConstRef1{TGeoNavigator})

# Wrapper of const Double_t * TGeoNavigator::GetNormal()
@trydoc raw"""
    GetNormal(this::ByConstRef1{TGeoNavigator})::ConstCxxPtr2{Float64}


""" GetNormal(this::ByConstRef1{TGeoNavigator})

# Wrapper of const char * TGeoNavigator::GetPath()
@trydoc raw"""
    GetPath(this::ByConstRef1{TGeoNavigator})::ByCopy{String}
Get path to the current node in the form /node0/node1/...

""" GetPath(this::ByConstRef1{TGeoNavigator})

# Wrapper of Double_t TGeoNavigator::GetSafeDistance()
@trydoc raw"""
    GetSafeDistance(this::ByConstRef1{TGeoNavigator})::Float64


""" GetSafeDistance(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetSafeLevel()
@trydoc raw"""
    GetSafeLevel(this::ByConstRef1{TGeoNavigator})::Int32
Go upwards the tree until a non-overlapping node.

""" GetSafeLevel(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetStackLevel()
@trydoc raw"""
    GetStackLevel(this::ByConstRef1{TGeoNavigator})::Int32


""" GetStackLevel(this::ByConstRef1{TGeoNavigator})

# Wrapper of Double_t TGeoNavigator::GetStep()
@trydoc raw"""
    GetStep(this::ByConstRef1{TGeoNavigator})::Float64


""" GetStep(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetThreadId()
@trydoc raw"""
    GetThreadId(this::ByConstRef1{TGeoNavigator})::Int32


""" GetThreadId(this::ByConstRef1{TGeoNavigator})

# Wrapper of Int_t TGeoNavigator::GetVirtualLevel()
@trydoc raw"""
    GetVirtualLevel(this::ByRef1{TGeoNavigator})::Int32
Find level of virtuality of current overlapping node (number of levels up having the same tracking media.

""" GetVirtualLevel(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::GotoSafeLevel()
@trydoc raw"""
    GotoSafeLevel(this::ByRef1{TGeoNavigator})::Bool
Go upwards the tree until a non-overlapping node.

""" GotoSafeLevel(this::ByRef1{TGeoNavigator})

# Wrapper of TGeoNode * TGeoNavigator::InitTrack(const Double_t *, const Double_t *)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of TGeoNode * TGeoNavigator::InitTrack(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of void TGeoNavigator::InspectState()
@trydoc raw"""
    InspectState(this::ByConstRef1{TGeoNavigator})::Nothing
Inspects path and all flags for the current state.

""" InspectState(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsCheckingOverlaps()
@trydoc raw"""
    IsCheckingOverlaps(this::ByConstRef1{TGeoNavigator})::Bool


""" IsCheckingOverlaps(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsCurrentOverlapping()
@trydoc raw"""
    IsCurrentOverlapping(this::ByConstRef1{TGeoNavigator})::Bool


""" IsCurrentOverlapping(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsEntering()
@trydoc raw"""
    IsEntering(this::ByConstRef1{TGeoNavigator})::Bool


""" IsEntering(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsExiting()
@trydoc raw"""
    IsExiting(this::ByConstRef1{TGeoNavigator})::Bool


""" IsExiting(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsNullStep()
@trydoc raw"""
    IsNullStep(this::ByConstRef1{TGeoNavigator})::Bool


""" IsNullStep(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsOnBoundary()
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoNavigator})::Bool


""" IsOnBoundary(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsOutside()
@trydoc raw"""
    IsOutside(this::ByConstRef1{TGeoNavigator})::Bool


""" IsOutside(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsSafeStep(Double_t, Double_t &)
@trydoc raw"""
    IsSafeStep(this::ByConstRef1{TGeoNavigator}, proposed::Float64, newsafety::ByRef2{Float64})::Bool
In case a previous safety value was computed, check if the safety region is still safe for the current point and proposed step.
Return value changed only if proposed distance is safe.
""" IsSafeStep(this::ByConstRef1{TGeoNavigator}, proposed::Float64, newsafety::ByRef2{Float64})

# Wrapper of Bool_t TGeoNavigator::IsSameLocation()
@trydoc raw"""
    IsSameLocation(this::ByConstRef1{TGeoNavigator})::Bool


""" IsSameLocation(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsSameLocation(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    IsSameLocation(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, change::Bool)::Bool
Checks if point (x,y,z) is still in the current node.
check if this is an overlapping node
""" IsSameLocation(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64, change::Bool)

# Wrapper of Bool_t TGeoNavigator::IsSamePoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    IsSamePoint(this::ByConstRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::Bool
Check if a new point with given coordinates is the same as the last located one.

""" IsSamePoint(this::ByConstRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of Bool_t TGeoNavigator::IsStartSafe()
@trydoc raw"""
    IsStartSafe(this::ByConstRef1{TGeoNavigator})::Bool


""" IsStartSafe(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsStepEntering()
@trydoc raw"""
    IsStepEntering(this::ByConstRef1{TGeoNavigator})::Bool


""" IsStepEntering(this::ByConstRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::IsStepExiting()
@trydoc raw"""
    IsStepExiting(this::ByConstRef1{TGeoNavigator})::Bool


""" IsStepExiting(this::ByConstRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoNavigator}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing


""" LocalToMaster(this::ByConstRef1{TGeoNavigator}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoNavigator}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing


""" LocalToMasterBomb(this::ByConstRef1{TGeoNavigator}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoNavigator}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing


""" LocalToMasterVect(this::ByConstRef1{TGeoNavigator}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing


""" MasterToLocal(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing


""" MasterToLocalBomb(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing


""" MasterToLocalVect(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::MasterToTop(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToTop(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, top::ByPtr2{Float64})::Nothing
Convert coordinates from master volume frame to top.

""" MasterToTop(this::ByConstRef1{TGeoNavigator}, master::ByConstPtr2{Float64}, top::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::PopDummy(Int_t)
@trydoc raw"""
    PopDummy(this::ByRef1{TGeoNavigator}, ipop::Int32)::Nothing


""" PopDummy(this::ByRef1{TGeoNavigator}, ipop::Int32)

# Wrapper of Bool_t TGeoNavigator::PopPath()
@trydoc raw"""
    PopPath(this::ByRef1{TGeoNavigator})::Bool


""" PopPath(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::PopPath(Int_t)
@trydoc raw"""
    PopPath(this::ByRef1{TGeoNavigator}, index::Int32)::Bool


""" PopPath(this::ByRef1{TGeoNavigator}, index::Int32)

# Wrapper of Bool_t TGeoNavigator::PopPoint()
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoNavigator})::Bool


""" PopPoint(this::ByRef1{TGeoNavigator})

# Wrapper of Bool_t TGeoNavigator::PopPoint(Int_t)
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoNavigator}, index::Int32)::Bool


""" PopPoint(this::ByRef1{TGeoNavigator}, index::Int32)

# Wrapper of Int_t TGeoNavigator::PushPath(Int_t)
@trydoc raw"""
    PushPath(this::ByRef1{TGeoNavigator}, startlevel::Int32)::Int32


""" PushPath(this::ByRef1{TGeoNavigator}, startlevel::Int32)

# Wrapper of Int_t TGeoNavigator::PushPoint(Int_t)
@trydoc raw"""
    PushPoint(this::ByRef1{TGeoNavigator}, startlevel::Int32)::Int32


""" PushPoint(this::ByRef1{TGeoNavigator}, startlevel::Int32)

# Wrapper of void TGeoNavigator::ResetAll()
@trydoc raw"""
    ResetAll(this::ByRef1{TGeoNavigator})::Nothing
Reset the navigator.

""" ResetAll(this::ByRef1{TGeoNavigator})

# Wrapper of void TGeoNavigator::ResetState()
@trydoc raw"""
    ResetState(this::ByRef1{TGeoNavigator})::Nothing
Reset current state flags.

""" ResetState(this::ByRef1{TGeoNavigator})

# Wrapper of Double_t TGeoNavigator::Safety(Bool_t)
@trydoc raw"""
    Safety(this::ByRef1{TGeoNavigator}, inside::Bool)::Float64
Compute safe distance from the current point.
This represent the distance from POINT to the closest boundary.
""" Safety(this::ByRef1{TGeoNavigator}, inside::Bool)

# Wrapper of TGeoNode * TGeoNavigator::SearchNode(Bool_t, const TGeoNode *)
@trydoc raw"""
    SearchNode(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Returns the deepest node containing fPoint, which must be set a priori.
Check if parallel world navigation is enabled
""" SearchNode(this::ByRef1{TGeoNavigator}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})

# Wrapper of void TGeoNavigator::SetCheckingOverlaps(Bool_t)
@trydoc raw"""
    SetCheckingOverlaps(this::ByRef1{TGeoNavigator}, flag::Bool)::Nothing


""" SetCheckingOverlaps(this::ByRef1{TGeoNavigator}, flag::Bool)

# Wrapper of void TGeoNavigator::SetCldirChecked(Double_t *)
@trydoc raw"""
    SetCldirChecked(this::ByRef1{TGeoNavigator}, dir::ByPtr2{Float64})::Nothing


""" SetCldirChecked(this::ByRef1{TGeoNavigator}, dir::ByPtr2{Float64})

# Wrapper of void TGeoNavigator::SetCurrentDirection(const Double_t *)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoNavigator}, dir::ByConstPtr2{Float64})::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoNavigator}, dir::ByConstPtr2{Float64})

# Wrapper of void TGeoNavigator::SetCurrentDirection(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoNavigator}, nx::Float64, ny::Float64, nz::Float64)::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoNavigator}, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of void TGeoNavigator::SetCurrentPoint(const Double_t *)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64})::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoNavigator}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoNavigator::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNavigator::SetLastPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetLastPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetLastPoint(this::ByRef1{TGeoNavigator}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNavigator::SetLastSafetyForPoint(Double_t, const Double_t *)
@trydoc raw"""
    SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, point::ByConstPtr2{Float64})::Nothing


""" SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, point::ByConstPtr2{Float64})

# Wrapper of void TGeoNavigator::SetLastSafetyForPoint(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, x::Float64, y::Float64, z::Float64)::Nothing


""" SetLastSafetyForPoint(this::ByRef1{TGeoNavigator}, safe::Float64, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoNavigator::SetOutside(Bool_t)
@trydoc raw"""
    SetOutside(this::ByRef1{TGeoNavigator}, flag::Bool)::Nothing


""" SetOutside(this::ByRef1{TGeoNavigator}, flag::Bool)

# Wrapper of void TGeoNavigator::SetStartSafe(Bool_t)
@trydoc raw"""
    SetStartSafe(this::ByRef1{TGeoNavigator}, flag::Bool)::Nothing


""" SetStartSafe(this::ByRef1{TGeoNavigator}, flag::Bool)

# Wrapper of void TGeoNavigator::SetStep(Double_t)
@trydoc raw"""
    SetStep(this::ByRef1{TGeoNavigator}, step::Float64)::Nothing


""" SetStep(this::ByRef1{TGeoNavigator}, step::Float64)

# Wrapper of TGeoNode * TGeoNavigator::Step(Bool_t, Bool_t)
@trydoc raw"""
    Step(this::ByRef1{TGeoNavigator}, is_geom::Bool, cross::Bool)::CxxPtr1{TGeoNode}
Make a rectiliniar step of length fStep from current point (fPoint) on current direction (fDirection).
If the step is imposed by geometry, is_geom flag must be true (default). The cross flag specifies if the boundary should be crossed in case of a geometry step (default true). Returns new node after step. Set also on boundary condition.
""" Step(this::ByRef1{TGeoNavigator}, is_geom::Bool, cross::Bool)

# Wrapper of void TGeoNavigator::TopToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    TopToMaster(this::ByConstRef1{TGeoNavigator}, top::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Convert coordinates from top volume frame to master.

""" TopToMaster(this::ByConstRef1{TGeoNavigator}, top::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of Int_t TGeoBuilder::AddMaterial(TGeoMaterial *)
@trydoc raw"""
    AddMaterial(this::ByRef1{TGeoBuilder}, material::ByPtr1{TGeoMaterial})::Int32
Add a material to the list. Returns index of the material in list.

""" AddMaterial(this::ByRef1{TGeoBuilder}, material::ByPtr1{TGeoMaterial})

# Wrapper of Int_t TGeoBuilder::AddShape(TGeoShape *)
@trydoc raw"""
    AddShape(this::ByRef1{TGeoBuilder}, shape::ByPtr1{TGeoShape})::Int32
Add a shape to the list. Returns index of the shape in list.

""" AddShape(this::ByRef1{TGeoBuilder}, shape::ByPtr1{TGeoShape})

# Wrapper of Int_t TGeoBuilder::AddTransformation(TGeoMatrix *)
@trydoc raw"""
    AddTransformation(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})::Int32
Add a matrix to the list. Returns index of the matrix in list.

""" AddTransformation(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})

# Wrapper of TGeoVolume * TGeoBuilder::Division(const char *, const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Division(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Create a new volume by dividing an existing one (GEANT3 like)
Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER) The behavior of the division operation can be triggered using OPTION (case insensitive):

- N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3)
- NX - divide range starting with START in NDIV cells (GSDVN2 in G3)
- S - divide all range with given STEP. NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3)
- SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3)
""" Division(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of TGeoVolume * TGeoBuilder::MakeArb8(const char *, TGeoMedium *, Double_t, Double_t *)
@trydoc raw"""
    MakeArb8(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})::CxxPtr1{TGeoVolume}
Make an [TGeoArb8](@ref) volume.

""" MakeArb8(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoBuilder::MakeBox(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeBox(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a box shape with given medium.

""" MakeBox(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeCone(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCone(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone shape with given medium.

""" MakeCone(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeCons(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCons(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone segment shape with given medium.

""" MakeCons(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeCtub(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCtub(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.

""" MakeCtub(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeEltu(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeEltu(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeEltu(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeGtra(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeGtra(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a twisted trapezoid shape with given medium.

""" MakeGtra(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeHype(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeHype(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeHype(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakePara(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakePara(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a parallelepiped shape with given medium.

""" MakePara(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeParaboloid(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeParaboloid(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeParaboloid(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakePcon(const char *, TGeoMedium *, Double_t, Double_t, Int_t)
@trydoc raw"""
    MakePcon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polycone shape with given medium.

""" MakePcon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)

# Wrapper of TGeoVolume * TGeoBuilder::MakePgon(const char *, TGeoMedium *, Double_t, Double_t, Int_t, Int_t)
@trydoc raw"""
    MakePgon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polygone shape with given medium.

""" MakePgon(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)

# Wrapper of TGeoVolume * TGeoBuilder::MakeSphere(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeSphere(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a sphere shape with given medium.

""" MakeSphere(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTorus(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTorus(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a torus shape with given medium.

""" MakeTorus(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTrap(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrap(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a trapezoid shape with given medium.

""" MakeTrap(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTrd1(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd1(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd1](@ref) shape with given medium.

""" MakeTrd1(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTrd2(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd2(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd2](@ref) shape with given medium.

""" MakeTrd2(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTube(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTube(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeTube(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoBuilder::MakeTubs(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTubs(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.

""" MakeTubs(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolumeAssembly * TGeoBuilder::MakeVolumeAssembly(const char *)
@trydoc raw"""
    MakeVolumeAssembly(this::ByRef1{TGeoBuilder}, name::ByCopy{String})::CxxPtr1{TGeoVolumeAssembly}
Make an assembly of volumes.

""" MakeVolumeAssembly(this::ByRef1{TGeoBuilder}, name::ByCopy{String})

# Wrapper of TGeoVolumeMulti * TGeoBuilder::MakeVolumeMulti(const char *, TGeoMedium *)
@trydoc raw"""
    MakeVolumeMulti(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})::CxxPtr1{TGeoVolumeMulti}
Make a [TGeoVolumeMulti](@ref) handling a list of volumes.

""" MakeVolumeMulti(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})

# Wrapper of TGeoVolume * TGeoBuilder::MakeXtru(const char *, TGeoMedium *, Int_t)
@trydoc raw"""
    MakeXtru(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)::CxxPtr1{TGeoVolume}
Make a TGeoXtru-shaped volume with nz planes.

""" MakeXtru(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)

# Wrapper of TGeoMaterial * TGeoBuilder::Material(const char *, Double_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Material(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)::CxxPtr1{TGeoMaterial}
Create material with given A, Z and density, having an unique id.

""" Material(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)

# Wrapper of void TGeoBuilder::Matrix(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Matrix(this::ByRef1{TGeoBuilder}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)::Nothing
Create rotation matrix named 'mat<index>'.
- index rotation matrix number
- theta1 polar angle for axis X
- phi1 azimuthal angle for axis X
- theta2 polar angle for axis Y
- phi2 azimuthal angle for axis Y
- theta3 polar angle for axis Z
- phi3 azimuthal angle for axis Z
""" Matrix(this::ByRef1{TGeoBuilder}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)

# Wrapper of TGeoMedium * TGeoBuilder::Medium(const char *, Int_t, Int_t, Int_t, Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Medium(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)::CxxPtr1{TGeoMedium}
Create tracking medium.
- numed tracking medium number assigned
- name tracking medium name
- nmat material number
- isvol sensitive volume flag
- ifield magnetic field
- fieldm max. field value (kilogauss)
- tmaxfd max. angle due to field (deg/step)
- stemax max. step allowed
- deemax max. fraction of energy lost in a step
- epsil tracking precision (cm)
- stmin min. step due to continuous processes (cm)
- ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;
- ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking performed with g3helix; ifield = 3 if tracking performed with g3helx3.
""" Medium(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)

# Wrapper of TGeoMaterial * TGeoBuilder::Mixture(const char *, Double_t *, Double_t *, Double_t, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)

# Wrapper of TGeoMaterial * TGeoBuilder::Mixture(const char *, Float_t *, Float_t *, Double_t, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)

# Wrapper of void TGeoBuilder::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Double_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of void TGeoBuilder::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Float_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of void TGeoBuilder::RegisterMatrix(TGeoMatrix *)
@trydoc raw"""
    RegisterMatrix(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})::Nothing
Register a matrix to the list of matrices.
It will be cleaned-up at the destruction [TGeoManager](@ref).
""" RegisterMatrix(this::ByRef1{TGeoBuilder}, matrix::ByPtr1{TGeoMatrix})

# Wrapper of TGeoVolume * TGeoBuilder::Volume(const char *, const char *, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of TGeoVolume * TGeoBuilder::Volume(const char *, const char *, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoBuilder}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of TGeoBuilder * TGeoBuilder::Instance(TGeoManager *)
@trydoc raw"""
    TGeoBuilder!Instance(this::ByRef1{TGeoBuilder}, geom::ByPtr1{TGeoManager})::CxxPtr1{TGeoBuilder}
Return pointer to singleton.

""" TGeoBuilder!Instance(this::ByRef1{TGeoBuilder}, geom::ByPtr1{TGeoManager})

# Wrapper of void TGeoManager::AddBorderSurface(TGeoBorderSurface *)
@trydoc raw"""
    AddBorderSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoBorderSurface})::Nothing
Add border surface;.

""" AddBorderSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoBorderSurface})

# Wrapper of void TGeoManager::AddGDMLMatrix(TGDMLMatrix *)
@trydoc raw"""
    AddGDMLMatrix(this::ByRef1{TGeoManager}, mat::ByPtr1{TGDMLMatrix})::Nothing
Add GDML matrix;.

""" AddGDMLMatrix(this::ByRef1{TGeoManager}, mat::ByPtr1{TGDMLMatrix})

# Wrapper of Int_t TGeoManager::AddMaterial(const TGeoMaterial *)
@trydoc raw"""
    AddMaterial(this::ByRef1{TGeoManager}, material::ByConstPtr1{TGeoMaterial})::Int32
Add a material to the list. Returns index of the material in list.

""" AddMaterial(this::ByRef1{TGeoManager}, material::ByConstPtr1{TGeoMaterial})

# Wrapper of TGeoNavigator * TGeoManager::AddNavigator()
@trydoc raw"""
    AddNavigator(this::ByRef1{TGeoManager})::CxxPtr1{TGeoNavigator}
Add a navigator in the list of navigators.
If it is the first one make it current navigator.
""" AddNavigator(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::AddOpticalSurface(TGeoOpticalSurface *)
@trydoc raw"""
    AddOpticalSurface(this::ByRef1{TGeoManager}, optsurf::ByPtr1{TGeoOpticalSurface})::Nothing
Add optical surface;.

""" AddOpticalSurface(this::ByRef1{TGeoManager}, optsurf::ByPtr1{TGeoOpticalSurface})

# Wrapper of Int_t TGeoManager::AddOverlap(const TNamed *)
@trydoc raw"""
    AddOverlap(this::ByRef1{TGeoManager}, ovlp::ByConstPtr1{TNamed})::Int32
Add an illegal overlap/extrusion to the list.

""" AddOverlap(this::ByRef1{TGeoManager}, ovlp::ByConstPtr1{TNamed})

# Wrapper of Bool_t TGeoManager::AddProperty(const char *, Double_t)
@trydoc raw"""
    AddProperty(this::ByRef1{TGeoManager}, property::ByCopy{String}, value::Float64)::Bool
Add a user-defined property. Returns true if added, false if existing.

""" AddProperty(this::ByRef1{TGeoManager}, property::ByCopy{String}, value::Float64)

# Wrapper of Int_t TGeoManager::AddRegion(TGeoRegion *)
@trydoc raw"""
    AddRegion(this::ByRef1{TGeoManager}, region::ByPtr1{TGeoRegion})::Int32
Add a new region of volumes.

""" AddRegion(this::ByRef1{TGeoManager}, region::ByPtr1{TGeoRegion})

# Wrapper of Int_t TGeoManager::AddShape(const TGeoShape *)
@trydoc raw"""
    AddShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})::Int32
Add a shape to the list. Returns index of the shape in list.

""" AddShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})

# Wrapper of void TGeoManager::AddSkinSurface(TGeoSkinSurface *)
@trydoc raw"""
    AddSkinSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoSkinSurface})::Nothing
Add skin surface;.

""" AddSkinSurface(this::ByRef1{TGeoManager}, surf::ByPtr1{TGeoSkinSurface})

# Wrapper of Int_t TGeoManager::AddTrack(Int_t, Int_t, TObject *)
@trydoc raw"""
    AddTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::Int32
Add a track to the list of tracks.
Use this for primaries only. For secondaries, add them to the parent track. The method create objects that are registered to the analysis manager but have to be cleaned-up by the user via [ClearTracks()](@ref).
""" AddTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of Int_t TGeoManager::AddTrack(TVirtualGeoTrack *)
@trydoc raw"""
    AddTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})::Int32
Add a track to the list of tracks.

""" AddTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})

# Wrapper of Int_t TGeoManager::AddTransformation(const TGeoMatrix *)
@trydoc raw"""
    AddTransformation(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})::Int32
Add a matrix to the list. Returns index of the matrix in list.

""" AddTransformation(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})

# Wrapper of Int_t TGeoManager::AddVolume(TGeoVolume *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoManager}, volume::ByPtr1{TGeoVolume})::Int32
Add a volume to the list. Returns index of the volume in list.

""" AddVolume(this::ByRef1{TGeoManager}, volume::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::AnimateTracks(Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    AnimateTracks(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64, nframes::Int32, option::ByCopy{String})::Nothing
Draw animation of tracks.

""" AnimateTracks(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64, nframes::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::BombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    BombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing
Get the new 'bombed' translation vector according current exploded view mode.

""" BombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of void TGeoManager::Browse(TBrowser *)
@trydoc raw"""
    Browse(this::ByRef1{TGeoManager}, b::ByPtr1{TBrowser})::Nothing
Describe how to browse this object.

""" Browse(this::ByRef1{TGeoManager}, b::ByPtr1{TBrowser})

# Wrapper of void TGeoManager::BuildDefaultMaterials()
@trydoc raw"""
    BuildDefaultMaterials(this::ByRef1{TGeoManager})::Nothing
Now just a shortcut for GetElementTable.

""" BuildDefaultMaterials(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::cd(const char *)
@trydoc raw"""
    cd(this::ByRef1{TGeoManager}, path::ByCopy{String})::Bool
Browse the tree of nodes starting from fTopNode according to pathname.
Changes the path accordingly.
""" cd(this::ByRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of void TGeoManager::CdDown(Int_t)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoManager}, index::Int32)::Nothing
Make a daughter of current node current.
Can be called only with a valid daughter index (no check). Updates cache accordingly.
""" CdDown(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::CdNext()
@trydoc raw"""
    CdNext(this::ByRef1{TGeoManager})::Nothing
Do a cd to the node found next by FindNextBoundary.

""" CdNext(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CdNode(Int_t)
@trydoc raw"""
    CdNode(this::ByRef1{TGeoManager}, nodeid::Int32)::Nothing
Change current path to point to the node having this id.
Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)
""" CdNode(this::ByRef1{TGeoManager}, nodeid::Int32)

# Wrapper of void TGeoManager::CdTop()
@trydoc raw"""
    CdTop(this::ByRef1{TGeoManager})::Nothing
Make top level node the current node.
Updates the cache accordingly. Determine the overlapping state of current node.
""" CdTop(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CdUp()
@trydoc raw"""
    CdUp(this::ByRef1{TGeoManager})::Nothing
Go one level up in geometry.
Updates cache accordingly. Determine the overlapping state of current node.
""" CdUp(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CheckBoundaryErrors(Int_t, Double_t)
@trydoc raw"""
    CheckBoundaryErrors(this::ByRef1{TGeoManager}, ntracks::Int32, radius::Float64)::Nothing
Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary.
If radius is not mentioned the full bounding box will be sampled.
""" CheckBoundaryErrors(this::ByRef1{TGeoManager}, ntracks::Int32, radius::Float64)

# Wrapper of void TGeoManager::CheckBoundaryReference(Int_t)
@trydoc raw"""
    CheckBoundaryReference(this::ByRef1{TGeoManager}, icheck::Int32)::Nothing
Check the boundary errors reference file created by CheckBoundaryErrors method.
The shape for which the crossing failed is drawn with the starting point in red and the extrapolated point to boundary (+/- failing push/pull) in yellow.
""" CheckBoundaryReference(this::ByRef1{TGeoManager}, icheck::Int32)

# Wrapper of void TGeoManager::CheckGeometry(Option_t *)
@trydoc raw"""
    CheckGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Perform last checks on the geometry.

""" CheckGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::CheckGeometryFull(Int_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    CheckGeometryFull(this::ByRef1{TGeoManager}, ntracks::Int32, vx::Float64, vy::Float64, vz::Float64, option::ByCopy{String})::Nothing
Geometry checking.
- if option contains 'o': Optional overlap checkings (by sampling and by mesh).
- if option contains 'b': Optional boundary crossing check + timing per volume.

STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be checked by user to get report, then [TGeoVolume!CheckOverlaps](@ref)(0.01, "s") can be called for the suspicious volumes.

STAGE 2: normal overlap checking using the shapes mesh - fills the list of overlaps.

STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of crossings per volume (rays propagated from boundary to boundary until geometry exit). Timing computed and results stored in a histo.

STAGE 4: shooting 1 mil. random rays inside EACH volume and calling [FindNextBoundary()](@ref) + [Safety()](@ref) for each call. The timing is normalized by the number of crossings computed at stage 2 and presented as percentage. One can get a picture on which are the most "burned" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced.
""" CheckGeometryFull(this::ByRef1{TGeoManager}, ntracks::Int32, vx::Float64, vy::Float64, vz::Float64, option::ByCopy{String})

# Wrapper of void TGeoManager::CheckOverlaps(Double_t, Option_t *)
@trydoc raw"""
    CheckOverlaps(this::ByRef1{TGeoManager}, ovlp::Float64, option::ByCopy{String})::Nothing
Check all geometry for illegal overlaps within a limit OVLP.

""" CheckOverlaps(this::ByRef1{TGeoManager}, ovlp::Float64, option::ByCopy{String})

# Wrapper of Bool_t TGeoManager::CheckPath(const char *)
@trydoc raw"""
    CheckPath(this::ByConstRef1{TGeoManager}, path::ByCopy{String})::Bool
Check if a geometry path is valid without changing the state of the current navigator.

""" CheckPath(this::ByConstRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of void TGeoManager::CheckPoint(Double_t, Double_t, Double_t, Option_t *, Double_t)
@trydoc raw"""
    CheckPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)::Nothing
Classify a given point. See [TGeoChecker!CheckPoint()](@ref).
""" CheckPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)

# Wrapper of void TGeoManager::CheckShape(TGeoShape *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TGeoManager}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing
Test for shape navigation methods.
Summary for test numbers:

- 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2)
""" CheckShape(this::ByRef1{TGeoManager}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::CleanGarbage()
@trydoc raw"""
    CleanGarbage(this::ByRef1{TGeoManager})::Nothing
Clean temporary volumes and shapes from garbage collection.

""" CleanGarbage(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearAttributes()
@trydoc raw"""
    ClearAttributes(this::ByRef1{TGeoManager})::Nothing
Reset all attributes to default ones.
Default attributes for visualization are those defined before closing the geometry.
""" ClearAttributes(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearNavigators()
@trydoc raw"""
    ClearNavigators(this::ByRef1{TGeoManager})::Nothing
Clear all navigators.

""" ClearNavigators(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearOverlaps()
@trydoc raw"""
    ClearOverlaps(this::ByRef1{TGeoManager})::Nothing
Clear the list of overlaps.

""" ClearOverlaps(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearPhysicalNodes(Bool_t)
@trydoc raw"""
    ClearPhysicalNodes(this::ByRef1{TGeoManager}, mustdelete::Bool)::Nothing
Clear the current list of physical nodes, so that we can thestart over with a new list.
If MUSTDELETE is true, delete previous nodes.
""" ClearPhysicalNodes(this::ByRef1{TGeoManager}, mustdelete::Bool)

# Wrapper of void TGeoManager::ClearShape(const TGeoShape *)
@trydoc raw"""
    ClearShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})::Nothing
Remove a shape from the list of shapes.

""" ClearShape(this::ByRef1{TGeoManager}, shape::ByConstPtr1{TGeoShape})

# Wrapper of void TGeoManager::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoManager})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoManager})

# Wrapper of void TGeoManager::ClearTracks()
@trydoc raw"""
    ClearTracks(this::ByRef1{TGeoManager})::Nothing


""" ClearTracks(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CloseGeometry(Option_t *)
@trydoc raw"""
    CloseGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-time shapes)building the cache manager, voxelizing all volumes, counting the total number of physical nodes and registering the manager class to the browser.

""" CloseGeometry(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::ConvertReflections()
@trydoc raw"""
    ConvertReflections(this::ByRef1{TGeoManager})::Nothing
Convert all reflections in geometry to normal rotations + reflected shapes.

""" ConvertReflections(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::CountLevels()
@trydoc raw"""
    CountLevels(this::ByRef1{TGeoManager})::Nothing
Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices.

""" CountLevels(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::CountNodes(const TGeoVolume *, Int_t, Int_t)
@trydoc raw"""
    CountNodes(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, nlevels::Int32, option::Int32)::Int32
Count the total number of nodes starting from a volume, nlevels down.

""" CountNodes(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, nlevels::Int32, option::Int32)

# Wrapper of TGeoParallelWorld * TGeoManager::CreateParallelWorld(const char *)
@trydoc raw"""
    CreateParallelWorld(this::ByRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoParallelWorld}
Create a parallel world for prioritised navigation.
This can be populated with physical nodes and can be navigated independently using its API. In case the flag SetUseParallelWorldNav is set, any navigation query in the main geometry is checked against the parallel geometry, which gets priority in case of overlaps with the main geometry volumes.
""" CreateParallelWorld(this::ByRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of void TGeoManager::CreateThreadData()
@trydoc raw"""
    CreateThreadData(this::ByConstRef1{TGeoManager})::Nothing
Create thread private data for all geometry objects.

""" CreateThreadData(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::CrossBoundaryAndLocate(Bool_t, TGeoNode *)
@trydoc raw"""
    CrossBoundaryAndLocate(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode.

""" CrossBoundaryAndLocate(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByPtr1{TGeoNode})

# Wrapper of void TGeoManager::DefaultAngles()
@trydoc raw"""
    DefaultAngles(this::ByRef1{TGeoManager})::Nothing
Set default angles for a given view.

""" DefaultAngles(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DefaultColors()
@trydoc raw"""
    DefaultColors(this::ByRef1{TGeoManager})::Nothing
Set default volume colors according to A of material.

""" DefaultColors(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DisableInactiveVolumes()
@trydoc raw"""
    DisableInactiveVolumes(this::ByRef1{TGeoManager})::Nothing


""" DisableInactiveVolumes(this::ByRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::Division(const char *, const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Division(this::ByRef1{TGeoManager}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Create a new volume by dividing an existing one (GEANT3 like)
Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER) The behavior of the division operation can be triggered using OPTION :

OPTION (case insensitive) :

- N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3)
- NX - divide range starting with START in NDIV cells (GSDVN2 in G3)
- S - divide all range with given STEP. NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3)
- SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3)
""" Division(this::ByRef1{TGeoManager}, name::ByCopy{String}, mother::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::DoBackupState()
@trydoc raw"""
    DoBackupState(this::ByRef1{TGeoManager})::Nothing
Backup the current state without affecting the cache stack.

""" DoBackupState(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DoRestoreState()
@trydoc raw"""
    DoRestoreState(this::ByRef1{TGeoManager})::Nothing
Restore a backed-up state without affecting the cache stack.

""" DoRestoreState(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::DrawCurrentPoint(Int_t)
@trydoc raw"""
    DrawCurrentPoint(this::ByRef1{TGeoManager}, color::Int32)::Nothing
Draw current point in the same view.

""" DrawCurrentPoint(this::ByRef1{TGeoManager}, color::Int32)

# Wrapper of void TGeoManager::DrawPath(const char *, Option_t *)
@trydoc raw"""
    DrawPath(this::ByRef1{TGeoManager}, path::ByCopy{String}, option::ByCopy{String})::Nothing
Draw current path.

""" DrawPath(this::ByRef1{TGeoManager}, path::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TGeoManager::DrawTracks(Option_t *)
@trydoc raw"""
    DrawTracks(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Draw tracks over the geometry, according to option.
By default, only primaries are drawn. See [TGeoTrack!Draw()](@ref) for additional options.
""" DrawTracks(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::Edit(Option_t *)
@trydoc raw"""
    Edit(this::ByRef1{TGeoManager}, option::ByCopy{String})::Nothing
Append a pad for this geometry.

""" Edit(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of void TGeoManager::EnableInactiveVolumes()
@trydoc raw"""
    EnableInactiveVolumes(this::ByRef1{TGeoManager})::Nothing


""" EnableInactiveVolumes(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ExecuteEvent(Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteEvent(this::ByRef1{TGeoManager}, event::Int32, px::Int32, py::Int32)::Nothing
Execute mouse actions on this manager.

""" ExecuteEvent(this::ByRef1{TGeoManager}, event::Int32, px::Int32, py::Int32)

# Wrapper of Int_t TGeoManager::Export(const char *, const char *, Option_t *)
@trydoc raw"""
    Export(this::ByRef1{TGeoManager}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})::Int32
Export this geometry to a file.
- Case 1: root file or root/xml file if filename theend with ".root". The key will be named name By default the geometry is saved without the voxelisation info. Use option 'v" to save the voxelisation info.
   if filename theend with ".xml" a root/xml file is produced.

 - Case 2: C++ script
   if filename theend with ".C"

 - Case 3: gdml file
   if filename theend with ".gdml" NOTE that to use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/geom/gdml
""" Export(this::ByRef1{TGeoManager}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of TGeoMaterial * TGeoManager::FindDuplicateMaterial(const TGeoMaterial *)
@trydoc raw"""
    FindDuplicateMaterial(this::ByConstRef1{TGeoManager}, mat::ByConstPtr1{TGeoMaterial})::CxxPtr1{TGeoMaterial}
Find if a given material duplicates an existing one.

""" FindDuplicateMaterial(this::ByConstRef1{TGeoManager}, mat::ByConstPtr1{TGeoMaterial})

# Wrapper of TGeoNode * TGeoManager::FindNextBoundary(Double_t, const char *, Bool_t)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoManager}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)::CxxPtr1{TGeoNode}
Find distance to next boundary and store it in fStep.
Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : "Is STEPMAX a safe step ?" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.

Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly [TGeoManager!Safety()](@ref) if they want this computed for the current point.
""" FindNextBoundary(this::ByRef1{TGeoManager}, stepmax::Float64, path::ByCopy{String}, frombdr::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNextBoundaryAndStep(Double_t, Bool_t)
@trydoc raw"""
    FindNextBoundaryAndStep(this::ByRef1{TGeoManager}, stepmax::Float64, compsafe::Bool)::CxxPtr1{TGeoNode}
Compute distance to next boundary within STEPMAX.
If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node.
""" FindNextBoundaryAndStep(this::ByRef1{TGeoManager}, stepmax::Float64, compsafe::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNextDaughterBoundary(Double_t *, Double_t *, Int_t &, Bool_t)
@trydoc raw"""
    FindNextDaughterBoundary(this::ByRef1{TGeoManager}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)::CxxPtr1{TGeoNode}
Computes as fStep the distance to next daughter of the current volume.
The point and direction must be converted in the coordinate system of the current volume. The proposed step limit is fStep.
""" FindNextDaughterBoundary(this::ByRef1{TGeoManager}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, idaughter::ByRef2{Int32}, compmatrix::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNode(Bool_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoManager}, safe_start::Bool)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoManager}, safe_start::Bool)

# Wrapper of TGeoNode * TGeoManager::FindNode(Double_t, Double_t, Double_t)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::CxxPtr1{TGeoNode}
Returns deepest node containing current point.

""" FindNode(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of Double_t * TGeoManager::FindNormal(Bool_t)
@trydoc raw"""
    FindNormal(this::ByRef1{TGeoManager}, forward::Bool)::CxxPtr2{Float64}
Computes normal vector to the next surface that will be or was already crossed when propagating on a straight line from a given point/direction.
Returns the normal vector cosines in the MASTER coordinate system. The dot product of the normal and the current direction is positive defined.
""" FindNormal(this::ByRef1{TGeoManager}, forward::Bool)

# Wrapper of Double_t * TGeoManager::FindNormalFast()
@trydoc raw"""
    FindNormalFast(this::ByRef1{TGeoManager})::CxxPtr2{Float64}
Computes fast normal to next crossed boundary, assuming that the current point is close enough to the boundary.
Works only after calling FindNextBoundary.
""" FindNormalFast(this::ByRef1{TGeoManager})

# Wrapper of TVirtualGeoTrack * TGeoManager::FindTrackWithId(Int_t)
@trydoc raw"""
    FindTrackWithId(this::ByConstRef1{TGeoManager}, id::Int32)::CxxPtr1{TVirtualGeoTrack}
Search the track hierarchy to find the track with the given id.
if 'primsFirst' is true, then: first tries [TGeoManager!GetTrackOfId](@ref), then does a recursive search if that fails. this would be faster if the track is somehow known to be a primary
""" FindTrackWithId(this::ByConstRef1{TGeoManager}, id::Int32)

# Wrapper of TGeoVolume * TGeoManager::FindVolumeFast(const char *, Bool_t)
@trydoc raw"""
    FindVolumeFast(this::ByRef1{TGeoManager}, name::ByCopy{String}, multi::Bool)::CxxPtr1{TGeoVolume}
Fast search for a named volume. All trailing blanks stripped.

""" FindVolumeFast(this::ByRef1{TGeoManager}, name::ByCopy{String}, multi::Bool)

# Wrapper of TGeoPNEntry * TGeoManager::GetAlignableEntry(const char *)
@trydoc raw"""
    GetAlignableEntry(this::ByConstRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoPNEntry}
Retrieves an existing alignable object.

""" GetAlignableEntry(this::ByConstRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoPNEntry * TGeoManager::GetAlignableEntry(Int_t)
@trydoc raw"""
    GetAlignableEntry(this::ByConstRef1{TGeoManager}, index::Int32)::CxxPtr1{TGeoPNEntry}
Retrieves an existing alignable object at a given index.

""" GetAlignableEntry(this::ByConstRef1{TGeoManager}, index::Int32)

# Wrapper of TGeoPNEntry * TGeoManager::GetAlignableEntryByUID(Int_t)
@trydoc raw"""
    GetAlignableEntryByUID(this::ByConstRef1{TGeoManager}, uid::Int32)::CxxPtr1{TGeoPNEntry}
Retrieves an existing alignable object having a preset UID.

""" GetAlignableEntryByUID(this::ByConstRef1{TGeoManager}, uid::Int32)

# Wrapper of UChar_t * TGeoManager::GetBits()
@trydoc raw"""
    GetBits(this::ByRef1{TGeoManager})::CxxPtr2{UInt8}


""" GetBits(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::GetBombFactors(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetBombFactors(this::ByConstRef1{TGeoManager}, bombx::ByRef2{Float64}, bomby::ByRef2{Float64}, bombz::ByRef2{Float64}, bombr::ByRef2{Float64})::Nothing
Retrieve cartesian and radial bomb factors.

""" GetBombFactors(this::ByConstRef1{TGeoManager}, bombx::ByRef2{Float64}, bomby::ByRef2{Float64}, bombz::ByRef2{Float64}, bombr::ByRef2{Float64})

# Wrapper of Int_t TGeoManager::GetBombMode()
@trydoc raw"""
    GetBombMode(this::ByConstRef1{TGeoManager})::Int32


""" GetBombMode(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoBorderSurface * TGeoManager::GetBorderSurface(const char *)
@trydoc raw"""
    GetBorderSurface(this::ByConstRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoBorderSurface}
Get border surface with a given name;.

""" GetBorderSurface(this::ByConstRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of void TGeoManager::GetBranchNames(Int_t *)
@trydoc raw"""
    GetBranchNames(this::ByConstRef1{TGeoManager}, names::ByPtr2{Int32})::Nothing
Fill volume names of current branch into an array.

""" GetBranchNames(this::ByConstRef1{TGeoManager}, names::ByPtr2{Int32})

# Wrapper of void TGeoManager::GetBranchNumbers(Int_t *, Int_t *)
@trydoc raw"""
    GetBranchNumbers(this::ByConstRef1{TGeoManager}, copyNumbers::ByPtr2{Int32}, volumeNumbers::ByPtr2{Int32})::Nothing
Fill node copy numbers of current branch into an array.

""" GetBranchNumbers(this::ByConstRef1{TGeoManager}, copyNumbers::ByPtr2{Int32}, volumeNumbers::ByPtr2{Int32})

# Wrapper of void TGeoManager::GetBranchOnlys(Int_t *)
@trydoc raw"""
    GetBranchOnlys(this::ByConstRef1{TGeoManager}, isonly::ByPtr2{Int32})::Nothing
Fill node copy numbers of current branch into an array.

""" GetBranchOnlys(this::ByConstRef1{TGeoManager}, isonly::ByPtr2{Int32})

# Wrapper of Int_t TGeoManager::GetByteCount(Option_t *)
@trydoc raw"""
    GetByteCount(this::ByRef1{TGeoManager}, option::ByCopy{String})::Int32
Get total size of geometry in bytes.

""" GetByteCount(this::ByRef1{TGeoManager}, option::ByCopy{String})

# Wrapper of TGeoNodeCache * TGeoManager::GetCache()
@trydoc raw"""
    GetCache(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoNodeCache}


""" GetCache(this::ByConstRef1{TGeoManager})

# Wrapper of const Double_t * TGeoManager::GetCldir()
@trydoc raw"""
    GetCldir(this::ByConstRef1{TGeoManager})::ConstCxxPtr2{Float64}


""" GetCldir(this::ByConstRef1{TGeoManager})

# Wrapper of const Double_t * TGeoManager::GetCldirChecked()
@trydoc raw"""
    GetCldirChecked(this::ByConstRef1{TGeoManager})::ConstCxxPtr2{Float64}


""" GetCldirChecked(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoShape * TGeoManager::GetClippingShape()
@trydoc raw"""
    GetClippingShape(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoShape}


""" GetClippingShape(this::ByConstRef1{TGeoManager})

# Wrapper of const Double_t * TGeoManager::GetCurrentDirection()
@trydoc raw"""
    GetCurrentDirection(this::ByConstRef1{TGeoManager})::ConstCxxPtr2{Float64}


""" GetCurrentDirection(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoHMatrix * TGeoManager::GetCurrentMatrix()
@trydoc raw"""
    GetCurrentMatrix(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoHMatrix}


""" GetCurrentMatrix(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoNavigator * TGeoManager::GetCurrentNavigator()
@trydoc raw"""
    GetCurrentNavigator(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoNavigator}
Returns current navigator for the calling thread.

""" GetCurrentNavigator(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::GetCurrentNode()
@trydoc raw"""
    GetCurrentNode(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoNode}


""" GetCurrentNode(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetCurrentNodeId()
@trydoc raw"""
    GetCurrentNodeId(this::ByConstRef1{TGeoManager})::Int32
Get the unique ID of the current node.

""" GetCurrentNodeId(this::ByConstRef1{TGeoManager})

# Wrapper of const Double_t * TGeoManager::GetCurrentPoint()
@trydoc raw"""
    GetCurrentPoint(this::ByConstRef1{TGeoManager})::ConstCxxPtr2{Float64}


""" GetCurrentPoint(this::ByConstRef1{TGeoManager})

# Wrapper of TVirtualGeoTrack * TGeoManager::GetCurrentTrack()
@trydoc raw"""
    GetCurrentTrack(this::ByRef1{TGeoManager})::CxxPtr1{TVirtualGeoTrack}


""" GetCurrentTrack(this::ByRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::GetCurrentVolume()
@trydoc raw"""
    GetCurrentVolume(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoVolume}


""" GetCurrentVolume(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoElementTable * TGeoManager::GetElementTable()
@trydoc raw"""
    GetElementTable(this::ByRef1{TGeoManager})::CxxPtr1{TGeoElementTable}
Returns material table. Creates it if not existing.

""" GetElementTable(this::ByRef1{TGeoManager})

# Wrapper of TGDMLMatrix * TGeoManager::GetGDMLMatrix(const char *)
@trydoc raw"""
    GetGDMLMatrix(this::ByConstRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGDMLMatrix}
Get GDML matrix with a given name;.

""" GetGDMLMatrix(this::ByConstRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TVirtualGeoPainter * TGeoManager::GetGeomPainter()
@trydoc raw"""
    GetGeomPainter(this::ByRef1{TGeoManager})::CxxPtr1{TVirtualGeoPainter}
Make a default painter if none present. Returns pointer to it.

""" GetGeomPainter(this::ByRef1{TGeoManager})

# Wrapper of TGeoHMatrix * TGeoManager::GetGLMatrix()
@trydoc raw"""
    GetGLMatrix(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoHMatrix}


""" GetGLMatrix(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoHMatrix * TGeoManager::GetHMatrix()
@trydoc raw"""
    GetHMatrix(this::ByRef1{TGeoManager})::CxxPtr1{TGeoHMatrix}
Return stored current matrix (global_ matrix of the next touched node).

""" GetHMatrix(this::ByRef1{TGeoManager})

# Wrapper of const Double_t * TGeoManager::GetLastPoint()
@trydoc raw"""
    GetLastPoint(this::ByConstRef1{TGeoManager})::ConstCxxPtr2{Float64}


""" GetLastPoint(this::ByConstRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::GetLastSafety()
@trydoc raw"""
    GetLastSafety(this::ByConstRef1{TGeoManager})::Float64


""" GetLastSafety(this::ByConstRef1{TGeoManager})

# Wrapper of TVirtualGeoTrack * TGeoManager::GetLastTrack()
@trydoc raw"""
    GetLastTrack(this::ByRef1{TGeoManager})::CxxPtr1{TVirtualGeoTrack}


""" GetLastTrack(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoManager})::Int32


""" GetLevel(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfBorderSurfaces()
@trydoc raw"""
    GetListOfBorderSurfaces(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfBorderSurfaces(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfGDMLMatrices()
@trydoc raw"""
    GetListOfGDMLMatrices(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfGDMLMatrices(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfGShapes()
@trydoc raw"""
    GetListOfGShapes(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfGShapes(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfGVolumes()
@trydoc raw"""
    GetListOfGVolumes(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfGVolumes(this::ByConstRef1{TGeoManager})

# Wrapper of TList * TGeoManager::GetListOfMaterials()
@trydoc raw"""
    GetListOfMaterials(this::ByConstRef1{TGeoManager})::CxxPtr1{TList}


""" GetListOfMaterials(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfMatrices()
@trydoc raw"""
    GetListOfMatrices(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfMatrices(this::ByConstRef1{TGeoManager})

# Wrapper of TList * TGeoManager::GetListOfMedia()
@trydoc raw"""
    GetListOfMedia(this::ByConstRef1{TGeoManager})::CxxPtr1{TList}


""" GetListOfMedia(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoNavigatorArray * TGeoManager::GetListOfNavigators()
@trydoc raw"""
    GetListOfNavigators(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoNavigatorArray}
Get list of navigators for the calling thread.

""" GetListOfNavigators(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfNodes()
@trydoc raw"""
    GetListOfNodes(this::ByRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfNodes(this::ByRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfOpticalSurfaces()
@trydoc raw"""
    GetListOfOpticalSurfaces(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfOpticalSurfaces(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfOverlaps()
@trydoc raw"""
    GetListOfOverlaps(this::ByRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfOverlaps(this::ByRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfPhysicalNodes()
@trydoc raw"""
    GetListOfPhysicalNodes(this::ByRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfPhysicalNodes(this::ByRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfRegions()
@trydoc raw"""
    GetListOfRegions(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfRegions(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfShapes()
@trydoc raw"""
    GetListOfShapes(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfShapes(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfSkinSurfaces()
@trydoc raw"""
    GetListOfSkinSurfaces(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfSkinSurfaces(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfTracks()
@trydoc raw"""
    GetListOfTracks(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfTracks(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfUVolumes()
@trydoc raw"""
    GetListOfUVolumes(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfUVolumes(this::ByConstRef1{TGeoManager})

# Wrapper of TObjArray * TGeoManager::GetListOfVolumes()
@trydoc raw"""
    GetListOfVolumes(this::ByConstRef1{TGeoManager})::CxxPtr1{TObjArray}


""" GetListOfVolumes(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::GetMasterVolume()
@trydoc raw"""
    GetMasterVolume(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoVolume}


""" GetMasterVolume(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoMaterial * TGeoManager::GetMaterial(const char *)
@trydoc raw"""
    GetMaterial(this::ByConstRef1{TGeoManager}, matname::ByCopy{String})::CxxPtr1{TGeoMaterial}
Search for a named material. All trailing blanks stripped.

""" GetMaterial(this::ByConstRef1{TGeoManager}, matname::ByCopy{String})

# Wrapper of TGeoMaterial * TGeoManager::GetMaterial(Int_t)
@trydoc raw"""
    GetMaterial(this::ByConstRef1{TGeoManager}, id::Int32)::CxxPtr1{TGeoMaterial}
Return material at position id.

""" GetMaterial(this::ByConstRef1{TGeoManager}, id::Int32)

# Wrapper of Int_t TGeoManager::GetMaterialIndex(const char *)
@trydoc raw"""
    GetMaterialIndex(this::ByConstRef1{TGeoManager}, matname::ByCopy{String})::Int32
Return index of named material.

""" GetMaterialIndex(this::ByConstRef1{TGeoManager}, matname::ByCopy{String})

# Wrapper of Int_t TGeoManager::GetMaxLevel()
@trydoc raw"""
    GetMaxLevel(this::ByConstRef1{TGeoManager})::Int32


""" GetMaxLevel(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetMaxThreads()
@trydoc raw"""
    GetMaxThreads(this::ByConstRef1{TGeoManager})::Int32


""" GetMaxThreads(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetMaxVisNodes()
@trydoc raw"""
    GetMaxVisNodes(this::ByConstRef1{TGeoManager})::Int32


""" GetMaxVisNodes(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoMedium * TGeoManager::GetMedium(const char *)
@trydoc raw"""
    GetMedium(this::ByConstRef1{TGeoManager}, medium::ByCopy{String})::CxxPtr1{TGeoMedium}
Search for a named tracking medium. All trailing blanks stripped.

""" GetMedium(this::ByConstRef1{TGeoManager}, medium::ByCopy{String})

# Wrapper of TGeoMedium * TGeoManager::GetMedium(Int_t)
@trydoc raw"""
    GetMedium(this::ByConstRef1{TGeoManager}, numed::Int32)::CxxPtr1{TGeoMedium}
Search for a tracking medium with a given ID.

""" GetMedium(this::ByConstRef1{TGeoManager}, numed::Int32)

# Wrapper of TGeoNode * TGeoManager::GetMother(Int_t)
@trydoc raw"""
    GetMother(this::ByConstRef1{TGeoManager}, up::Int32)::CxxPtr1{TGeoNode}


""" GetMother(this::ByConstRef1{TGeoManager}, up::Int32)

# Wrapper of TGeoHMatrix * TGeoManager::GetMotherMatrix(Int_t)
@trydoc raw"""
    GetMotherMatrix(this::ByConstRef1{TGeoManager}, up::Int32)::CxxPtr1{TGeoHMatrix}


""" GetMotherMatrix(this::ByConstRef1{TGeoManager}, up::Int32)

# Wrapper of Int_t TGeoManager::GetNAlignable(Bool_t)
@trydoc raw"""
    GetNAlignable(this::ByConstRef1{TGeoManager}, with_uid::Bool)::Int32
Retrieves number of PN entries with or without UID.

""" GetNAlignable(this::ByConstRef1{TGeoManager}, with_uid::Bool)

# Wrapper of TGeoNode * TGeoManager::GetNextNode()
@trydoc raw"""
    GetNextNode(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoNode}


""" GetNextNode(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNmany()
@trydoc raw"""
    GetNmany(this::ByConstRef1{TGeoManager})::Int32


""" GetNmany(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNNodes()
@trydoc raw"""
    GetNNodes(this::ByRef1{TGeoManager})::Int32


""" GetNNodes(this::ByRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::GetNode(Int_t)
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoManager}, level::Int32)::CxxPtr1{TGeoNode}


""" GetNode(this::ByConstRef1{TGeoManager}, level::Int32)

# Wrapper of Int_t TGeoManager::GetNodeId()
@trydoc raw"""
    GetNodeId(this::ByConstRef1{TGeoManager})::Int32


""" GetNodeId(this::ByConstRef1{TGeoManager})

# Wrapper of const Double_t * TGeoManager::GetNormal()
@trydoc raw"""
    GetNormal(this::ByConstRef1{TGeoManager})::ConstCxxPtr2{Float64}


""" GetNormal(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNproperties()
@trydoc raw"""
    GetNproperties(this::ByConstRef1{TGeoManager})::Int32


""" GetNproperties(this::ByConstRef1{TGeoManager})

# Wrapper of int TGeoManager::GetNregions()
@trydoc raw"""
    GetNregions(this::ByConstRef1{TGeoManager})::Int32


""" GetNregions(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNsegments()
@trydoc raw"""
    GetNsegments(this::ByConstRef1{TGeoManager})::Int32
Get number of segments approximating circles.

""" GetNsegments(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNtracks()
@trydoc raw"""
    GetNtracks(this::ByConstRef1{TGeoManager})::Int32


""" GetNtracks(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoOpticalSurface * TGeoManager::GetOpticalSurface(const char *)
@trydoc raw"""
    GetOpticalSurface(this::ByConstRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoOpticalSurface}
Get optical surface with a given name;.

""" GetOpticalSurface(this::ByConstRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TVirtualGeoPainter * TGeoManager::GetPainter()
@trydoc raw"""
    GetPainter(this::ByConstRef1{TGeoManager})::CxxPtr1{TVirtualGeoPainter}


""" GetPainter(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::GetPaintVolume()
@trydoc raw"""
    GetPaintVolume(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoVolume}


""" GetPaintVolume(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoParallelWorld * TGeoManager::GetParallelWorld()
@trydoc raw"""
    GetParallelWorld(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoParallelWorld}


""" GetParallelWorld(this::ByConstRef1{TGeoManager})

# Wrapper of TVirtualGeoTrack * TGeoManager::GetParentTrackOfId(Int_t)
@trydoc raw"""
    GetParentTrackOfId(this::ByConstRef1{TGeoManager}, id::Int32)::CxxPtr1{TVirtualGeoTrack}
Get parent track with a given ID.

""" GetParentTrackOfId(this::ByConstRef1{TGeoManager}, id::Int32)

# Wrapper of const char * TGeoManager::GetParticleName()
@trydoc raw"""
    GetParticleName(this::ByConstRef1{TGeoManager})::ByCopy{String}


""" GetParticleName(this::ByConstRef1{TGeoManager})

# Wrapper of const char * TGeoManager::GetPath()
@trydoc raw"""
    GetPath(this::ByConstRef1{TGeoManager})::ByCopy{String}
Get path to the current node in the form /node0/node1/...

""" GetPath(this::ByConstRef1{TGeoManager})

# Wrapper of const char * TGeoManager::GetPdgName(Int_t)
@trydoc raw"""
    GetPdgName(this::ByConstRef1{TGeoManager}, pdg::Int32)::ByCopy{String}
Get name for given pdg code;.

""" GetPdgName(this::ByConstRef1{TGeoManager}, pdg::Int32)

# Wrapper of TGeoPhysicalNode * TGeoManager::GetPhysicalNode(Int_t)
@trydoc raw"""
    GetPhysicalNode(this::ByConstRef1{TGeoManager}, i::Int32)::CxxPtr1{TGeoPhysicalNode}


""" GetPhysicalNode(this::ByConstRef1{TGeoManager}, i::Int32)

# Wrapper of Double_t TGeoManager::GetProperty(const char *, Bool_t *)
@trydoc raw"""
    GetProperty(this::ByConstRef1{TGeoManager}, name::ByCopy{String}, error::ByPtr2{Bool})::Float64
Get a user-defined property.

""" GetProperty(this::ByConstRef1{TGeoManager}, name::ByCopy{String}, error::ByPtr2{Bool})

# Wrapper of Double_t TGeoManager::GetProperty(size_t, TString &, Bool_t *)
@trydoc raw"""
    GetProperty(this::ByConstRef1{TGeoManager}, i::Int64, name::ByRef1{TString}, error::ByPtr2{Bool})::Float64
Get a user-defined property from a given index.

""" GetProperty(this::ByConstRef1{TGeoManager}, i::Int64, name::ByRef1{TString}, error::ByPtr2{Bool})

# Wrapper of TGeoRegion * TGeoManager::GetRegion(int)
@trydoc raw"""
    GetRegion(this::ByRef1{TGeoManager}, i::Int32)::CxxPtr1{TGeoRegion}


""" GetRegion(this::ByRef1{TGeoManager}, i::Int32)

# Wrapper of Int_t TGeoManager::GetRTmode()
@trydoc raw"""
    GetRTmode(this::ByConstRef1{TGeoManager})::Int32


""" GetRTmode(this::ByConstRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::GetSafeDistance()
@trydoc raw"""
    GetSafeDistance(this::ByConstRef1{TGeoManager})::Float64


""" GetSafeDistance(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetSafeLevel()
@trydoc raw"""
    GetSafeLevel(this::ByConstRef1{TGeoManager})::Int32
Go upwards the tree until a non-overlapping node.

""" GetSafeLevel(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoSkinSurface * TGeoManager::GetSkinSurface(const char *)
@trydoc raw"""
    GetSkinSurface(this::ByConstRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoSkinSurface}
Get skin surface with a given name;.

""" GetSkinSurface(this::ByConstRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of Int_t TGeoManager::GetStackLevel()
@trydoc raw"""
    GetStackLevel(this::ByConstRef1{TGeoManager})::Int32


""" GetStackLevel(this::ByConstRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::GetStep()
@trydoc raw"""
    GetStep(this::ByConstRef1{TGeoManager})::Float64


""" GetStep(this::ByConstRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::GetTmax()
@trydoc raw"""
    GetTmax(this::ByConstRef1{TGeoManager})::Float64


""" GetTmax(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::GetTminTmax(Double_t &, Double_t &)
@trydoc raw"""
    GetTminTmax(this::ByConstRef1{TGeoManager}, tmin::ByRef2{Float64}, tmax::ByRef2{Float64})::Bool
Get time cut for drawing tracks.

""" GetTminTmax(this::ByConstRef1{TGeoManager}, tmin::ByRef2{Float64}, tmax::ByRef2{Float64})

# Wrapper of TGeoNode * TGeoManager::GetTopNode()
@trydoc raw"""
    GetTopNode(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoNode}


""" GetTopNode(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::GetTopVolume()
@trydoc raw"""
    GetTopVolume(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoVolume}


""" GetTopVolume(this::ByConstRef1{TGeoManager})

# Wrapper of TVirtualGeoTrack * TGeoManager::GetTrack(Int_t)
@trydoc raw"""
    GetTrack(this::ByRef1{TGeoManager}, index::Int32)::CxxPtr1{TVirtualGeoTrack}


""" GetTrack(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of Int_t TGeoManager::GetTrackIndex(Int_t)
@trydoc raw"""
    GetTrackIndex(this::ByConstRef1{TGeoManager}, id::Int32)::Int32
Get index for track id, -1 if not found.

""" GetTrackIndex(this::ByConstRef1{TGeoManager}, id::Int32)

# Wrapper of TVirtualGeoTrack * TGeoManager::GetTrackOfId(Int_t)
@trydoc raw"""
    GetTrackOfId(this::ByConstRef1{TGeoManager}, id::Int32)::CxxPtr1{TVirtualGeoTrack}
Get track with a given ID.

""" GetTrackOfId(this::ByConstRef1{TGeoManager}, id::Int32)

# Wrapper of Int_t TGeoManager::GetUID(const char *)
@trydoc raw"""
    GetUID(this::ByConstRef1{TGeoManager}, volname::ByCopy{String})::Int32
Retrieve unique id for a volume name. Return -1 if name not found.

""" GetUID(this::ByConstRef1{TGeoManager}, volname::ByCopy{String})

# Wrapper of TGeoVolume * TGeoManager::GetUserPaintVolume()
@trydoc raw"""
    GetUserPaintVolume(this::ByConstRef1{TGeoManager})::CxxPtr1{TGeoVolume}


""" GetUserPaintVolume(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetVirtualLevel()
@trydoc raw"""
    GetVirtualLevel(this::ByRef1{TGeoManager})::Int32
Find level of virtuality of current overlapping node (number of levels up having the same tracking media.

""" GetVirtualLevel(this::ByRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::GetVisDensity()
@trydoc raw"""
    GetVisDensity(this::ByConstRef1{TGeoManager})::Float64


""" GetVisDensity(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetVisLevel()
@trydoc raw"""
    GetVisLevel(this::ByConstRef1{TGeoManager})::Int32
Returns current depth to which geometry is drawn.

""" GetVisLevel(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetVisOption()
@trydoc raw"""
    GetVisOption(this::ByConstRef1{TGeoManager})::Int32
Returns current depth to which geometry is drawn.

""" GetVisOption(this::ByConstRef1{TGeoManager})

# Wrapper of TGeoVolume * TGeoManager::GetVolume(const char *)
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoVolume}
Search for a named volume. All trailing blanks stripped.

""" GetVolume(this::ByConstRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoVolume * TGeoManager::GetVolume(Int_t)
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoManager}, uid::Int32)::CxxPtr1{TGeoVolume}


""" GetVolume(this::ByConstRef1{TGeoManager}, uid::Int32)

# Wrapper of Bool_t TGeoManager::GotoSafeLevel()
@trydoc raw"""
    GotoSafeLevel(this::ByRef1{TGeoManager})::Bool
Go upwards the tree until a non-overlapping node.

""" GotoSafeLevel(this::ByRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::InitTrack(const Double_t *, const Double_t *)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoManager}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoManager}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of TGeoNode * TGeoManager::InitTrack(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    InitTrack(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)::CxxPtr1{TGeoNode}
Initialize current point and current direction vector (normalized) in MARS.
Return corresponding node.
""" InitTrack(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of void TGeoManager::InspectState()
@trydoc raw"""
    InspectState(this::ByConstRef1{TGeoManager})::Nothing
Inspects path and all flags for the current state.

""" InspectState(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsActivityEnabled()
@trydoc raw"""
    IsActivityEnabled(this::ByConstRef1{TGeoManager})::Bool


""" IsActivityEnabled(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsAnimatingTracks()
@trydoc raw"""
    IsAnimatingTracks(this::ByConstRef1{TGeoManager})::Bool


""" IsAnimatingTracks(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsCheckingOverlaps()
@trydoc raw"""
    IsCheckingOverlaps(this::ByConstRef1{TGeoManager})::Bool


""" IsCheckingOverlaps(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsCleaning()
@trydoc raw"""
    IsCleaning(this::ByConstRef1{TGeoManager})::Bool


""" IsCleaning(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsClosed()
@trydoc raw"""
    IsClosed(this::ByConstRef1{TGeoManager})::Bool


""" IsClosed(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsCurrentOverlapping()
@trydoc raw"""
    IsCurrentOverlapping(this::ByConstRef1{TGeoManager})::Bool


""" IsCurrentOverlapping(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsDrawingExtra()
@trydoc raw"""
    IsDrawingExtra(this::ByConstRef1{TGeoManager})::Bool


""" IsDrawingExtra(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsEntering()
@trydoc raw"""
    IsEntering(this::ByConstRef1{TGeoManager})::Bool


""" IsEntering(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsExiting()
@trydoc raw"""
    IsExiting(this::ByConstRef1{TGeoManager})::Bool


""" IsExiting(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TGeoManager})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsInPhiRange()
@trydoc raw"""
    IsInPhiRange(this::ByConstRef1{TGeoManager})::Bool
True if current node is in phi range.

""" IsInPhiRange(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsMatrixReflection()
@trydoc raw"""
    IsMatrixReflection(this::ByConstRef1{TGeoManager})::Bool


""" IsMatrixReflection(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsMatrixTransform()
@trydoc raw"""
    IsMatrixTransform(this::ByConstRef1{TGeoManager})::Bool


""" IsMatrixTransform(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsMultiThread()
@trydoc raw"""
    IsMultiThread(this::ByConstRef1{TGeoManager})::Bool


""" IsMultiThread(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsNodeSelectable()
@trydoc raw"""
    IsNodeSelectable(this::ByConstRef1{TGeoManager})::Bool


""" IsNodeSelectable(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsNullStep()
@trydoc raw"""
    IsNullStep(this::ByConstRef1{TGeoManager})::Bool


""" IsNullStep(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsOnBoundary()
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoManager})::Bool


""" IsOnBoundary(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsOutside()
@trydoc raw"""
    IsOutside(this::ByConstRef1{TGeoManager})::Bool


""" IsOutside(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsParallelWorldNav()
@trydoc raw"""
    IsParallelWorldNav(this::ByConstRef1{TGeoManager})::Bool


""" IsParallelWorldNav(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsSameLocation()
@trydoc raw"""
    IsSameLocation(this::ByConstRef1{TGeoManager})::Bool


""" IsSameLocation(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsSameLocation(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    IsSameLocation(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, change::Bool)::Bool
Checks if point (x,y,z) is still in the current node.

""" IsSameLocation(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64, change::Bool)

# Wrapper of Bool_t TGeoManager::IsSamePoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    IsSamePoint(this::ByConstRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::Bool
Check if a new point with given coordinates is the same as the last located one.

""" IsSamePoint(this::ByConstRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of Bool_t TGeoManager::IsStartSafe()
@trydoc raw"""
    IsStartSafe(this::ByConstRef1{TGeoManager})::Bool


""" IsStartSafe(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsStepEntering()
@trydoc raw"""
    IsStepEntering(this::ByConstRef1{TGeoManager})::Bool


""" IsStepEntering(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsStepExiting()
@trydoc raw"""
    IsStepExiting(this::ByConstRef1{TGeoManager})::Bool


""" IsStepExiting(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsStreamingVoxels()
@trydoc raw"""
    IsStreamingVoxels(this::ByConstRef1{TGeoManager})::Bool


""" IsStreamingVoxels(this::ByConstRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::IsVisLeaves()
@trydoc raw"""
    IsVisLeaves(this::ByConstRef1{TGeoManager})::Bool


""" IsVisLeaves(this::ByConstRef1{TGeoManager})

# Wrapper of void TGeoManager::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoManager}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing


""" LocalToMaster(this::ByConstRef1{TGeoManager}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoManager::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoManager}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing


""" LocalToMasterBomb(this::ByConstRef1{TGeoManager}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoManager::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoManager}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing


""" LocalToMasterVect(this::ByConstRef1{TGeoManager}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of TGeoPhysicalNode * TGeoManager::MakeAlignablePN(const char *)
@trydoc raw"""
    MakeAlignablePN(this::ByRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoPhysicalNode}
Make a physical node from the path pointed by an alignable object with a given name.

""" MakeAlignablePN(this::ByRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoPhysicalNode * TGeoManager::MakeAlignablePN(TGeoPNEntry *)
@trydoc raw"""
    MakeAlignablePN(this::ByRef1{TGeoManager}, entry::ByPtr1{TGeoPNEntry})::CxxPtr1{TGeoPhysicalNode}
Make a physical node from the path pointed by a given alignable object.

""" MakeAlignablePN(this::ByRef1{TGeoManager}, entry::ByPtr1{TGeoPNEntry})

# Wrapper of TGeoVolume * TGeoManager::MakeArb8(const char *, TGeoMedium *, Double_t, Double_t *)
@trydoc raw"""
    MakeArb8(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})::CxxPtr1{TGeoVolume}
Make an [TGeoArb8](@ref) volume.

""" MakeArb8(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, vertices::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoManager::MakeBox(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeBox(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a box shape with given medium.

""" MakeBox(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeCone(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCone(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone shape with given medium.

""" MakeCone(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeCons(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCons(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a cone segment shape with given medium.

""" MakeCons(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeCtub(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeCtub(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.

""" MakeCtub(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeEltu(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeEltu(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeEltu(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, a::Float64, b::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeGtra(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeGtra(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a twisted trapezoid shape with given medium.

""" MakeGtra(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, twist::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeHype(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeHype(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeHype(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakePara(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakePara(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a parallelepiped shape with given medium.

""" MakePara(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx::Float64, dy::Float64, dz::Float64, alpha::Float64, theta::Float64, phi::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeParaboloid(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeParaboloid(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeParaboloid(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rlo::Float64, rhi::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakePcon(const char *, TGeoMedium *, Double_t, Double_t, Int_t)
@trydoc raw"""
    MakePcon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polycone shape with given medium.

""" MakePcon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nz::Int32)

# Wrapper of TGeoVolume * TGeoManager::MakePgon(const char *, TGeoMedium *, Double_t, Double_t, Int_t, Int_t)
@trydoc raw"""
    MakePgon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a polygone shape with given medium.

""" MakePgon(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, phi::Float64, dphi::Float64, nedges::Int32, nz::Int32)

# Wrapper of TGeoPhysicalNode * TGeoManager::MakePhysicalNode(const char *)
@trydoc raw"""
    MakePhysicalNode(this::ByRef1{TGeoManager}, path::ByCopy{String})::CxxPtr1{TGeoPhysicalNode}
Makes a physical node corresponding to a path.
If PATH is not specified, makes physical node matching current modeller state.
""" MakePhysicalNode(this::ByRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of TGeoVolume * TGeoManager::MakeSphere(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeSphere(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a sphere shape with given medium.

""" MakeSphere(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, themin::Float64, themax::Float64, phimin::Float64, phimax::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTorus(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTorus(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a torus shape with given medium.

""" MakeTorus(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)

# Wrapper of TVirtualGeoTrack * TGeoManager::MakeTrack(Int_t, Int_t, TObject *)
@trydoc raw"""
    MakeTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::CxxPtr1{TVirtualGeoTrack}
Makes a primary track but do not attach it to the list of tracks.
The track can be attached as daughter to another one with TVirtualGeoTrack!AddTrack
""" MakeTrack(this::ByRef1{TGeoManager}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of TGeoVolume * TGeoManager::MakeTrap(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrap(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a trapezoid shape with given medium.

""" MakeTrap(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dz::Float64, theta::Float64, phi::Float64, h1::Float64, bl1::Float64, tl1::Float64, alpha1::Float64, h2::Float64, bl2::Float64, tl2::Float64, alpha2::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTrd1(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd1(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd1](@ref) shape with given medium.

""" MakeTrd1(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTrd2(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTrd2(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a [TGeoTrd2](@ref) shape with given medium.

""" MakeTrd2(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, dx1::Float64, dx2::Float64, dy1::Float64, dy2::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTube(const char *, TGeoMedium *, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTube(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube shape with given medium.

""" MakeTube(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of TGeoVolume * TGeoManager::MakeTubs(const char *, TGeoMedium *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    MakeTubs(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::CxxPtr1{TGeoVolume}
Make in one step a volume pointing to a tube segment shape with given medium.
The segment will be from phiStart to phiEnd, the angles are expressed in degree
""" MakeTubs(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of TGeoVolumeAssembly * TGeoManager::MakeVolumeAssembly(const char *)
@trydoc raw"""
    MakeVolumeAssembly(this::ByRef1{TGeoManager}, name::ByCopy{String})::CxxPtr1{TGeoVolumeAssembly}
Make an assembly of volumes.

""" MakeVolumeAssembly(this::ByRef1{TGeoManager}, name::ByCopy{String})

# Wrapper of TGeoVolumeMulti * TGeoManager::MakeVolumeMulti(const char *, TGeoMedium *)
@trydoc raw"""
    MakeVolumeMulti(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})::CxxPtr1{TGeoVolumeMulti}
Make a [TGeoVolumeMulti](@ref) handling a list of volumes.

""" MakeVolumeMulti(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium})

# Wrapper of TGeoVolume * TGeoManager::MakeXtru(const char *, TGeoMedium *, Int_t)
@trydoc raw"""
    MakeXtru(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)::CxxPtr1{TGeoVolume}
Make a TGeoXtru-shaped volume with nz planes.

""" MakeXtru(this::ByRef1{TGeoManager}, name::ByCopy{String}, medium::ByPtr1{TGeoMedium}, nz::Int32)

# Wrapper of void TGeoManager::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing


""" MasterToLocal(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoManager::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing


""" MasterToLocalBomb(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoManager::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing


""" MasterToLocalVect(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoManager::MasterToTop(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToTop(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, top::ByPtr2{Float64})::Nothing
Convert coordinates from master volume frame to top.

""" MasterToTop(this::ByConstRef1{TGeoManager}, master::ByConstPtr2{Float64}, top::ByPtr2{Float64})

# Wrapper of TGeoMaterial * TGeoManager::Material(const char *, Double_t, Double_t, Double_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Material(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)::CxxPtr1{TGeoMaterial}
Create material with given A, Z and density, having an unique id.

""" Material(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::Float64, z::Float64, dens::Float64, uid::Int32, radlen::Float64, intlen::Float64)

# Wrapper of void TGeoManager::Matrix(Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Matrix(this::ByRef1{TGeoManager}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)::Nothing
Create rotation matrix named 'mat<index>'.
- index rotation matrix number
- theta1 polar angle for axis X
- phi1 azimuthal angle for axis X
- theta2 polar angle for axis Y
- phi2 azimuthal angle for axis Y
- theta3 polar angle for axis Z
- phi3 azimuthal angle for axis Z
""" Matrix(this::ByRef1{TGeoManager}, index::Int32, theta1::Float64, phi1::Float64, theta2::Float64, phi2::Float64, theta3::Float64, phi3::Float64)

# Wrapper of TGeoMedium * TGeoManager::Medium(const char *, Int_t, Int_t, Int_t, Int_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    Medium(this::ByRef1{TGeoManager}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)::CxxPtr1{TGeoMedium}
Create tracking medium.
- numed tracking medium number assigned
- name tracking medium name
- nmat material number
- isvol sensitive volume flag
- ifield magnetic field
- fieldm max. field value (kilogauss)
- tmaxfd max. angle due to field (deg/step)
- stemax max. step allowed
- deemax max. fraction of energy lost in a step
- epsil tracking precision (cm)
- stmin min. step due to continuous processes (cm)
- ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;
- ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking performed with g3helix; ifield = 3 if tracking performed with g3helx3.
""" Medium(this::ByRef1{TGeoManager}, name::ByCopy{String}, numed::Int32, nmat::Int32, isvol::Int32, ifield::Int32, fieldm::Float64, tmaxfd::Float64, stemax::Float64, deemax::Float64, epsil::Float64, stmin::Float64)

# Wrapper of TGeoMaterial * TGeoManager::Mixture(const char *, Double_t *, Double_t *, Double_t, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float64}, z::ByPtr2{Float64}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float64}, uid::Int32)

# Wrapper of TGeoMaterial * TGeoManager::Mixture(const char *, Float_t *, Float_t *, Double_t, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)::CxxPtr1{TGeoMaterial}
Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id.

""" Mixture(this::ByRef1{TGeoManager}, name::ByCopy{String}, a::ByPtr2{Float32}, z::ByPtr2{Float32}, dens::Float64, nelem::Int32, wmat::ByPtr2{Float32}, uid::Int32)

# Wrapper of void TGeoManager::ModifiedPad()
@trydoc raw"""
    ModifiedPad(this::ByConstRef1{TGeoManager})::Nothing
Send "Modified" signal to painter.

""" ModifiedPad(this::ByConstRef1{TGeoManager})

# Wrapper of void TGeoManager::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Double_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of void TGeoManager::Node(const char *, Int_t, const char *, Double_t, Double_t, Double_t, Int_t, Bool_t, Float_t *, Int_t)
@trydoc raw"""
    Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)::Nothing
Create a node called `<name_nr>` pointing to the volume called `<name>` as daughter of the volume called `<mother>` (gspos).
The relative matrix is made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`. In case npar>0, create the volume to be positioned in mother, according its actual parameters (gsposp).

- NAME Volume name
- NUMBER Copy number of the volume
- MOTHER Mother volume name
- X X coord. of the volume in mother ref. sys.
- Y Y coord. of the volume in mother ref. sys.
- Z Z coord. of the volume in mother ref. sys.
- IROT Rotation matrix number w.r.t. mother ref. sys.
- ISONLY ONLY/MANY flag
""" Node(this::ByRef1{TGeoManager}, name::ByCopy{String}, nr::Int32, mother::ByCopy{String}, x::Float64, y::Float64, z::Float64, irot::Int32, isOnly::Bool, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of void TGeoManager::OptimizeVoxels(const char *)
@trydoc raw"""
    OptimizeVoxels(this::ByRef1{TGeoManager}, filename::ByCopy{String})::Nothing
Optimize voxelization type for all volumes. Save best choice in a macro.

""" OptimizeVoxels(this::ByRef1{TGeoManager}, filename::ByCopy{String})

# Wrapper of void TGeoManager::PopDummy(Int_t)
@trydoc raw"""
    PopDummy(this::ByRef1{TGeoManager}, ipop::Int32)::Nothing


""" PopDummy(this::ByRef1{TGeoManager}, ipop::Int32)

# Wrapper of Bool_t TGeoManager::PopPath()
@trydoc raw"""
    PopPath(this::ByRef1{TGeoManager})::Bool


""" PopPath(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::PopPath(Int_t)
@trydoc raw"""
    PopPath(this::ByRef1{TGeoManager}, index::Int32)::Bool


""" PopPath(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of Bool_t TGeoManager::PopPoint()
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoManager})::Bool


""" PopPoint(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::PopPoint(Int_t)
@trydoc raw"""
    PopPoint(this::ByRef1{TGeoManager}, index::Int32)::Bool


""" PopPoint(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::PrintOverlaps()
@trydoc raw"""
    PrintOverlaps(this::ByConstRef1{TGeoManager})::Nothing
Prints the current list of overlaps.

""" PrintOverlaps(this::ByConstRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::PushPath(Int_t)
@trydoc raw"""
    PushPath(this::ByRef1{TGeoManager}, startlevel::Int32)::Int32


""" PushPath(this::ByRef1{TGeoManager}, startlevel::Int32)

# Wrapper of Int_t TGeoManager::PushPoint(Int_t)
@trydoc raw"""
    PushPoint(this::ByRef1{TGeoManager}, startlevel::Int32)::Int32


""" PushPoint(this::ByRef1{TGeoManager}, startlevel::Int32)

# Wrapper of void TGeoManager::RandomPoints(const TGeoVolume *, Int_t, Option_t *)
@trydoc raw"""
    RandomPoints(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})::Nothing
Draw random points in the bounding box of a volume.

""" RandomPoints(this::ByRef1{TGeoManager}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::RandomRays(Int_t, Double_t, Double_t, Double_t, const char *, Bool_t)
@trydoc raw"""
    RandomRays(this::ByRef1{TGeoManager}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)::Nothing
Randomly shoot nrays and plot intersections with surfaces for current top node.

""" RandomRays(this::ByRef1{TGeoManager}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)

# Wrapper of void TGeoManager::RefreshPhysicalNodes(Bool_t)
@trydoc raw"""
    RefreshPhysicalNodes(this::ByRef1{TGeoManager}, lock::Bool)::Nothing
Refresh physical nodes to reflect the actual geometry paths after alignment was applied.
Optionally locks physical nodes (default).
""" RefreshPhysicalNodes(this::ByRef1{TGeoManager}, lock::Bool)

# Wrapper of void TGeoManager::RegisterMatrix(const TGeoMatrix *)
@trydoc raw"""
    RegisterMatrix(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})::Nothing
Register a matrix to the list of matrices.
It will be cleaned-up at the destruction [TGeoManager](@ref).
""" RegisterMatrix(this::ByRef1{TGeoManager}, matrix::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoManager::RemoveMaterial(Int_t)
@trydoc raw"""
    RemoveMaterial(this::ByRef1{TGeoManager}, index::Int32)::Nothing
Remove material at given index.

""" RemoveMaterial(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::RemoveNavigator(const TGeoNavigator *)
@trydoc raw"""
    RemoveNavigator(this::ByRef1{TGeoManager}, nav::ByConstPtr1{TGeoNavigator})::Nothing
Clear a single navigator.

""" RemoveNavigator(this::ByRef1{TGeoManager}, nav::ByConstPtr1{TGeoNavigator})

# Wrapper of Int_t TGeoManager::ReplaceVolume(TGeoVolume *, TGeoVolume *)
@trydoc raw"""
    ReplaceVolume(this::ByRef1{TGeoManager}, vorig::ByPtr1{TGeoVolume}, vnew::ByPtr1{TGeoVolume})::Int32
Replaces all occurrences of VORIG with VNEW in the geometry tree.
The volume VORIG is not replaced from the list of volumes, but all node referencing it will reference VNEW instead. Returns number of occurrences changed.
""" ReplaceVolume(this::ByRef1{TGeoManager}, vorig::ByPtr1{TGeoVolume}, vnew::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::ResetState()
@trydoc raw"""
    ResetState(this::ByRef1{TGeoManager})::Nothing
Reset current state flags.

""" ResetState(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::ResetUserData()
@trydoc raw"""
    ResetUserData(this::ByRef1{TGeoManager})::Nothing
Sets all pointers [TGeoVolume!fField](@ref) to NULL.
User data becomes decoupled from geometry. Deletion has to be managed by users.
""" ResetUserData(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::RestoreMasterVolume()
@trydoc raw"""
    RestoreMasterVolume(this::ByRef1{TGeoManager})::Nothing
Restore the master volume of the geometry.

""" RestoreMasterVolume(this::ByRef1{TGeoManager})

# Wrapper of Double_t TGeoManager::Safety(Bool_t)
@trydoc raw"""
    Safety(this::ByRef1{TGeoManager}, inside::Bool)::Float64
Compute safe distance from the current point.
This represent the distance from POINT to the closest boundary.
""" Safety(this::ByRef1{TGeoManager}, inside::Bool)

# Wrapper of TGeoNode * TGeoManager::SamplePoints(Int_t, Double_t &, Double_t, const char *)
@trydoc raw"""
    SamplePoints(this::ByRef1{TGeoManager}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})::CxxPtr1{TGeoNode}
shoot npoints randomly in a box of 1E-5 around current point.
return minimum distance to points outside
""" SamplePoints(this::ByRef1{TGeoManager}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})

# Wrapper of void TGeoManager::SaveAttributes(const char *)
@trydoc raw"""
    SaveAttributes(this::ByRef1{TGeoManager}, filename::ByCopy{String})::Nothing
Save current attributes in a macro.

""" SaveAttributes(this::ByRef1{TGeoManager}, filename::ByCopy{String})

# Wrapper of TGeoNode * TGeoManager::SearchNode(Bool_t, const TGeoNode *)
@trydoc raw"""
    SearchNode(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})::CxxPtr1{TGeoNode}
Returns the deepest node containing fPoint, which must be set a priori.

""" SearchNode(this::ByRef1{TGeoManager}, downwards::Bool, skipnode::ByConstPtr1{TGeoNode})

# Wrapper of void TGeoManager::SelectTrackingMedia()
@trydoc raw"""
    SelectTrackingMedia(this::ByRef1{TGeoManager})::Nothing
Define different tracking media.

""" SelectTrackingMedia(this::ByRef1{TGeoManager})

# Wrapper of TGeoPNEntry * TGeoManager::SetAlignableEntry(const char *, const char *, Int_t)
@trydoc raw"""
    SetAlignableEntry(this::ByRef1{TGeoManager}, unique_name::ByCopy{String}, path::ByCopy{String}, uid::Int32)::CxxPtr1{TGeoPNEntry}
Creates an alignable object with unique name corresponding to a path and adds it to the list of alignables.
An optional unique ID can be provided, in which case PN entries can be searched fast by uid.
""" SetAlignableEntry(this::ByRef1{TGeoManager}, unique_name::ByCopy{String}, path::ByCopy{String}, uid::Int32)

# Wrapper of void TGeoManager::SetAllIndex()
@trydoc raw"""
    SetAllIndex(this::ByRef1{TGeoManager})::Nothing
Assigns uid's for all materials,media and matrices.

""" SetAllIndex(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::SetAnimateTracks(Bool_t)
@trydoc raw"""
    SetAnimateTracks(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetAnimateTracks(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetBombFactors(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetBombFactors(this::ByRef1{TGeoManager}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)::Nothing
Set factors that will "bomb" all translations in cartesian and cylindrical coordinates.

""" SetBombFactors(this::ByRef1{TGeoManager}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)

# Wrapper of void TGeoManager::SetCheckedNode(TGeoNode *)
@trydoc raw"""
    SetCheckedNode(this::ByRef1{TGeoManager}, node::ByPtr1{TGeoNode})::Nothing
Assign a given node to be checked for overlaps. Any other overlaps will be ignored.

""" SetCheckedNode(this::ByRef1{TGeoManager}, node::ByPtr1{TGeoNode})

# Wrapper of void TGeoManager::SetCheckingOverlaps(Bool_t)
@trydoc raw"""
    SetCheckingOverlaps(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetCheckingOverlaps(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetCldirChecked(Double_t *)
@trydoc raw"""
    SetCldirChecked(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})::Nothing


""" SetCldirChecked(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})

# Wrapper of void TGeoManager::SetClipping(Bool_t)
@trydoc raw"""
    SetClipping(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetClipping(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetClippingShape(TGeoShape *)
@trydoc raw"""
    SetClippingShape(this::ByRef1{TGeoManager}, clip::ByPtr1{TGeoShape})::Nothing
Set a user-defined shape as clipping for ray tracing.

""" SetClippingShape(this::ByRef1{TGeoManager}, clip::ByPtr1{TGeoShape})

# Wrapper of void TGeoManager::SetCurrentDirection(Double_t *)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoManager}, dir::ByPtr2{Float64})

# Wrapper of void TGeoManager::SetCurrentDirection(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentDirection(this::ByRef1{TGeoManager}, nx::Float64, ny::Float64, nz::Float64)::Nothing


""" SetCurrentDirection(this::ByRef1{TGeoManager}, nx::Float64, ny::Float64, nz::Float64)

# Wrapper of Bool_t TGeoManager::SetCurrentNavigator(Int_t)
@trydoc raw"""
    SetCurrentNavigator(this::ByRef1{TGeoManager}, index::Int32)::Bool
Switch to another existing navigator for the calling thread.

""" SetCurrentNavigator(this::ByRef1{TGeoManager}, index::Int32)

# Wrapper of void TGeoManager::SetCurrentPoint(Double_t *)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoManager}, point::ByPtr2{Float64})::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoManager}, point::ByPtr2{Float64})

# Wrapper of void TGeoManager::SetCurrentPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetCurrentPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoManager::SetCurrentTrack(Int_t)
@trydoc raw"""
    SetCurrentTrack(this::ByRef1{TGeoManager}, i::Int32)::Nothing


""" SetCurrentTrack(this::ByRef1{TGeoManager}, i::Int32)

# Wrapper of void TGeoManager::SetCurrentTrack(TVirtualGeoTrack *)
@trydoc raw"""
    SetCurrentTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})::Nothing


""" SetCurrentTrack(this::ByRef1{TGeoManager}, track::ByPtr1{TVirtualGeoTrack})

# Wrapper of void TGeoManager::SetDrawExtraPaths(Bool_t)
@trydoc raw"""
    SetDrawExtraPaths(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetDrawExtraPaths(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetExplodedView(Int_t)
@trydoc raw"""
    SetExplodedView(this::ByRef1{TGeoManager}, iopt::Int32)::Nothing
Set type of exploding view (see [TGeoPainter!SetExplodedView()](@ref))
""" SetExplodedView(this::ByRef1{TGeoManager}, iopt::Int32)

# Wrapper of void TGeoManager::SetLastPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetLastPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)::Nothing


""" SetLastPoint(this::ByRef1{TGeoManager}, x::Float64, y::Float64, z::Float64)

# Wrapper of void TGeoManager::SetMatrixReflection(Bool_t)
@trydoc raw"""
    SetMatrixReflection(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetMatrixReflection(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetMatrixTransform(Bool_t)
@trydoc raw"""
    SetMatrixTransform(this::ByRef1{TGeoManager}, on::Bool)::Nothing


""" SetMatrixTransform(this::ByRef1{TGeoManager}, on::Bool)

# Wrapper of void TGeoManager::SetMaxThreads(Int_t)
@trydoc raw"""
    SetMaxThreads(this::ByRef1{TGeoManager}, nthreads::Int32)::Nothing
Set maximum number of threads for navigation.

""" SetMaxThreads(this::ByRef1{TGeoManager}, nthreads::Int32)

# Wrapper of void TGeoManager::SetMaxVisNodes(Int_t)
@trydoc raw"""
    SetMaxVisNodes(this::ByRef1{TGeoManager}, maxnodes::Int32)::Nothing
set the maximum number of visible nodes.

""" SetMaxVisNodes(this::ByRef1{TGeoManager}, maxnodes::Int32)

# Wrapper of void TGeoManager::SetNmeshPoints(Int_t)
@trydoc raw"""
    SetNmeshPoints(this::ByRef1{TGeoManager}, npoints::Int32)::Nothing
Set the number of points to be generated on the shape outline when checking for overlaps.

""" SetNmeshPoints(this::ByRef1{TGeoManager}, npoints::Int32)

# Wrapper of void TGeoManager::SetNodeSelectable(Bool_t)
@trydoc raw"""
    SetNodeSelectable(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetNodeSelectable(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetNsegments(Int_t)
@trydoc raw"""
    SetNsegments(this::ByRef1{TGeoManager}, nseg::Int32)::Nothing
Set number of segments for approximating circles in drawing.

""" SetNsegments(this::ByRef1{TGeoManager}, nseg::Int32)

# Wrapper of void TGeoManager::SetOutside(Bool_t)
@trydoc raw"""
    SetOutside(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetOutside(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetPaintVolume(TGeoVolume *)
@trydoc raw"""
    SetPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::SetParticleName(const char *)
@trydoc raw"""
    SetParticleName(this::ByRef1{TGeoManager}, pname::ByCopy{String})::Nothing


""" SetParticleName(this::ByRef1{TGeoManager}, pname::ByCopy{String})

# Wrapper of void TGeoManager::SetPdgName(Int_t, const char *)
@trydoc raw"""
    SetPdgName(this::ByRef1{TGeoManager}, pdg::Int32, name::ByCopy{String})::Nothing
Set a name for a particle having a given pdg.

""" SetPdgName(this::ByRef1{TGeoManager}, pdg::Int32, name::ByCopy{String})

# Wrapper of void TGeoManager::SetPhiRange(Double_t, Double_t)
@trydoc raw"""
    SetPhiRange(this::ByRef1{TGeoManager}, phimin::Float64, phimax::Float64)::Nothing
Set cut phi range.

""" SetPhiRange(this::ByRef1{TGeoManager}, phimin::Float64, phimax::Float64)

# Wrapper of void TGeoManager::SetRTmode(Int_t)
@trydoc raw"""
    SetRTmode(this::ByRef1{TGeoManager}, mode::Int32)::Nothing
Change raytracing mode.

""" SetRTmode(this::ByRef1{TGeoManager}, mode::Int32)

# Wrapper of void TGeoManager::SetStartSafe(Bool_t)
@trydoc raw"""
    SetStartSafe(this::ByRef1{TGeoManager}, flag::Bool)::Nothing


""" SetStartSafe(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetStep(Double_t)
@trydoc raw"""
    SetStep(this::ByRef1{TGeoManager}, step::Float64)::Nothing


""" SetStep(this::ByRef1{TGeoManager}, step::Float64)

# Wrapper of void TGeoManager::SetTminTmax(Double_t, Double_t)
@trydoc raw"""
    SetTminTmax(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64)::Nothing
Set time cut interval for drawing tracks.
If called with no arguments, time cut will be disabled.
""" SetTminTmax(this::ByRef1{TGeoManager}, tmin::Float64, tmax::Float64)

# Wrapper of void TGeoManager::SetTopVisible(Bool_t)
@trydoc raw"""
    SetTopVisible(this::ByRef1{TGeoManager}, vis::Bool)::Nothing
make top volume visible on screen

""" SetTopVisible(this::ByRef1{TGeoManager}, vis::Bool)

# Wrapper of void TGeoManager::SetTopVolume(TGeoVolume *)
@trydoc raw"""
    SetTopVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})::Nothing
Set the top volume and corresponding node as starting point of the geometry.

""" SetTopVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::SetUseParallelWorldNav(Bool_t)
@trydoc raw"""
    SetUseParallelWorldNav(this::ByRef1{TGeoManager}, flag::Bool)::Nothing
Activate/deactivate usage of parallel world navigation.
Can only be done if there is a parallel world. Activating navigation will automatically close the parallel geometry.
""" SetUseParallelWorldNav(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetUserPaintVolume(TGeoVolume *)
@trydoc raw"""
    SetUserPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetUserPaintVolume(this::ByRef1{TGeoManager}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoManager::SetVisDensity(Double_t)
@trydoc raw"""
    SetVisDensity(this::ByRef1{TGeoManager}, dens::Float64)::Nothing
Set density threshold.
Volumes with densities lower than this become transparent.
""" SetVisDensity(this::ByRef1{TGeoManager}, dens::Float64)

# Wrapper of void TGeoManager::SetVisibility(TObject *, Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoManager}, obj::ByPtr1{TObject}, vis::Bool)::Nothing
Set visibility for a volume.

""" SetVisibility(this::ByRef1{TGeoManager}, obj::ByPtr1{TObject}, vis::Bool)

# Wrapper of void TGeoManager::SetVisLevel(Int_t)
@trydoc raw"""
    SetVisLevel(this::ByRef1{TGeoManager}, level::Int32)::Nothing
set default level down to which visualization is performed

""" SetVisLevel(this::ByRef1{TGeoManager}, level::Int32)

# Wrapper of void TGeoManager::SetVisOption(Int_t)
@trydoc raw"""
    SetVisOption(this::ByRef1{TGeoManager}, option::Int32)::Nothing
set drawing mode :
- option=0 (default) all nodes drawn down to vislevel
- option=1 leaves and nodes at vislevel drawn
- option=2 path is drawn
- option=4 visibility changed
""" SetVisOption(this::ByRef1{TGeoManager}, option::Int32)

# Wrapper of void TGeoManager::SetVolumeAttribute(const char *, const char *, Int_t)
@trydoc raw"""
    SetVolumeAttribute(this::ByRef1{TGeoManager}, name::ByCopy{String}, att::ByCopy{String}, val::Int32)::Nothing
Set volume attributes in G3 style.

""" SetVolumeAttribute(this::ByRef1{TGeoManager}, name::ByCopy{String}, att::ByCopy{String}, val::Int32)

# Wrapper of ULong_t TGeoManager::SizeOf(const TGeoNode *, Option_t *)
@trydoc raw"""
    SizeOf(this::ByRef1{TGeoManager}, node::ByConstPtr1{TGeoNode}, option::ByCopy{String})::UInt64
computes the total size in bytes of the branch starting with node.
The option can specify if all the branch has to be parsed or only the node
""" SizeOf(this::ByRef1{TGeoManager}, node::ByConstPtr1{TGeoNode}, option::ByCopy{String})

# Wrapper of void TGeoManager::SortOverlaps()
@trydoc raw"""
    SortOverlaps(this::ByRef1{TGeoManager})::Nothing
Sort overlaps by decreasing overlap distance. Extrusions comes first.

""" SortOverlaps(this::ByRef1{TGeoManager})

# Wrapper of TGeoNode * TGeoManager::Step(Bool_t, Bool_t)
@trydoc raw"""
    Step(this::ByRef1{TGeoManager}, is_geom::Bool, cross::Bool)::CxxPtr1{TGeoNode}
Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection).
If the step is imposed by geometry, is_geom flag must be true (default). The cross flag specifies if the boundary should be crossed in case of a geometry step (default true). Returns new node after step. Set also on boundary condition.
""" Step(this::ByRef1{TGeoManager}, is_geom::Bool, cross::Bool)

# Wrapper of void TGeoManager::Test(Int_t, Option_t *)
@trydoc raw"""
    Test(this::ByRef1{TGeoManager}, npoints::Int32, option::ByCopy{String})::Nothing
Check time of finding "Where am I" for n points.

""" Test(this::ByRef1{TGeoManager}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TGeoManager::TestOverlaps(const char *)
@trydoc raw"""
    TestOverlaps(this::ByRef1{TGeoManager}, path::ByCopy{String})::Nothing
Geometry overlap checker based on sampling.

""" TestOverlaps(this::ByRef1{TGeoManager}, path::ByCopy{String})

# Wrapper of void TGeoManager::TopToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    TopToMaster(this::ByConstRef1{TGeoManager}, top::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Convert coordinates from top volume frame to master.

""" TopToMaster(this::ByConstRef1{TGeoManager}, top::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of Int_t TGeoManager::TransformVolumeToAssembly(const char *)
@trydoc raw"""
    TransformVolumeToAssembly(this::ByRef1{TGeoManager}, vname::ByCopy{String})::Int32
Transform all volumes named VNAME to assemblies. The volumes must be virtual.

""" TransformVolumeToAssembly(this::ByRef1{TGeoManager}, vname::ByCopy{String})

# Wrapper of void TGeoManager::UnbombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    UnbombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing
Get the new 'unbombed' translation vector according current exploded view mode.

""" UnbombTranslation(this::ByRef1{TGeoManager}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of void TGeoManager::ViewLeaves(Bool_t)
@trydoc raw"""
    ViewLeaves(this::ByRef1{TGeoManager}, flag::Bool)::Nothing
Set visualization option (leaves only OR all volumes)

""" ViewLeaves(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of TGeoVolume * TGeoManager::Volume(const char *, const char *, Int_t, Double_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float64}, npar::Int32)

# Wrapper of TGeoVolume * TGeoManager::Volume(const char *, const char *, Int_t, Float_t *, Int_t)
@trydoc raw"""
    Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)::CxxPtr1{TGeoVolume}
Create a volume in GEANT3 style.
- NAME Volume name
- SHAPE Volume type
- NMED Tracking medium number
- NPAR Number of shape parameters
- UPAR Vector containing shape parameters
""" Volume(this::ByRef1{TGeoManager}, name::ByCopy{String}, shape::ByCopy{String}, nmed::Int32, upar::ByPtr2{Float32}, npar::Int32)

# Wrapper of Double_t TGeoManager::Weight(Double_t, Option_t *)
@trydoc raw"""
    Weight(this::ByRef1{TGeoManager}, precision::Float64, option::ByCopy{String})::Float64
Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.
Option can be "v" - verbose (default)
""" Weight(this::ByRef1{TGeoManager}, precision::Float64, option::ByCopy{String})

# Wrapper of void TGeoManager::ClearThreadsMap()
@trydoc raw"""
    TGeoManager!ClearThreadsMap(this::ByRef1{TGeoManager})::Nothing
Clear the current map of threads.
This will be filled again by the calling threads via ThreadId calls.
""" TGeoManager!ClearThreadsMap(this::ByRef1{TGeoManager})

# Wrapper of UInt_t TGeoManager::GetExportPrecision()
@trydoc raw"""
    TGeoManager!GetExportPrecision(this::ByRef1{TGeoManager})::UInt32


""" TGeoManager!GetExportPrecision(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetMaxDaughters()
@trydoc raw"""
    TGeoManager!GetMaxDaughters(this::ByRef1{TGeoManager})::Int32
Return maximum number of daughters of a volume used in the geometry.

""" TGeoManager!GetMaxDaughters(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetMaxLevels()
@trydoc raw"""
    TGeoManager!GetMaxLevels(this::ByRef1{TGeoManager})::Int32
Return maximum number of levels used in the geometry.

""" TGeoManager!GetMaxLevels(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetMaxXtruVert()
@trydoc raw"""
    TGeoManager!GetMaxXtruVert(this::ByRef1{TGeoManager})::Int32
Return maximum number of vertices for an xtru shape used.

""" TGeoManager!GetMaxXtruVert(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetNumThreads()
@trydoc raw"""
    TGeoManager!GetNumThreads(this::ByRef1{TGeoManager})::Int32
Returns number of threads that were set to use geometry.

""" TGeoManager!GetNumThreads(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::GetVerboseLevel()
@trydoc raw"""
    TGeoManager!GetVerboseLevel(this::ByRef1{TGeoManager})::Int32
Set verbosity level (static function).
- 0 - suppress messages related to geom-painter visibility level
- 1 - default value
""" TGeoManager!GetVerboseLevel(this::ByRef1{TGeoManager})

# Wrapper of TGeoManager * TGeoManager::Import(const char *, const char *, Option_t *)
@trydoc raw"""
    TGeoManager!Import(this::ByRef1{TGeoManager}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})::CxxPtr1{TGeoManager}
static function Import a geometry from a gdml or [ROOT](@ref) file
- Case 1: gdml if filename ends with ".gdml" the foreign geometry described with gdml is imported executing some python scripts in $ROOTSYS/gdml. NOTE that to use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml
- Case 2: root file (.root) or root/xml file (.xml) Import in memory from filename the geometry with key=name. if name="" (default), the first [TGeoManager](@ref) object in the file is returned.

Note that this function deletes the current gGeoManager (if one) before importing the new object.
""" TGeoManager!Import(this::ByRef1{TGeoManager}, filename::ByCopy{String}, name::ByCopy{String}, option::ByCopy{String})

# Wrapper of Bool_t TGeoManager::IsLocked()
@trydoc raw"""
    TGeoManager!IsLocked(this::ByRef1{TGeoManager})::Bool
Check lock state.

""" TGeoManager!IsLocked(this::ByRef1{TGeoManager})

# Wrapper of Bool_t TGeoManager::LockDefaultUnits(Bool_t)
@trydoc raw"""
    TGeoManager!LockDefaultUnits(this::ByRef1{TGeoManager}, new_value::Bool)::Bool


""" TGeoManager!LockDefaultUnits(this::ByRef1{TGeoManager}, new_value::Bool)

# Wrapper of void TGeoManager::LockGeometry()
@trydoc raw"""
    TGeoManager!LockGeometry(this::ByRef1{TGeoManager})::Nothing
Lock current geometry so that no other geometry can be imported.

""" TGeoManager!LockGeometry(this::ByRef1{TGeoManager})

# Wrapper of Int_t TGeoManager::Parse(const char *, TString &, TString &, TString &)
@trydoc raw"""
    TGeoManager!Parse(this::ByRef1{TGeoManager}, expr::ByCopy{String}, expr1::ByRef1{TString}, expr2::ByRef1{TString}, expr3::ByRef1{TString})::Int32
Parse a string boolean expression and do a syntax check.
Find top level boolean operator and returns its type. Fill the two substrings to which this operator applies. The returned integer is :

- -1 : parse error
- 0 : no boolean operator
- 1 : union - represented as '+' in expression
- 2 : difference (subtraction) - represented as '-' in expression
- 3 : intersection - represented as '*' in expression. Parentheses should be used to avoid ambiguities. For instance :
- A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C) eliminate not needed parentheses
""" TGeoManager!Parse(this::ByRef1{TGeoManager}, expr::ByCopy{String}, expr1::ByRef1{TString}, expr2::ByRef1{TString}, expr3::ByRef1{TString})

# Wrapper of void TGeoManager::SetExportPrecision(UInt_t)
@trydoc raw"""
    TGeoManager!SetExportPrecision(this::ByRef1{TGeoManager}, prec::UInt32)::Nothing


""" TGeoManager!SetExportPrecision(this::ByRef1{TGeoManager}, prec::UInt32)

# Wrapper of void TGeoManager::SetNavigatorsLock(Bool_t)
@trydoc raw"""
    TGeoManager!SetNavigatorsLock(this::ByRef1{TGeoManager}, flag::Bool)::Nothing
Set the lock for navigators.

""" TGeoManager!SetNavigatorsLock(this::ByRef1{TGeoManager}, flag::Bool)

# Wrapper of void TGeoManager::SetVerboseLevel(Int_t)
@trydoc raw"""
    TGeoManager!SetVerboseLevel(this::ByRef1{TGeoManager}, vl::Int32)::Nothing
Return current verbosity level (static function).

""" TGeoManager!SetVerboseLevel(this::ByRef1{TGeoManager}, vl::Int32)

# Wrapper of Int_t TGeoManager::ThreadId()
@trydoc raw"""
    TGeoManager!ThreadId(this::ByRef1{TGeoManager})::Int32
Translates the current thread id to an ordinal number.
This can be used to manage data which is specific for a given thread.
""" TGeoManager!ThreadId(this::ByRef1{TGeoManager})

# Wrapper of void TGeoManager::UnlockGeometry()
@trydoc raw"""
    TGeoManager!UnlockGeometry(this::ByRef1{TGeoManager})::Nothing
Unlock current geometry.

""" TGeoManager!UnlockGeometry(this::ByRef1{TGeoManager})

# Wrapper of bool TGeoMaterial::AddConstProperty(const char *, const char *)
@trydoc raw"""
    AddConstProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddConstProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of bool TGeoMaterial::AddProperty(const char *, const char *)
@trydoc raw"""
    AddProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddProperty(this::ByRef1{TGeoMaterial}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of TGeoMaterial * TGeoMaterial::DecayMaterial(Double_t, Double_t)
@trydoc raw"""
    DecayMaterial(this::ByRef1{TGeoMaterial}, time::Float64, precision::Float64)::CxxPtr1{TGeoMaterial}
Create the material representing the decay product of this material at a given time.
The precision represent the minimum cumulative branching ratio for which decay products are still taken into account.
""" DecayMaterial(this::ByRef1{TGeoMaterial}, time::Float64, precision::Float64)

# Wrapper of void TGeoMaterial::FillMaterialEvolution(TObjArray *, Double_t)
@trydoc raw"""
    FillMaterialEvolution(this::ByRef1{TGeoMaterial}, population::ByPtr1{TObjArray}, precision::Float64)::Nothing
Fills a user array with all the elements deriving from the possible decay of the top element composing the mixture.
Each element contained by `<population>` may be a radionuclide having a Bateman solution attached. The precision represent the minimum cumulative branching ratio for which decay products are still taken into account. To visualize the time evolution of each decay product one can use: 

    TGeoElement *elem = population->At(index);
    TGeoElementRN *elemrn = 0;
    if (elem->IsRadioNuclide()) elemrn = (TGeoElementRN*)elem;

(C++ version of the code)

 One can get Ni/N1(t=0) at any moment of time. Ni is the number of atoms of one of the decay products, N1(0) is the number of atoms of the top element at t=0. 

    Double_t fraction_weight = elemrn->Ratio()->Concentration(time);

(C++ version of the code)

 One can also display the time evolution of the fractional weight: 

    elemrn->Ratio()->Draw(option);

(C++ version of the code)
""" FillMaterialEvolution(this::ByRef1{TGeoMaterial}, population::ByPtr1{TObjArray}, precision::Float64)

# Wrapper of Double_t TGeoMaterial::GetA()
@trydoc raw"""
    GetA(this::ByConstRef1{TGeoMaterial})::Float64


""" GetA(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGeoElement * TGeoMaterial::GetBaseElement()
@trydoc raw"""
    GetBaseElement(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TGeoElement}


""" GetBaseElement(this::ByConstRef1{TGeoMaterial})

# Wrapper of Int_t TGeoMaterial::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoMaterial})::Int32


""" GetByteCount(this::ByConstRef1{TGeoMaterial})

# Wrapper of TObject * TGeoMaterial::GetCerenkovProperties()
@trydoc raw"""
    GetCerenkovProperties(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TObject}


""" GetCerenkovProperties(this::ByConstRef1{TGeoMaterial})

# Wrapper of Double_t TGeoMaterial::GetConstProperty(const char *, Bool_t *)
@trydoc raw"""
    GetConstProperty(this::ByConstRef1{TGeoMaterial}, property::ByCopy{String}, error::ByPtr2{Bool})::Float64


""" GetConstProperty(this::ByConstRef1{TGeoMaterial}, property::ByCopy{String}, error::ByPtr2{Bool})

# Wrapper of Double_t TGeoMaterial::GetConstProperty(Int_t, Bool_t *)
@trydoc raw"""
    GetConstProperty(this::ByConstRef1{TGeoMaterial}, i::Int32, error::ByPtr2{Bool})::Float64


""" GetConstProperty(this::ByConstRef1{TGeoMaterial}, i::Int32, error::ByPtr2{Bool})

# Wrapper of const char * TGeoMaterial::GetConstPropertyRef(const char *)
@trydoc raw"""
    GetConstPropertyRef(this::ByConstRef1{TGeoMaterial}, property::ByCopy{String})::ByCopy{String}


""" GetConstPropertyRef(this::ByConstRef1{TGeoMaterial}, property::ByCopy{String})

# Wrapper of const char * TGeoMaterial::GetConstPropertyRef(Int_t)
@trydoc raw"""
    GetConstPropertyRef(this::ByConstRef1{TGeoMaterial}, i::Int32)::ByCopy{String}


""" GetConstPropertyRef(this::ByConstRef1{TGeoMaterial}, i::Int32)

# Wrapper of Int_t TGeoMaterial::GetDefaultColor()
@trydoc raw"""
    GetDefaultColor(this::ByConstRef1{TGeoMaterial})::Int32
Get some default color related to this material.

""" GetDefaultColor(this::ByConstRef1{TGeoMaterial})

# Wrapper of Double_t TGeoMaterial::GetDensity()
@trydoc raw"""
    GetDensity(this::ByConstRef1{TGeoMaterial})::Float64


""" GetDensity(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGeoElement * TGeoMaterial::GetElement()
@trydoc raw"""
    GetElement(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TGeoElement}
Get a pointer to the element this material is made of.
This second call is to avoid warnings to not call a virtual method from the constructor
""" GetElement(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGeoElement * TGeoMaterial::GetElement(Int_t)
@trydoc raw"""
    GetElement(this::ByConstRef1{TGeoMaterial}, i::Int32)::CxxPtr1{TGeoElement}
Get a pointer to the element this material is made of.

""" GetElement(this::ByConstRef1{TGeoMaterial}, i::Int32)

# Wrapper of void TGeoMaterial::GetElementProp(Double_t &, Double_t &, Double_t &, Int_t)
@trydoc raw"""
    GetElementProp(this::ByRef1{TGeoMaterial}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)::Nothing
Single interface to get element properties.

""" GetElementProp(this::ByRef1{TGeoMaterial}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)

# Wrapper of TGeoExtension * TGeoMaterial::GetFWExtension()
@trydoc raw"""
    GetFWExtension(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TGeoExtension}


""" GetFWExtension(this::ByConstRef1{TGeoMaterial})

# Wrapper of Int_t TGeoMaterial::GetIndex()
@trydoc raw"""
    GetIndex(this::ByRef1{TGeoMaterial})::Int32
Retrieve material index in the list of materials.

""" GetIndex(this::ByRef1{TGeoMaterial})

# Wrapper of Double_t TGeoMaterial::GetIntLen()
@trydoc raw"""
    GetIntLen(this::ByConstRef1{TGeoMaterial})::Float64


""" GetIntLen(this::ByConstRef1{TGeoMaterial})

# Wrapper of Int_t TGeoMaterial::GetNconstProperties()
@trydoc raw"""
    GetNconstProperties(this::ByConstRef1{TGeoMaterial})::Int32


""" GetNconstProperties(this::ByConstRef1{TGeoMaterial})

# Wrapper of Int_t TGeoMaterial::GetNelements()
@trydoc raw"""
    GetNelements(this::ByConstRef1{TGeoMaterial})::Int32


""" GetNelements(this::ByConstRef1{TGeoMaterial})

# Wrapper of Int_t TGeoMaterial::GetNproperties()
@trydoc raw"""
    GetNproperties(this::ByConstRef1{TGeoMaterial})::Int32


""" GetNproperties(this::ByConstRef1{TGeoMaterial})

# Wrapper of const char * TGeoMaterial::GetPointerName()
@trydoc raw"""
    GetPointerName(this::ByConstRef1{TGeoMaterial})::ByCopy{String}
Provide a pointer name containing uid.

""" GetPointerName(this::ByConstRef1{TGeoMaterial})

# Wrapper of Double_t TGeoMaterial::GetPressure()
@trydoc raw"""
    GetPressure(this::ByConstRef1{TGeoMaterial})::Float64


""" GetPressure(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGDMLMatrix * TGeoMaterial::GetProperty(const char *)
@trydoc raw"""
    GetProperty(this::ByConstRef1{TGeoMaterial}, name::ByCopy{String})::CxxPtr1{TGDMLMatrix}


""" GetProperty(this::ByConstRef1{TGeoMaterial}, name::ByCopy{String})

# Wrapper of TGDMLMatrix * TGeoMaterial::GetProperty(Int_t)
@trydoc raw"""
    GetProperty(this::ByConstRef1{TGeoMaterial}, i::Int32)::CxxPtr1{TGDMLMatrix}


""" GetProperty(this::ByConstRef1{TGeoMaterial}, i::Int32)

# Wrapper of const char * TGeoMaterial::GetPropertyRef(const char *)
@trydoc raw"""
    GetPropertyRef(this::ByConstRef1{TGeoMaterial}, property::ByCopy{String})::ByCopy{String}


""" GetPropertyRef(this::ByConstRef1{TGeoMaterial}, property::ByCopy{String})

# Wrapper of const char * TGeoMaterial::GetPropertyRef(Int_t)
@trydoc raw"""
    GetPropertyRef(this::ByConstRef1{TGeoMaterial}, i::Int32)::ByCopy{String}


""" GetPropertyRef(this::ByConstRef1{TGeoMaterial}, i::Int32)

# Wrapper of Double_t TGeoMaterial::GetRadLen()
@trydoc raw"""
    GetRadLen(this::ByConstRef1{TGeoMaterial})::Float64


""" GetRadLen(this::ByConstRef1{TGeoMaterial})

# Wrapper of Double_t TGeoMaterial::GetSpecificActivity(Int_t)
@trydoc raw"""
    GetSpecificActivity(this::ByConstRef1{TGeoMaterial}, ::Int32)::Float64


""" GetSpecificActivity(this::ByConstRef1{TGeoMaterial}, ::Int32)

# Wrapper of Double_t TGeoMaterial::GetTemperature()
@trydoc raw"""
    GetTemperature(this::ByConstRef1{TGeoMaterial})::Float64


""" GetTemperature(this::ByConstRef1{TGeoMaterial})

# Wrapper of Char_t TGeoMaterial::GetTransparency()
@trydoc raw"""
    GetTransparency(this::ByConstRef1{TGeoMaterial})::Int8


""" GetTransparency(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGeoExtension * TGeoMaterial::GetUserExtension()
@trydoc raw"""
    GetUserExtension(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TGeoExtension}


""" GetUserExtension(this::ByConstRef1{TGeoMaterial})

# Wrapper of Double_t TGeoMaterial::GetZ()
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoMaterial})::Float64


""" GetZ(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGeoExtension * TGeoMaterial::GrabFWExtension()
@trydoc raw"""
    GrabFWExtension(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TGeoExtension}
Get a copy of the framework extension pointer.
The user must call Release() on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new())
""" GrabFWExtension(this::ByConstRef1{TGeoMaterial})

# Wrapper of TGeoExtension * TGeoMaterial::GrabUserExtension()
@trydoc raw"""
    GrabUserExtension(this::ByConstRef1{TGeoMaterial})::CxxPtr1{TGeoExtension}
Get a copy of the user extension pointer.
The user must call Release() on the copy pointer once this pointer is not needed anymore (equivalent to delete() after calling new())
""" GrabUserExtension(this::ByConstRef1{TGeoMaterial})

# Wrapper of Bool_t TGeoMaterial::IsEq(const TGeoMaterial *)
@trydoc raw"""
    IsEq(this::ByConstRef1{TGeoMaterial}, other::ByConstPtr1{TGeoMaterial})::Bool
return true if the other material has the same physical properties

""" IsEq(this::ByConstRef1{TGeoMaterial}, other::ByConstPtr1{TGeoMaterial})

# Wrapper of Bool_t TGeoMaterial::IsMixture()
@trydoc raw"""
    IsMixture(this::ByConstRef1{TGeoMaterial})::Bool


""" IsMixture(this::ByConstRef1{TGeoMaterial})

# Wrapper of Bool_t TGeoMaterial::IsUsed()
@trydoc raw"""
    IsUsed(this::ByConstRef1{TGeoMaterial})::Bool


""" IsUsed(this::ByConstRef1{TGeoMaterial})

# Wrapper of void TGeoMaterial::Print(const Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoMaterial}, option::ByCopy{String})::Nothing
print characteristics of this material

""" Print(this::ByConstRef1{TGeoMaterial}, option::ByCopy{String})

# Wrapper of void TGeoMaterial::SetA(Double_t)
@trydoc raw"""
    SetA(this::ByRef1{TGeoMaterial}, a::Float64)::Nothing


""" SetA(this::ByRef1{TGeoMaterial}, a::Float64)

# Wrapper of void TGeoMaterial::SetCerenkovProperties(TObject *)
@trydoc raw"""
    SetCerenkovProperties(this::ByRef1{TGeoMaterial}, cerenkov::ByPtr1{TObject})::Nothing


""" SetCerenkovProperties(this::ByRef1{TGeoMaterial}, cerenkov::ByPtr1{TObject})

# Wrapper of void TGeoMaterial::SetDensity(Double_t)
@trydoc raw"""
    SetDensity(this::ByRef1{TGeoMaterial}, density::Float64)::Nothing


""" SetDensity(this::ByRef1{TGeoMaterial}, density::Float64)

# Wrapper of void TGeoMaterial::SetFWExtension(TGeoExtension *)
@trydoc raw"""
    SetFWExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})::Nothing
Connect framework defined extension to the material.
The material "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for the use by TGeo and the users should NOT connect extensions using this method
""" SetFWExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoMaterial::SetIndex(Int_t)
@trydoc raw"""
    SetIndex(this::ByRef1{TGeoMaterial}, index::Int32)::Nothing


""" SetIndex(this::ByRef1{TGeoMaterial}, index::Int32)

# Wrapper of void TGeoMaterial::SetPressure(Double_t)
@trydoc raw"""
    SetPressure(this::ByRef1{TGeoMaterial}, pressure::Float64)::Nothing


""" SetPressure(this::ByRef1{TGeoMaterial}, pressure::Float64)

# Wrapper of void TGeoMaterial::SetRadLen(Double_t, Double_t)
@trydoc raw"""
    SetRadLen(this::ByRef1{TGeoMaterial}, radlen::Float64, intlen::Float64)::Nothing
Set radiation/absorption lengths.
If the values are negative, their absolute value is taken, otherwise radlen is recomputed using G3 formula.
""" SetRadLen(this::ByRef1{TGeoMaterial}, radlen::Float64, intlen::Float64)

# Wrapper of void TGeoMaterial::SetTemperature(Double_t)
@trydoc raw"""
    SetTemperature(this::ByRef1{TGeoMaterial}, temperature::Float64)::Nothing


""" SetTemperature(this::ByRef1{TGeoMaterial}, temperature::Float64)

# Wrapper of void TGeoMaterial::SetTransparency(Char_t)
@trydoc raw"""
    SetTransparency(this::ByRef1{TGeoMaterial}, transparency::Int8)::Nothing


""" SetTransparency(this::ByRef1{TGeoMaterial}, transparency::Int8)

# Wrapper of void TGeoMaterial::SetUsed(Bool_t)
@trydoc raw"""
    SetUsed(this::ByRef1{TGeoMaterial}, flag::Bool)::Nothing


""" SetUsed(this::ByRef1{TGeoMaterial}, flag::Bool)

# Wrapper of void TGeoMaterial::SetUserExtension(TGeoExtension *)
@trydoc raw"""
    SetUserExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})::Nothing
Connect user-defined extension to the material.
The material "grabs" a copy, so the original object can be released by the producer. Release the previously connected extension if any.

NOTE: This interface is intended for user extensions and is guaranteed not to be used by TGeo
""" SetUserExtension(this::ByRef1{TGeoMaterial}, ext::ByPtr1{TGeoExtension})

# Wrapper of void TGeoMaterial::SetZ(Double_t)
@trydoc raw"""
    SetZ(this::ByRef1{TGeoMaterial}, z::Float64)::Nothing


""" SetZ(this::ByRef1{TGeoMaterial}, z::Float64)

# Wrapper of Double_t TGeoMaterial::Coulomb(Double_t)
@trydoc raw"""
    TGeoMaterial!Coulomb(this::ByRef1{TGeoMaterial}, z::Float64)::Float64
static function Compute Coulomb correction for pair production and Brem REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78 FORMULA 2.7.17

""" TGeoMaterial!Coulomb(this::ByRef1{TGeoMaterial}, z::Float64)

# Wrapper of Double_t TGeoMaterial::ScreenFactor(Double_t)
@trydoc raw"""
    TGeoMaterial!ScreenFactor(this::ByRef1{TGeoMaterial}, z::Float64)::Float64
static function Compute screening factor for pair production and Bremsstrahlung REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78 FORMULA 2.7.22

""" TGeoMaterial!ScreenFactor(this::ByRef1{TGeoMaterial}, z::Float64)

# Wrapper of Int_t TGeoMedium::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoMedium})::Int32


""" GetByteCount(this::ByConstRef1{TGeoMedium})

# Wrapper of Int_t TGeoMedium::GetId()
@trydoc raw"""
    GetId(this::ByConstRef1{TGeoMedium})::Int32


""" GetId(this::ByConstRef1{TGeoMedium})

# Wrapper of TGeoMaterial * TGeoMedium::GetMaterial()
@trydoc raw"""
    GetMaterial(this::ByConstRef1{TGeoMedium})::CxxPtr1{TGeoMaterial}


""" GetMaterial(this::ByConstRef1{TGeoMedium})

# Wrapper of Double_t TGeoMedium::GetParam(Int_t)
@trydoc raw"""
    GetParam(this::ByConstRef1{TGeoMedium}, i::Int32)::Float64


""" GetParam(this::ByConstRef1{TGeoMedium}, i::Int32)

# Wrapper of const char * TGeoMedium::GetPointerName()
@trydoc raw"""
    GetPointerName(this::ByConstRef1{TGeoMedium})::ByCopy{String}
Provide a pointer name containing uid.

""" GetPointerName(this::ByConstRef1{TGeoMedium})

# Wrapper of void TGeoMedium::SetCerenkovProperties(TObject *)
@trydoc raw"""
    SetCerenkovProperties(this::ByRef1{TGeoMedium}, cerenkov::ByPtr1{TObject})::Nothing


""" SetCerenkovProperties(this::ByRef1{TGeoMedium}, cerenkov::ByPtr1{TObject})

# Wrapper of void TGeoMedium::SetId(Int_t)
@trydoc raw"""
    SetId(this::ByRef1{TGeoMedium}, id::Int32)::Nothing


""" SetId(this::ByRef1{TGeoMedium}, id::Int32)

# Wrapper of void TGeoMedium::SetMaterial(TGeoMaterial *)
@trydoc raw"""
    SetMaterial(this::ByRef1{TGeoMedium}, mat::ByPtr1{TGeoMaterial})::Nothing


""" SetMaterial(this::ByRef1{TGeoMedium}, mat::ByPtr1{TGeoMaterial})

# Wrapper of void TGeoMedium::SetParam(Int_t, Double_t)
@trydoc raw"""
    SetParam(this::ByRef1{TGeoMedium}, i::Int32, val::Float64)::Nothing


""" SetParam(this::ByRef1{TGeoMedium}, i::Int32, val::Float64)

# Wrapper of TGeoNode * TGeoVolumeAssembly::AddNode(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::CxxPtr1{TGeoNode}
Add a component to the assembly.

""" AddNode(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::AddNodeOverlap(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNodeOverlap(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::Nothing
Add an overlapping node - not allowed for assemblies.

""" AddNodeOverlap(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoVolumeAssembly})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoVolumeAssembly})

# Wrapper of TGeoVolume * TGeoVolumeAssembly::CloneVolume()
@trydoc raw"""
    CloneVolume(this::ByConstRef1{TGeoVolumeAssembly})::CxxPtr1{TGeoVolume}
Clone this volume.
build a volume with same name, shape and medium
""" CloneVolume(this::ByConstRef1{TGeoVolumeAssembly})

# Wrapper of void TGeoVolumeAssembly::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoVolumeAssembly}, nthreads::Int32)::Nothing


""" CreateThreadData(this::ByRef1{TGeoVolumeAssembly}, nthreads::Int32)

# Wrapper of TGeoVolume * TGeoVolumeAssembly::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolumeAssembly}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Division makes no sense for assemblies.

""" Divide(this::ByRef1{TGeoVolumeAssembly}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of TGeoVolume * TGeoVolumeAssembly::Divide(TGeoVolume *, TGeoPatternFinder *, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolumeAssembly}, cell::ByPtr1{TGeoVolume}, pattern::ByPtr1{TGeoPatternFinder}, option::ByCopy{String})::CxxPtr1{TGeoVolume}
Assign to the assembly a collection of identical volumes positioned according a predefined pattern.
The option can be spaced out or touching depending on the empty space between volumes.
""" Divide(this::ByRef1{TGeoVolumeAssembly}, cell::ByPtr1{TGeoVolume}, pattern::ByPtr1{TGeoPatternFinder}, option::ByCopy{String})

# Wrapper of void TGeoVolumeAssembly::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TGeoVolumeAssembly}, option::ByCopy{String})::Nothing
draw only this volume

""" DrawOnly(this::ByRef1{TGeoVolumeAssembly}, option::ByCopy{String})

# Wrapper of Int_t TGeoVolumeAssembly::GetCurrentNodeIndex()
@trydoc raw"""
    GetCurrentNodeIndex(this::ByConstRef1{TGeoVolumeAssembly})::Int32


""" GetCurrentNodeIndex(this::ByConstRef1{TGeoVolumeAssembly})

# Wrapper of Int_t TGeoVolumeAssembly::GetNextNodeIndex()
@trydoc raw"""
    GetNextNodeIndex(this::ByConstRef1{TGeoVolumeAssembly})::Int32


""" GetNextNodeIndex(this::ByConstRef1{TGeoVolumeAssembly})

# Wrapper of Bool_t TGeoVolumeAssembly::IsAssembly()
@trydoc raw"""
    IsAssembly(this::ByConstRef1{TGeoVolumeAssembly})::Bool
Returns true if the volume is an assembly or a scaled assembly.

""" IsAssembly(this::ByConstRef1{TGeoVolumeAssembly})

# Wrapper of Bool_t TGeoVolumeAssembly::IsVisible()
@trydoc raw"""
    IsVisible(this::ByConstRef1{TGeoVolumeAssembly})::Bool


""" IsVisible(this::ByConstRef1{TGeoVolumeAssembly})

# Wrapper of void TGeoVolumeAssembly::SetCurrentNodeIndex(Int_t)
@trydoc raw"""
    SetCurrentNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)::Nothing


""" SetCurrentNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)

# Wrapper of void TGeoVolumeAssembly::SetNextNodeIndex(Int_t)
@trydoc raw"""
    SetNextNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)::Nothing


""" SetNextNodeIndex(this::ByRef1{TGeoVolumeAssembly}, index::Int32)

# Wrapper of TGeoVolumeAssembly * TGeoVolumeAssembly::MakeAssemblyFromVolume(TGeoVolume *)
@trydoc raw"""
    TGeoVolumeAssembly!MakeAssemblyFromVolume(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume})::CxxPtr1{TGeoVolumeAssembly}
Make a clone of volume VOL but which is an assembly.

""" TGeoVolumeAssembly!MakeAssemblyFromVolume(this::ByRef1{TGeoVolumeAssembly}, vol::ByPtr1{TGeoVolume})

# Wrapper of TGeoNode * TGeoVolumeMulti::AddNode(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::CxxPtr1{TGeoNode}
Add a new node to the list of nodes.
This is the usual method for adding daughters inside the container volume.
""" AddNode(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeMulti::AddNodeOverlap(TGeoVolume *, Int_t, TGeoMatrix *, Option_t *)
@trydoc raw"""
    AddNodeOverlap(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})::Nothing
Add a new node to the list of nodes, This node is possibly overlapping with other daughters of the volume or extruding the volume.

""" AddNodeOverlap(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume}, copy_no::Int32, mat::ByPtr1{TGeoMatrix}, option::ByCopy{String})

# Wrapper of void TGeoVolumeMulti::AddVolume(TGeoVolume *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume})::Nothing
Add a volume with valid shape to the list of volumes.
Copy all existing nodes to this volume
""" AddVolume(this::ByRef1{TGeoVolumeMulti}, vol::ByPtr1{TGeoVolume})

# Wrapper of TGeoVolume * TGeoVolumeMulti::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *)
@trydoc raw"""
    Divide(this::ByRef1{TGeoVolumeMulti}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})::CxxPtr1{TGeoVolume}
division of multiple volumes

""" Divide(this::ByRef1{TGeoVolumeMulti}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64, numed::Int32, option::ByCopy{String})

# Wrapper of Int_t TGeoVolumeMulti::GetAxis()
@trydoc raw"""
    GetAxis(this::ByConstRef1{TGeoVolumeMulti})::Int32


""" GetAxis(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of TGeoShape * TGeoVolumeMulti::GetLastShape()
@trydoc raw"""
    GetLastShape(this::ByConstRef1{TGeoVolumeMulti})::CxxPtr1{TGeoShape}
Returns the last shape.

""" GetLastShape(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of Int_t TGeoVolumeMulti::GetNdiv()
@trydoc raw"""
    GetNdiv(this::ByConstRef1{TGeoVolumeMulti})::Int32


""" GetNdiv(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of Int_t TGeoVolumeMulti::GetNvolumes()
@trydoc raw"""
    GetNvolumes(this::ByConstRef1{TGeoVolumeMulti})::Int32


""" GetNvolumes(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of Double_t TGeoVolumeMulti::GetStart()
@trydoc raw"""
    GetStart(this::ByConstRef1{TGeoVolumeMulti})::Float64


""" GetStart(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of Double_t TGeoVolumeMulti::GetStep()
@trydoc raw"""
    GetStep(this::ByConstRef1{TGeoVolumeMulti})::Float64


""" GetStep(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of TGeoVolume * TGeoVolumeMulti::GetVolume(Int_t)
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoVolumeMulti}, id::Int32)::CxxPtr1{TGeoVolume}


""" GetVolume(this::ByConstRef1{TGeoVolumeMulti}, id::Int32)

# Wrapper of Bool_t TGeoVolumeMulti::IsVolumeMulti()
@trydoc raw"""
    IsVolumeMulti(this::ByConstRef1{TGeoVolumeMulti})::Bool


""" IsVolumeMulti(this::ByConstRef1{TGeoVolumeMulti})

# Wrapper of TGeoVolume * TGeoVolumeMulti::MakeCopyVolume(TGeoShape *)
@trydoc raw"""
    MakeCopyVolume(this::ByRef1{TGeoVolumeMulti}, newshape::ByPtr1{TGeoShape})::CxxPtr1{TGeoVolume}
Make a copy of this volume build a volume with same name, shape and medium.

""" MakeCopyVolume(this::ByRef1{TGeoVolumeMulti}, newshape::ByPtr1{TGeoShape})

# Wrapper of void TGeoVolumeMulti::SetLineColor(Color_t)
@trydoc raw"""
    SetLineColor(this::ByRef1{TGeoVolumeMulti}, lcolor::Int16)::Nothing
Set the line color for all components.

""" SetLineColor(this::ByRef1{TGeoVolumeMulti}, lcolor::Int16)

# Wrapper of void TGeoVolumeMulti::SetLineStyle(Style_t)
@trydoc raw"""
    SetLineStyle(this::ByRef1{TGeoVolumeMulti}, lstyle::Int16)::Nothing
Set the line style for all components.

""" SetLineStyle(this::ByRef1{TGeoVolumeMulti}, lstyle::Int16)

# Wrapper of void TGeoVolumeMulti::SetLineWidth(Width_t)
@trydoc raw"""
    SetLineWidth(this::ByRef1{TGeoVolumeMulti}, lwidth::Int16)::Nothing
Set the line width for all components.

""" SetLineWidth(this::ByRef1{TGeoVolumeMulti}, lwidth::Int16)

# Wrapper of void TGeoVolumeMulti::SetMedium(TGeoMedium *)
@trydoc raw"""
    SetMedium(this::ByRef1{TGeoVolumeMulti}, medium::ByPtr1{TGeoMedium})::Nothing
Set medium for a multiple volume.

""" SetMedium(this::ByRef1{TGeoVolumeMulti}, medium::ByPtr1{TGeoMedium})

# Wrapper of void TGeoVolumeMulti::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoVolumeMulti}, vis::Bool)::Nothing
Set visibility for all components.

""" SetVisibility(this::ByRef1{TGeoVolumeMulti}, vis::Bool)

# Wrapper of Double_t TGeoElement::A()
@trydoc raw"""
    A(this::ByConstRef1{TGeoElement})::Float64


""" A(this::ByConstRef1{TGeoElement})

# Wrapper of void TGeoElement::AddIsotope(TGeoIsotope *, Double_t)
@trydoc raw"""
    AddIsotope(this::ByRef1{TGeoElement}, isotope::ByPtr1{TGeoIsotope}, relativeAbundance::Float64)::Nothing
Add an isotope for this element. All isotopes have to be isotopes of the same element.

""" AddIsotope(this::ByRef1{TGeoElement}, isotope::ByPtr1{TGeoIsotope}, relativeAbundance::Float64)

# Wrapper of void TGeoElement::ComputeDerivedQuantities()
@trydoc raw"""
    ComputeDerivedQuantities(this::ByRef1{TGeoElement})::Nothing
Calculate properties for an atomic number.

""" ComputeDerivedQuantities(this::ByRef1{TGeoElement})

# Wrapper of Int_t TGeoElement::ENDFCode()
@trydoc raw"""
    ENDFCode(this::ByConstRef1{TGeoElement})::Int32


""" ENDFCode(this::ByConstRef1{TGeoElement})

# Wrapper of Double_t TGeoElement::GetfCoulomb()
@trydoc raw"""
    GetfCoulomb(this::ByConstRef1{TGeoElement})::Float64


""" GetfCoulomb(this::ByConstRef1{TGeoElement})

# Wrapper of Double_t TGeoElement::GetfRadTsai()
@trydoc raw"""
    GetfRadTsai(this::ByConstRef1{TGeoElement})::Float64


""" GetfRadTsai(this::ByConstRef1{TGeoElement})

# Wrapper of TGeoIsotope * TGeoElement::GetIsotope(Int_t)
@trydoc raw"""
    GetIsotope(this::ByConstRef1{TGeoElement}, i::Int32)::CxxPtr1{TGeoIsotope}
Return i-th isotope in the element.

""" GetIsotope(this::ByConstRef1{TGeoElement}, i::Int32)

# Wrapper of Int_t TGeoElement::GetNisotopes()
@trydoc raw"""
    GetNisotopes(this::ByConstRef1{TGeoElement})::Int32


""" GetNisotopes(this::ByConstRef1{TGeoElement})

# Wrapper of Double_t TGeoElement::GetRelativeAbundance(Int_t)
@trydoc raw"""
    GetRelativeAbundance(this::ByConstRef1{TGeoElement}, i::Int32)::Float64
Return relative abundance of i-th isotope in this element.

""" GetRelativeAbundance(this::ByConstRef1{TGeoElement}, i::Int32)

# Wrapper of Double_t TGeoElement::GetSpecificActivity()
@trydoc raw"""
    GetSpecificActivity(this::ByConstRef1{TGeoElement})::Float64


""" GetSpecificActivity(this::ByConstRef1{TGeoElement})

# Wrapper of Bool_t TGeoElement::HasIsotopes()
@trydoc raw"""
    HasIsotopes(this::ByConstRef1{TGeoElement})::Bool


""" HasIsotopes(this::ByConstRef1{TGeoElement})

# Wrapper of Bool_t TGeoElement::IsDefined()
@trydoc raw"""
    IsDefined(this::ByConstRef1{TGeoElement})::Bool


""" IsDefined(this::ByConstRef1{TGeoElement})

# Wrapper of Bool_t TGeoElement::IsRadioNuclide()
@trydoc raw"""
    IsRadioNuclide(this::ByConstRef1{TGeoElement})::Bool


""" IsRadioNuclide(this::ByConstRef1{TGeoElement})

# Wrapper of Bool_t TGeoElement::IsUsed()
@trydoc raw"""
    IsUsed(this::ByConstRef1{TGeoElement})::Bool


""" IsUsed(this::ByConstRef1{TGeoElement})

# Wrapper of Int_t TGeoElement::N()
@trydoc raw"""
    N(this::ByConstRef1{TGeoElement})::Int32


""" N(this::ByConstRef1{TGeoElement})

# Wrapper of Double_t TGeoElement::Neff()
@trydoc raw"""
    Neff(this::ByConstRef1{TGeoElement})::Float64
Returns effective number of nucleons.

""" Neff(this::ByConstRef1{TGeoElement})

# Wrapper of void TGeoElement::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoElement}, option::ByCopy{String})::Nothing
Print this isotope.

""" Print(this::ByConstRef1{TGeoElement}, option::ByCopy{String})

# Wrapper of void TGeoElement::SetDefined(Bool_t)
@trydoc raw"""
    SetDefined(this::ByRef1{TGeoElement}, flag::Bool)::Nothing


""" SetDefined(this::ByRef1{TGeoElement}, flag::Bool)

# Wrapper of void TGeoElement::SetUsed(Bool_t)
@trydoc raw"""
    SetUsed(this::ByRef1{TGeoElement}, flag::Bool)::Nothing


""" SetUsed(this::ByRef1{TGeoElement}, flag::Bool)

# Wrapper of Int_t TGeoElement::Z()
@trydoc raw"""
    Z(this::ByConstRef1{TGeoElement})::Int32


""" Z(this::ByConstRef1{TGeoElement})

# Wrapper of TGeoElementTable * TGeoElement::GetElementTable()
@trydoc raw"""
    TGeoElement!GetElementTable(this::ByRef1{TGeoElement})::CxxPtr1{TGeoElementTable}
Returns pointer to the table.

""" TGeoElement!GetElementTable(this::ByRef1{TGeoElement})

# Wrapper of Double_t TGeoIsotope::GetA()
@trydoc raw"""
    GetA(this::ByConstRef1{TGeoIsotope})::Float64


""" GetA(this::ByConstRef1{TGeoIsotope})

# Wrapper of Int_t TGeoIsotope::GetN()
@trydoc raw"""
    GetN(this::ByConstRef1{TGeoIsotope})::Int32


""" GetN(this::ByConstRef1{TGeoIsotope})

# Wrapper of Int_t TGeoIsotope::GetZ()
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoIsotope})::Int32


""" GetZ(this::ByConstRef1{TGeoIsotope})

# Wrapper of void TGeoIsotope::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoIsotope}, option::ByCopy{String})::Nothing
Print this isotope.

""" Print(this::ByConstRef1{TGeoIsotope}, option::ByCopy{String})

# Wrapper of TGeoIsotope * TGeoIsotope::FindIsotope(const char *)
@trydoc raw"""
    TGeoIsotope!FindIsotope(this::ByRef1{TGeoIsotope}, name::ByCopy{String})::CxxPtr1{TGeoIsotope}
Find existing isotope by name.

""" TGeoIsotope!FindIsotope(this::ByRef1{TGeoIsotope}, name::ByCopy{String})

# Wrapper of void TGeoElementTable::AddElement(const char *, const char *, Int_t, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, a::Float64)::Nothing
Add an element to the table. Obsolete.

""" AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, a::Float64)

# Wrapper of void TGeoElementTable::AddElement(const char *, const char *, Int_t, Int_t, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, n::Int32, a::Float64)::Nothing
Add an element to the table.

""" AddElement(this::ByRef1{TGeoElementTable}, name::ByCopy{String}, title::ByCopy{String}, z::Int32, n::Int32, a::Float64)

# Wrapper of void TGeoElementTable::AddElement(TGeoElement *)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElement})::Nothing
Add a custom element to the table.

""" AddElement(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElement})

# Wrapper of void TGeoElementTable::AddElementRN(TGeoElementRN *)
@trydoc raw"""
    AddElementRN(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElementRN})::Nothing
Add a radionuclide to the table and map it.

""" AddElementRN(this::ByRef1{TGeoElementTable}, elem::ByPtr1{TGeoElementRN})

# Wrapper of void TGeoElementTable::AddIsotope(TGeoIsotope *)
@trydoc raw"""
    AddIsotope(this::ByRef1{TGeoElementTable}, isotope::ByPtr1{TGeoIsotope})::Nothing
Add isotope to the table.

""" AddIsotope(this::ByRef1{TGeoElementTable}, isotope::ByPtr1{TGeoIsotope})

# Wrapper of void TGeoElementTable::BuildDefaultElements()
@trydoc raw"""
    BuildDefaultElements(this::ByRef1{TGeoElementTable})::Nothing
Creates the default element table.

""" BuildDefaultElements(this::ByRef1{TGeoElementTable})

# Wrapper of Bool_t TGeoElementTable::CheckTable()
@trydoc raw"""
    CheckTable(this::ByConstRef1{TGeoElementTable})::Bool
Checks status of element table.

""" CheckTable(this::ByConstRef1{TGeoElementTable})

# Wrapper of void TGeoElementTable::ExportElementsRN(const char *)
@trydoc raw"""
    ExportElementsRN(this::ByRef1{TGeoElementTable}, filename::ByCopy{String})::Nothing
Export radionuclides in a file.

""" ExportElementsRN(this::ByRef1{TGeoElementTable}, filename::ByCopy{String})

# Wrapper of TGeoElement * TGeoElementTable::FindElement(const char *)
@trydoc raw"""
    FindElement(this::ByConstRef1{TGeoElementTable}, name::ByCopy{String})::CxxPtr1{TGeoElement}
Search an element by symbol or full name Exact matching.

""" FindElement(this::ByConstRef1{TGeoElementTable}, name::ByCopy{String})

# Wrapper of TGeoIsotope * TGeoElementTable::FindIsotope(const char *)
@trydoc raw"""
    FindIsotope(this::ByConstRef1{TGeoElementTable}, name::ByCopy{String})::CxxPtr1{TGeoIsotope}
Find existing isotope by name. Not optimized for a big number of isotopes.

""" FindIsotope(this::ByConstRef1{TGeoElementTable}, name::ByCopy{String})

# Wrapper of TGeoElement * TGeoElementTable::GetElement(Int_t)
@trydoc raw"""
    GetElement(this::ByRef1{TGeoElementTable}, z::Int32)::CxxPtr1{TGeoElement}


""" GetElement(this::ByRef1{TGeoElementTable}, z::Int32)

# Wrapper of TGeoElementRN * TGeoElementTable::GetElementRN(Int_t, Int_t, Int_t)
@trydoc raw"""
    GetElementRN(this::ByConstRef1{TGeoElementTable}, a::Int32, z::Int32, iso::Int32)::CxxPtr1{TGeoElementRN}
Retrieve a radionuclide by a, z, and isomeric state.

""" GetElementRN(this::ByConstRef1{TGeoElementTable}, a::Int32, z::Int32, iso::Int32)

# Wrapper of TGeoElementRN * TGeoElementTable::GetElementRN(Int_t)
@trydoc raw"""
    GetElementRN(this::ByConstRef1{TGeoElementTable}, ENDFcode::Int32)::CxxPtr1{TGeoElementRN}
Retrieve a radionuclide by ENDF code.

""" GetElementRN(this::ByConstRef1{TGeoElementTable}, ENDFcode::Int32)

# Wrapper of TObjArray * TGeoElementTable::GetElementsRN()
@trydoc raw"""
    GetElementsRN(this::ByConstRef1{TGeoElementTable})::CxxPtr1{TObjArray}


""" GetElementsRN(this::ByConstRef1{TGeoElementTable})

# Wrapper of Int_t TGeoElementTable::GetNelements()
@trydoc raw"""
    GetNelements(this::ByConstRef1{TGeoElementTable})::Int32


""" GetNelements(this::ByConstRef1{TGeoElementTable})

# Wrapper of Int_t TGeoElementTable::GetNelementsRN()
@trydoc raw"""
    GetNelementsRN(this::ByConstRef1{TGeoElementTable})::Int32


""" GetNelementsRN(this::ByConstRef1{TGeoElementTable})

# Wrapper of Bool_t TGeoElementTable::HasDefaultElements()
@trydoc raw"""
    HasDefaultElements(this::ByConstRef1{TGeoElementTable})::Bool


""" HasDefaultElements(this::ByConstRef1{TGeoElementTable})

# Wrapper of Bool_t TGeoElementTable::HasRNElements()
@trydoc raw"""
    HasRNElements(this::ByConstRef1{TGeoElementTable})::Bool


""" HasRNElements(this::ByConstRef1{TGeoElementTable})

# Wrapper of void TGeoElementTable::ImportElementsRN()
@trydoc raw"""
    ImportElementsRN(this::ByRef1{TGeoElementTable})::Nothing
Creates the list of radionuclides.

""" ImportElementsRN(this::ByRef1{TGeoElementTable})

# Wrapper of void TGeoElementTable::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoElementTable}, option::ByCopy{String})::Nothing
Print table of elements.
The accepted options are: "" - prints everything by default "D" - prints default elements only "I" - prints isotopes "R" - prints radio-nuclides only if imported "U" - prints user-defined elements only
""" Print(this::ByConstRef1{TGeoElementTable}, option::ByCopy{String})

# Wrapper of void TGeoElementRN::AddDecay(Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    AddDecay(this::ByRef1{TGeoElementRN}, decay::Int32, diso::Int32, branchingRatio::Float64, qValue::Float64)::Nothing
Adds a decay mode for this element.

""" AddDecay(this::ByRef1{TGeoElementRN}, decay::Int32, diso::Int32, branchingRatio::Float64, qValue::Float64)

# Wrapper of void TGeoElementRN::AddDecay(TGeoDecayChannel *)
@trydoc raw"""
    AddDecay(this::ByRef1{TGeoElementRN}, dc::ByPtr1{TGeoDecayChannel})::Nothing
Adds a decay channel to the list of decays.

""" AddDecay(this::ByRef1{TGeoElementRN}, dc::ByPtr1{TGeoDecayChannel})

# Wrapper of void TGeoElementRN::AddRatio(TGeoBatemanSol &)
@trydoc raw"""
    AddRatio(this::ByRef1{TGeoElementRN}, ratio::ByRef1{TGeoBatemanSol})::Nothing
Adds a proportion ratio to the existing one.

""" AddRatio(this::ByRef1{TGeoElementRN}, ratio::ByRef1{TGeoBatemanSol})

# Wrapper of Int_t TGeoElementRN::AtomicNo()
@trydoc raw"""
    AtomicNo(this::ByConstRef1{TGeoElementRN})::Int32


""" AtomicNo(this::ByConstRef1{TGeoElementRN})

# Wrapper of Bool_t TGeoElementRN::CheckDecays()
@trydoc raw"""
    CheckDecays(this::ByConstRef1{TGeoElementRN})::Bool
Check if all decay chain of the element is OK.

""" CheckDecays(this::ByConstRef1{TGeoElementRN})

# Wrapper of Int_t TGeoElementRN::DecayResult(TGeoDecayChannel *)
@trydoc raw"""
    DecayResult(this::ByConstRef1{TGeoElementRN}, dc::ByPtr1{TGeoDecayChannel})::Int32
Returns ENDF code of decay result.

""" DecayResult(this::ByConstRef1{TGeoElementRN}, dc::ByPtr1{TGeoDecayChannel})

# Wrapper of TObjArray * TGeoElementRN::Decays()
@trydoc raw"""
    Decays(this::ByConstRef1{TGeoElementRN})::CxxPtr1{TObjArray}


""" Decays(this::ByConstRef1{TGeoElementRN})

# Wrapper of Int_t TGeoElementRN::ENDFCode()
@trydoc raw"""
    ENDFCode(this::ByConstRef1{TGeoElementRN})::Int32


""" ENDFCode(this::ByConstRef1{TGeoElementRN})

# Wrapper of void TGeoElementRN::FillPopulation(TObjArray *, Double_t, Double_t)
@trydoc raw"""
    FillPopulation(this::ByRef1{TGeoElementRN}, population::ByPtr1{TObjArray}, precision::Float64, factor::Float64)::Nothing
Fills the input array with the set of RN elements resulting from the decay of this one.
All element in the list will contain the time evolution of their proportion by number with respect to this element. The proportion can be retrieved via the method [TGeoElementRN!Ratio()](@ref). The precision represent the minimum cumulative branching ratio for which decay products are still taken into account.
""" FillPopulation(this::ByRef1{TGeoElementRN}, population::ByPtr1{TObjArray}, precision::Float64, factor::Float64)

# Wrapper of Int_t TGeoElementRN::GetNdecays()
@trydoc raw"""
    GetNdecays(this::ByConstRef1{TGeoElementRN})::Int32
Get number of decay channels of this element.

""" GetNdecays(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::GetSpecificActivity()
@trydoc raw"""
    GetSpecificActivity(this::ByConstRef1{TGeoElementRN})::Float64
Get the activity in Bq of a gram of material made from this element.

""" GetSpecificActivity(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::HalfLife()
@trydoc raw"""
    HalfLife(this::ByConstRef1{TGeoElementRN})::Float64


""" HalfLife(this::ByConstRef1{TGeoElementRN})

# Wrapper of Int_t TGeoElementRN::IsoNo()
@trydoc raw"""
    IsoNo(this::ByConstRef1{TGeoElementRN})::Int32


""" IsoNo(this::ByConstRef1{TGeoElementRN})

# Wrapper of Bool_t TGeoElementRN::IsRadioNuclide()
@trydoc raw"""
    IsRadioNuclide(this::ByConstRef1{TGeoElementRN})::Bool


""" IsRadioNuclide(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::Level()
@trydoc raw"""
    Level(this::ByConstRef1{TGeoElementRN})::Float64


""" Level(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::MassEx()
@trydoc raw"""
    MassEx(this::ByConstRef1{TGeoElementRN})::Float64


""" MassEx(this::ByConstRef1{TGeoElementRN})

# Wrapper of Int_t TGeoElementRN::MassNo()
@trydoc raw"""
    MassNo(this::ByConstRef1{TGeoElementRN})::Int32


""" MassNo(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::NatAbun()
@trydoc raw"""
    NatAbun(this::ByConstRef1{TGeoElementRN})::Float64


""" NatAbun(this::ByConstRef1{TGeoElementRN})

# Wrapper of const char * TGeoElementRN::PJ()
@trydoc raw"""
    PJ(this::ByConstRef1{TGeoElementRN})::ByCopy{String}


""" PJ(this::ByConstRef1{TGeoElementRN})

# Wrapper of void TGeoElementRN::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoElementRN}, option::ByCopy{String})::Nothing
Print info about the element;.

""" Print(this::ByConstRef1{TGeoElementRN}, option::ByCopy{String})

# Wrapper of TGeoBatemanSol * TGeoElementRN::Ratio()
@trydoc raw"""
    Ratio(this::ByConstRef1{TGeoElementRN})::CxxPtr1{TGeoBatemanSol}


""" Ratio(this::ByConstRef1{TGeoElementRN})

# Wrapper of void TGeoElementRN::ResetRatio()
@trydoc raw"""
    ResetRatio(this::ByRef1{TGeoElementRN})::Nothing
Clears the existing ratio.

""" ResetRatio(this::ByRef1{TGeoElementRN})

# Wrapper of Bool_t TGeoElementRN::Stable()
@trydoc raw"""
    Stable(this::ByConstRef1{TGeoElementRN})::Bool


""" Stable(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::Status()
@trydoc raw"""
    Status(this::ByConstRef1{TGeoElementRN})::Float64


""" Status(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::TG_F()
@trydoc raw"""
    TG_F(this::ByConstRef1{TGeoElementRN})::Float64


""" TG_F(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::TG_S()
@trydoc raw"""
    TG_S(this::ByConstRef1{TGeoElementRN})::Float64


""" TG_S(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::TH_F()
@trydoc raw"""
    TH_F(this::ByConstRef1{TGeoElementRN})::Float64


""" TH_F(this::ByConstRef1{TGeoElementRN})

# Wrapper of Double_t TGeoElementRN::TH_S()
@trydoc raw"""
    TH_S(this::ByConstRef1{TGeoElementRN})::Float64


""" TH_S(this::ByConstRef1{TGeoElementRN})

# Wrapper of Int_t TGeoElementRN::ENDF(Int_t, Int_t, Int_t)
@trydoc raw"""
    TGeoElementRN!ENDF(this::ByRef1{TGeoElementRN}, a::Int32, z::Int32, iso::Int32)::Int32


""" TGeoElementRN!ENDF(this::ByRef1{TGeoElementRN}, a::Int32, z::Int32, iso::Int32)

# Wrapper of TGeoElementRN * TGeoElementRN::ReadElementRN(const char *, Int_t &)
@trydoc raw"""
    TGeoElementRN!ReadElementRN(this::ByRef1{TGeoElementRN}, record::ByCopy{String}, ndecays::ByRef2{Int32})::CxxPtr1{TGeoElementRN}
Create element from line record.

""" TGeoElementRN!ReadElementRN(this::ByRef1{TGeoElementRN}, record::ByCopy{String}, ndecays::ByRef2{Int32})

# Wrapper of Double_t TGeoDecayChannel::BranchingRatio()
@trydoc raw"""
    BranchingRatio(this::ByConstRef1{TGeoDecayChannel})::Float64


""" BranchingRatio(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of TGeoElementRN * TGeoDecayChannel::Daughter()
@trydoc raw"""
    Daughter(this::ByConstRef1{TGeoDecayChannel})::CxxPtr1{TGeoElementRN}


""" Daughter(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of UInt_t TGeoDecayChannel::Decay()
@trydoc raw"""
    Decay(this::ByConstRef1{TGeoDecayChannel})::UInt32


""" Decay(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of void TGeoDecayChannel::DecayShift(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    DecayShift(this::ByConstRef1{TGeoDecayChannel}, dA::ByRef2{Int32}, dZ::ByRef2{Int32}, dI::ByRef2{Int32})::Nothing
Returns variation in A, Z and Iso after decay.

""" DecayShift(this::ByConstRef1{TGeoDecayChannel}, dA::ByRef2{Int32}, dZ::ByRef2{Int32}, dI::ByRef2{Int32})

# Wrapper of Int_t TGeoDecayChannel::DeltaIso()
@trydoc raw"""
    DeltaIso(this::ByConstRef1{TGeoDecayChannel})::Int32


""" DeltaIso(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of Int_t TGeoDecayChannel::GetIndex()
@trydoc raw"""
    GetIndex(this::ByConstRef1{TGeoDecayChannel})::Int32
Get index of this channel in the list of decays of the parent nuclide.

""" GetIndex(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of const char * TGeoDecayChannel::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TGeoDecayChannel})::ByCopy{String}
Returns name of decay.

""" GetName(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of TGeoDecayChannel & TGeoDecayChannel::operator=(const TGeoDecayChannel &)
@trydoc raw"""
    assign(this::ByRef1{TGeoDecayChannel}, dc::ByConstRef1{TGeoDecayChannel})::CxxRef1{TGeoDecayChannel}
Assignment.
assignment operator
""" assign(this::ByRef1{TGeoDecayChannel}, dc::ByConstRef1{TGeoDecayChannel})

# Wrapper of TGeoElementRN * TGeoDecayChannel::Parent()
@trydoc raw"""
    Parent(this::ByConstRef1{TGeoDecayChannel})::CxxPtr1{TGeoElementRN}


""" Parent(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of void TGeoDecayChannel::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoDecayChannel}, opt::ByCopy{String})::Nothing
Prints decay info.

""" Print(this::ByConstRef1{TGeoDecayChannel}, opt::ByCopy{String})

# Wrapper of Double_t TGeoDecayChannel::Qvalue()
@trydoc raw"""
    Qvalue(this::ByConstRef1{TGeoDecayChannel})::Float64


""" Qvalue(this::ByConstRef1{TGeoDecayChannel})

# Wrapper of void TGeoDecayChannel::SetDaughter(TGeoElementRN *)
@trydoc raw"""
    SetDaughter(this::ByRef1{TGeoDecayChannel}, daughter::ByPtr1{TGeoElementRN})::Nothing


""" SetDaughter(this::ByRef1{TGeoDecayChannel}, daughter::ByPtr1{TGeoElementRN})

# Wrapper of void TGeoDecayChannel::SetParent(TGeoElementRN *)
@trydoc raw"""
    SetParent(this::ByRef1{TGeoDecayChannel}, parent::ByPtr1{TGeoElementRN})::Nothing


""" SetParent(this::ByRef1{TGeoDecayChannel}, parent::ByPtr1{TGeoElementRN})

# Wrapper of void TGeoDecayChannel::DecayName(UInt_t, TString &)
@trydoc raw"""
    TGeoDecayChannel!DecayName(this::ByRef1{TGeoDecayChannel}, decay::UInt32, name::ByRef1{TString})::Nothing
Returns decay name.

""" TGeoDecayChannel!DecayName(this::ByRef1{TGeoDecayChannel}, decay::UInt32, name::ByRef1{TString})

# Wrapper of TGeoDecayChannel * TGeoDecayChannel::ReadDecay(const char *)
@trydoc raw"""
    TGeoDecayChannel!ReadDecay(this::ByRef1{TGeoDecayChannel}, record::ByCopy{String})::CxxPtr1{TGeoDecayChannel}
Create element from line record.

""" TGeoDecayChannel!ReadDecay(this::ByRef1{TGeoDecayChannel}, record::ByCopy{String})

# Wrapper of Double_t TGeoBatemanSol::Concentration(Double_t)
@trydoc raw"""
    Concentration(this::ByConstRef1{TGeoBatemanSol}, time::Float64)::Float64
Find concentration of the element at a given time.

""" Concentration(this::ByConstRef1{TGeoBatemanSol}, time::Float64)

# Wrapper of void TGeoBatemanSol::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoBatemanSol}, option::ByCopy{String})::Nothing
Draw the solution of Bateman equation versus time.

""" Draw(this::ByRef1{TGeoBatemanSol}, option::ByCopy{String})

# Wrapper of void TGeoBatemanSol::FindSolution(const TObjArray *)
@trydoc raw"""
    FindSolution(this::ByRef1{TGeoBatemanSol}, array::ByConstPtr1{TObjArray})::Nothing
Find the solution for the Bateman equations corresponding to the decay chain described by an array ending with element X.
A->B->...->X Cn = SUM [Ain * exp(-LMBDi*t)]; Cn - concentration Nx/Na n - order of X in chain (A->B->X => n=3) LMBDi - decay constant for element of order i in the chain Ain = LMBD1*...*LMBD(n-1) * br1*...*br(n-1)/(LMBD1-LMBDi)...(LMBDn-LMBDi) bri - branching ratio for decay Ei->Ei+1
""" FindSolution(this::ByRef1{TGeoBatemanSol}, array::ByConstPtr1{TObjArray})

# Wrapper of void TGeoBatemanSol::GetCoeff(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetCoeff(this::ByConstRef1{TGeoBatemanSol}, i::Int32, cn::ByRef2{Float64}, lambda::ByRef2{Float64})::Nothing


""" GetCoeff(this::ByConstRef1{TGeoBatemanSol}, i::Int32, cn::ByRef2{Float64}, lambda::ByRef2{Float64})

# Wrapper of TGeoElementRN * TGeoBatemanSol::GetElement()
@trydoc raw"""
    GetElement(this::ByConstRef1{TGeoBatemanSol})::CxxPtr1{TGeoElementRN}


""" GetElement(this::ByConstRef1{TGeoBatemanSol})

# Wrapper of Int_t TGeoBatemanSol::GetNcoeff()
@trydoc raw"""
    GetNcoeff(this::ByConstRef1{TGeoBatemanSol})::Int32


""" GetNcoeff(this::ByConstRef1{TGeoBatemanSol})

# Wrapper of void TGeoBatemanSol::GetRange(Double_t &, Double_t &)
@trydoc raw"""
    GetRange(this::ByConstRef1{TGeoBatemanSol}, tmin::ByRef2{Float64}, tmax::ByRef2{Float64})::Nothing


""" GetRange(this::ByConstRef1{TGeoBatemanSol}, tmin::ByRef2{Float64}, tmax::ByRef2{Float64})

# Wrapper of TGeoElementRN * TGeoBatemanSol::GetTopElement()
@trydoc raw"""
    GetTopElement(this::ByConstRef1{TGeoBatemanSol})::CxxPtr1{TGeoElementRN}


""" GetTopElement(this::ByConstRef1{TGeoBatemanSol})

# Wrapper of void TGeoBatemanSol::Normalize(Double_t)
@trydoc raw"""
    Normalize(this::ByRef1{TGeoBatemanSol}, factor::Float64)::Nothing
Normalize all coefficients with a given factor.

""" Normalize(this::ByRef1{TGeoBatemanSol}, factor::Float64)

# Wrapper of TGeoBatemanSol & TGeoBatemanSol::operator+=(const TGeoBatemanSol &)
@trydoc raw"""
    add!(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})::CxxRef1{TGeoBatemanSol}
Addition of other solution.

""" add!(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})

# Wrapper of TGeoBatemanSol & TGeoBatemanSol::operator=(const TGeoBatemanSol &)
@trydoc raw"""
    assign(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})::CxxRef1{TGeoBatemanSol}
Assignment.

""" assign(this::ByRef1{TGeoBatemanSol}, other::ByConstRef1{TGeoBatemanSol})

# Wrapper of void TGeoBatemanSol::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoBatemanSol}, option::ByCopy{String})::Nothing
Print concentration evolution.

""" Print(this::ByConstRef1{TGeoBatemanSol}, option::ByCopy{String})

# Wrapper of void TGeoBatemanSol::SetFactor(Double_t)
@trydoc raw"""
    SetFactor(this::ByRef1{TGeoBatemanSol}, factor::Float64)::Nothing


""" SetFactor(this::ByRef1{TGeoBatemanSol}, factor::Float64)

# Wrapper of void TGeoBatemanSol::SetRange(Double_t, Double_t)
@trydoc raw"""
    SetRange(this::ByRef1{TGeoBatemanSol}, tmin::Float64, tmax::Float64)::Nothing


""" SetRange(this::ByRef1{TGeoBatemanSol}, tmin::Float64, tmax::Float64)

# Wrapper of TObjArray * TGeoElemIter::GetBranch()
@trydoc raw"""
    GetBranch(this::ByConstRef1{TGeoElemIter})::CxxPtr1{TObjArray}


""" GetBranch(this::ByConstRef1{TGeoElemIter})

# Wrapper of const TGeoElementRN * TGeoElemIter::GetElement()
@trydoc raw"""
    GetElement(this::ByConstRef1{TGeoElemIter})::ConstCxxPtr1{TGeoElementRN}


""" GetElement(this::ByConstRef1{TGeoElemIter})

# Wrapper of Int_t TGeoElemIter::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoElemIter})::Int32


""" GetLevel(this::ByConstRef1{TGeoElemIter})

# Wrapper of Double_t TGeoElemIter::GetRatio()
@trydoc raw"""
    GetRatio(this::ByConstRef1{TGeoElemIter})::Float64


""" GetRatio(this::ByConstRef1{TGeoElemIter})

# Wrapper of const TGeoElementRN * TGeoElemIter::GetTop()
@trydoc raw"""
    GetTop(this::ByConstRef1{TGeoElemIter})::ConstCxxPtr1{TGeoElementRN}


""" GetTop(this::ByConstRef1{TGeoElemIter})

# Wrapper of TGeoElementRN * TGeoElemIter::Next()
@trydoc raw"""
    Next(this::ByRef1{TGeoElemIter})::CxxPtr1{TGeoElementRN}
Return next element.

""" Next(this::ByRef1{TGeoElemIter})

# Wrapper of TGeoElementRN * TGeoElemIter::operator()()
@trydoc raw"""
    paren(this::ByRef1{TGeoElemIter})::CxxPtr1{TGeoElementRN}
() operator.

""" paren(this::ByRef1{TGeoElemIter})

# Wrapper of TGeoElemIter & TGeoElemIter::operator=(const TGeoElemIter &)
@trydoc raw"""
    assign(this::ByRef1{TGeoElemIter}, iter::ByConstRef1{TGeoElemIter})::CxxRef1{TGeoElemIter}
Assignment.

""" assign(this::ByRef1{TGeoElemIter}, iter::ByConstRef1{TGeoElemIter})

# Wrapper of void TGeoElemIter::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoElemIter}, option::ByCopy{String})::Nothing
Print info about the current decay branch.

""" Print(this::ByConstRef1{TGeoElemIter}, option::ByCopy{String})

# Wrapper of void TGeoElemIter::SetLimitRatio(Double_t)
@trydoc raw"""
    SetLimitRatio(this::ByRef1{TGeoElemIter}, limit::Float64)::Nothing


""" SetLimitRatio(this::ByRef1{TGeoElemIter}, limit::Float64)

# Wrapper of TGeoExtension * TGeoExtension::Grab()
@trydoc raw"""
    Grab(this::ByRef1{TGeoExtension})::CxxPtr1{TGeoExtension}


""" Grab(this::ByRef1{TGeoExtension})

# Wrapper of void TGeoExtension::Release()
@trydoc raw"""
    Release(this::ByConstRef1{TGeoExtension})::Nothing


""" Release(this::ByConstRef1{TGeoExtension})

# Wrapper of void TGeoMixture::AddElement(Double_t, Double_t, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, a::Float64, z::Float64, weight::Float64)::Nothing
add an element to the mixture using fraction by weight Check if the element is already defined

""" AddElement(this::ByRef1{TGeoMixture}, a::Float64, z::Float64, weight::Float64)

# Wrapper of void TGeoMixture::AddElement(TGeoElement *, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, weight::Float64)::Nothing
add an element to the mixture using fraction by weight

""" AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, weight::Float64)

# Wrapper of void TGeoMixture::AddElement(TGeoElement *, Int_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, natoms::Int32)::Nothing
Add a mixture element by number of atoms in the chemical formula.

""" AddElement(this::ByRef1{TGeoMixture}, elem::ByPtr1{TGeoElement}, natoms::Int32)

# Wrapper of void TGeoMixture::AddElement(TGeoMaterial *, Double_t)
@trydoc raw"""
    AddElement(this::ByRef1{TGeoMixture}, mat::ByPtr1{TGeoMaterial}, weight::Float64)::Nothing
Define one component of the mixture as an existing material/mixture.

""" AddElement(this::ByRef1{TGeoMixture}, mat::ByPtr1{TGeoMaterial}, weight::Float64)

# Wrapper of void TGeoMixture::ComputeDerivedQuantities()
@trydoc raw"""
    ComputeDerivedQuantities(this::ByRef1{TGeoMixture})::Nothing
Compute Derived Quantities as in Geant4.

""" ComputeDerivedQuantities(this::ByRef1{TGeoMixture})

# Wrapper of void TGeoMixture::ComputeNuclearInterLength()
@trydoc raw"""
    ComputeNuclearInterLength(this::ByRef1{TGeoMixture})::Nothing
Compute Nuclear Interaction Length based on Geant4 formula.

""" ComputeNuclearInterLength(this::ByRef1{TGeoMixture})

# Wrapper of void TGeoMixture::ComputeRadiationLength()
@trydoc raw"""
    ComputeRadiationLength(this::ByRef1{TGeoMixture})::Nothing
Compute Radiation Length based on Geant4 formula.

""" ComputeRadiationLength(this::ByRef1{TGeoMixture})

# Wrapper of TGeoMaterial * TGeoMixture::DecayMaterial(Double_t, Double_t)
@trydoc raw"""
    DecayMaterial(this::ByRef1{TGeoMixture}, time::Float64, precision::Float64)::CxxPtr1{TGeoMaterial}
Create the mixture representing the decay product of this material at a given time.
The precision represent the minimum cumulative branching ratio for which decay products are still taken into account.
""" DecayMaterial(this::ByRef1{TGeoMixture}, time::Float64, precision::Float64)

# Wrapper of void TGeoMixture::DefineElement(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, a::Float64, z::Float64, weight::Float64)::Nothing


""" DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, a::Float64, z::Float64, weight::Float64)

# Wrapper of void TGeoMixture::DefineElement(Int_t, Int_t, Int_t)
@trydoc raw"""
    DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, z::Int32, natoms::Int32)::Nothing
Define the mixture element at index iel by number of atoms in the chemical formula.

""" DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, z::Int32, natoms::Int32)

# Wrapper of void TGeoMixture::DefineElement(Int_t, TGeoElement *, Double_t)
@trydoc raw"""
    DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, elem::ByPtr1{TGeoElement}, weight::Float64)::Nothing


""" DefineElement(this::ByRef1{TGeoMixture}, iel::Int32, elem::ByPtr1{TGeoElement}, weight::Float64)

# Wrapper of void TGeoMixture::FillMaterialEvolution(TObjArray *, Double_t)
@trydoc raw"""
    FillMaterialEvolution(this::ByRef1{TGeoMixture}, population::ByPtr1{TObjArray}, precision::Float64)::Nothing
Fills a user array with all the elements deriving from the possible decay of the top elements composing the mixture.
Each element contained by `<population>` may be a radionuclide having a Bateman solution attached. The precision represent the minimum cumulative branching ratio for which decay products are still taken into account. To visualize the time evolution of each decay product one can use: 

    TGeoElement *elem = population->At(index);
    TGeoElementRN *elemrn = 0;
    if (elem->IsRadioNuclide()) elemrn = (TGeoElementRN*)elem;

(C++ version of the code)

 One can get Ni/N1(t=0) at any moment of time. Ni is the number of atoms of one of the decay products, N1(0) is the number of atoms of the first top element at t=0. 

    Double_t fraction_weight = elemrn->Ratio()->Concentration(time);

(C++ version of the code)

 One can also display the time evolution of the fractional weight: 

    elemrn->Ratio()->Draw(option);

(C++ version of the code)
""" FillMaterialEvolution(this::ByRef1{TGeoMixture}, population::ByPtr1{TObjArray}, precision::Float64)

# Wrapper of Double_t * TGeoMixture::GetAmixt()
@trydoc raw"""
    GetAmixt(this::ByConstRef1{TGeoMixture})::CxxPtr2{Float64}


""" GetAmixt(this::ByConstRef1{TGeoMixture})

# Wrapper of Int_t TGeoMixture::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoMixture})::Int32


""" GetByteCount(this::ByConstRef1{TGeoMixture})

# Wrapper of TGeoElement * TGeoMixture::GetElement(Int_t)
@trydoc raw"""
    GetElement(this::ByConstRef1{TGeoMixture}, i::Int32)::CxxPtr1{TGeoElement}
Retrieve the pointer to the element corresponding to component I.

""" GetElement(this::ByConstRef1{TGeoMixture}, i::Int32)

# Wrapper of void TGeoMixture::GetElementProp(Double_t &, Double_t &, Double_t &, Int_t)
@trydoc raw"""
    GetElementProp(this::ByRef1{TGeoMixture}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)::Nothing
Single interface to get element properties.

""" GetElementProp(this::ByRef1{TGeoMixture}, a::ByRef2{Float64}, z::ByRef2{Float64}, w::ByRef2{Float64}, i::Int32)

# Wrapper of Int_t TGeoMixture::GetNelements()
@trydoc raw"""
    GetNelements(this::ByConstRef1{TGeoMixture})::Int32


""" GetNelements(this::ByConstRef1{TGeoMixture})

# Wrapper of Int_t * TGeoMixture::GetNmixt()
@trydoc raw"""
    GetNmixt(this::ByConstRef1{TGeoMixture})::CxxPtr2{Int32}


""" GetNmixt(this::ByConstRef1{TGeoMixture})

# Wrapper of Double_t TGeoMixture::GetSpecificActivity(Int_t)
@trydoc raw"""
    GetSpecificActivity(this::ByConstRef1{TGeoMixture}, i::Int32)::Float64
Get specific activity (in Bq/gram) for the whole mixture (no argument) or for a given component.

""" GetSpecificActivity(this::ByConstRef1{TGeoMixture}, i::Int32)

# Wrapper of Double_t * TGeoMixture::GetWmixt()
@trydoc raw"""
    GetWmixt(this::ByConstRef1{TGeoMixture})::CxxPtr2{Float64}


""" GetWmixt(this::ByConstRef1{TGeoMixture})

# Wrapper of Double_t * TGeoMixture::GetZmixt()
@trydoc raw"""
    GetZmixt(this::ByConstRef1{TGeoMixture})::CxxPtr2{Float64}


""" GetZmixt(this::ByConstRef1{TGeoMixture})

# Wrapper of Bool_t TGeoMixture::IsEq(const TGeoMaterial *)
@trydoc raw"""
    IsEq(this::ByConstRef1{TGeoMixture}, other::ByConstPtr1{TGeoMaterial})::Bool
Return true if the other material has the same physical properties.

""" IsEq(this::ByConstRef1{TGeoMixture}, other::ByConstPtr1{TGeoMaterial})

# Wrapper of Bool_t TGeoMixture::IsMixture()
@trydoc raw"""
    IsMixture(this::ByConstRef1{TGeoMixture})::Bool


""" IsMixture(this::ByConstRef1{TGeoMixture})

# Wrapper of void TGeoMixture::Print(const Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoMixture}, option::ByCopy{String})::Nothing
print characteristics of this material

""" Print(this::ByConstRef1{TGeoMixture}, option::ByCopy{String})

# Wrapper of void TGeoMixture::SetA(Double_t)
@trydoc raw"""
    SetA(this::ByRef1{TGeoMixture}, a::Float64)::Nothing


""" SetA(this::ByRef1{TGeoMixture}, a::Float64)

# Wrapper of void TGeoMixture::SetDensity(Double_t)
@trydoc raw"""
    SetDensity(this::ByRef1{TGeoMixture}, density::Float64)::Nothing


""" SetDensity(this::ByRef1{TGeoMixture}, density::Float64)

# Wrapper of void TGeoMixture::SetZ(Double_t)
@trydoc raw"""
    SetZ(this::ByRef1{TGeoMixture}, z::Float64)::Nothing


""" SetZ(this::ByRef1{TGeoMixture}, z::Float64)

# Wrapper of void TGeoPatternFinder::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternFinder}, ::Int32)::Nothing


""" cd(this::ByRef1{TGeoPatternFinder}, ::Int32)

# Wrapper of TGeoNode * TGeoPatternFinder::CdNext()
@trydoc raw"""
    CdNext(this::ByRef1{TGeoPatternFinder})::CxxPtr1{TGeoNode}
Make next node (if any) current.

""" CdNext(this::ByRef1{TGeoPatternFinder})

# Wrapper of void TGeoPatternFinder::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoPatternFinder})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of TGeoMatrix * TGeoPatternFinder::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternFinder})::CxxPtr1{TGeoMatrix}


""" CreateMatrix(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of void TGeoPatternFinder::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoPatternFinder}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoPatternFinder}, nthreads::Int32)

# Wrapper of TGeoNode * TGeoPatternFinder::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternFinder}, ::ByPtr2{Float64}, ::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}


""" FindNode(this::ByRef1{TGeoPatternFinder}, ::ByPtr2{Float64}, ::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternFinder::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoPatternFinder})::Int32


""" GetByteCount(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetCurrent()
@trydoc raw"""
    GetCurrent(this::ByRef1{TGeoPatternFinder})::Int32
Return current index.

""" GetCurrent(this::ByRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternFinder})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetDivIndex()
@trydoc raw"""
    GetDivIndex(this::ByRef1{TGeoPatternFinder})::Int32


""" GetDivIndex(this::ByRef1{TGeoPatternFinder})

# Wrapper of Double_t TGeoPatternFinder::GetEnd()
@trydoc raw"""
    GetEnd(this::ByConstRef1{TGeoPatternFinder})::Float64


""" GetEnd(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of TGeoMatrix * TGeoPatternFinder::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByRef1{TGeoPatternFinder})::CxxPtr1{TGeoMatrix}
Return current matrix.

""" GetMatrix(this::ByRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetNdiv()
@trydoc raw"""
    GetNdiv(this::ByConstRef1{TGeoPatternFinder})::Int32


""" GetNdiv(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of Int_t TGeoPatternFinder::GetNext()
@trydoc raw"""
    GetNext(this::ByConstRef1{TGeoPatternFinder})::Int32
Get index of next division.

""" GetNext(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of TGeoNode * TGeoPatternFinder::GetNodeOffset(Int_t)
@trydoc raw"""
    GetNodeOffset(this::ByRef1{TGeoPatternFinder}, idiv::Int32)::CxxPtr1{TGeoNode}


""" GetNodeOffset(this::ByRef1{TGeoPatternFinder}, idiv::Int32)

# Wrapper of Double_t TGeoPatternFinder::GetStart()
@trydoc raw"""
    GetStart(this::ByConstRef1{TGeoPatternFinder})::Float64


""" GetStart(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of Double_t TGeoPatternFinder::GetStep()
@trydoc raw"""
    GetStep(this::ByConstRef1{TGeoPatternFinder})::Float64


""" GetStep(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of TGeoVolume * TGeoPatternFinder::GetVolume()
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoPatternFinder})::CxxPtr1{TGeoVolume}


""" GetVolume(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of Bool_t TGeoPatternFinder::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternFinder}, ::ByConstPtr2{Float64})::Bool


""" IsOnBoundary(this::ByConstRef1{TGeoPatternFinder}, ::ByConstPtr2{Float64})

# Wrapper of Bool_t TGeoPatternFinder::IsReflected()
@trydoc raw"""
    IsReflected(this::ByConstRef1{TGeoPatternFinder})::Bool


""" IsReflected(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of Bool_t TGeoPatternFinder::IsSpacedOut()
@trydoc raw"""
    IsSpacedOut(this::ByConstRef1{TGeoPatternFinder})::Bool


""" IsSpacedOut(this::ByConstRef1{TGeoPatternFinder})

# Wrapper of TGeoPatternFinder * TGeoPatternFinder::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternFinder}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}


""" MakeCopy(this::ByRef1{TGeoPatternFinder}, reflect::Bool)

# Wrapper of void TGeoPatternFinder::Reflect(Bool_t)
@trydoc raw"""
    Reflect(this::ByRef1{TGeoPatternFinder}, flag::Bool)::Nothing


""" Reflect(this::ByRef1{TGeoPatternFinder}, flag::Bool)

# Wrapper of void TGeoPatternFinder::SetDivIndex(Int_t)
@trydoc raw"""
    SetDivIndex(this::ByRef1{TGeoPatternFinder}, index::Int32)::Nothing


""" SetDivIndex(this::ByRef1{TGeoPatternFinder}, index::Int32)

# Wrapper of void TGeoPatternFinder::SetNext(Int_t)
@trydoc raw"""
    SetNext(this::ByRef1{TGeoPatternFinder}, index::Int32)::Nothing
Set index of next division.

""" SetNext(this::ByRef1{TGeoPatternFinder}, index::Int32)

# Wrapper of void TGeoPatternFinder::SetRange(Double_t, Double_t, Int_t)
@trydoc raw"""
    SetRange(this::ByRef1{TGeoPatternFinder}, thestart::Float64, step::Float64, ndivisions::Int32)::Nothing
Set division range. Use this method only when dividing an assembly.

""" SetRange(this::ByRef1{TGeoPatternFinder}, thestart::Float64, step::Float64, ndivisions::Int32)

# Wrapper of void TGeoPatternFinder::SetSpacedOut(Bool_t)
@trydoc raw"""
    SetSpacedOut(this::ByRef1{TGeoPatternFinder}, flag::Bool)::Nothing


""" SetSpacedOut(this::ByRef1{TGeoPatternFinder}, flag::Bool)

# Wrapper of void TGeoPatternFinder::SetVolume(TGeoVolume *)
@trydoc raw"""
    SetVolume(this::ByRef1{TGeoPatternFinder}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetVolume(this::ByRef1{TGeoPatternFinder}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TGeoPatternFinder::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternFinder}, ::Int32, ::ByRef1{TGeoHMatrix})::Nothing


""" UpdateMatrix(this::ByConstRef1{TGeoPatternFinder}, ::Int32, ::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoVoxelFinder::DaughterToMother(Int_t, const Double_t *, Double_t *)
@trydoc raw"""
    DaughterToMother(this::ByConstRef1{TGeoVoxelFinder}, id::Int32, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
convert a point from the local_ reference system of node id to reference system of mother volume

""" DaughterToMother(this::ByConstRef1{TGeoVoxelFinder}, id::Int32, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of Double_t TGeoVoxelFinder::Efficiency()
@trydoc raw"""
    Efficiency(this::ByRef1{TGeoVoxelFinder})::Float64
Compute voxelization efficiency.

""" Efficiency(this::ByRef1{TGeoVoxelFinder})

# Wrapper of void TGeoVoxelFinder::FindOverlaps(Int_t)
@trydoc raw"""
    FindOverlaps(this::ByConstRef1{TGeoVoxelFinder}, inode::Int32)::Nothing
create the list of nodes for which the bboxes overlap with inode's bbox

""" FindOverlaps(this::ByConstRef1{TGeoVoxelFinder}, inode::Int32)

# Wrapper of Double_t * TGeoVoxelFinder::GetBoxes()
@trydoc raw"""
    GetBoxes(this::ByConstRef1{TGeoVoxelFinder})::CxxPtr2{Float64}


""" GetBoxes(this::ByConstRef1{TGeoVoxelFinder})

# Wrapper of Int_t * TGeoVoxelFinder::GetCheckList(const Double_t *, Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetCheckList(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, nelem::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}
get the list of daughter indices for which point is inside their bbox

""" GetCheckList(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, nelem::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of Int_t * TGeoVoxelFinder::GetCheckList(Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetCheckList(this::ByConstRef1{TGeoVoxelFinder}, nelem::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}


""" GetCheckList(this::ByConstRef1{TGeoVoxelFinder}, nelem::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of Int_t * TGeoVoxelFinder::GetNextCandidates(const Double_t *, Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetNextCandidates(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}
Returns list of new candidates in next voxel.
If NULL, nowhere to go next.
""" GetNextCandidates(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of Int_t * TGeoVoxelFinder::GetNextVoxel(const Double_t *, const Double_t *, Int_t &, TGeoStateInfo &)
@trydoc raw"""
    GetNextVoxel(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})::CxxPtr2{Int32}
get the list of new candidates for the next voxel crossed by current ray printf("### GetNextVoxel\n");

""" GetNextVoxel(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, ncheck::ByRef2{Int32}, td::ByRef1{TGeoStateInfo})

# Wrapper of Bool_t TGeoVoxelFinder::IsInvalid()
@trydoc raw"""
    IsInvalid(this::ByConstRef1{TGeoVoxelFinder})::Bool


""" IsInvalid(this::ByConstRef1{TGeoVoxelFinder})

# Wrapper of Bool_t TGeoVoxelFinder::IsSafeVoxel(const Double_t *, Int_t, Double_t)
@trydoc raw"""
    IsSafeVoxel(this::ByConstRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, inode::Int32, minsafe::Float64)::Bool
Computes squared distance from POINT to the voxel(s) containing node INODE.
Returns 0 if POINT inside voxel(s).
""" IsSafeVoxel(this::ByConstRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, inode::Int32, minsafe::Float64)

# Wrapper of Bool_t TGeoVoxelFinder::NeedRebuild()
@trydoc raw"""
    NeedRebuild(this::ByConstRef1{TGeoVoxelFinder})::Bool


""" NeedRebuild(this::ByConstRef1{TGeoVoxelFinder})

# Wrapper of void TGeoVoxelFinder::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoVoxelFinder}, option::ByCopy{String})::Nothing
Print the voxels.

""" Print(this::ByConstRef1{TGeoVoxelFinder}, option::ByCopy{String})

# Wrapper of void TGeoVoxelFinder::PrintVoxelLimits(const Double_t *)
@trydoc raw"""
    PrintVoxelLimits(this::ByConstRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64})::Nothing
print the voxel containing point

""" PrintVoxelLimits(this::ByConstRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoVoxelFinder::SetInvalid(Bool_t)
@trydoc raw"""
    SetInvalid(this::ByRef1{TGeoVoxelFinder}, flag::Bool)::Nothing


""" SetInvalid(this::ByRef1{TGeoVoxelFinder}, flag::Bool)

# Wrapper of void TGeoVoxelFinder::SetNeedRebuild(Bool_t)
@trydoc raw"""
    SetNeedRebuild(this::ByRef1{TGeoVoxelFinder}, flag::Bool)::Nothing


""" SetNeedRebuild(this::ByRef1{TGeoVoxelFinder}, flag::Bool)

# Wrapper of void TGeoVoxelFinder::SortCrossedVoxels(const Double_t *, const Double_t *, TGeoStateInfo &)
@trydoc raw"""
    SortCrossedVoxels(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, td::ByRef1{TGeoStateInfo})::Nothing
get the list in the next voxel crossed by a ray

""" SortCrossedVoxels(this::ByRef1{TGeoVoxelFinder}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, td::ByRef1{TGeoStateInfo})

# Wrapper of void TGeoVoxelFinder::Voxelize(Option_t *)
@trydoc raw"""
    Voxelize(this::ByRef1{TGeoVoxelFinder}, option::ByCopy{String})::Nothing
Voxelize attached volume according to option If the volume is an assembly, make sure the bbox is computed.

""" Voxelize(this::ByRef1{TGeoVoxelFinder}, option::ByCopy{String})

# Wrapper of void TGeoPatternX::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternX}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternX}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternX::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternX})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternX})

# Wrapper of Double_t TGeoPatternX::FindNextBoundary(Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})::Float64
Compute distance to next division layer returning the index of next section.
Point is in the frame of the divided volume.
""" FindNextBoundary(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})

# Wrapper of TGeoNode * TGeoPatternX::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Find the cell corresponding to point and next cell along dir (if asked)

""" FindNode(this::ByRef1{TGeoPatternX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternX::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternX})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternX})

# Wrapper of Bool_t TGeoPatternX::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternX}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternX}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternX::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternX}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternX}, reflect::Bool)

# Wrapper of TGeoPatternX & TGeoPatternX::operator=(const TGeoPatternX &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternX}, ::ByConstRef1{TGeoPatternX})::CxxRef1{TGeoPatternX}
assignment operator

""" assign(this::ByRef1{TGeoPatternX}, ::ByConstRef1{TGeoPatternX})

# Wrapper of void TGeoPatternX::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternX}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternX}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternY::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternY}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternY}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternY::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternY})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternY})

# Wrapper of Double_t TGeoPatternY::FindNextBoundary(Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})::Float64
Compute distance to next division layer returning the index of next section.
Point is in the frame of the divided volume.
""" FindNextBoundary(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})

# Wrapper of TGeoNode * TGeoPatternY::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Find the cell corresponding to point and next cell along dir (if asked)

""" FindNode(this::ByRef1{TGeoPatternY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternY::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternY})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternY})

# Wrapper of Bool_t TGeoPatternY::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternY}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternY}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternY::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternY}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternY}, reflect::Bool)

# Wrapper of TGeoPatternY & TGeoPatternY::operator=(const TGeoPatternY &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternY}, ::ByConstRef1{TGeoPatternY})::CxxRef1{TGeoPatternY}
assignment operator

""" assign(this::ByRef1{TGeoPatternY}, ::ByConstRef1{TGeoPatternY})

# Wrapper of void TGeoPatternY::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternY}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternY}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternZ::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternZ}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternZ}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternZ::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternZ})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternZ})

# Wrapper of Double_t TGeoPatternZ::FindNextBoundary(Double_t *, Double_t *, Int_t &)
@trydoc raw"""
    FindNextBoundary(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})::Float64
Compute distance to next division layer returning the index of next section.
Point is in the frame of the divided volume.
""" FindNextBoundary(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByPtr2{Float64}, indnext::ByRef2{Int32})

# Wrapper of TGeoNode * TGeoPatternZ::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
Find the cell corresponding to point and next cell along dir (if asked)

""" FindNode(this::ByRef1{TGeoPatternZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternZ::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternZ})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternZ})

# Wrapper of Bool_t TGeoPatternZ::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternZ}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternZ}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternZ::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternZ}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternZ}, reflect::Bool)

# Wrapper of TGeoPatternZ & TGeoPatternZ::operator=(const TGeoPatternZ &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternZ}, ::ByConstRef1{TGeoPatternZ})::CxxRef1{TGeoPatternZ}
assignment operator

""" assign(this::ByRef1{TGeoPatternZ}, ::ByConstRef1{TGeoPatternZ})

# Wrapper of void TGeoPatternZ::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternZ}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternZ}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternParaX::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternParaX}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternParaX}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternParaX::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternParaX})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternParaX})

# Wrapper of TGeoNode * TGeoPatternParaX::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternParaX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternParaX}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternParaX::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternParaX})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternParaX})

# Wrapper of Bool_t TGeoPatternParaX::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternParaX}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternParaX}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternParaX::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternParaX}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternParaX}, reflect::Bool)

# Wrapper of TGeoPatternParaX & TGeoPatternParaX::operator=(const TGeoPatternParaX &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternParaX}, ::ByConstRef1{TGeoPatternParaX})::CxxRef1{TGeoPatternParaX}
assignment operator

""" assign(this::ByRef1{TGeoPatternParaX}, ::ByConstRef1{TGeoPatternParaX})

# Wrapper of void TGeoPatternParaX::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternParaX}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternParaX}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternParaY::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternParaY}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternParaY}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternParaY::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternParaY})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternParaY})

# Wrapper of TGeoNode * TGeoPatternParaY::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternParaY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternParaY}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternParaY::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternParaY})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternParaY})

# Wrapper of Bool_t TGeoPatternParaY::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternParaY}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternParaY}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternParaY::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternParaY}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternParaY}, reflect::Bool)

# Wrapper of TGeoPatternParaY & TGeoPatternParaY::operator=(const TGeoPatternParaY &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternParaY}, ::ByConstRef1{TGeoPatternParaY})::CxxRef1{TGeoPatternParaY}
assignment operator

""" assign(this::ByRef1{TGeoPatternParaY}, ::ByConstRef1{TGeoPatternParaY})

# Wrapper of void TGeoPatternParaY::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternParaY}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternParaY}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternParaZ::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternParaZ}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternParaZ}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternParaZ::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternParaZ})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternParaZ})

# Wrapper of TGeoNode * TGeoPatternParaZ::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternParaZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternParaZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternParaZ::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternParaZ})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternParaZ})

# Wrapper of Bool_t TGeoPatternParaZ::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternParaZ}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternParaZ}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternParaZ::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternParaZ}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternParaZ}, reflect::Bool)

# Wrapper of TGeoPatternParaZ & TGeoPatternParaZ::operator=(const TGeoPatternParaZ &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternParaZ}, ::ByConstRef1{TGeoPatternParaZ})::CxxRef1{TGeoPatternParaZ}
assignment operator

""" assign(this::ByRef1{TGeoPatternParaZ}, ::ByConstRef1{TGeoPatternParaZ})

# Wrapper of void TGeoPatternParaZ::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternParaZ}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternParaZ}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternTrapZ::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternTrapZ}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternTrapZ}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternTrapZ::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternTrapZ})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternTrapZ})

# Wrapper of TGeoNode * TGeoPatternTrapZ::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternTrapZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
get the node division containing the query point

""" FindNode(this::ByRef1{TGeoPatternTrapZ}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternTrapZ::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternTrapZ})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternTrapZ})

# Wrapper of Double_t TGeoPatternTrapZ::GetTxz()
@trydoc raw"""
    GetTxz(this::ByConstRef1{TGeoPatternTrapZ})::Float64


""" GetTxz(this::ByConstRef1{TGeoPatternTrapZ})

# Wrapper of Double_t TGeoPatternTrapZ::GetTyz()
@trydoc raw"""
    GetTyz(this::ByConstRef1{TGeoPatternTrapZ})::Float64


""" GetTyz(this::ByConstRef1{TGeoPatternTrapZ})

# Wrapper of Bool_t TGeoPatternTrapZ::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternTrapZ}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternTrapZ}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternTrapZ::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternTrapZ}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternTrapZ}, reflect::Bool)

# Wrapper of TGeoPatternTrapZ & TGeoPatternTrapZ::operator=(const TGeoPatternTrapZ &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternTrapZ}, ::ByConstRef1{TGeoPatternTrapZ})::CxxRef1{TGeoPatternTrapZ}
assignment operator

""" assign(this::ByRef1{TGeoPatternTrapZ}, ::ByConstRef1{TGeoPatternTrapZ})

# Wrapper of void TGeoPatternTrapZ::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternTrapZ}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternTrapZ}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternCylR::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternCylR}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternCylR}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternCylR::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternCylR})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternCylR})

# Wrapper of TGeoNode * TGeoPatternCylR::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternCylR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternCylR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternCylR::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternCylR})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternCylR})

# Wrapper of Bool_t TGeoPatternCylR::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternCylR}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternCylR}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternCylR::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternCylR}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternCylR}, reflect::Bool)

# Wrapper of TGeoPatternCylR & TGeoPatternCylR::operator=(const TGeoPatternCylR &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternCylR}, ::ByConstRef1{TGeoPatternCylR})::CxxRef1{TGeoPatternCylR}
assignment operator

""" assign(this::ByRef1{TGeoPatternCylR}, ::ByConstRef1{TGeoPatternCylR})

# Wrapper of void TGeoPatternCylR::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternCylR}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternCylR}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternCylPhi::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternCylPhi}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternCylPhi}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternCylPhi::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternCylPhi})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternCylPhi})

# Wrapper of TGeoNode * TGeoPatternCylPhi::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternCylPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternCylPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternCylPhi::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternCylPhi})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternCylPhi})

# Wrapper of Bool_t TGeoPatternCylPhi::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternCylPhi}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternCylPhi}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternCylPhi::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternCylPhi}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternCylPhi}, reflect::Bool)

# Wrapper of void TGeoPatternCylPhi::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternCylPhi}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternCylPhi}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternSphR::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternSphR}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternSphR}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternSphR::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternSphR})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternSphR})

# Wrapper of TGeoNode * TGeoPatternSphR::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternSphR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternSphR}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternSphR::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternSphR})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternSphR})

# Wrapper of TGeoPatternFinder * TGeoPatternSphR::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternSphR}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternSphR}, reflect::Bool)

# Wrapper of TGeoPatternSphR & TGeoPatternSphR::operator=(const TGeoPatternSphR &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternSphR}, ::ByConstRef1{TGeoPatternSphR})::CxxRef1{TGeoPatternSphR}
assignment operator

""" assign(this::ByRef1{TGeoPatternSphR}, ::ByConstRef1{TGeoPatternSphR})

# Wrapper of void TGeoPatternSphR::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternSphR}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternSphR}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternSphTheta::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternSphTheta}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternSphTheta}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternSphTheta::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternSphTheta})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternSphTheta})

# Wrapper of TGeoNode * TGeoPatternSphTheta::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternSphTheta}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternSphTheta}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternSphTheta::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternSphTheta})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternSphTheta})

# Wrapper of TGeoPatternFinder * TGeoPatternSphTheta::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternSphTheta}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternSphTheta}, reflect::Bool)

# Wrapper of TGeoPatternSphTheta & TGeoPatternSphTheta::operator=(const TGeoPatternSphTheta &)
@trydoc raw"""
    assign(this::ByRef1{TGeoPatternSphTheta}, ::ByConstRef1{TGeoPatternSphTheta})::CxxRef1{TGeoPatternSphTheta}
assignment operator

""" assign(this::ByRef1{TGeoPatternSphTheta}, ::ByConstRef1{TGeoPatternSphTheta})

# Wrapper of void TGeoPatternSphTheta::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternSphTheta}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternSphTheta}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternSphPhi::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternSphPhi}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternSphPhi}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternSphPhi::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternSphPhi})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternSphPhi})

# Wrapper of TGeoNode * TGeoPatternSphPhi::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternSphPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternSphPhi}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of Int_t TGeoPatternSphPhi::GetDivAxis()
@trydoc raw"""
    GetDivAxis(this::ByRef1{TGeoPatternSphPhi})::Int32


""" GetDivAxis(this::ByRef1{TGeoPatternSphPhi})

# Wrapper of Bool_t TGeoPatternSphPhi::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoPatternSphPhi}, point::ByConstPtr2{Float64})::Bool
Checks if the current point is on division boundary.

""" IsOnBoundary(this::ByConstRef1{TGeoPatternSphPhi}, point::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternSphPhi::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternSphPhi}, reflect::Bool)::CxxPtr1{TGeoPatternFinder}
Make a copy of this finder. Reflect by Z if required.

""" MakeCopy(this::ByRef1{TGeoPatternSphPhi}, reflect::Bool)

# Wrapper of void TGeoPatternSphPhi::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternSphPhi}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternSphPhi}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of void TGeoPatternHoneycomb::cd(Int_t)
@trydoc raw"""
    cd(this::ByRef1{TGeoPatternHoneycomb}, idiv::Int32)::Nothing
Update current division index and global_ matrix to point to a given slice.

""" cd(this::ByRef1{TGeoPatternHoneycomb}, idiv::Int32)

# Wrapper of TGeoMatrix * TGeoPatternHoneycomb::CreateMatrix()
@trydoc raw"""
    CreateMatrix(this::ByConstRef1{TGeoPatternHoneycomb})::CxxPtr1{TGeoMatrix}
Return new matrix of type used by this finder.

""" CreateMatrix(this::ByConstRef1{TGeoPatternHoneycomb})

# Wrapper of TGeoNode * TGeoPatternHoneycomb::FindNode(Double_t *, const Double_t *)
@trydoc raw"""
    FindNode(this::ByRef1{TGeoPatternHoneycomb}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})::CxxPtr1{TGeoNode}
find the node containing the query point

""" FindNode(this::ByRef1{TGeoPatternHoneycomb}, point::ByPtr2{Float64}, dir::ByConstPtr2{Float64})

# Wrapper of TGeoPatternFinder * TGeoPatternHoneycomb::MakeCopy(Bool_t)
@trydoc raw"""
    MakeCopy(this::ByRef1{TGeoPatternHoneycomb}, ::Bool)::CxxPtr1{TGeoPatternFinder}


""" MakeCopy(this::ByRef1{TGeoPatternHoneycomb}, ::Bool)

# Wrapper of void TGeoPatternHoneycomb::UpdateMatrix(Int_t, TGeoHMatrix &)
@trydoc raw"""
    UpdateMatrix(this::ByConstRef1{TGeoPatternHoneycomb}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})::Nothing
Fills external matrix with the local_ one corresponding to the given division index.

""" UpdateMatrix(this::ByConstRef1{TGeoPatternHoneycomb}, idiv::Int32, matrix::ByRef1{TGeoHMatrix})

# Wrapper of Int_t TGeoNodeMatrix::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoNodeMatrix})::Int32
return the total size in bytes of this node

""" GetByteCount(this::ByConstRef1{TGeoNodeMatrix})

# Wrapper of TGeoMatrix * TGeoNodeMatrix::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByConstRef1{TGeoNodeMatrix})::CxxPtr1{TGeoMatrix}


""" GetMatrix(this::ByConstRef1{TGeoNodeMatrix})

# Wrapper of Int_t TGeoNodeMatrix::GetOptimalVoxels()
@trydoc raw"""
    GetOptimalVoxels(this::ByConstRef1{TGeoNodeMatrix})::Int32
Returns type of optimal voxelization for this node.
- type = 0 -> cartesian
- type = 1 -> cylindrical
""" GetOptimalVoxels(this::ByConstRef1{TGeoNodeMatrix})

# Wrapper of Bool_t TGeoNodeMatrix::IsFolder()
@trydoc raw"""
    IsFolder(this::ByConstRef1{TGeoNodeMatrix})::Bool
Returns kTRUE in case object contains browsable objects (like containers or lists of other objects).

""" IsFolder(this::ByConstRef1{TGeoNodeMatrix})

# Wrapper of TGeoNode * TGeoNodeMatrix::MakeCopyNode()
@trydoc raw"""
    MakeCopyNode(this::ByConstRef1{TGeoNodeMatrix})::CxxPtr1{TGeoNode}
Make a copy of this node.

""" MakeCopyNode(this::ByConstRef1{TGeoNodeMatrix})

# Wrapper of void TGeoNodeMatrix::SetMatrix(const TGeoMatrix *)
@trydoc raw"""
    SetMatrix(this::ByRef1{TGeoNodeMatrix}, matrix::ByConstPtr1{TGeoMatrix})::Nothing
Matrix setter.

""" SetMatrix(this::ByRef1{TGeoNodeMatrix}, matrix::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoNodeOffset::cd()
@trydoc raw"""
    cd(this::ByConstRef1{TGeoNodeOffset})::Nothing


""" cd(this::ByConstRef1{TGeoNodeOffset})

# Wrapper of TGeoPatternFinder * TGeoNodeOffset::GetFinder()
@trydoc raw"""
    GetFinder(this::ByConstRef1{TGeoNodeOffset})::CxxPtr1{TGeoPatternFinder}


""" GetFinder(this::ByConstRef1{TGeoNodeOffset})

# Wrapper of Int_t TGeoNodeOffset::GetIndex()
@trydoc raw"""
    GetIndex(this::ByConstRef1{TGeoNodeOffset})::Int32
Get the index of this offset.

""" GetIndex(this::ByConstRef1{TGeoNodeOffset})

# Wrapper of TGeoMatrix * TGeoNodeOffset::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByConstRef1{TGeoNodeOffset})::CxxPtr1{TGeoMatrix}


""" GetMatrix(this::ByConstRef1{TGeoNodeOffset})

# Wrapper of Double_t TGeoNodeOffset::GetOffset()
@trydoc raw"""
    GetOffset(this::ByConstRef1{TGeoNodeOffset})::Float64


""" GetOffset(this::ByConstRef1{TGeoNodeOffset})

# Wrapper of TGeoNode * TGeoNodeOffset::MakeCopyNode()
@trydoc raw"""
    MakeCopyNode(this::ByConstRef1{TGeoNodeOffset})::CxxPtr1{TGeoNode}
Make a copy of this node.

""" MakeCopyNode(this::ByConstRef1{TGeoNodeOffset})

# Wrapper of void TGeoNodeOffset::SetFinder(TGeoPatternFinder *)
@trydoc raw"""
    SetFinder(this::ByRef1{TGeoNodeOffset}, finder::ByPtr1{TGeoPatternFinder})::Nothing


""" SetFinder(this::ByRef1{TGeoNodeOffset}, finder::ByPtr1{TGeoPatternFinder})

# Wrapper of const TGeoMatrix * TGeoIterator::GetCurrentMatrix()
@trydoc raw"""
    GetCurrentMatrix(this::ByConstRef1{TGeoIterator})::ConstCxxPtr1{TGeoMatrix}
Returns global_ matrix for current node.

""" GetCurrentMatrix(this::ByConstRef1{TGeoIterator})

# Wrapper of Int_t TGeoIterator::GetIndex(Int_t)
@trydoc raw"""
    GetIndex(this::ByConstRef1{TGeoIterator}, i::Int32)::Int32


""" GetIndex(this::ByConstRef1{TGeoIterator}, i::Int32)

# Wrapper of Int_t TGeoIterator::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoIterator})::Int32


""" GetLevel(this::ByConstRef1{TGeoIterator})

# Wrapper of TGeoNode * TGeoIterator::GetNode(Int_t)
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoIterator}, level::Int32)::CxxPtr1{TGeoNode}
Returns current node at a given level.

""" GetNode(this::ByConstRef1{TGeoIterator}, level::Int32)

# Wrapper of void TGeoIterator::GetPath(TString &)
@trydoc raw"""
    GetPath(this::ByConstRef1{TGeoIterator}, path::ByRef1{TString})::Nothing
Returns the path for the current node.

""" GetPath(this::ByConstRef1{TGeoIterator}, path::ByRef1{TString})

# Wrapper of TGeoVolume * TGeoIterator::GetTopVolume()
@trydoc raw"""
    GetTopVolume(this::ByConstRef1{TGeoIterator})::CxxPtr1{TGeoVolume}


""" GetTopVolume(this::ByConstRef1{TGeoIterator})

# Wrapper of Int_t TGeoIterator::GetType()
@trydoc raw"""
    GetType(this::ByConstRef1{TGeoIterator})::Int32


""" GetType(this::ByConstRef1{TGeoIterator})

# Wrapper of TGeoIteratorPlugin * TGeoIterator::GetUserPlugin()
@trydoc raw"""
    GetUserPlugin(this::ByConstRef1{TGeoIterator})::CxxPtr1{TGeoIteratorPlugin}


""" GetUserPlugin(this::ByConstRef1{TGeoIterator})

# Wrapper of TGeoNode * TGeoIterator::Next()
@trydoc raw"""
    Next(this::ByRef1{TGeoIterator})::CxxPtr1{TGeoNode}
Returns next node.

""" Next(this::ByRef1{TGeoIterator})

# Wrapper of TGeoNode * TGeoIterator::operator()()
@trydoc raw"""
    paren(this::ByRef1{TGeoIterator})::CxxPtr1{TGeoNode}
Returns next node.

""" paren(this::ByRef1{TGeoIterator})

# Wrapper of TGeoIterator & TGeoIterator::operator=(const TGeoIterator &)
@trydoc raw"""
    assign(this::ByRef1{TGeoIterator}, iter::ByConstRef1{TGeoIterator})::CxxRef1{TGeoIterator}
Assignment.

""" assign(this::ByRef1{TGeoIterator}, iter::ByConstRef1{TGeoIterator})

# Wrapper of void TGeoIterator::Reset(TGeoVolume *)
@trydoc raw"""
    Reset(this::ByRef1{TGeoIterator}, top::ByPtr1{TGeoVolume})::Nothing
Resets the iterator for volume TOP.

""" Reset(this::ByRef1{TGeoIterator}, top::ByPtr1{TGeoVolume})

# Wrapper of void TGeoIterator::SetPluginAutoexec(Bool_t)
@trydoc raw"""
    SetPluginAutoexec(this::ByRef1{TGeoIterator}, mode::Bool)::Nothing


""" SetPluginAutoexec(this::ByRef1{TGeoIterator}, mode::Bool)

# Wrapper of void TGeoIterator::SetTopName(const char *)
@trydoc raw"""
    SetTopName(this::ByRef1{TGeoIterator}, name::ByCopy{String})::Nothing
Set the top name for path.

""" SetTopName(this::ByRef1{TGeoIterator}, name::ByCopy{String})

# Wrapper of void TGeoIterator::SetType(Int_t)
@trydoc raw"""
    SetType(this::ByRef1{TGeoIterator}, type::Int32)::Nothing


""" SetType(this::ByRef1{TGeoIterator}, type::Int32)

# Wrapper of void TGeoIterator::SetUserPlugin(TGeoIteratorPlugin *)
@trydoc raw"""
    SetUserPlugin(this::ByRef1{TGeoIterator}, plugin::ByPtr1{TGeoIteratorPlugin})::Nothing
Set a plugin.

""" SetUserPlugin(this::ByRef1{TGeoIterator}, plugin::ByPtr1{TGeoIteratorPlugin})

# Wrapper of void TGeoIterator::Skip()
@trydoc raw"""
    Skip(this::ByRef1{TGeoIterator})::Nothing
Stop iterating the current branch.
The iteration of the next node will behave as if the branch starting from the current node (included) is not existing.
""" Skip(this::ByRef1{TGeoIterator})

# Wrapper of void TGeoIterator::Up()
@trydoc raw"""
    Up(this::ByRef1{TGeoIterator})::Nothing


""" Up(this::ByRef1{TGeoIterator})

# Wrapper of void TGeoIteratorPlugin::ProcessNode()
@trydoc raw"""
    ProcessNode(this::ByRef1{TGeoIteratorPlugin})::Nothing


""" ProcessNode(this::ByRef1{TGeoIteratorPlugin})

# Wrapper of void TGeoIteratorPlugin::SetIterator(const TGeoIterator *)
@trydoc raw"""
    SetIterator(this::ByRef1{TGeoIteratorPlugin}, iter::ByConstPtr1{TGeoIterator})::Nothing


""" SetIterator(this::ByRef1{TGeoIteratorPlugin}, iter::ByConstPtr1{TGeoIterator})

# Wrapper of Double_t TGeoPolygon::Area()
@trydoc raw"""
    Area(this::ByConstRef1{TGeoPolygon})::Float64
Computes area of the polygon in [length^2].

""" Area(this::ByConstRef1{TGeoPolygon})

# Wrapper of Bool_t TGeoPolygon::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoPolygon}, point::ByConstPtr2{Float64})::Bool
Check if a point given by X = point[0], Y = point[1] is inside the polygon.

""" Contains(this::ByConstRef1{TGeoPolygon}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoPolygon::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoPolygon}, option::ByCopy{String})::Nothing
Draw the polygon.

""" Draw(this::ByRef1{TGeoPolygon}, option::ByCopy{String})

# Wrapper of void TGeoPolygon::FinishPolygon()
@trydoc raw"""
    FinishPolygon(this::ByRef1{TGeoPolygon})::Nothing
Decompose polygon in a convex outscribed part and a list of daughter polygons that have to be subtracted to get the actual one.

""" FinishPolygon(this::ByRef1{TGeoPolygon})

# Wrapper of void TGeoPolygon::GetConvexVertices(Double_t *, Double_t *)
@trydoc raw"""
    GetConvexVertices(this::ByConstRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})::Nothing
Fill list of vertices of the convex outscribed polygon into provided arrays.

""" GetConvexVertices(this::ByConstRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})

# Wrapper of Int_t TGeoPolygon::GetNconvex()
@trydoc raw"""
    GetNconvex(this::ByConstRef1{TGeoPolygon})::Int32


""" GetNconvex(this::ByConstRef1{TGeoPolygon})

# Wrapper of Int_t TGeoPolygon::GetNvert()
@trydoc raw"""
    GetNvert(this::ByConstRef1{TGeoPolygon})::Int32


""" GetNvert(this::ByConstRef1{TGeoPolygon})

# Wrapper of void TGeoPolygon::GetVertices(Double_t *, Double_t *)
@trydoc raw"""
    GetVertices(this::ByConstRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})::Nothing
Fill list of vertices into provided arrays.

""" GetVertices(this::ByConstRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})

# Wrapper of Double_t * TGeoPolygon::GetX()
@trydoc raw"""
    GetX(this::ByRef1{TGeoPolygon})::CxxPtr2{Float64}


""" GetX(this::ByRef1{TGeoPolygon})

# Wrapper of Double_t * TGeoPolygon::GetY()
@trydoc raw"""
    GetY(this::ByRef1{TGeoPolygon})::CxxPtr2{Float64}


""" GetY(this::ByRef1{TGeoPolygon})

# Wrapper of Bool_t TGeoPolygon::IsClockwise()
@trydoc raw"""
    IsClockwise(this::ByConstRef1{TGeoPolygon})::Bool


""" IsClockwise(this::ByConstRef1{TGeoPolygon})

# Wrapper of Bool_t TGeoPolygon::IsConvex()
@trydoc raw"""
    IsConvex(this::ByConstRef1{TGeoPolygon})::Bool


""" IsConvex(this::ByConstRef1{TGeoPolygon})

# Wrapper of Bool_t TGeoPolygon::IsFinished()
@trydoc raw"""
    IsFinished(this::ByConstRef1{TGeoPolygon})::Bool


""" IsFinished(this::ByConstRef1{TGeoPolygon})

# Wrapper of Bool_t TGeoPolygon::IsIllegalCheck()
@trydoc raw"""
    IsIllegalCheck(this::ByConstRef1{TGeoPolygon})::Bool
Check for illegal crossings between non-consecutive segments.

""" IsIllegalCheck(this::ByConstRef1{TGeoPolygon})

# Wrapper of Double_t TGeoPolygon::Safety(const Double_t *, Int_t &)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoPolygon}, point::ByConstPtr2{Float64}, isegment::ByRef2{Int32})::Float64
Compute minimum distance from POINT to any segment. Returns segment index.

""" Safety(this::ByConstRef1{TGeoPolygon}, point::ByConstPtr2{Float64}, isegment::ByRef2{Int32})

# Wrapper of void TGeoPolygon::SetConvex(Bool_t)
@trydoc raw"""
    SetConvex(this::ByRef1{TGeoPolygon}, flag::Bool)::Nothing


""" SetConvex(this::ByRef1{TGeoPolygon}, flag::Bool)

# Wrapper of void TGeoPolygon::SetNextIndex(Int_t)
@trydoc raw"""
    SetNextIndex(this::ByRef1{TGeoPolygon}, index::Int32)::Nothing
Sets the next polygone index.
If index<0 sets all indices consecutive in increasing order.
""" SetNextIndex(this::ByRef1{TGeoPolygon}, index::Int32)

# Wrapper of void TGeoPolygon::SetXY(Double_t *, Double_t *)
@trydoc raw"""
    SetXY(this::ByRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})::Nothing
Set X/Y array pointer for the polygon and daughters.

""" SetXY(this::ByRef1{TGeoPolygon}, x::ByPtr2{Float64}, y::ByPtr2{Float64})

# Wrapper of Bool_t TGeoCacheState::GetState(Int_t &, Int_t &, Double_t *)
@trydoc raw"""
    GetState(this::ByConstRef1{TGeoCacheState}, level::ByRef2{Int32}, nmany::ByRef2{Int32}, point::ByPtr2{Float64})::Bool
Restore a modeler state.

""" GetState(this::ByConstRef1{TGeoCacheState}, level::ByRef2{Int32}, nmany::ByRef2{Int32}, point::ByPtr2{Float64})

# Wrapper of void TGeoCacheState::SetState(Int_t, Int_t, Int_t, Bool_t, Double_t *)
@trydoc raw"""
    SetState(this::ByRef1{TGeoCacheState}, level::Int32, startlevel::Int32, nmany::Int32, ovlp::Bool, point::ByPtr2{Float64})::Nothing
Fill current modeller state.

""" SetState(this::ByRef1{TGeoCacheState}, level::Int32, startlevel::Int32, nmany::Int32, ovlp::Bool, point::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::BuildIdArray()
@trydoc raw"""
    BuildIdArray(this::ByRef1{TGeoNodeCache})::Nothing
Builds node id array.

""" BuildIdArray(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::BuildInfoBranch()
@trydoc raw"""
    BuildInfoBranch(this::ByRef1{TGeoNodeCache})::Nothing
Builds info branch. Navigation is possible only after this step.

""" BuildInfoBranch(this::ByRef1{TGeoNodeCache})

# Wrapper of Bool_t TGeoNodeCache::CdDown(Int_t)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNodeCache}, index::Int32)::Bool
Make daughter INDEX of current node the active state. Compute global_ matrix.

""" CdDown(this::ByRef1{TGeoNodeCache}, index::Int32)

# Wrapper of Bool_t TGeoNodeCache::CdDown(TGeoNode *)
@trydoc raw"""
    CdDown(this::ByRef1{TGeoNodeCache}, node::ByPtr1{TGeoNode})::Bool
Make daughter INDEX of current node the active state. Compute global_ matrix.

""" CdDown(this::ByRef1{TGeoNodeCache}, node::ByPtr1{TGeoNode})

# Wrapper of void TGeoNodeCache::CdNode(Int_t)
@trydoc raw"""
    CdNode(this::ByRef1{TGeoNodeCache}, nodeid::Int32)::Nothing
Change current path to point to the node having this id.
Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)
""" CdNode(this::ByRef1{TGeoNodeCache}, nodeid::Int32)

# Wrapper of void TGeoNodeCache::CdTop()
@trydoc raw"""
    CdTop(this::ByRef1{TGeoNodeCache})::Nothing


""" CdTop(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::CdUp()
@trydoc raw"""
    CdUp(this::ByRef1{TGeoNodeCache})::Nothing
Make mother of current node the active state.

""" CdUp(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::FillIdBranch(const Int_t *, Int_t)
@trydoc raw"""
    FillIdBranch(this::ByRef1{TGeoNodeCache}, br::ByConstPtr2{Int32}, startlevel::Int32)::Nothing


""" FillIdBranch(this::ByRef1{TGeoNodeCache}, br::ByConstPtr2{Int32}, startlevel::Int32)

# Wrapper of void * TGeoNodeCache::GetBranch()
@trydoc raw"""
    GetBranch(this::ByConstRef1{TGeoNodeCache})::CxxPtr2{Nothing}


""" GetBranch(this::ByConstRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::GetBranchNames(Int_t *)
@trydoc raw"""
    GetBranchNames(this::ByConstRef1{TGeoNodeCache}, names::ByPtr2{Int32})::Nothing
Fill names with current branch volume names (4 char - used by GEANT3 interface).

""" GetBranchNames(this::ByConstRef1{TGeoNodeCache}, names::ByPtr2{Int32})

# Wrapper of void TGeoNodeCache::GetBranchNumbers(Int_t *, Int_t *)
@trydoc raw"""
    GetBranchNumbers(this::ByConstRef1{TGeoNodeCache}, copyNumbers::ByPtr2{Int32}, volumeNumbers::ByPtr2{Int32})::Nothing
Fill copy numbers of current branch nodes.

""" GetBranchNumbers(this::ByConstRef1{TGeoNodeCache}, copyNumbers::ByPtr2{Int32}, volumeNumbers::ByPtr2{Int32})

# Wrapper of void TGeoNodeCache::GetBranchOnlys(Int_t *)
@trydoc raw"""
    GetBranchOnlys(this::ByConstRef1{TGeoNodeCache}, isonly::ByPtr2{Int32})::Nothing
Fill copy numbers of current branch nodes.

""" GetBranchOnlys(this::ByConstRef1{TGeoNodeCache}, isonly::ByPtr2{Int32})

# Wrapper of TGeoHMatrix * TGeoNodeCache::GetCurrentMatrix()
@trydoc raw"""
    GetCurrentMatrix(this::ByConstRef1{TGeoNodeCache})::CxxPtr1{TGeoHMatrix}


""" GetCurrentMatrix(this::ByConstRef1{TGeoNodeCache})

# Wrapper of Int_t TGeoNodeCache::GetCurrentNodeId()
@trydoc raw"""
    GetCurrentNodeId(this::ByConstRef1{TGeoNodeCache})::Int32
Returns a fixed ID for current physical node.

""" GetCurrentNodeId(this::ByConstRef1{TGeoNodeCache})

# Wrapper of const Int_t * TGeoNodeCache::GetIdBranch()
@trydoc raw"""
    GetIdBranch(this::ByConstRef1{TGeoNodeCache})::ConstCxxPtr2{Int32}


""" GetIdBranch(this::ByConstRef1{TGeoNodeCache})

# Wrapper of TGeoStateInfo * TGeoNodeCache::GetInfo()
@trydoc raw"""
    GetInfo(this::ByRef1{TGeoNodeCache})::CxxPtr1{TGeoStateInfo}
Get next state info pointer.

""" GetInfo(this::ByRef1{TGeoNodeCache})

# Wrapper of Int_t TGeoNodeCache::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoNodeCache})::Int32


""" GetLevel(this::ByConstRef1{TGeoNodeCache})

# Wrapper of TGeoStateInfo * TGeoNodeCache::GetMakePWInfo(Int_t)
@trydoc raw"""
    GetMakePWInfo(this::ByRef1{TGeoNodeCache}, nd::Int32)::CxxPtr1{TGeoStateInfo}
Get the PW info, if none create one.

""" GetMakePWInfo(this::ByRef1{TGeoNodeCache}, nd::Int32)

# Wrapper of void * TGeoNodeCache::GetMatrices()
@trydoc raw"""
    GetMatrices(this::ByConstRef1{TGeoNodeCache})::CxxPtr2{Nothing}


""" GetMatrices(this::ByConstRef1{TGeoNodeCache})

# Wrapper of TGeoNode * TGeoNodeCache::GetMother(Int_t)
@trydoc raw"""
    GetMother(this::ByConstRef1{TGeoNodeCache}, up::Int32)::CxxPtr1{TGeoNode}


""" GetMother(this::ByConstRef1{TGeoNodeCache}, up::Int32)

# Wrapper of TGeoHMatrix * TGeoNodeCache::GetMotherMatrix(Int_t)
@trydoc raw"""
    GetMotherMatrix(this::ByConstRef1{TGeoNodeCache}, up::Int32)::CxxPtr1{TGeoHMatrix}


""" GetMotherMatrix(this::ByConstRef1{TGeoNodeCache}, up::Int32)

# Wrapper of TGeoNode * TGeoNodeCache::GetNode()
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoNodeCache})::CxxPtr1{TGeoNode}


""" GetNode(this::ByConstRef1{TGeoNodeCache})

# Wrapper of Int_t TGeoNodeCache::GetNodeId()
@trydoc raw"""
    GetNodeId(this::ByConstRef1{TGeoNodeCache})::Int32
Get unique node id.

""" GetNodeId(this::ByConstRef1{TGeoNodeCache})

# Wrapper of const char * TGeoNodeCache::GetPath()
@trydoc raw"""
    GetPath(this::ByRef1{TGeoNodeCache})::ByCopy{String}
Returns the current geometry path.

""" GetPath(this::ByRef1{TGeoNodeCache})

# Wrapper of Int_t TGeoNodeCache::GetStackLevel()
@trydoc raw"""
    GetStackLevel(this::ByConstRef1{TGeoNodeCache})::Int32


""" GetStackLevel(this::ByConstRef1{TGeoNodeCache})

# Wrapper of TGeoNode * TGeoNodeCache::GetTopNode()
@trydoc raw"""
    GetTopNode(this::ByConstRef1{TGeoNodeCache})::CxxPtr1{TGeoNode}


""" GetTopNode(this::ByConstRef1{TGeoNodeCache})

# Wrapper of Bool_t TGeoNodeCache::HasIdArray()
@trydoc raw"""
    HasIdArray(this::ByConstRef1{TGeoNodeCache})::Bool


""" HasIdArray(this::ByConstRef1{TGeoNodeCache})

# Wrapper of Bool_t TGeoNodeCache::IsDummy()
@trydoc raw"""
    IsDummy(this::ByConstRef1{TGeoNodeCache})::Bool


""" IsDummy(this::ByConstRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::LocalToMaster(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMaster(this::ByConstRef1{TGeoNodeCache}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Local point converted to master frame defined by current matrix.

""" LocalToMaster(this::ByConstRef1{TGeoNodeCache}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::LocalToMasterBomb(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterBomb(this::ByConstRef1{TGeoNodeCache}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Local point converted to master frame defined by current matrix and rescaled with bomb factor.

""" LocalToMasterBomb(this::ByConstRef1{TGeoNodeCache}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::LocalToMasterVect(const Double_t *, Double_t *)
@trydoc raw"""
    LocalToMasterVect(this::ByConstRef1{TGeoNodeCache}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})::Nothing
Local vector converted to master frame defined by current matrix.

""" LocalToMasterVect(this::ByConstRef1{TGeoNodeCache}, local_::ByConstPtr2{Float64}, master::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::MasterToLocal(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocal(this::ByConstRef1{TGeoNodeCache}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
Point in master frame defined by current matrix converted to local_ one.

""" MasterToLocal(this::ByConstRef1{TGeoNodeCache}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::MasterToLocalBomb(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalBomb(this::ByConstRef1{TGeoNodeCache}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
Point in master frame defined by current matrix converted to local_ one and rescaled with bomb factor.

""" MasterToLocalBomb(this::ByConstRef1{TGeoNodeCache}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::MasterToLocalVect(const Double_t *, Double_t *)
@trydoc raw"""
    MasterToLocalVect(this::ByConstRef1{TGeoNodeCache}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})::Nothing
Vector in master frame defined by current matrix converted to local_ one.

""" MasterToLocalVect(this::ByConstRef1{TGeoNodeCache}, master::ByConstPtr2{Float64}, local_::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::PopDummy(Int_t)
@trydoc raw"""
    PopDummy(this::ByRef1{TGeoNodeCache}, ipop::Int32)::Nothing


""" PopDummy(this::ByRef1{TGeoNodeCache}, ipop::Int32)

# Wrapper of Bool_t TGeoNodeCache::PopState(Int_t &, Double_t *)
@trydoc raw"""
    PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, point::ByPtr2{Float64})::Bool
Pop next state/point from heap.

""" PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, point::ByPtr2{Float64})

# Wrapper of Bool_t TGeoNodeCache::PopState(Int_t &, Int_t, Double_t *)
@trydoc raw"""
    PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, level::Int32, point::ByPtr2{Float64})::Bool
Pop next state/point from heap and restore matrices starting from LEVEL.

""" PopState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, level::Int32, point::ByPtr2{Float64})

# Wrapper of Int_t TGeoNodeCache::PushState(Bool_t, Int_t, Int_t, Double_t *)
@trydoc raw"""
    PushState(this::ByRef1{TGeoNodeCache}, ovlp::Bool, ntmany::Int32, startlevel::Int32, point::ByPtr2{Float64})::Int32
Push current state into heap.

""" PushState(this::ByRef1{TGeoNodeCache}, ovlp::Bool, ntmany::Int32, startlevel::Int32, point::ByPtr2{Float64})

# Wrapper of void TGeoNodeCache::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TGeoNodeCache})::Nothing


""" Refresh(this::ByRef1{TGeoNodeCache})

# Wrapper of void TGeoNodeCache::ReleaseInfo()
@trydoc raw"""
    ReleaseInfo(this::ByRef1{TGeoNodeCache})::Nothing
Release last used state info pointer.

""" ReleaseInfo(this::ByRef1{TGeoNodeCache})

# Wrapper of Bool_t TGeoNodeCache::RestoreState(Int_t &, TGeoCacheState *, Double_t *)
@trydoc raw"""
    RestoreState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, state::ByPtr1{TGeoCacheState}, point::ByPtr2{Float64})::Bool
Pop next state/point from a backed-up state.

""" RestoreState(this::ByRef1{TGeoNodeCache}, nmany::ByRef2{Int32}, state::ByPtr1{TGeoCacheState}, point::ByPtr2{Float64})

# Wrapper of Double_t TGeoCompositeShape::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoCompositeShape})::Float64
Computes capacity of this shape [length^3] by sampling with 1% error.

""" Capacity(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoCompositeShape})::Nothing
Needed just for cleanup.

""" ClearThreadData(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoCompositeShape})::Nothing
compute bounding box of the sphere

""" ComputeBBox(this::ByRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Computes normal vector in POINT to the composite shape.

""" ComputeNormal(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoCompositeShape::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64})::Bool
Tests if point is inside the shape.

""" Contains(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoCompositeShape::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of void TGeoCompositeShape::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoCompositeShape}, nthreads::Int32)::Nothing
Needed just for cleanup.

""" CreateThreadData(this::ByRef1{TGeoCompositeShape}, nthreads::Int32)

# Wrapper of Int_t TGeoCompositeShape::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoCompositeShape}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each corner.

""" DistancetoPrimitive(this::ByRef1{TGeoCompositeShape}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoCompositeShape::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to outside of this composite shape.

""" DistFromInside(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoCompositeShape::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to this composite shape.
Check if the bounding box is crossed within the requested distance
""" DistFromOutside(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoCompositeShape::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoCompositeShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide all range of iaxis in range/step cells.

""" Divide(this::ByRef1{TGeoCompositeShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of TGeoBoolNode * TGeoCompositeShape::GetBoolNode()
@trydoc raw"""
    GetBoolNode(this::ByConstRef1{TGeoCompositeShape})::CxxPtr1{TGeoBoolNode}


""" GetBoolNode(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoCompositeShape}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoCompositeShape}, param::ByPtr2{Float64})

# Wrapper of TGeoShape * TGeoCompositeShape::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoCompositeShape}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoCompositeShape}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoCompositeShape::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoCompositeShape}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoCompositeShape}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoCompositeShape::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoCompositeShape})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of Bool_t TGeoCompositeShape::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoCompositeShape}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoCompositeShape}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoCompositeShape})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of Bool_t TGeoCompositeShape::IsComposite()
@trydoc raw"""
    IsComposite(this::ByConstRef1{TGeoCompositeShape})::Bool


""" IsComposite(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of Bool_t TGeoCompositeShape::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoCompositeShape})::Bool


""" IsCylType(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of void TGeoCompositeShape::MakeNode(const char *)
@trydoc raw"""
    MakeNode(this::ByRef1{TGeoCompositeShape}, expression::ByCopy{String})::Nothing
Make a boolean node according to the top level boolean operation of expression.
Propagates signal to branches until expression is fully decomposed. printf("Making node for : %s\n", expression);
""" MakeNode(this::ByRef1{TGeoCompositeShape}, expression::ByCopy{String})

# Wrapper of Bool_t TGeoCompositeShape::PaintComposite(Option_t *)
@trydoc raw"""
    PaintComposite(this::ByConstRef1{TGeoCompositeShape}, option::ByCopy{String})::Bool
Paint this composite shape into the current 3D viewer Returns bool flag indicating if the caller should continue to paint child objects.

""" PaintComposite(this::ByConstRef1{TGeoCompositeShape}, option::ByCopy{String})

# Wrapper of void TGeoCompositeShape::RegisterYourself()
@trydoc raw"""
    RegisterYourself(this::ByRef1{TGeoCompositeShape})::Nothing
Register the shape and all components to [TGeoManager](@ref) class.

""" RegisterYourself(this::ByRef1{TGeoCompositeShape})

# Wrapper of Double_t TGeoCompositeShape::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoCompositeShape}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoCompositeShape::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoCompositeShape}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoCompositeShape::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoCompositeShape}, param::ByPtr2{Float64})::Nothing
Set dimensions based on the array of parameters param[0] - half-length in x param[1] - half-length in y param[2] - half-length in z.

""" SetDimensions(this::ByRef1{TGeoCompositeShape}, param::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoCompositeShape}, points::ByPtr2{Float64})::Nothing
create points for a composite shape

""" SetPoints(this::ByConstRef1{TGeoCompositeShape}, points::ByPtr2{Float64})

# Wrapper of void TGeoCompositeShape::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoCompositeShape}, points::ByPtr2{Float32})::Nothing
create points for a composite shape

""" SetPoints(this::ByConstRef1{TGeoCompositeShape}, points::ByPtr2{Float32})

# Wrapper of void TGeoCompositeShape::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoCompositeShape})::Nothing
compute size of this 3D object

""" Sizeof3D(this::ByConstRef1{TGeoCompositeShape})

# Wrapper of Double_t TGeoCone::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoCone})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoCone})

# Wrapper of void TGeoCone::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoCone})::Nothing
compute bounding box of the sphere

""" ComputeBBox(this::ByRef1{TGeoCone})

# Wrapper of void TGeoCone::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoCone::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoCone::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64})::Bool
test if point is inside this cone

""" Contains(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoCone::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoCone::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoCone}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoCone}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoCone::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the cone Boundary safe algorithm.

""" DistFromInside(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoCone::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoCone::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the tube

""" DistFromOutside(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoCone::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoCone::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoCone}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this cone shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For Z division creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoCone}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of const char * TGeoCone::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoCone}, iaxis::Int32)::ByCopy{String}
Returns name of axis IAXIS.

""" GetAxisName(this::ByConstRef1{TGeoCone}, iaxis::Int32)

# Wrapper of Double_t TGeoCone::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoCone}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoCone}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoCone::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoCone}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2, dZ
""" GetBoundingCylinder(this::ByConstRef1{TGeoCone}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoCone::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoCone})::Int32


""" GetByteCount(this::ByConstRef1{TGeoCone})

# Wrapper of Double_t TGeoCone::GetDz()
@trydoc raw"""
    GetDz(this::ByConstRef1{TGeoCone})::Float64


""" GetDz(this::ByConstRef1{TGeoCone})

# Wrapper of TGeoShape * TGeoCone::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoCone}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoCone}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoCone::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoCone}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoCone}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoCone::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoCone})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoCone})

# Wrapper of Bool_t TGeoCone::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoCone}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoCone}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoCone::GetRmax1()
@trydoc raw"""
    GetRmax1(this::ByConstRef1{TGeoCone})::Float64


""" GetRmax1(this::ByConstRef1{TGeoCone})

# Wrapper of Double_t TGeoCone::GetRmax2()
@trydoc raw"""
    GetRmax2(this::ByConstRef1{TGeoCone})::Float64


""" GetRmax2(this::ByConstRef1{TGeoCone})

# Wrapper of Double_t TGeoCone::GetRmin1()
@trydoc raw"""
    GetRmin1(this::ByConstRef1{TGeoCone})::Float64


""" GetRmin1(this::ByConstRef1{TGeoCone})

# Wrapper of Double_t TGeoCone::GetRmin2()
@trydoc raw"""
    GetRmin2(this::ByConstRef1{TGeoCone})::Float64


""" GetRmin2(this::ByConstRef1{TGeoCone})

# Wrapper of void TGeoCone::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoCone})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoCone})

# Wrapper of Bool_t TGeoCone::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoCone})::Bool


""" IsCylType(this::ByConstRef1{TGeoCone})

# Wrapper of Double_t TGeoCone::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoCone}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoCone::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoCone}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoCone::SetConeDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetConeDimensions(this::ByRef1{TGeoCone}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::Nothing
Set cone dimensions.

""" SetConeDimensions(this::ByRef1{TGeoCone}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of void TGeoCone::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoCone}, param::ByPtr2{Float64})::Nothing
Set cone dimensions from an array.

""" SetDimensions(this::ByRef1{TGeoCone}, param::ByPtr2{Float64})

# Wrapper of void TGeoCone::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoCone}, points::ByPtr2{Float64})::Nothing
Create cone mesh points.

""" SetPoints(this::ByConstRef1{TGeoCone}, points::ByPtr2{Float64})

# Wrapper of void TGeoCone::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoCone}, points::ByPtr2{Float32})::Nothing
Create cone mesh points.

""" SetPoints(this::ByConstRef1{TGeoCone}, points::ByPtr2{Float32})

# Wrapper of void TGeoCone::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoCone})::Nothing
Fill size of this 3-D object.

""" Sizeof3D(this::ByConstRef1{TGeoCone})

# Wrapper of Double_t TGeoCone::Capacity(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoCone!Capacity(this::ByRef1{TGeoCone}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::Float64
Computes capacity of the shape in [length^3].

""" TGeoCone!Capacity(this::ByRef1{TGeoCone}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of void TGeoCone::ComputeNormalS(const Double_t *, const Double_t *, Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoCone!ComputeNormalS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::Nothing
Compute normal to closest surface from POINT.

""" TGeoCone!ComputeNormalS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of Double_t TGeoCone::DistFromInsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoCone!DistFromInsideS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::Float64
Compute distance from inside point to surface of the cone (static) Boundary safe algorithm.

""" TGeoCone!DistFromInsideS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of Double_t TGeoCone::DistFromOutsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoCone!DistFromOutsideS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)::Float64
Compute distance from outside point to surface of the tube Boundary safe algorithm.

""" TGeoCone!DistFromOutsideS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64)

# Wrapper of void TGeoCone::DistToCone(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t &, Double_t &)
@trydoc raw"""
    TGeoCone!DistToCone(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, r1::Float64, r2::Float64, b::ByRef2{Float64}, delta::ByRef2{Float64})::Nothing
Static method to compute distance to a conical surface with :
- r1, z1 - radius and Z position of lower base
- r2, z2 - radius and Z position of upper base
""" TGeoCone!DistToCone(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, r1::Float64, r2::Float64, b::ByRef2{Float64}, delta::ByRef2{Float64})

# Wrapper of Double_t TGeoCone::SafetyS(const Double_t *, Bool_t, Double_t, Double_t, Double_t, Double_t, Double_t, Int_t)
@trydoc raw"""
    TGeoCone!SafetyS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, in::Bool, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, skipz::Int32)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" TGeoCone!SafetyS(this::ByRef1{TGeoCone}, point::ByConstPtr2{Float64}, in::Bool, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, skipz::Int32)

# Wrapper of void TGeoConeSeg::AfterStreamer()
@trydoc raw"""
    AfterStreamer(this::ByRef1{TGeoConeSeg})::Nothing
Function called after streaming an object of this class.

""" AfterStreamer(this::ByRef1{TGeoConeSeg})

# Wrapper of Double_t TGeoConeSeg::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoConeSeg})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoConeSeg})

# Wrapper of void TGeoConeSeg::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoConeSeg})::Nothing
compute bounding box of the tube segment

""" ComputeBBox(this::ByRef1{TGeoConeSeg})

# Wrapper of void TGeoConeSeg::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoConeSeg::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64})::Bool
test if point is inside this sphere

""" Contains(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoConeSeg::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoConeSeg::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoConeSeg}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoConeSeg}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoConeSeg::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the tube segment

""" DistFromInside(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoConeSeg::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the tube

""" DistFromOutside(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoConeSeg::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoConeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this cone segment shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For Z division creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoConeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoConeSeg::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoConeSeg}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoConeSeg}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoConeSeg::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoConeSeg}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoConeSeg}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoConeSeg::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoConeSeg})::Int32


""" GetByteCount(this::ByConstRef1{TGeoConeSeg})

# Wrapper of TGeoShape * TGeoConeSeg::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoConeSeg}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoConeSeg}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoConeSeg::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoConeSeg}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoConeSeg}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoConeSeg::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoConeSeg})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoConeSeg})

# Wrapper of Double_t TGeoConeSeg::GetPhi1()
@trydoc raw"""
    GetPhi1(this::ByConstRef1{TGeoConeSeg})::Float64


""" GetPhi1(this::ByConstRef1{TGeoConeSeg})

# Wrapper of Double_t TGeoConeSeg::GetPhi2()
@trydoc raw"""
    GetPhi2(this::ByConstRef1{TGeoConeSeg})::Float64


""" GetPhi2(this::ByConstRef1{TGeoConeSeg})

# Wrapper of Bool_t TGeoConeSeg::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoConeSeg}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoConeSeg}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoConeSeg})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoConeSeg})

# Wrapper of Double_t TGeoConeSeg::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoConeSeg::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoConeSeg}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoConeSeg::SetConsDimensions(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetConsDimensions(this::ByRef1{TGeoConeSeg}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::Nothing
Set dimensions of the cone segment.

""" SetConsDimensions(this::ByRef1{TGeoConeSeg}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoConeSeg::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoConeSeg}, param::ByPtr2{Float64})::Nothing
Set dimensions of the cone segment from an array.

""" SetDimensions(this::ByRef1{TGeoConeSeg}, param::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoConeSeg}, points::ByPtr2{Float64})::Nothing
Create cone segment mesh points.

""" SetPoints(this::ByConstRef1{TGeoConeSeg}, points::ByPtr2{Float64})

# Wrapper of void TGeoConeSeg::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoConeSeg}, points::ByPtr2{Float32})::Nothing
Create cone segment mesh points.

""" SetPoints(this::ByConstRef1{TGeoConeSeg}, points::ByPtr2{Float32})

# Wrapper of void TGeoConeSeg::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoConeSeg})::Nothing
Fill size of this 3-D object.

""" Sizeof3D(this::ByConstRef1{TGeoConeSeg})

# Wrapper of Double_t TGeoConeSeg::Capacity(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoConeSeg!Capacity(this::ByRef1{TGeoConeSeg}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)::Float64
Computes capacity of the shape in [length^3].

""" TGeoConeSeg!Capacity(this::ByRef1{TGeoConeSeg}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoConeSeg::ComputeNormalS(const Double_t *, const Double_t *, Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoConeSeg!ComputeNormalS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64)::Nothing
Compute normal to closest surface from POINT.

""" TGeoConeSeg!ComputeNormalS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64)

# Wrapper of Double_t TGeoConeSeg::DistFromInsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoConeSeg!DistFromInsideS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)::Float64
compute distance from inside point to surface of the tube segment

""" TGeoConeSeg!DistFromInsideS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)

# Wrapper of Double_t TGeoConeSeg::DistFromOutsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoConeSeg!DistFromOutsideS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)::Float64
compute distance from outside point to surface of arbitrary tube

""" TGeoConeSeg!DistFromOutsideS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)

# Wrapper of Double_t TGeoConeSeg::DistToCons(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoConeSeg!DistToCons(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, r1::Float64, z1::Float64, r2::Float64, z2::Float64, phi1::Float64, phi2::Float64)::Float64
Static method to compute distance to a conical surface with :
- r1, z1 - radius and Z position of lower base
- r2, z2 - radius and Z position of upper base
- phi1, phi2 - phi limits
""" TGeoConeSeg!DistToCons(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, r1::Float64, z1::Float64, r2::Float64, z2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of Double_t TGeoConeSeg::SafetyS(const Double_t *, Bool_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Int_t)
@trydoc raw"""
    TGeoConeSeg!SafetyS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, in::Bool, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64, skipz::Int32)::Float64
Static method to compute the closest distance from given point to this shape.

""" TGeoConeSeg!SafetyS(this::ByRef1{TGeoConeSeg}, point::ByConstPtr2{Float64}, in::Bool, dz::Float64, rmin1::Float64, rmax1::Float64, rmin2::Float64, rmax2::Float64, phi1::Float64, phi2::Float64, skipz::Int32)

# Wrapper of Double_t TGeoTube::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoTube})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoTube})

# Wrapper of void TGeoTube::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTube})::Nothing
compute bounding box of the tube

""" ComputeBBox(this::ByRef1{TGeoTube})

# Wrapper of void TGeoTube::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTube::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoTube::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64})::Bool
test if point is inside this tube

""" Contains(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoTube::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoTube::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTube}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoTube}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoTube::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the tube Boundary safe algorithm.

""" DistFromInside(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTube::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoTube::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the tube and safe distance Boundary safe algorithm.
fist localize point w.r.t tube
""" DistFromOutside(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTube::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoTube::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTube}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this tube shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For radial division creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTube}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of const char * TGeoTube::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoTube}, iaxis::Int32)::ByCopy{String}
Returns name of axis IAXIS.

""" GetAxisName(this::ByConstRef1{TGeoTube}, iaxis::Int32)

# Wrapper of Double_t TGeoTube::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoTube}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoTube}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoTube::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoTube}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2, dZ
""" GetBoundingCylinder(this::ByConstRef1{TGeoTube}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoTube::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoTube})::Int32


""" GetByteCount(this::ByConstRef1{TGeoTube})

# Wrapper of Double_t TGeoTube::GetDz()
@trydoc raw"""
    GetDz(this::ByConstRef1{TGeoTube})::Float64


""" GetDz(this::ByConstRef1{TGeoTube})

# Wrapper of TGeoShape * TGeoTube::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoTube}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoTube}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoTube::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoTube}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoTube}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoTube::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoTube})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoTube})

# Wrapper of Bool_t TGeoTube::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoTube}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoTube}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoTube::GetRmax()
@trydoc raw"""
    GetRmax(this::ByConstRef1{TGeoTube})::Float64


""" GetRmax(this::ByConstRef1{TGeoTube})

# Wrapper of Double_t TGeoTube::GetRmin()
@trydoc raw"""
    GetRmin(this::ByConstRef1{TGeoTube})::Float64


""" GetRmin(this::ByConstRef1{TGeoTube})

# Wrapper of Bool_t TGeoTube::HasRmin()
@trydoc raw"""
    HasRmin(this::ByConstRef1{TGeoTube})::Bool


""" HasRmin(this::ByConstRef1{TGeoTube})

# Wrapper of void TGeoTube::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoTube})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoTube})

# Wrapper of Bool_t TGeoTube::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoTube})::Bool


""" IsCylType(this::ByConstRef1{TGeoTube})

# Wrapper of Double_t TGeoTube::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoTube}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoTube::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoTube}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoTube::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTube}, param::ByPtr2{Float64})::Nothing
Set tube dimensions starting from a list.

""" SetDimensions(this::ByRef1{TGeoTube}, param::ByPtr2{Float64})

# Wrapper of void TGeoTube::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTube}, points::ByPtr2{Float64})::Nothing
create tube mesh points

""" SetPoints(this::ByConstRef1{TGeoTube}, points::ByPtr2{Float64})

# Wrapper of void TGeoTube::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTube}, points::ByPtr2{Float32})::Nothing
create tube mesh points

""" SetPoints(this::ByConstRef1{TGeoTube}, points::ByPtr2{Float32})

# Wrapper of void TGeoTube::SetTubeDimensions(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTubeDimensions(this::ByRef1{TGeoTube}, rmin::Float64, rmax::Float64, dz::Float64)::Nothing
Set tube dimensions.

""" SetTubeDimensions(this::ByRef1{TGeoTube}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of void TGeoTube::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoTube})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoTube})

# Wrapper of Double_t TGeoTube::Capacity(Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTube!Capacity(this::ByRef1{TGeoTube}, rmin::Float64, rmax::Float64, dz::Float64)::Float64
Computes capacity of the shape in [length^3].

""" TGeoTube!Capacity(this::ByRef1{TGeoTube}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of void TGeoTube::ComputeNormalS(const Double_t *, const Double_t *, Double_t *, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTube!ComputeNormalS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64)::Nothing
Compute normal to closest surface from POINT.

""" TGeoTube!ComputeNormalS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of Double_t TGeoTube::DistFromInsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTube!DistFromInsideS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64)::Float64
Compute distance from inside point to surface of the tube (static) Boundary safe algorithm.
compute distance to surface Do Z
""" TGeoTube!DistFromInsideS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of Double_t TGeoTube::DistFromOutsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTube!DistFromOutsideS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64)::Float64
Static method to compute distance from outside point to a tube with given parameters Boundary safe algorithm.
check Z planes
""" TGeoTube!DistFromOutsideS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64)

# Wrapper of void TGeoTube::DistToTube(Double_t, Double_t, Double_t, Double_t, Double_t &, Double_t &)
@trydoc raw"""
    TGeoTube!DistToTube(this::ByRef1{TGeoTube}, rsq::Float64, nsq::Float64, rdotn::Float64, radius::Float64, b::ByRef2{Float64}, delta::ByRef2{Float64})::Nothing
Static method computing the distance to a tube with given radius, starting from POINT along DIR director cosines.
The distance is computed as : RSQ = point[0]*point[0]+point[1]*point[1] NSQ = dir[0]*dir[0]+dir[1]*dir[1] —> should NOT be 0 !!! RDOTN = point[0]*dir[0]+point[1]*dir[1] The distance can be computed as : D = -B +/- DELTA where DELTA.GT.0 and D.GT.0
""" TGeoTube!DistToTube(this::ByRef1{TGeoTube}, rsq::Float64, nsq::Float64, rdotn::Float64, radius::Float64, b::ByRef2{Float64}, delta::ByRef2{Float64})

# Wrapper of Double_t TGeoTube::SafetyS(const Double_t *, Bool_t, Double_t, Double_t, Double_t, Int_t)
@trydoc raw"""
    TGeoTube!SafetyS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, in::Bool, rmin::Float64, rmax::Float64, dz::Float64, skipz::Int32)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" TGeoTube!SafetyS(this::ByRef1{TGeoTube}, point::ByConstPtr2{Float64}, in::Bool, rmin::Float64, rmax::Float64, dz::Float64, skipz::Int32)

# Wrapper of void TGeoTubeSeg::AfterStreamer()
@trydoc raw"""
    AfterStreamer(this::ByRef1{TGeoTubeSeg})::Nothing
Function called after streaming an object of this class.

""" AfterStreamer(this::ByRef1{TGeoTubeSeg})

# Wrapper of Double_t TGeoTubeSeg::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoTubeSeg})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of void TGeoTubeSeg::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTubeSeg})::Nothing
compute bounding box of the tube segment

""" ComputeBBox(this::ByRef1{TGeoTubeSeg})

# Wrapper of void TGeoTubeSeg::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoTubeSeg::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64})::Bool
test if point is inside this tube segment first check if point is inside the tube

""" Contains(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoTubeSeg::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoTubeSeg::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTubeSeg}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoTubeSeg}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoTubeSeg::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the tube segment Boundary safe algorithm.

""" DistFromInside(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoTubeSeg::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the tube segment fist localize point w.r.t tube

""" DistFromOutside(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoTubeSeg::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTubeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this tube segment shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. For radialdivision creates all volumes with different shapes and returns pointer to volume that was divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTubeSeg}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoTubeSeg::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoTubeSeg}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoTubeSeg}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoTubeSeg::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoTubeSeg}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoTubeSeg}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoTubeSeg::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoTubeSeg})::Int32


""" GetByteCount(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of TGeoShape * TGeoTubeSeg::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoTubeSeg}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoTubeSeg}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoTubeSeg::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoTubeSeg}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoTubeSeg}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoTubeSeg::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoTubeSeg})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of Double_t TGeoTubeSeg::GetPhi1()
@trydoc raw"""
    GetPhi1(this::ByConstRef1{TGeoTubeSeg})::Float64


""" GetPhi1(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of Double_t TGeoTubeSeg::GetPhi2()
@trydoc raw"""
    GetPhi2(this::ByConstRef1{TGeoTubeSeg})::Float64


""" GetPhi2(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of Bool_t TGeoTubeSeg::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoTubeSeg}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoTubeSeg}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoTubeSeg})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of Double_t TGeoTubeSeg::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point [InitTrigonometry()](@ref);to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoTubeSeg::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoTubeSeg}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoTubeSeg::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTubeSeg}, param::ByPtr2{Float64})::Nothing
Set dimensions of the tube segment starting from a list.

""" SetDimensions(this::ByRef1{TGeoTubeSeg}, param::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTubeSeg}, points::ByPtr2{Float64})::Nothing
Create tube segment mesh points.

""" SetPoints(this::ByConstRef1{TGeoTubeSeg}, points::ByPtr2{Float64})

# Wrapper of void TGeoTubeSeg::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTubeSeg}, points::ByPtr2{Float32})::Nothing
Create tube segment mesh points.

""" SetPoints(this::ByConstRef1{TGeoTubeSeg}, points::ByPtr2{Float32})

# Wrapper of void TGeoTubeSeg::SetTubsDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTubsDimensions(this::ByRef1{TGeoTubeSeg}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::Nothing
Set dimensions of the tube segment.
The segment will be from phiStart to phiEnd expressed in degree.
""" SetTubsDimensions(this::ByRef1{TGeoTubeSeg}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoTubeSeg::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoTubeSeg})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoTubeSeg})

# Wrapper of Double_t TGeoTubeSeg::Capacity(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTubeSeg!Capacity(this::ByRef1{TGeoTubeSeg}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)::Float64
Computes capacity of the shape in [length^3].

""" TGeoTubeSeg!Capacity(this::ByRef1{TGeoTubeSeg}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoTubeSeg::ComputeNormalS(const Double_t *, const Double_t *, Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTubeSeg!ComputeNormalS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64)::Nothing
Compute normal to closest surface from POINT.

""" TGeoTubeSeg!ComputeNormalS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64)

# Wrapper of Double_t TGeoTubeSeg::DistFromInsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTubeSeg!DistFromInsideS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)::Float64
Compute distance from inside point to surface of the tube segment (static) Boundary safe algorithm.
Do Z
""" TGeoTubeSeg!DistFromInsideS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)

# Wrapper of Double_t TGeoTubeSeg::DistFromOutsideS(const Double_t *, const Double_t *, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    TGeoTubeSeg!DistFromOutsideS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)::Float64
Static method to compute distance to arbitrary tube segment from outside point Boundary safe algorithm.

""" TGeoTubeSeg!DistFromOutsideS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rmin::Float64, rmax::Float64, dz::Float64, c1::Float64, s1::Float64, c2::Float64, s2::Float64, cm::Float64, sm::Float64, cdfi::Float64)

# Wrapper of Double_t TGeoTubeSeg::SafetyS(const Double_t *, Bool_t, Double_t, Double_t, Double_t, Double_t, Double_t, Int_t)
@trydoc raw"""
    TGeoTubeSeg!SafetyS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, in::Bool, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, skipz::Int32)::Float64
Static method to compute the closest distance from given point to this shape.

""" TGeoTubeSeg!SafetyS(this::ByRef1{TGeoTubeSeg}, point::ByConstPtr2{Float64}, in::Bool, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, skipz::Int32)

# Wrapper of Double_t TGeoCtub::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoCtub})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoCtub})

# Wrapper of void TGeoCtub::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoCtub})::Nothing
compute minimum bounding box of the ctub

""" ComputeBBox(this::ByRef1{TGeoCtub})

# Wrapper of void TGeoCtub::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoCtub::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoCtub::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64})::Bool
check if point is contained in the cut tube check the lower cut plane

""" Contains(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoCtub::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Double_t TGeoCtub::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the cut tube

""" DistFromInside(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoCtub::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoCtub::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the cut tube

""" DistFromOutside(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoCtub::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoCtub::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoCtub}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the tube along one axis.

""" Divide(this::ByRef1{TGeoCtub}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoCtub::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoCtub}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoCtub}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of Int_t TGeoCtub::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoCtub})::Int32


""" GetByteCount(this::ByConstRef1{TGeoCtub})

# Wrapper of TGeoShape * TGeoCtub::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoCtub}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoCtub}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoCtub::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoCtub}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoCtub}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of const Double_t * TGeoCtub::GetNhigh()
@trydoc raw"""
    GetNhigh(this::ByConstRef1{TGeoCtub})::ConstCxxPtr2{Float64}


""" GetNhigh(this::ByConstRef1{TGeoCtub})

# Wrapper of const Double_t * TGeoCtub::GetNlow()
@trydoc raw"""
    GetNlow(this::ByConstRef1{TGeoCtub})::ConstCxxPtr2{Float64}


""" GetNlow(this::ByConstRef1{TGeoCtub})

# Wrapper of Int_t TGeoCtub::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoCtub})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoCtub})

# Wrapper of Bool_t TGeoCtub::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoCtub}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoCtub}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoCtub::GetZcoord(Double_t, Double_t, Double_t)
@trydoc raw"""
    GetZcoord(this::ByConstRef1{TGeoCtub}, xc::Float64, yc::Float64, zc::Float64)::Float64
compute real Z coordinate of a point belonging to either lower or higher caps (z should be either +fDz or -fDz)

""" GetZcoord(this::ByConstRef1{TGeoCtub}, xc::Float64, yc::Float64, zc::Float64)

# Wrapper of void TGeoCtub::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoCtub})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoCtub})

# Wrapper of Double_t TGeoCtub::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoCtub}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoCtub::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoCtub}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoCtub::SetCtubDimensions(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCtubDimensions(this::ByRef1{TGeoCtub}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)::Nothing
set dimensions of a cut tube

""" SetCtubDimensions(this::ByRef1{TGeoCtub}, rmin::Float64, rmax::Float64, dz::Float64, phi1::Float64, phi2::Float64, lx::Float64, ly::Float64, lz::Float64, tx::Float64, ty::Float64, tz::Float64)

# Wrapper of void TGeoCtub::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoCtub}, param::ByPtr2{Float64})::Nothing
Set dimensions of the cut tube starting from a list.

""" SetDimensions(this::ByRef1{TGeoCtub}, param::ByPtr2{Float64})

# Wrapper of void TGeoCtub::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoCtub}, points::ByPtr2{Float64})::Nothing
Create mesh points for the cut tube.

""" SetPoints(this::ByConstRef1{TGeoCtub}, points::ByPtr2{Float64})

# Wrapper of void TGeoCtub::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoCtub}, points::ByPtr2{Float32})::Nothing
Create mesh points for the cut tube.

""" SetPoints(this::ByConstRef1{TGeoCtub}, points::ByPtr2{Float32})

# Wrapper of Double_t TGeoEltu::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoEltu})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoEltu})

# Wrapper of void TGeoEltu::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoEltu})::Nothing
compute bounding box of the tube

""" ComputeBBox(this::ByRef1{TGeoEltu})

# Wrapper of void TGeoEltu::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoEltu::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoEltu::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64})::Bool
test if point is inside the elliptical tube

""" Contains(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoEltu::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoEltu::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoEltu}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex

""" DistancetoPrimitive(this::ByRef1{TGeoEltu}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoEltu::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the tube

""" DistFromInside(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoEltu::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoEltu::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the tube and safe distance

""" DistFromOutside(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoEltu::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoEltu::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoEltu}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the shape along one axis.

""" Divide(this::ByRef1{TGeoEltu}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoEltu::GetA()
@trydoc raw"""
    GetA(this::ByConstRef1{TGeoEltu})::Float64


""" GetA(this::ByConstRef1{TGeoEltu})

# Wrapper of Double_t TGeoEltu::GetB()
@trydoc raw"""
    GetB(this::ByConstRef1{TGeoEltu})::Float64


""" GetB(this::ByConstRef1{TGeoEltu})

# Wrapper of void TGeoEltu::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoEltu}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoEltu}, param::ByPtr2{Float64})

# Wrapper of TGeoShape * TGeoEltu::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoEltu}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoEltu}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoEltu::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoEltu}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoEltu}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoEltu::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoEltu})::Int32
Returns the number of vertices on the mesh.

""" GetNmeshVertices(this::ByConstRef1{TGeoEltu})

# Wrapper of Bool_t TGeoEltu::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoEltu}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoEltu}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoEltu::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoEltu})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoEltu})

# Wrapper of Bool_t TGeoEltu::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoEltu})::Bool


""" IsCylType(this::ByConstRef1{TGeoEltu})

# Wrapper of Double_t TGeoEltu::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoEltu}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoEltu::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoEltu}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoEltu::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoEltu}, param::ByPtr2{Float64})::Nothing
Set shape dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoEltu}, param::ByPtr2{Float64})

# Wrapper of void TGeoEltu::SetEltuDimensions(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetEltuDimensions(this::ByRef1{TGeoEltu}, a::Float64, b::Float64, dz::Float64)::Nothing
Set dimensions of the elliptical tube.

""" SetEltuDimensions(this::ByRef1{TGeoEltu}, a::Float64, b::Float64, dz::Float64)

# Wrapper of void TGeoEltu::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoEltu}, points::ByPtr2{Float64})::Nothing
Create elliptical tube mesh points.

""" SetPoints(this::ByConstRef1{TGeoEltu}, points::ByPtr2{Float64})

# Wrapper of void TGeoEltu::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoEltu}, points::ByPtr2{Float32})::Nothing
Create elliptical tube mesh points.

""" SetPoints(this::ByConstRef1{TGeoEltu}, points::ByPtr2{Float32})

# Wrapper of TObject * TGeoRCExtension::GetUserObject()
@trydoc raw"""
    GetUserObject(this::ByConstRef1{TGeoRCExtension})::CxxPtr1{TObject}


""" GetUserObject(this::ByConstRef1{TGeoRCExtension})

# Wrapper of TGeoExtension * TGeoRCExtension::Grab()
@trydoc raw"""
    Grab(this::ByRef1{TGeoRCExtension})::CxxPtr1{TGeoExtension}


""" Grab(this::ByRef1{TGeoRCExtension})

# Wrapper of void TGeoRCExtension::Release()
@trydoc raw"""
    Release(this::ByConstRef1{TGeoRCExtension})::Nothing


""" Release(this::ByConstRef1{TGeoRCExtension})

# Wrapper of void TGeoRCExtension::SetUserObject(TObject *)
@trydoc raw"""
    SetUserObject(this::ByRef1{TGeoRCExtension}, obj::ByPtr1{TObject})::Nothing


""" SetUserObject(this::ByRef1{TGeoRCExtension}, obj::ByPtr1{TObject})

# Wrapper of void TVirtualMagField::Field(const Double_t *, Double_t *)
@trydoc raw"""
    Field(this::ByRef1{TVirtualMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})::Nothing


""" Field(this::ByRef1{TVirtualMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})

# Wrapper of void TGeoUniformMagField::Field(const Double_t *, Double_t *)
@trydoc raw"""
    Field(this::ByRef1{TGeoUniformMagField}, ::ByConstPtr2{Float64}, B::ByPtr2{Float64})::Nothing


""" Field(this::ByRef1{TGeoUniformMagField}, ::ByConstPtr2{Float64}, B::ByPtr2{Float64})

# Wrapper of const Double_t * TGeoUniformMagField::GetFieldValue()
@trydoc raw"""
    GetFieldValue(this::ByConstRef1{TGeoUniformMagField})::ConstCxxPtr2{Float64}


""" GetFieldValue(this::ByConstRef1{TGeoUniformMagField})

# Wrapper of void TGeoUniformMagField::SetFieldValue(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetFieldValue(this::ByRef1{TGeoUniformMagField}, Bx::Float64, By::Float64, Bz::Float64)::Nothing


""" SetFieldValue(this::ByRef1{TGeoUniformMagField}, Bx::Float64, By::Float64, Bz::Float64)

# Wrapper of void TGeoGlobalMagField::Field(const Double_t *, Double_t *)
@trydoc raw"""
    Field(this::ByRef1{TGeoGlobalMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})::Nothing


""" Field(this::ByRef1{TGeoGlobalMagField}, x::ByConstPtr2{Float64}, B::ByPtr2{Float64})

# Wrapper of TVirtualMagField * TGeoGlobalMagField::GetField()
@trydoc raw"""
    GetField(this::ByConstRef1{TGeoGlobalMagField})::CxxPtr1{TVirtualMagField}


""" GetField(this::ByConstRef1{TGeoGlobalMagField})

# Wrapper of Bool_t TGeoGlobalMagField::IsLocked()
@trydoc raw"""
    IsLocked(this::ByRef1{TGeoGlobalMagField})::Bool


""" IsLocked(this::ByRef1{TGeoGlobalMagField})

# Wrapper of void TGeoGlobalMagField::Lock()
@trydoc raw"""
    Lock(this::ByRef1{TGeoGlobalMagField})::Nothing
Locks the global_ magnetic field if this is set. Cannot be unlocked.

""" Lock(this::ByRef1{TGeoGlobalMagField})

# Wrapper of void TGeoGlobalMagField::SetField(TVirtualMagField *)
@trydoc raw"""
    SetField(this::ByRef1{TGeoGlobalMagField}, field::ByPtr1{TVirtualMagField})::Nothing
Field setter. Deletes previous field if any. Acts only if fLock=kFALSE.

""" SetField(this::ByRef1{TGeoGlobalMagField}, field::ByPtr1{TVirtualMagField})

# Wrapper of TGeoGlobalMagField * TGeoGlobalMagField::GetInstance()
@trydoc raw"""
    TGeoGlobalMagField!GetInstance(this::ByRef1{TGeoGlobalMagField})::CxxPtr1{TGeoGlobalMagField}
Static getter that does not create the object.

""" TGeoGlobalMagField!GetInstance(this::ByRef1{TGeoGlobalMagField})

# Wrapper of TGeoGlobalMagField * TGeoGlobalMagField::Instance()
@trydoc raw"""
    TGeoGlobalMagField!Instance(this::ByRef1{TGeoGlobalMagField})::CxxPtr1{TGeoGlobalMagField}
Returns always a valid static pointer to the field manager.

""" TGeoGlobalMagField!Instance(this::ByRef1{TGeoGlobalMagField})

# Wrapper of Double_t TGeoHalfSpace::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoHalfSpace})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoHalfSpace})

# Wrapper of void TGeoHalfSpace::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoHalfSpace})::Nothing
Compute bounding box - nothing to do in this case.

""" ComputeBBox(this::ByRef1{TGeoHalfSpace})

# Wrapper of void TGeoHalfSpace::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoHalfSpace::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoHalfSpace::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64})::Bool
test if point is inside the half-space

""" Contains(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoHalfSpace::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoHalfSpace::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoHalfSpace}, px::Int32, py::Int32)::Int32
A half-space does not have a mesh primitive.

""" DistancetoPrimitive(this::ByRef1{TGeoHalfSpace}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoHalfSpace::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to the plane

""" DistFromInside(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoHalfSpace::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoHalfSpace::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to the plane

""" DistFromOutside(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoHalfSpace::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoHalfSpace::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoHalfSpace}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the shape along one axis.

""" Divide(this::ByRef1{TGeoHalfSpace}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoHalfSpace::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoHalfSpace}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoHalfSpace}, param::ByPtr2{Float64})

# Wrapper of TGeoShape * TGeoHalfSpace::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoHalfSpace}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoHalfSpace}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoHalfSpace::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoHalfSpace}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoHalfSpace}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoHalfSpace::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoHalfSpace})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoHalfSpace})

# Wrapper of Double_t * TGeoHalfSpace::GetNorm()
@trydoc raw"""
    GetNorm(this::ByRef1{TGeoHalfSpace})::CxxPtr2{Float64}


""" GetNorm(this::ByRef1{TGeoHalfSpace})

# Wrapper of Double_t * TGeoHalfSpace::GetPoint()
@trydoc raw"""
    GetPoint(this::ByRef1{TGeoHalfSpace})::CxxPtr2{Float64}


""" GetPoint(this::ByRef1{TGeoHalfSpace})

# Wrapper of void TGeoHalfSpace::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoHalfSpace})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoHalfSpace})

# Wrapper of Bool_t TGeoHalfSpace::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoHalfSpace})::Bool


""" IsCylType(this::ByConstRef1{TGeoHalfSpace})

# Wrapper of Double_t TGeoHalfSpace::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoHalfSpace}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoHalfSpace::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoHalfSpace}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoHalfSpace::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoHalfSpace}, param::ByPtr2{Float64})::Nothing
Set half-space parameters as stored in an array.

""" SetDimensions(this::ByRef1{TGeoHalfSpace}, param::ByPtr2{Float64})

# Wrapper of void TGeoHalfSpace::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoHalfSpace}, points::ByPtr2{Float64})::Nothing
Fill box points.

""" SetPoints(this::ByConstRef1{TGeoHalfSpace}, points::ByPtr2{Float64})

# Wrapper of void TGeoHalfSpace::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoHalfSpace}, points::ByPtr2{Float32})::Nothing
Fill box points.

""" SetPoints(this::ByConstRef1{TGeoHalfSpace}, points::ByPtr2{Float32})

# Wrapper of void TGeoHalfSpace::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoHalfSpace})::Nothing


""" Sizeof3D(this::ByConstRef1{TGeoHalfSpace})

# Wrapper of Double_t TGeoHelix::ComputeSafeStep(Double_t)
@trydoc raw"""
    ComputeSafeStep(this::ByConstRef1{TGeoHelix}, epsil::Float64)::Float64
Compute safe linear step that can be made such that the error between linear-helix extrapolation is less than EPSIL.

""" ComputeSafeStep(this::ByConstRef1{TGeoHelix}, epsil::Float64)

# Wrapper of const Double_t * TGeoHelix::GetCurrentDirection()
@trydoc raw"""
    GetCurrentDirection(this::ByConstRef1{TGeoHelix})::ConstCxxPtr2{Float64}


""" GetCurrentDirection(this::ByConstRef1{TGeoHelix})

# Wrapper of const Double_t * TGeoHelix::GetCurrentPoint()
@trydoc raw"""
    GetCurrentPoint(this::ByConstRef1{TGeoHelix})::ConstCxxPtr2{Float64}


""" GetCurrentPoint(this::ByConstRef1{TGeoHelix})

# Wrapper of Double_t TGeoHelix::GetStep()
@trydoc raw"""
    GetStep(this::ByConstRef1{TGeoHelix})::Float64


""" GetStep(this::ByConstRef1{TGeoHelix})

# Wrapper of Double_t TGeoHelix::GetTotalCurvature()
@trydoc raw"""
    GetTotalCurvature(this::ByConstRef1{TGeoHelix})::Float64
Compute helix total curvature.

""" GetTotalCurvature(this::ByConstRef1{TGeoHelix})

# Wrapper of Double_t TGeoHelix::GetXYcurvature()
@trydoc raw"""
    GetXYcurvature(this::ByConstRef1{TGeoHelix})::Float64


""" GetXYcurvature(this::ByConstRef1{TGeoHelix})

# Wrapper of void TGeoHelix::InitDirection(Double_t *, Bool_t)
@trydoc raw"""
    InitDirection(this::ByRef1{TGeoHelix}, dir::ByPtr2{Float64}, is_normalized::Bool)::Nothing
Initialize particle direction (tangent on the helix in initial point)

""" InitDirection(this::ByRef1{TGeoHelix}, dir::ByPtr2{Float64}, is_normalized::Bool)

# Wrapper of void TGeoHelix::InitDirection(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    InitDirection(this::ByRef1{TGeoHelix}, dirx::Float64, diry::Float64, dirz::Float64, is_normalized::Bool)::Nothing
Initialize particle direction (tangent on the helix in initial point)

""" InitDirection(this::ByRef1{TGeoHelix}, dirx::Float64, diry::Float64, dirz::Float64, is_normalized::Bool)

# Wrapper of void TGeoHelix::InitPoint(Double_t *)
@trydoc raw"""
    InitPoint(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64})::Nothing
Set initial point on the helix.

""" InitPoint(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64})

# Wrapper of void TGeoHelix::InitPoint(Double_t, Double_t, Double_t)
@trydoc raw"""
    InitPoint(this::ByRef1{TGeoHelix}, x0::Float64, y0::Float64, z0::Float64)::Nothing
Initialize coordinates of a point on the helix.

""" InitPoint(this::ByRef1{TGeoHelix}, x0::Float64, y0::Float64, z0::Float64)

# Wrapper of Bool_t TGeoHelix::IsRightHanded()
@trydoc raw"""
    IsRightHanded(this::ByConstRef1{TGeoHelix})::Bool


""" IsRightHanded(this::ByConstRef1{TGeoHelix})

# Wrapper of void TGeoHelix::ResetStep()
@trydoc raw"""
    ResetStep(this::ByRef1{TGeoHelix})::Nothing
Reset current point/direction to initial values.

""" ResetStep(this::ByRef1{TGeoHelix})

# Wrapper of void TGeoHelix::SetCharge(Int_t)
@trydoc raw"""
    SetCharge(this::ByRef1{TGeoHelix}, charge::Int32)::Nothing
Positive charge means left-handed helix.

""" SetCharge(this::ByRef1{TGeoHelix}, charge::Int32)

# Wrapper of void TGeoHelix::SetField(Double_t, Double_t, Double_t, Bool_t)
@trydoc raw"""
    SetField(this::ByRef1{TGeoHelix}, bx::Float64, by::Float64, bz::Float64, is_normalized::Bool)::Nothing
Initialize particle direction (tangent on the helix in initial point)

""" SetField(this::ByRef1{TGeoHelix}, bx::Float64, by::Float64, bz::Float64, is_normalized::Bool)

# Wrapper of void TGeoHelix::SetHelixStep(Double_t)
@trydoc raw"""
    SetHelixStep(this::ByRef1{TGeoHelix}, hstep::Float64)::Nothing
Set Z step of the helix on a complete turn. Positive or null.

""" SetHelixStep(this::ByRef1{TGeoHelix}, hstep::Float64)

# Wrapper of void TGeoHelix::SetXYcurvature(Double_t)
@trydoc raw"""
    SetXYcurvature(this::ByRef1{TGeoHelix}, curvature::Float64)::Nothing
Set XY curvature: c = 1/Rxy.

""" SetXYcurvature(this::ByRef1{TGeoHelix}, curvature::Float64)

# Wrapper of void TGeoHelix::Step(Double_t)
@trydoc raw"""
    Step(this::ByRef1{TGeoHelix}, step::Float64)::Nothing
Make a step from current point along the helix and compute new point, direction and angle To reach a plane/ shape boundary, one has to:
1. Compute the safety to the plane/boundary
2. Define / update a helix according local_ field and particle state (position, direction, charge)
3. Compute the magnetic safety (maximum distance for which the field can be considered constant)
4. Call [TGeoHelix!Step()](@ref) having as argument the minimum between 1. and 3.
5. Repeat from 1. until the step to be made is small enough.
6. Add to the total step the distance along a straight line from the last point to the plane/shape boundary
""" Step(this::ByRef1{TGeoHelix}, step::Float64)

# Wrapper of Double_t TGeoHelix::StepToPlane(Double_t *, Double_t *)
@trydoc raw"""
    StepToPlane(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64}, norm::ByPtr2{Float64})::Float64
Propagate initial point up to a given Z position in MARS.

""" StepToPlane(this::ByRef1{TGeoHelix}, point::ByPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoHelix::UpdateHelix()
@trydoc raw"""
    UpdateHelix(this::ByRef1{TGeoHelix})::Nothing
Update the local_ helix matrix.

""" UpdateHelix(this::ByRef1{TGeoHelix})

# Wrapper of Double_t TGeoHype::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoHype})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoHype})

# Wrapper of void TGeoHype::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoHype})::Nothing
Compute bounding box of the hyperboloid.

""" ComputeBBox(this::ByRef1{TGeoHype})

# Wrapper of void TGeoHype::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoHype::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoHype::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64})::Bool
test if point is inside this tube

""" Contains(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoHype::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoHype::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoHype}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoHype}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoHype::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the hyperboloid.

""" DistFromInside(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoHype::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoHype::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the hyperboloid.

""" DistFromOutside(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoHype::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Int_t TGeoHype::DistToHype(const Double_t *, const Double_t *, Double_t *, Bool_t, Bool_t)
@trydoc raw"""
    DistToHype(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, s::ByPtr2{Float64}, inner::Bool, in::Bool)::Int32
Compute distance from an arbitrary point to inner/outer surface of hyperboloid.
Returns number of positive solutions. S[2] contains the solutions.
""" DistToHype(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, s::ByPtr2{Float64}, inner::Bool, in::Bool)

# Wrapper of TGeoVolume * TGeoHype::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoHype}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Cannot divide hyperboloids.

""" Divide(this::ByRef1{TGeoHype}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoHype::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoHype}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoHype}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoHype::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoHype}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2, dZ
""" GetBoundingCylinder(this::ByConstRef1{TGeoHype}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoHype::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoHype})::Int32


""" GetByteCount(this::ByConstRef1{TGeoHype})

# Wrapper of TGeoShape * TGeoHype::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoHype}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoHype}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoHype::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoHype}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoHype}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoHype::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoHype})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoHype})

# Wrapper of Bool_t TGeoHype::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoHype}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoHype}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoHype::GetStIn()
@trydoc raw"""
    GetStIn(this::ByConstRef1{TGeoHype})::Float64


""" GetStIn(this::ByConstRef1{TGeoHype})

# Wrapper of Double_t TGeoHype::GetStOut()
@trydoc raw"""
    GetStOut(this::ByConstRef1{TGeoHype})::Float64


""" GetStOut(this::ByConstRef1{TGeoHype})

# Wrapper of Bool_t TGeoHype::HasInner()
@trydoc raw"""
    HasInner(this::ByConstRef1{TGeoHype})::Bool


""" HasInner(this::ByConstRef1{TGeoHype})

# Wrapper of void TGeoHype::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoHype})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoHype})

# Wrapper of Bool_t TGeoHype::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoHype})::Bool


""" IsCylType(this::ByConstRef1{TGeoHype})

# Wrapper of Double_t TGeoHype::RadiusHypeSq(Double_t, Bool_t)
@trydoc raw"""
    RadiusHypeSq(this::ByConstRef1{TGeoHype}, z::Float64, inner::Bool)::Float64
Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas.

""" RadiusHypeSq(this::ByConstRef1{TGeoHype}, z::Float64, inner::Bool)

# Wrapper of Double_t TGeoHype::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoHype::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoHype}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Double_t TGeoHype::SafetyToHype(const Double_t *, Bool_t, Bool_t)
@trydoc raw"""
    SafetyToHype(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, inner::Bool, in::Bool)::Float64
Compute an underestimate of the closest distance from a point to inner or outer infinite hyperbolas.

""" SafetyToHype(this::ByConstRef1{TGeoHype}, point::ByConstPtr2{Float64}, inner::Bool, in::Bool)

# Wrapper of void TGeoHype::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoHype}, param::ByPtr2{Float64})::Nothing
Set dimensions of the hyperboloid starting from an array.
- param[0] = dz
- param[1] = rin
- param[2] = stin
- param[3] = rout
- param[4] = stout
""" SetDimensions(this::ByRef1{TGeoHype}, param::ByPtr2{Float64})

# Wrapper of void TGeoHype::SetHypeDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetHypeDimensions(this::ByRef1{TGeoHype}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)::Nothing
Set dimensions of the hyperboloid.

""" SetHypeDimensions(this::ByRef1{TGeoHype}, rin::Float64, stin::Float64, rout::Float64, stout::Float64, dz::Float64)

# Wrapper of void TGeoHype::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoHype}, points::ByPtr2{Float64})::Nothing
create tube mesh points

""" SetPoints(this::ByConstRef1{TGeoHype}, points::ByPtr2{Float64})

# Wrapper of void TGeoHype::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoHype}, points::ByPtr2{Float32})::Nothing
create tube mesh points

""" SetPoints(this::ByConstRef1{TGeoHype}, points::ByPtr2{Float32})

# Wrapper of void TGeoHype::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoHype})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoHype})

# Wrapper of Double_t TGeoHype::ZHypeSq(Double_t, Bool_t)
@trydoc raw"""
    ZHypeSq(this::ByConstRef1{TGeoHype}, r::Float64, inner::Bool)::Float64
Compute z^2 at a given r^2, for either inner or outer hyperbolas.

""" ZHypeSq(this::ByConstRef1{TGeoHype}, r::Float64, inner::Bool)

# Wrapper of TGeoNavigator * TGeoNavigatorArray::AddNavigator()
@trydoc raw"""
    AddNavigator(this::ByRef1{TGeoNavigatorArray})::CxxPtr1{TGeoNavigator}
Add a new navigator to the array.

""" AddNavigator(this::ByRef1{TGeoNavigatorArray})

# Wrapper of TGeoNavigator * TGeoNavigatorArray::GetCurrentNavigator()
@trydoc raw"""
    GetCurrentNavigator(this::ByConstRef1{TGeoNavigatorArray})::CxxPtr1{TGeoNavigator}


""" GetCurrentNavigator(this::ByConstRef1{TGeoNavigatorArray})

# Wrapper of TGeoNavigator * TGeoNavigatorArray::SetCurrentNavigator(Int_t)
@trydoc raw"""
    SetCurrentNavigator(this::ByRef1{TGeoNavigatorArray}, inav::Int32)::CxxPtr1{TGeoNavigator}


""" SetCurrentNavigator(this::ByRef1{TGeoNavigatorArray}, inav::Int32)

# Wrapper of void TGeoRegion::AddCut(const char *, Double_t)
@trydoc raw"""
    AddCut(this::ByRef1{TGeoRegion}, name::ByCopy{String}, cut::Float64)::Nothing
Add cut to the region.

""" AddCut(this::ByRef1{TGeoRegion}, name::ByCopy{String}, cut::Float64)

# Wrapper of void TGeoRegion::AddCut(const TGeoRegionCut &)
@trydoc raw"""
    AddCut(this::ByRef1{TGeoRegion}, regioncut::ByConstRef1{TGeoRegionCut})::Nothing
Add an identical cut to the region.

""" AddCut(this::ByRef1{TGeoRegion}, regioncut::ByConstRef1{TGeoRegionCut})

# Wrapper of bool TGeoRegion::AddVolume(const char *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoRegion}, name::ByCopy{String})::Bool
Add an existing volume to the region.

""" AddVolume(this::ByRef1{TGeoRegion}, name::ByCopy{String})

# Wrapper of void TGeoRegion::AddVolume(TGeoVolume *)
@trydoc raw"""
    AddVolume(this::ByRef1{TGeoRegion}, vol::ByPtr1{TGeoVolume})::Nothing


""" AddVolume(this::ByRef1{TGeoRegion}, vol::ByPtr1{TGeoVolume})

# Wrapper of TGeoRegionCut * TGeoRegion::GetCut(int)
@trydoc raw"""
    GetCut(this::ByConstRef1{TGeoRegion}, i::Int32)::CxxPtr1{TGeoRegionCut}


""" GetCut(this::ByConstRef1{TGeoRegion}, i::Int32)

# Wrapper of int TGeoRegion::GetNcuts()
@trydoc raw"""
    GetNcuts(this::ByConstRef1{TGeoRegion})::Int32


""" GetNcuts(this::ByConstRef1{TGeoRegion})

# Wrapper of int TGeoRegion::GetNvolumes()
@trydoc raw"""
    GetNvolumes(this::ByConstRef1{TGeoRegion})::Int32


""" GetNvolumes(this::ByConstRef1{TGeoRegion})

# Wrapper of TGeoVolume * TGeoRegion::GetVolume(int)
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoRegion}, i::Int32)::CxxPtr1{TGeoVolume}


""" GetVolume(this::ByConstRef1{TGeoRegion}, i::Int32)

# Wrapper of TGeoRegion & TGeoRegion::operator=(const TGeoRegion &)
@trydoc raw"""
    assign(this::ByRef1{TGeoRegion}, other::ByConstRef1{TGeoRegion})::CxxRef1{TGeoRegion}
Assignment operator.

""" assign(this::ByRef1{TGeoRegion}, other::ByConstRef1{TGeoRegion})

# Wrapper of void TGeoRegion::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoRegion}, option::ByCopy{String})::Nothing
Print region info.

""" Print(this::ByConstRef1{TGeoRegion}, option::ByCopy{String})

# Wrapper of TVirtualGeoTrack * TVirtualGeoTrack::AddDaughter(Int_t, Int_t, TObject *)
@trydoc raw"""
    AddDaughter(this::ByRef1{TVirtualGeoTrack}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::CxxPtr1{TVirtualGeoTrack}


""" AddDaughter(this::ByRef1{TVirtualGeoTrack}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of Int_t TVirtualGeoTrack::AddDaughter(TVirtualGeoTrack *)
@trydoc raw"""
    AddDaughter(this::ByRef1{TVirtualGeoTrack}, other::ByPtr1{TVirtualGeoTrack})::Int32


""" AddDaughter(this::ByRef1{TVirtualGeoTrack}, other::ByPtr1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::AddPoint(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    AddPoint(this::ByRef1{TVirtualGeoTrack}, x::Float64, y::Float64, z::Float64, t::Float64)::Nothing


""" AddPoint(this::ByRef1{TVirtualGeoTrack}, x::Float64, y::Float64, z::Float64, t::Float64)

# Wrapper of TVirtualGeoTrack * TVirtualGeoTrack::FindTrackWithId(Int_t)
@trydoc raw"""
    FindTrackWithId(this::ByConstRef1{TVirtualGeoTrack}, id::Int32)::CxxPtr1{TVirtualGeoTrack}
Recursively search through this track for a daughter particle (at any depth) with the specified id.

""" FindTrackWithId(this::ByConstRef1{TVirtualGeoTrack}, id::Int32)

# Wrapper of TVirtualGeoTrack * TVirtualGeoTrack::GetDaughter(Int_t)
@trydoc raw"""
    GetDaughter(this::ByConstRef1{TVirtualGeoTrack}, index::Int32)::CxxPtr1{TVirtualGeoTrack}


""" GetDaughter(this::ByConstRef1{TVirtualGeoTrack}, index::Int32)

# Wrapper of Int_t TVirtualGeoTrack::GetDaughterId(Int_t)
@trydoc raw"""
    GetDaughterId(this::ByConstRef1{TVirtualGeoTrack}, index::Int32)::Int32
Returns daughter id.

""" GetDaughterId(this::ByConstRef1{TVirtualGeoTrack}, index::Int32)

# Wrapper of const Double_t * TVirtualGeoTrack::GetFirstPoint()
@trydoc raw"""
    GetFirstPoint(this::ByConstRef1{TVirtualGeoTrack})::ConstCxxPtr2{Float64}


""" GetFirstPoint(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Int_t TVirtualGeoTrack::GetId()
@trydoc raw"""
    GetId(this::ByConstRef1{TVirtualGeoTrack})::Int32


""" GetId(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of const Double_t * TVirtualGeoTrack::GetLastPoint()
@trydoc raw"""
    GetLastPoint(this::ByConstRef1{TVirtualGeoTrack})::ConstCxxPtr2{Float64}


""" GetLastPoint(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Int_t TVirtualGeoTrack::GetLastPoint(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetLastPoint(this::ByConstRef1{TVirtualGeoTrack}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, t::ByRef2{Float64})::Int32


""" GetLastPoint(this::ByConstRef1{TVirtualGeoTrack}, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, t::ByRef2{Float64})

# Wrapper of TVirtualGeoTrack * TVirtualGeoTrack::GetMother()
@trydoc raw"""
    GetMother(this::ByConstRef1{TVirtualGeoTrack})::CxxPtr1{TVirtualGeoTrack}


""" GetMother(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of TObject * TVirtualGeoTrack::GetMotherParticle()
@trydoc raw"""
    GetMotherParticle(this::ByConstRef1{TVirtualGeoTrack})::CxxPtr1{TObject}


""" GetMotherParticle(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of const char * TVirtualGeoTrack::GetName()
@trydoc raw"""
    GetName(this::ByConstRef1{TVirtualGeoTrack})::ByCopy{String}
Get the PDG name.

""" GetName(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Int_t TVirtualGeoTrack::GetNdaughters()
@trydoc raw"""
    GetNdaughters(this::ByConstRef1{TVirtualGeoTrack})::Int32


""" GetNdaughters(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Int_t TVirtualGeoTrack::GetNpoints()
@trydoc raw"""
    GetNpoints(this::ByConstRef1{TVirtualGeoTrack})::Int32


""" GetNpoints(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Int_t TVirtualGeoTrack::GetParentId()
@trydoc raw"""
    GetParentId(this::ByConstRef1{TVirtualGeoTrack})::Int32


""" GetParentId(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of TObject * TVirtualGeoTrack::GetParticle()
@trydoc raw"""
    GetParticle(this::ByConstRef1{TVirtualGeoTrack})::CxxPtr1{TObject}


""" GetParticle(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Int_t TVirtualGeoTrack::GetPDG()
@trydoc raw"""
    GetPDG(this::ByConstRef1{TVirtualGeoTrack})::Int32


""" GetPDG(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of const Double_t * TVirtualGeoTrack::GetPoint(Int_t)
@trydoc raw"""
    GetPoint(this::ByConstRef1{TVirtualGeoTrack}, i::Int32)::ConstCxxPtr2{Float64}


""" GetPoint(this::ByConstRef1{TVirtualGeoTrack}, i::Int32)

# Wrapper of Int_t TVirtualGeoTrack::GetPoint(Int_t, Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetPoint(this::ByConstRef1{TVirtualGeoTrack}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, t::ByRef2{Float64})::Int32


""" GetPoint(this::ByConstRef1{TVirtualGeoTrack}, i::Int32, x::ByRef2{Float64}, y::ByRef2{Float64}, z::ByRef2{Float64}, t::ByRef2{Float64})

# Wrapper of Bool_t TVirtualGeoTrack::HasPoints()
@trydoc raw"""
    HasPoints(this::ByConstRef1{TVirtualGeoTrack})::Bool


""" HasPoints(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of Bool_t TVirtualGeoTrack::IsInTimeRange()
@trydoc raw"""
    IsInTimeRange(this::ByConstRef1{TVirtualGeoTrack})::Bool
True if track TOF range overlaps with time interval of [TGeoManager](@ref).

""" IsInTimeRange(this::ByConstRef1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})

# Wrapper of void TVirtualGeoTrack::PaintCollect(Double_t, Double_t *)
@trydoc raw"""
    PaintCollect(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})::Nothing


""" PaintCollect(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})

# Wrapper of void TVirtualGeoTrack::PaintCollectTrack(Double_t, Double_t *)
@trydoc raw"""
    PaintCollectTrack(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})::Nothing


""" PaintCollectTrack(this::ByRef1{TVirtualGeoTrack}, ::Float64, ::ByPtr2{Float64})

# Wrapper of void TVirtualGeoTrack::PaintTrack(Option_t *)
@trydoc raw"""
    PaintTrack(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})::Nothing


""" PaintTrack(this::ByRef1{TVirtualGeoTrack}, option::ByCopy{String})

# Wrapper of void TVirtualGeoTrack::ResetTrack()
@trydoc raw"""
    ResetTrack(this::ByRef1{TVirtualGeoTrack})::Nothing


""" ResetTrack(this::ByRef1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::SetId(Int_t)
@trydoc raw"""
    SetId(this::ByRef1{TVirtualGeoTrack}, id::Int32)::Nothing


""" SetId(this::ByRef1{TVirtualGeoTrack}, id::Int32)

# Wrapper of void TVirtualGeoTrack::SetName(const char *)
@trydoc raw"""
    SetName(this::ByRef1{TVirtualGeoTrack}, name::ByCopy{String})::Nothing
Set a default name for this track.

""" SetName(this::ByRef1{TVirtualGeoTrack}, name::ByCopy{String})

# Wrapper of void TVirtualGeoTrack::SetParent(TVirtualGeoTrack *)
@trydoc raw"""
    SetParent(this::ByRef1{TVirtualGeoTrack}, parent::ByPtr1{TVirtualGeoTrack})::Nothing


""" SetParent(this::ByRef1{TVirtualGeoTrack}, parent::ByPtr1{TVirtualGeoTrack})

# Wrapper of void TVirtualGeoTrack::SetParticle(TObject *)
@trydoc raw"""
    SetParticle(this::ByRef1{TVirtualGeoTrack}, particle::ByPtr1{TObject})::Nothing


""" SetParticle(this::ByRef1{TVirtualGeoTrack}, particle::ByPtr1{TObject})

# Wrapper of void TVirtualGeoTrack::SetPDG(Int_t)
@trydoc raw"""
    SetPDG(this::ByRef1{TVirtualGeoTrack}, pdgcode::Int32)::Nothing


""" SetPDG(this::ByRef1{TVirtualGeoTrack}, pdgcode::Int32)

# Wrapper of void TVirtualGeoPainter::AddSize3D(Int_t, Int_t, Int_t)
@trydoc raw"""
    AddSize3D(this::ByRef1{TVirtualGeoPainter}, numpoints::Int32, numsegs::Int32, numpolys::Int32)::Nothing


""" AddSize3D(this::ByRef1{TVirtualGeoPainter}, numpoints::Int32, numsegs::Int32, numpolys::Int32)

# Wrapper of TVirtualGeoTrack * TVirtualGeoPainter::AddTrack(Int_t, Int_t, TObject *)
@trydoc raw"""
    AddTrack(this::ByRef1{TVirtualGeoPainter}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})::CxxPtr1{TVirtualGeoTrack}


""" AddTrack(this::ByRef1{TVirtualGeoPainter}, id::Int32, pdgcode::Int32, particle::ByPtr1{TObject})

# Wrapper of void TVirtualGeoPainter::AddTrackPoint(Double_t *, Double_t *, Bool_t)
@trydoc raw"""
    AddTrackPoint(this::ByRef1{TVirtualGeoPainter}, point::ByPtr2{Float64}, box::ByPtr2{Float64}, reset::Bool)::Nothing


""" AddTrackPoint(this::ByRef1{TVirtualGeoPainter}, point::ByPtr2{Float64}, box::ByPtr2{Float64}, reset::Bool)

# Wrapper of void TVirtualGeoPainter::BombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    BombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing


""" BombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of void TVirtualGeoPainter::CheckBoundaryErrors(Int_t, Double_t)
@trydoc raw"""
    CheckBoundaryErrors(this::ByRef1{TVirtualGeoPainter}, ntracks::Int32, radius::Float64)::Nothing


""" CheckBoundaryErrors(this::ByRef1{TVirtualGeoPainter}, ntracks::Int32, radius::Float64)

# Wrapper of void TVirtualGeoPainter::CheckBoundaryReference(Int_t)
@trydoc raw"""
    CheckBoundaryReference(this::ByRef1{TVirtualGeoPainter}, icheck::Int32)::Nothing


""" CheckBoundaryReference(this::ByRef1{TVirtualGeoPainter}, icheck::Int32)

# Wrapper of void TVirtualGeoPainter::CheckGeometry(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    CheckGeometry(this::ByConstRef1{TVirtualGeoPainter}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64)::Nothing


""" CheckGeometry(this::ByConstRef1{TVirtualGeoPainter}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64)

# Wrapper of void TVirtualGeoPainter::CheckGeometryFull(Bool_t, Bool_t, Int_t, const Double_t *)
@trydoc raw"""
    CheckGeometryFull(this::ByRef1{TVirtualGeoPainter}, checkoverlaps::Bool, checkcrossings::Bool, nrays::Int32, vertex::ByConstPtr2{Float64})::Nothing


""" CheckGeometryFull(this::ByRef1{TVirtualGeoPainter}, checkoverlaps::Bool, checkcrossings::Bool, nrays::Int32, vertex::ByConstPtr2{Float64})

# Wrapper of void TVirtualGeoPainter::CheckOverlaps(const TGeoVolume *, Double_t, Option_t *)
@trydoc raw"""
    CheckOverlaps(this::ByConstRef1{TVirtualGeoPainter}, vol::ByConstPtr1{TGeoVolume}, ovlp::Float64, option::ByCopy{String})::Nothing


""" CheckOverlaps(this::ByConstRef1{TVirtualGeoPainter}, vol::ByConstPtr1{TGeoVolume}, ovlp::Float64, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::CheckPoint(Double_t, Double_t, Double_t, Option_t *, Double_t)
@trydoc raw"""
    CheckPoint(this::ByRef1{TVirtualGeoPainter}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)::Nothing


""" CheckPoint(this::ByRef1{TVirtualGeoPainter}, x::Float64, y::Float64, z::Float64, option::ByCopy{String}, safety::Float64)

# Wrapper of void TVirtualGeoPainter::CheckShape(TGeoShape *, Int_t, Int_t, Option_t *)
@trydoc raw"""
    CheckShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})::Nothing


""" CheckShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, testNo::Int32, nsamples::Int32, option::ByCopy{String})

# Wrapper of Int_t TVirtualGeoPainter::CountVisibleNodes()
@trydoc raw"""
    CountVisibleNodes(this::ByRef1{TVirtualGeoPainter})::Int32


""" CountVisibleNodes(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::DefaultAngles()
@trydoc raw"""
    DefaultAngles(this::ByRef1{TVirtualGeoPainter})::Nothing


""" DefaultAngles(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::DefaultColors()
@trydoc raw"""
    DefaultColors(this::ByRef1{TVirtualGeoPainter})::Nothing


""" DefaultColors(this::ByRef1{TVirtualGeoPainter})

# Wrapper of Int_t TVirtualGeoPainter::DistanceToPrimitiveVol(TGeoVolume *, Int_t, Int_t)
@trydoc raw"""
    DistanceToPrimitiveVol(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, px::Int32, py::Int32)::Int32


""" DistanceToPrimitiveVol(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::DrawBatemanSol(TGeoBatemanSol *, Option_t *)
@trydoc raw"""
    DrawBatemanSol(this::ByRef1{TVirtualGeoPainter}, sol::ByPtr1{TGeoBatemanSol}, option::ByCopy{String})::Nothing


""" DrawBatemanSol(this::ByRef1{TVirtualGeoPainter}, sol::ByPtr1{TGeoBatemanSol}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawCurrentPoint(Int_t)
@trydoc raw"""
    DrawCurrentPoint(this::ByRef1{TVirtualGeoPainter}, color::Int32)::Nothing


""" DrawCurrentPoint(this::ByRef1{TVirtualGeoPainter}, color::Int32)

# Wrapper of void TVirtualGeoPainter::DrawOnly(Option_t *)
@trydoc raw"""
    DrawOnly(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing


""" DrawOnly(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawOverlap(void *, Option_t *)
@trydoc raw"""
    DrawOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})::Nothing


""" DrawOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawPanel()
@trydoc raw"""
    DrawPanel(this::ByRef1{TVirtualGeoPainter})::Nothing


""" DrawPanel(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::DrawPath(const char *, Option_t *)
@trydoc raw"""
    DrawPath(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String}, option::ByCopy{String})::Nothing


""" DrawPath(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawPolygon(const TGeoPolygon *)
@trydoc raw"""
    DrawPolygon(this::ByRef1{TVirtualGeoPainter}, poly::ByConstPtr1{TGeoPolygon})::Nothing


""" DrawPolygon(this::ByRef1{TVirtualGeoPainter}, poly::ByConstPtr1{TGeoPolygon})

# Wrapper of void TVirtualGeoPainter::DrawShape(TGeoShape *, Option_t *)
@trydoc raw"""
    DrawShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})::Nothing


""" DrawShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::DrawVolume(TGeoVolume *, Option_t *)
@trydoc raw"""
    DrawVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String})::Nothing


""" DrawVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::EditGeometry(Option_t *)
@trydoc raw"""
    EditGeometry(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing


""" EditGeometry(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::EstimateCameraMove(Double_t, Double_t, Double_t *, Double_t *)
@trydoc raw"""
    EstimateCameraMove(this::ByRef1{TVirtualGeoPainter}, ::Float64, ::Float64, ::ByPtr2{Float64}, ::ByPtr2{Float64})::Nothing


""" EstimateCameraMove(this::ByRef1{TVirtualGeoPainter}, ::Float64, ::Float64, ::ByPtr2{Float64}, ::ByPtr2{Float64})

# Wrapper of void TVirtualGeoPainter::ExecuteManagerEvent(TGeoManager *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteManagerEvent(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteManagerEvent(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::ExecuteShapeEvent(TGeoShape *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteShapeEvent(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteShapeEvent(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::ExecuteVolumeEvent(TGeoVolume *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ExecuteVolumeEvent(this::ByRef1{TVirtualGeoPainter}, volume::ByPtr1{TGeoVolume}, event::Int32, px::Int32, py::Int32)::Nothing


""" ExecuteVolumeEvent(this::ByRef1{TVirtualGeoPainter}, volume::ByPtr1{TGeoVolume}, event::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::GetBombFactors(Double_t &, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetBombFactors(this::ByConstRef1{TVirtualGeoPainter}, bombx::ByRef2{Float64}, bomby::ByRef2{Float64}, bombz::ByRef2{Float64}, bombr::ByRef2{Float64})::Nothing


""" GetBombFactors(this::ByConstRef1{TVirtualGeoPainter}, bombx::ByRef2{Float64}, bomby::ByRef2{Float64}, bombz::ByRef2{Float64}, bombr::ByRef2{Float64})

# Wrapper of Int_t TVirtualGeoPainter::GetBombMode()
@trydoc raw"""
    GetBombMode(this::ByConstRef1{TVirtualGeoPainter})::Int32


""" GetBombMode(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of Int_t TVirtualGeoPainter::GetColor(Int_t, Float_t)
@trydoc raw"""
    GetColor(this::ByConstRef1{TVirtualGeoPainter}, base::Int32, light::Float32)::Int32


""" GetColor(this::ByConstRef1{TVirtualGeoPainter}, base::Int32, light::Float32)

# Wrapper of TGeoVolume * TVirtualGeoPainter::GetDrawnVolume()
@trydoc raw"""
    GetDrawnVolume(this::ByConstRef1{TVirtualGeoPainter})::CxxPtr1{TGeoVolume}


""" GetDrawnVolume(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of const char * TVirtualGeoPainter::GetDrawPath()
@trydoc raw"""
    GetDrawPath(this::ByConstRef1{TVirtualGeoPainter})::ByCopy{String}


""" GetDrawPath(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of Int_t TVirtualGeoPainter::GetNsegments()
@trydoc raw"""
    GetNsegments(this::ByConstRef1{TVirtualGeoPainter})::Int32


""" GetNsegments(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of TGeoVolume * TVirtualGeoPainter::GetTopVolume()
@trydoc raw"""
    GetTopVolume(this::ByConstRef1{TVirtualGeoPainter})::CxxPtr1{TGeoVolume}


""" GetTopVolume(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::GetViewAngles(Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetViewAngles(this::ByRef1{TVirtualGeoPainter}, ::ByRef2{Float64}, ::ByRef2{Float64}, ::ByRef2{Float64})::Nothing


""" GetViewAngles(this::ByRef1{TVirtualGeoPainter}, ::ByRef2{Float64}, ::ByRef2{Float64}, ::ByRef2{Float64})

# Wrapper of Double_t * TVirtualGeoPainter::GetViewBox()
@trydoc raw"""
    GetViewBox(this::ByRef1{TVirtualGeoPainter})::CxxPtr2{Float64}


""" GetViewBox(this::ByRef1{TVirtualGeoPainter})

# Wrapper of Int_t TVirtualGeoPainter::GetVisLevel()
@trydoc raw"""
    GetVisLevel(this::ByConstRef1{TVirtualGeoPainter})::Int32


""" GetVisLevel(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of Int_t TVirtualGeoPainter::GetVisOption()
@trydoc raw"""
    GetVisOption(this::ByConstRef1{TVirtualGeoPainter})::Int32


""" GetVisOption(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of const char * TVirtualGeoPainter::GetVolumeInfo(const TGeoVolume *, Int_t, Int_t)
@trydoc raw"""
    GetVolumeInfo(this::ByConstRef1{TVirtualGeoPainter}, volume::ByConstPtr1{TGeoVolume}, px::Int32, py::Int32)::ByCopy{String}


""" GetVolumeInfo(this::ByConstRef1{TVirtualGeoPainter}, volume::ByConstPtr1{TGeoVolume}, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::GrabFocus(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    GrabFocus(this::ByRef1{TVirtualGeoPainter}, nfr::Int32, dlong::Float64, dlat::Float64, dpsi::Float64)::Nothing


""" GrabFocus(this::ByRef1{TVirtualGeoPainter}, nfr::Int32, dlong::Float64, dlat::Float64, dpsi::Float64)

# Wrapper of Bool_t TVirtualGeoPainter::IsExplodedView()
@trydoc raw"""
    IsExplodedView(this::ByConstRef1{TVirtualGeoPainter})::Bool


""" IsExplodedView(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of Bool_t TVirtualGeoPainter::IsPaintingShape()
@trydoc raw"""
    IsPaintingShape(this::ByConstRef1{TVirtualGeoPainter})::Bool


""" IsPaintingShape(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of Bool_t TVirtualGeoPainter::IsRaytracing()
@trydoc raw"""
    IsRaytracing(this::ByConstRef1{TVirtualGeoPainter})::Bool


""" IsRaytracing(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of TH2F * TVirtualGeoPainter::LegoPlot(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t, Double_t, Double_t, Option_t *)
@trydoc raw"""
    LegoPlot(this::ByRef1{TVirtualGeoPainter}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})::CxxPtr1{TH2F}


""" LegoPlot(this::ByRef1{TVirtualGeoPainter}, ntheta::Int32, themin::Float64, themax::Float64, nphi::Int32, phimin::Float64, phimax::Float64, rmin::Float64, rmax::Float64, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::ModifiedPad(Bool_t)
@trydoc raw"""
    ModifiedPad(this::ByConstRef1{TVirtualGeoPainter}, update::Bool)::Nothing


""" ModifiedPad(this::ByConstRef1{TVirtualGeoPainter}, update::Bool)

# Wrapper of void TVirtualGeoPainter::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing
This method must be overridden if a class wants to paint itself.
The difference between [Paint()](@ref) and [Draw()](@ref) is that when a object draws itself it is added to the display list of the pad in which it is drawn (and automatically redrawn whenever the pad is redrawn). While paint just draws the object without adding it to the pad display list.
""" Paint(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::PaintNode(TGeoNode *, Option_t *, TGeoMatrix *)
@trydoc raw"""
    PaintNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})::Nothing


""" PaintNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})

# Wrapper of void TVirtualGeoPainter::PaintOverlap(void *, Option_t *)
@trydoc raw"""
    PaintOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})::Nothing


""" PaintOverlap(this::ByRef1{TVirtualGeoPainter}, ovlp::ByPtr2{Nothing}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::PaintShape(TGeoShape *, Option_t *)
@trydoc raw"""
    PaintShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})::Nothing


""" PaintShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape}, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::PaintVolume(TGeoVolume *, Option_t *, TGeoMatrix *)
@trydoc raw"""
    PaintVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})::Nothing


""" PaintVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume}, option::ByCopy{String}, global_::ByPtr1{TGeoMatrix})

# Wrapper of void TVirtualGeoPainter::PrintOverlaps()
@trydoc raw"""
    PrintOverlaps(this::ByConstRef1{TVirtualGeoPainter})::Nothing


""" PrintOverlaps(this::ByConstRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::RandomPoints(const TGeoVolume *, Int_t, Option_t *)
@trydoc raw"""
    RandomPoints(this::ByRef1{TVirtualGeoPainter}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})::Nothing


""" RandomPoints(this::ByRef1{TVirtualGeoPainter}, vol::ByConstPtr1{TGeoVolume}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::RandomRays(Int_t, Double_t, Double_t, Double_t, const char *, Bool_t)
@trydoc raw"""
    RandomRays(this::ByRef1{TVirtualGeoPainter}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)::Nothing


""" RandomRays(this::ByRef1{TVirtualGeoPainter}, nrays::Int32, startx::Float64, starty::Float64, startz::Float64, target_vol::ByCopy{String}, check_norm::Bool)

# Wrapper of void TVirtualGeoPainter::Raytrace(Option_t *)
@trydoc raw"""
    Raytrace(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})::Nothing


""" Raytrace(this::ByRef1{TVirtualGeoPainter}, option::ByCopy{String})

# Wrapper of TGeoNode * TVirtualGeoPainter::SamplePoints(Int_t, Double_t &, Double_t, const char *)
@trydoc raw"""
    SamplePoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})::CxxPtr1{TGeoNode}


""" SamplePoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, dist::ByRef2{Float64}, epsil::Float64, g3path::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::SetBombFactors(Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetBombFactors(this::ByRef1{TVirtualGeoPainter}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)::Nothing


""" SetBombFactors(this::ByRef1{TVirtualGeoPainter}, bombx::Float64, bomby::Float64, bombz::Float64, bombr::Float64)

# Wrapper of void TVirtualGeoPainter::SetCheckedNode(TGeoNode *)
@trydoc raw"""
    SetCheckedNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode})::Nothing


""" SetCheckedNode(this::ByRef1{TVirtualGeoPainter}, node::ByPtr1{TGeoNode})

# Wrapper of void TVirtualGeoPainter::SetClippingShape(TGeoShape *)
@trydoc raw"""
    SetClippingShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape})::Nothing


""" SetClippingShape(this::ByRef1{TVirtualGeoPainter}, shape::ByPtr1{TGeoShape})

# Wrapper of void TVirtualGeoPainter::SetExplodedView(Int_t)
@trydoc raw"""
    SetExplodedView(this::ByRef1{TVirtualGeoPainter}, iopt::Int32)::Nothing


""" SetExplodedView(this::ByRef1{TVirtualGeoPainter}, iopt::Int32)

# Wrapper of void TVirtualGeoPainter::SetGeoManager(TGeoManager *)
@trydoc raw"""
    SetGeoManager(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager})::Nothing


""" SetGeoManager(this::ByRef1{TVirtualGeoPainter}, geom::ByPtr1{TGeoManager})

# Wrapper of void TVirtualGeoPainter::SetIteratorPlugin(TGeoIteratorPlugin *)
@trydoc raw"""
    SetIteratorPlugin(this::ByRef1{TVirtualGeoPainter}, plugin::ByPtr1{TGeoIteratorPlugin})::Nothing


""" SetIteratorPlugin(this::ByRef1{TVirtualGeoPainter}, plugin::ByPtr1{TGeoIteratorPlugin})

# Wrapper of void TVirtualGeoPainter::SetNmeshPoints(Int_t)
@trydoc raw"""
    SetNmeshPoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32)::Nothing


""" SetNmeshPoints(this::ByRef1{TVirtualGeoPainter}, npoints::Int32)

# Wrapper of void TVirtualGeoPainter::SetNsegments(Int_t)
@trydoc raw"""
    SetNsegments(this::ByRef1{TVirtualGeoPainter}, nseg::Int32)::Nothing


""" SetNsegments(this::ByRef1{TVirtualGeoPainter}, nseg::Int32)

# Wrapper of void TVirtualGeoPainter::SetRaytracing(Bool_t)
@trydoc raw"""
    SetRaytracing(this::ByRef1{TVirtualGeoPainter}, flag::Bool)::Nothing


""" SetRaytracing(this::ByRef1{TVirtualGeoPainter}, flag::Bool)

# Wrapper of void TVirtualGeoPainter::SetTopVisible(Bool_t)
@trydoc raw"""
    SetTopVisible(this::ByRef1{TVirtualGeoPainter}, vis::Bool)::Nothing


""" SetTopVisible(this::ByRef1{TVirtualGeoPainter}, vis::Bool)

# Wrapper of void TVirtualGeoPainter::SetTopVolume(TGeoVolume *)
@trydoc raw"""
    SetTopVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})::Nothing


""" SetTopVolume(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TVirtualGeoPainter::SetVisLevel(Int_t)
@trydoc raw"""
    SetVisLevel(this::ByRef1{TVirtualGeoPainter}, level::Int32)::Nothing


""" SetVisLevel(this::ByRef1{TVirtualGeoPainter}, level::Int32)

# Wrapper of void TVirtualGeoPainter::SetVisOption(Int_t)
@trydoc raw"""
    SetVisOption(this::ByRef1{TVirtualGeoPainter}, option::Int32)::Nothing


""" SetVisOption(this::ByRef1{TVirtualGeoPainter}, option::Int32)

# Wrapper of Int_t TVirtualGeoPainter::ShapeDistancetoPrimitive(const TGeoShape *, Int_t, Int_t, Int_t)
@trydoc raw"""
    ShapeDistancetoPrimitive(this::ByConstRef1{TVirtualGeoPainter}, shape::ByConstPtr1{TGeoShape}, numpoints::Int32, px::Int32, py::Int32)::Int32


""" ShapeDistancetoPrimitive(this::ByConstRef1{TVirtualGeoPainter}, shape::ByConstPtr1{TGeoShape}, numpoints::Int32, px::Int32, py::Int32)

# Wrapper of void TVirtualGeoPainter::Test(Int_t, Option_t *)
@trydoc raw"""
    Test(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, option::ByCopy{String})::Nothing


""" Test(this::ByRef1{TVirtualGeoPainter}, npoints::Int32, option::ByCopy{String})

# Wrapper of void TVirtualGeoPainter::TestOverlaps(const char *)
@trydoc raw"""
    TestOverlaps(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String})::Nothing


""" TestOverlaps(this::ByRef1{TVirtualGeoPainter}, path::ByCopy{String})

# Wrapper of Bool_t TVirtualGeoPainter::TestVoxels(TGeoVolume *)
@trydoc raw"""
    TestVoxels(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})::Bool


""" TestVoxels(this::ByRef1{TVirtualGeoPainter}, vol::ByPtr1{TGeoVolume})

# Wrapper of void TVirtualGeoPainter::UnbombTranslation(const Double_t *, Double_t *)
@trydoc raw"""
    UnbombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})::Nothing


""" UnbombTranslation(this::ByRef1{TVirtualGeoPainter}, tr::ByConstPtr2{Float64}, bombtr::ByPtr2{Float64})

# Wrapper of Double_t TVirtualGeoPainter::Weight(Double_t, Option_t *)
@trydoc raw"""
    Weight(this::ByRef1{TVirtualGeoPainter}, precision::Float64, option::ByCopy{String})::Float64


""" Weight(this::ByRef1{TVirtualGeoPainter}, precision::Float64, option::ByCopy{String})

# Wrapper of TVirtualGeoPainter * TVirtualGeoPainter::GeoPainter()
@trydoc raw"""
    TVirtualGeoPainter!GeoPainter(this::ByRef1{TVirtualGeoPainter})::CxxPtr1{TVirtualGeoPainter}
Static function returning a pointer to the geometry painter.
The painter will paint objects from the specified geometry. If the geometry painter does not exist a default painter is created.
""" TVirtualGeoPainter!GeoPainter(this::ByRef1{TVirtualGeoPainter})

# Wrapper of void TVirtualGeoPainter::SetPainter(const TVirtualGeoPainter *)
@trydoc raw"""
    TVirtualGeoPainter!SetPainter(this::ByRef1{TVirtualGeoPainter}, painter::ByConstPtr1{TVirtualGeoPainter})::Nothing
Static function to set an alternative histogram painter.

""" TVirtualGeoPainter!SetPainter(this::ByRef1{TVirtualGeoPainter}, painter::ByConstPtr1{TVirtualGeoPainter})

# Wrapper of TGeoHMatrix * TGeoPNEntry::GetGlobalOrig()
@trydoc raw"""
    GetGlobalOrig(this::ByConstRef1{TGeoPNEntry})::CxxPtr1{TGeoHMatrix}


""" GetGlobalOrig(this::ByConstRef1{TGeoPNEntry})

# Wrapper of const TGeoHMatrix * TGeoPNEntry::GetMatrix()
@trydoc raw"""
    GetMatrix(this::ByConstRef1{TGeoPNEntry})::ConstCxxPtr1{TGeoHMatrix}


""" GetMatrix(this::ByConstRef1{TGeoPNEntry})

# Wrapper of TGeoHMatrix * TGeoPNEntry::GetMatrixOrig()
@trydoc raw"""
    GetMatrixOrig(this::ByConstRef1{TGeoPNEntry})::CxxPtr1{TGeoHMatrix}


""" GetMatrixOrig(this::ByConstRef1{TGeoPNEntry})

# Wrapper of const char * TGeoPNEntry::GetPath()
@trydoc raw"""
    GetPath(this::ByConstRef1{TGeoPNEntry})::ByCopy{String}


""" GetPath(this::ByConstRef1{TGeoPNEntry})

# Wrapper of TGeoPhysicalNode * TGeoPNEntry::GetPhysicalNode()
@trydoc raw"""
    GetPhysicalNode(this::ByConstRef1{TGeoPNEntry})::CxxPtr1{TGeoPhysicalNode}


""" GetPhysicalNode(this::ByConstRef1{TGeoPNEntry})

# Wrapper of void TGeoPNEntry::SetMatrix(const TGeoHMatrix *)
@trydoc raw"""
    SetMatrix(this::ByRef1{TGeoPNEntry}, matrix::ByConstPtr1{TGeoHMatrix})::Nothing
Set the additional matrix for this node entry.
The matrix will be deleted by this class unless registered by the user to gGeoManager
""" SetMatrix(this::ByRef1{TGeoPNEntry}, matrix::ByConstPtr1{TGeoHMatrix})

# Wrapper of void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *)
@trydoc raw"""
    SetPhysicalNode(this::ByRef1{TGeoPNEntry}, node::ByPtr1{TGeoPhysicalNode})::Nothing
Setter for the corresponding physical node.

""" SetPhysicalNode(this::ByRef1{TGeoPNEntry}, node::ByPtr1{TGeoPhysicalNode})

# Wrapper of Bool_t TGeoPhysicalNode::Align(TGeoMatrix *, TGeoShape *, Bool_t, Double_t)
@trydoc raw"""
    Align(this::ByRef1{TGeoPhysicalNode}, newmat::ByPtr1{TGeoMatrix}, newshape::ByPtr1{TGeoShape}, check::Bool, ovlp::Float64)::Bool
Align a physical node with a new relative matrix/shape.
Example: /TOP_1/A_1/B_1/C_1 node->Align(transl_1, box) will perform:

- change RELATIVE translation of C_1 node (with respect to its container volume B) to transl_1
- change the shape of the C volume *NOTE* The operations will affect ONLY the LAST node in the branch. All volumes/nodes in the branch represented by this physical node are CLONED so the operation does not affect other possible replicas.
""" Align(this::ByRef1{TGeoPhysicalNode}, newmat::ByPtr1{TGeoMatrix}, newshape::ByPtr1{TGeoShape}, check::Bool, ovlp::Float64)

# Wrapper of void TGeoPhysicalNode::cd()
@trydoc raw"""
    cd(this::ByConstRef1{TGeoPhysicalNode})::Nothing


""" cd(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of void TGeoPhysicalNode::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})::Nothing
Draw this node.

""" Draw(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})

# Wrapper of Int_t TGeoPhysicalNode::GetLevel()
@trydoc raw"""
    GetLevel(this::ByConstRef1{TGeoPhysicalNode})::Int32


""" GetLevel(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of TGeoHMatrix * TGeoPhysicalNode::GetMatrix(Int_t)
@trydoc raw"""
    GetMatrix(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)::CxxPtr1{TGeoHMatrix}
Return global_ matrix for node at LEVEL.

""" GetMatrix(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)

# Wrapper of TGeoNode * TGeoPhysicalNode::GetMother(Int_t)
@trydoc raw"""
    GetMother(this::ByConstRef1{TGeoPhysicalNode}, levup::Int32)::CxxPtr1{TGeoNode}
Return parent at LEVUP generation.

""" GetMother(this::ByConstRef1{TGeoPhysicalNode}, levup::Int32)

# Wrapper of TGeoNode * TGeoPhysicalNode::GetNode(Int_t)
@trydoc raw"""
    GetNode(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)::CxxPtr1{TGeoNode}
Return node in branch at LEVEL. If not specified, return last leaf.

""" GetNode(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)

# Wrapper of TGeoHMatrix * TGeoPhysicalNode::GetOriginalMatrix()
@trydoc raw"""
    GetOriginalMatrix(this::ByConstRef1{TGeoPhysicalNode})::CxxPtr1{TGeoHMatrix}


""" GetOriginalMatrix(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of TGeoShape * TGeoPhysicalNode::GetShape(Int_t)
@trydoc raw"""
    GetShape(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)::CxxPtr1{TGeoShape}
Return shape associated with volume.

""" GetShape(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)

# Wrapper of TGeoVolume * TGeoPhysicalNode::GetVolume(Int_t)
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)::CxxPtr1{TGeoVolume}
Return volume associated with node at LEVEL in the branch.

""" GetVolume(this::ByConstRef1{TGeoPhysicalNode}, level::Int32)

# Wrapper of Bool_t TGeoPhysicalNode::IsAligned()
@trydoc raw"""
    IsAligned(this::ByConstRef1{TGeoPhysicalNode})::Bool


""" IsAligned(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *)
@trydoc raw"""
    IsMatchingState(this::ByConstRef1{TGeoPhysicalNode}, nav::ByPtr1{TGeoNavigator})::Bool
Checks if a given navigator state matches this physical node.

""" IsMatchingState(this::ByConstRef1{TGeoPhysicalNode}, nav::ByPtr1{TGeoNavigator})

# Wrapper of Bool_t TGeoPhysicalNode::IsVisible()
@trydoc raw"""
    IsVisible(this::ByConstRef1{TGeoPhysicalNode})::Bool


""" IsVisible(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of Bool_t TGeoPhysicalNode::IsVisibleFull()
@trydoc raw"""
    IsVisibleFull(this::ByConstRef1{TGeoPhysicalNode})::Bool


""" IsVisibleFull(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of Bool_t TGeoPhysicalNode::IsVolAttributes()
@trydoc raw"""
    IsVolAttributes(this::ByConstRef1{TGeoPhysicalNode})::Bool


""" IsVolAttributes(this::ByConstRef1{TGeoPhysicalNode})

# Wrapper of void TGeoPhysicalNode::Paint(Option_t *)
@trydoc raw"""
    Paint(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})::Nothing
Paint this node and its content according to visualization settings.

""" Paint(this::ByRef1{TGeoPhysicalNode}, option::ByCopy{String})

# Wrapper of void TGeoPhysicalNode::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoPhysicalNode}, option::ByCopy{String})::Nothing
Print info about this node.

""" Print(this::ByConstRef1{TGeoPhysicalNode}, option::ByCopy{String})

# Wrapper of void TGeoPhysicalNode::Refresh()
@trydoc raw"""
    Refresh(this::ByRef1{TGeoPhysicalNode})::Nothing
Refresh this physical node.
Called for all registered physical nodes after an [Align()](@ref) call.
""" Refresh(this::ByRef1{TGeoPhysicalNode})

# Wrapper of void TGeoPhysicalNode::SetIsVolAtt(Bool_t)
@trydoc raw"""
    SetIsVolAtt(this::ByRef1{TGeoPhysicalNode}, flag::Bool)::Nothing


""" SetIsVolAtt(this::ByRef1{TGeoPhysicalNode}, flag::Bool)

# Wrapper of void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *)
@trydoc raw"""
    SetMatrixOrig(this::ByRef1{TGeoPhysicalNode}, local_::ByConstPtr1{TGeoMatrix})::Nothing
Allows PN entries (or users) to preset the local_ original matrix for the last node pointed by the path.

""" SetMatrixOrig(this::ByRef1{TGeoPhysicalNode}, local_::ByConstPtr1{TGeoMatrix})

# Wrapper of void TGeoPhysicalNode::SetVisibility(Bool_t)
@trydoc raw"""
    SetVisibility(this::ByRef1{TGeoPhysicalNode}, flag::Bool)::Nothing


""" SetVisibility(this::ByRef1{TGeoPhysicalNode}, flag::Bool)

# Wrapper of void TGeoPhysicalNode::SetVisibleFull(Bool_t)
@trydoc raw"""
    SetVisibleFull(this::ByRef1{TGeoPhysicalNode}, flag::Bool)::Nothing


""" SetVisibleFull(this::ByRef1{TGeoPhysicalNode}, flag::Bool)

# Wrapper of bool TGeoOpticalSurface::AddConstProperty(const char *, const char *)
@trydoc raw"""
    AddConstProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddConstProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of bool TGeoOpticalSurface::AddProperty(const char *, const char *)
@trydoc raw"""
    AddProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})::Bool


""" AddProperty(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String}, ref::ByCopy{String})

# Wrapper of Double_t TGeoOpticalSurface::GetConstProperty(const char *, Bool_t *)
@trydoc raw"""
    GetConstProperty(this::ByConstRef1{TGeoOpticalSurface}, property::ByCopy{String}, error::ByPtr2{Bool})::Float64


""" GetConstProperty(this::ByConstRef1{TGeoOpticalSurface}, property::ByCopy{String}, error::ByPtr2{Bool})

# Wrapper of Double_t TGeoOpticalSurface::GetConstProperty(Int_t, Bool_t *)
@trydoc raw"""
    GetConstProperty(this::ByConstRef1{TGeoOpticalSurface}, i::Int32, error::ByPtr2{Bool})::Float64


""" GetConstProperty(this::ByConstRef1{TGeoOpticalSurface}, i::Int32, error::ByPtr2{Bool})

# Wrapper of const char * TGeoOpticalSurface::GetConstPropertyRef(const char *)
@trydoc raw"""
    GetConstPropertyRef(this::ByConstRef1{TGeoOpticalSurface}, property::ByCopy{String})::ByCopy{String}


""" GetConstPropertyRef(this::ByConstRef1{TGeoOpticalSurface}, property::ByCopy{String})

# Wrapper of const char * TGeoOpticalSurface::GetConstPropertyRef(Int_t)
@trydoc raw"""
    GetConstPropertyRef(this::ByConstRef1{TGeoOpticalSurface}, i::Int32)::ByCopy{String}


""" GetConstPropertyRef(this::ByConstRef1{TGeoOpticalSurface}, i::Int32)

# Wrapper of Int_t TGeoOpticalSurface::GetNconstProperties()
@trydoc raw"""
    GetNconstProperties(this::ByConstRef1{TGeoOpticalSurface})::Int32


""" GetNconstProperties(this::ByConstRef1{TGeoOpticalSurface})

# Wrapper of Int_t TGeoOpticalSurface::GetNproperties()
@trydoc raw"""
    GetNproperties(this::ByConstRef1{TGeoOpticalSurface})::Int32


""" GetNproperties(this::ByConstRef1{TGeoOpticalSurface})

# Wrapper of Double_t TGeoOpticalSurface::GetPolish()
@trydoc raw"""
    GetPolish(this::ByConstRef1{TGeoOpticalSurface})::Float64


""" GetPolish(this::ByConstRef1{TGeoOpticalSurface})

# Wrapper of TGDMLMatrix * TGeoOpticalSurface::GetProperty(const char *)
@trydoc raw"""
    GetProperty(this::ByConstRef1{TGeoOpticalSurface}, name::ByCopy{String})::CxxPtr1{TGDMLMatrix}


""" GetProperty(this::ByConstRef1{TGeoOpticalSurface}, name::ByCopy{String})

# Wrapper of TGDMLMatrix * TGeoOpticalSurface::GetProperty(Int_t)
@trydoc raw"""
    GetProperty(this::ByConstRef1{TGeoOpticalSurface}, i::Int32)::CxxPtr1{TGDMLMatrix}


""" GetProperty(this::ByConstRef1{TGeoOpticalSurface}, i::Int32)

# Wrapper of const char * TGeoOpticalSurface::GetPropertyRef(const char *)
@trydoc raw"""
    GetPropertyRef(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String})::ByCopy{String}


""" GetPropertyRef(this::ByRef1{TGeoOpticalSurface}, property::ByCopy{String})

# Wrapper of const char * TGeoOpticalSurface::GetPropertyRef(Int_t)
@trydoc raw"""
    GetPropertyRef(this::ByConstRef1{TGeoOpticalSurface}, i::Int32)::ByCopy{String}


""" GetPropertyRef(this::ByConstRef1{TGeoOpticalSurface}, i::Int32)

# Wrapper of Double_t TGeoOpticalSurface::GetSigmaAlpha()
@trydoc raw"""
    GetSigmaAlpha(this::ByConstRef1{TGeoOpticalSurface})::Float64


""" GetSigmaAlpha(this::ByConstRef1{TGeoOpticalSurface})

# Wrapper of Double_t TGeoOpticalSurface::GetValue()
@trydoc raw"""
    GetValue(this::ByConstRef1{TGeoOpticalSurface})::Float64


""" GetValue(this::ByConstRef1{TGeoOpticalSurface})

# Wrapper of void TGeoOpticalSurface::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoOpticalSurface}, option::ByCopy{String})::Nothing
Print [TNamed](@ref) name and title.

""" Print(this::ByConstRef1{TGeoOpticalSurface}, option::ByCopy{String})

# Wrapper of void TGeoOpticalSurface::SetPolish(Double_t)
@trydoc raw"""
    SetPolish(this::ByRef1{TGeoOpticalSurface}, polish::Float64)::Nothing


""" SetPolish(this::ByRef1{TGeoOpticalSurface}, polish::Float64)

# Wrapper of void TGeoOpticalSurface::SetSigmaAlpha(Double_t)
@trydoc raw"""
    SetSigmaAlpha(this::ByRef1{TGeoOpticalSurface}, sigmaalpha::Float64)::Nothing


""" SetSigmaAlpha(this::ByRef1{TGeoOpticalSurface}, sigmaalpha::Float64)

# Wrapper of void TGeoOpticalSurface::SetValue(Double_t)
@trydoc raw"""
    SetValue(this::ByRef1{TGeoOpticalSurface}, value::Float64)::Nothing


""" SetValue(this::ByRef1{TGeoOpticalSurface}, value::Float64)

# Wrapper of void TGeoSkinSurface::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoSkinSurface}, option::ByCopy{String})::Nothing
Print [TNamed](@ref) name and title.

""" Print(this::ByConstRef1{TGeoSkinSurface}, option::ByCopy{String})

# Wrapper of void TGeoBorderSurface::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoBorderSurface}, option::ByCopy{String})::Nothing
Print [TNamed](@ref) name and title.

""" Print(this::ByConstRef1{TGeoBorderSurface}, option::ByCopy{String})

# Wrapper of Double_t TGeoPara::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoPara})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoPara})

# Wrapper of void TGeoPara::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoPara})::Nothing
compute bounding box

""" ComputeBBox(this::ByRef1{TGeoPara})

# Wrapper of void TGeoPara::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoPara::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoPara::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64})::Bool
test if point is inside this sphere test Z range

""" Contains(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoPara::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Double_t TGeoPara::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the para Boundary safe algorithm.

""" DistFromInside(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoPara::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoPara::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the para

""" DistFromOutside(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoPara::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoPara::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoPara}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this parallelepiped shape belonging to volume "voldiv" into ndiv equal volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume. In case a wrong division axis is supplied, returns pointer to volume to be divided.
""" Divide(this::ByRef1{TGeoPara}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoPara::GetAlpha()
@trydoc raw"""
    GetAlpha(this::ByConstRef1{TGeoPara})::Float64


""" GetAlpha(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoPara}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoPara}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoPara::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoPara}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoPara}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoPara::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoPara})::Int32


""" GetByteCount(this::ByConstRef1{TGeoPara})

# Wrapper of Int_t TGeoPara::GetFittingBox(const TGeoBBox *, TGeoMatrix *, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetFittingBox(this::ByConstRef1{TGeoPara}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})::Int32
Fills real parameters of a positioned box inside this. Returns 0 if successful.

""" GetFittingBox(this::ByConstRef1{TGeoPara}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})

# Wrapper of TGeoShape * TGeoPara::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoPara}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoPara}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of Int_t TGeoPara::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoPara})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetPhi()
@trydoc raw"""
    GetPhi(this::ByConstRef1{TGeoPara})::Float64


""" GetPhi(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetTheta()
@trydoc raw"""
    GetTheta(this::ByConstRef1{TGeoPara})::Float64


""" GetTheta(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetTxy()
@trydoc raw"""
    GetTxy(this::ByConstRef1{TGeoPara})::Float64


""" GetTxy(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetTxz()
@trydoc raw"""
    GetTxz(this::ByConstRef1{TGeoPara})::Float64


""" GetTxz(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetTyz()
@trydoc raw"""
    GetTyz(this::ByConstRef1{TGeoPara})::Float64


""" GetTyz(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetX()
@trydoc raw"""
    GetX(this::ByConstRef1{TGeoPara})::Float64


""" GetX(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetY()
@trydoc raw"""
    GetY(this::ByConstRef1{TGeoPara})::Float64


""" GetY(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::GetZ()
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoPara})::Float64


""" GetZ(this::ByConstRef1{TGeoPara})

# Wrapper of void TGeoPara::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoPara})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoPara})

# Wrapper of Bool_t TGeoPara::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoPara})::Bool


""" IsCylType(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoPara::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoPara}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoPara::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoPara}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoPara::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoPara}, param::ByPtr2{Float64})::Nothing
Set dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoPara}, param::ByPtr2{Float64})

# Wrapper of void TGeoPara::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoPara}, points::ByPtr2{Float64})::Nothing
Create PARA mesh points.

""" SetPoints(this::ByConstRef1{TGeoPara}, points::ByPtr2{Float64})

# Wrapper of void TGeoPara::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoPara}, points::ByPtr2{Float32})::Nothing
create sphere mesh points

""" SetPoints(this::ByConstRef1{TGeoPara}, points::ByPtr2{Float32})

# Wrapper of void TGeoPara::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoPara})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoPara})

# Wrapper of Double_t TGeoParaboloid::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoParaboloid})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoParaboloid})

# Wrapper of void TGeoParaboloid::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoParaboloid})::Nothing
compute bounding box of the tube

""" ComputeBBox(this::ByRef1{TGeoParaboloid})

# Wrapper of void TGeoParaboloid::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoParaboloid::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64})::Bool
test if point is inside the elliptical tube

""" Contains(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoParaboloid::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoParaboloid::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoParaboloid}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex

""" DistancetoPrimitive(this::ByRef1{TGeoParaboloid}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoParaboloid::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the paraboloid

""" DistFromInside(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoParaboloid::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the paraboloid and safe distance

""" DistFromOutside(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoParaboloid::DistToParaboloid(const Double_t *, const Double_t *, Bool_t)
@trydoc raw"""
    DistToParaboloid(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, in::Bool)::Float64
Compute distance from a point to the parabola given by: `z = a*rsq + b; rsq = x*x+y*y`

""" DistToParaboloid(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, in::Bool)

# Wrapper of TGeoVolume * TGeoParaboloid::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoParaboloid}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide the paraboloid along one axis.

""" Divide(this::ByRef1{TGeoParaboloid}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoParaboloid::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoParaboloid}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoParaboloid}, param::ByPtr2{Float64})

# Wrapper of Double_t TGeoParaboloid::GetDz()
@trydoc raw"""
    GetDz(this::ByConstRef1{TGeoParaboloid})::Float64


""" GetDz(this::ByConstRef1{TGeoParaboloid})

# Wrapper of TGeoShape * TGeoParaboloid::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoParaboloid}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoParaboloid}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoParaboloid::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoParaboloid}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoParaboloid}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoParaboloid::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoParaboloid})::Int32
Returns number of vertices on the paraboloid mesh.

""" GetNmeshVertices(this::ByConstRef1{TGeoParaboloid})

# Wrapper of Bool_t TGeoParaboloid::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoParaboloid}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoParaboloid}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoParaboloid::GetRhi()
@trydoc raw"""
    GetRhi(this::ByConstRef1{TGeoParaboloid})::Float64


""" GetRhi(this::ByConstRef1{TGeoParaboloid})

# Wrapper of Double_t TGeoParaboloid::GetRlo()
@trydoc raw"""
    GetRlo(this::ByConstRef1{TGeoParaboloid})::Float64


""" GetRlo(this::ByConstRef1{TGeoParaboloid})

# Wrapper of void TGeoParaboloid::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoParaboloid})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoParaboloid})

# Wrapper of Bool_t TGeoParaboloid::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoParaboloid})::Bool


""" IsCylType(this::ByConstRef1{TGeoParaboloid})

# Wrapper of Double_t TGeoParaboloid::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, in::Bool)::Float64
Computes the closest distance from given point to this shape.

""" Safety(this::ByConstRef1{TGeoParaboloid}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoParaboloid::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoParaboloid}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoParaboloid::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoParaboloid}, param::ByPtr2{Float64})::Nothing
Set paraboloid dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoParaboloid}, param::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::SetParaboloidDimensions(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetParaboloidDimensions(this::ByRef1{TGeoParaboloid}, rlo::Float64, rhi::Float64, dz::Float64)::Nothing
Set paraboloid dimensions.

""" SetParaboloidDimensions(this::ByRef1{TGeoParaboloid}, rlo::Float64, rhi::Float64, dz::Float64)

# Wrapper of void TGeoParaboloid::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoParaboloid}, points::ByPtr2{Float64})::Nothing
Create paraboloid mesh points.
Npoints = n*(n+1) + 2
        ifirst = 0
        ipoint(i,j) = 1+i*n+j;                              i=[0,n]  j=[0,n-1]
        ilast = 1+n*(n+1)
    Nsegments = n*(2*n+3)
        lower: (0, j+1);                                    j=[0,n-1]
        circle(i): (n*i+1+j, n*i+1+(j+1)%n);                i=[0,n]  j=[0,n-1]
        generator(i): (n*i+1+j, n*(i+1)+1+j);               i,j=[0,n-1]
        upper: (n*n+1+j, (n+1)*n+1)                           j=[0,n-1]
    Npolygons = n*(n+2)
        lower: (n+j, (j+1)%n, j)                              j=[0,n-1]
        lateral(i): ((2*i+1)*n+j, 2*(i+1)*n+j, (2*i+3)*n+j, 2*(i+1)*n+(j+1)%n)
                                                           i,j = [0,n-1]
        upper: ((2n+1)*n+j, 2*n*(n+1)+(j+1)%n, 2*n*(n+1)+j)   j=[0,n-1]

(C++ version of the code)
""" SetPoints(this::ByConstRef1{TGeoParaboloid}, points::ByPtr2{Float64})

# Wrapper of void TGeoParaboloid::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoParaboloid}, points::ByPtr2{Float32})::Nothing
Create paraboloid mesh points.

""" SetPoints(this::ByConstRef1{TGeoParaboloid}, points::ByPtr2{Float32})

# Wrapper of void TGeoParaboloid::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoParaboloid})::Nothing


""" Sizeof3D(this::ByConstRef1{TGeoParaboloid})

# Wrapper of void TGeoParallelWorld::AddNode(const char *)
@trydoc raw"""
    AddNode(this::ByRef1{TGeoParallelWorld}, path::ByCopy{String})::Nothing
Add a node normally to this world. Overlapping nodes not allowed.

""" AddNode(this::ByRef1{TGeoParallelWorld}, path::ByCopy{String})

# Wrapper of void TGeoParallelWorld::AddOverlap(const char *, Bool_t)
@trydoc raw"""
    AddOverlap(this::ByRef1{TGeoParallelWorld}, volname::ByCopy{String}, activate::Bool)::Nothing
To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world.
Better be done before misalignment
""" AddOverlap(this::ByRef1{TGeoParallelWorld}, volname::ByCopy{String}, activate::Bool)

# Wrapper of void TGeoParallelWorld::AddOverlap(TGeoVolume *, Bool_t)
@trydoc raw"""
    AddOverlap(this::ByRef1{TGeoParallelWorld}, vol::ByPtr1{TGeoVolume}, activate::Bool)::Nothing
To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world.
Better be done before misalignment
""" AddOverlap(this::ByRef1{TGeoParallelWorld}, vol::ByPtr1{TGeoVolume}, activate::Bool)

# Wrapper of void TGeoParallelWorld::CheckOverlaps(Double_t)
@trydoc raw"""
    CheckOverlaps(this::ByRef1{TGeoParallelWorld}, ovlp::Float64)::Nothing
Check overlaps within a tolerance value.

""" CheckOverlaps(this::ByRef1{TGeoParallelWorld}, ovlp::Float64)

# Wrapper of Bool_t TGeoParallelWorld::CloseGeometry()
@trydoc raw"""
    CloseGeometry(this::ByRef1{TGeoParallelWorld})::Bool
The main geometry must be closed.

""" CloseGeometry(this::ByRef1{TGeoParallelWorld})

# Wrapper of void TGeoParallelWorld::Draw(Option_t *)
@trydoc raw"""
    Draw(this::ByRef1{TGeoParallelWorld}, option::ByCopy{String})::Nothing
Draw the parallel world.

""" Draw(this::ByRef1{TGeoParallelWorld}, option::ByCopy{String})

# Wrapper of TGeoManager * TGeoParallelWorld::GetGeometry()
@trydoc raw"""
    GetGeometry(this::ByConstRef1{TGeoParallelWorld})::CxxPtr1{TGeoManager}


""" GetGeometry(this::ByConstRef1{TGeoParallelWorld})

# Wrapper of TGeoVolume * TGeoParallelWorld::GetVolume()
@trydoc raw"""
    GetVolume(this::ByConstRef1{TGeoParallelWorld})::CxxPtr1{TGeoVolume}


""" GetVolume(this::ByConstRef1{TGeoParallelWorld})

# Wrapper of Bool_t TGeoParallelWorld::IsClosed()
@trydoc raw"""
    IsClosed(this::ByConstRef1{TGeoParallelWorld})::Bool


""" IsClosed(this::ByConstRef1{TGeoParallelWorld})

# Wrapper of Bool_t TGeoParallelWorld::IsUsingOverlaps()
@trydoc raw"""
    IsUsingOverlaps(this::ByConstRef1{TGeoParallelWorld})::Bool


""" IsUsingOverlaps(this::ByConstRef1{TGeoParallelWorld})

# Wrapper of Int_t TGeoParallelWorld::PrintDetectedOverlaps()
@trydoc raw"""
    PrintDetectedOverlaps(this::ByConstRef1{TGeoParallelWorld})::Int32
Print the overlaps which were detected during real tracking.

""" PrintDetectedOverlaps(this::ByConstRef1{TGeoParallelWorld})

# Wrapper of void TGeoParallelWorld::RefreshPhysicalNodes()
@trydoc raw"""
    RefreshPhysicalNodes(this::ByRef1{TGeoParallelWorld})::Nothing
Refresh the node pointers and re-voxelize.
To be called mandatory in case re-alignment happened.
""" RefreshPhysicalNodes(this::ByRef1{TGeoParallelWorld})

# Wrapper of void TGeoParallelWorld::ResetOverlaps()
@trydoc raw"""
    ResetOverlaps(this::ByConstRef1{TGeoParallelWorld})::Nothing
Reset overlapflag for all volumes in geometry.

""" ResetOverlaps(this::ByConstRef1{TGeoParallelWorld})

# Wrapper of void TGeoParallelWorld::SetUseOverlaps(Bool_t)
@trydoc raw"""
    SetUseOverlaps(this::ByRef1{TGeoParallelWorld}, flag::Bool)::Nothing


""" SetUseOverlaps(this::ByRef1{TGeoParallelWorld}, flag::Bool)

# Wrapper of Double_t TGeoPcon::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoPcon})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoPcon})

# Wrapper of void TGeoPcon::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoPcon})::Nothing
compute bounding box of the pcon Check if the sections are in increasing Z order

""" ComputeBBox(this::ByRef1{TGeoPcon})

# Wrapper of void TGeoPcon::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoPcon::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoPcon::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64})::Bool
test if point is inside this shape check total z range

""" Contains(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoPcon::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of void TGeoPcon::DefineSection(Int_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DefineSection(this::ByRef1{TGeoPcon}, snum::Int32, z::Float64, rmin::Float64, rmax::Float64)::Nothing
Defines z position of a section plane, rmin and rmax at this z.
Sections should be defined in increasing or decreasing Z order and the last section HAS to be snum = fNz-1
""" DefineSection(this::ByRef1{TGeoPcon}, snum::Int32, z::Float64, rmin::Float64, rmax::Float64)

# Wrapper of Int_t TGeoPcon::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoPcon}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoPcon}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoPcon::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the polycone

""" DistFromInside(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoPcon::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoPcon::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the tube

""" DistFromOutside(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoPcon::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoPcon::DistToSegZ(const Double_t *, const Double_t *, Int_t &)
@trydoc raw"""
    DistToSegZ(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iz::ByRef2{Int32})::Float64
compute distance to a pcon Z slice. Segment iz must be valid

""" DistToSegZ(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iz::ByRef2{Int32})

# Wrapper of TGeoVolume * TGeoPcon::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoPcon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this polycone shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. Z divisions can be performed if the divided range is in between two consecutive Z planes. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoPcon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t & TGeoPcon::Dphi()
@trydoc raw"""
    Dphi(this::ByRef1{TGeoPcon})::CxxRef2{Float64}


""" Dphi(this::ByRef1{TGeoPcon})

# Wrapper of const char * TGeoPcon::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoPcon}, iaxis::Int32)::ByCopy{String}
Returns name of axis IAXIS.

""" GetAxisName(this::ByConstRef1{TGeoPcon}, iaxis::Int32)

# Wrapper of Double_t TGeoPcon::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoPcon}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoPcon}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoPcon::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoPcon}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoPcon}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoPcon::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoPcon})::Int32


""" GetByteCount(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t TGeoPcon::GetDphi()
@trydoc raw"""
    GetDphi(this::ByConstRef1{TGeoPcon})::Float64


""" GetDphi(this::ByConstRef1{TGeoPcon})

# Wrapper of TGeoShape * TGeoPcon::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoPcon}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoPcon}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoPcon::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoPcon}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoPcon}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoPcon::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoPcon})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoPcon})

# Wrapper of Int_t TGeoPcon::GetNsegments()
@trydoc raw"""
    GetNsegments(this::ByConstRef1{TGeoPcon})::Int32
Returns number of segments on each mesh circle segment.

""" GetNsegments(this::ByConstRef1{TGeoPcon})

# Wrapper of Int_t TGeoPcon::GetNz()
@trydoc raw"""
    GetNz(this::ByConstRef1{TGeoPcon})::Int32


""" GetNz(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t TGeoPcon::GetPhi1()
@trydoc raw"""
    GetPhi1(this::ByConstRef1{TGeoPcon})::Float64


""" GetPhi1(this::ByConstRef1{TGeoPcon})

# Wrapper of Bool_t TGeoPcon::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoPcon}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoPcon}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t * TGeoPcon::GetRmax()
@trydoc raw"""
    GetRmax(this::ByConstRef1{TGeoPcon})::CxxPtr2{Float64}


""" GetRmax(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t TGeoPcon::GetRmax(Int_t)
@trydoc raw"""
    GetRmax(this::ByConstRef1{TGeoPcon}, ipl::Int32)::Float64
Returns Rmax for Z segment IPL.

""" GetRmax(this::ByConstRef1{TGeoPcon}, ipl::Int32)

# Wrapper of Double_t * TGeoPcon::GetRmin()
@trydoc raw"""
    GetRmin(this::ByConstRef1{TGeoPcon})::CxxPtr2{Float64}


""" GetRmin(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t TGeoPcon::GetRmin(Int_t)
@trydoc raw"""
    GetRmin(this::ByConstRef1{TGeoPcon}, ipl::Int32)::Float64
Returns Rmin for Z segment IPL.

""" GetRmin(this::ByConstRef1{TGeoPcon}, ipl::Int32)

# Wrapper of Double_t * TGeoPcon::GetZ()
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoPcon})::CxxPtr2{Float64}


""" GetZ(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t TGeoPcon::GetZ(Int_t)
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoPcon}, ipl::Int32)::Float64
Returns Z for segment IPL.

""" GetZ(this::ByConstRef1{TGeoPcon}, ipl::Int32)

# Wrapper of void TGeoPcon::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoPcon})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoPcon})

# Wrapper of Bool_t TGeoPcon::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoPcon})::Bool


""" IsCylType(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t & TGeoPcon::Phi1()
@trydoc raw"""
    Phi1(this::ByRef1{TGeoPcon})::CxxRef2{Float64}


""" Phi1(this::ByRef1{TGeoPcon})

# Wrapper of Double_t & TGeoPcon::Rmax(Int_t)
@trydoc raw"""
    Rmax(this::ByRef1{TGeoPcon}, ipl::Int32)::CxxRef2{Float64}


""" Rmax(this::ByRef1{TGeoPcon}, ipl::Int32)

# Wrapper of Double_t & TGeoPcon::Rmin(Int_t)
@trydoc raw"""
    Rmin(this::ByRef1{TGeoPcon}, ipl::Int32)::CxxRef2{Float64}


""" Rmin(this::ByRef1{TGeoPcon}, ipl::Int32)

# Wrapper of Double_t TGeoPcon::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint. localize the Z segment
""" Safety(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoPcon::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoPcon}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Double_t TGeoPcon::SafetyToSegment(const Double_t *, Int_t, Bool_t, Double_t)
@trydoc raw"""
    SafetyToSegment(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, ipl::Int32, in::Bool, safmin::Float64)::Float64
Compute safety from POINT to segment between planes ipl, ipl+1 within safmin.

""" SafetyToSegment(this::ByConstRef1{TGeoPcon}, point::ByConstPtr2{Float64}, ipl::Int32, in::Bool, safmin::Float64)

# Wrapper of void TGeoPcon::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoPcon}, param::ByPtr2{Float64})::Nothing
Set polycone dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoPcon}, param::ByPtr2{Float64})

# Wrapper of void TGeoPcon::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoPcon}, points::ByPtr2{Float64})::Nothing
create polycone mesh points

""" SetPoints(this::ByConstRef1{TGeoPcon}, points::ByPtr2{Float64})

# Wrapper of void TGeoPcon::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoPcon}, points::ByPtr2{Float32})::Nothing
create polycone mesh points

""" SetPoints(this::ByConstRef1{TGeoPcon}, points::ByPtr2{Float32})

# Wrapper of void TGeoPcon::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoPcon})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoPcon})

# Wrapper of Double_t & TGeoPcon::Z(Int_t)
@trydoc raw"""
    Z(this::ByRef1{TGeoPcon}, ipl::Int32)::CxxRef2{Float64}


""" Z(this::ByRef1{TGeoPcon}, ipl::Int32)

# Wrapper of Double_t TGeoPgon::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoPgon})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoPgon})

# Wrapper of void TGeoPgon::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoPgon})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoPgon})

# Wrapper of void TGeoPgon::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoPgon})::Nothing
compute bounding box for a polygone Check if the sections are in increasing Z order

""" ComputeBBox(this::ByRef1{TGeoPgon})

# Wrapper of void TGeoPgon::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoPgon::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoPgon::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64})::Bool
test if point is inside this shape check total z range

""" Contains(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoPgon::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of void TGeoPgon::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoPgon}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoPgon}, nthreads::Int32)

# Wrapper of Int_t TGeoPgon::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoPgon}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoPgon}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoPgon::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the polygone first find out in which Z section the point is in

""" DistFromInside(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoPgon::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoPgon::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the polygone.

""" DistFromOutside(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoPgon::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoPgon::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoPgon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this polygone shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Z divisions. Phi divisions are allowed only if nedgesndiv=0 and create polygone "segments" with nedges/ndiv edges. Z divisions can be performed if the divided range is in between two consecutive Z planes. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoPgon}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of void TGeoPgon::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoPgon}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoPgon}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoPgon::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoPgon})::Int32


""" GetByteCount(this::ByConstRef1{TGeoPgon})

# Wrapper of TGeoShape * TGeoPgon::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoPgon}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoPgon}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoPgon::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoPgon}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoPgon}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoPgon::GetNedges()
@trydoc raw"""
    GetNedges(this::ByConstRef1{TGeoPgon})::Int32


""" GetNedges(this::ByConstRef1{TGeoPgon})

# Wrapper of Int_t TGeoPgon::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoPgon})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoPgon})

# Wrapper of Int_t TGeoPgon::GetNsegments()
@trydoc raw"""
    GetNsegments(this::ByConstRef1{TGeoPgon})::Int32
Returns number of segments on each mesh circle segment.

""" GetNsegments(this::ByConstRef1{TGeoPgon})

# Wrapper of Bool_t TGeoPgon::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoPgon}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoPgon}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of void TGeoPgon::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoPgon})::Nothing
Inspect the PGON parameters.

""" InspectShape(this::ByConstRef1{TGeoPgon})

# Wrapper of Double_t TGeoPgon::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoPgon::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoPgon}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Double_t TGeoPgon::SafetyToSegment(const Double_t *, Int_t, Int_t, Bool_t, Double_t, Double_t)
@trydoc raw"""
    SafetyToSegment(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, ipl::Int32, iphi::Int32, in::Bool, safphi::Float64, safmin::Float64)::Float64
Compute safety from POINT to segment between planes ipl, ipl+1 within safmin.

""" SafetyToSegment(this::ByConstRef1{TGeoPgon}, point::ByConstPtr2{Float64}, ipl::Int32, iphi::Int32, in::Bool, safphi::Float64, safmin::Float64)

# Wrapper of void TGeoPgon::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoPgon}, param::ByPtr2{Float64})::Nothing
Set PGON dimensions starting from an array.

""" SetDimensions(this::ByRef1{TGeoPgon}, param::ByPtr2{Float64})

# Wrapper of void TGeoPgon::SetNedges(Int_t)
@trydoc raw"""
    SetNedges(this::ByRef1{TGeoPgon}, ne::Int32)::Nothing


""" SetNedges(this::ByRef1{TGeoPgon}, ne::Int32)

# Wrapper of void TGeoPgon::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoPgon}, points::ByPtr2{Float64})::Nothing
create polygone mesh points

""" SetPoints(this::ByConstRef1{TGeoPgon}, points::ByPtr2{Float64})

# Wrapper of void TGeoPgon::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoPgon}, points::ByPtr2{Float32})::Nothing
create polygone mesh points

""" SetPoints(this::ByConstRef1{TGeoPgon}, points::ByPtr2{Float32})

# Wrapper of void TGeoPgon::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoPgon})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoPgon})

# Wrapper of Double_t TGeoRegionCut::GetCut()
@trydoc raw"""
    GetCut(this::ByConstRef1{TGeoRegionCut})::Float64


""" GetCut(this::ByConstRef1{TGeoRegionCut})

# Wrapper of void TGeoRegionCut::SetCut(Double_t)
@trydoc raw"""
    SetCut(this::ByRef1{TGeoRegionCut}, cut::Float64)::Nothing


""" SetCut(this::ByRef1{TGeoRegionCut}, cut::Float64)

# Wrapper of Double_t TGeoScaledShape::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoScaledShape})::Float64
Computes capacity of this shape [length^3].

""" Capacity(this::ByConstRef1{TGeoScaledShape})

# Wrapper of void TGeoScaledShape::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoScaledShape})::Nothing
Compute bounding box of the scaled shape.

""" ComputeBBox(this::ByRef1{TGeoScaledShape})

# Wrapper of void TGeoScaledShape::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoScaledShape::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoScaledShape::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64})::Bool
Test if point is inside the scaled shape.

""" Contains(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoScaledShape::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoScaledShape::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoScaledShape}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex. Should not be called.

""" DistancetoPrimitive(this::ByRef1{TGeoScaledShape}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoScaledShape::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the scaled shape.

""" DistFromInside(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoScaledShape::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoScaledShape::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the scaled shape.

""" DistFromOutside(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoScaledShape::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoScaledShape::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoScaledShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Cannot divide assemblies.

""" Divide(this::ByRef1{TGeoScaledShape}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of TGeoShape * TGeoScaledShape::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoScaledShape}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoScaledShape}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoScaledShape::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoScaledShape}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoScaledShape}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoScaledShape::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoScaledShape})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoScaledShape})

# Wrapper of TGeoScale * TGeoScaledShape::GetScale()
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoScaledShape})::CxxPtr1{TGeoScale}


""" GetScale(this::ByConstRef1{TGeoScaledShape})

# Wrapper of TGeoShape * TGeoScaledShape::GetShape()
@trydoc raw"""
    GetShape(this::ByConstRef1{TGeoScaledShape})::CxxPtr1{TGeoShape}


""" GetShape(this::ByConstRef1{TGeoScaledShape})

# Wrapper of void TGeoScaledShape::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoScaledShape})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoScaledShape})

# Wrapper of Bool_t TGeoScaledShape::IsAssembly()
@trydoc raw"""
    IsAssembly(this::ByConstRef1{TGeoScaledShape})::Bool
Returns true if the scaled shape is an assembly.

""" IsAssembly(this::ByConstRef1{TGeoScaledShape})

# Wrapper of Bool_t TGeoScaledShape::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoScaledShape})::Bool


""" IsCylType(this::ByConstRef1{TGeoScaledShape})

# Wrapper of Bool_t TGeoScaledShape::IsReflected()
@trydoc raw"""
    IsReflected(this::ByConstRef1{TGeoScaledShape})::Bool
Check if the scale transformation is a reflection.

""" IsReflected(this::ByConstRef1{TGeoScaledShape})

# Wrapper of Double_t TGeoScaledShape::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoScaledShape}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoScaledShape::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoScaledShape}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoScaledShape::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoScaledShape}, points::ByPtr2{Float64})::Nothing
Mesh points for scaled shapes.

""" SetPoints(this::ByConstRef1{TGeoScaledShape}, points::ByPtr2{Float64})

# Wrapper of void TGeoScaledShape::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoScaledShape}, points::ByPtr2{Float32})::Nothing
Mesh points for scaled shapes.

""" SetPoints(this::ByConstRef1{TGeoScaledShape}, points::ByPtr2{Float32})

# Wrapper of void TGeoScaledShape::SetScale(TGeoScale *)
@trydoc raw"""
    SetScale(this::ByRef1{TGeoScaledShape}, scale::ByPtr1{TGeoScale})::Nothing


""" SetScale(this::ByRef1{TGeoScaledShape}, scale::ByPtr1{TGeoScale})

# Wrapper of TGeoShape * TGeoScaledShape::MakeScaledShape(const char *, TGeoShape *, TGeoScale *)
@trydoc raw"""
    TGeoScaledShape!MakeScaledShape(this::ByRef1{TGeoScaledShape}, name::ByCopy{String}, shape::ByPtr1{TGeoShape}, scale::ByPtr1{TGeoScale})::CxxPtr1{TGeoShape}
Create a scaled shape starting from a non-scaled one.

""" TGeoScaledShape!MakeScaledShape(this::ByRef1{TGeoScaledShape}, name::ByCopy{String}, shape::ByPtr1{TGeoShape}, scale::ByPtr1{TGeoScale})

# Wrapper of void TGeoShapeAssembly::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoShapeAssembly})::Nothing
Compute bounding box of the assembly.

""" ComputeBBox(this::ByRef1{TGeoShapeAssembly})

# Wrapper of void TGeoShapeAssembly::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT. Should not be called.

""" ComputeNormal(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoShapeAssembly::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoShapeAssembly::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64})::Bool
Test if point is inside the assembly.

""" Contains(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoShapeAssembly::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoShapeAssembly::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoShapeAssembly}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each vertex. Should not be called.

""" DistancetoPrimitive(this::ByRef1{TGeoShapeAssembly}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoShapeAssembly::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the hyperboloid.

""" DistFromInside(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoShapeAssembly::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoShapeAssembly::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the hyperboloid.
fVolume->SetNextNodeIndex(-1);
""" DistFromOutside(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoShapeAssembly::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoShapeAssembly::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoShapeAssembly}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Cannot divide assemblies.

""" Divide(this::ByRef1{TGeoShapeAssembly}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of TGeoShape * TGeoShapeAssembly::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoShapeAssembly}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoShapeAssembly}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoShapeAssembly::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoShapeAssembly}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoShapeAssembly}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoShapeAssembly::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoShapeAssembly})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoShapeAssembly})

# Wrapper of void TGeoShapeAssembly::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoShapeAssembly})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoShapeAssembly})

# Wrapper of Bool_t TGeoShapeAssembly::IsAssembly()
@trydoc raw"""
    IsAssembly(this::ByConstRef1{TGeoShapeAssembly})::Bool


""" IsAssembly(this::ByConstRef1{TGeoShapeAssembly})

# Wrapper of Bool_t TGeoShapeAssembly::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoShapeAssembly})::Bool


""" IsCylType(this::ByConstRef1{TGeoShapeAssembly})

# Wrapper of void TGeoShapeAssembly::NeedsBBoxRecompute()
@trydoc raw"""
    NeedsBBoxRecompute(this::ByRef1{TGeoShapeAssembly})::Nothing


""" NeedsBBoxRecompute(this::ByRef1{TGeoShapeAssembly})

# Wrapper of void TGeoShapeAssembly::RecomputeBoxLast()
@trydoc raw"""
    RecomputeBoxLast(this::ByRef1{TGeoShapeAssembly})::Nothing
Recompute bounding box of the assembly after adding a node.

""" RecomputeBoxLast(this::ByRef1{TGeoShapeAssembly})

# Wrapper of Double_t TGeoShapeAssembly::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoShapeAssembly}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoShapeAssembly::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoShapeAssembly}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoShapeAssembly::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoShapeAssembly}, points::ByPtr2{Float64})::Nothing
No mesh for assemblies.

""" SetPoints(this::ByConstRef1{TGeoShapeAssembly}, points::ByPtr2{Float64})

# Wrapper of void TGeoShapeAssembly::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoShapeAssembly}, points::ByPtr2{Float32})::Nothing
No mesh for assemblies.

""" SetPoints(this::ByConstRef1{TGeoShapeAssembly}, points::ByPtr2{Float32})

# Wrapper of Double_t TGeoSphere::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoSphere})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoSphere})

# Wrapper of void TGeoSphere::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoSphere})::Nothing
compute bounding box of the sphere

""" ComputeBBox(this::ByRef1{TGeoSphere})

# Wrapper of void TGeoSphere::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoSphere::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoSphere::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64})::Bool
test if point is inside this sphere check Rmin<=R<=Rmax

""" Contains(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoSphere::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Int_t TGeoSphere::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoSphere}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoSphere}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoSphere::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the sphere

""" DistFromInside(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoSphere::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoSphere::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the sphere Check if the bounding box is crossed within the requested distance

""" DistFromOutside(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoSphere::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoSphere::DistToSphere(const Double_t *, const Double_t *, Double_t, Bool_t, Bool_t)
@trydoc raw"""
    DistToSphere(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rsph::Float64, check::Bool, firstcross::Bool)::Float64
compute distance to sphere of radius rsph. Direction has to be a unit vector

""" DistToSphere(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, rsph::Float64, check::Bool, firstcross::Bool)

# Wrapper of TGeoVolume * TGeoSphere::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoSphere}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this box shape belonging to volume "voldiv" into ndiv equal volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume. In case a wrong division axis is supplied, returns pointer to volume to be divided.
""" Divide(this::ByRef1{TGeoSphere}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of const char * TGeoSphere::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoSphere}, iaxis::Int32)::ByCopy{String}
Returns name of axis IAXIS.

""" GetAxisName(this::ByConstRef1{TGeoSphere}, iaxis::Int32)

# Wrapper of Double_t TGeoSphere::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoSphere}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoSphere}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoSphere::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoSphere}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoSphere}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoSphere::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoSphere})::Int32


""" GetByteCount(this::ByConstRef1{TGeoSphere})

# Wrapper of TGeoShape * TGeoSphere::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoSphere}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoSphere}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoSphere::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoSphere}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoSphere}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoSphere::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoSphere})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoSphere})

# Wrapper of Int_t TGeoSphere::GetNumberOfDivisions()
@trydoc raw"""
    GetNumberOfDivisions(this::ByConstRef1{TGeoSphere})::Int32


""" GetNumberOfDivisions(this::ByConstRef1{TGeoSphere})

# Wrapper of Int_t TGeoSphere::GetNz()
@trydoc raw"""
    GetNz(this::ByConstRef1{TGeoSphere})::Int32


""" GetNz(this::ByConstRef1{TGeoSphere})

# Wrapper of Double_t TGeoSphere::GetPhi1()
@trydoc raw"""
    GetPhi1(this::ByConstRef1{TGeoSphere})::Float64


""" GetPhi1(this::ByConstRef1{TGeoSphere})

# Wrapper of Double_t TGeoSphere::GetPhi2()
@trydoc raw"""
    GetPhi2(this::ByConstRef1{TGeoSphere})::Float64


""" GetPhi2(this::ByConstRef1{TGeoSphere})

# Wrapper of Bool_t TGeoSphere::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoSphere}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoSphere}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoSphere::GetRmax()
@trydoc raw"""
    GetRmax(this::ByConstRef1{TGeoSphere})::Float64


""" GetRmax(this::ByConstRef1{TGeoSphere})

# Wrapper of Double_t TGeoSphere::GetRmin()
@trydoc raw"""
    GetRmin(this::ByConstRef1{TGeoSphere})::Float64


""" GetRmin(this::ByConstRef1{TGeoSphere})

# Wrapper of Double_t TGeoSphere::GetTheta1()
@trydoc raw"""
    GetTheta1(this::ByConstRef1{TGeoSphere})::Float64


""" GetTheta1(this::ByConstRef1{TGeoSphere})

# Wrapper of Double_t TGeoSphere::GetTheta2()
@trydoc raw"""
    GetTheta2(this::ByConstRef1{TGeoSphere})::Float64


""" GetTheta2(this::ByConstRef1{TGeoSphere})

# Wrapper of void TGeoSphere::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoSphere})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoSphere})

# Wrapper of Bool_t TGeoSphere::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoSphere})::Bool


""" IsCylType(this::ByConstRef1{TGeoSphere})

# Wrapper of Int_t TGeoSphere::IsOnBoundary(const Double_t *)
@trydoc raw"""
    IsOnBoundary(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64})::Int32
Check if a point in local_ sphere coordinates is close to a boundary within shape tolerance.
Return values:

- 0 - not close to boundary
- 1 - close to Rmin boundary
- 2 - close to Rmax boundary
- 3,4 - close to phi1/phi2 boundary
- 5,6 - close to theta1/theta2 boundary
""" IsOnBoundary(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64})

# Wrapper of Bool_t TGeoSphere::IsPointInside(const Double_t *, Bool_t, Bool_t, Bool_t)
@trydoc raw"""
    IsPointInside(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, checkR::Bool, checkTh::Bool, checkPh::Bool)::Bool
Check if a point is inside radius/theta/phi ranges for the spherical sector.

""" IsPointInside(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, checkR::Bool, checkTh::Bool, checkPh::Bool)

# Wrapper of Double_t TGeoSphere::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoSphere}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoSphere::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoSphere}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoSphere::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64})::Nothing
Set dimensions of the spherical segment starting from a list of parameters.
Only takes rmin and rmax
""" SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64})

# Wrapper of void TGeoSphere::SetDimensions(Double_t *, Int_t)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64}, nparam::Int32)::Nothing
Set dimensions of the spherical segment starting from a list of parameters.

""" SetDimensions(this::ByRef1{TGeoSphere}, param::ByPtr2{Float64}, nparam::Int32)

# Wrapper of void TGeoSphere::SetNumberOfDivisions(Int_t)
@trydoc raw"""
    SetNumberOfDivisions(this::ByRef1{TGeoSphere}, p::Int32)::Nothing
Set the number of divisions of mesh circles keeping aspect ratio.

""" SetNumberOfDivisions(this::ByRef1{TGeoSphere}, p::Int32)

# Wrapper of void TGeoSphere::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoSphere}, points::ByPtr2{Float64})::Nothing
create sphere mesh points

""" SetPoints(this::ByConstRef1{TGeoSphere}, points::ByPtr2{Float64})

# Wrapper of void TGeoSphere::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoSphere}, points::ByPtr2{Float32})::Nothing
create sphere mesh points

""" SetPoints(this::ByConstRef1{TGeoSphere}, points::ByPtr2{Float32})

# Wrapper of void TGeoSphere::SetSphDimensions(Double_t, Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetSphDimensions(this::ByRef1{TGeoSphere}, rmin::Float64, rmax::Float64, theta1::Float64, theta2::Float64, phi1::Float64, phi2::Float64)::Nothing
Set spherical segment dimensions.

""" SetSphDimensions(this::ByRef1{TGeoSphere}, rmin::Float64, rmax::Float64, theta1::Float64, theta2::Float64, phi1::Float64, phi2::Float64)

# Wrapper of void TGeoSphere::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoSphere})::Nothing


""" Sizeof3D(this::ByConstRef1{TGeoSphere})

# Wrapper of void TGeoFacet::Flip()
@trydoc raw"""
    Flip(this::ByRef1{TGeoFacet})::Nothing


""" Flip(this::ByRef1{TGeoFacet})

# Wrapper of int TGeoFacet::GetNvert()
@trydoc raw"""
    GetNvert(this::ByConstRef1{TGeoFacet})::Int32


""" GetNvert(this::ByConstRef1{TGeoFacet})

# Wrapper of bool TGeoFacet::IsNeighbour(const TGeoFacet &, bool &)
@trydoc raw"""
    IsNeighbour(this::ByConstRef1{TGeoFacet}, other::ByConstRef1{TGeoFacet}, flip::ByRef2{Bool})::Bool
Check if a connected neighbour facet has compatible normal.

""" IsNeighbour(this::ByConstRef1{TGeoFacet}, other::ByConstRef1{TGeoFacet}, flip::ByRef2{Bool})

# Wrapper of int TGeoFacet::operator[](int)
@trydoc raw"""
    Base.getindex(this::ByConstRef1{TGeoFacet}, ivert::Int32)::Int32


""" Base.getindex(this::ByConstRef1{TGeoFacet}, ivert::Int32)

# Wrapper of bool TGeoTessellated::AddFacet(int, int, int)
@trydoc raw"""
    AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32)::Bool
Adding a triangular facet from indices of vertices.

""" AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32)

# Wrapper of bool TGeoTessellated::AddFacet(int, int, int, int)
@trydoc raw"""
    AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32, i4::Int32)::Bool
Adding a quadrilateral facet from indices of vertices.

""" AddFacet(this::ByRef1{TGeoTessellated}, i1::Int32, i2::Int32, i3::Int32, i4::Int32)

# Wrapper of bool TGeoTessellated::CheckClosure(bool, bool)
@trydoc raw"""
    CheckClosure(this::ByRef1{TGeoTessellated}, fixFlipped::Bool, verbose::Bool)::Bool
Check closure of the solid and check/fix flipped normals.

""" CheckClosure(this::ByRef1{TGeoTessellated}, fixFlipped::Bool, verbose::Bool)

# Wrapper of void TGeoTessellated::CloseShape(bool, bool, bool)
@trydoc raw"""
    CloseShape(this::ByRef1{TGeoTessellated}, check::Bool, fixFlipped::Bool, verbose::Bool)::Nothing
Close the shape: calculate bounding box and compact vertices.

""" CloseShape(this::ByRef1{TGeoTessellated}, check::Bool, fixFlipped::Bool, verbose::Bool)

# Wrapper of void TGeoTessellated::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTessellated})::Nothing
Compute bounding box.

""" ComputeBBox(this::ByRef1{TGeoTessellated})

# Wrapper of int TGeoTessellated::DistancetoPrimitive(int, int)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTessellated}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each corner.

""" DistancetoPrimitive(this::ByRef1{TGeoTessellated}, px::Int32, py::Int32)

# Wrapper of bool TGeoTessellated::FacetCheck(int)
@trydoc raw"""
    FacetCheck(this::ByConstRef1{TGeoTessellated}, ifacet::Int32)::Bool
Check validity of facet.

""" FacetCheck(this::ByConstRef1{TGeoTessellated}, ifacet::Int32)

# Wrapper of void TGeoTessellated::FlipFacets()
@trydoc raw"""
    FlipFacets(this::ByRef1{TGeoTessellated})::Nothing
Flip all facets.

""" FlipFacets(this::ByRef1{TGeoTessellated})

# Wrapper of const TGeoFacet & TGeoTessellated::GetFacet(int)
@trydoc raw"""
    GetFacet(this::ByConstRef1{TGeoTessellated}, i::Int32)::ConstCxxRef1{TGeoFacet}


""" GetFacet(this::ByConstRef1{TGeoTessellated}, i::Int32)

# Wrapper of void TGeoTessellated::GetMeshNumbers(int &, int &, int &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoTessellated}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoTessellated}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of int TGeoTessellated::GetNfacets()
@trydoc raw"""
    GetNfacets(this::ByConstRef1{TGeoTessellated})::Int32


""" GetNfacets(this::ByConstRef1{TGeoTessellated})

# Wrapper of int TGeoTessellated::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoTessellated})::Int32


""" GetNmeshVertices(this::ByConstRef1{TGeoTessellated})

# Wrapper of int TGeoTessellated::GetNsegments()
@trydoc raw"""
    GetNsegments(this::ByConstRef1{TGeoTessellated})::Int32


""" GetNsegments(this::ByConstRef1{TGeoTessellated})

# Wrapper of int TGeoTessellated::GetNvertices()
@trydoc raw"""
    GetNvertices(this::ByConstRef1{TGeoTessellated})::Int32


""" GetNvertices(this::ByConstRef1{TGeoTessellated})

# Wrapper of void TGeoTessellated::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoTessellated})::Nothing
Prints shape parameters.

""" InspectShape(this::ByConstRef1{TGeoTessellated})

# Wrapper of bool TGeoTessellated::IsClosedBody()
@trydoc raw"""
    IsClosedBody(this::ByConstRef1{TGeoTessellated})::Bool


""" IsClosedBody(this::ByConstRef1{TGeoTessellated})

# Wrapper of bool TGeoTessellated::IsDefined()
@trydoc raw"""
    IsDefined(this::ByConstRef1{TGeoTessellated})::Bool


""" IsDefined(this::ByConstRef1{TGeoTessellated})

# Wrapper of void TGeoTessellated::Print(Option_t *)
@trydoc raw"""
    Print(this::ByConstRef1{TGeoTessellated}, option::ByCopy{String})::Nothing
Prints basic info.

""" Print(this::ByConstRef1{TGeoTessellated}, option::ByCopy{String})

# Wrapper of void TGeoTessellated::ResizeCenter(double)
@trydoc raw"""
    ResizeCenter(this::ByRef1{TGeoTessellated}, maxsize::Float64)::Nothing
Resize and center the shape in a box of size maxsize.
Resize the shape by scaling vertices within maxsize and center to origin.
""" ResizeCenter(this::ByRef1{TGeoTessellated}, maxsize::Float64)

# Wrapper of void TGeoTessellated::SetPoints(double *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTessellated}, points::ByPtr2{Float64})::Nothing
Fill tessellated points to an array.

""" SetPoints(this::ByConstRef1{TGeoTessellated}, points::ByPtr2{Float64})

# Wrapper of void TGeoTessellated::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTessellated}, points::ByPtr2{Float32})::Nothing
Fill tessellated points in float.

""" SetPoints(this::ByConstRef1{TGeoTessellated}, points::ByPtr2{Float32})

# Wrapper of void TGeoTessellated::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoTessellated})::Nothing


""" Sizeof3D(this::ByConstRef1{TGeoTessellated})

# Wrapper of TGeoTessellated * TGeoTessellated::ImportFromObjFormat(const char *, bool, bool)
@trydoc raw"""
    TGeoTessellated!ImportFromObjFormat(this::ByRef1{TGeoTessellated}, objfile::ByCopy{String}, check::Bool, verbose::Bool)::CxxPtr1{TGeoTessellated}
Reader from .obj format.
Reads a single tessellated solid from an .obj file.
""" TGeoTessellated!ImportFromObjFormat(this::ByRef1{TGeoTessellated}, objfile::ByCopy{String}, check::Bool, verbose::Bool)

# Wrapper of Double_t TGeoTorus::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoTorus})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoTorus})

# Wrapper of void TGeoTorus::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTorus})::Nothing
Compute bounding box of the torus.

""" ComputeBBox(this::ByRef1{TGeoTorus})

# Wrapper of void TGeoTorus::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTorus::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoTorus::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64})::Bool
Test if point is inside the torus.
check phi range
""" Contains(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoTorus::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Double_t TGeoTorus::Daxis(const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    Daxis(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, t::Float64)::Float64
Computes distance to axis of the torus from point pt + t*dir;.

""" Daxis(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, t::Float64)

# Wrapper of Double_t TGeoTorus::DDaxis(const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    DDaxis(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, t::Float64)::Float64
Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;.

""" DDaxis(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, t::Float64)

# Wrapper of Double_t TGeoTorus::DDDaxis(const Double_t *, const Double_t *, Double_t)
@trydoc raw"""
    DDDaxis(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, t::Float64)::Float64
Second derivative of distance to torus axis w.r.t t.

""" DDDaxis(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, t::Float64)

# Wrapper of Int_t TGeoTorus::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoTorus}, px::Int32, py::Int32)::Int32
Compute closest distance from point px,py to each vertex.

""" DistancetoPrimitive(this::ByRef1{TGeoTorus}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoTorus::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the torus.

""" DistFromInside(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTorus::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoTorus::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the torus.

""" DistFromOutside(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTorus::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoTorus::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTorus}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this torus shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.

""" Divide(this::ByRef1{TGeoTorus}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of const char * TGeoTorus::GetAxisName(Int_t)
@trydoc raw"""
    GetAxisName(this::ByConstRef1{TGeoTorus}, iaxis::Int32)::ByCopy{String}
Returns name of axis IAXIS.

""" GetAxisName(this::ByConstRef1{TGeoTorus}, iaxis::Int32)

# Wrapper of Double_t TGeoTorus::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoTorus}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoTorus}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoTorus::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoTorus}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2, dZ
""" GetBoundingCylinder(this::ByConstRef1{TGeoTorus}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoTorus::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoTorus})::Int32


""" GetByteCount(this::ByConstRef1{TGeoTorus})

# Wrapper of Double_t TGeoTorus::GetDphi()
@trydoc raw"""
    GetDphi(this::ByConstRef1{TGeoTorus})::Float64


""" GetDphi(this::ByConstRef1{TGeoTorus})

# Wrapper of TGeoShape * TGeoTorus::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoTorus}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
Create a shape fitting the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoTorus}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoTorus::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoTorus}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoTorus}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoTorus::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoTorus})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoTorus})

# Wrapper of Double_t TGeoTorus::GetPhi1()
@trydoc raw"""
    GetPhi1(this::ByConstRef1{TGeoTorus})::Float64


""" GetPhi1(this::ByConstRef1{TGeoTorus})

# Wrapper of Bool_t TGeoTorus::GetPointsOnSegments(Int_t, Double_t *)
@trydoc raw"""
    GetPointsOnSegments(this::ByConstRef1{TGeoTorus}, npoints::Int32, array::ByPtr2{Float64})::Bool
Fills array with n random points located on the line segments of the shape mesh.
The output array must be provided with a length of minimum 3*npoints. Returns true if operation is implemented.
""" GetPointsOnSegments(this::ByConstRef1{TGeoTorus}, npoints::Int32, array::ByPtr2{Float64})

# Wrapper of Double_t TGeoTorus::GetR()
@trydoc raw"""
    GetR(this::ByConstRef1{TGeoTorus})::Float64


""" GetR(this::ByConstRef1{TGeoTorus})

# Wrapper of Double_t TGeoTorus::GetRmax()
@trydoc raw"""
    GetRmax(this::ByConstRef1{TGeoTorus})::Float64


""" GetRmax(this::ByConstRef1{TGeoTorus})

# Wrapper of Double_t TGeoTorus::GetRmin()
@trydoc raw"""
    GetRmin(this::ByConstRef1{TGeoTorus})::Float64


""" GetRmin(this::ByConstRef1{TGeoTorus})

# Wrapper of void TGeoTorus::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoTorus})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoTorus})

# Wrapper of Bool_t TGeoTorus::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoTorus})::Bool


""" IsCylType(this::ByConstRef1{TGeoTorus})

# Wrapper of Double_t TGeoTorus::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoTorus}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoTorus::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoTorus}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoTorus::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTorus}, param::ByPtr2{Float64})::Nothing
Set torus dimensions starting from a list.

""" SetDimensions(this::ByRef1{TGeoTorus}, param::ByPtr2{Float64})

# Wrapper of void TGeoTorus::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTorus}, points::ByPtr2{Float64})::Nothing
Create torus mesh points.

""" SetPoints(this::ByConstRef1{TGeoTorus}, points::ByPtr2{Float64})

# Wrapper of void TGeoTorus::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTorus}, points::ByPtr2{Float32})::Nothing
Create torus mesh points.

""" SetPoints(this::ByConstRef1{TGeoTorus}, points::ByPtr2{Float32})

# Wrapper of void TGeoTorus::SetTorusDimensions(Double_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    SetTorusDimensions(this::ByRef1{TGeoTorus}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)::Nothing
Set torus dimensions.

""" SetTorusDimensions(this::ByRef1{TGeoTorus}, r::Float64, rmin::Float64, rmax::Float64, phi1::Float64, dphi::Float64)

# Wrapper of void TGeoTorus::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoTorus})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoTorus})

# Wrapper of Int_t TGeoTorus::SolveCubic(Double_t, Double_t, Double_t, Double_t *)
@trydoc raw"""
    SolveCubic(this::ByConstRef1{TGeoTorus}, a::Float64, b::Float64, c::Float64, x::ByPtr2{Float64})::Int32
Find real solutions of the cubic equation : x^3 + a*x^2 + b*x + c = 0 Input: a,b,c Output: x[3] real solutions Returns number of real solutions (1 or 3)

""" SolveCubic(this::ByConstRef1{TGeoTorus}, a::Float64, b::Float64, c::Float64, x::ByPtr2{Float64})

# Wrapper of Int_t TGeoTorus::SolveQuartic(Double_t, Double_t, Double_t, Double_t, Double_t *)
@trydoc raw"""
    SolveQuartic(this::ByConstRef1{TGeoTorus}, a::Float64, b::Float64, c::Float64, d::Float64, x::ByPtr2{Float64})::Int32
Find real solutions of the quartic equation : x^4 + a*x^3 + b*x^2 + c*x + d = 0 Input: a,b,c,d Output: x[4] - real solutions Returns number of real solutions (0 to 3)

""" SolveQuartic(this::ByConstRef1{TGeoTorus}, a::Float64, b::Float64, c::Float64, d::Float64, x::ByPtr2{Float64})

# Wrapper of Double_t TGeoTorus::ToBoundary(const Double_t *, const Double_t *, Double_t, Bool_t)
@trydoc raw"""
    ToBoundary(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, r::Float64, in::Bool)::Float64
Returns distance to the surface or the torus (fR,r) from a point, along a direction.
Point is close enough to the boundary so that the distance to the torus is decreasing while moving along the given direction.
""" ToBoundary(this::ByConstRef1{TGeoTorus}, pt::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, r::Float64, in::Bool)

# Wrapper of Double_t TGeoTrd1::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoTrd1})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoTrd1})

# Wrapper of void TGeoTrd1::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTrd1})::Nothing
compute bounding box for a trd1

""" ComputeBBox(this::ByRef1{TGeoTrd1})

# Wrapper of void TGeoTrd1::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoTrd1::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64})::Bool
test if point is inside this shape check Z range

""" Contains(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoTrd1::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Double_t TGeoTrd1::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the trd1 Boundary safe algorithm.

""" DistFromInside(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoTrd1::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the trd1 Boundary safe algorithm.

""" DistFromOutside(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoTrd1::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTrd1}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this trd1 shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Returns pointer to created division cell volume in case of Y divisions. For Z divisions just return the pointer to the volume to be divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTrd1}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoTrd1::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoTrd1}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoTrd1}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoTrd1::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoTrd1}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoTrd1}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoTrd1::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoTrd1})::Int32


""" GetByteCount(this::ByConstRef1{TGeoTrd1})

# Wrapper of Double_t TGeoTrd1::GetDx1()
@trydoc raw"""
    GetDx1(this::ByConstRef1{TGeoTrd1})::Float64


""" GetDx1(this::ByConstRef1{TGeoTrd1})

# Wrapper of Double_t TGeoTrd1::GetDx2()
@trydoc raw"""
    GetDx2(this::ByConstRef1{TGeoTrd1})::Float64


""" GetDx2(this::ByConstRef1{TGeoTrd1})

# Wrapper of Double_t TGeoTrd1::GetDy()
@trydoc raw"""
    GetDy(this::ByConstRef1{TGeoTrd1})::Float64


""" GetDy(this::ByConstRef1{TGeoTrd1})

# Wrapper of Double_t TGeoTrd1::GetDz()
@trydoc raw"""
    GetDz(this::ByConstRef1{TGeoTrd1})::Float64


""" GetDz(this::ByConstRef1{TGeoTrd1})

# Wrapper of Int_t TGeoTrd1::GetFittingBox(const TGeoBBox *, TGeoMatrix *, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetFittingBox(this::ByConstRef1{TGeoTrd1}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})::Int32
Fills real parameters of a positioned box inside this. Returns 0 if successful.

""" GetFittingBox(this::ByConstRef1{TGeoTrd1}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})

# Wrapper of TGeoShape * TGeoTrd1::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoTrd1}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoTrd1}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoTrd1::GetOppositeCorner(const Double_t *, Int_t, Double_t *, Double_t *)
@trydoc raw"""
    GetOppositeCorner(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, inorm::Int32, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})::Nothing
get the opposite corner of the intersected face

""" GetOppositeCorner(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, inorm::Int32, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::GetVisibleCorner(const Double_t *, Double_t *, Double_t *)
@trydoc raw"""
    GetVisibleCorner(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})::Nothing
get the most visible corner from outside point and the normals

""" GetVisibleCorner(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoTrd1})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoTrd1})

# Wrapper of Bool_t TGeoTrd1::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoTrd1})::Bool


""" IsCylType(this::ByConstRef1{TGeoTrd1})

# Wrapper of Double_t TGeoTrd1::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoTrd1}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoTrd1::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoTrd1}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoTrd1::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTrd1}, param::ByPtr2{Float64})::Nothing
set trd1 params in one step :

""" SetDimensions(this::ByRef1{TGeoTrd1}, param::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTrd1}, points::ByPtr2{Float64})::Nothing
create arb8 mesh points

""" SetPoints(this::ByConstRef1{TGeoTrd1}, points::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTrd1}, points::ByPtr2{Float32})::Nothing
create arb8 mesh points

""" SetPoints(this::ByConstRef1{TGeoTrd1}, points::ByPtr2{Float32})

# Wrapper of void TGeoTrd1::SetVertex(Double_t *)
@trydoc raw"""
    SetVertex(this::ByConstRef1{TGeoTrd1}, vertex::ByPtr2{Float64})::Nothing
set vertex of a corner according to visibility flags

""" SetVertex(this::ByConstRef1{TGeoTrd1}, vertex::ByPtr2{Float64})

# Wrapper of void TGeoTrd1::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoTrd1})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoTrd1})

# Wrapper of Double_t TGeoTrd2::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoTrd2})::Float64
Computes capacity of the shape in [length^3].

""" Capacity(this::ByConstRef1{TGeoTrd2})

# Wrapper of void TGeoTrd2::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoTrd2})::Nothing
compute bounding box for a trd2

""" ComputeBBox(this::ByRef1{TGeoTrd2})

# Wrapper of void TGeoTrd2::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoTrd2::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64})::Bool
test if point is inside this shape check Z range

""" Contains(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoTrd2::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of Double_t TGeoTrd2::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from inside point to surface of the trd2 Boundary safe algorithm.

""" DistFromInside(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoTrd2::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
Compute distance from outside point to surface of the trd2 Boundary safe algorithm.

""" DistFromOutside(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of TGeoVolume * TGeoTrd2::Divide(TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t)
@trydoc raw"""
    Divide(this::ByRef1{TGeoTrd2}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)::CxxPtr1{TGeoVolume}
Divide this trd2 shape belonging to volume "voldiv" into ndiv volumes called divname, from thestart position with the given step.
Only Z divisions are supported. For Z divisions just return the pointer to the volume to be divided. In case a wrong division axis is supplied, returns pointer to volume that was divided.
""" Divide(this::ByRef1{TGeoTrd2}, voldiv::ByPtr1{TGeoVolume}, divname::ByCopy{String}, iaxis::Int32, ndiv::Int32, thestart::Float64, step::Float64)

# Wrapper of Double_t TGeoTrd2::GetAxisRange(Int_t, Double_t &, Double_t &)
@trydoc raw"""
    GetAxisRange(this::ByConstRef1{TGeoTrd2}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})::Float64
Get range of shape for a given axis.

""" GetAxisRange(this::ByConstRef1{TGeoTrd2}, iaxis::Int32, xlo::ByRef2{Float64}, xhi::ByRef2{Float64})

# Wrapper of void TGeoTrd2::GetBoundingCylinder(Double_t *)
@trydoc raw"""
    GetBoundingCylinder(this::ByConstRef1{TGeoTrd2}, param::ByPtr2{Float64})::Nothing
Fill vector param[4] with the bounding cylinder parameters.
The order is the following : Rmin, Rmax, Phi1, Phi2
""" GetBoundingCylinder(this::ByConstRef1{TGeoTrd2}, param::ByPtr2{Float64})

# Wrapper of Int_t TGeoTrd2::GetByteCount()
@trydoc raw"""
    GetByteCount(this::ByConstRef1{TGeoTrd2})::Int32


""" GetByteCount(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoTrd2::GetDx1()
@trydoc raw"""
    GetDx1(this::ByConstRef1{TGeoTrd2})::Float64


""" GetDx1(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoTrd2::GetDx2()
@trydoc raw"""
    GetDx2(this::ByConstRef1{TGeoTrd2})::Float64


""" GetDx2(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoTrd2::GetDy1()
@trydoc raw"""
    GetDy1(this::ByConstRef1{TGeoTrd2})::Float64


""" GetDy1(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoTrd2::GetDy2()
@trydoc raw"""
    GetDy2(this::ByConstRef1{TGeoTrd2})::Float64


""" GetDy2(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoTrd2::GetDz()
@trydoc raw"""
    GetDz(this::ByConstRef1{TGeoTrd2})::Float64


""" GetDz(this::ByConstRef1{TGeoTrd2})

# Wrapper of Int_t TGeoTrd2::GetFittingBox(const TGeoBBox *, TGeoMatrix *, Double_t &, Double_t &, Double_t &)
@trydoc raw"""
    GetFittingBox(this::ByConstRef1{TGeoTrd2}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})::Int32
Fills real parameters of a positioned box inside this. Returns 0 if successful.

""" GetFittingBox(this::ByConstRef1{TGeoTrd2}, parambox::ByConstPtr1{TGeoBBox}, mat::ByPtr1{TGeoMatrix}, dx::ByRef2{Float64}, dy::ByRef2{Float64}, dz::ByRef2{Float64})

# Wrapper of TGeoShape * TGeoTrd2::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoTrd2}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
in case shape has some negative parameters, these has to be computed in order to fit the mother

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoTrd2}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoTrd2::GetOppositeCorner(const Double_t *, Int_t, Double_t *, Double_t *)
@trydoc raw"""
    GetOppositeCorner(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, inorm::Int32, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})::Nothing
get the opposite corner of the intersected face

""" GetOppositeCorner(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, inorm::Int32, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::GetVisibleCorner(const Double_t *, Double_t *, Double_t *)
@trydoc raw"""
    GetVisibleCorner(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})::Nothing
get the most visible corner from outside point and the normals

""" GetVisibleCorner(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, vertex::ByPtr2{Float64}, normals::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoTrd2})::Nothing
print shape parameters

""" InspectShape(this::ByConstRef1{TGeoTrd2})

# Wrapper of Bool_t TGeoTrd2::IsCylType()
@trydoc raw"""
    IsCylType(this::ByConstRef1{TGeoTrd2})::Bool


""" IsCylType(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoTrd2::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint.
""" Safety(this::ByConstRef1{TGeoTrd2}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoTrd2::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoTrd2}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoTrd2::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoTrd2}, param::ByPtr2{Float64})::Nothing
set arb8 params in one step :

""" SetDimensions(this::ByRef1{TGeoTrd2}, param::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTrd2}, points::ByPtr2{Float64})::Nothing
create trd2 mesh points

""" SetPoints(this::ByConstRef1{TGeoTrd2}, points::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoTrd2}, points::ByPtr2{Float32})::Nothing
create trd2 mesh points

""" SetPoints(this::ByConstRef1{TGeoTrd2}, points::ByPtr2{Float32})

# Wrapper of void TGeoTrd2::SetVertex(Double_t *)
@trydoc raw"""
    SetVertex(this::ByConstRef1{TGeoTrd2}, vertex::ByPtr2{Float64})::Nothing
set vertex of a corner according to visibility flags

""" SetVertex(this::ByConstRef1{TGeoTrd2}, vertex::ByPtr2{Float64})

# Wrapper of void TGeoTrd2::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoTrd2})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoTrd2})

# Wrapper of Double_t TGeoXtru::Capacity()
@trydoc raw"""
    Capacity(this::ByConstRef1{TGeoXtru})::Float64
Compute capacity [length^3] of this shape.

""" Capacity(this::ByConstRef1{TGeoXtru})

# Wrapper of void TGeoXtru::ClearThreadData()
@trydoc raw"""
    ClearThreadData(this::ByConstRef1{TGeoXtru})::Nothing


""" ClearThreadData(this::ByConstRef1{TGeoXtru})

# Wrapper of void TGeoXtru::ComputeBBox()
@trydoc raw"""
    ComputeBBox(this::ByRef1{TGeoXtru})::Nothing
compute bounding box of the pcon

""" ComputeBBox(this::ByRef1{TGeoXtru})

# Wrapper of void TGeoXtru::ComputeNormal(const Double_t *, const Double_t *, Double_t *)
@trydoc raw"""
    ComputeNormal(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})::Nothing
Compute normal to closest surface from POINT.

""" ComputeNormal(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, norm::ByPtr2{Float64})

# Wrapper of void TGeoXtru::ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)
@trydoc raw"""
    ComputeNormal_v(this::ByRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions.

""" ComputeNormal_v(this::ByRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, norms::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of Bool_t TGeoXtru::Contains(const Double_t *)
@trydoc raw"""
    Contains(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64})::Bool
test if point is inside this shape

""" Contains(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64})

# Wrapper of void TGeoXtru::Contains_v(const Double_t *, Bool_t *, Int_t)
@trydoc raw"""
    Contains_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)::Nothing
Check the inside status for each of the points in the array.
Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point
""" Contains_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, inside::ByPtr2{Bool}, vecsize::Int32)

# Wrapper of void TGeoXtru::CreateThreadData(Int_t)
@trydoc raw"""
    CreateThreadData(this::ByRef1{TGeoXtru}, nthreads::Int32)::Nothing
Create thread data for n threads max.

""" CreateThreadData(this::ByRef1{TGeoXtru}, nthreads::Int32)

# Wrapper of Bool_t TGeoXtru::DefinePolygon(Int_t, const Double_t *, const Double_t *)
@trydoc raw"""
    DefinePolygon(this::ByRef1{TGeoXtru}, nvert::Int32, xv::ByConstPtr2{Float64}, yv::ByConstPtr2{Float64})::Bool
Creates the polygon representing the blueprint of any Xtru section.
- nvert = number of vertices >2
- xv[nvert] = array of X vertex positions
- yv[nvert] = array of Y vertex positions

*NOTE* should be called before DefineSection or ctor with 'param'
""" DefinePolygon(this::ByRef1{TGeoXtru}, nvert::Int32, xv::ByConstPtr2{Float64}, yv::ByConstPtr2{Float64})

# Wrapper of void TGeoXtru::DefineSection(Int_t, Double_t, Double_t, Double_t, Double_t)
@trydoc raw"""
    DefineSection(this::ByRef1{TGeoXtru}, snum::Int32, z::Float64, x0::Float64, y0::Float64, scale::Float64)::Nothing
defines z position of a section plane, rmin and rmax at this z.

""" DefineSection(this::ByRef1{TGeoXtru}, snum::Int32, z::Float64, x0::Float64, y0::Float64, scale::Float64)

# Wrapper of Int_t TGeoXtru::DistancetoPrimitive(Int_t, Int_t)
@trydoc raw"""
    DistancetoPrimitive(this::ByRef1{TGeoXtru}, px::Int32, py::Int32)::Int32
compute closest distance from point px,py to each corner

""" DistancetoPrimitive(this::ByRef1{TGeoXtru}, px::Int32, py::Int32)

# Wrapper of Double_t TGeoXtru::DistFromInside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromInside(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from inside point to surface of the polycone locate Z segment

""" DistFromInside(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoXtru::DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromInside_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromInside_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of Double_t TGeoXtru::DistFromOutside(const Double_t *, const Double_t *, Int_t, Double_t, Double_t *)
@trydoc raw"""
    DistFromOutside(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})::Float64
compute distance from outside point to surface of the tube Warning("DistFromOutside", "not implemented");

""" DistFromOutside(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, dir::ByConstPtr2{Float64}, iact::Int32, step::Float64, safe::ByPtr2{Float64})

# Wrapper of void TGeoXtru::DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *)
@trydoc raw"""
    DistFromOutside_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})::Nothing
Compute distance from array of input points having directions specified by dirs. Store output in dists.

""" DistFromOutside_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, dirs::ByConstPtr2{Float64}, dists::ByPtr2{Float64}, vecsize::Int32, step::ByPtr2{Float64})

# Wrapper of void TGeoXtru::DrawPolygon(Option_t *)
@trydoc raw"""
    DrawPolygon(this::ByRef1{TGeoXtru}, option::ByCopy{String})::Nothing
Draw the section polygon.

""" DrawPolygon(this::ByRef1{TGeoXtru}, option::ByCopy{String})

# Wrapper of TGeoShape * TGeoXtru::GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *)
@trydoc raw"""
    GetMakeRuntimeShape(this::ByConstRef1{TGeoXtru}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})::CxxPtr1{TGeoShape}
In case shape has some negative parameters, these has to be computed in order to fit the mother.

""" GetMakeRuntimeShape(this::ByConstRef1{TGeoXtru}, mother::ByPtr1{TGeoShape}, mat::ByPtr1{TGeoMatrix})

# Wrapper of void TGeoXtru::GetMeshNumbers(Int_t &, Int_t &, Int_t &)
@trydoc raw"""
    GetMeshNumbers(this::ByConstRef1{TGeoXtru}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})::Nothing
Returns numbers of vertices, segments and polygons composing the shape mesh.

""" GetMeshNumbers(this::ByConstRef1{TGeoXtru}, nvert::ByRef2{Int32}, nsegs::ByRef2{Int32}, npols::ByRef2{Int32})

# Wrapper of Int_t TGeoXtru::GetNmeshVertices()
@trydoc raw"""
    GetNmeshVertices(this::ByConstRef1{TGeoXtru})::Int32
Return number of vertices of the mesh representation.

""" GetNmeshVertices(this::ByConstRef1{TGeoXtru})

# Wrapper of Int_t TGeoXtru::GetNvert()
@trydoc raw"""
    GetNvert(this::ByConstRef1{TGeoXtru})::Int32


""" GetNvert(this::ByConstRef1{TGeoXtru})

# Wrapper of Int_t TGeoXtru::GetNz()
@trydoc raw"""
    GetNz(this::ByConstRef1{TGeoXtru})::Int32


""" GetNz(this::ByConstRef1{TGeoXtru})

# Wrapper of Double_t TGeoXtru::GetScale(Int_t)
@trydoc raw"""
    GetScale(this::ByConstRef1{TGeoXtru}, i::Int32)::Float64


""" GetScale(this::ByConstRef1{TGeoXtru}, i::Int32)

# Wrapper of Double_t TGeoXtru::GetX(Int_t)
@trydoc raw"""
    GetX(this::ByConstRef1{TGeoXtru}, i::Int32)::Float64


""" GetX(this::ByConstRef1{TGeoXtru}, i::Int32)

# Wrapper of Double_t TGeoXtru::GetXOffset(Int_t)
@trydoc raw"""
    GetXOffset(this::ByConstRef1{TGeoXtru}, i::Int32)::Float64


""" GetXOffset(this::ByConstRef1{TGeoXtru}, i::Int32)

# Wrapper of Double_t TGeoXtru::GetY(Int_t)
@trydoc raw"""
    GetY(this::ByConstRef1{TGeoXtru}, i::Int32)::Float64


""" GetY(this::ByConstRef1{TGeoXtru}, i::Int32)

# Wrapper of Double_t TGeoXtru::GetYOffset(Int_t)
@trydoc raw"""
    GetYOffset(this::ByConstRef1{TGeoXtru}, i::Int32)::Float64


""" GetYOffset(this::ByConstRef1{TGeoXtru}, i::Int32)

# Wrapper of Double_t * TGeoXtru::GetZ()
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoXtru})::CxxPtr2{Float64}


""" GetZ(this::ByConstRef1{TGeoXtru})

# Wrapper of Double_t TGeoXtru::GetZ(Int_t)
@trydoc raw"""
    GetZ(this::ByConstRef1{TGeoXtru}, ipl::Int32)::Float64
Return the Z coordinate for segment ipl.

""" GetZ(this::ByConstRef1{TGeoXtru}, ipl::Int32)

# Wrapper of void TGeoXtru::InspectShape()
@trydoc raw"""
    InspectShape(this::ByConstRef1{TGeoXtru})::Nothing
Print actual Xtru parameters.

""" InspectShape(this::ByConstRef1{TGeoXtru})

# Wrapper of Double_t TGeoXtru::Safety(const Double_t *, Bool_t)
@trydoc raw"""
    Safety(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, in::Bool)::Float64
computes the closest distance from given point to this shape, according to option.
The matching point on the shape is stored in spoint. 

>localize the Z segment
""" Safety(this::ByConstRef1{TGeoXtru}, point::ByConstPtr2{Float64}, in::Bool)

# Wrapper of void TGeoXtru::Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t)
@trydoc raw"""
    Safety_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)::Nothing
Compute safe distance from each of the points in the input array.
Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values
""" Safety_v(this::ByConstRef1{TGeoXtru}, points::ByConstPtr2{Float64}, inside::ByConstPtr2{Bool}, safe::ByPtr2{Float64}, vecsize::Int32)

# Wrapper of void TGeoXtru::SetCurrentVertices(Double_t, Double_t, Double_t)
@trydoc raw"""
    SetCurrentVertices(this::ByRef1{TGeoXtru}, x0::Float64, y0::Float64, scale::Float64)::Nothing
Set current vertex coordinates according X0, Y0 and SCALE.

""" SetCurrentVertices(this::ByRef1{TGeoXtru}, x0::Float64, y0::Float64, scale::Float64)

# Wrapper of void TGeoXtru::SetCurrentZ(Double_t, Int_t)
@trydoc raw"""
    SetCurrentZ(this::ByRef1{TGeoXtru}, z::Float64, iz::Int32)::Nothing
Recompute current section vertices for a given Z position within range of section iz.

""" SetCurrentZ(this::ByRef1{TGeoXtru}, z::Float64, iz::Int32)

# Wrapper of void TGeoXtru::SetDimensions(Double_t *)
@trydoc raw"""
    SetDimensions(this::ByRef1{TGeoXtru}, param::ByPtr2{Float64})::Nothing

- param[0] = nz // number of z planes
- param[1] = z1 // Z position of first plane
- param[2] = x1 // X position of first plane
- param[3] = y1 // Y position of first plane
- param[4] = scale1 // scale factor for first plane ...
- param[4*(nz-1]+1] = zn
- param[4*(nz-1)+2] = xn
- param[4*(nz-1)+3] = yn
- param[4*(nz-1)+4] = scalen
""" SetDimensions(this::ByRef1{TGeoXtru}, param::ByPtr2{Float64})

# Wrapper of void TGeoXtru::SetPoints(Double_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoXtru}, points::ByPtr2{Float64})::Nothing
create polycone mesh points

""" SetPoints(this::ByConstRef1{TGeoXtru}, points::ByPtr2{Float64})

# Wrapper of void TGeoXtru::SetPoints(Float_t *)
@trydoc raw"""
    SetPoints(this::ByConstRef1{TGeoXtru}, points::ByPtr2{Float32})::Nothing
create polycone mesh points

""" SetPoints(this::ByConstRef1{TGeoXtru}, points::ByPtr2{Float32})

# Wrapper of void TGeoXtru::Sizeof3D()
@trydoc raw"""
    Sizeof3D(this::ByConstRef1{TGeoXtru})::Nothing
fill size of this 3-D object

""" Sizeof3D(this::ByConstRef1{TGeoXtru})

# Wrapper of Double_t & TGeoXtru::Z(Int_t)
@trydoc raw"""
    Z(this::ByRef1{TGeoXtru}, ipl::Int32)::CxxRef2{Float64}


""" Z(this::ByRef1{TGeoXtru}, ipl::Int32)
#
######################################################################
